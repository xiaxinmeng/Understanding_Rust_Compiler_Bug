{"sha": "235938d1acdd93d6641a741c81f64e415b786751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNTkzOGQxYWNkZDkzZDY2NDFhNzQxYzgxZjY0ZTQxNWI3ODY3NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-01T14:21:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-01T14:21:31Z"}, "message": "Auto merge of #70653 - Centril:rollup-vh5x5e5, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #70511 (Add `-Z dump-mir-dataflow` flag for dumping dataflow results visualization)\n - #70522 (Improve error messages for raw strings (#60762))\n - #70547 (Add `can_unwind` field to `FnAbi`)\n - #70591 (Ensure LLVM is in the link path for \"fulldeps\" tests)\n - #70627 (Use place directly its copy)\n - #70652 (Add git repo address to unstable book)\n\nFailed merges:\n\n - #70634 (Remove some reexports in `rustc_middle`)\n\nr? @ghost", "tree": {"sha": "175a4a3534196b2226fe3978dc7b9953f4ab30d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/175a4a3534196b2226fe3978dc7b9953f4ab30d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/235938d1acdd93d6641a741c81f64e415b786751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/235938d1acdd93d6641a741c81f64e415b786751", "html_url": "https://github.com/rust-lang/rust/commit/235938d1acdd93d6641a741c81f64e415b786751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/235938d1acdd93d6641a741c81f64e415b786751/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99009bf31992fb9257b84550dbf7cb509f987952", "url": "https://api.github.com/repos/rust-lang/rust/commits/99009bf31992fb9257b84550dbf7cb509f987952", "html_url": "https://github.com/rust-lang/rust/commit/99009bf31992fb9257b84550dbf7cb509f987952"}, {"sha": "c1419b4c919fcdb91205b32a6ccca7b170b1e58a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1419b4c919fcdb91205b32a6ccca7b170b1e58a", "html_url": "https://github.com/rust-lang/rust/commit/c1419b4c919fcdb91205b32a6ccca7b170b1e58a"}], "stats": {"total": 1366, "additions": 852, "deletions": 514}, "files": [{"sha": "2499856235f100b6b03a9bed6fcf2f8624d87eac", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -21,7 +21,7 @@ use crate::flags::Subcommand;\n use crate::native;\n use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n-use crate::util::{self, dylib_path, dylib_path_var};\n+use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var};\n use crate::Crate as CargoCrate;\n use crate::{envify, DocTests, GitRepo, Mode};\n \n@@ -1178,6 +1178,15 @@ impl Step for Compiletest {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n+            // Tests that use compiler libraries may inherit the `-lLLVM` link\n+            // requirement, but the `-L` library path is not propagated across\n+            // separate compilations. We can add LLVM's library path to the\n+            // platform-specific environment variable as a workaround.\n+            if !builder.config.dry_run && suite.ends_with(\"fulldeps\") {\n+                let llvm_libdir = output(Command::new(&llvm_config).arg(\"--libdir\"));\n+                add_link_lib_path(vec![llvm_libdir.trim().into()], &mut cmd);\n+            }\n+\n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {"}, {"sha": "0cd56d0940451ab40a0391c193c685e7b333342c", "filename": "src/doc/unstable-book/book.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Fdoc%2Funstable-book%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Fdoc%2Funstable-book%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fbook.toml?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -1,3 +1,6 @@\n [book]\n title = \"The Rust Unstable Book\"\n author = \"The Rust Community\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book\""}, {"sha": "064ca53bd1bd1ad1a2868b962f3293de098f8228", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -396,6 +396,11 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n         }\n \n+        // FIXME(eddyb, wesleywiser): apply this to callsites as well?\n+        if !self.can_unwind {\n+            llvm::Attribute::NoUnwind.apply_llfn(llvm::AttributePlace::Function, llfn);\n+        }\n+\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);\n@@ -431,6 +436,8 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     }\n \n     fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n+        // FIXME(wesleywiser, eddyb): We should apply `nounwind` and `noreturn` as appropriate to this callsite.\n+\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite, ty);"}, {"sha": "784a3a87e98852980b52d304ee927e2f85a6b620", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 56, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -10,13 +10,10 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::{OptLevel, Sanitizer};\n use rustc_session::Session;\n-use rustc_target::abi::call::Conv;\n-use rustc_target::spec::PanicStrategy;\n \n-use crate::abi::FnAbi;\n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n use crate::llvm::{self, Attribute};\n@@ -77,12 +74,6 @@ pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n     Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n-/// Tell LLVM whether the function can or cannot unwind.\n-#[inline]\n-fn unwind(val: &'ll Value, can_unwind: bool) {\n-    Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n-}\n-\n /// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n fn naked(val: &'ll Value, is_naked: bool) {\n@@ -246,12 +237,7 @@ pub(crate) fn default_optimisation_attrs(sess: &Session, llfn: &'ll Value) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (`#[attribute]`)\n /// attributes.\n-pub fn from_fn_attrs(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    llfn: &'ll Value,\n-    instance: ty::Instance<'tcx>,\n-    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n-) {\n+pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::Instance<'tcx>) {\n     let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n \n     match codegen_fn_attrs.optimize {\n@@ -315,46 +301,6 @@ pub fn from_fn_attrs(\n     }\n     sanitize(cx, codegen_fn_attrs.flags, llfn);\n \n-    unwind(\n-        llfn,\n-        if cx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-            // In panic=abort mode we assume nothing can unwind anywhere, so\n-            // optimize based on this!\n-            false\n-        } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n-            // If a specific #[unwind] attribute is present, use that.\n-            true\n-        } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n-            // Special attribute for allocator functions, which can't unwind.\n-            false\n-        } else {\n-            if fn_abi.conv == Conv::Rust {\n-                // Any Rust method (or `extern \"Rust\" fn` or `extern\n-                // \"rust-call\" fn`) is explicitly allowed to unwind\n-                // (unless it has no-unwind attribute, handled above).\n-                true\n-            } else {\n-                // Anything else is either:\n-                //\n-                //  1. A foreign item using a non-Rust ABI (like `extern \"C\" { fn foo(); }`), or\n-                //\n-                //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n-                //\n-                // Foreign items (case 1) are assumed to not unwind; it is\n-                // UB otherwise. (At least for now; see also\n-                // rust-lang/rust#63909 and Rust RFC 2753.)\n-                //\n-                // Items defined in Rust with non-Rust ABIs (case 2) are also\n-                // not supposed to unwind. Whether this should be enforced\n-                // (versus stating it is UB) and *how* it would be enforced\n-                // is currently under discussion; see rust-lang/rust#58794.\n-                //\n-                // In either case, we mark item as explicitly nounwind.\n-                false\n-            }\n-        },\n-    );\n-\n     // Always annotate functions with the target-cpu they are compiled for.\n     // Without this, ThinLTO won't inline Rust functions into Clang generated\n     // functions (because Clang annotates functions this way too)."}, {"sha": "a36314448b170b82734ee9fb8ad58101598d2d43", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -78,7 +78,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n         let llfn = cx.declare_fn(&sym, &fn_abi);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        attributes::from_fn_attrs(cx, llfn, instance, &fn_abi);\n+        attributes::from_fn_attrs(cx, llfn, instance);\n \n         let instance_def_id = instance.def_id();\n "}, {"sha": "a7a9d0c8a075994c496a963f312c7ab8036e3422", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -77,7 +77,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         debug!(\"predefine_fn: instance = {:?}\", instance);\n \n-        attributes::from_fn_attrs(self, lldecl, instance, &fn_abi);\n+        attributes::from_fn_attrs(self, lldecl, instance);\n \n         self.instances.borrow_mut().insert(instance, lldecl);\n     }"}, {"sha": "931fab6ae01da93a013d8a1baaee9cf4a65dc327", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,\n         mut bx: Bx,\n-        location: &mir::Place<'tcx>,\n+        location: mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n@@ -580,7 +580,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic == Some(\"transmute\") {\n             if let Some(destination_ref) = destination.as_ref() {\n-                let &(ref dest, target) = destination_ref;\n+                let &(dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n                 helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n@@ -619,7 +619,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let mut llargs = Vec::with_capacity(arg_count);\n \n         // Prepare the return value destination\n-        let ret_dest = if let Some((ref dest, _)) = *destination {\n+        let ret_dest = if let Some((dest, _)) = *destination {\n             let is_intrinsic = intrinsic.is_some();\n             self.make_return_dest(&mut bx, dest, &fn_abi.ret, &mut llargs, is_intrinsic)\n         } else {\n@@ -873,7 +873,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.unreachable();\n             }\n \n-            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+            mir::TerminatorKind::Drop { location, target, unwind } => {\n                 self.codegen_drop_terminator(helper, bx, location, target, unwind);\n             }\n \n@@ -1123,7 +1123,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn make_return_dest(\n         &mut self,\n         bx: &mut Bx,\n-        dest: &mir::Place<'tcx>,\n+        dest: mir::Place<'tcx>,\n         fn_ret: &ArgAbi<'tcx, Ty<'tcx>>,\n         llargs: &mut Vec<Bx::Value>,\n         is_intrinsic: bool,\n@@ -1184,7 +1184,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &mut Bx, src: &mir::Operand<'tcx>, dst: &mir::Place<'tcx>) {\n+    fn codegen_transmute(&mut self, bx: &mut Bx, src: &mir::Operand<'tcx>, dst: mir::Place<'tcx>) {\n         if let Some(index) = dst.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),"}, {"sha": "ce681c729b2b5ec553ffc23762d362d9fd99b01b", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (bx, OperandRef { val, layout: cast })\n             }\n \n-            mir::Rvalue::Ref(_, bk, ref place) => {\n+            mir::Rvalue::Ref(_, bk, place) => {\n                 let mk_ref = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| {\n                     tcx.mk_ref(\n                         tcx.lifetimes.re_erased,\n@@ -393,14 +393,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_place_to_pointer(bx, place, mk_ref)\n             }\n \n-            mir::Rvalue::AddressOf(mutability, ref place) => {\n+            mir::Rvalue::AddressOf(mutability, place) => {\n                 let mk_ptr = move |tcx: TyCtxt<'tcx>, ty: Ty<'tcx>| {\n                     tcx.mk_ptr(ty::TypeAndMut { ty, mutbl: mutability })\n                 };\n                 self.codegen_place_to_pointer(bx, place, mk_ptr)\n             }\n \n-            mir::Rvalue::Len(ref place) => {\n+            mir::Rvalue::Len(place) => {\n                 let size = self.evaluate_array_len(&mut bx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n@@ -537,7 +537,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn evaluate_array_len(&mut self, bx: &mut Bx, place: &mir::Place<'tcx>) -> Bx::Value {\n+    fn evaluate_array_len(&mut self, bx: &mut Bx, place: mir::Place<'tcx>) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let Some(index) = place.as_local() {\n@@ -557,7 +557,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn codegen_place_to_pointer(\n         &mut self,\n         mut bx: Bx,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         mk_ptr_ty: impl FnOnce(TyCtxt<'tcx>, Ty<'tcx>) -> Ty<'tcx>,\n     ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n         let cg_place = self.codegen_place(&mut bx, place.as_ref());"}, {"sha": "f58c5cc8eeb8a495cc0d0f45a524c2e51cff3b0f", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -562,6 +562,8 @@ fn test_debugging_options_tracking_hash() {\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n     opts.debugging_opts.dump_mir_graphviz = true;\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir_dataflow = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n     // Make sure changing a [TRACKED] option changes the hash\n     opts = reference.clone();"}, {"sha": "fcb7475cc2e89890d16bc92bce45a5a1af21ec53", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 124, "deletions": 22, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -17,9 +17,13 @@\n mod cursor;\n pub mod unescape;\n \n+#[cfg(test)]\n+mod tests;\n+\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::{Cursor, EOF_CHAR};\n+use std::convert::TryInto;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -132,9 +136,80 @@ pub enum LiteralKind {\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\"\n-    RawStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawStr(UnvalidatedRawStr),\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n-    RawByteStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawByteStr(UnvalidatedRawStr),\n+}\n+\n+/// Represents something that looks like a raw string, but may have some\n+/// problems. Use `.validate()` to convert it into something\n+/// usable.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct UnvalidatedRawStr {\n+    /// The prefix (`r###\"`) is valid\n+    valid_start: bool,\n+    /// The number of leading `#`\n+    n_start_hashes: usize,\n+    /// The number of trailing `#`. `n_end_hashes` <= `n_start_hashes`\n+    n_end_hashes: usize,\n+    /// The offset starting at `r` or `br` where the user may have intended to end the string.\n+    /// Currently, it is the longest sequence of pattern `\"#+\"`.\n+    possible_terminator_offset: Option<usize>,\n+}\n+\n+/// Error produced validating a raw string. Represents cases like:\n+/// - `r##~\"abcde\"##`: `LexRawStrError::InvalidStarter`\n+/// - `r###\"abcde\"##`: `LexRawStrError::NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n+/// - Too many `#`s (>65536): `TooManyDelimiters`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum LexRawStrError {\n+    /// Non `#` characters exist between `r` and `\"` eg. `r#~\"..`\n+    InvalidStarter,\n+    /// The string was never terminated. `possible_terminator_offset` is the number of characters after `r` or `br` where they\n+    /// may have intended to terminate it.\n+    NoTerminator { expected: usize, found: usize, possible_terminator_offset: Option<usize> },\n+    /// More than 65536 `#`s exist.\n+    TooManyDelimiters,\n+}\n+\n+/// Raw String that contains a valid prefix (`#+\"`) and postfix (`\"#+`) where\n+/// there are a matching number of `#` characters in both. Note that this will\n+/// not consume extra trailing `#` characters: `r###\"abcde\"####` is lexed as a\n+/// `ValidatedRawString { n_hashes: 3 }` followed by a `#` token.\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+pub struct ValidatedRawStr {\n+    n_hashes: u16,\n+}\n+\n+impl ValidatedRawStr {\n+    pub fn num_hashes(&self) -> u16 {\n+        self.n_hashes\n+    }\n+}\n+\n+impl UnvalidatedRawStr {\n+    pub fn validate(self) -> Result<ValidatedRawStr, LexRawStrError> {\n+        if !self.valid_start {\n+            return Err(LexRawStrError::InvalidStarter);\n+        }\n+\n+        // Only up to 65535 `#`s are allowed in raw strings\n+        let n_start_safe: u16 =\n+            self.n_start_hashes.try_into().map_err(|_| LexRawStrError::TooManyDelimiters)?;\n+\n+        if self.n_start_hashes > self.n_end_hashes {\n+            Err(LexRawStrError::NoTerminator {\n+                expected: self.n_start_hashes,\n+                found: self.n_end_hashes,\n+                possible_terminator_offset: self.possible_terminator_offset,\n+            })\n+        } else {\n+            // Since the lexer should never produce a literal with n_end > n_start, if n_start <= n_end,\n+            // they must be equal.\n+            debug_assert_eq!(self.n_start_hashes, self.n_end_hashes);\n+            Ok(ValidatedRawStr { n_hashes: n_start_safe })\n+        }\n+    }\n }\n \n /// Base of numeric literal encoding according to its prefix.\n@@ -209,7 +284,7 @@ pub fn is_whitespace(c: char) -> bool {\n         // Dedicated whitespace characters from Unicode\n         | '\\u{2028}' // LINE SEPARATOR\n         | '\\u{2029}' // PARAGRAPH SEPARATOR\n-            => true,\n+        => true,\n         _ => false,\n     }\n }\n@@ -258,12 +333,12 @@ impl Cursor<'_> {\n             'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(1);\n                     let suffix_start = self.len_consumed();\n-                    if terminated {\n+                    if raw_str_i.n_end_hashes == raw_str_i.n_start_hashes {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawStr { n_hashes, started, terminated };\n+                    let kind = RawStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -293,12 +368,14 @@ impl Cursor<'_> {\n                 }\n                 ('r', '\"') | ('r', '#') => {\n                     self.bump();\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(2);\n                     let suffix_start = self.len_consumed();\n+                    let terminated = raw_str_i.n_start_hashes == raw_str_i.n_end_hashes;\n                     if terminated {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawByteStr { n_hashes, started, terminated };\n+\n+                    let kind = RawByteStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -594,37 +671,49 @@ impl Cursor<'_> {\n         false\n     }\n \n-    /// Eats the double-quoted string and returns a tuple of\n-    /// (amount of the '#' symbols, raw string started, raw string terminated)\n-    fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n+    /// Eats the double-quoted string and returns an `UnvalidatedRawStr`.\n+    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> UnvalidatedRawStr {\n         debug_assert!(self.prev() == 'r');\n-        let mut started: bool = false;\n-        let mut finished: bool = false;\n+        let mut valid_start: bool = false;\n+        let start_pos = self.len_consumed();\n+        let (mut possible_terminator_offset, mut max_hashes) = (None, 0);\n \n         // Count opening '#' symbols.\n-        let n_hashes = self.eat_while(|c| c == '#');\n+        let n_start_hashes = self.eat_while(|c| c == '#');\n \n         // Check that string is started.\n         match self.bump() {\n-            Some('\"') => started = true,\n-            _ => return (n_hashes, started, finished),\n+            Some('\"') => valid_start = true,\n+            _ => {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes: 0,\n+                    possible_terminator_offset,\n+                };\n+            }\n         }\n \n         // Skip the string contents and on each '#' character met, check if this is\n         // a raw string termination.\n-        while !finished {\n+        loop {\n             self.eat_while(|c| c != '\"');\n \n             if self.is_eof() {\n-                return (n_hashes, started, finished);\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes: max_hashes,\n+                    possible_terminator_offset,\n+                };\n             }\n \n             // Eat closing double quote.\n             self.bump();\n \n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n-            let mut hashes_left = n_hashes;\n+            let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n                 if c == '#' && hashes_left != 0 {\n                     hashes_left -= 1;\n@@ -633,10 +722,23 @@ impl Cursor<'_> {\n                     false\n                 }\n             };\n-            finished = self.eat_while(is_closing_hash) == n_hashes;\n+            let n_end_hashes = self.eat_while(is_closing_hash);\n+\n+            if n_end_hashes == n_start_hashes {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes,\n+                    possible_terminator_offset: None,\n+                };\n+            } else if n_end_hashes > max_hashes {\n+                // Keep track of possible terminators to give a hint about where there might be\n+                // a missing terminator\n+                possible_terminator_offset =\n+                    Some(self.len_consumed() - start_pos - n_end_hashes + prefix_len);\n+                max_hashes = n_end_hashes;\n+            }\n         }\n-\n-        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {"}, {"sha": "4af435536f011d9f85912f6a58d4fd6170732313", "filename": "src/librustc_lexer/src/tests.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -0,0 +1,121 @@\n+#[cfg(test)]\n+mod tests {\n+    use crate::*;\n+\n+    fn check_raw_str(\n+        s: &str,\n+        expected: UnvalidatedRawStr,\n+        validated: Result<ValidatedRawStr, LexRawStrError>,\n+    ) {\n+        let s = &format!(\"r{}\", s);\n+        let mut cursor = Cursor::new(s);\n+        cursor.bump();\n+        let tok = cursor.raw_double_quoted_string(0);\n+        assert_eq!(tok, expected);\n+        assert_eq!(tok.validate(), validated);\n+    }\n+\n+    #[test]\n+    fn test_naked_raw_str() {\n+        check_raw_str(\n+            r#\"\"abc\"\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_raw_no_start() {\n+        check_raw_str(\n+            r##\"\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_too_many_terminators() {\n+        // this error is handled in the parser later\n+        check_raw_str(\n+            r###\"#\"abc\"##\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 1 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unterminated() {\n+        check_raw_str(\n+            r#\"#\"abc\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 1,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        );\n+        check_raw_str(\n+            r###\"##\"abc\"#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                possible_terminator_offset: Some(7),\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 1,\n+                possible_terminator_offset: Some(7),\n+            }),\n+        );\n+        // We're looking for \"# not just any #\n+        check_raw_str(\n+            r###\"##\"abc#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        )\n+    }\n+\n+    #[test]\n+    fn test_invalid_start() {\n+        check_raw_str(\n+            r##\"#~\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: false,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::InvalidStarter),\n+        );\n+    }\n+}"}, {"sha": "216fe43e819976fa30cf73fb56af60efbcb6b511", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -2030,9 +2030,9 @@ impl<'tcx> Operand<'tcx> {\n \n     /// Returns the `Place` that is the target of this `Operand`, or `None` if this `Operand` is a\n     /// constant.\n-    pub fn place(&self) -> Option<&Place<'tcx>> {\n+    pub fn place(&self) -> Option<Place<'tcx>> {\n         match self {\n-            Operand::Copy(place) | Operand::Move(place) => Some(place),\n+            Operand::Copy(place) | Operand::Move(place) => Some(*place),\n             Operand::Constant(_) => None,\n         }\n     }"}, {"sha": "17c93922b0023a7191d5d192371e0ba4832e3fe2", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -1,4 +1,5 @@\n use crate::ich::StableHashingContext;\n+use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n use crate::ty::subst::Subst;\n use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n@@ -15,7 +16,7 @@ use rustc_target::abi::call::{\n     ArgAbi, ArgAttribute, ArgAttributes, Conv, FnAbi, PassMode, Reg, RegKind,\n };\n pub use rustc_target::abi::*;\n-use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec};\n+use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy};\n \n use std::cmp;\n use std::fmt;\n@@ -2368,11 +2369,55 @@ where\n         sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n+        codegen_fn_attr_flags: CodegenFnAttrFlags,\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self;\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n \n+fn fn_can_unwind(\n+    panic_strategy: PanicStrategy,\n+    codegen_fn_attr_flags: CodegenFnAttrFlags,\n+    call_conv: Conv,\n+) -> bool {\n+    if panic_strategy != PanicStrategy::Unwind {\n+        // In panic=abort mode we assume nothing can unwind anywhere, so\n+        // optimize based on this!\n+        false\n+    } else if codegen_fn_attr_flags.contains(CodegenFnAttrFlags::UNWIND) {\n+        // If a specific #[unwind] attribute is present, use that.\n+        true\n+    } else if codegen_fn_attr_flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n+        // Special attribute for allocator functions, which can't unwind.\n+        false\n+    } else {\n+        if call_conv == Conv::Rust {\n+            // Any Rust method (or `extern \"Rust\" fn` or `extern\n+            // \"rust-call\" fn`) is explicitly allowed to unwind\n+            // (unless it has no-unwind attribute, handled above).\n+            true\n+        } else {\n+            // Anything else is either:\n+            //\n+            //  1. A foreign item using a non-Rust ABI (like `extern \"C\" { fn foo(); }`), or\n+            //\n+            //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n+            //\n+            // Foreign items (case 1) are assumed to not unwind; it is\n+            // UB otherwise. (At least for now; see also\n+            // rust-lang/rust#63909 and Rust RFC 2753.)\n+            //\n+            // Items defined in Rust with non-Rust ABIs (case 2) are also\n+            // not supposed to unwind. Whether this should be enforced\n+            // (versus stating it is UB) and *how* it would be enforced\n+            // is currently under discussion; see rust-lang/rust#58794.\n+            //\n+            // In either case, we mark item as explicitly nounwind.\n+            false\n+        }\n+    }\n+}\n+\n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n@@ -2382,7 +2427,12 @@ where\n         + HasParamEnv<'tcx>,\n {\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnAbi::new_internal(cx, sig, extra_args, None, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n+        // Assume that fn pointers may always unwind\n+        let codegen_fn_attr_flags = CodegenFnAttrFlags::UNWIND;\n+\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, |ty, _| {\n+            ArgAbi::new(cx.layout_of(ty))\n+        })\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2394,7 +2444,9 @@ where\n             None\n         };\n \n-        call::FnAbi::new_internal(cx, sig, extra_args, caller_location, |ty, arg_idx| {\n+        let attrs = cx.tcx().codegen_fn_attrs(instance.def_id()).flags;\n+\n+        call::FnAbi::new_internal(cx, sig, extra_args, caller_location, attrs, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n@@ -2450,6 +2502,7 @@ where\n         sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n+        codegen_fn_attr_flags: CodegenFnAttrFlags,\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n     ) -> Self {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n@@ -2639,6 +2692,7 @@ where\n             c_variadic: sig.c_variadic,\n             fixed_count: inputs.len(),\n             conv,\n+            can_unwind: fn_can_unwind(cx.tcx().sess.panic_strategy(), codegen_fn_attr_flags, conv),\n         };\n         fn_abi.adjust_for_abi(cx, sig.abi);\n         fn_abi"}, {"sha": "7242bbcd2eb8fcfaccbc101b15ec55127ae4c8e6", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n             let idx = self.idx_vec.push(borrow);\n             self.location_map.insert(location, idx);\n \n-            self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n+            self.insert_as_pending_if_two_phase(location, assigned_place, kind, idx);\n \n             self.local_map.entry(borrowed_place.local).or_default().insert(idx);\n         }"}, {"sha": "e0420d974fbdf3cdc93d35e8a43d5210c487a251", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -114,7 +114,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n     fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         // When we see `X = ...`, then kill borrows of\n         // `(*X).foo` and so forth.\n-        self.record_killed_borrows_for_place(place, location);\n+        self.record_killed_borrows_for_place(*place, location);\n \n         self.super_assign(place, rvalue, location);\n     }\n@@ -139,7 +139,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n \n         // A `Call` terminator's return value can be a local which has borrows,\n         // so we need to record those as `killed` as well.\n-        if let TerminatorKind::Call { ref destination, .. } = terminator.kind {\n+        if let TerminatorKind::Call { destination, .. } = terminator.kind {\n             if let Some((place, _)) = destination {\n                 self.record_killed_borrows_for_place(place, location);\n             }\n@@ -177,7 +177,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n \n     /// When recording facts for Polonius, records the borrows on the specified place\n     /// as `killed`. For example, when assigning to a local, or on a call's return destination.\n-    fn record_killed_borrows_for_place(&mut self, place: &Place<'tcx>, location: Location) {\n+    fn record_killed_borrows_for_place(&mut self, place: Place<'tcx>, location: Location) {\n         if let Some(all_facts) = self.all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n \n@@ -217,7 +217,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n                                 self.body,\n-                                &self.borrow_set.borrows[borrow_index].borrowed_place,\n+                                self.borrow_set.borrows[borrow_index].borrowed_place,\n                                 place,\n                                 places_conflict::PlaceConflictBias::NoOverlap,\n                             );"}, {"sha": "9df5760563129802b790870965b86e89c353529a", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -247,7 +247,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_move_out_while_borrowed(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         debug!(\n@@ -291,7 +291,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_use_while_mutably_borrowed(\n         &mut self,\n         location: Location,\n-        (place, _span): (&Place<'tcx>, Span),\n+        (place, _span): (Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n@@ -330,7 +330,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_conflicting_borrow(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -347,7 +347,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         let (desc_place, msg_place, msg_borrow, union_type_name) =\n-            self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n+            self.describe_place_for_conflicting_borrow(place, issued_borrow.borrowed_place);\n \n         let explanation = self.explain_why_borrow_contains_point(location, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() { \"second \" } else { \"\" };\n@@ -396,8 +396,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n                 self.suggest_split_at_mut_if_applicable(\n                     &mut err,\n-                    &place,\n-                    &issued_borrow.borrowed_place,\n+                    place,\n+                    issued_borrow.borrowed_place,\n                 );\n                 err\n             }\n@@ -410,7 +410,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             (BorrowKind::Mut { .. }, BorrowKind::Shallow)\n             | (BorrowKind::Unique, BorrowKind::Shallow) => {\n                 if let Some(immutable_section_description) =\n-                    self.classify_immutable_section(&issued_borrow.assigned_place)\n+                    self.classify_immutable_section(issued_borrow.assigned_place)\n                 {\n                     let mut err = self.cannot_mutate_in_immutable_section(\n                         span,\n@@ -546,8 +546,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn suggest_split_at_mut_if_applicable(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        place: &Place<'tcx>,\n-        borrowed_place: &Place<'tcx>,\n+        place: Place<'tcx>,\n+        borrowed_place: Place<'tcx>,\n     ) {\n         if let ([ProjectionElem::Index(_)], [ProjectionElem::Index(_)]) =\n             (&place.projection[..], &borrowed_place.projection[..])\n@@ -584,8 +584,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// >  mutable (via `a.u.s.b`) [E0502]\n     pub(in crate::borrow_check) fn describe_place_for_conflicting_borrow(\n         &self,\n-        first_borrowed_place: &Place<'tcx>,\n-        second_borrowed_place: &Place<'tcx>,\n+        first_borrowed_place: Place<'tcx>,\n+        second_borrowed_place: Place<'tcx>,\n     ) -> (String, String, String, String) {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n@@ -615,13 +615,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     cursor = proj_base;\n \n                     match elem {\n-                        ProjectionElem::Field(field, _)\n-                            if union_ty(*local, proj_base).is_some() =>\n-                        {\n-                            return Some((\n-                                PlaceRef { local: *local, projection: proj_base },\n-                                field,\n-                            ));\n+                        ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n+                            return Some((PlaceRef { local, projection: proj_base }, field));\n                         }\n                         _ => {}\n                     }\n@@ -631,7 +626,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { local, ref projection } = *second_borrowed_place;\n+                let Place { local, ref projection } = second_borrowed_place;\n \n                 let mut cursor = &projection[..];\n                 while let [proj_base @ .., elem] = cursor {\n@@ -682,7 +677,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n         debug!(\n@@ -967,7 +962,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n-        (place, drop_span): (&Place<'tcx>, Span),\n+        (place, drop_span): (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n         dropped_ty: Ty<'tcx>,\n     ) {\n@@ -1379,15 +1374,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n         let loan_span = loan_spans.args_or_use();\n \n         let descr_place = self.describe_any_place(place.as_ref());\n         if loan.kind == BorrowKind::Shallow {\n-            if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n+            if let Some(section) = self.classify_immutable_section(loan.assigned_place) {\n                 let mut err = self.cannot_mutate_in_immutable_section(\n                     span,\n                     loan_span,\n@@ -1432,9 +1427,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_illegal_reassignment(\n         &mut self,\n         _location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         assigned_span: Span,\n-        err_place: &Place<'tcx>,\n+        err_place: Place<'tcx>,\n     ) {\n         let (from_arg, local_decl, local_name) = match err_place.as_local() {\n             Some(local) => (\n@@ -1539,17 +1534,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// Describe the reason for the fake borrow that was assigned to `place`.\n-    fn classify_immutable_section(&self, place: &Place<'tcx>) -> Option<&'static str> {\n+    fn classify_immutable_section(&self, place: Place<'tcx>) -> Option<&'static str> {\n         use rustc_middle::mir::visit::Visitor;\n-        struct FakeReadCauseFinder<'a, 'tcx> {\n-            place: &'a Place<'tcx>,\n+        struct FakeReadCauseFinder<'tcx> {\n+            place: Place<'tcx>,\n             cause: Option<FakeReadCause>,\n         }\n-        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'_, 'tcx> {\n+        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'tcx> {\n             fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n                 match statement {\n-                    Statement { kind: StatementKind::FakeRead(cause, box ref place), .. }\n-                        if *place == *self.place =>\n+                    Statement { kind: StatementKind::FakeRead(cause, box place), .. }\n+                        if *place == self.place =>\n                     {\n                         self.cause = Some(*cause);\n                     }"}, {"sha": "7340e88f19b3783ea01f613a90a190fa9e405eda", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -286,7 +286,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n-        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n+        kind_place: Option<(WriteKind, Place<'tcx>)>,\n     ) -> BorrowExplanation {\n         debug!(\n             \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\","}, {"sha": "d32533b6ce9a1a35ac98414e83a7c8c0f8892e05", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // whether or not the right-hand side is a place expression\n                         if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                             VarBindingForm {\n-                                opt_match_place: Some((ref opt_match_place, match_span)),\n+                                opt_match_place: Some((opt_match_place, match_span)),\n                                 binding_mode: _,\n                                 opt_ty_info: _,\n                                 pat_span: _,\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 grouped_errors,\n                                 kind,\n                                 original_path,\n-                                move_from,\n+                                *move_from,\n                                 local,\n                                 opt_match_place,\n                                 match_span,\n@@ -143,16 +143,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         grouped_errors: &mut Vec<GroupedMoveError<'tcx>>,\n         kind: IllegalMoveOriginKind<'tcx>,\n         original_path: Place<'tcx>,\n-        move_from: &Place<'tcx>,\n+        move_from: Place<'tcx>,\n         bind_to: Local,\n-        match_place: &Option<Place<'tcx>>,\n+        match_place: Option<Place<'tcx>>,\n         match_span: Span,\n         statement_span: Span,\n     ) {\n         debug!(\"append_binding_error(match_place={:?}, match_span={:?})\", match_place, match_span);\n \n         let from_simple_let = match_place.is_none();\n-        let match_place = match_place.as_ref().unwrap_or(move_from);\n+        let match_place = match_place.unwrap_or(move_from);\n \n         match self.move_data.rev_lookup.find(match_place.as_ref()) {\n             // Error with the match place\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n                 grouped_errors.push(GroupedMoveError::MovesFromPlace {\n                     span,\n-                    move_from: *match_place,\n+                    move_from,\n                     original_path,\n                     kind,\n                     binds_to,\n@@ -223,14 +223,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let (span, use_spans, original_path, kind): (\n                 Span,\n                 Option<UseSpans>,\n-                &Place<'tcx>,\n+                Place<'tcx>,\n                 &IllegalMoveOriginKind<'_>,\n             ) = match error {\n-                GroupedMoveError::MovesFromPlace { span, ref original_path, ref kind, .. }\n-                | GroupedMoveError::MovesFromValue { span, ref original_path, ref kind, .. } => {\n+                GroupedMoveError::MovesFromPlace { span, original_path, ref kind, .. }\n+                | GroupedMoveError::MovesFromValue { span, original_path, ref kind, .. } => {\n                     (span, None, original_path, kind)\n                 }\n-                GroupedMoveError::OtherIllegalMove { use_spans, ref original_path, ref kind } => {\n+                GroupedMoveError::OtherIllegalMove { use_spans, original_path, ref kind } => {\n                     (use_spans.args_or_use(), Some(use_spans), original_path, kind)\n                 }\n             };\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => self\n                         .report_cannot_move_from_borrowed_content(\n                             original_path,\n-                            target_place,\n+                            *target_place,\n                             span,\n                             use_spans,\n                         ),\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn report_cannot_move_from_static(\n         &mut self,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'a> {\n         let description = if place.projection.len() == 1 {\n@@ -288,8 +288,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn report_cannot_move_from_borrowed_content(\n         &mut self,\n-        move_place: &Place<'tcx>,\n-        deref_target_place: &Place<'tcx>,\n+        move_place: Place<'tcx>,\n+        deref_target_place: Place<'tcx>,\n         span: Span,\n         use_spans: Option<UseSpans>,\n     ) -> DiagnosticBuilder<'a> {"}, {"sha": "35edd3d803db93460d2693205c94800c56110a10", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -22,7 +22,7 @@ pub(crate) enum AccessKind {\n impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(crate) fn report_mutability_error(\n         &mut self,\n-        access_place: &Place<'tcx>,\n+        access_place: Place<'tcx>,\n         span: Span,\n         the_place_err: PlaceRef<'tcx>,\n         error_access: AccessKind,"}, {"sha": "318751113b283817adf8f35d1f7a5925be11267f", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -56,33 +56,33 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         self.check_activations(location);\n \n-        match statement.kind {\n-            StatementKind::Assign(box (ref lhs, ref rhs)) => {\n+        match &statement.kind {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n                 self.consume_rvalue(location, rhs);\n \n-                self.mutate_place(location, lhs, Shallow(None), JustWrite);\n+                self.mutate_place(location, *lhs, Shallow(None), JustWrite);\n             }\n             StatementKind::FakeRead(_, _) => {\n                 // Only relevant for initialized/liveness/safety checks.\n             }\n-            StatementKind::SetDiscriminant { ref place, variant_index: _ } => {\n-                self.mutate_place(location, place, Shallow(None), JustWrite);\n+            StatementKind::SetDiscriminant { place, variant_index: _ } => {\n+                self.mutate_place(location, **place, Shallow(None), JustWrite);\n             }\n-            StatementKind::LlvmInlineAsm(ref asm) => {\n+            StatementKind::LlvmInlineAsm(asm) => {\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n                             location,\n-                            output,\n+                            *output,\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                         );\n                     } else {\n                         self.mutate_place(\n                             location,\n-                            output,\n+                            *output,\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                         );\n@@ -102,7 +102,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n-                    &Place::from(local),\n+                    Place::from(*local),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n@@ -119,36 +119,36 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n-            TerminatorKind::Drop { location: ref drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { location: drop_place, target: _, unwind: _ } => {\n                 self.access_place(\n                     location,\n-                    drop_place,\n+                    *drop_place,\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: ref drop_place,\n+                location: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.mutate_place(location, drop_place, Deep, JustWrite);\n+                self.mutate_place(location, *drop_place, Deep, JustWrite);\n                 self.consume_operand(location, new_value);\n             }\n             TerminatorKind::Call {\n                 ref func,\n                 ref args,\n-                ref destination,\n+                destination,\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n                 self.consume_operand(location, func);\n                 for arg in args {\n                     self.consume_operand(location, arg);\n                 }\n-                if let Some((ref dest, _ /*bb*/)) = *destination {\n-                    self.mutate_place(location, dest, Deep, JustWrite);\n+                if let Some((dest, _ /*bb*/)) = destination {\n+                    self.mutate_place(location, *dest, Deep, JustWrite);\n                 }\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n@@ -166,19 +166,19 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 let borrow_set = self.borrow_set.clone();\n                 let resume = self.location_table.start_index(resume.start_location());\n                 for i in borrow_set.borrows.indices() {\n-                    if borrow_of_local_data(&borrow_set.borrows[i].borrowed_place) {\n+                    if borrow_of_local_data(borrow_set.borrows[i].borrowed_place) {\n                         self.all_facts.invalidates.push((resume, i));\n                     }\n                 }\n \n-                self.mutate_place(location, resume_arg, Deep, JustWrite);\n+                self.mutate_place(location, *resume_arg, Deep, JustWrite);\n             }\n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n                 let start = self.location_table.start_index(location);\n                 for i in borrow_set.borrows.indices() {\n-                    if borrow_of_local_data(&borrow_set.borrows[i].borrowed_place) {\n+                    if borrow_of_local_data(borrow_set.borrows[i].borrowed_place) {\n                         self.all_facts.invalidates.push((start, i));\n                     }\n                 }\n@@ -201,7 +201,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     fn mutate_place(\n         &mut self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         kind: AccessDepth,\n         _mode: MutateMode,\n     ) {\n@@ -216,15 +216,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     /// Simulates consumption of an operand.\n     fn consume_operand(&mut self, location: Location, operand: &Operand<'tcx>) {\n         match *operand {\n-            Operand::Copy(ref place) => {\n+            Operand::Copy(place) => {\n                 self.access_place(\n                     location,\n                     place,\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n             }\n-            Operand::Move(ref place) => {\n+            Operand::Move(place) => {\n                 self.access_place(\n                     location,\n                     place,\n@@ -239,7 +239,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     // Simulates consumption of an rvalue\n     fn consume_rvalue(&mut self, location: Location, rvalue: &Rvalue<'tcx>) {\n         match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n+            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -258,7 +258,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n-            Rvalue::AddressOf(mutability, ref place) => {\n+            Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -279,7 +279,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, operand)\n             }\n \n-            Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n+            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -313,7 +313,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     fn access_place(\n         &mut self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         kind: (AccessDepth, ReadOrWrite),\n         _is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n@@ -325,7 +325,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n     ) {\n@@ -413,7 +413,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n             self.access_place(\n                 location,\n-                &borrow.borrowed_place,\n+                borrow.borrowed_place,\n                 (Deep, Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index)),\n                 LocalMutationIsAllowed::No,\n             );"}, {"sha": "52847af214f6c760e90cb5dfbfcfdc09d2a92bbe", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -308,8 +308,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n     for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n-        let mut initial_diag =\n-            mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n+        let mut initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);\n \n         let scope = mbcx.body.source_info(location).scope;\n         let lint_root = match &mbcx.body.source_scopes[scope].local_data {\n@@ -523,11 +522,11 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n \n         self.check_activations(location, span, flow_state);\n \n-        match stmt.kind {\n-            StatementKind::Assign(box (ref lhs, ref rhs)) => {\n+        match &stmt.kind {\n+            StatementKind::Assign(box (lhs, ref rhs)) => {\n                 self.consume_rvalue(location, (rhs, span), flow_state);\n \n-                self.mutate_place(location, (lhs, span), Shallow(None), JustWrite, flow_state);\n+                self.mutate_place(location, (*lhs, span), Shallow(None), JustWrite, flow_state);\n             }\n             StatementKind::FakeRead(_, box ref place) => {\n                 // Read for match doesn't access any memory and is used to\n@@ -547,8 +546,8 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                     flow_state,\n                 );\n             }\n-            StatementKind::SetDiscriminant { ref place, variant_index: _ } => {\n-                self.mutate_place(location, (place, span), Shallow(None), JustWrite, flow_state);\n+            StatementKind::SetDiscriminant { place, variant_index: _ } => {\n+                self.mutate_place(location, (**place, span), Shallow(None), JustWrite, flow_state);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n@@ -557,7 +556,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n                             location,\n-                            (output, o.span),\n+                            (*output, o.span),\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                             flow_state,\n@@ -571,7 +570,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                     } else {\n                         self.mutate_place(\n                             location,\n-                            (output, o.span),\n+                            (*output, o.span),\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                             flow_state,\n@@ -592,7 +591,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n-                    (&Place::from(local), span),\n+                    (Place::from(*local), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n@@ -638,14 +637,14 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n \n                 self.access_place(\n                     loc,\n-                    (drop_place, span),\n+                    (*drop_place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: ref drop_place,\n+                location: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,\n@@ -664,7 +663,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 for arg in args {\n                     self.consume_operand(loc, (arg, span), flow_state);\n                 }\n-                if let Some((ref dest, _ /*bb*/)) = *destination {\n+                if let Some((dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(loc, (dest, span), Deep, JustWrite, flow_state);\n                 }\n             }\n@@ -677,7 +676,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, ref resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n                 self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n@@ -884,7 +883,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn access_place(\n         &mut self,\n         location: Location,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         kind: (AccessDepth, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -905,7 +904,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Check is_empty() first because it's the common case, and doing that\n         // way we avoid the clone() call.\n         if !self.access_place_error_reported.is_empty()\n-            && self.access_place_error_reported.contains(&(*place_span.0, place_span.1))\n+            && self.access_place_error_reported.contains(&(place_span.0, place_span.1))\n         {\n             debug!(\n                 \"access_place: suppressing error place_span=`{:?}` kind=`{:?}`\",\n@@ -933,14 +932,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if conflict_error || mutability_error {\n             debug!(\"access_place: logging error place_span=`{:?}` kind=`{:?}`\", place_span, kind);\n \n-            self.access_place_error_reported.insert((*place_span.0, place_span.1));\n+            self.access_place_error_reported.insert((place_span.0, place_span.1));\n         }\n     }\n \n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -1043,7 +1042,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // these sepately so that we only emit a warning if borrow\n                     // checking was otherwise successful.\n                     this.reservation_warnings\n-                        .insert(bi, (*place_span.0, place_span.1, location, bk, borrow.clone()));\n+                        .insert(bi, (place_span.0, place_span.1, location, bk, borrow.clone()));\n \n                     // Don't suppress actual errors.\n                     Control::Continue\n@@ -1100,7 +1099,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn mutate_place(\n         &mut self,\n         location: Location,\n-        place_span: (&'cx Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -1150,7 +1149,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n+            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -1188,7 +1187,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::AddressOf(mutability, ref place) => {\n+            Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -1222,7 +1221,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.consume_operand(location, (operand, span), flow_state)\n             }\n \n-            Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n+            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -1283,7 +1282,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n-        let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n+        let propagate_closure_used_mut_place = |this: &mut Self, place: Place<'tcx>| {\n             if !place.projection.is_empty() {\n                 if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n                     this.used_mut_upvars.push(field);\n@@ -1297,7 +1296,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // captures of a closure are copied/moved directly\n         // when generating MIR.\n         match *operand {\n-            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+            Operand::Move(place) | Operand::Copy(place) => {\n                 match place.as_local() {\n                     Some(local) if !self.body.local_decls[local].is_user_variable() => {\n                         if self.body.local_decls[local].ty.is_mutable_ptr() {\n@@ -1336,8 +1335,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let stmt = &bbd.statements[loc.statement_index];\n                         debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n-                        if let StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref source))) =\n-                            stmt.kind\n+                        if let StatementKind::Assign(box (_, Rvalue::Ref(_, _, source))) = stmt.kind\n                         {\n                             propagate_closure_used_mut_place(self, source);\n                         } else {\n@@ -1361,7 +1359,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *operand {\n-            Operand::Copy(ref place) => {\n+            Operand::Copy(place) => {\n                 // copy of place: check if this is \"copy of frozen path\"\n                 // (FIXME: see check_loans.rs)\n                 self.access_place(\n@@ -1380,7 +1378,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     flow_state,\n                 );\n             }\n-            Operand::Move(ref place) => {\n+            Operand::Move(place) => {\n                 // move of place: check if this is move of already borrowed path\n                 self.access_place(\n                     location,\n@@ -1411,7 +1409,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n-        let place = &borrow.borrowed_place;\n+        let place = borrow.borrowed_place;\n         let mut root_place = PlaceRef { local: place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n@@ -1465,7 +1463,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_for_local_borrow(&mut self, borrow: &BorrowData<'tcx>, yield_span: Span) {\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n-        if borrow_of_local_data(&borrow.borrowed_place) {\n+        if borrow_of_local_data(borrow.borrowed_place) {\n             let err = self.cannot_borrow_across_generator_yield(\n                 self.retrieve_borrow_spans(borrow).var_or_use(),\n                 yield_span,\n@@ -1491,7 +1489,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             self.access_place(\n                 location,\n-                (&borrow.borrowed_place, span),\n+                (borrow.borrowed_place, span),\n                 (Deep, Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index)),\n                 LocalMutationIsAllowed::No,\n                 flow_state,\n@@ -1506,7 +1504,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         local: Local,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", local);\n@@ -1730,7 +1728,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_assigned_path_is_moved(\n         &mut self,\n         location: Location,\n-        (place, span): (&'cx Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n@@ -1903,7 +1901,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns `true` if an error is reported.\n     fn check_access_permissions(\n         &mut self,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'tcx>,"}, {"sha": "678ab3ed323eaabba05ed1c90fc9ed3073b63547", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -317,7 +317,7 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n     regioncx: &RegionInferenceContext<'_>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n ) {\n-    if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n+    if !mir_util::dump_enabled(infcx.tcx, \"nll\", source.def_id()) {\n         return;\n     }\n "}, {"sha": "f5238e7b7bedcf64baaec6039dd10a1eee762efc", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -27,7 +27,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n-    access_place: (AccessDepth, &Place<'tcx>),\n+    access_place: (AccessDepth, Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,\n     candidates: I,\n     mut op: F,\n@@ -48,7 +48,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n         if places_conflict::borrow_conflicts_with_place(\n             tcx,\n             body,\n-            &borrowed.borrowed_place,\n+            borrowed.borrowed_place,\n             borrowed.kind,\n             place.as_ref(),\n             access,\n@@ -130,7 +130,7 @@ pub(super) fn is_active<'tcx>(\n \n /// Determines if a given borrow is borrowing local data\n /// This is called for all Yield expressions on movable generators\n-pub(super) fn borrow_of_local_data(place: &Place<'_>) -> bool {\n+pub(super) fn borrow_of_local_data(place: Place<'_>) -> bool {\n     // Reborrow of already borrowed data is ignored\n     // Any errors will be caught on the initial borrow\n     !place.is_indirect()"}, {"sha": "d48df6a91095e02cbd47e06839d5f6eba2f05c6e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -24,8 +24,8 @@ crate enum PlaceConflictBias {\n crate fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_place: &Place<'tcx>,\n-    access_place: &Place<'tcx>,\n+    borrow_place: Place<'tcx>,\n+    access_place: Place<'tcx>,\n     bias: PlaceConflictBias,\n ) -> bool {\n     borrow_conflicts_with_place(\n@@ -46,7 +46,7 @@ crate fn places_conflict<'tcx>(\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_place: &Place<'tcx>,\n+    borrow_place: Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: PlaceRef<'tcx>,\n     access: AccessDepth,\n@@ -71,7 +71,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_place: &Place<'tcx>,\n+    borrow_place: Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: PlaceRef<'tcx>,\n     access: AccessDepth,"}, {"sha": "2da72f3bcc517451239ca8ffed3a0134e6593983", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -51,7 +51,7 @@ struct GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n }\n \n impl GatherUsedMutsVisitor<'_, '_, '_> {\n-    fn remove_never_initialized_mut_locals(&mut self, into: &Place<'_>) {\n+    fn remove_never_initialized_mut_locals(&mut self, into: Place<'_>) {\n         // Remove any locals that we found were initialized from the\n         // `never_initialized_mut_locals` set. At the end, the only remaining locals will\n         // be those that were never initialized - we will consider those as being used as\n@@ -66,10 +66,10 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n         debug!(\"visit_terminator_kind: kind={:?}\", kind);\n         match &kind {\n             TerminatorKind::Call { destination: Some((into, _)), .. } => {\n-                self.remove_never_initialized_mut_locals(&into);\n+                self.remove_never_initialized_mut_locals(*into);\n             }\n             TerminatorKind::DropAndReplace { location, .. } => {\n-                self.remove_never_initialized_mut_locals(&location);\n+                self.remove_never_initialized_mut_locals(*location);\n             }\n             _ => {}\n         }\n@@ -82,7 +82,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                     never_initialized_mut_locals={:?}\",\n                 statement, into.local, self.never_initialized_mut_locals\n             );\n-            self.remove_never_initialized_mut_locals(into);\n+            self.remove_never_initialized_mut_locals(*into);\n         }\n     }\n "}, {"sha": "91b342ae5c36a7efc74c173d38256fa94099e825", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -49,7 +49,7 @@ where\n fn place_contents_drop_state_cannot_differ<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    place: &mir::Place<'tcx>,\n+    place: mir::Place<'tcx>,\n ) -> bool {\n     let ty = place.ty(body, tcx).ty;\n     match ty.kind {\n@@ -110,7 +110,7 @@ pub(crate) fn on_all_children_bits<'tcx, F>(\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex,\n     ) -> bool {\n-        place_contents_drop_state_cannot_differ(tcx, body, &move_data.move_paths[path].place)\n+        place_contents_drop_state_cannot_differ(tcx, body, move_data.move_paths[path].place)\n     }\n \n     fn on_all_children_bits<'tcx, F>("}, {"sha": "39676d03740b26b6e84c0806c7c2d1d9cdd27ac1", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -135,14 +135,14 @@ where\n                     target.block,\n                     func,\n                     args,\n-                    return_place,\n+                    *return_place,\n                 );\n             }\n             TerminatorKind::Yield { resume, resume_arg, .. } => {\n                 self.results.borrow().analysis.apply_yield_resume_effect(\n                     &mut self.state,\n                     *resume,\n-                    resume_arg,\n+                    *resume_arg,\n                 );\n             }\n             _ => {}"}, {"sha": "2a9d2d99c8a72905380ea59b200a6c002ef5ba56", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -15,6 +15,7 @@ use rustc_span::symbol::{sym, Symbol};\n \n use super::graphviz;\n use super::{Analysis, GenKillAnalysis, GenKillSet, Results};\n+use crate::util::pretty::dump_enabled;\n \n /// A solver for dataflow problems.\n pub struct Engine<'a, 'tcx, A>\n@@ -228,7 +229,7 @@ where\n                     self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n                 }\n \n-                self.analysis.apply_yield_resume_effect(in_out, target, &resume_arg);\n+                self.analysis.apply_yield_resume_effect(in_out, target, resume_arg);\n                 self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n             }\n \n@@ -272,7 +273,7 @@ where\n                     }\n                 }\n \n-                if let Some((ref dest_place, dest_bb)) = *destination {\n+                if let Some((dest_place, dest_bb)) = *destination {\n                     // N.B.: This must be done *last*, otherwise the unwind path will see the call\n                     // return effect.\n                     self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n@@ -314,7 +315,7 @@ where\n         in_out: &mut BitSet<A::Idx>,\n         bb: BasicBlock,\n         enum_def: &'tcx ty::AdtDef,\n-        enum_place: &mir::Place<'tcx>,\n+        enum_place: mir::Place<'tcx>,\n         dirty_list: &mut WorkQueue<BasicBlock>,\n         values: &[u128],\n         targets: &[BasicBlock],\n@@ -361,14 +362,14 @@ fn switch_on_enum_discriminant(\n     tcx: TyCtxt<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n     block: &'mir mir::BasicBlockData<'tcx>,\n-    switch_on: &mir::Place<'tcx>,\n-) -> Option<(&'mir mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n+    switch_on: mir::Place<'tcx>,\n+) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n     match block.statements.last().map(|stmt| &stmt.kind) {\n         Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n-            if lhs == switch_on =>\n+            if *lhs == switch_on =>\n         {\n             match &discriminated.ty(body, tcx).ty.kind {\n-                ty::Adt(def, _) => Some((discriminated, def)),\n+                ty::Adt(def, _) => Some((*discriminated, def)),\n \n                 // `Rvalue::Discriminant` is also used to get the active yield point for a\n                 // generator, but we do not need edge-specific effects in that case. This may\n@@ -400,12 +401,25 @@ where\n     let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n         Ok(attrs) => attrs,\n \n-        // Invalid `rustc_mir` attrs will be reported using `span_err`.\n+        // Invalid `rustc_mir` attrs are reported in `RustcMirAttrs::parse`\n         Err(()) => return Ok(()),\n     };\n \n     let path = match attrs.output_path(A::NAME) {\n         Some(path) => path,\n+\n+        None if tcx.sess.opts.debugging_opts.dump_mir_dataflow\n+            && dump_enabled(tcx, A::NAME, def_id) =>\n+        {\n+            let mut path = PathBuf::from(&tcx.sess.opts.debugging_opts.dump_mir_dir);\n+\n+            let item_name = ty::print::with_forced_impl_filename_line(|| {\n+                tcx.def_path(def_id).to_filename_friendly_no_crate()\n+            });\n+            path.push(format!(\"rustc.{}.{}.dot\", item_name, A::NAME));\n+            path\n+        }\n+\n         None => return Ok(()),\n     };\n \n@@ -430,7 +444,12 @@ where\n \n     let graphviz = graphviz::Formatter::new(body, def_id, results, &mut *formatter);\n     dot::render_opts(&graphviz, &mut buf, &[dot::RenderOption::Monospace])?;\n+\n+    if let Some(parent) = path.parent() {\n+        fs::create_dir_all(parent)?;\n+    }\n     fs::write(&path, buf)?;\n+\n     Ok(())\n }\n "}, {"sha": "fd2a3d5ea28f24d684bf1dc531b1d6dbef13b704", "filename": "src/librustc_mir/dataflow/framework/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -225,7 +225,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n+        return_place: mir::Place<'tcx>,\n     );\n \n     /// Updates the current dataflow state with the effect of resuming from a `Yield` terminator.\n@@ -238,7 +238,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n         &self,\n         _state: &mut BitSet<Self::Idx>,\n         _resume_block: BasicBlock,\n-        _resume_place: &mir::Place<'tcx>,\n+        _resume_place: mir::Place<'tcx>,\n     ) {\n     }\n \n@@ -251,7 +251,7 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n         &self,\n         _state: &mut BitSet<Self::Idx>,\n         _block: BasicBlock,\n-        _enum_place: &mir::Place<'tcx>,\n+        _enum_place: mir::Place<'tcx>,\n         _adt: &ty::AdtDef,\n         _variant: VariantIdx,\n     ) {\n@@ -332,15 +332,15 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n+        return_place: mir::Place<'tcx>,\n     );\n \n     /// See `Analysis::apply_yield_resume_effect`.\n     fn yield_resume_effect(\n         &self,\n         _trans: &mut BitSet<Self::Idx>,\n         _resume_block: BasicBlock,\n-        _resume_place: &mir::Place<'tcx>,\n+        _resume_place: mir::Place<'tcx>,\n     ) {\n     }\n \n@@ -349,7 +349,7 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n         &self,\n         _state: &mut impl GenKill<Self::Idx>,\n         _block: BasicBlock,\n-        _enum_place: &mir::Place<'tcx>,\n+        _enum_place: mir::Place<'tcx>,\n         _adt: &ty::AdtDef,\n         _variant: VariantIdx,\n     ) {\n@@ -402,7 +402,7 @@ where\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n+        return_place: mir::Place<'tcx>,\n     ) {\n         self.call_return_effect(state, block, func, args, return_place);\n     }\n@@ -411,7 +411,7 @@ where\n         &self,\n         state: &mut BitSet<Self::Idx>,\n         resume_block: BasicBlock,\n-        resume_place: &mir::Place<'tcx>,\n+        resume_place: mir::Place<'tcx>,\n     ) {\n         self.yield_resume_effect(state, resume_block, resume_place);\n     }\n@@ -420,7 +420,7 @@ where\n         &self,\n         state: &mut BitSet<Self::Idx>,\n         block: BasicBlock,\n-        enum_place: &mir::Place<'tcx>,\n+        enum_place: mir::Place<'tcx>,\n         adt: &ty::AdtDef,\n         variant: VariantIdx,\n     ) {"}, {"sha": "8c65b7452d1fd66b19f85166b29df93d6e062647", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -223,7 +223,7 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _return_place: &mir::Place<'tcx>,\n+        _return_place: mir::Place<'tcx>,\n     ) {\n         let location = self.body.terminator_loc(block);\n         let idx = self.effect_at_target(SeekTarget::AfterAssumeCallReturns(location)).unwrap();"}, {"sha": "6972a81cf1b0e1afbe9bc90820f4a1f6c9345061", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -123,7 +123,7 @@ where\n         _block: mir::BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _dest_place: &mir::Place<'tcx>,\n+        _dest_place: mir::Place<'tcx>,\n     ) {\n     }\n }\n@@ -160,13 +160,13 @@ where\n \n         match rvalue {\n             mir::Rvalue::AddressOf(mt, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, borrowed_place) {\n+                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, *borrowed_place) {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n \n             mir::Rvalue::Ref(_, kind, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, borrowed_place) {\n+                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, *borrowed_place) {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n@@ -230,33 +230,33 @@ impl MutBorrow<'mir, 'tcx> {\n     /// below. See [rust-lang/unsafe-code-guidelines#134].\n     ///\n     /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n-    fn shared_borrow_allows_mutation(&self, place: &Place<'tcx>) -> bool {\n+    fn shared_borrow_allows_mutation(&self, place: Place<'tcx>) -> bool {\n         !place.ty(self.body, self.tcx).ty.is_freeze(self.tcx, self.param_env, DUMMY_SP)\n     }\n }\n \n pub trait BorrowAnalysisKind<'tcx> {\n     const ANALYSIS_NAME: &'static str;\n \n-    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool;\n-    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool;\n+    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool;\n+    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool;\n }\n \n impl BorrowAnalysisKind<'tcx> for AnyBorrow {\n     const ANALYSIS_NAME: &'static str = \"maybe_borrowed_locals\";\n \n-    fn in_ref(&self, _: mir::BorrowKind, _: &Place<'_>) -> bool {\n+    fn in_ref(&self, _: mir::BorrowKind, _: Place<'_>) -> bool {\n         true\n     }\n-    fn in_address_of(&self, _: Mutability, _: &Place<'_>) -> bool {\n+    fn in_address_of(&self, _: Mutability, _: Place<'_>) -> bool {\n         true\n     }\n }\n \n impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n     const ANALYSIS_NAME: &'static str = \"maybe_mut_borrowed_locals\";\n \n-    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool {\n+    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool {\n         match kind {\n             mir::BorrowKind::Mut { .. } => true,\n             mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n@@ -265,7 +265,7 @@ impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n         }\n     }\n \n-    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool {\n+    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool {\n         match mt {\n             Mutability::Mut => true,\n             Mutability::Not => self.shared_borrow_allows_mutation(place),"}, {"sha": "0de8f45720e6f441778ec083ad286dc574415059", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n \n     /// Kill any borrows that conflict with `place`.\n-    fn kill_borrows_on_place(&self, trans: &mut impl GenKill<BorrowIndex>, place: &Place<'tcx>) {\n+    fn kill_borrows_on_place(&self, trans: &mut impl GenKill<BorrowIndex>, place: Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n         let other_borrows_of_local = self\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             places_conflict(\n                 self.tcx,\n                 self.body,\n-                &self.borrow_set.borrows[i].borrowed_place,\n+                self.borrow_set.borrows[i].borrowed_place,\n                 place,\n                 PlaceConflictBias::NoOverlap,\n             )\n@@ -262,8 +262,8 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         location: Location,\n     ) {\n         match stmt.kind {\n-            mir::StatementKind::Assign(box (ref lhs, ref rhs)) => {\n-                if let mir::Rvalue::Ref(_, _, ref place) = *rhs {\n+            mir::StatementKind::Assign(box (lhs, ref rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, place) = *rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,\n@@ -286,13 +286,13 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, &Place::from(local));\n+                self.kill_borrows_on_place(trans, Place::from(local));\n             }\n \n             mir::StatementKind::LlvmInlineAsm(ref asm) => {\n                 for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n-                        self.kill_borrows_on_place(trans, output);\n+                        self.kill_borrows_on_place(trans, *output);\n                     }\n                 }\n             }\n@@ -329,7 +329,7 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         _block: mir::BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _dest_place: &mir::Place<'tcx>,\n+        _dest_place: mir::Place<'tcx>,\n     ) {\n     }\n }"}, {"sha": "1c85226b1221f19f6dcb006f76171b068c47b872", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -323,7 +323,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n         _block: mir::BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        dest_place: &mir::Place<'tcx>,\n+        dest_place: mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n@@ -342,7 +342,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,\n         _block: mir::BasicBlock,\n-        enum_place: &mir::Place<'tcx>,\n+        enum_place: mir::Place<'tcx>,\n         _adt: &ty::AdtDef,\n         variant: VariantIdx,\n     ) {\n@@ -425,7 +425,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n         _block: mir::BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        dest_place: &mir::Place<'tcx>,\n+        dest_place: mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 0 (initialized).\n@@ -494,7 +494,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for DefinitelyInitializedPlaces<'_, 'tcx> {\n         _block: mir::BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        dest_place: &mir::Place<'tcx>,\n+        dest_place: mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n@@ -585,7 +585,7 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         block: mir::BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _dest_place: &mir::Place<'tcx>,\n+        _dest_place: mir::Place<'tcx>,\n     ) {\n         let move_data = self.move_data();\n         let init_loc_map = &move_data.init_loc_map;"}, {"sha": "3dfcfe16fb51493e5f51fd32345c59e0623fd528", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -56,7 +56,7 @@ impl dataflow::GenKillAnalysis<'tcx> for MaybeStorageLive {\n         _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        _return_place: &mir::Place<'tcx>,\n+        _return_place: mir::Place<'tcx>,\n     ) {\n         // Nothing to do when a call returns successfully\n     }\n@@ -231,7 +231,7 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n         _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n+        return_place: mir::Place<'tcx>,\n     ) {\n         trans.gen(return_place.local);\n     }\n@@ -240,7 +240,7 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n         &self,\n         trans: &mut BitSet<Self::Idx>,\n         _resume_block: BasicBlock,\n-        resume_place: &mir::Place<'tcx>,\n+        resume_place: mir::Place<'tcx>,\n     ) {\n         trans.gen(resume_place.local);\n     }"}, {"sha": "fabe575c28904e2715eda7492a6fc1da924e1abf", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -94,7 +94,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// problematic for borrowck.\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n+    fn move_path_for(&mut self, place: Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n         let mut base = self.builder.data.rev_lookup.locals[place.local];\n \n@@ -195,7 +195,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         })\n     }\n \n-    fn create_move_path(&mut self, place: &Place<'tcx>) {\n+    fn create_move_path(&mut self, place: Place<'tcx>) {\n         // This is an non-moving access (such as an overwrite or\n         // drop), so this not being a valid move path is OK.\n         let _ = self.move_path_for(place);\n@@ -279,22 +279,22 @@ struct Gatherer<'b, 'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rval)) => {\n-                self.create_move_path(place);\n+        match &stmt.kind {\n+            StatementKind::Assign(box (place, rval)) => {\n+                self.create_move_path(*place);\n                 if let RvalueInitializationState::Shallow = rval.initialization_state() {\n                     // Box starts out uninitialized - need to create a separate\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n-                    self.create_move_path(&self.builder.tcx.mk_place_deref(place.clone()));\n+                    self.create_move_path(self.builder.tcx.mk_place_deref(place.clone()));\n                     self.gather_init(place.as_ref(), InitKind::Shallow);\n                 } else {\n                     self.gather_init(place.as_ref(), InitKind::Deep);\n                 }\n                 self.gather_rvalue(rval);\n             }\n-            StatementKind::FakeRead(_, ref place) => {\n-                self.create_move_path(place);\n+            StatementKind::FakeRead(_, place) => {\n+                self.create_move_path(**place);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n                 for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n@@ -308,7 +308,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n-                self.gather_move(&Place::from(local));\n+                self.gather_move(Place::from(*local));\n             }\n             StatementKind::SetDiscriminant { .. } => {\n                 span_bug!(\n@@ -369,7 +369,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Unreachable => {}\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Place::return_place());\n+                self.gather_move(Place::return_place());\n             }\n \n             TerminatorKind::Assert { ref cond, .. } => {\n@@ -380,16 +380,16 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.gather_operand(discr);\n             }\n \n-            TerminatorKind::Yield { ref value, resume_arg: ref place, .. } => {\n+            TerminatorKind::Yield { ref value, resume_arg: place, .. } => {\n                 self.gather_operand(value);\n                 self.create_move_path(place);\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n \n-            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { location, target: _, unwind: _ } => {\n                 self.gather_move(location);\n             }\n-            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n+            TerminatorKind::DropAndReplace { location, ref value, .. } => {\n                 self.create_move_path(location);\n                 self.gather_operand(value);\n                 self.gather_init(location.as_ref(), InitKind::Deep);\n@@ -405,7 +405,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 for arg in args {\n                     self.gather_operand(arg);\n                 }\n-                if let Some((ref destination, _bb)) = *destination {\n+                if let Some((destination, _bb)) = *destination {\n                     self.create_move_path(destination);\n                     self.gather_init(destination.as_ref(), InitKind::NonPanicPathOnly);\n                 }\n@@ -416,14 +416,14 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n             Operand::Constant(..) | Operand::Copy(..) => {} // not-a-move\n-            Operand::Move(ref place) => {\n+            Operand::Move(place) => {\n                 // a move\n                 self.gather_move(place);\n             }\n         }\n     }\n \n-    fn gather_move(&mut self, place: &Place<'tcx>) {\n+    fn gather_move(&mut self, place: Place<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, place);\n \n         if let [ref base @ .., ProjectionElem::Subslice { from, to, from_end: false }] =\n@@ -434,7 +434,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             // are disjoint, which is expected by drop elaboration.\n             let base_place =\n                 Place { local: place.local, projection: self.builder.tcx.intern_place_elems(base) };\n-            let base_path = match self.move_path_for(&base_place) {\n+            let base_path = match self.move_path_for(base_place) {\n                 Ok(path) => path,\n                 Err(MoveError::UnionMove { path }) => {\n                     self.record_move(place, path);\n@@ -467,13 +467,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             match self.move_path_for(place) {\n                 Ok(path) | Err(MoveError::UnionMove { path }) => self.record_move(place, path),\n                 Err(error @ MoveError::IllegalMove { .. }) => {\n-                    self.builder.errors.push((*place, error));\n+                    self.builder.errors.push((place, error));\n                 }\n             };\n         }\n     }\n \n-    fn record_move(&mut self, place: &Place<'tcx>, path: MovePathIndex) {\n+    fn record_move(&mut self, place: Place<'tcx>, path: MovePathIndex) {\n         let move_out = self.builder.data.moves.push(MoveOut { path, source: self.loc });\n         debug!(\n             \"gather_move({:?}, {:?}): adding move {:?} of {:?}\","}, {"sha": "7191198b6c0eeab89c857a0f681fbae4e75f327d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -464,7 +464,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // avoid allocations.\n     pub fn eval_place_to_op(\n         &self,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base_op = match place.local {\n@@ -498,7 +498,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Operand::*;\n         let op = match *mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(ref place) | Move(ref place) => self.eval_place_to_op(place, layout)?,\n+            Copy(place) | Move(place) => self.eval_place_to_op(place, layout)?,\n \n             Constant(ref constant) => {\n                 let val ="}, {"sha": "5c4915d54b0378e1ec48cfd20445ddd3e94b74e2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -635,7 +635,7 @@ where\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         let mut place_ty = match place.local {\n             mir::RETURN_PLACE => {"}, {"sha": "961b0f4d189f8140dda07a1f7e4cab555f07acd6", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -87,23 +87,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.tcx.span = stmt.source_info.span;\n         self.memory.tcx.span = stmt.source_info.span;\n \n-        match stmt.kind {\n-            Assign(box (ref place, ref rvalue)) => self.eval_rvalue_into_place(rvalue, place)?,\n+        match &stmt.kind {\n+            Assign(box (place, rvalue)) => self.eval_rvalue_into_place(rvalue, *place)?,\n \n-            SetDiscriminant { ref place, variant_index } => {\n-                let dest = self.eval_place(place)?;\n-                self.write_discriminant_index(variant_index, dest)?;\n+            SetDiscriminant { place, variant_index } => {\n+                let dest = self.eval_place(**place)?;\n+                self.write_discriminant_index(*variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.storage_live(local)?;\n+                let old_val = self.storage_live(*local)?;\n                 self.deallocate_local(old_val)?;\n             }\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.storage_dead(local);\n+                let old_val = self.storage_dead(*local);\n                 self.deallocate_local(old_val)?;\n             }\n \n@@ -112,9 +112,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             FakeRead(..) => {}\n \n             // Stacked Borrows.\n-            Retag(kind, ref place) => {\n-                let dest = self.eval_place(place)?;\n-                M::retag(self, kind, dest)?;\n+            Retag(kind, place) => {\n+                let dest = self.eval_place(**place)?;\n+                M::retag(self, *kind, dest)?;\n             }\n \n             // Statements we do not track.\n@@ -138,7 +138,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn eval_rvalue_into_place(\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let dest = self.eval_place(place)?;\n \n@@ -224,15 +224,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Len(ref place) => {\n+            Len(place) => {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n                 let len = mplace.len(self)?;\n                 self.write_scalar(Scalar::from_machine_usize(len, self), dest)?;\n             }\n \n-            AddressOf(_, ref place) | Ref(_, _, ref place) => {\n+            AddressOf(_, place) | Ref(_, _, place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(src)?;\n                 if place.layout.size.bytes() > 0 {\n@@ -261,7 +261,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.cast(src, kind, dest)?;\n             }\n \n-            Discriminant(ref place) => {\n+            Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(op)?.0;\n                 let size = dest.layout.size;"}, {"sha": "0c2aa28d8118d3bcb310004cfceab595f38f9d4d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -51,7 +51,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.go_to_block(target_block);\n             }\n \n-            Call { ref func, ref args, ref destination, ref cleanup, .. } => {\n+            Call { ref func, ref args, destination, ref cleanup, .. } => {\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n@@ -68,7 +68,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let args = self.eval_operands(args)?;\n                 let ret = match destination {\n-                    Some((dest, ret)) => Some((self.eval_place(dest)?, *ret)),\n+                    Some((dest, ret)) => Some((self.eval_place(dest)?, ret)),\n                     None => None,\n                 };\n                 self.eval_fn_call(\n@@ -81,7 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 )?;\n             }\n \n-            Drop { ref location, target, unwind } => {\n+            Drop { location, target, unwind } => {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n                 let ty = place.layout.ty;\n@@ -328,7 +328,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n                     for local in body.args_iter() {\n-                        let dest = self.eval_place(&mir::Place::from(local))?;\n+                        let dest = self.eval_place(mir::Place::from(local))?;\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n@@ -346,7 +346,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     // Don't forget to check the return type!\n                     if let Some((caller_ret, _)) = ret {\n-                        let callee_ret = self.eval_place(&mir::Place::return_place())?;\n+                        let callee_ret = self.eval_place(mir::Place::return_place())?;\n                         if !Self::check_argument_compat(\n                             rust_abi,\n                             caller_ret.layout,"}, {"sha": "0a998bbfe7068d3e3a5c7f560ca3c8481828c5ed", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -230,7 +230,7 @@ fn build_drop_shim<'tcx>(\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n                 source_info,\n-                &dropee,\n+                dropee,\n                 (),\n                 return_block,\n                 elaborate_drops::Unwind::To(resume_block),"}, {"sha": "7c46855dfd63c0b70715d2fbb8c26612c353dcc1", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -68,7 +68,7 @@ fn add_moves_for_packed_drops_patch<'tcx>(\n         let terminator = data.terminator();\n \n         match terminator.kind {\n-            TerminatorKind::Drop { ref location, .. }\n+            TerminatorKind::Drop { location, .. }\n                 if util::is_disaligned(tcx, body, param_env, location) =>\n             {\n                 add_move_for_packed_drop(tcx, body, &mut patch, terminator, loc, data.is_cleanup);"}, {"sha": "b95a3939389bace36adc7db94eb2b1ffd2dbe221", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -68,15 +68,15 @@ where\n         _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n+        return_place: mir::Place<'tcx>,\n     ) {\n         // We cannot reason about another function's internals, so use conservative type-based\n         // qualification for the result of a function call.\n         let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n \n         if !return_place.is_indirect() {\n-            self.assign_qualif_direct(return_place, qualif);\n+            self.assign_qualif_direct(&return_place, qualif);\n         }\n     }\n }\n@@ -214,7 +214,7 @@ where\n         block: BasicBlock,\n         func: &mir::Operand<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n+        return_place: mir::Place<'tcx>,\n     ) {\n         self.transfer_function(state).apply_call_return_effect(block, func, args, return_place)\n     }"}, {"sha": "649cc0a79d636554af570edfbf975fe237a8e07b", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -260,7 +260,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         // Special-case reborrows to be more like a copy of a reference.\n         match *rvalue {\n-            Rvalue::Ref(_, kind, ref place) => {\n+            Rvalue::Ref(_, kind, place) => {\n                 if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n                     let ctx = match kind {\n                         BorrowKind::Shared => {\n@@ -281,7 +281,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     return;\n                 }\n             }\n-            Rvalue::AddressOf(mutbl, ref place) => {\n+            Rvalue::AddressOf(mutbl, place) => {\n                 if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n                     let ctx = match mutbl {\n                         Mutability::Not => {\n@@ -645,7 +645,7 @@ fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId)\n fn place_as_reborrow(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    place: &'a Place<'tcx>,\n+    place: Place<'tcx>,\n ) -> Option<&'a [PlaceElem<'tcx>]> {\n     place.projection.split_last().and_then(|(outermost, inner)| {\n         if outermost != &ProjectionElem::Deref {"}, {"sha": "3ce9b875e16cc2861bb81c4c242ee3749833ca1b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -184,14 +184,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         // because either of these would allow modifying the layout constrained field and\n         // insert values that violate the layout constraints.\n         if context.is_mutating_use() || context.is_borrow() {\n-            self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n+            self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n         for (i, elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n \n             if context.is_borrow() {\n-                if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n+                if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                     let source_info = self.source_info;\n                     let lint_root = self.body.source_scopes[source_info.scope]\n                         .local_data\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     }\n     fn check_mut_borrowing_layout_constrained_field(\n         &mut self,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n         let mut cursor = place.projection.as_ref();"}, {"sha": "b51c6141915483b48c6e78f31f408b74f0965e41", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -468,15 +468,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn eval_place(&mut self, place: &Place<'tcx>) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n         self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(ref place) | Operand::Copy(ref place) => self.eval_place(place),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place),\n         }\n     }\n \n@@ -572,7 +572,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place_layout: TyAndLayout<'tcx>,\n         source_info: SourceInfo,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n     ) -> Option<()> {\n         // #66397: Don't try to eval into large places as that can cause an OOM\n         if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n@@ -825,7 +825,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (ref place, ref mut rval)) = statement.kind {\n+        if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(local) = place.as_local() {"}, {"sha": "a25b554b345eb0d6ed0b8c454f5eeb6c28cbbe6c", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -97,9 +97,8 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                             if let Some(local) = place.as_local() {\n                                 if local == dest_local {\n                                     let maybe_action = match operand {\n-                                        Operand::Copy(ref src_place)\n-                                        | Operand::Move(ref src_place) => {\n-                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                        Operand::Copy(src_place) | Operand::Move(src_place) => {\n+                                            Action::local_copy(&body, &def_use_analysis, *src_place)\n                                         }\n                                         Operand::Constant(ref src_constant) => {\n                                             Action::constant(src_constant)\n@@ -195,7 +194,7 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(\n         body: &Body<'tcx>,\n         def_use_analysis: &DefUseAnalysis,\n-        src_place: &Place<'tcx>,\n+        src_place: Place<'tcx>,\n     ) -> Option<Action<'tcx>> {\n         // The source must be a local.\n         let src_local = if let Some(local) = src_place.as_local() {"}, {"sha": "9933b5cd9f74f2c0ff5bc988e5550b02621b0d3b", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -46,7 +46,7 @@ pub fn on_mir_pass<'tcx>(\n     body: &Body<'tcx>,\n     is_after: bool,\n ) {\n-    if mir_util::dump_enabled(tcx, pass_name, source) {\n+    if mir_util::dump_enabled(tcx, pass_name, source.def_id()) {\n         mir_util::dump_mir(\n             tcx,\n             Some(pass_num),"}, {"sha": "d3971c9a45cae540d3091e2d8c8644ec0645517f", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -346,7 +346,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n             let resume_block = self.patch.resume_block();\n             match terminator.kind {\n-                TerminatorKind::Drop { ref location, target, unwind } => {\n+                TerminatorKind::Drop { location, target, unwind } => {\n                     self.init_data.seek_before(loc);\n                     match self.move_data().rev_lookup.find(location.as_ref()) {\n                         LookupResult::Exact(path) => elaborate_drop(\n@@ -371,7 +371,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         }\n                     }\n                 }\n-                TerminatorKind::DropAndReplace { ref location, ref value, target, unwind } => {\n+                TerminatorKind::DropAndReplace { location, ref value, target, unwind } => {\n                     assert!(!data.is_cleanup);\n \n                     self.elaborate_replace(loc, location, value, target, unwind);\n@@ -396,7 +396,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn elaborate_replace(\n         &mut self,\n         loc: Location,\n-        location: &Place<'tcx>,\n+        location: Place<'tcx>,\n         value: &Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n@@ -407,7 +407,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n-            kind: StatementKind::Assign(box (*location, Rvalue::Use(value.clone()))),\n+            kind: StatementKind::Assign(box (location, Rvalue::Use(value.clone()))),\n             source_info: terminator.source_info,\n         };\n \n@@ -459,7 +459,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\"elaborate_drop_and_replace({:?}) - untracked {:?}\", terminator, parent);\n                 self.patch.patch_terminator(\n                     bb,\n-                    TerminatorKind::Drop { location: *location, target, unwind: Some(unwind) },\n+                    TerminatorKind::Drop { location, target, unwind: Some(unwind) },\n                 );\n             }\n         }"}, {"sha": "390d927a85471f347daf3e66571b1d3da3c79059", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -853,7 +853,7 @@ fn elaborate_generator_drops<'tcx>(\n         elaborate_drop(\n             &mut elaborator,\n             *source_info,\n-            &Place::from(SELF_ARG),\n+            Place::from(SELF_ARG),\n             (),\n             *target,\n             unwind,"}, {"sha": "157dada831a2e2610b5d304988c00241cd8fcb5c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -450,7 +450,7 @@ impl Inliner<'tcx> {\n                 // Place could result in two different locations if `f`\n                 // writes to `i`. To prevent this we need to create a temporary\n                 // borrow of the place and pass the destination as `*temp` instead.\n-                fn dest_needs_borrow(place: &Place<'_>) -> bool {\n+                fn dest_needs_borrow(place: Place<'_>) -> bool {\n                     for elem in place.projection.iter() {\n                         match elem {\n                             ProjectionElem::Deref | ProjectionElem::Index(_) => return true,\n@@ -461,7 +461,7 @@ impl Inliner<'tcx> {\n                     false\n                 }\n \n-                let dest = if dest_needs_borrow(&destination.0) {\n+                let dest = if dest_needs_borrow(destination.0) {\n                     debug!(\"creating temp for return destination\");\n                     let dest = Rvalue::Ref(\n                         self.tcx.lifetimes.re_erased,"}, {"sha": "c5b366ef5725179b91f59d3c89a7b54cd2f987fa", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -150,7 +150,7 @@ fn check_rvalue(\n         Rvalue::Len(place)\n         | Rvalue::Discriminant(place)\n         | Rvalue::Ref(_, _, place)\n-        | Rvalue::AddressOf(_, place) => check_place(tcx, place, span, def_id, body),\n+        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, def_id, body),\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n@@ -215,7 +215,7 @@ fn check_statement(\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(box (place, rval)) => {\n-            check_place(tcx, place, span, def_id, body)?;\n+            check_place(tcx, *place, span, def_id, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n         }\n \n@@ -225,10 +225,12 @@ fn check_statement(\n             Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n         }\n \n-        StatementKind::FakeRead(_, place) => check_place(tcx, place, span, def_id, body),\n+        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, def_id, body),\n \n         // just an assignment\n-        StatementKind::SetDiscriminant { place, .. } => check_place(tcx, place, span, def_id, body),\n+        StatementKind::SetDiscriminant { place, .. } => {\n+            check_place(tcx, **place, span, def_id, body)\n+        }\n \n         StatementKind::LlvmInlineAsm { .. } => {\n             Err((span, \"cannot use inline assembly in const fn\".into()))\n@@ -251,7 +253,7 @@ fn check_operand(\n     body: &Body<'tcx>,\n ) -> McfResult {\n     match operand {\n-        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, place, span, def_id, body),\n+        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, def_id, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n             Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n             None => Ok(()),\n@@ -261,7 +263,7 @@ fn check_operand(\n \n fn check_place(\n     tcx: TyCtxt<'tcx>,\n-    place: &Place<'tcx>,\n+    place: Place<'tcx>,\n     span: Span,\n     def_id: DefId,\n     body: &Body<'tcx>,\n@@ -330,9 +332,9 @@ fn check_terminator(\n         | TerminatorKind::Return\n         | TerminatorKind::Resume => Ok(()),\n \n-        TerminatorKind::Drop { location, .. } => check_place(tcx, location, span, def_id, body),\n+        TerminatorKind::Drop { location, .. } => check_place(tcx, *location, span, def_id, body),\n         TerminatorKind::DropAndReplace { location, value, .. } => {\n-            check_place(tcx, location, span, def_id, body)?;\n+            check_place(tcx, *location, span, def_id, body)?;\n             check_operand(tcx, value, span, def_id, body)\n         }\n "}, {"sha": "cccf9ff30168c19fea15fd869cf230efbd8f4a56", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -127,7 +127,7 @@ pub fn sanity_check_via_rustc_peek<'tcx, A>(\n                 let loc = Location { block: bb, statement_index };\n                 cursor.seek_before(loc);\n                 let state = cursor.get();\n-                results.analysis.peek_at(tcx, place, state, call);\n+                results.analysis.peek_at(tcx, *place, state, call);\n             }\n \n             _ => {\n@@ -231,7 +231,7 @@ pub trait RustcPeekAt<'tcx>: Analysis<'tcx> {\n     fn peek_at(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         flow_state: &BitSet<Self::Idx>,\n         call: PeekCall,\n     );\n@@ -244,7 +244,7 @@ where\n     fn peek_at(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         flow_state: &BitSet<Self::Idx>,\n         call: PeekCall,\n     ) {\n@@ -268,7 +268,7 @@ impl<'tcx> RustcPeekAt<'tcx> for MaybeMutBorrowedLocals<'_, 'tcx> {\n     fn peek_at(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         flow_state: &BitSet<Local>,\n         call: PeekCall,\n     ) {"}, {"sha": "7cdd929c7a033d2faffee0093dcc77a9a9423cbd", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -89,7 +89,7 @@ fn match_get_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local\n         StatementKind::Assign(box (place_into, rvalue_from)) => match rvalue_from {\n             Rvalue::Use(Operand::Copy(pf)) | Rvalue::Use(Operand::Move(pf)) => {\n                 let local_into = place_into.as_local()?;\n-                let (local_from, vf) = match_variant_field_place(&pf)?;\n+                let (local_from, vf) = match_variant_field_place(*pf)?;\n                 Some((local_into, local_from, vf))\n             }\n             _ => None,\n@@ -107,7 +107,7 @@ fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local\n         StatementKind::Assign(box (place_from, rvalue_into)) => match rvalue_into {\n             Rvalue::Use(Operand::Move(place_into)) => {\n                 let local_into = place_into.as_local()?;\n-                let (local_from, vf) = match_variant_field_place(&place_from)?;\n+                let (local_from, vf) = match_variant_field_place(*place_from)?;\n                 Some((local_into, local_from, vf))\n             }\n             _ => None,\n@@ -137,7 +137,7 @@ struct VarField<'tcx> {\n }\n \n /// Match on `((_LOCAL as Variant).FIELD: TY)`.\n-fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n+fn match_variant_field_place<'tcx>(place: Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n     match place.as_ref() {\n         PlaceRef {\n             local,"}, {"sha": "202e5e27f1d9431be4df5a8646bd51a693c48cd4", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -8,7 +8,7 @@ pub fn is_disaligned<'tcx, L>(\n     tcx: TyCtxt<'tcx>,\n     local_decls: &L,\n     param_env: ty::ParamEnv<'tcx>,\n-    place: &Place<'tcx>,\n+    place: Place<'tcx>,\n ) -> bool\n where\n     L: HasLocalDecls<'tcx>,\n@@ -34,7 +34,7 @@ where\n     }\n }\n \n-fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'tcx>) -> bool\n+fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: Place<'tcx>) -> bool\n where\n     L: HasLocalDecls<'tcx>,\n {"}, {"sha": "f6d67abcef041c25fdf3101f371cacb0a424bd49", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -100,7 +100,7 @@ where\n \n     source_info: SourceInfo,\n \n-    place: &'l Place<'tcx>,\n+    place: Place<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n@@ -109,7 +109,7 @@ where\n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n-    place: &Place<'tcx>,\n+    place: Place<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n@@ -126,7 +126,7 @@ where\n     D: DropElaborator<'b, 'tcx>,\n     'tcx: 'b,\n {\n-    fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n+    fn place_ty(&self, place: Place<'tcx>) -> Ty<'tcx> {\n         place.ty(self.elaborator.body(), self.tcx()).ty\n     }\n \n@@ -168,7 +168,7 @@ where\n                 self.elaborator.patch().patch_terminator(\n                     bb,\n                     TerminatorKind::Drop {\n-                        location: *self.place,\n+                        location: self.place,\n                         target: self.succ,\n                         unwind: self.unwind.into_option(),\n                     },\n@@ -195,7 +195,7 @@ where\n     /// (the move path is `None` if the field is a rest field).\n     fn move_paths_for_fields(\n         &self,\n-        base_place: &Place<'tcx>,\n+        base_place: Place<'tcx>,\n         variant_path: D::Path,\n         variant: &'tcx ty::VariantDef,\n         substs: SubstsRef<'tcx>,\n@@ -219,7 +219,7 @@ where\n \n     fn drop_subpath(\n         &mut self,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         path: Option<D::Path>,\n         succ: BasicBlock,\n         unwind: Unwind,\n@@ -267,12 +267,10 @@ where\n     ) -> Vec<BasicBlock> {\n         Some(succ)\n             .into_iter()\n-            .chain(fields.iter().rev().zip(unwind_ladder).map(\n-                |(&(ref place, path), &unwind_succ)| {\n-                    succ = self.drop_subpath(place, path, succ, unwind_succ);\n-                    succ\n-                },\n-            ))\n+            .chain(fields.iter().rev().zip(unwind_ladder).map(|(&(place, path), &unwind_succ)| {\n+                succ = self.drop_subpath(place, path, succ, unwind_succ);\n+                succ\n+            }))\n             .collect()\n     }\n \n@@ -315,7 +313,7 @@ where\n         debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n \n         let mut fields = fields;\n-        fields.retain(|&(ref place, _)| {\n+        fields.retain(|&(place, _)| {\n             self.place_ty(place).needs_drop(self.tcx(), self.elaborator.param_env())\n         });\n \n@@ -364,7 +362,7 @@ where\n         let unwind_succ =\n             self.unwind.map(|unwind| self.box_free_block(adt, substs, unwind, Unwind::InCleanup));\n \n-        self.drop_subpath(&interior, interior_path, succ, unwind_succ)\n+        self.drop_subpath(interior, interior_path, succ, unwind_succ)\n     }\n \n     fn open_drop_for_adt(&mut self, adt: &'tcx ty::AdtDef, substs: SubstsRef<'tcx>) -> BasicBlock {\n@@ -439,8 +437,7 @@ where\n                     self.place.clone(),\n                     ProjectionElem::Downcast(Some(variant.ident.name), variant_index),\n                 );\n-                let fields =\n-                    self.move_paths_for_fields(&base_place, variant_path, &variant, substs);\n+                let fields = self.move_paths_for_fields(base_place, variant_path, &variant, substs);\n                 values.push(discr.val);\n                 if let Unwind::To(unwind) = unwind {\n                     // We can't use the half-ladder from the original\n@@ -527,9 +524,9 @@ where\n         // way lies only trouble.\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n         let discr = Place::from(self.new_temp(discr_ty));\n-        let discr_rv = Rvalue::Discriminant(*self.place);\n+        let discr_rv = Rvalue::Discriminant(self.place);\n         let switch_block = BasicBlockData {\n-            statements: vec![self.assign(&discr, discr_rv)],\n+            statements: vec![self.assign(discr, discr_rv)],\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n@@ -560,11 +557,11 @@ where\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n-                &Place::from(ref_place),\n+                Place::from(ref_place),\n                 Rvalue::Ref(\n                     tcx.lifetimes.re_erased,\n                     BorrowKind::Mut { allow_two_phase_borrow: false },\n-                    *self.place,\n+                    self.place,\n                 ),\n             )],\n             terminator: Some(Terminator {\n@@ -607,7 +604,7 @@ where\n         &mut self,\n         succ: BasicBlock,\n         cur: Local,\n-        length_or_end: &Place<'tcx>,\n+        length_or_end: Place<'tcx>,\n         ety: Ty<'tcx>,\n         unwind: Unwind,\n         ptr_based: bool,\n@@ -617,7 +614,7 @@ where\n         let tcx = self.tcx();\n \n         let ptr_ty = tcx.mk_ptr(ty::TypeAndMut { ty: ety, mutbl: hir::Mutability::Mut });\n-        let ptr = &Place::from(self.new_temp(ptr_ty));\n+        let ptr = Place::from(self.new_temp(ptr_ty));\n         let can_go = Place::from(self.new_temp(tcx.types.bool));\n \n         let one = self.constant_usize(1);\n@@ -631,7 +628,7 @@ where\n         };\n \n         let drop_block = BasicBlockData {\n-            statements: vec![self.assign(ptr, ptr_next), self.assign(&Place::from(cur), cur_next)],\n+            statements: vec![self.assign(ptr, ptr_next), self.assign(Place::from(cur), cur_next)],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n@@ -643,8 +640,8 @@ where\n \n         let loop_block = BasicBlockData {\n             statements: vec![self.assign(\n-                &can_go,\n-                Rvalue::BinaryOp(BinOp::Eq, copy(Place::from(cur)), copy(*length_or_end)),\n+                can_go,\n+                Rvalue::BinaryOp(BinOp::Eq, copy(Place::from(cur)), copy(length_or_end)),\n             )],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -703,16 +700,16 @@ where\n             }\n         }\n \n-        let move_ = |place: &Place<'tcx>| Operand::Move(*place);\n-        let elem_size = &Place::from(self.new_temp(tcx.types.usize));\n-        let len = &Place::from(self.new_temp(tcx.types.usize));\n+        let move_ = |place: Place<'tcx>| Operand::Move(place);\n+        let elem_size = Place::from(self.new_temp(tcx.types.usize));\n+        let len = Place::from(self.new_temp(tcx.types.usize));\n \n         static USIZE_SWITCH_ZERO: &[u128] = &[0];\n \n         let base_block = BasicBlockData {\n             statements: vec![\n                 self.assign(elem_size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n-                self.assign(len, Rvalue::Len(*self.place)),\n+                self.assign(len, Rvalue::Len(self.place)),\n             ],\n             is_cleanup: self.unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -748,10 +745,10 @@ where\n         let length_or_end = if ptr_based { Place::from(self.new_temp(iter_ty)) } else { length };\n \n         let unwind = self.unwind.map(|unwind| {\n-            self.drop_loop(unwind, cur, &length_or_end, ety, Unwind::InCleanup, ptr_based)\n+            self.drop_loop(unwind, cur, length_or_end, ety, Unwind::InCleanup, ptr_based)\n         });\n \n-        let loop_block = self.drop_loop(self.succ, cur, &length_or_end, ety, unwind, ptr_based);\n+        let loop_block = self.drop_loop(self.succ, cur, length_or_end, ety, unwind, ptr_based);\n \n         let cur = Place::from(cur);\n         let drop_block_stmts = if ptr_based {\n@@ -761,17 +758,17 @@ where\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             vec![\n-                self.assign(&tmp, Rvalue::AddressOf(Mutability::Mut, *self.place)),\n-                self.assign(&cur, Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty)),\n+                self.assign(tmp, Rvalue::AddressOf(Mutability::Mut, self.place)),\n+                self.assign(cur, Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty)),\n                 self.assign(\n-                    &length_or_end,\n+                    length_or_end,\n                     Rvalue::BinaryOp(BinOp::Offset, Operand::Copy(cur), Operand::Move(length)),\n                 ),\n             ]\n         } else {\n             // cur = 0 (length already pushed)\n             let zero = self.constant_usize(0);\n-            vec![self.assign(&cur, Rvalue::Use(zero))]\n+            vec![self.assign(cur, Rvalue::Use(zero))]\n         };\n         let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n             statements: drop_block_stmts,\n@@ -935,7 +932,7 @@ where\n \n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block =\n-            TerminatorKind::Drop { location: *self.place, target, unwind: unwind.into_option() };\n+            TerminatorKind::Drop { location: self.place, target, unwind: unwind.into_option() };\n         self.new_block(unwind, block)\n     }\n \n@@ -992,7 +989,7 @@ where\n         })\n     }\n \n-    fn assign(&self, lhs: &Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n-        Statement { source_info: self.source_info, kind: StatementKind::Assign(box (*lhs, rhs)) }\n+    fn assign(&self, lhs: Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n+        Statement { source_info: self.source_info, kind: StatementKind::Assign(box (lhs, rhs)) }\n     }\n }"}, {"sha": "a1b7634f0c618f167fee2a991845756206aa3e41", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -265,7 +265,7 @@ pub fn dump_mir<'tcx>(\n     body: &Body<'tcx>,\n     result: &LivenessResult,\n ) {\n-    if !dump_enabled(tcx, pass_name, source) {\n+    if !dump_enabled(tcx, pass_name, source.def_id()) {\n         return;\n     }\n     let node_path = ty::print::with_forced_impl_filename_line(|| {"}, {"sha": "df7df6a0809b51b3d61c8e8f5b6da5991b8dfe89", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -78,21 +78,21 @@ pub fn dump_mir<'tcx, F>(\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n-    if !dump_enabled(tcx, pass_name, source) {\n+    if !dump_enabled(tcx, pass_name, source.def_id()) {\n         return;\n     }\n \n     dump_matched_mir_node(tcx, pass_num, pass_name, disambiguator, source, body, extra_data);\n }\n \n-pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, source: MirSource<'tcx>) -> bool {\n+pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, def_id: DefId) -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return false,\n         Some(ref filters) => filters,\n     };\n     let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.def_path_str(source.def_id())\n+        tcx.def_path_str(def_id)\n     });\n     filters.split('|').any(|or_filter| {\n         or_filter.split('&').all(|and_filter| {"}, {"sha": "8c41554bc85f97444ae2e245529faa9d3c57b14a", "filename": "src/librustc_mir_build/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -9,7 +9,7 @@ use rustc_span::Span;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn ast_block(\n         &mut self,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         block: BasicBlock,\n         ast_block: &'tcx hir::Block<'tcx>,\n         source_info: SourceInfo,\n@@ -43,7 +43,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn ast_block_stmts(\n         &mut self,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         mut block: BasicBlock,\n         span: Span,\n         stmts: Vec<StmtRef<'tcx>>,"}, {"sha": "f5828c4ac1fa12b800fc6c3a63cafdf18cc2ba2e", "filename": "src/librustc_mir_build/build/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fcfg.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -34,20 +34,20 @@ impl<'tcx> CFG<'tcx> {\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         rvalue: Rvalue<'tcx>,\n     ) {\n         self.push(\n             block,\n-            Statement { source_info, kind: StatementKind::Assign(box (*place, rvalue)) },\n+            Statement { source_info, kind: StatementKind::Assign(box (place, rvalue)) },\n         );\n     }\n \n     crate fn push_assign_constant(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n-        temp: &Place<'tcx>,\n+        temp: Place<'tcx>,\n         constant: Constant<'tcx>,\n     ) {\n         self.push_assign(block, source_info, temp, Rvalue::Use(Operand::Constant(box constant)));\n@@ -57,7 +57,7 @@ impl<'tcx> CFG<'tcx> {\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n     ) {\n         self.push_assign(\n             block,"}, {"sha": "9f74385b3368b1c13577c2c13e881200377d7cfa", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -341,12 +341,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(block, source_info, &len, Rvalue::Len(slice));\n+        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice));\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,\n             source_info,\n-            &lt,\n+            lt,\n             Rvalue::BinaryOp(BinOp::Lt, Operand::Copy(Place::from(index)), Operand::Copy(len)),\n         );\n         let msg = BoundsCheck { len: Operand::Move(len), index: Operand::Copy(Place::from(index)) };\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         self.cfg.push_assign(\n                             block,\n                             source_info,\n-                            &fake_borrow_temp.into(),\n+                            fake_borrow_temp.into(),\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,"}, {"sha": "20ef763e90cb4847f2e4f73c1a3f64b643cfaee9", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.cfg.push_assign(\n                         block,\n                         source_info,\n-                        &is_min,\n+                        is_min,\n                         Rvalue::BinaryOp(BinOp::Eq, arg.to_copy(), minval),\n                     );\n \n@@ -109,15 +109,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n-                this.cfg.push_assign(block, source_info, &Place::from(result), box_);\n+                this.cfg.push_assign(block, source_info, Place::from(result), box_);\n \n                 // initialize the box contents:\n                 unpack!(\n-                    block = this.into(\n-                        &this.hir.tcx().mk_place_deref(Place::from(result)),\n-                        block,\n-                        value\n-                    )\n+                    block =\n+                        this.into(this.hir.tcx().mk_place_deref(Place::from(result)), block, value)\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n@@ -284,7 +281,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.cfg.push_assign(\n                 block,\n                 source_info,\n-                &result_value,\n+                result_value,\n                 Rvalue::CheckedBinaryOp(op, lhs, rhs),\n             );\n             let val_fld = Field::new(0);\n@@ -317,7 +314,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_assign(\n                     block,\n                     source_info,\n-                    &is_zero,\n+                    is_zero,\n                     Rvalue::BinaryOp(BinOp::Eq, rhs.to_copy(), zero),\n                 );\n \n@@ -338,13 +335,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.cfg.push_assign(\n                         block,\n                         source_info,\n-                        &is_neg_1,\n+                        is_neg_1,\n                         Rvalue::BinaryOp(BinOp::Eq, rhs.to_copy(), neg_1),\n                     );\n                     self.cfg.push_assign(\n                         block,\n                         source_info,\n-                        &is_min,\n+                        is_min,\n                         Rvalue::BinaryOp(BinOp::Eq, lhs.to_copy(), min),\n                     );\n \n@@ -353,7 +350,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.cfg.push_assign(\n                         block,\n                         source_info,\n-                        &of,\n+                        of,\n                         Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min),\n                     );\n \n@@ -428,7 +425,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         this.cfg.push_assign(\n             block,\n             source_info,\n-            &Place::from(temp),\n+            Place::from(temp),\n             Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place),\n         );\n "}, {"sha": "73d95575e39d598a9558d1a13179ef2921103765", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             this.local_decls.push(local_decl)\n         };\n-        let temp_place = &Place::from(temp);\n+        let temp_place = Place::from(temp);\n \n         match expr.kind {\n             // Don't bother with StorageLive and Dead for these temporaries,"}, {"sha": "6b93755e9da7cec4c24ea4aa6d7ec2555dcd945d", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -16,7 +16,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// is assumed to be uninitialized.\n     crate fn into_expr(\n         &mut self,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n     ) -> BlockAnd<()> {\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // introduce a unit temporary as the destination for the loop body.\n                         let tmp = this.get_unit_temp();\n                         // Execute the body, branching back to the test.\n-                        let body_block_end = unpack!(this.into(&tmp, body_block, body));\n+                        let body_block_end = unpack!(this.into(tmp, body_block, body));\n                         this.cfg.goto(body_block_end, source_info, loop_block);\n                     },\n                 );\n@@ -202,8 +202,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         is_block_tail: None,\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n-                    let block = unpack!(this.into(&ptr_temp, block, ptr));\n-                    this.into(&this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n+                    let block = unpack!(this.into(ptr_temp, block, ptr));\n+                    this.into(this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             destination: if expr.ty.is_never() {\n                                 None\n                             } else {\n-                                Some((*destination, success))\n+                                Some((destination, success))\n                             },\n                             from_hir_call,\n                         },\n@@ -373,12 +373,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg.terminate(\n                     block,\n                     source_info,\n-                    TerminatorKind::Yield {\n-                        value,\n-                        resume,\n-                        resume_arg: *destination,\n-                        drop: cleanup,\n-                    },\n+                    TerminatorKind::Yield { value, resume, resume_arg: destination, drop: cleanup },\n                 );\n                 resume.unit()\n             }"}, {"sha": "92e1e10518506afff50a89c32cbaf91d2dd20d17", "filename": "src/librustc_mir_build/build/expr/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } else {\n                     let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_place(block, lhs));\n-                    this.cfg.push_assign(block, source_info, &lhs, rhs);\n+                    this.cfg.push_assign(block, source_info, lhs, rhs);\n                 }\n \n                 this.block_context.pop();\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     block =\n                         this.build_binary_op(block, op, expr_span, lhs_ty, Operand::Copy(lhs), rhs)\n                 );\n-                this.cfg.push_assign(block, source_info, &lhs, result);\n+                this.cfg.push_assign(block, source_info, lhs, result);\n \n                 this.block_context.pop();\n                 block.unit()"}, {"sha": "0baa0c833a514f8f2d8999ac637a1ee507b95e0e", "filename": "src/librustc_mir_build/build/into.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -12,15 +12,15 @@ pub(in crate::build) trait EvalInto<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         block: BasicBlock,\n     ) -> BlockAnd<()>;\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn into<E>(\n         &mut self,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         block: BasicBlock,\n         expr: E,\n     ) -> BlockAnd<()>\n@@ -35,7 +35,7 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n@@ -47,7 +47,7 @@ impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n         builder.into_expr(destination, block, self)"}, {"sha": "a98b18c0cf1d800bc52d78c465cdc8d75aa9de1f", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -10,16 +10,16 @@ use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::hair::{self, *};\n+use rustc_ast::ast::Name;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::HirId;\n+use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::layout::VariantIdx;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::HirId;\n-use rustc_index::bit_set::BitSet;\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n-use rustc_ast::ast::Name;\n \n // helper functions, broken out by category:\n mod simplify;\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// * From each otherwise block to the next prebinding block.\n     crate fn match_expr(\n         &mut self,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n         scrutinee: ExprRef<'tcx>,\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// `outer_source_info` is the SourceInfo for the whole match.\n     fn lower_match_arms(\n         &mut self,\n-        destination: &Place<'tcx>,\n+        destination: Place<'tcx>,\n         scrutinee_place: Place<'tcx>,\n         scrutinee_span: Span,\n         arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n@@ -364,7 +364,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(&place, block, initializer));\n+                unpack!(block = self.into(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(&place, block, initializer));\n+                unpack!(block = self.into(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -1691,7 +1691,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n             for &(place, temp) in fake_borrows {\n                 let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, place);\n-                self.cfg.push_assign(block, scrutinee_source_info, &Place::from(temp), borrow);\n+                self.cfg.push_assign(block, scrutinee_source_info, Place::from(temp), borrow);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n@@ -1858,7 +1858,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, binding.source);\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(borrow_kind) => {\n                     let value_for_arm = self.storage_live_binding(\n@@ -1870,9 +1870,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n \n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source);\n-                    self.cfg.push_assign(block, source_info, &value_for_arm, rvalue);\n+                    self.cfg.push_assign(block, source_info, value_for_arm, rvalue);\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, value_for_arm);\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, ref_for_guard, rvalue);\n                 }\n             }\n         }\n@@ -1910,7 +1910,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Rvalue::Ref(re_erased, borrow_kind, binding.source)\n                 }\n             };\n-            self.cfg.push_assign(block, source_info, &local, rvalue);\n+            self.cfg.push_assign(block, source_info, local, rvalue);\n         }\n     }\n "}, {"sha": "450bb0a861d74a1ca9fea80bf85f3379f04e5afd", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n-                self.cfg.push_assign(block, source_info, &discr, Rvalue::Discriminant(place));\n+                self.cfg.push_assign(block, source_info, discr, Rvalue::Discriminant(place));\n                 assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(\n                     block,\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n-                self.cfg.push_assign(block, source_info, &actual, Rvalue::Len(place));\n+                self.cfg.push_assign(block, source_info, actual, Rvalue::Len(place));\n \n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let result = self.temp(bool_ty, source_info.span);\n \n         // result = op(left, right)\n-        self.cfg.push_assign(block, source_info, &result, Rvalue::BinaryOp(op, left, right));\n+        self.cfg.push_assign(block, source_info, result, Rvalue::BinaryOp(op, left, right));\n \n         // branch based on result\n         self.cfg.terminate(\n@@ -394,7 +394,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.cfg.push_assign(\n                         block,\n                         source_info,\n-                        &temp,\n+                        temp,\n                         Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), val, ty),\n                     );\n                     val = Operand::Move(temp);\n@@ -404,7 +404,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.cfg.push_assign(\n                         block,\n                         source_info,\n-                        &slice,\n+                        slice,\n                         Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), expect, ty),\n                     );\n                     expect = Operand::Move(slice);"}, {"sha": "8f98dd9b70e806c876a5b7d8f6132cd502e6bcf9", "filename": "src/librustc_mir_build/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.push_assign_constant(\n             block,\n             source_info,\n-            &temp,\n+            temp,\n             Constant {\n                 span: source_info.span,\n                 user_ty: None,"}, {"sha": "cec7e5bc199666bce9467c0ee68b8820cdc088a0", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -663,7 +663,7 @@ fn construct_const<'a, 'tcx>(\n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Place::return_place(), block, expr));\n+    unpack!(block = builder.into_expr(Place::return_place(), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -969,7 +969,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::return_place(), block, body)\n+        self.into(Place::return_place(), block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "3689e5cb9d8a2d1912ecc1970ebb1f36bac5ffcf", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -520,10 +520,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(&destination, block, value));\n+                unpack!(block = self.into(destination, block, value));\n                 self.block_context.pop();\n             } else {\n-                self.cfg.push_assign_unit(block, source_info, &destination)\n+                self.cfg.push_assign_unit(block, source_info, destination)\n             }\n         } else {\n             assert!(value.is_none(), \"`return` and `break` should have a destination\");"}, {"sha": "96321ef2145e595fadfff8f78ab34f841a55f8c7", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -1,20 +1,20 @@\n use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::util::comments;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{error_code, DiagnosticBuilder, FatalError};\n-use rustc_lexer::unescape;\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n use rustc_lexer::Base;\n+use rustc_lexer::{unescape, LexRawStrError, UnvalidatedRawStr, ValidatedRawStr};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Pos, Span};\n \n use log::debug;\n use std::char;\n-use std::convert::TryInto;\n \n mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n+\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -373,30 +373,22 @@ impl<'a> StringReader<'a> {\n                 let id = self.symbol_from_to(content_start, content_end);\n                 (token::ByteStr, id)\n             }\n-            rustc_lexer::LiteralKind::RawStr { n_hashes, started, terminated } => {\n-                if !started {\n-                    self.report_non_started_raw_string(start);\n-                }\n-                if !terminated {\n-                    self.report_unterminated_raw_string(start, n_hashes)\n-                }\n-                let n_hashes: u16 = self.restrict_n_hashes(start, n_hashes);\n+            rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n+                let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n+                let n_hashes = valid_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n+\n                 let content_start = start + BytePos(2 + n);\n                 let content_end = suffix_start - BytePos(1 + n);\n                 self.validate_raw_str_escape(content_start, content_end);\n                 let id = self.symbol_from_to(content_start, content_end);\n                 (token::StrRaw(n_hashes), id)\n             }\n-            rustc_lexer::LiteralKind::RawByteStr { n_hashes, started, terminated } => {\n-                if !started {\n-                    self.report_non_started_raw_string(start);\n-                }\n-                if !terminated {\n-                    self.report_unterminated_raw_string(start, n_hashes)\n-                }\n-                let n_hashes: u16 = self.restrict_n_hashes(start, n_hashes);\n+            rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n+                let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n+                let n_hashes = validated_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n+\n                 let content_start = start + BytePos(3 + n);\n                 let content_end = suffix_start - BytePos(1 + n);\n                 self.validate_raw_byte_str_escape(content_start, content_end);\n@@ -482,6 +474,26 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    fn validate_and_report_errors(\n+        &self,\n+        start: BytePos,\n+        unvalidated_raw_str: UnvalidatedRawStr,\n+    ) -> ValidatedRawStr {\n+        match unvalidated_raw_str.validate() {\n+            Err(LexRawStrError::InvalidStarter) => self.report_non_started_raw_string(start),\n+            Err(LexRawStrError::NoTerminator { expected, found, possible_terminator_offset }) => {\n+                self.report_unterminated_raw_string(\n+                    start,\n+                    expected,\n+                    possible_terminator_offset,\n+                    found,\n+                )\n+            }\n+            Err(LexRawStrError::TooManyDelimiters) => self.report_too_many_hashes(start),\n+            Ok(valid) => valid,\n+        }\n+    }\n+\n     fn report_non_started_raw_string(&self, start: BytePos) -> ! {\n         let bad_char = self.str_from(start).chars().last().unwrap();\n         self.struct_fatal_span_char(\n@@ -495,38 +507,51 @@ impl<'a> StringReader<'a> {\n         FatalError.raise()\n     }\n \n-    fn report_unterminated_raw_string(&self, start: BytePos, n_hashes: usize) -> ! {\n+    fn report_unterminated_raw_string(\n+        &self,\n+        start: BytePos,\n+        n_hashes: usize,\n+        possible_offset: Option<usize>,\n+        found_terminators: usize,\n+    ) -> ! {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal_with_code(\n             self.mk_sp(start, start),\n             \"unterminated raw string\",\n             error_code!(E0748),\n         );\n+\n         err.span_label(self.mk_sp(start, start), \"unterminated raw string\");\n \n         if n_hashes > 0 {\n             err.note(&format!(\n                 \"this raw string should be terminated with `\\\"{}`\",\n-                \"#\".repeat(n_hashes as usize)\n+                \"#\".repeat(n_hashes)\n             ));\n         }\n \n+        if let Some(possible_offset) = possible_offset {\n+            let lo = start + BytePos(possible_offset as u32);\n+            let hi = lo + BytePos(found_terminators as u32);\n+            let span = self.mk_sp(lo, hi);\n+            err.span_suggestion(\n+                span,\n+                \"consider terminating the string here\",\n+                \"#\".repeat(n_hashes),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n         err.emit();\n         FatalError.raise()\n     }\n \n-    fn restrict_n_hashes(&self, start: BytePos, n_hashes: usize) -> u16 {\n-        match n_hashes.try_into() {\n-            Ok(n_hashes) => n_hashes,\n-            Err(_) => {\n-                self.fatal_span_(\n-                    start,\n-                    self.pos,\n-                    \"too many `#` symbols: raw strings may be \\\n-                                  delimited by up to 65535 `#` symbols\",\n-                )\n-                .raise();\n-            }\n-        }\n+    fn report_too_many_hashes(&self, start: BytePos) -> ! {\n+        self.fatal_span_(\n+            start,\n+            self.pos,\n+            \"too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\",\n+        )\n+        .raise();\n     }\n \n     fn validate_char_escape(&self, content_start: BytePos, content_end: BytePos) {"}, {"sha": "8e2a9513d6b829dffa8c962f4b47556f3fae703d", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -4,6 +4,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n #![feature(try_blocks)]\n+#![feature(or_patterns)]\n \n use rustc_ast::ast;\n use rustc_ast::token::{self, Nonterminal};"}, {"sha": "12b9b682682485038b7482c6abee3c4a568ba3f3", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ast::{\n };\n use rustc_ast::ast::{AttrVec, ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -255,6 +255,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        if self.check_too_many_raw_str_terminators(&mut err) {\n+            return Err(err);\n+        }\n+\n         let sm = self.sess.source_map();\n         if self.prev_token.span == DUMMY_SP {\n             // Account for macro context where the previous span might not be\n@@ -282,6 +286,29 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n+    fn check_too_many_raw_str_terminators(&mut self, err: &mut DiagnosticBuilder<'_>) -> bool {\n+        match (&self.prev_token.kind, &self.token.kind) {\n+            (\n+                TokenKind::Literal(Lit {\n+                    kind: LitKind::StrRaw(n_hashes) | LitKind::ByteStrRaw(n_hashes),\n+                    ..\n+                }),\n+                TokenKind::Pound,\n+            ) => {\n+                err.set_primary_message(\"too many `#` when terminating raw string\");\n+                err.span_suggestion(\n+                    self.token.span,\n+                    \"remove the extra `#`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                err.note(&format!(\"the raw string started with {} `#`s\", n_hashes));\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn maybe_annotate_with_ascription(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -491,7 +518,7 @@ impl<'a> Parser<'a> {\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n                     err.span_suggestion_verbose(\n-                            inner_op.span.shrink_to_hi(),\n+                        inner_op.span.shrink_to_hi(),\n                         \"split the comparison into two\",\n                         format!(\" && {}\", expr_to_str(&r1)),\n                         Applicability::MaybeIncorrect,\n@@ -1086,7 +1113,7 @@ impl<'a> Parser<'a> {\n             self.look_ahead(2, |t| t.is_ident())\n             || self.look_ahead(1, |t| t == &token::ModSep)\n                 && (self.look_ahead(2, |t| t.is_ident()) ||   // `foo:bar::baz`\n-             self.look_ahead(2, |t| t == &token::Lt)) // `foo:bar::<baz>`\n+            self.look_ahead(2, |t| t == &token::Lt)) // `foo:bar::<baz>`\n     }\n \n     pub(super) fn recover_seq_parse_error("}, {"sha": "432f1e17ab312c592d4df04d6e06c7a45009a5b5", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -835,6 +835,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"the directory the MIR is dumped into\"),\n     dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n         \"in addition to `.mir` files, create graphviz `.dot` files\"),\n+    dump_mir_dataflow: bool = (false, parse_bool, [UNTRACKED],\n+        \"in addition to `.mir` files, create graphviz `.dot` files with dataflow results\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n         \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n     mir_emit_retag: bool = (false, parse_bool, [TRACKED],"}, {"sha": "72768c31e3077444eb9f74f488718d07f8f3bb43", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -546,6 +546,8 @@ pub struct FnAbi<'a, Ty> {\n     pub fixed_count: usize,\n \n     pub conv: Conv,\n+\n+    pub can_unwind: bool,\n }\n \n impl<'a, Ty> FnAbi<'a, Ty> {"}, {"sha": "5a1d1be11b63362de0d48bd4dfeb4eba377f8849", "filename": "src/test/ui/parser/raw-str-unbalanced.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99009bf31992fb9257b84550dbf7cb509f987952/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99009bf31992fb9257b84550dbf7cb509f987952/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.rs?ref=99009bf31992fb9257b84550dbf7cb509f987952", "patch": "@@ -1,4 +0,0 @@\n-static s: &'static str =\n-    r#\"\n-      \"## //~ ERROR expected one of `.`, `;`, `?`, or an operator, found `#`\n-;"}, {"sha": "ddb75722bef9f32c37e39f6da7fcc4eebd8beda2", "filename": "src/test/ui/parser/raw-str-unbalanced.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99009bf31992fb9257b84550dbf7cb509f987952/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99009bf31992fb9257b84550dbf7cb509f987952/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.stderr?ref=99009bf31992fb9257b84550dbf7cb509f987952", "patch": "@@ -1,8 +0,0 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `#`\n-  --> $DIR/raw-str-unbalanced.rs:3:9\n-   |\n-LL |       \"##\n-   |         ^ expected one of `.`, `;`, `?`, or an operator\n-\n-error: aborting due to previous error\n-"}, {"sha": "b74907b72b0cfe182a6c46ad2ac719b67c811b80", "filename": "src/test/ui/parser/raw/raw-byte-string-eof.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-byte-string-eof.rs"}, {"sha": "a76668e8051b52c75daf1df79f3c8060611d8ddd", "filename": "src/test/ui/parser/raw/raw-byte-string-eof.stderr", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -2,7 +2,9 @@ error[E0748]: unterminated raw string\n   --> $DIR/raw-byte-string-eof.rs:2:5\n    |\n LL |     br##\"a\"#;\n-   |     ^ unterminated raw string\n+   |     ^      - help: consider terminating the string here: `##`\n+   |     |\n+   |     unterminated raw string\n    |\n    = note: this raw string should be terminated with `\"##`\n ", "previous_filename": "src/test/ui/parser/raw-byte-string-eof.stderr"}, {"sha": "163c8ac66b022ae8eb4aac851d8adc71027e05bb", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-byte-string-literals.rs"}, {"sha": "4076fe334e6533e3ddf1a697d9db181ef1e48512", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-byte-string-literals.stderr"}, {"sha": "2f13893cecd2f00a8bf73aeacb3e7db00aeeb642", "filename": "src/test/ui/parser/raw/raw-str-delim.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-str-delim.rs"}, {"sha": "8a04f99a126dadb7534b8f9faa8affc217ead99a", "filename": "src/test/ui/parser/raw/raw-str-delim.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-str-delim.stderr"}, {"sha": "462c2279f5c1c3791af6098c461d17d68ed2929d", "filename": "src/test/ui/parser/raw/raw-str-in-macro-call.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+macro_rules! m1 {\n+    ($tt:tt #) => ()\n+}\n+\n+macro_rules! m2 {\n+    ($tt:tt) => ()\n+}\n+\n+fn main() {\n+    m1!(r#\"abc\"##);\n+    m2!(r#\"abc\"#);\n+}"}, {"sha": "35f118f5ce6eed46af1e1b3a89f2be036f7204ea", "filename": "src/test/ui/parser/raw/raw-str-unbalanced.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -0,0 +1,4 @@\n+static s: &'static str =\n+    r#\"\n+      \"## //~ too many `#` when terminating raw string\n+;"}, {"sha": "bf8f3a7a5a4bd833cc012ec8f3cc23d5831945df", "filename": "src/test/ui/parser/raw/raw-str-unbalanced.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -0,0 +1,10 @@\n+error: too many `#` when terminating raw string\n+  --> $DIR/raw-str-unbalanced.rs:3:9\n+   |\n+LL |       \"##\n+   |         ^ help: remove the extra `#`\n+   |\n+   = note: the raw string started with 1 `#`s\n+\n+error: aborting due to previous error\n+"}, {"sha": "fd317295561f4084214b2babd523d4a7142f2831", "filename": "src/test/ui/parser/raw/raw-str-unterminated.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-str-unterminated.rs"}, {"sha": "077f763f154c589cd2f58e79a0e31552e8884a20", "filename": "src/test/ui/parser/raw/raw-str-unterminated.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw-str-unterminated.stderr"}, {"sha": "067332d2819bdcfae675a6a843a9b0a8682e9a1b", "filename": "src/test/ui/parser/raw/raw-string-2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x = r###\"here's a long string\"# \"# \"##;\n+    //~^ ERROR unterminated raw string\n+}"}, {"sha": "8bbac9d7bd0bd9a799e1b3326e9714e26d0a116d", "filename": "src/test/ui/parser/raw/raw-string-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -0,0 +1,11 @@\n+error[E0748]: unterminated raw string\n+  --> $DIR/raw-string-2.rs:2:13\n+   |\n+LL |     let x = r###\"here's a long string\"# \"# \"##;\n+   |             ^ unterminated raw string       -- help: consider terminating the string here: `###`\n+   |\n+   = note: this raw string should be terminated with `\"###`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0748`."}, {"sha": "84f07c4a941bc900a5e3db9f8ef1f11cd3bded58", "filename": "src/test/ui/parser/raw/raw-string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.rs?ref=235938d1acdd93d6641a741c81f64e415b786751", "previous_filename": "src/test/ui/parser/raw/raw_string.rs"}, {"sha": "b2b853a89e7510ba18d194074491a9fa53cf6685", "filename": "src/test/ui/parser/raw/raw-string.stderr", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/235938d1acdd93d6641a741c81f64e415b786751/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.stderr?ref=235938d1acdd93d6641a741c81f64e415b786751", "patch": "@@ -1,8 +1,10 @@\n error[E0748]: unterminated raw string\n-  --> $DIR/raw_string.rs:2:13\n+  --> $DIR/raw-string.rs:2:13\n    |\n LL |     let x = r##\"lol\"#;\n-   |             ^ unterminated raw string\n+   |             ^       - help: consider terminating the string here: `##`\n+   |             |\n+   |             unterminated raw string\n    |\n    = note: this raw string should be terminated with `\"##`\n ", "previous_filename": "src/test/ui/parser/raw/raw_string.stderr"}]}