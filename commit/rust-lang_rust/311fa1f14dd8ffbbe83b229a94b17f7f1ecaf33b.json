{"sha": "311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "node_id": "C_kwDOAAsO6NoAKDMxMWZhMWYxNGRkOGZmYmJlODNiMjI5YTk0YjE3ZjdmMWVjYWYzM2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T13:56:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T13:56:00Z"}, "message": "Auto merge of #89881 - Mark-Simulacrum:fieldless-fast, r=davidtwco\n\nAvoid generating empty closures for fieldless enum variants\n\nFor many enums, this avoids generating lots of tiny stubs that need to be codegen'd and then inlined and removed by LLVM. perf shows this to be a fairly small, but significant, win on rustc bootstrap time -- with minimal impact on runtime performance (which is at times even positive).", "tree": {"sha": "8c499d38adbac35b3b987b6968f932795fb6e890", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c499d38adbac35b3b987b6968f932795fb6e890"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "html_url": "https://github.com/rust-lang/rust/commit/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22c2d9ddbf356bcdb718e88ca6ee3665e1e42690", "url": "https://api.github.com/repos/rust-lang/rust/commits/22c2d9ddbf356bcdb718e88ca6ee3665e1e42690", "html_url": "https://github.com/rust-lang/rust/commit/22c2d9ddbf356bcdb718e88ca6ee3665e1e42690"}, {"sha": "3228603cce1bcb81a48171cf5e2083ee0cda7fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3228603cce1bcb81a48171cf5e2083ee0cda7fd9", "html_url": "https://github.com/rust-lang/rust/commit/3228603cce1bcb81a48171cf5e2083ee0cda7fd9"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "66e6b571beb2b84bbc1acf3961a372191259de75", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "patch": "@@ -247,13 +247,24 @@ fn encodable_body(\n                     })\n                     .collect();\n \n-                let result = quote! { ::rustc_serialize::Encoder::emit_enum_variant(\n-                    __encoder,\n-                   #variant_name,\n-                   #variant_idx,\n-                   #field_idx,\n-                   |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n-                ) };\n+                let result = if field_idx != 0 {\n+                    quote! {\n+                        ::rustc_serialize::Encoder::emit_enum_variant(\n+                            __encoder,\n+                            #variant_name,\n+                            #variant_idx,\n+                            #field_idx,\n+                            |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n+                        )\n+                    }\n+                } else {\n+                    quote! {\n+                        ::rustc_serialize::Encoder::emit_fieldless_enum_variant::<#variant_idx>(\n+                            __encoder,\n+                            #variant_name,\n+                        )\n+                    }\n+                };\n                 variant_idx += 1;\n                 result\n             });"}, {"sha": "df78e1bcbf63cca6cdbfbe0fae38fcc224364ad3", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "patch": "@@ -589,6 +589,13 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         }\n     }\n \n+    fn emit_fieldless_enum_variant<const ID: usize>(\n+        &mut self,\n+        name: &str,\n+    ) -> Result<(), Self::Error> {\n+        escape_str(self.writer, name)\n+    }\n+\n     fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n@@ -885,6 +892,13 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         }\n     }\n \n+    fn emit_fieldless_enum_variant<const ID: usize>(\n+        &mut self,\n+        name: &str,\n+    ) -> Result<(), Self::Error> {\n+        escape_str(self.writer, name)\n+    }\n+\n     fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,"}, {"sha": "96a2231b5906ac8235813276c4540c968971e875", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "patch": "@@ -58,6 +58,20 @@ pub trait Encoder {\n         f(self)\n     }\n \n+    // We put the field index in a const generic to allow the emit_usize to be\n+    // compiled into a more efficient form. In practice, the variant index is\n+    // known at compile-time, and that knowledge allows much more efficient\n+    // codegen than we'd otherwise get. LLVM isn't always able to make the\n+    // optimization that would otherwise be necessary here, likely due to the\n+    // multiple levels of inlining and const-prop that are needed.\n+    #[inline]\n+    fn emit_fieldless_enum_variant<const ID: usize>(\n+        &mut self,\n+        _v_name: &str,\n+    ) -> Result<(), Self::Error> {\n+        self.emit_usize(ID)\n+    }\n+\n     #[inline]\n     fn emit_enum_variant_arg<F>(&mut self, _first: bool, f: F) -> Result<(), Self::Error>\n     where"}]}