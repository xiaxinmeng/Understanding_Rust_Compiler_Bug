{"sha": "d889da43f8f55d2ca1a795915d2375342e2a520c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ODlkYTQzZjhmNTVkMmNhMWE3OTU5MTVkMjM3NTM0MmUyYTUyMGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-09T08:57:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-09T09:01:15Z"}, "message": "move MemoryData to memory.rs; remove all the Hashing stuff", "tree": {"sha": "e85ca7b397a15bf479ade19fe40685744ee82c29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85ca7b397a15bf479ade19fe40685744ee82c29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d889da43f8f55d2ca1a795915d2375342e2a520c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d889da43f8f55d2ca1a795915d2375342e2a520c", "html_url": "https://github.com/rust-lang/rust/commit/d889da43f8f55d2ca1a795915d2375342e2a520c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d889da43f8f55d2ca1a795915d2375342e2a520c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72918c1a97458fb30163677af8dfb4fb573cdeb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/72918c1a97458fb30163677af8dfb4fb573cdeb6", "html_url": "https://github.com/rust-lang/rust/commit/72918c1a97458fb30163677af8dfb4fb573cdeb6"}], "stats": {"total": 116, "additions": 45, "deletions": 71}, "files": [{"sha": "6758cbeb953947223f94ee2d6967a4ef967ff458", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 70, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d889da43f8f55d2ca1a795915d2375342e2a520c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889da43f8f55d2ca1a795915d2375342e2a520c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d889da43f8f55d2ca1a795915d2375342e2a520c", "patch": "@@ -18,14 +18,11 @@ use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n-use rustc_data_structures::fx::FxHasher;\n-\n use syntax::ast::Mutability;\n use syntax::attr;\n \n use std::marker::PhantomData;\n-use std::collections::{HashMap, BTreeMap};\n-use std::hash::{Hash, Hasher};\n+use std::collections::HashMap;\n \n pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n@@ -43,7 +40,7 @@ use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n use tls::EvalContextExt as TlsEvalContextExt;\n-use memory::MemoryKind as MiriMemoryKind;\n+use memory::{MemoryKind as MiriMemoryKind, TlsKey, TlsEntry, MemoryData};\n use locks::LockInfo;\n use range_map::RangeMap;\n use helpers::FalibleScalarExt;\n@@ -214,75 +211,12 @@ pub struct Evaluator<'tcx> {\n     _dummy : PhantomData<&'tcx ()>,\n }\n \n-impl<'tcx> Hash for Evaluator<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let Evaluator {\n-            env_vars,\n-            _dummy: _,\n-        } = self;\n-\n-        env_vars.iter()\n-            .map(|(env, ptr)| {\n-                let mut h = FxHasher::default();\n-                env.hash(&mut h);\n-                ptr.hash(&mut h);\n-                h.finish()\n-            })\n-            .fold(0u64, |acc, hash| acc.wrapping_add(hash))\n-            .hash(state);\n-    }\n-}\n-\n-pub type TlsKey = u128;\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct TlsEntry<'tcx> {\n-    data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq)]\n-pub struct MemoryData<'tcx> {\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// Memory regions that are locked by some function\n-    ///\n-    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n-    /// The entry is created when allocating the memory and deleted after deallocation.\n-    locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n-}\n-\n-impl<'tcx> MemoryData<'tcx> {\n-    fn new() -> Self {\n-        MemoryData {\n-            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n-            thread_local: BTreeMap::new(),\n-            locks: HashMap::new(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Hash for MemoryData<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let MemoryData {\n-            next_thread_local: _,\n-            thread_local,\n-            locks: _,\n-        } = self;\n-\n-        thread_local.hash(state);\n-    }\n-}\n-\n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryData = MemoryData<'tcx>;\n+    type MemoryData = memory::MemoryData<'tcx>;\n     type MemoryKinds = memory::MemoryKind;\n \n     const MUT_STATIC_KIND: Option<memory::MemoryKind> = Some(memory::MemoryKind::MutStatic);\n+    const DETECT_LOOPS: bool = false;\n \n     /// Returns Ok() when the function was handled, fail otherwise\n     fn find_fn<'a>("}, {"sha": "9f8118a223bc24b9b2a04abd163b69f3d78d146f", "filename": "src/memory.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d889da43f8f55d2ca1a795915d2375342e2a520c/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889da43f8f55d2ca1a795915d2375342e2a520c/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d889da43f8f55d2ca1a795915d2375342e2a520c", "patch": "@@ -1,4 +1,44 @@\n-#[derive(Debug, PartialEq, Copy, Clone, Hash, Eq)]\n+use std::collections::{HashMap, BTreeMap};\n+\n+use rustc::ty;\n+\n+use super::{AllocId, Scalar, LockInfo, RangeMap};\n+\n+pub type TlsKey = u128;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct TlsEntry<'tcx> {\n+    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct MemoryData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    pub(crate) next_thread_local: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    pub(crate) thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// Memory regions that are locked by some function\n+    ///\n+    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n+    /// The entry is created when allocating the memory and deleted after deallocation.\n+    pub(crate) locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n+}\n+\n+impl<'tcx> MemoryData<'tcx> {\n+    pub(crate) fn new() -> Self {\n+        MemoryData {\n+            next_thread_local: 1, // start with 1 as we must not use 0 on Windows\n+            thread_local: BTreeMap::new(),\n+            locks: HashMap::new(),\n+        }\n+    }\n+}\n+\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MemoryKind {\n     /// `__rust_alloc` memory\n     Rust,"}]}