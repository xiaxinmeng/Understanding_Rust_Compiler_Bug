{"sha": "dc4560dc26498573516d833cb2333b54071070e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNDU2MGRjMjY0OTg1NzM1MTZkODMzY2IyMzMzYjU0MDcxMDcwZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-22T02:19:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-22T02:19:58Z"}, "message": "auto merge of #7182 : Aatch/rust/trans-refactor-pt2, r=graydon\n\nThis is another big refactoring of `trans` though this is unlikely to have much of an\r\nimpact on code size or speed.\r\n\r\nThe major change here is the implementation of a `Type` struct which is the new\r\nhome for all your LLVM `TypeRef` needs. It's a simple wrapper struct, with static\r\nmethods for constructing types, then regular methods for\r\nmanipulating/interrogating them. The purpose of this is mostly to make the code\r\nsurrounding them somewhat more ideomatic. A line like: `T_ptr(T_ptr(T_i8()))` is \r\nnow `Type::i8().ptr_to().ptr_to()`,which is much more like regular Rust code.\r\n\r\nThere are a variety of smaller changes here and there:\r\n\r\n* Remove address spaces. At least it doesn't generate them, I haven't spent much\r\n  time looking for related code.\r\n* Use a macro for declaring the LLVM intrinsics, makes it look much nicer.\r\n* Make the type for a string slice actually create a named `str_slice` type in LLVM,\r\n  this makes reading the appropriate code much easier.\r\n* Change the way struct and enum type names are generated. This just means\r\n  that a struct like `struct Foo { a: int }` now produces the IR \r\n  `%struct.Foo = type { i64 }`, which is much easier to read. Similarly, other structs\r\n  are a bit tighter to make it easier to read.\r\n\r\n--- --- ---\r\n\r\nThis PR did get away from me a little, as I occasionally got distracted or as I fixed\r\nup problems with unrelated code that were stopping me from continuing. One major\r\nthing is that this PR contains the work from #7168, since that would have conflicted\r\nwith this and it was broken anyway. Sorry for bundling it like this.\r\n\r\nFixes #3670 and #7063\r\n\r\n--- --- ---\r\n\r\nEDIT: This no longer removes the llvm insn stats.", "tree": {"sha": "1eb6fd5ae7a3a58b350fcc8e22984589d325baf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eb6fd5ae7a3a58b350fcc8e22984589d325baf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc4560dc26498573516d833cb2333b54071070e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4560dc26498573516d833cb2333b54071070e3", "html_url": "https://github.com/rust-lang/rust/commit/dc4560dc26498573516d833cb2333b54071070e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc4560dc26498573516d833cb2333b54071070e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f886520d2468507cc80ceb40a26594265052603e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f886520d2468507cc80ceb40a26594265052603e", "html_url": "https://github.com/rust-lang/rust/commit/f886520d2468507cc80ceb40a26594265052603e"}, {"sha": "e3ef7504e9496f72820af55f8b9838ec0f54d9f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ef7504e9496f72820af55f8b9838ec0f54d9f0", "html_url": "https://github.com/rust-lang/rust/commit/e3ef7504e9496f72820af55f8b9838ec0f54d9f0"}], "stats": {"total": 5293, "additions": 2496, "deletions": 2797}, "files": [{"sha": "76bba481619859677b262aeb1626d6d537c8b3c3", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -11,8 +11,8 @@\n \n use driver::session;\n use middle::trans::base;\n-use middle::trans::common::{T_fn, T_i8, T_i32, T_int, T_ptr, T_void};\n-use lib::llvm::{ModuleRef, ValueRef, TypeRef};\n+use middle::trans::type_::Type;\n+use lib::llvm::{ModuleRef, ValueRef};\n \n pub struct Upcalls {\n     trace: ValueRef,\n@@ -22,40 +22,35 @@ pub struct Upcalls {\n     reset_stack_limit: ValueRef\n }\n \n-pub fn declare_upcalls(targ_cfg: @session::config,\n-                       llmod: ModuleRef) -> @Upcalls {\n-    fn decl(llmod: ModuleRef, prefix: ~str, name: ~str,\n-            tys: ~[TypeRef], rv: TypeRef) ->\n-       ValueRef {\n-        let arg_tys = tys.map(|t| *t);\n-        let fn_ty = T_fn(arg_tys, rv);\n-        return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n-    }\n-    fn nothrow(f: ValueRef) -> ValueRef {\n-        base::set_no_unwind(f); f\n-    }\n-    let d: &fn(a: ~str, b: ~[TypeRef], c: TypeRef) -> ValueRef =\n-        |a,b,c| decl(llmod, ~\"upcall_\", a, b, c);\n-    let dv: &fn(a: ~str, b: ~[TypeRef]) -> ValueRef =\n-        |a,b| decl(llmod, ~\"upcall_\", a, b, T_void());\n+macro_rules! upcall (\n+    (fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n+        let fn_ty = Type::func([ $($arg),* ], &$ret);\n+        base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty)\n+    });\n+    (nothrow fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n+        let fn_ty = Type::func([ $($arg),* ], &$ret);\n+        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n+        base::set_no_unwind(decl);\n+        decl\n+    });\n+    (nothrow fn $name:ident -> $ret:expr) => ({\n+        let fn_ty = Type::func([], &$ret);\n+        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n+        base::set_no_unwind(decl);\n+        decl\n+    })\n+)\n \n-    let int_t = T_int(targ_cfg);\n+pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls {\n+    let opaque_ptr = Type::i8().ptr_to();\n+    let int_ty = Type::int(targ_cfg.arch);\n \n     @Upcalls {\n-        trace: dv(~\"trace\", ~[T_ptr(T_i8()),\n-                              T_ptr(T_i8()),\n-                              int_t]),\n-        call_shim_on_c_stack:\n-            d(~\"call_shim_on_c_stack\",\n-              // arguments: void *args, void *fn_ptr\n-              ~[T_ptr(T_i8()), T_ptr(T_i8())],\n-              int_t),\n+        trace: upcall!(fn trace(opaque_ptr, opaque_ptr, int_ty) -> Type::void()),\n+        call_shim_on_c_stack: upcall!(fn call_shim_on_c_stack(opaque_ptr, opaque_ptr) -> int_ty),\n         call_shim_on_rust_stack:\n-            d(~\"call_shim_on_rust_stack\",\n-              ~[T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n-        rust_personality:\n-            nothrow(d(~\"rust_personality\", ~[], T_i32())),\n-        reset_stack_limit:\n-            nothrow(dv(~\"reset_stack_limit\", ~[]))\n+            upcall!(fn call_shim_on_rust_stack(opaque_ptr, opaque_ptr) -> int_ty),\n+        rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n+        reset_stack_limit: upcall!(nothrow fn reset_stack_limit -> Type::void())\n     }\n }"}, {"sha": "4bc96117ff51aa7ae63a5144910ce9f59be73f41", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 70, "deletions": 135, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -13,9 +13,9 @@ use core::prelude::*;\n use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ushort};\n use core::option;\n-use core::ptr;\n use core::str;\n-use core::vec;\n+\n+use middle::trans::type_::Type;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -2121,155 +2121,90 @@ pub fn ConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    type_names: @mut HashMap<TypeRef, @str>,\n-    named_types: @mut HashMap<@str, TypeRef>\n-}\n-\n-pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n-    assert!(tn.type_names.insert(t, s));\n-    assert!(tn.named_types.insert(s, t));\n-}\n-\n-pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {\n-    return tn.type_names.find(&t).map_consume(|x| *x);\n+    type_names: HashMap<TypeRef, ~str>,\n+    named_types: HashMap<~str, TypeRef>\n }\n \n-pub fn name_has_type(tn: @TypeNames, s: @str) -> Option<TypeRef> {\n-    return tn.named_types.find(&s).map_consume(|x| *x);\n-}\n-\n-pub fn mk_type_names() -> @TypeNames {\n-    @TypeNames {\n-        type_names: @mut HashMap::new(),\n-        named_types: @mut HashMap::new()\n+impl TypeNames {\n+    pub fn new() -> TypeNames {\n+        TypeNames {\n+            type_names: HashMap::new(),\n+            named_types: HashMap::new()\n+        }\n     }\n-}\n \n-pub fn type_to_str(names: @TypeNames, ty: TypeRef) -> @str {\n-    return type_to_str_inner(names, [], ty);\n-}\n+    pub fn associate_type(&mut self, s: &str, t: &Type) {\n+        assert!(self.type_names.insert(t.to_ref(), s.to_owned()));\n+        assert!(self.named_types.insert(s.to_owned(), t.to_ref()));\n+    }\n \n-pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n-                      -> @str {\n-    unsafe {\n-        match type_has_name(names, ty) {\n-          option::Some(n) => return n,\n-          _ => {}\n+    pub fn find_name<'r>(&'r self, ty: &Type) -> Option<&'r str> {\n+        match self.type_names.find(&ty.to_ref()) {\n+            Some(a) => Some(a.slice(0, a.len())),\n+            None => None\n         }\n+    }\n \n-        let outer = vec::append_one(outer0.to_owned(), ty);\n-\n-        let kind = llvm::LLVMGetTypeKind(ty);\n+    pub fn find_type(&self, s: &str) -> Option<Type> {\n+        self.named_types.find_equiv(&s).map_consume(|x| Type::from_ref(*x))\n+    }\n \n-        fn tys_str(names: @TypeNames, outer: &[TypeRef],\n-                   tys: ~[TypeRef]) -> @str {\n-            let mut s = ~\"\";\n-            let mut first: bool = true;\n-            for tys.each |t| {\n-                if first { first = false; } else { s += \", \"; }\n-                s += type_to_str_inner(names, outer, *t);\n-            }\n-            // [Note at-str] FIXME #2543: Could rewrite this without the copy,\n-            // but need better @str support.\n-            return s.to_managed();\n+    pub fn type_to_str(&self, ty: Type) -> ~str {\n+        match self.find_name(&ty) {\n+            option::Some(name) => return name.to_owned(),\n+            None => ()\n         }\n \n-        match kind {\n-          Void => return @\"Void\",\n-          Half => return @\"Half\",\n-          Float => return @\"Float\",\n-          Double => return @\"Double\",\n-          X86_FP80 => return @\"X86_FP80\",\n-          FP128 => return @\"FP128\",\n-          PPC_FP128 => return @\"PPC_FP128\",\n-          Label => return @\"Label\",\n-          Integer => {\n-            // See [Note at-str]\n-            return fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty)\n-                        as int).to_managed();\n-          }\n-          Function => {\n-            let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n-            let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n-            let args = vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n-            // See [Note at-str]\n-            return fmt!(\"fn(%s) -> %s\",\n-                        tys_str(names, outer, args),\n-                        type_to_str_inner(names, outer, out_ty)).to_managed();\n-          }\n-          Struct => {\n-            let elts = struct_tys(ty);\n-            // See [Note at-str]\n-            return fmt!(\"{%s}\", tys_str(names, outer, elts)).to_managed();\n-          }\n-          Array => {\n-            let el_ty = llvm::LLVMGetElementType(ty);\n-            // See [Note at-str]\n-            return fmt!(\"[%s@ x %u\", type_to_str_inner(names, outer, el_ty),\n-                llvm::LLVMGetArrayLength(ty) as uint).to_managed();\n-          }\n-          Pointer => {\n-            let mut i = 0;\n-            for outer0.each |tout| {\n-                i += 1;\n-                if *tout as int == ty as int {\n-                    let n = outer0.len() - i;\n-                    // See [Note at-str]\n-                    return fmt!(\"*\\\\%d\", n as int).to_managed();\n+        unsafe {\n+            let kind = ty.kind();\n+\n+            match kind {\n+                Void => ~\"Void\",\n+                Half => ~\"Half\",\n+                Double => ~\"Double\",\n+                X86_FP80 => ~\"X86_FP80\",\n+                FP128 => ~\"FP128\",\n+                PPC_FP128 => ~\"PPC_FP128\",\n+                Label => ~\"Label\",\n+                Vector => ~\"Vector\",\n+                Metadata => ~\"Metadata\",\n+                X86_MMX => ~\"X86_MMAX\",\n+                Integer => {\n+                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n                 }\n-            }\n-            let addrstr = {\n-                let addrspace = llvm::LLVMGetPointerAddressSpace(ty) as uint;\n-                if addrspace == 0 {\n-                    ~\"\"\n-                } else {\n-                    fmt!(\"addrspace(%u)\", addrspace)\n+                Function => {\n+                    let out_ty = ty.return_type();\n+                    let args = ty.func_params();\n+                    let args = args.map(|&ty| self.type_to_str(ty)).connect(\", \");\n+                    let out_ty = self.type_to_str(out_ty);\n+                    fmt!(\"fn(%s) -> %s\", args, out_ty)\n+                }\n+                Struct => {\n+                    let tys = ty.field_types();\n+                    let tys = tys.map(|&ty| self.type_to_str(ty)).connect(\", \");\n+                    fmt!(\"{%s}\", tys)\n+                }\n+                Array => {\n+                    let el_ty = ty.element_type();\n+                    let el_ty = self.type_to_str(el_ty);\n+                    let len = ty.array_length();\n+                    fmt!(\"[%s x %u]\", el_ty, len)\n+                }\n+                Pointer => {\n+                    let el_ty = ty.element_type();\n+                    let el_ty = self.type_to_str(el_ty);\n+                    fmt!(\"*%s\", el_ty)\n                 }\n-            };\n-            // See [Note at-str]\n-            return fmt!(\"%s*%s\", addrstr, type_to_str_inner(names,\n-                        outer,\n-                        llvm::LLVMGetElementType(ty))).to_managed();\n-          }\n-          Vector => return @\"Vector\",\n-          Metadata => return @\"Metadata\",\n-          X86_MMX => return @\"X86_MMAX\",\n-          _ => fail!()\n+                _ => fail!(\"Unknown Type Kind (%u)\", kind as uint)\n+            }\n         }\n     }\n-}\n-\n-pub fn float_width(llt: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(llt) as int {\n-              1 => 32u,\n-              2 => 64u,\n-              3 => 80u,\n-              4 | 5 => 128u,\n-              _ => fail!(\"llvm_float_width called on a non-float type\")\n-            };\n-    }\n-}\n-\n-pub fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let args = vec::from_elem(llvm::LLVMCountParamTypes(fn_ty) as uint,\n-                                 0 as TypeRef);\n-        llvm::LLVMGetParamTypes(fn_ty, vec::raw::to_ptr(args));\n-        return args;\n-    }\n-}\n \n-pub fn struct_tys(struct_ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let n_elts = llvm::LLVMCountStructElementTypes(struct_ty) as uint;\n-        if n_elts == 0 {\n-            return ~[];\n+    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n+        unsafe {\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(val));\n+            self.type_to_str(ty)\n         }\n-        let mut elts = vec::from_elem(n_elts, ptr::null());\n-        llvm::LLVMGetStructElementTypes(struct_ty, &mut elts[0]);\n-        return elts;\n     }\n }\n "}, {"sha": "ffb7a1daf3593a3871b1d2b4e214722f88933c96", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -50,7 +50,7 @@ use core::prelude::*;\n \n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{ty_to_str, region_to_str, Repr};\n+use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n use util::common::indenter;\n \n use core::uint;\n@@ -1026,7 +1026,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn region_to_str(&self, r: ty::Region) -> ~str {\n-        region_to_str(self.tcx, r)\n+        region_ptr_to_str(self.tcx, r)\n     }\n }\n "}, {"sha": "a6e8cf666daea630eb0dbd68391ac30ea5f525ad", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -259,7 +259,7 @@ pub enum opt_result {\n     range_result(Result, Result),\n }\n pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n-    let _icx = bcx.insn_ctxt(\"match::trans_opt\");\n+    let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n     match *o {\n@@ -381,7 +381,7 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     do m.map |br| {\n@@ -428,7 +428,7 @@ pub fn enter_match<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let mut result = ~[];\n@@ -474,7 +474,7 @@ pub fn enter_default<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n@@ -521,7 +521,7 @@ pub fn enter_opt<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n@@ -632,7 +632,7 @@ pub fn enter_rec_or_struct<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n@@ -667,7 +667,7 @@ pub fn enter_tup<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n@@ -695,7 +695,7 @@ pub fn enter_tuple_struct<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n@@ -720,7 +720,7 @@ pub fn enter_box<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n@@ -747,7 +747,7 @@ pub fn enter_uniq<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n@@ -774,7 +774,7 @@ pub fn enter_region<'r>(bcx: block,\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n            col,\n-           bcx.val_str(val));\n+           bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let dummy = @ast::pat { id: 0, node: ast::pat_wild, span: dummy_sp() };\n@@ -870,7 +870,7 @@ pub fn extract_variant_args(bcx: block,\n                             disr_val: int,\n                             val: ValueRef)\n     -> ExtractedBlock {\n-    let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n+    let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     };\n@@ -896,7 +896,7 @@ pub fn extract_vec_elems(bcx: block,\n                          val: ValueRef,\n                          count: ValueRef)\n                       -> ExtractedBlock {\n-    let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n+    let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n     let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span,\n                                                           pat_id, 0);\n@@ -911,7 +911,7 @@ pub fn extract_vec_elems(bcx: block,\n                     Sub(bcx, count,\n                         C_int(bcx.ccx(), (elem_count - i) as int))])\n             }\n-            _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty) }\n+            _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n         }\n     };\n     if slice.is_some() {\n@@ -1088,7 +1088,7 @@ pub fn compare_values(cx: block,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n                    -> Result {\n-    let _icx = cx.insn_ctxt(\"compare_values\");\n+    let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::eq);\n       return rslt(rs.bcx, rs.val);\n@@ -1202,9 +1202,7 @@ fn insert_lllocals(bcx: block,\n             }\n         };\n \n-        debug!(\"binding %? to %s\",\n-               binding_info.id,\n-               val_str(bcx.ccx().tn, llval));\n+        debug!(\"binding %? to %s\", binding_info.id, bcx.val_to_str(llval));\n         llmap.insert(binding_info.id, llval);\n     }\n     return bcx;\n@@ -1221,7 +1219,7 @@ pub fn compile_guard(bcx: block,\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n            matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_str(*v)));\n+           vals.map(|v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n     let mut bcx = bcx;\n@@ -1272,14 +1270,14 @@ pub fn compile_submatch(bcx: block,\n     debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_str(*v)));\n+           vals.map(|v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n     /*\n       For an empty match, a fall-through case must exist\n      */\n     assert!((m.len() > 0u || chk.is_some()));\n-    let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n+    let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n     let dm = tcx.def_map;\n@@ -1391,19 +1389,15 @@ pub fn compile_submatch(bcx: block,\n     if any_box_pat(m, col) {\n         bcx = root_pats_as_necessary(bcx, m, col, val);\n         let llbox = Load(bcx, val);\n-        let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n-        let unboxed =\n-            GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n+        let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk);\n         return;\n     }\n \n     if any_uniq_pat(m, col) {\n         let llbox = Load(bcx, val);\n-        let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n-        let unboxed =\n-            GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n+        let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk);\n         return;\n@@ -1619,7 +1613,7 @@ pub fn trans_match(bcx: block,\n                    discr_expr: @ast::expr,\n                    arms: ~[ast::arm],\n                    dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"match::trans_match\");\n+    let _icx = push_ctxt(\"match::trans_match\");\n     do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n@@ -1646,7 +1640,7 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n                 // but during matching we need to store a *T as explained\n                 // above\n                 let is_move = ccx.maps.moves_map.contains(&p_id);\n-                llmatch = alloca(bcx, T_ptr(llvariable_ty));\n+                llmatch = alloca(bcx, llvariable_ty.ptr_to());\n                 trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n             }\n             ast::bind_by_ref(_) => {\n@@ -1666,7 +1660,7 @@ pub fn trans_match_inner(scope_cx: block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n                          dest: Dest) -> block {\n-    let _icx = scope_cx.insn_ctxt(\"match::trans_match_inner\");\n+    let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n \n@@ -1753,7 +1747,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             make_copy: bool,\n                             binding_mode: IrrefutablePatternBindingMode)\n                          -> block {\n-    let _icx = bcx.insn_ctxt(\"match::bind_irrefutable_pat\");\n+    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n "}, {"sha": "906c9d028ebc619d7152195f97b65944a44bfa5d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -49,7 +49,7 @@ use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n \n-use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n+use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -59,6 +59,8 @@ use middle::ty;\n use syntax::ast;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n \n /// Representations.\n pub enum Repr {\n@@ -212,7 +214,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n \n fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n-    let llty_rec = T_struct(lltys, packed);\n+    let llty_rec = Type::struct_(lltys, packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n@@ -226,17 +228,16 @@ fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n  * All nominal types are LLVM structs, in order to be able to use\n  * forward-declared opaque types to prevent circularity in `type_of`.\n  */\n-pub fn fields_of(cx: &mut CrateContext, r: &Repr) -> ~[TypeRef] {\n+pub fn fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n     generic_fields_of(cx, r, false)\n }\n /// Like `fields_of`, but for `type_of::sizing_type_of` (q.v.).\n-pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[TypeRef] {\n+pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n     generic_fields_of(cx, r, true)\n }\n-fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool)\n-    -> ~[TypeRef] {\n+fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n     match *r {\n-        CEnum(*) => ~[T_enum_discrim(cx)],\n+        CEnum(*) => ~[Type::enum_discrim(cx)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n         NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n         General(ref sts) => {\n@@ -262,13 +263,12 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool)\n             let padding = largest_size - most_aligned.size;\n \n             struct_llfields(cx, most_aligned, sizing)\n-                + [T_array(T_i8(), padding /*bad*/as uint)]\n+                + [Type::array(&Type::i8(), padding)]\n         }\n     }\n }\n \n-fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool)\n-    -> ~[TypeRef] {\n+fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n     } else {\n@@ -309,7 +309,7 @@ pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n                                          (cases.len() - 1) as int),\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n-                 T_enum_discrim(bcx.ccx()))\n+                 Type::enum_discrim(bcx.ccx()))\n         }\n     }\n }\n@@ -438,11 +438,11 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             } else {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n-                let llty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n-                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), llty), 0);\n+                let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n+                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n                 // The contents of memory at this pointer can't matter, but use\n                 // the value that's \"reasonable\" in case of pointer comparison.\n-                PointerCast(bcx, val, T_ptr(llty))\n+                PointerCast(bcx, val, ty.ptr_to())\n             }\n         }\n     }\n@@ -456,8 +456,8 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n         let fields = do st.fields.map |&ty| {\n             type_of::type_of(ccx, ty)\n         };\n-        let real_llty = T_struct(fields, st.packed);\n-        PointerCast(bcx, val, T_ptr(real_llty))\n+        let real_ty = Type::struct_(fields, st.packed);\n+        PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n     };\n@@ -572,7 +572,7 @@ fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n }\n \n fn padding(size: u64) -> ValueRef {\n-    C_undef(T_array(T_i8(), size /*bad*/as uint))\n+    C_undef(Type::array(&Type::i8(), size))\n }\n \n // XXX this utility routine should be somewhere more general"}, {"sha": "dd8b7ebc00b74c47cbf66f4cc0da720df00bc277", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -20,6 +20,8 @@ use middle::trans::callee;\n use middle::trans::common::*;\n use middle::ty;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use syntax::ast;\n \n@@ -110,11 +112,11 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     // Depending on how many outputs we have, the return type is different\n     let output = if numOutputs == 0 {\n-        T_void()\n+        Type::void()\n     } else if numOutputs == 1 {\n         val_ty(outputs[0])\n     } else {\n-        T_struct(outputs.map(|o| val_ty(*o)), false)\n+        Type::struct_(outputs.map(|o| val_ty(*o)), false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -130,12 +132,12 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     // Again, based on how many outputs we have\n     if numOutputs == 1 {\n-        let op = PointerCast(bcx, aoutputs[0], T_ptr(val_ty(outputs[0])));\n+        let op = PointerCast(bcx, aoutputs[0], val_ty(outputs[0]).ptr_to());\n         Store(bcx, r, op);\n     } else {\n         for aoutputs.iter().enumerate().advance |(i, o)| {\n             let v = ExtractValue(bcx, r, i);\n-            let op = PointerCast(bcx, *o, T_ptr(val_ty(outputs[i])));\n+            let op = PointerCast(bcx, *o, val_ty(outputs[i]).ptr_to());\n             Store(bcx, v, op);\n         }\n     }"}, {"sha": "7132af24d45a44defe3994730fb938d80504a8ed", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 265, "deletions": 456, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -29,8 +29,8 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n-use lib::llvm::{llvm, True, False};\n+use lib::llvm::{ContextRef, ModuleRef, ValueRef, BasicBlockRef};\n+use lib::llvm::{llvm, True};\n use lib;\n use metadata::common::LinkMeta;\n use metadata::{csearch, cstore, encoder};\n@@ -63,6 +63,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n \n+use middle::trans::type_::Type;\n+\n use core::hash;\n use core::hashmap::{HashMap};\n use core::int;\n@@ -71,6 +73,7 @@ use core::libc::c_uint;\n use core::str;\n use core::uint;\n use core::vec;\n+use core::local_data;\n use extra::time;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n@@ -86,49 +89,52 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::task_llcx;\n \n-pub struct icx_popper {\n-    ccx: @mut CrateContext,\n-}\n+fn task_local_insn_key(_v: @~[&'static str]) {}\n \n-#[unsafe_destructor]\n-impl Drop for icx_popper {\n-    fn finalize(&self) {\n-        if self.ccx.sess.count_llvm_insns() {\n-            self.ccx.stats.llvm_insn_ctxt.pop();\n+pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n+    unsafe {\n+        let opt = local_data::local_data_get(task_local_insn_key);\n+        if opt.is_some() {\n+            blk(*opt.unwrap());\n         }\n     }\n }\n \n-pub fn icx_popper(ccx: @mut CrateContext) -> icx_popper {\n-    icx_popper {\n-        ccx: ccx\n+pub fn init_insn_ctxt() {\n+    unsafe {\n+        local_data::local_data_set(task_local_insn_key, @~[]);\n     }\n }\n \n-pub trait get_insn_ctxt {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper;\n-}\n+pub struct _InsnCtxt { _x: () }\n \n-impl get_insn_ctxt for @mut CrateContext {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper {\n-        debug!(\"new insn_ctxt: %s\", s);\n-        if self.sess.count_llvm_insns() {\n-            self.stats.llvm_insn_ctxt.push(str::to_owned(s));\n+#[unsafe_destructor]\n+impl Drop for _InsnCtxt {\n+    fn finalize(&self) {\n+        unsafe {\n+            do local_data::local_data_modify(task_local_insn_key) |c| {\n+                do c.map_consume |@ctx| {\n+                    let mut ctx = ctx;\n+                    ctx.pop();\n+                    @ctx\n+                }\n+            }\n         }\n-        icx_popper(*self)\n-    }\n-}\n-\n-impl get_insn_ctxt for block {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper {\n-        self.ccx().insn_ctxt(s)\n     }\n }\n \n-impl get_insn_ctxt for fn_ctxt {\n-    fn insn_ctxt(&self, s: &str) -> icx_popper {\n-        self.ccx.insn_ctxt(s)\n+pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n+    debug!(\"new InsnCtxt: %s\", s);\n+    unsafe {\n+        do local_data::local_data_modify(task_local_insn_key) |c| {\n+            do c.map_consume |@ctx| {\n+                let mut ctx = ctx;\n+                ctx.push(s);\n+                @ctx\n+            }\n+        }\n     }\n+    _InsnCtxt { _x: () }\n }\n \n fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n@@ -138,49 +144,33 @@ fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n     }\n }\n \n-pub fn log_fn_time(ccx: @mut CrateContext, name: ~str, start: time::Timespec,\n-                   end: time::Timespec) {\n-    let elapsed = 1000 * ((end.sec - start.sec) as int) +\n-        ((end.nsec as int) - (start.nsec as int)) / 1000000;\n-    ccx.stats.fn_times.push((name, elapsed));\n-}\n-\n-pub fn decl_fn(llmod: ModuleRef,\n-               name: &str,\n-               cc: lib::llvm::CallConv,\n-               llty: TypeRef)\n-               -> ValueRef {\n-    let llfn: ValueRef = str::as_c_str(name, |buf| {\n+pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n+    let llfn: ValueRef = do name.as_c_str |buf| {\n         unsafe {\n-            llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n+            llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n         }\n-    });\n+    };\n \n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     return llfn;\n }\n \n-pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef)\n-                  -> ValueRef {\n-    return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n+pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n+    return decl_fn(llmod, name, lib::llvm::CCallConv, ty);\n }\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n-   ValueRef {\n-    let llfn = decl_cdecl_fn(llmod, name, llty);\n+pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, ty: Type) -> ValueRef {\n+    let llfn = decl_cdecl_fn(llmod, name, ty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: &mut ExternMap,\n-                     llmod: ModuleRef,\n-                     name: @str,\n-                     cc: lib::llvm::CallConv,\n-                     ty: TypeRef) -> ValueRef {\n-    match externs.find(&name) {\n-        Some(n) => return copy *n,\n+pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: @str,\n+                     cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n+    match externs.find_copy(&name) {\n+        Some(n) => return n,\n         None => ()\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n@@ -189,51 +179,27 @@ pub fn get_extern_fn(externs: &mut ExternMap,\n }\n \n pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n-                        name: @str, ty: TypeRef) -> ValueRef {\n-    match externs.find(&name) {\n-        Some(n) => return copy *n,\n+                        name: @str, ty: Type) -> ValueRef {\n+    match externs.find_copy(&name) {\n+        Some(n) => return n,\n         None => ()\n     }\n     unsafe {\n-        let c = str::as_c_str(name, |buf| {\n-            llvm::LLVMAddGlobal(llmod, ty, buf)\n-        });\n+        let c = do name.as_c_str |buf| {\n+            llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n+        };\n         externs.insert(name, c);\n         return c;\n     }\n }\n-\n-fn get_simple_extern_fn(cx: block,\n-                        externs: &mut ExternMap,\n-                        llmod: ModuleRef,\n-                        name: @str,\n-                        n_args: int) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n-    let ccx = cx.fcx.ccx;\n-    let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n-    let output = ccx.int_type;\n-    let t = T_fn(inputs, output);\n-    return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n-}\n-\n-pub fn trans_foreign_call(cx: block, externs: &mut ExternMap,\n-                          llmod: ModuleRef, name: @str, args: &[ValueRef]) ->\n-   ValueRef {\n-    let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n-    let n = args.len() as int;\n-    let llforeign: ValueRef =\n-        get_simple_extern_fn(cx, externs, llmod, name, n);\n-    return Call(cx, llforeign, args);\n-}\n-\n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"umax\");\n+    let _icx = push_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, b, a);\n }\n \n pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"umin\");\n+    let _icx = push_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, a, b);\n }\n@@ -242,19 +208,19 @@ pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"ptr_offs\");\n-    let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n+    let _icx = push_ctxt(\"ptr_offs\");\n+    let raw = PointerCast(bcx, base, Type::i8p());\n     InBoundsGEP(bcx, raw, [sz])\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let _icx = bcx.insn_ctxt(\"bump_ptr\");\n+    let _icx = push_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n-    let typ = T_ptr(type_of(ccx, t));\n+    let typ = type_of(ccx, t).ptr_to();\n     PointerCast(bcx, bumped, typ)\n }\n \n@@ -266,11 +232,11 @@ pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n pub fn opaque_box_body(bcx: block,\n                        body_t: ty::t,\n                        boxptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n+    let _icx = push_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let ty = type_of(ccx, body_t);\n-    let ty = T_box(ccx, ty);\n-    let boxptr = PointerCast(bcx, boxptr, T_ptr(ty));\n+    let ty = Type::box(ccx, &ty);\n+    let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n \n@@ -280,7 +246,7 @@ pub fn malloc_raw_dyn(bcx: block,\n                       t: ty::t,\n                       heap: heap,\n                       size: ValueRef) -> Result {\n-    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n+    let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n     let (mk_fn, langcall) = match heap {\n@@ -301,8 +267,8 @@ pub fn malloc_raw_dyn(bcx: block,\n     glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n     // Allocate space:\n-    let tydesc = PointerCast(bcx, static_ti.tydesc, T_ptr(T_i8()));\n-    let rval = alloca(bcx, T_ptr(T_i8()));\n+    let tydesc = PointerCast(bcx, static_ti.tydesc, Type::i8p());\n+    let rval = alloca(bcx, Type::i8p());\n     let bcx = callee::trans_lang_call(\n         bcx,\n         langcall,\n@@ -313,25 +279,6 @@ pub fn malloc_raw_dyn(bcx: block,\n     r\n }\n \n-/**\n-* Get the type of a box in the default address space.\n-*\n-* Shared box pointers live in address space 1 so the GC strategy can find\n-* them. Before taking a pointer to the inside of a box it should be cast into\n-* address space 0. Otherwise the resulting (non-box) pointer will be in the\n-* wrong address space and thus be the wrong type.\n-*/\n-pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n-    unsafe {\n-        debug!(\"non_gc_box_cast\");\n-        add_comment(bcx, \"non_gc_box_cast\");\n-        assert!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n-                     gc_box_addrspace || bcx.unreachable);\n-        let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n-        PointerCast(bcx, val, non_gc_t)\n-    }\n-}\n-\n // malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n@@ -351,10 +298,9 @@ pub struct MallocResult {\n // and pulls out the body\n pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> MallocResult {\n-    let _icx = bcx.insn_ctxt(\"malloc_general\");\n+    let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n-    let non_gc_box = non_gc_box_cast(bcx, llbox);\n-    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n+    let body = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n \n     MallocResult { bcx: bcx, box: llbox, body: body }\n }\n@@ -502,7 +448,7 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                     parent_id: ast::def_id,\n                     substs: &[ty::t])\n                  -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n+    let _icx = push_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n@@ -592,7 +538,7 @@ pub fn compare_scalar_values(cx: block,\n                              nt: scalar_type,\n                              op: ast::binop)\n                           -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n+    let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n                            comparison operator\");\n@@ -661,12 +607,12 @@ pub fn store_inbounds(cx: block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                           f: val_and_ty_fn) -> block {\n-    let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n+    let _icx = push_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n                     variant: ty::VariantInfo,\n                     tps: &[ty::t], f: val_and_ty_fn) -> block {\n-        let _icx = cx.insn_ctxt(\"iter_variant\");\n+        let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n@@ -761,22 +707,22 @@ pub fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n pub fn cast_shift_const_rhs(op: ast::binop,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n-                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n-                   |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n+                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n+                   |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n pub fn cast_shift_rhs(op: ast::binop,\n                       lhs: ValueRef, rhs: ValueRef,\n-                      trunc: &fn(ValueRef, TypeRef) -> ValueRef,\n-                      zext: &fn(ValueRef, TypeRef) -> ValueRef)\n+                      trunc: &fn(ValueRef, Type) -> ValueRef,\n+                      zext: &fn(ValueRef, Type) -> ValueRef)\n                    -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n         if ast_util::is_shift_binop(op) {\n             let rhs_llty = val_ty(rhs);\n             let lhs_llty = val_ty(lhs);\n-            let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty);\n-            let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty);\n+            let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty.to_ref());\n+            let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty.to_ref());\n             if lhs_sz < rhs_sz {\n                 trunc(rhs, lhs_llty)\n             } else if lhs_sz > rhs_sz {\n@@ -801,11 +747,11 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n-        let zero = C_integral(T_int_ty(cx.ccx(), t), 0u64, False);\n+        let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       ty::ty_uint(t) => {\n-        let zero = C_integral(T_uint_ty(cx.ccx(), t), 0u64, False);\n+        let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n@@ -819,7 +765,7 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n }\n \n pub fn null_env_ptr(bcx: block) -> ValueRef {\n-    C_null(T_opaque_box_ptr(bcx.ccx()))\n+    C_null(Type::opaque_box(bcx.ccx()).ptr_to())\n }\n \n pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n@@ -840,9 +786,9 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n \n pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n            -> (ValueRef, block) {\n-    let _icx = bcx.insn_ctxt(\"invoke_\");\n+    let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable {\n-        return (C_null(T_i8()), bcx);\n+        return (C_null(Type::i8()), bcx);\n     }\n \n     match bcx.node_info {\n@@ -956,7 +902,7 @@ pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n }\n \n pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n-    let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n+    let _icx = push_ctxt(\"get_landing_pad\");\n \n     let mut cached = None;\n     let mut pad_bcx = bcx; // Guaranteed to be set below\n@@ -975,7 +921,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n-    let llretty = T_struct([T_ptr(T_i8()), T_i32()], false);\n+    let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n     // The exception handling personality function. This is the C++\n     // personality function __gxx_personality_v0, wrapped in our naming\n     // convention.\n@@ -1033,7 +979,7 @@ pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n \n pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n-        return C_null(T_ptr(T_i8()));\n+        return C_null(Type::i8p());\n     }\n     let llptr = alloc_ty(bcx, t);\n     Store(bcx, v, llptr);\n@@ -1049,20 +995,20 @@ pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n }\n \n pub fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n+    let _icx = push_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"load_if_immediate\");\n+    let _icx = push_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(t) { return Load(cx, v); }\n     return v;\n }\n \n pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n     if !bcx.sess().trace() { return; }\n-    let _icx = bcx.insn_ctxt(\"trans_trace\");\n+    let _icx = push_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let (V_filename, V_line) = match sp_opt {\n@@ -1076,14 +1022,14 @@ pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n       }\n     };\n     let ccx = bcx.ccx();\n-    let V_trace_str = PointerCast(bcx, V_trace_str, T_ptr(T_i8()));\n-    let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let V_trace_str = PointerCast(bcx, V_trace_str, Type::i8p());\n+    let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n     let args = ~[V_trace_str, V_filename, C_int(ccx, V_line)];\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n pub fn build_return(bcx: block) {\n-    let _icx = bcx.insn_ctxt(\"build_return\");\n+    let _icx = push_ctxt(\"build_return\");\n     Br(bcx, bcx.fcx.llreturn);\n }\n \n@@ -1099,7 +1045,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n            bcx.to_str(), local.node.id);\n     let _indenter = indenter();\n \n-    let _icx = bcx.insn_ctxt(\"init_local\");\n+    let _icx = push_ctxt(\"init_local\");\n     let ty = node_id_type(bcx, local.node.id);\n \n     debug!(\"ty=%s\", bcx.ty_to_str(ty));\n@@ -1147,7 +1093,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n }\n \n pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_stmt\");\n+    let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n     if cx.sess().asm_comments() {\n@@ -1275,7 +1221,7 @@ pub fn trans_block_cleanups_(bcx: block,\n                              cleanups: &[cleanup],\n                              /* cleanup_cx: block, */\n                              is_lpad: bool) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n+    let _icx = push_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n     let no_lpads =\n@@ -1302,7 +1248,7 @@ pub fn trans_block_cleanups_(bcx: block,\n pub fn cleanup_and_leave(bcx: block,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n-    let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n+    let _icx = push_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     let is_lpad = leave == None;\n@@ -1369,12 +1315,12 @@ pub fn cleanup_and_leave(bcx: block,\n }\n \n pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n-    let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n+    let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n pub fn leave_block(bcx: block, out_of: block) -> block {\n-    let _icx = bcx.insn_ctxt(\"leave_block\");\n+    let _icx = push_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n@@ -1385,7 +1331,7 @@ pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n                   f: &fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(\"with_scope\");\n+    let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n            bcx.to_str(), opt_node_info, name);\n@@ -1400,7 +1346,7 @@ pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n                          name: &str,\n                          f: &fn(block) -> Result) -> Result {\n-    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n+    let _icx = push_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let Result {bcx, val} = f(scope_cx);\n@@ -1412,7 +1358,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n-    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n+    let _icx = push_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let DatumBlock {bcx, datum} = f(scope_cx);\n@@ -1434,7 +1380,7 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n }\n \n pub fn alloc_local(cx: block, local: @ast::local) -> block {\n-    let _icx = cx.insn_ctxt(\"alloc_local\");\n+    let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n       ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n@@ -1456,7 +1402,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n \n \n pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(\"with_cond\");\n+    let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n@@ -1466,23 +1412,23 @@ pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n }\n \n pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n-    let _icx = cx.insn_ctxt(\"call_memcpy\");\n+    let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n     let memcpy = ccx.intrinsics.get_copy(&key);\n-    let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n-    let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n+    let src_ptr = PointerCast(cx, src, Type::i8p());\n+    let dst_ptr = PointerCast(cx, dst, Type::i8p());\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(align as i32);\n     let volatile = C_i1(false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile]);\n }\n \n pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(\"memcpy_ty\");\n+    let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n         let llty = type_of::type_of(ccx, t);\n@@ -1495,7 +1441,7 @@ pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n }\n \n pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n-    let _icx = cx.insn_ctxt(\"zero_mem\");\n+    let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of::type_of(ccx, t);\n@@ -1507,8 +1453,8 @@ pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n-    let _icx = cx.insn_ctxt(\"memzero\");\n+pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n+    let _icx = push_ctxt(\"memzero\");\n     let ccx = cx.ccx();\n \n     let intrinsic_key = match ccx.sess.targ_cfg.arch {\n@@ -1517,50 +1463,48 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     };\n \n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n-    let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n+    let llptr = PointerCast(cx, llptr, Type::i8().ptr_to());\n     let llzeroval = C_u8(0);\n-    let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n-    let align = C_i32(llalign_of_min(ccx, llty) as i32);\n+    let size = IntCast(cx, machine::llsize_of(ccx, ty), ccx.int_type);\n+    let align = C_i32(llalign_of_min(ccx, ty) as i32);\n     let volatile = C_i1(false);\n     Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"alloc_ty\");\n+    let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n-    let llty = type_of::type_of(ccx, t);\n-    if ty::type_has_params(t) { debug!(\"%s\", ty_to_str(ccx.tcx, t)); }\n-    assert!(!ty::type_has_params(t));\n-    let val = alloca(bcx, llty);\n+    let ty = type_of::type_of(ccx, t);\n+    assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n+    let val = alloca(bcx, ty);\n     return val;\n }\n \n-pub fn alloca(cx: block, t: TypeRef) -> ValueRef {\n-    alloca_maybe_zeroed(cx, t, false)\n+pub fn alloca(cx: block, ty: Type) -> ValueRef {\n+    alloca_maybe_zeroed(cx, ty, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"alloca\");\n+pub fn alloca_maybe_zeroed(cx: block, ty: Type, zero: bool) -> ValueRef {\n+    let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n-            return llvm::LLVMGetUndef(t);\n+            return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n     let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n-    let p = Alloca(initcx, t);\n-    if zero { memzero(initcx, p, t); }\n-    return p;\n+    let p = Alloca(initcx, ty);\n+    if zero { memzero(initcx, p, ty); }\n+    p\n }\n \n-pub fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"arrayalloca\");\n+pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n+    let _icx = push_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n-            return llvm::LLVMGetUndef(t);\n+            return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n-    return ArrayAlloca(\n-        base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n+    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), ty, v);\n }\n \n pub struct BasicBlocks {\n@@ -1630,7 +1574,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe {\n-              llvm::LLVMGetUndef(T_ptr(T_i8()))\n+              llvm::LLVMGetUndef(Type::i8p().to_ref())\n           },\n           llretptr: None,\n           llstaticallocas: llbbs.sa,\n@@ -1686,7 +1630,7 @@ pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n                                  self_arg: self_arg,\n                                  args: &[ast::arg])\n                               -> ~[ValueRef] {\n-    let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n+    let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n       impl_self(tt) => {\n@@ -1734,7 +1678,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::t]) -> block {\n-    let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n+    let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n     match fcx.llself {\n@@ -1748,7 +1692,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                 Store(bcx, tmp, alloc);\n                 alloc\n             } else {\n-                PointerCast(bcx, slf.v, T_ptr(type_of(bcx.ccx(), slf.t)))\n+                PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n             };\n \n             fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n@@ -1800,7 +1744,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(\"finish_fn\");\n+    let _icx = push_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n     build_return_block(fcx);\n }\n@@ -1818,7 +1762,7 @@ pub fn build_return_block(fcx: fn_ctxt) {\n }\n \n pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n+    let _icx = push_ctxt(\"tie_up_header_blocks\");\n     match fcx.llloadenv {\n         Some(ll) => {\n             Br(raw_block(fcx, false, fcx.llstaticallocas), ll);\n@@ -1849,7 +1793,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      maybe_load_env: &fn(fn_ctxt),\n                      finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n-    let _icx = ccx.insn_ctxt(\"trans_closure\");\n+    let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     debug!(\"trans_closure(..., param_substs=%s)\",\n@@ -1872,16 +1816,6 @@ pub fn trans_closure(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    // Set GC for function.\n-    if ccx.sess.opts.gc {\n-        do str::as_c_str(\"generic\") |strategy| {\n-            unsafe {\n-                llvm::LLVMSetGC(fcx.llfn, strategy);\n-            }\n-        }\n-        ccx.uses_gc = true;\n-    }\n-\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     let bcx_top = top_scope_block(fcx, body.info());\n@@ -1938,7 +1872,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n     debug!(\"trans_fn(self_arg=%?, param_substs=%s)\",\n            self_arg,\n            param_substs.repr(ccx.tcx));\n-    let _icx = ccx.insn_ctxt(\"trans_fn\");\n+    let _icx = push_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     let the_path_str = path_str(ccx.sess, path);\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n@@ -1962,7 +1896,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |_bcx| { });\n     if do_time {\n         let end = time::get_time();\n-        log_fn_time(ccx, the_path_str, start, end);\n+        ccx.log_fn_time(the_path_str, start, end);\n     }\n }\n \n@@ -1973,7 +1907,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n                           disr: int,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n+    let _icx = push_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n     let fn_args = do args.map |varg| {\n         ast::arg {\n@@ -2047,7 +1981,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(\"trans_tuple_struct\");\n+    let _icx = push_ctxt(\"trans_tuple_struct\");\n \n     // Translate struct fields to function arguments.\n     let fn_args = do fields.map |field| {\n@@ -2133,7 +2067,7 @@ pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n }\n \n pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n-    let _icx = ccx.insn_ctxt(\"trans_item\");\n+    let _icx = push_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n@@ -2240,7 +2174,7 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n-    let _icx = ccx.insn_ctxt(\"trans_mod\");\n+    let _icx = push_ctxt(\"trans_mod\");\n     for m.items.each |item| {\n         trans_item(ccx, *item);\n     }\n@@ -2275,7 +2209,7 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n                           attrs: &[ast::attribute],\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n-                          llfty: TypeRef)\n+                          fn_ty: Type)\n                           -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n@@ -2287,12 +2221,11 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n         mangle_exported_name(ccx, /*bad*/copy path, node_type)\n     };\n \n-    let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n+    let llfn = decl_fn(ccx.llmod, ps, cc, fn_ty);\n     ccx.item_symbols.insert(node_id, ps);\n \n     // FIXME #4404 android JNI hacks\n-    let is_entry = is_entry_fn(&ccx.sess, node_id) &&\n-                     (!*ccx.sess.building_library ||\n+    let is_entry = is_entry_fn(&ccx.sess, node_id) && (!*ccx.sess.building_library ||\n                       (*ccx.sess.building_library &&\n                        ccx.sess.targ_cfg.os == session::os_android));\n     if is_entry {\n@@ -2352,7 +2285,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n     fn create_entry_fn(ccx: @mut CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = T_fn([ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n+        let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()], &ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n         let llfn = if *ccx.sess.building_library {\n@@ -2381,10 +2314,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             }\n \n             let crate_map = ccx.crate_map;\n-            let opaque_crate_map = llvm::LLVMBuildPointerCast(bld,\n-                                                              crate_map,\n-                                                              T_ptr(T_i8()),\n-                                                              noname());\n+            let opaque_crate_map = do \"crate_map\".as_c_str |buf| {\n+                llvm::LLVMBuildPointerCast(bld, crate_map, Type::i8p().to_ref(), buf)\n+            };\n \n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = ccx.tcx.lang_items.start_fn();\n@@ -2397,11 +2329,12 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = llvm::LLVMBuildPointerCast(\n-                            bld, rust_main, T_ptr(T_i8()), noname());\n+                    let opaque_rust_main = do \"rust_main\".as_c_str |buf| {\n+                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n+                    };\n \n                     ~[\n-                        C_null(T_opaque_box_ptr(ccx)),\n+                        C_null(Type::opaque_box(ccx).ptr_to()),\n                         opaque_rust_main,\n                         llvm::LLVMGetParam(llfn, 0),\n                         llvm::LLVMGetParam(llfn, 1),\n@@ -2413,7 +2346,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 debug!(\"using user-defined start fn\");\n                 let args = {\n                     ~[\n-                        C_null(T_opaque_box_ptr(ccx)),\n+                        C_null(Type::opaque_box(ccx).ptr_to()),\n                         llvm::LLVMGetParam(llfn, 0 as c_uint),\n                         llvm::LLVMGetParam(llfn, 1 as c_uint),\n                         opaque_crate_map\n@@ -2439,7 +2372,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n     let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n-    let llenvblobptr = PointerCast(bcx, llenvptr, T_opaque_box_ptr(ccx));\n+    let llenvblobptr = PointerCast(bcx, llenvptr, Type::opaque_box(ccx).ptr_to());\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n@@ -2530,7 +2463,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                     let g = do str::as_c_str(ident) |buf| {\n                         unsafe {\n                             let ty = type_of(ccx, typ);\n-                            llvm::LLVMAddGlobal(ccx.llmod, ty, buf)\n+                            llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n                         }\n                     };\n                     g\n@@ -2608,7 +2541,7 @@ pub fn register_method(ccx: @mut CrateContext,\n \n // The constant translation pass.\n pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n-    let _icx = ccx.insn_ctxt(\"trans_constant\");\n+    let _icx = push_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n         let vi = ty::enum_variants(ccx.tcx,\n@@ -2626,7 +2559,7 @@ pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n             note_unique_llvm_symbol(ccx, s);\n             let discrim_gvar = str::as_c_str(s, |buf| {\n                 unsafe {\n-                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 }\n             });\n             unsafe {\n@@ -2659,219 +2592,102 @@ pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n \n pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n+        return llvm::LLVMConstPtrToInt(v, ccx.int_type.to_ref());\n     }\n }\n \n-pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n-    let T_memcpy32_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n-    let T_memcpy64_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i64(), T_i32(), T_i1()];\n-    let T_memset32_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_i8(), T_i32(), T_i32(), T_i1()];\n-    let T_memset64_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()];\n-    let T_trap_args: ~[TypeRef] = ~[];\n-    let T_frameaddress_args: ~[TypeRef] = ~[T_i32()];\n-    let gcroot =\n-        decl_cdecl_fn(llmod, \"llvm.gcroot\",\n-                      T_fn([T_ptr(T_ptr(T_i8())), T_ptr(T_i8())],\n-                           T_void()));\n-    let gcread =\n-        decl_cdecl_fn(llmod, \"llvm.gcread\",\n-                      T_fn([T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))],\n-                           T_void()));\n-    let memcpy32 =\n-        decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i32\",\n-                      T_fn(T_memcpy32_args, T_void()));\n-    let memcpy64 =\n-        decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i64\",\n-                      T_fn(T_memcpy64_args, T_void()));\n-    let memmove32 =\n-        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n-                      T_fn(T_memcpy32_args, T_void()));\n-    let memmove64 =\n-        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i64\",\n-                      T_fn(T_memcpy64_args, T_void()));\n-    let memset32 =\n-        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i32\",\n-                      T_fn(T_memset32_args, T_void()));\n-    let memset64 =\n-        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n-                      T_fn(T_memset64_args, T_void()));\n-    let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args,\n-                                                      T_void()));\n-    let frameaddress = decl_cdecl_fn(llmod, \"llvm.frameaddress\",\n-                                     T_fn(T_frameaddress_args,\n-                                          T_ptr(T_i8())));\n-    let sqrtf32 = decl_cdecl_fn(llmod, \"llvm.sqrt.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let sqrtf64 = decl_cdecl_fn(llmod, \"llvm.sqrt.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let powif32 = decl_cdecl_fn(llmod, \"llvm.powi.f32\",\n-                                T_fn([T_f32(), T_i32()], T_f32()));\n-    let powif64 = decl_cdecl_fn(llmod, \"llvm.powi.f64\",\n-                                T_fn([T_f64(), T_i32()], T_f64()));\n-    let sinf32 = decl_cdecl_fn(llmod, \"llvm.sin.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let sinf64 = decl_cdecl_fn(llmod, \"llvm.sin.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let cosf32 = decl_cdecl_fn(llmod, \"llvm.cos.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let cosf64 = decl_cdecl_fn(llmod, \"llvm.cos.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let powf32 = decl_cdecl_fn(llmod, \"llvm.pow.f32\",\n-                                T_fn([T_f32(), T_f32()], T_f32()));\n-    let powf64 = decl_cdecl_fn(llmod, \"llvm.pow.f64\",\n-                                T_fn([T_f64(), T_f64()], T_f64()));\n-    let expf32 = decl_cdecl_fn(llmod, \"llvm.exp.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let expf64 = decl_cdecl_fn(llmod, \"llvm.exp.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let exp2f32 = decl_cdecl_fn(llmod, \"llvm.exp2.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let exp2f64 = decl_cdecl_fn(llmod, \"llvm.exp2.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let logf32 = decl_cdecl_fn(llmod, \"llvm.log.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let logf64 = decl_cdecl_fn(llmod, \"llvm.log.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let log10f32 = decl_cdecl_fn(llmod, \"llvm.log10.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let log10f64 = decl_cdecl_fn(llmod, \"llvm.log10.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let log2f32 = decl_cdecl_fn(llmod, \"llvm.log2.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let log2f64 = decl_cdecl_fn(llmod, \"llvm.log2.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let fmaf32 = decl_cdecl_fn(llmod, \"llvm.fma.f32\",\n-                                T_fn([T_f32(), T_f32(), T_f32()], T_f32()));\n-    let fmaf64 = decl_cdecl_fn(llmod, \"llvm.fma.f64\",\n-                                T_fn([T_f64(), T_f64(), T_f64()], T_f64()));\n-    let fabsf32 = decl_cdecl_fn(llmod, \"llvm.fabs.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let fabsf64 = decl_cdecl_fn(llmod, \"llvm.fabs.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let floorf32 = decl_cdecl_fn(llmod, \"llvm.floor.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let floorf64 = decl_cdecl_fn(llmod, \"llvm.floor.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let ceilf32 = decl_cdecl_fn(llmod, \"llvm.ceil.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let ceilf64 = decl_cdecl_fn(llmod, \"llvm.ceil.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let truncf32 = decl_cdecl_fn(llmod, \"llvm.trunc.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let truncf64 = decl_cdecl_fn(llmod, \"llvm.trunc.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let ctpop8 = decl_cdecl_fn(llmod, \"llvm.ctpop.i8\",\n-                                T_fn([T_i8()], T_i8()));\n-    let ctpop16 = decl_cdecl_fn(llmod, \"llvm.ctpop.i16\",\n-                                T_fn([T_i16()], T_i16()));\n-    let ctpop32 = decl_cdecl_fn(llmod, \"llvm.ctpop.i32\",\n-                                T_fn([T_i32()], T_i32()));\n-    let ctpop64 = decl_cdecl_fn(llmod, \"llvm.ctpop.i64\",\n-                                T_fn([T_i64()], T_i64()));\n-    let ctlz8 = decl_cdecl_fn(llmod, \"llvm.ctlz.i8\",\n-                                T_fn([T_i8(), T_i1()], T_i8()));\n-    let ctlz16 = decl_cdecl_fn(llmod, \"llvm.ctlz.i16\",\n-                                T_fn([T_i16(), T_i1()], T_i16()));\n-    let ctlz32 = decl_cdecl_fn(llmod, \"llvm.ctlz.i32\",\n-                                T_fn([T_i32(), T_i1()], T_i32()));\n-    let ctlz64 = decl_cdecl_fn(llmod, \"llvm.ctlz.i64\",\n-                                T_fn([T_i64(), T_i1()], T_i64()));\n-    let cttz8 = decl_cdecl_fn(llmod, \"llvm.cttz.i8\",\n-                                T_fn([T_i8(), T_i1()], T_i8()));\n-    let cttz16 = decl_cdecl_fn(llmod, \"llvm.cttz.i16\",\n-                                T_fn([T_i16(), T_i1()], T_i16()));\n-    let cttz32 = decl_cdecl_fn(llmod, \"llvm.cttz.i32\",\n-                                T_fn([T_i32(), T_i1()], T_i32()));\n-    let cttz64 = decl_cdecl_fn(llmod, \"llvm.cttz.i64\",\n-                                T_fn([T_i64(), T_i1()], T_i64()));\n-    let bswap16 = decl_cdecl_fn(llmod, \"llvm.bswap.i16\",\n-                                T_fn([T_i16()], T_i16()));\n-    let bswap32 = decl_cdecl_fn(llmod, \"llvm.bswap.i32\",\n-                                T_fn([T_i32()], T_i32()));\n-    let bswap64 = decl_cdecl_fn(llmod, \"llvm.bswap.i64\",\n-                                T_fn([T_i64()], T_i64()));\n+macro_rules! ifn (\n+    ($name:expr, $args:expr, $ret:expr) => ({\n+        let name = $name;\n+        let f = decl_cdecl_fn(llmod, name, Type::func($args, &$ret));\n+        intrinsics.insert(name, f);\n+    })\n+)\n \n+pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n+    let i8p = Type::i8p();\n     let mut intrinsics = HashMap::new();\n-    intrinsics.insert(\"llvm.gcroot\", gcroot);\n-    intrinsics.insert(\"llvm.gcread\", gcread);\n-    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n-    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i64\", memcpy64);\n-    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n-    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n-    intrinsics.insert(\"llvm.memset.p0i8.i32\", memset32);\n-    intrinsics.insert(\"llvm.memset.p0i8.i64\", memset64);\n-    intrinsics.insert(\"llvm.trap\", trap);\n-    intrinsics.insert(\"llvm.frameaddress\", frameaddress);\n-    intrinsics.insert(\"llvm.sqrt.f32\", sqrtf32);\n-    intrinsics.insert(\"llvm.sqrt.f64\", sqrtf64);\n-    intrinsics.insert(\"llvm.powi.f32\", powif32);\n-    intrinsics.insert(\"llvm.powi.f64\", powif64);\n-    intrinsics.insert(\"llvm.sin.f32\", sinf32);\n-    intrinsics.insert(\"llvm.sin.f64\", sinf64);\n-    intrinsics.insert(\"llvm.cos.f32\", cosf32);\n-    intrinsics.insert(\"llvm.cos.f64\", cosf64);\n-    intrinsics.insert(\"llvm.pow.f32\", powf32);\n-    intrinsics.insert(\"llvm.pow.f64\", powf64);\n-    intrinsics.insert(\"llvm.exp.f32\", expf32);\n-    intrinsics.insert(\"llvm.exp.f64\", expf64);\n-    intrinsics.insert(\"llvm.exp2.f32\", exp2f32);\n-    intrinsics.insert(\"llvm.exp2.f64\", exp2f64);\n-    intrinsics.insert(\"llvm.log.f32\", logf32);\n-    intrinsics.insert(\"llvm.log.f64\", logf64);\n-    intrinsics.insert(\"llvm.log10.f32\", log10f32);\n-    intrinsics.insert(\"llvm.log10.f64\", log10f64);\n-    intrinsics.insert(\"llvm.log2.f32\", log2f32);\n-    intrinsics.insert(\"llvm.log2.f64\", log2f64);\n-    intrinsics.insert(\"llvm.fma.f32\", fmaf32);\n-    intrinsics.insert(\"llvm.fma.f64\", fmaf64);\n-    intrinsics.insert(\"llvm.fabs.f32\", fabsf32);\n-    intrinsics.insert(\"llvm.fabs.f64\", fabsf64);\n-    intrinsics.insert(\"llvm.floor.f32\", floorf32);\n-    intrinsics.insert(\"llvm.floor.f64\", floorf64);\n-    intrinsics.insert(\"llvm.ceil.f32\", ceilf32);\n-    intrinsics.insert(\"llvm.ceil.f64\", ceilf64);\n-    intrinsics.insert(\"llvm.trunc.f32\", truncf32);\n-    intrinsics.insert(\"llvm.trunc.f64\", truncf64);\n-    intrinsics.insert(\"llvm.ctpop.i8\", ctpop8);\n-    intrinsics.insert(\"llvm.ctpop.i16\", ctpop16);\n-    intrinsics.insert(\"llvm.ctpop.i32\", ctpop32);\n-    intrinsics.insert(\"llvm.ctpop.i64\", ctpop64);\n-    intrinsics.insert(\"llvm.ctlz.i8\", ctlz8);\n-    intrinsics.insert(\"llvm.ctlz.i16\", ctlz16);\n-    intrinsics.insert(\"llvm.ctlz.i32\", ctlz32);\n-    intrinsics.insert(\"llvm.ctlz.i64\", ctlz64);\n-    intrinsics.insert(\"llvm.cttz.i8\", cttz8);\n-    intrinsics.insert(\"llvm.cttz.i16\", cttz16);\n-    intrinsics.insert(\"llvm.cttz.i32\", cttz32);\n-    intrinsics.insert(\"llvm.cttz.i64\", cttz64);\n-    intrinsics.insert(\"llvm.bswap.i16\", bswap16);\n-    intrinsics.insert(\"llvm.bswap.i32\", bswap32);\n-    intrinsics.insert(\"llvm.bswap.i64\", bswap64);\n+\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\",\n+         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\",\n+         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\",\n+         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\",\n+         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memset.p0i8.i32\",\n+         [i8p, Type::i8(), Type::i32(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memset.p0i8.i64\",\n+         [i8p, Type::i8(), Type::i64(), Type::i32(), Type::i1()], Type::void());\n+\n+    ifn!(\"llvm.trap\", [], Type::void());\n+    ifn!(\"llvm.frameaddress\", [Type::i32()], i8p);\n+\n+    ifn!(\"llvm.powi.f32\", [Type::f32(), Type::i32()], Type::f32());\n+    ifn!(\"llvm.powi.f64\", [Type::f64(), Type::i32()], Type::f64());\n+    ifn!(\"llvm.pow.f32\",  [Type::f32(), Type::f32()], Type::f32());\n+    ifn!(\"llvm.pow.f64\",  [Type::f64(), Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.sqrt.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.sqrt.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.sin.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.sin.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.cos.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.cos.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.exp.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.exp.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.exp2.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.exp2.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.log.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.log.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.log10.f32\",[Type::f32()], Type::f32());\n+    ifn!(\"llvm.log10.f64\",[Type::f64()], Type::f64());\n+    ifn!(\"llvm.log2.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.log2.f64\", [Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.fma.f32\",  [Type::f32(), Type::f32(), Type::f32()], Type::f32());\n+    ifn!(\"llvm.fma.f64\",  [Type::f64(), Type::f64(), Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.fabs.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.fabs.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.floor.f32\",[Type::f32()], Type::f32());\n+    ifn!(\"llvm.floor.f64\",[Type::f64()], Type::f64());\n+    ifn!(\"llvm.ceil.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.ceil.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.trunc.f32\",[Type::f32()], Type::f32());\n+    ifn!(\"llvm.trunc.f64\",[Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.ctpop.i8\", [Type::i8()], Type::i8());\n+    ifn!(\"llvm.ctpop.i16\",[Type::i16()], Type::i16());\n+    ifn!(\"llvm.ctpop.i32\",[Type::i32()], Type::i32());\n+    ifn!(\"llvm.ctpop.i64\",[Type::i64()], Type::i64());\n+\n+    ifn!(\"llvm.ctlz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n+    ifn!(\"llvm.ctlz.i16\", [Type::i16(), Type::i1()], Type::i16());\n+    ifn!(\"llvm.ctlz.i32\", [Type::i32(), Type::i1()], Type::i32());\n+    ifn!(\"llvm.ctlz.i64\", [Type::i64(), Type::i1()], Type::i64());\n+\n+    ifn!(\"llvm.cttz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n+    ifn!(\"llvm.cttz.i16\", [Type::i16(), Type::i1()], Type::i16());\n+    ifn!(\"llvm.cttz.i32\", [Type::i32(), Type::i1()], Type::i32());\n+    ifn!(\"llvm.cttz.i64\", [Type::i64(), Type::i1()], Type::i64());\n+\n+    ifn!(\"llvm.bswap.i16\",[Type::i16()], Type::i16());\n+    ifn!(\"llvm.bswap.i32\",[Type::i32()], Type::i32());\n+    ifn!(\"llvm.bswap.i64\",[Type::i64()], Type::i64());\n \n     return intrinsics;\n }\n \n-pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n-                              intrinsics: &mut HashMap<&'static str, ValueRef>) {\n-    let declare =\n-        decl_cdecl_fn(llmod, \"llvm.dbg.declare\",\n-                      T_fn([T_metadata(), T_metadata()], T_void()));\n-    let value =\n-        decl_cdecl_fn(llmod, \"llvm.dbg.value\",\n-                      T_fn([T_metadata(), T_i64(), T_metadata()], T_void()));\n-    intrinsics.insert(\"llvm.dbg.declare\", declare);\n-    intrinsics.insert(\"llvm.dbg.value\", value);\n+pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'static str, ValueRef>) {\n+    ifn!(\"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n+    ifn!(\"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n pub fn trap(bcx: block) {\n-    let v: ~[ValueRef] = ~[];\n-    match bcx.ccx().intrinsics.find(& &\"llvm.trap\") {\n-      Some(&x) => { Call(bcx, x, v); },\n+    match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n+      Some(&x) => { Call(bcx, x, []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n }\n@@ -2884,7 +2700,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n     let gc_metadata = do str::as_c_str(gc_metadata_name) |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n     };\n     unsafe {\n@@ -2895,13 +2711,13 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n }\n \n pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n-    let elttype = T_struct([ccx.int_type, ccx.int_type], false);\n-    let maptype = T_array(elttype, ccx.module_data.len() + 1);\n-    let map = str::as_c_str(\"_rust_mod_map\", |buf| {\n+    let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n+    let maptype = Type::array(&elttype, (ccx.module_data.len() + 1) as u64);\n+    let map = do \"_rust_mod_map\".as_c_str |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n-    });\n+    };\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n \n@@ -2933,7 +2749,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> ValueRef {\n     let targ_cfg = sess.targ_cfg;\n-    let int_type = T_int(targ_cfg);\n+    let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n@@ -2943,11 +2759,11 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         ~\"toplevel\"\n     };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n-    let arrtype = T_array(int_type, n_subcrates as uint);\n-    let maptype = T_struct([T_i32(), T_ptr(T_i8()), int_type, arrtype], false);\n+    let arrtype = Type::array(&int_type, n_subcrates as u64);\n+    let maptype = Type::struct_([Type::i32(), Type::i8p(), int_type, arrtype], false);\n     let map = str::as_c_str(sym_name, |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(llmod, maptype, buf)\n+            llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n@@ -2966,7 +2782,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n                       cstore::get_crate_hash(cstore, i));\n         let cr = str::as_c_str(nm, |buf| {\n             unsafe {\n-                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n         });\n         subcrates.push(p2i(ccx, cr));\n@@ -2990,8 +2806,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n         let mod_map = create_module_map(ccx);\n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n-             lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n-                                                   T_ptr(T_i8())),\n+             lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn, Type::i8p().to_ref()),\n              p2i(ccx, mod_map),\n              C_array(ccx.int_type, subcrates)]));\n     }\n@@ -3029,7 +2844,7 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n     let llconst = C_struct([llmeta]);\n     let mut llglobal = str::as_c_str(\"rust_metadata\", |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n     });\n     unsafe {\n@@ -3039,20 +2854,19 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n         });\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n-        let t_ptr_i8 = T_ptr(T_i8());\n-        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-        let llvm_used = str::as_c_str(\"llvm.used\", |buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n-        });\n+        let t_ptr_i8 = Type::i8p();\n+        llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n+        let llvm_used = do \"llvm.used\".as_c_str |buf| {\n+            llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n+        };\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n         llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n }\n \n // Writes the current ABI version into the crate.\n pub fn write_abi_version(ccx: &mut CrateContext) {\n-    mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n-                     false);\n+    mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version), false);\n }\n \n pub fn trans_crate(sess: session::Session,\n@@ -3089,19 +2903,13 @@ pub fn trans_crate(sess: session::Session,\n \n     let ccx = @mut CrateContext::new(sess, llmod_id, tcx, emap2, maps,\n                                  symbol_hasher, link_meta, reachable);\n-    // FIXME(#6511): get LLVM building with --enable-threads so this\n-    //               function can be called\n-    // if !llvm::LLVMRustStartMultithreading() {\n-    //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n-    // }\n-\n     {\n-        let _icx = ccx.insn_ctxt(\"data\");\n+        let _icx = push_ctxt(\"data\");\n         trans_constants(ccx, crate);\n     }\n \n     {\n-        let _icx = ccx.insn_ctxt(\"text\");\n+        let _icx = push_ctxt(\"text\");\n         trans_mod(ccx, &crate.node.module);\n     }\n \n@@ -3135,6 +2943,7 @@ pub fn trans_crate(sess: session::Session,\n             io::println(fmt!(\"%-7u %s\", v, k));\n         }\n     }\n+\n     let llcx = ccx.llcx;\n     let link_meta = ccx.link_meta;\n     let llmod = ccx.llmod;"}, {"sha": "83c1a3c80db24fd457af36e25acb989061eca6e4", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 141, "deletions": 140, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -13,15 +13,18 @@ use core::prelude::*;\n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n-use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use lib;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_min;\n use syntax::codemap::span;\n \n+use middle::trans::base;\n+use middle::trans::type_::Type;\n+\n use core::cast;\n-use core::hashmap::HashMap;\n use core::libc::{c_uint, c_ulonglong, c_char};\n+use core::hashmap::HashMap;\n use core::str;\n use core::vec;\n \n@@ -44,10 +47,8 @@ pub fn B(cx: block) -> BuilderRef {\n }\n \n pub fn count_insn(cx: block, category: &str) {\n-    if cx.ccx().sess.count_llvm_insns() {\n-\n+    do base::with_insn_ctxt |v| {\n         let h = &mut cx.ccx().stats.llvm_insns;\n-        let v : &[~str] = cx.ccx().stats.llvm_insn_ctxt;\n \n         // Build version of path with cycles removed.\n \n@@ -186,13 +187,13 @@ pub fn Invoke(cx: block,\n               Catch: BasicBlockRef)\n            -> ValueRef {\n     if cx.unreachable {\n-        return C_null(T_i8());\n+        return C_null(Type::i8());\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke(%s with arguments (%s))\",\n-           val_str(cx.ccx().tn, Fn),\n-           Args.map(|a| val_str(cx.ccx().tn, *a).to_owned()).connect(\", \"));\n+           cx.val_to_str(Fn),\n+           Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx),\n@@ -232,7 +233,7 @@ pub fn Unreachable(cx: block) {\n \n pub fn _Undef(val: ValueRef) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMGetUndef(val_ty(val));\n+        return llvm::LLVMGetUndef(val_ty(val).to_ref());\n     }\n }\n \n@@ -486,35 +487,35 @@ pub fn Not(cx: block, V: ValueRef) -> ValueRef {\n }\n \n /* Memory */\n-pub fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn Malloc(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"malloc\");\n-        return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+        return llvm::LLVMBuildMalloc(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n-pub fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"arraymalloc\");\n-        return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+        return llvm::LLVMBuildArrayMalloc(B(cx), Ty.to_ref(), Val, noname());\n     }\n }\n \n-pub fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn Alloca(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         count_insn(cx, \"alloca\");\n-        return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+        return llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n-pub fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         count_insn(cx, \"arrayalloca\");\n-        return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+        return llvm::LLVMBuildArrayAlloca(B(cx), Ty.to_ref(), Val, noname());\n     }\n }\n \n@@ -531,9 +532,12 @@ pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n             let ty = val_ty(PointerVal);\n-            let eltty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Array {\n-                llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n-            return llvm::LLVMGetUndef(eltty);\n+            let eltty = if ty.kind() == lib::llvm::Array {\n+                ty.element_type()\n+            } else {\n+                ccx.int_type\n+            };\n+            return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n         count_insn(cx, \"load\");\n         return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n@@ -544,7 +548,7 @@ pub fn AtomicLoad(cx: block, PointerVal: ValueRef, order: AtomicOrdering) -> Val\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n-            return llvm::LLVMGetUndef(ccx.int_type);\n+            return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n         count_insn(cx, \"load.atomic\");\n         let align = llalign_of_min(ccx, ccx.int_type);\n@@ -576,8 +580,8 @@ pub fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         debug!(\"Store %s -> %s\",\n-               val_str(cx.ccx().tn, Val),\n-               val_str(cx.ccx().tn, Ptr));\n+               cx.val_to_str(Val),\n+               cx.val_to_str(Ptr));\n         count_insn(cx, \"store\");\n         llvm::LLVMBuildStore(B(cx), Val, Ptr);\n     }\n@@ -587,8 +591,8 @@ pub fn AtomicStore(cx: block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrderin\n     unsafe {\n         if cx.unreachable { return; }\n         debug!(\"Store %s -> %s\",\n-               val_str(cx.ccx().tn, Val),\n-               val_str(cx.ccx().tn, Ptr));\n+               cx.val_to_str(Val),\n+               cx.val_to_str(Ptr));\n         count_insn(cx, \"store.atomic\");\n         let align = llalign_of_min(cx.ccx(), cx.ccx().int_type);\n         llvm::LLVMBuildAtomicStore(B(cx), Val, Ptr, order, align as c_uint);\n@@ -597,7 +601,7 @@ pub fn AtomicStore(cx: block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrderin\n \n pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"gep\");\n         return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n                                    Indices.len() as c_uint, noname());\n@@ -614,21 +618,18 @@ pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     return InBoundsGEP(cx, base, v);\n }\n \n-pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n-   ValueRef {\n+pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"inboundsgep\");\n-        return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                           vec::raw::to_ptr(Indices),\n-                                           Indices.len() as c_uint,\n-                                           noname());\n+        return llvm::LLVMBuildInBoundsGEP(\n+            B(cx), Pointer, vec::raw::to_ptr(Indices), Indices.len() as c_uint, noname());\n     }\n }\n \n pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"structgep\");\n         return llvm::LLVMBuildStructGEP(B(cx),\n                                         Pointer,\n@@ -639,171 +640,171 @@ pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n \n pub fn GlobalString(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"globalstring\");\n         return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n     }\n }\n \n pub fn GlobalStringPtr(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"globalstringptr\");\n         return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n     }\n }\n \n /* Casts */\n-pub fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn Trunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"trunc\");\n-        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn ZExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"zext\");\n-        return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildZExt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"sext\");\n-        return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildSExt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPToUI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fptoui\");\n-        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPToSI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fptosi\");\n-        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy.to_ref(),noname());\n     }\n }\n \n-pub fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn UIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"uitofp\");\n-        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"sitofp\");\n-        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fptrunc\");\n-        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fpext\");\n-        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"ptrtoint\");\n-        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"inttoptr\");\n-        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn BitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"bitcast\");\n-        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"zextorbitcast\");\n-        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"sextorbitcast\");\n-        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"truncorbitcast\");\n-        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef, _: *u8)\n+pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"cast\");\n-        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn PointerCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"pointercast\");\n-        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn IntCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"intcast\");\n-        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fpcast\");\n-        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n@@ -812,7 +813,7 @@ pub fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"icmp\");\n         return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n     }\n@@ -821,25 +822,25 @@ pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"fcmp\");\n         return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n     }\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn EmptyPhi(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         count_insn(cx, \"emptyphi\");\n-        return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+        return llvm::LLVMBuildPhi(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n-pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n+pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         assert_eq!(vals.len(), bbs.len());\n         let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n@@ -863,10 +864,13 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(Fn);\n-        let retty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Integer {\n-            llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n-            count_insn(cx, \"\");\n-        return llvm::LLVMGetUndef(retty);\n+        let retty = if ty.kind() == lib::llvm::Integer {\n+            ty.return_type()\n+        } else {\n+            ccx.int_type\n+        };\n+        count_insn(cx, \"ret_undef\");\n+        return llvm::LLVMGetUndef(retty.to_ref());\n     }\n }\n \n@@ -886,20 +890,18 @@ pub fn add_comment(bcx: block, text: &str) {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = ~\"# \" +\n                 sanitized.replace(\"\\n\", \"\\n\\t# \");\n-            let asm = str::as_c_str(comment_text, |c| {\n-                str::as_c_str(\"\", |e| {\n-                    count_insn(bcx, \"inlineasm\");\n-                    llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e,\n-                                             False, False)\n-                })\n-            });\n+            count_insn(bcx, \"inlineasm\");\n+            let asm = do comment_text.as_c_str |c| {\n+                llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n+                                         c, noname(), False, False)\n+            };\n             Call(bcx, asm, []);\n         }\n     }\n }\n \n pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n-                     inputs: &[ValueRef], output: TypeRef,\n+                     inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     unsafe {\n@@ -911,14 +913,13 @@ pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n                          else          { lib::llvm::False };\n \n         let argtys = do inputs.map |v| {\n-            debug!(\"Asm Input Type: %?\", val_str(cx.ccx().tn, *v));\n+            debug!(\"Asm Input Type: %?\", cx.val_to_str(*v));\n             val_ty(*v)\n         };\n \n-        debug!(\"Asm Output Type: %?\", ty_str(cx.ccx().tn, output));\n-        let llfty = T_fn(argtys, output);\n-        let v = llvm::LLVMInlineAsm(llfty, asm, cons, volatile,\n-                                    alignstack, dia as c_uint);\n+        debug!(\"Asm Output Type: %?\", cx.ccx().tn.type_to_str(output));\n+        let fty = Type::func(argtys, &output);\n+        let v = llvm::LLVMInlineAsm(fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n \n         Call(cx, v, inputs)\n     }\n@@ -930,8 +931,8 @@ pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n         count_insn(cx, \"call\");\n \n         debug!(\"Call(Fn=%s, Args=%?)\",\n-               val_str(cx.ccx().tn, Fn),\n-               Args.map(|arg| val_str(cx.ccx().tn, *arg)));\n+               cx.val_to_str(Fn),\n+               Args.map(|arg| cx.val_to_str(*arg)));\n \n         do vec::as_imm_buf(Args) |ptr, len| {\n             llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n@@ -971,18 +972,18 @@ pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n     }\n }\n \n-pub fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+pub fn VAArg(cx: block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         count_insn(cx, \"vaarg\");\n-        return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+        return llvm::LLVMBuildVAArg(B(cx), list, Ty.to_ref(), noname());\n     }\n }\n \n pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"extractelement\");\n         return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n     }\n@@ -991,7 +992,7 @@ pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"insertelement\");\n         llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname())\n     }\n@@ -1000,23 +1001,24 @@ pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"shufflevector\");\n         llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname())\n     }\n }\n \n pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n-        let Undef = llvm::LLVMGetUndef(T_vector(val_ty(EltVal), NumElts));\n+        let elt_ty = val_ty(EltVal);\n+        let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, NumElts as u64).to_ref());\n         let VecVal = InsertElement(cx, Undef, EltVal, C_i32(0));\n-        ShuffleVector(cx, VecVal, Undef, C_null(T_vector(T_i32(), NumElts)))\n+        ShuffleVector(cx, VecVal, Undef, C_null(Type::vector(&Type::i32(), NumElts as u64)))\n     }\n }\n \n pub fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"extractvalue\");\n         return llvm::LLVMBuildExtractValue(\n             B(cx), AggVal, Index as c_uint, noname());\n@@ -1035,15 +1037,15 @@ pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n \n pub fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"isnull\");\n         return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n     }\n }\n \n pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"isnotnull\");\n         return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n     }\n@@ -1052,7 +1054,7 @@ pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n pub fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         count_insn(cx, \"ptrdiff\");\n         return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n     }\n@@ -1071,19 +1073,18 @@ pub fn Trap(cx: block) {\n         assert!((T as int != 0));\n         let Args: ~[ValueRef] = ~[];\n         count_insn(cx, \"trap\");\n-        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args),\n-                            Args.len() as c_uint, noname());\n+        llvm::LLVMBuildCall(b, T, vec::raw::to_ptr(Args), Args.len() as c_uint, noname());\n     }\n }\n \n-pub fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n+pub fn LandingPad(cx: block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n         assert!(!cx.unreachable);\n         count_insn(cx, \"landingpad\");\n-        return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n-                                      NumClauses as c_uint, noname());\n+        return llvm::LLVMBuildLandingPad(\n+            B(cx), Ty.to_ref(), PersFn, NumClauses as c_uint, noname());\n     }\n }\n "}, {"sha": "4526af2da0f49a4b39d98c4d16f24cc7d3b061b2", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -8,25 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{llvm, TypeRef, ValueRef, Attribute, Void};\n+use lib::llvm::{llvm, ValueRef, Attribute, Void};\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n \n+use middle::trans::type_::Type;\n+\n use core::libc::c_uint;\n use core::option;\n use core::vec;\n \n pub trait ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n-                    ret_def: bool) -> FnType;\n+    fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n }\n \n pub struct LLVMType {\n     cast: bool,\n-    ty: TypeRef\n+    ty: Type\n }\n \n pub struct FnType {\n@@ -37,10 +36,10 @@ pub struct FnType {\n }\n \n impl FnType {\n-    pub fn decl_fn(&self, decl: &fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+    pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n-        let fnty = T_fn(atys, rty);\n+        let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);\n \n         for self.attrs.iter().enumerate().advance |(i, a)| {\n@@ -57,10 +56,7 @@ impl FnType {\n         return llfn;\n     }\n \n-    pub fn build_shim_args(&self,\n-                           bcx: block,\n-                           arg_tys: &[TypeRef],\n-                           llargbundle: ValueRef)\n+    pub fn build_shim_args(&self, bcx: block, arg_tys: &[Type], llargbundle: ValueRef)\n                            -> ~[ValueRef] {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n@@ -80,7 +76,7 @@ impl FnType {\n         while i < n {\n             let llargval = if atys[i].cast {\n                 let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let arg_ptr = BitCast(bcx, arg_ptr, T_ptr(atys[i].ty));\n+                let arg_ptr = BitCast(bcx, arg_ptr, atys[i].ty.ptr_to());\n                 Load(bcx, arg_ptr)\n             } else if attrs[i].is_some() {\n                 GEPi(bcx, llargbundle, [0u, i])\n@@ -94,19 +90,13 @@ impl FnType {\n         return llargvals;\n     }\n \n-    pub fn build_shim_ret(&self,\n-                          bcx: block,\n-                          arg_tys: &[TypeRef],\n-                          ret_def: bool,\n-                          llargbundle: ValueRef,\n-                          llretval: ValueRef) {\n+    pub fn build_shim_ret(&self, bcx: block, arg_tys: &[Type], ret_def: bool,\n+                          llargbundle: ValueRef, llretval: ValueRef) {\n         for self.attrs.iter().enumerate().advance |(i, a)| {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {\n-                        llvm::LLVMAddInstrAttribute(llretval,\n-                                                    (i + 1u) as c_uint,\n-                                                    attr as c_uint);\n+                        llvm::LLVMAddInstrAttribute(llretval, (i + 1u) as c_uint, attr as c_uint);\n                     }\n                 }\n                 _ => ()\n@@ -121,7 +111,7 @@ impl FnType {\n         // R* llretloc = *llretptr; /* (args->r) */\n         let llretloc = Load(bcx, llretptr);\n         if self.ret_ty.cast {\n-            let tmp_ptr = BitCast(bcx, llretloc, T_ptr(self.ret_ty.ty));\n+            let tmp_ptr = BitCast(bcx, llretloc, self.ret_ty.ty.ptr_to());\n             // *args->r = r;\n             Store(bcx, llretval, tmp_ptr);\n         } else {\n@@ -130,11 +120,8 @@ impl FnType {\n         };\n     }\n \n-    pub fn build_wrap_args(&self,\n-                           bcx: block,\n-                           ret_ty: TypeRef,\n-                           llwrapfn: ValueRef,\n-                           llargbundle: ValueRef) {\n+    pub fn build_wrap_args(&self, bcx: block, ret_ty: Type,\n+                           llwrapfn: ValueRef, llargbundle: ValueRef) {\n         let mut atys: &[LLVMType] = self.arg_tys;\n         let mut attrs: &[option::Option<Attribute>] = self.attrs;\n         let mut j = 0u;\n@@ -145,7 +132,7 @@ impl FnType {\n             get_param(llwrapfn, 0u)\n         } else if self.ret_ty.cast {\n             let retptr = alloca(bcx, self.ret_ty.ty);\n-            BitCast(bcx, retptr, T_ptr(ret_ty))\n+            BitCast(bcx, retptr, ret_ty.ptr_to())\n         } else {\n             alloca(bcx, ret_ty)\n         };\n@@ -159,7 +146,7 @@ impl FnType {\n                 store_inbounds(bcx, argval, llargbundle, [0u, i]);\n             } else if atys[i].cast {\n                 let argptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let argptr = BitCast(bcx, argptr, T_ptr(atys[i].ty));\n+                let argptr = BitCast(bcx, argptr, atys[i].ty.ptr_to());\n                 Store(bcx, argval, argptr);\n             } else {\n                 store_inbounds(bcx, argval, llargbundle, [0u, i]);\n@@ -169,27 +156,20 @@ impl FnType {\n         store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n     }\n \n-    pub fn build_wrap_ret(&self,\n-                          bcx: block,\n-                          arg_tys: &[TypeRef],\n-                          llargbundle: ValueRef) {\n-        unsafe {\n-            if llvm::LLVMGetTypeKind(self.ret_ty.ty) == Void {\n-                return;\n-            }\n+    pub fn build_wrap_ret(&self, bcx: block, arg_tys: &[Type], llargbundle: ValueRef) {\n+        if self.ret_ty.ty.kind() == Void {\n+            return;\n         }\n \n         if bcx.fcx.llretptr.is_some() {\n             let llretval = load_inbounds(bcx, llargbundle, [ 0, arg_tys.len() ]);\n             let llretval = if self.ret_ty.cast {\n-                let retptr = BitCast(bcx, llretval, T_ptr(self.ret_ty.ty));\n+                let retptr = BitCast(bcx, llretval, self.ret_ty.ty.ptr_to());\n                 Load(bcx, retptr)\n             } else {\n                 Load(bcx, llretval)\n             };\n-            let llretptr = BitCast(bcx,\n-                                   bcx.fcx.llretptr.get(),\n-                                   T_ptr(self.ret_ty.ty));\n+            let llretptr = BitCast(bcx, bcx.fcx.llretptr.get(), self.ret_ty.ty.ptr_to());\n             Store(bcx, llretval, llretptr);\n         }\n     }"}, {"sha": "2f4579afe9c1f0cf997dff25c3b0ff9e10251d7c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 68, "deletions": 73, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::struct_tys;\n-use lib::llvm::TypeRef;\n use lib::llvm::{Attribute, StructRetAttribute};\n-use lib::llvm::True;\n use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n-use middle::trans::common::{T_i8, T_i16, T_i32, T_i64};\n-use middle::trans::common::{T_array, T_ptr, T_void};\n+\n+use middle::trans::type_::Type;\n \n use core::option::{Option, None, Some};\n use core::uint;\n@@ -24,117 +21,115 @@ fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n \n-fn align(off: uint, ty: TypeRef) -> uint {\n+fn align(off: uint, ty: Type) -> uint {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-            }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                if llvm::LLVMIsPackedStruct(ty) == True {\n-                    1\n-                } else {\n-                    let str_tys = struct_tys(ty);\n-                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n-                }\n+fn ty_align(ty: Type) -> uint {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Array => {\n-                let elt = llvm::LLVMGetElementType(ty);\n-                ty_align(elt)\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                1\n+            } else {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n             }\n-            _ => fail!(\"ty_align: unhandled type\")\n-        };\n+        }\n+        Array => {\n+            let elt = ty.element_type();\n+            ty_align(elt)\n+        }\n+        _ => fail!(\"ty_align: unhandled type\")\n     }\n }\n \n-fn ty_size(ty: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+fn ty_size(ty: Type) -> uint {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                if llvm::LLVMIsPackedStruct(ty) == True {\n-                    let str_tys = struct_tys(ty);\n-                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                } else {\n-                    let str_tys = struct_tys(ty);\n-                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                    align(size, ty)\n-                }\n-            }\n-            Array => {\n-                let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                let elt = llvm::LLVMGetElementType(ty);\n-                let eltsz = ty_size(elt);\n-                len * eltsz\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+            } else {\n+                let str_tys = ty.field_types();\n+                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                align(size, ty)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n-        };\n+        }\n+        Array => {\n+            let len = ty.array_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt);\n+            len * eltsz\n+        }\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n-fn classify_ret_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     if is_reg_ty(ty) {\n         return (LLVMType { cast: false, ty: ty }, None);\n     }\n     let size = ty_size(ty);\n     if size <= 4 {\n         let llty = if size <= 1 {\n-            T_i8()\n+            Type::i8()\n         } else if size <= 2 {\n-            T_i16()\n+            Type::i16()\n         } else {\n-            T_i32()\n+            Type::i32()\n         };\n         return (LLVMType { cast: true, ty: llty }, None);\n     }\n-    (LLVMType { cast: false, ty: T_ptr(ty) }, Some(StructRetAttribute))\n+    (LLVMType { cast: false, ty: ty.ptr_to() }, Some(StructRetAttribute))\n }\n \n-fn classify_arg_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+fn classify_arg_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     if is_reg_ty(ty) {\n         return (LLVMType { cast: false, ty: ty }, None);\n     }\n     let align = ty_align(ty);\n     let size = ty_size(ty);\n     let llty = if align <= 4 {\n-        T_array(T_i32(), (size + 3) / 4)\n+        Type::array(&Type::i32(), (size + 3) / 4 as u64)\n     } else {\n-        T_array(T_i64(), (size + 7) / 8)\n+        Type::array(&Type::i64(), (size + 7) / 8 as u64)\n     };\n     (LLVMType { cast: true, ty: llty }, None)\n }\n \n-fn is_reg_ty(ty: TypeRef) -> bool {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer\n-            | Pointer\n-            | Float\n-            | Double => true,\n-            _ => false\n-        };\n+fn is_reg_ty(ty: Type) -> bool {\n+    match ty.kind() {\n+        Integer\n+        | Pointer\n+        | Float\n+        | Double => true,\n+        _ => false\n     }\n }\n \n enum ARM_ABIInfo { ARM_ABIInfo }\n \n impl ABIInfo for ARM_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = ~[];\n         let mut attrs = ~[];\n@@ -147,14 +142,14 @@ impl ABIInfo for ARM_ABIInfo {\n         let mut (ret_ty, ret_attr) = if ret_def {\n             classify_ret_ty(rty)\n         } else {\n-            (LLVMType { cast: false, ty: T_void() }, None)\n+            (LLVMType { cast: false, ty: Type::void() }, None)\n         };\n \n         let sret = ret_attr.is_some();\n         if sret {\n             arg_tys.unshift(ret_ty);\n             attrs.unshift(ret_attr);\n-            ret_ty = LLVMType { cast: false, ty: T_void() };\n+            ret_ty = LLVMType { cast: false, ty: Type::void() };\n         }\n \n         return FnType {"}, {"sha": "ab5296b0c7a02910156d0294dfd71dc524bb15ee", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 77, "deletions": 94, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -11,104 +11,89 @@\n use core::prelude::*;\n \n use core::libc::c_uint;\n-use core::ptr;\n use core::uint;\n use core::vec;\n-use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n-use lib::llvm::{Struct, Array, Attribute};\n-use lib::llvm::{StructRetAttribute};\n-use lib::llvm::True;\n+use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n+use lib::llvm::{Attribute, StructRetAttribute};\n use middle::trans::context::task_llcx;\n-use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n+use middle::trans::type_::Type;\n+\n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n \n-fn align(off: uint, ty: TypeRef) -> uint {\n+fn align(off: uint, ty: Type) -> uint {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let n = llvm::LLVMCountStructElementTypes(ty);\n-    if (n == 0) {\n-        return ~[];\n-    }\n-        let mut elts = vec::from_elem(n as uint, ptr::null());\n-        llvm::LLVMGetStructElementTypes(ty, &mut elts[0]);\n-        return elts;\n-    }\n-}\n-\n-fn ty_align(ty: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+fn ty_align(ty: Type) -> uint {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-              if llvm::LLVMIsPackedStruct(ty) == True {\n-                1\n-              } else {\n-                let str_tys = struct_tys(ty);\n-                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n-              }\n-            }\n-            Array => {\n-                let elt = llvm::LLVMGetElementType(ty);\n-                ty_align(elt)\n-            }\n-            _ => fail!(\"ty_size: unhandled type\")\n-        };\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+          if ty.is_packed() {\n+            1\n+          } else {\n+            let str_tys = ty.field_types();\n+            str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+          }\n+        }\n+        Array => {\n+            let elt = ty.element_type();\n+            ty_align(elt)\n+        }\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n-fn ty_size(ty: TypeRef) -> uint {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-            }\n-            Pointer => 4,\n-            Float => 4,\n-            Double => 8,\n-            Struct => {\n-                if llvm::LLVMIsPackedStruct(ty) == True {\n-                    let str_tys = struct_tys(ty);\n-                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                } else {\n-                    let str_tys = struct_tys(ty);\n-                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                    align(size, ty)\n-                }\n+fn ty_size(ty: Type) -> uint {\n+    match ty.kind() {\n+        Integer => {\n+            unsafe {\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n-            Array => {\n-              let len = llvm::LLVMGetArrayLength(ty) as uint;\n-              let elt = llvm::LLVMGetElementType(ty);\n-              let eltsz = ty_size(elt);\n-              len * eltsz\n+        }\n+        Pointer => 4,\n+        Float => 4,\n+        Double => 8,\n+        Struct => {\n+            if ty.is_packed() {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+            } else {\n+                let str_tys = ty.field_types();\n+                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                align(size, ty)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n-        };\n+        }\n+        Array => {\n+            let len = ty.array_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt);\n+            len * eltsz\n+        }\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n-fn classify_ret_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     return if is_reg_ty(ty) {\n         (LLVMType { cast: false, ty: ty }, None)\n     } else {\n-        (LLVMType { cast: false, ty: T_ptr(ty) }, Some(StructRetAttribute))\n+        (LLVMType { cast: false, ty: ty.ptr_to() }, Some(StructRetAttribute))\n     };\n }\n \n-fn classify_arg_ty(ty: TypeRef,\n-                   offset: &mut uint) -> (LLVMType, Option<Attribute>) {\n+fn classify_arg_ty(ty: Type, offset: &mut uint) -> (LLVMType, Option<Attribute>) {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -133,28 +118,26 @@ fn classify_arg_ty(ty: TypeRef,\n     };\n }\n \n-fn is_reg_ty(ty: TypeRef) -> bool {\n-    unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n-            Integer\n-            | Pointer\n-            | Float\n-            | Double => true,\n-            _ => false\n-        };\n-    }\n+fn is_reg_ty(ty: Type) -> bool {\n+    return match ty.kind() {\n+        Integer\n+        | Pointer\n+        | Float\n+        | Double => true,\n+        _ => false\n+    };\n }\n \n-fn padding_ty(align: uint, offset: uint) -> Option<TypeRef> {\n+fn padding_ty(align: uint, offset: uint) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n-        return Some(T_i32());\n+        return Some(Type::i32());\n     }\n \n     return None;\n }\n \n-fn coerce_to_int(size: uint) -> ~[TypeRef] {\n-    let int_ty = T_i32();\n+fn coerce_to_int(size: uint) -> ~[Type] {\n+    let int_ty = Type::i32();\n     let mut args = ~[];\n \n     let mut n = size / 32;\n@@ -166,16 +149,16 @@ fn coerce_to_int(size: uint) -> ~[TypeRef] {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint))\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint)));\n         }\n     }\n \n-    return args;\n+    args\n }\n \n-fn struct_ty(ty: TypeRef,\n-             padding: Option<TypeRef>,\n-             coerce: bool) -> TypeRef {\n+fn struct_ty(ty: Type,\n+             padding: Option<Type>,\n+             coerce: bool) -> Type {\n     let size = ty_size(ty) * 8;\n     let mut fields = padding.map_default(~[], |p| ~[*p]);\n \n@@ -185,20 +168,20 @@ fn struct_ty(ty: TypeRef,\n         fields.push(ty);\n     }\n \n-    return T_struct(fields, false);\n+    return Type::struct_(fields, false);\n }\n \n enum MIPS_ABIInfo { MIPS_ABIInfo }\n \n impl ABIInfo for MIPS_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         let mut (ret_ty, ret_attr) = if ret_def {\n             classify_ret_ty(rty)\n         } else {\n-            (LLVMType { cast: false, ty: T_void() }, None)\n+            (LLVMType { cast: false, ty: Type::void() }, None)\n         };\n \n         let sret = ret_attr.is_some();\n@@ -215,7 +198,7 @@ impl ABIInfo for MIPS_ABIInfo {\n         if sret {\n             arg_tys = vec::append(~[ret_ty], arg_tys);\n             attrs = vec::append(~[ret_attr], attrs);\n-            ret_ty = LLVMType { cast: false, ty: T_void() };\n+            ret_ty = LLVMType { cast: false, ty: Type::void() };\n         }\n \n         return FnType {"}, {"sha": "8131fd009eedf23a0a71ffc409a340d70e14e74e", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -12,19 +12,20 @@ use core::prelude::*;\n \n use driver::session::{os_win32, os_macos};\n use lib::llvm::*;\n-use lib::llvm::llvm::*;\n use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n \n+use middle::trans::type_::Type;\n+\n struct X86_ABIInfo {\n     ccx: @mut CrateContext\n }\n \n impl ABIInfo for X86_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = do atys.map |a| {\n             LLVMType { cast: false, ty: *a }\n@@ -41,7 +42,7 @@ impl ABIInfo for X86_ABIInfo {\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n         let sret = {\n-            let returning_a_struct = unsafe { LLVMGetTypeKind(rty) == Struct && ret_def };\n+            let returning_a_struct = rty.kind() == Struct && ret_def;\n             let big_struct = match self.ccx.sess.targ_cfg.os {\n                 os_win32 | os_macos => llsize_of_alloc(self.ccx, rty) > 8,\n                 _ => true\n@@ -52,18 +53,18 @@ impl ABIInfo for X86_ABIInfo {\n         if sret {\n             let ret_ptr_ty = LLVMType {\n                 cast: false,\n-                ty: T_ptr(ret_ty.ty)\n+                ty: ret_ty.ty.ptr_to()\n             };\n             arg_tys = ~[ret_ptr_ty] + arg_tys;\n             attrs = ~[Some(StructRetAttribute)] + attrs;\n             ret_ty = LLVMType {\n                 cast: false,\n-                ty: T_void(),\n+                ty: Type::void(),\n             };\n         } else if !ret_def {\n             ret_ty = LLVMType {\n                 cast: false,\n-                ty: T_void()\n+                ty: Type::void()\n             };\n         }\n "}, {"sha": "4a92b940190a4c37d90c975cca9e3e706f2088c6", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 244, "deletions": 256, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -11,151 +11,169 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n+use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n-use lib::llvm::struct_tys;\n-use lib::llvm::True;\n-use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n-use core::libc::c_uint;\n+use middle::trans::type_::Type;\n+\n use core::option;\n use core::option::Option;\n use core::uint;\n use core::vec;\n \n #[deriving(Eq)]\n-enum x86_64_reg_class {\n-    no_class,\n-    integer_class,\n-    sse_fs_class,\n-    sse_fv_class,\n-    sse_ds_class,\n-    sse_dv_class,\n-    sse_int_class,\n-    sseup_class,\n-    x87_class,\n-    x87up_class,\n-    complex_x87_class,\n-    memory_class\n+enum RegClass {\n+    NoClass,\n+    Int,\n+    SSEFs,\n+    SSEFv,\n+    SSEDs,\n+    SSEDv,\n+    SSEInt,\n+    SSEUp,\n+    X87,\n+    X87Up,\n+    ComplexX87,\n+    Memory\n }\n \n-fn is_sse(c: x86_64_reg_class) -> bool {\n-    return match c {\n-        sse_fs_class | sse_fv_class |\n-        sse_ds_class | sse_dv_class => true,\n-        _ => false\n-    };\n+impl Type {\n+    fn is_reg_ty(&self) -> bool {\n+        match self.kind() {\n+            Integer | Pointer | Float | Double => true,\n+            _ => false\n+        }\n+    }\n }\n \n-fn is_ymm(cls: &[x86_64_reg_class]) -> bool {\n-    let len = cls.len();\n-    return (len > 2u &&\n-         is_sse(cls[0]) &&\n-         cls[1] == sseup_class &&\n-         cls[2] == sseup_class) ||\n-        (len > 3u &&\n-         is_sse(cls[1]) &&\n-         cls[2] == sseup_class &&\n-         cls[3] == sseup_class);\n+impl RegClass {\n+    fn is_sse(&self) -> bool {\n+        match *self {\n+            SSEFs | SSEFv | SSEDs | SSEDv => true,\n+            _ => false\n+        }\n+    }\n }\n \n-fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n-    fn align(off: uint, ty: TypeRef) -> uint {\n+trait ClassList {\n+    fn is_pass_byval(&self) -> bool;\n+    fn is_ret_bysret(&self) -> bool;\n+}\n+\n+impl<'self> ClassList for &'self [RegClass] {\n+    fn is_pass_byval(&self) -> bool {\n+        if self.len() == 0 { return false; }\n+\n+        let class = self[0];\n+           class == Memory\n+        || class == X87\n+        || class == ComplexX87\n+    }\n+\n+    fn is_ret_bysret(&self) -> bool {\n+        if self.len() == 0 { return false; }\n+\n+        self[0] == Memory\n+    }\n+}\n+\n+fn classify_ty(ty: Type) -> ~[RegClass] {\n+    fn align(off: uint, ty: Type) -> uint {\n         let a = ty_align(ty);\n         return (off + a - 1u) / a * a;\n     }\n \n-    fn ty_align(ty: TypeRef) -> uint {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) {\n-                Integer => {\n-                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-                }\n-                Pointer => 8,\n-                Float => 4,\n-                Double => 8,\n-                Struct => {\n-                  if llvm::LLVMIsPackedStruct(ty) == True {\n-                    1\n-                  } else {\n-                    let str_tys = struct_tys(ty);\n-                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n-                  }\n+    fn ty_align(ty: Type) -> uint {\n+        match ty.kind() {\n+            Integer => {\n+                unsafe {\n+                    ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n                 }\n-                Array => {\n-                    let elt = llvm::LLVMGetElementType(ty);\n-                    ty_align(elt)\n-                }\n-                _ => fail!(\"ty_size: unhandled type\")\n-            };\n+            }\n+            Pointer => 8,\n+            Float => 4,\n+            Double => 8,\n+            Struct => {\n+              if ty.is_packed() {\n+                1\n+              } else {\n+                let str_tys = ty.field_types();\n+                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n+              }\n+            }\n+            Array => {\n+                let elt = ty.element_type();\n+                ty_align(elt)\n+            }\n+            _ => fail!(\"ty_size: unhandled type\")\n         }\n     }\n \n-    fn ty_size(ty: TypeRef) -> uint {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) {\n-                Integer => {\n-                    ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n-                }\n-                Pointer => 8,\n-                Float => 4,\n-                Double => 8,\n-                Struct => {\n-                    if llvm::LLVMIsPackedStruct(ty) == True {\n-                        let str_tys = struct_tys(ty);\n-                        str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-                    } else {\n-                        let str_tys = struct_tys(ty);\n-                        let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                        align(size, ty)\n-                    }\n+    fn ty_size(ty: Type) -> uint {\n+        match ty.kind() {\n+            Integer => {\n+                unsafe {\n+                    ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n                 }\n-                Array => {\n-                  let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                  let elt = llvm::LLVMGetElementType(ty);\n-                  let eltsz = ty_size(elt);\n-                  len * eltsz\n+            }\n+            Pointer => 8,\n+            Float => 4,\n+            Double => 8,\n+            Struct => {\n+                if ty.is_packed() {\n+                    let str_tys = ty.field_types();\n+                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+                } else {\n+                    let str_tys = ty.field_types();\n+                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                    align(size, ty)\n                 }\n-                _ => fail!(\"ty_size: unhandled type\")\n-            };\n+            }\n+            Array => {\n+                let len = ty.array_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                len * eltsz\n+            }\n+            _ => fail!(\"ty_size: unhandled type\")\n         }\n     }\n \n-    fn all_mem(cls: &mut [x86_64_reg_class]) {\n+    fn all_mem(cls: &mut [RegClass]) {\n         for uint::range(0, cls.len()) |i| {\n-            cls[i] = memory_class;\n+            cls[i] = Memory;\n         }\n     }\n \n-    fn unify(cls: &mut [x86_64_reg_class],\n+    fn unify(cls: &mut [RegClass],\n              i: uint,\n-             newv: x86_64_reg_class) {\n+             newv: RegClass) {\n         if cls[i] == newv {\n             return;\n-        } else if cls[i] == no_class {\n+        } else if cls[i] == NoClass {\n             cls[i] = newv;\n-        } else if newv == no_class {\n+        } else if newv == NoClass {\n             return;\n-        } else if cls[i] == memory_class || newv == memory_class {\n-            cls[i] = memory_class;\n-        } else if cls[i] == integer_class || newv == integer_class {\n-            cls[i] = integer_class;\n-        } else if cls[i] == x87_class ||\n-                  cls[i] == x87up_class ||\n-                  cls[i] == complex_x87_class ||\n-                  newv == x87_class ||\n-                  newv == x87up_class ||\n-                  newv == complex_x87_class {\n-            cls[i] = memory_class;\n+        } else if cls[i] == Memory || newv == Memory {\n+            cls[i] = Memory;\n+        } else if cls[i] == Int || newv == Int {\n+            cls[i] = Int;\n+        } else if cls[i] == X87 ||\n+                  cls[i] == X87Up ||\n+                  cls[i] == ComplexX87 ||\n+                  newv == X87 ||\n+                  newv == X87Up ||\n+                  newv == ComplexX87 {\n+            cls[i] = Memory;\n         } else {\n             cls[i] = newv;\n         }\n     }\n \n-    fn classify_struct(tys: &[TypeRef],\n-                       cls: &mut [x86_64_reg_class], i: uint,\n+    fn classify_struct(tys: &[Type],\n+                       cls: &mut [RegClass], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n         for tys.each |ty| {\n@@ -165,108 +183,104 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         }\n     }\n \n-    fn classify(ty: TypeRef,\n-                cls: &mut [x86_64_reg_class], ix: uint,\n+    fn classify(ty: Type,\n+                cls: &mut [RegClass], ix: uint,\n                 off: uint) {\n-        unsafe {\n-            let t_align = ty_align(ty);\n-            let t_size = ty_size(ty);\n-\n-            let misalign = off % t_align;\n-            if misalign != 0u {\n-                let mut i = off / 8u;\n-                let e = (off + t_size + 7u) / 8u;\n-                while i < e {\n-                    unify(cls, ix + i, memory_class);\n-                    i += 1u;\n-                }\n-                return;\n+        let t_align = ty_align(ty);\n+        let t_size = ty_size(ty);\n+\n+        let misalign = off % t_align;\n+        if misalign != 0u {\n+            let mut i = off / 8u;\n+            let e = (off + t_size + 7u) / 8u;\n+            while i < e {\n+                unify(cls, ix + i, Memory);\n+                i += 1u;\n             }\n+            return;\n+        }\n \n-            match llvm::LLVMGetTypeKind(ty) as int {\n-                8 /* integer */ |\n-                12 /* pointer */ => {\n-                    unify(cls, ix + off / 8u, integer_class);\n-                }\n-                2 /* float */ => {\n-                    if off % 8u == 4u {\n-                        unify(cls, ix + off / 8u, sse_fv_class);\n-                    } else {\n-                        unify(cls, ix + off / 8u, sse_fs_class);\n-                    }\n-                }\n-                3 /* double */ => {\n-                    unify(cls, ix + off / 8u, sse_ds_class);\n-                }\n-                10 /* struct */ => {\n-                    classify_struct(struct_tys(ty), cls, ix, off);\n+        match ty.kind() {\n+            Integer |\n+            Pointer => {\n+                unify(cls, ix + off / 8u, Int);\n+            }\n+            Float => {\n+                if off % 8u == 4u {\n+                    unify(cls, ix + off / 8u, SSEFv);\n+                } else {\n+                    unify(cls, ix + off / 8u, SSEFs);\n                 }\n-                11 /* array */ => {\n-                    let elt = llvm::LLVMGetElementType(ty);\n-                    let eltsz = ty_size(elt);\n-                    let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                    let mut i = 0u;\n-                    while i < len {\n-                        classify(elt, cls, ix, off + i * eltsz);\n-                        i += 1u;\n-                    }\n+            }\n+            Double => {\n+                unify(cls, ix + off / 8u, SSEDs);\n+            }\n+            Struct => {\n+                classify_struct(ty.field_types(), cls, ix, off);\n+            }\n+            Array => {\n+                let len = ty.array_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                let mut i = 0u;\n+                while i < len {\n+                    classify(elt, cls, ix, off + i * eltsz);\n+                    i += 1u;\n                 }\n-                _ => fail!(\"classify: unhandled type\")\n             }\n+            _ => fail!(\"classify: unhandled type\")\n         }\n     }\n \n-    fn fixup(ty: TypeRef, cls: &mut [x86_64_reg_class]) {\n-        unsafe {\n-            let mut i = 0u;\n-            let llty = llvm::LLVMGetTypeKind(ty) as int;\n-            let e = cls.len();\n-            if cls.len() > 2u &&\n-               (llty == 10 /* struct */ ||\n-                llty == 11 /* array */) {\n-                if is_sse(cls[i]) {\n-                    i += 1u;\n-                    while i < e {\n-                        if cls[i] != sseup_class {\n-                            all_mem(cls);\n-                            return;\n-                        }\n-                        i += 1u;\n-                    }\n-                } else {\n-                    all_mem(cls);\n-                    return\n-                }\n-            } else {\n+    fn fixup(ty: Type, cls: &mut [RegClass]) {\n+        let mut i = 0u;\n+        let ty_kind = ty.kind();\n+        let e = cls.len();\n+        if cls.len() > 2u &&\n+           (ty_kind == Struct ||\n+            ty_kind == Array) {\n+            if cls[i].is_sse() {\n+                i += 1u;\n                 while i < e {\n-                    if cls[i] == memory_class {\n+                    if cls[i] != SSEUp {\n                         all_mem(cls);\n                         return;\n                     }\n-                    if cls[i] == x87up_class {\n-                        // for darwin\n-                        // cls[i] = sse_ds_class;\n-                        all_mem(cls);\n-                        return;\n-                    }\n-                    if cls[i] == sseup_class {\n-                        cls[i] = sse_int_class;\n-                    } else if is_sse(cls[i]) {\n-                        i += 1;\n-                        while i != e && cls[i] == sseup_class { i += 1u; }\n-                    } else if cls[i] == x87_class {\n-                        i += 1;\n-                        while i != e && cls[i] == x87up_class { i += 1u; }\n-                    } else {\n-                        i += 1;\n-                    }\n+                    i += 1u;\n+                }\n+            } else {\n+                all_mem(cls);\n+                return\n+            }\n+        } else {\n+            while i < e {\n+                if cls[i] == Memory {\n+                    all_mem(cls);\n+                    return;\n+                }\n+                if cls[i] == X87Up {\n+                    // for darwin\n+                    // cls[i] = SSEDs;\n+                    all_mem(cls);\n+                    return;\n+                }\n+                if cls[i] == SSEUp {\n+                    cls[i] = SSEInt;\n+                } else if cls[i].is_sse() {\n+                    i += 1;\n+                    while i != e && cls[i] == SSEUp { i += 1u; }\n+                } else if cls[i] == X87 {\n+                    i += 1;\n+                    while i != e && cls[i] == X87Up { i += 1u; }\n+                } else {\n+                    i += 1;\n                 }\n             }\n         }\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = vec::from_elem(words, no_class);\n+    let mut cls = vec::from_elem(words, NoClass);\n     if words > 4 {\n         all_mem(cls);\n         let cls = cls;\n@@ -277,115 +291,89 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     return cls;\n }\n \n-fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n-    fn llvec_len(cls: &[x86_64_reg_class]) -> uint {\n+fn llreg_ty(cls: &[RegClass]) -> Type {\n+    fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n         for cls.each |c| {\n-            if *c != sseup_class {\n+            if *c != SSEUp {\n                 break;\n             }\n             len += 1u;\n         }\n         return len;\n     }\n \n-    unsafe {\n-        let mut tys = ~[];\n-        let mut i = 0u;\n-        let e = cls.len();\n-        while i < e {\n-            match cls[i] {\n-                integer_class => {\n-                    tys.push(T_i64());\n-                }\n-                sse_fv_class => {\n-                    let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n-                    let vec_ty = llvm::LLVMVectorType(T_f32(),\n-                                                      vec_len as c_uint);\n-                    tys.push(vec_ty);\n-                    i += vec_len;\n-                    loop;\n-                }\n-                sse_fs_class => {\n-                    tys.push(T_f32());\n-                }\n-                sse_ds_class => {\n-                    tys.push(T_f64());\n-                }\n-                _ => fail!(\"llregtype: unhandled class\")\n+    let mut tys = ~[];\n+    let mut i = 0u;\n+    let e = cls.len();\n+    while i < e {\n+        match cls[i] {\n+            Int => {\n+                tys.push(Type::i64());\n+            }\n+            SSEFv => {\n+                let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                let vec_ty = Type::vector(&Type::f32(), vec_len as u64);\n+                tys.push(vec_ty);\n+                i += vec_len;\n+                loop;\n+            }\n+            SSEFs => {\n+                tys.push(Type::f32());\n+            }\n+            SSEDs => {\n+                tys.push(Type::f64());\n             }\n-            i += 1u;\n+            _ => fail!(\"llregtype: unhandled class\")\n         }\n-        return T_struct(tys, false);\n+        i += 1u;\n     }\n+    return Type::struct_(tys, false);\n }\n \n-fn x86_64_tys(atys: &[TypeRef],\n-              rty: TypeRef,\n+fn x86_64_tys(atys: &[Type],\n+              rty: Type,\n               ret_def: bool) -> FnType {\n-    fn is_reg_ty(ty: TypeRef) -> bool {\n-        unsafe {\n-            return match llvm::LLVMGetTypeKind(ty) as int {\n-                8 /* integer */ |\n-                12 /* pointer */ |\n-                2 /* float */ |\n-                3 /* double */ => true,\n-                _ => false\n-            };\n-        }\n-    }\n-\n-    fn is_pass_byval(cls: &[x86_64_reg_class]) -> bool {\n-        return cls.len() > 0 &&\n-            (cls[0] == memory_class ||\n-             cls[0] == x87_class ||\n-             cls[0] == complex_x87_class);\n-    }\n-\n-    fn is_ret_bysret(cls: &[x86_64_reg_class]) -> bool {\n-        return cls.len() > 0 && cls[0] == memory_class;\n-    }\n \n-    fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: &fn(cls: &[x86_64_reg_class]) -> bool,\n+    fn x86_64_ty(ty: Type,\n+                 is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n-        let mut cast = false;\n-        let mut ty_attr = option::None;\n-        let mut llty = ty;\n-        if !is_reg_ty(ty) {\n+\n+        let (cast, attr, ty) = if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {\n-                llty = T_ptr(ty);\n-                ty_attr = option::Some(attr);\n+                (false, option::Some(attr), ty.ptr_to())\n             } else {\n-                cast = true;\n-                llty = llreg_ty(cls);\n+                (true, option::None, llreg_ty(cls))\n             }\n-        }\n-        return (LLVMType { cast: cast, ty: llty }, ty_attr);\n+        } else {\n+            (false, option::None, ty)\n+        };\n+\n+        (LLVMType { cast: cast, ty: ty }, attr)\n     }\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n     for atys.each |t| {\n-        let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n+        let (ty, attr) = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n         attrs.push(attr);\n     }\n-    let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n+    let mut (ret_ty, ret_attr) = x86_64_ty(rty, |cls| cls.is_ret_bysret(),\n                                        StructRetAttribute);\n     let sret = ret_attr.is_some();\n     if sret {\n         arg_tys = vec::append(~[ret_ty], arg_tys);\n         ret_ty = LLVMType {\n                    cast:  false,\n-                   ty: T_void()\n+                   ty: Type::void()\n                  };\n         attrs = vec::append(~[ret_attr], attrs);\n     } else if !ret_def {\n         ret_ty = LLVMType {\n                    cast: false,\n-                   ty: T_void()\n+                   ty: Type::void()\n                  };\n     }\n     return FnType {\n@@ -400,8 +388,8 @@ enum X86_64_ABIInfo { X86_64_ABIInfo }\n \n impl ABIInfo for X86_64_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         return x86_64_tys(atys, rty, ret_def);\n     }"}, {"sha": "0809b1c124e0ffde2ec2a4c44c8666fb69a8e0a2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -45,6 +45,8 @@ use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use util::ppaux::Repr;\n \n+use middle::trans::type_::Type;\n+\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -76,7 +78,7 @@ pub struct Callee {\n }\n \n pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n-    let _icx = bcx.insn_ctxt(\"trans_callee\");\n+    let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n@@ -170,7 +172,7 @@ pub fn trans_fn_ref(bcx: block,\n      * with id `def_id` into a function pointer.  This may require\n      * monomorphization or inlining. */\n \n-    let _icx = bcx.insn_ctxt(\"trans_fn_ref\");\n+    let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let type_params = node_id_type_params(bcx, ref_id);\n     let vtables = node_vtables(bcx, ref_id);\n@@ -214,7 +216,7 @@ pub fn trans_fn_ref_with_vtables(\n     // - `type_params`: values for each of the fn/method's type parameters\n     // - `vtables`: values for each bound on each of the type parameters\n \n-    let _icx = bcx.insn_ctxt(\"trans_fn_ref_with_vtables\");\n+    let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n@@ -326,7 +328,7 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = common::node_id_type(bcx, ref_id);\n \n             val = PointerCast(\n-                bcx, val, T_ptr(type_of::type_of_fn_from_ty(ccx, ref_ty)));\n+                bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n         }\n         return FnData {llfn: val};\n     }\n@@ -355,7 +357,7 @@ pub fn trans_call(in_cx: block,\n                   id: ast::node_id,\n                   dest: expr::Dest)\n                   -> block {\n-    let _icx = in_cx.insn_ctxt(\"trans_call\");\n+    let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      call_ex.info(),\n                      expr_ty(in_cx, f),\n@@ -373,7 +375,7 @@ pub fn trans_method_call(in_cx: block,\n                          args: CallArgs,\n                          dest: expr::Dest)\n                          -> block {\n-    let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n+    let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n            call_ex.repr(in_cx.tcx()),\n            rcvr.repr(in_cx.tcx()));\n@@ -516,7 +518,7 @@ pub fn trans_call_inner(in_cx: block,\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n         let ret_flag = if ret_in_loop {\n-            let flag = alloca(bcx, T_bool());\n+            let flag = alloca(bcx, Type::bool());\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n         } else {\n@@ -526,13 +528,13 @@ pub fn trans_call_inner(in_cx: block,\n         let (llfn, llenv) = unsafe {\n             match callee.data {\n                 Fn(d) => {\n-                    (d.llfn, llvm::LLVMGetUndef(T_opaque_box_ptr(ccx)))\n+                    (d.llfn, llvm::LLVMGetUndef(Type::opaque_box(ccx).ptr_to().to_ref()))\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n                     let llself = PointerCast(bcx,\n                                              d.llself,\n-                                             T_opaque_box_ptr(ccx));\n+                                             Type::opaque_box(ccx).ptr_to());\n                     (d.llfn, llself)\n                 }\n                 Closure(d) => {\n@@ -572,9 +574,9 @@ pub fn trans_call_inner(in_cx: block,\n \n         // Uncomment this to debug calls.\n         /*\n-        io::println(fmt!(\"calling: %s\", bcx.val_str(llfn)));\n+        io::println(fmt!(\"calling: %s\", bcx.val_to_str(llfn)));\n         for llargs.each |llarg| {\n-            io::println(fmt!(\"arg: %s\", bcx.val_str(*llarg)));\n+            io::println(fmt!(\"arg: %s\", bcx.val_to_str(*llarg)));\n         }\n         io::println(\"---\");\n         */\n@@ -653,7 +655,7 @@ pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: expr::Dest)\n         expr::Ignore => {\n             if ty::type_is_nil(retty) {\n                 unsafe {\n-                    llvm::LLVMGetUndef(T_ptr(T_nil()))\n+                    llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n                 }\n             } else {\n                 alloc_ty(bcx, retty)\n@@ -669,7 +671,7 @@ pub fn trans_args(cx: block,\n                   autoref_arg: AutorefArg,\n                   llargs: &mut ~[ValueRef]) -> block\n {\n-    let _icx = cx.insn_ctxt(\"trans_args\");\n+    let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n \n@@ -723,15 +725,15 @@ pub fn trans_arg_expr(bcx: block,\n                       temp_cleanups: &mut ~[ValueRef],\n                       ret_flag: Option<ValueRef>,\n                       autoref_arg: AutorefArg) -> Result {\n-    let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n+    let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s, \\\n             ret_flag=%?)\",\n            formal_arg_ty.repr(bcx.tcx()),\n            self_mode,\n            arg_expr.repr(bcx.tcx()),\n-           ret_flag.map(|v| bcx.val_str(*v)));\n+           ret_flag.map(|v| bcx.val_to_str(*v)));\n \n     // translate the arg expr to a datum\n     let arg_datumblock = match ret_flag {\n@@ -777,7 +779,7 @@ pub fn trans_arg_expr(bcx: block,\n         // to have type lldestty (the callee's expected type).\n         let llformal_arg_ty = type_of::type_of(ccx, formal_arg_ty);\n         unsafe {\n-            val = llvm::LLVMGetUndef(llformal_arg_ty);\n+            val = llvm::LLVMGetUndef(llformal_arg_ty.to_ref());\n         }\n     } else {\n         // FIXME(#3548) use the adjustments table\n@@ -838,15 +840,15 @@ pub fn trans_arg_expr(bcx: block,\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n             let llformal_arg_ty = match self_mode {\n-                ty::ByRef => T_ptr(llformal_arg_ty),\n+                ty::ByRef => llformal_arg_ty.ptr_to(),\n                 ty::ByCopy => llformal_arg_ty,\n             };\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n-                   bcx.val_str(val), bcx.llty_str(llformal_arg_ty));\n+                   bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }\n \n-    debug!(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n+    debug!(\"--- trans_arg_expr passing %s\", bcx.val_to_str(val));\n     return rslt(bcx, val);\n }"}, {"sha": "4ab9cd6c95713542ed399194ef4beceab5ed9c8d", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -26,6 +26,8 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use core::vec;\n use syntax::ast;\n@@ -72,7 +74,7 @@ use syntax::parse::token::special_idents;\n // closure\".\n //\n // Typically an opaque closure suffices because we only manipulate it\n-// by ptr.  The routine common::T_opaque_box_ptr() returns an\n+// by ptr.  The routine Type::opaque_box().ptr_to() returns an\n // appropriate type for such an opaque closure; it allows access to\n // the box fields, but not the closure_data itself.\n //\n@@ -160,15 +162,15 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n \n pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n-    let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n+    let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, llbox: ValueRef) {\n-        let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n+        let _icx = push_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n-        let llbox = PointerCast(bcx, llbox, T_opaque_box_ptr(ccx));\n+        let llbox = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n         let ref_cnt = GEPi(bcx, llbox, [0u, abi::box_field_refcnt]);\n         let rc = C_int(ccx, 0x12345678);\n         Store(bcx, rc, ref_cnt);\n@@ -204,7 +206,7 @@ pub struct ClosureResult {\n pub fn store_environment(bcx: block,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil) -> ClosureResult {\n-    let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n+    let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n@@ -258,7 +260,7 @@ pub fn build_closure(bcx0: block,\n                      cap_vars: &[moves::CaptureVar],\n                      sigil: ast::Sigil,\n                      include_ret_handle: Option<ValueRef>) -> ClosureResult {\n-    let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n+    let _icx = push_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let bcx = bcx0;\n \n@@ -298,12 +300,11 @@ pub fn build_closure(bcx0: block,\n         let ret_true = match bcx.fcx.loop_ret {\n             Some((_, retptr)) => retptr,\n             None => match bcx.fcx.llretptr {\n-                None => C_null(T_ptr(T_nil())),\n-                Some(retptr) => retptr,\n+                None => C_null(Type::nil().ptr_to()),\n+                Some(retptr) => PointerCast(bcx, retptr, Type::nil().ptr_to()),\n             }\n         };\n-        let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n-        let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(),\n+        let ret_datum = Datum {val: ret_true, ty: ty::mk_nil(),\n                                mode: ByRef(ZeroMem)};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: ret_datum});\n@@ -320,7 +321,7 @@ pub fn load_environment(fcx: fn_ctxt,\n                         cap_vars: &[moves::CaptureVar],\n                         load_ret_handle: bool,\n                         sigil: ast::Sigil) {\n-    let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n+    let _icx = push_ctxt(\"closure::load_environment\");\n \n     let llloadenv = match fcx.llloadenv {\n         Some(ll) => ll,\n@@ -391,7 +392,7 @@ pub fn trans_expr_fn(bcx: block,\n          (fn ptr, env) pair\n      */\n \n-    let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n+    let _icx = push_ctxt(\"closure::trans_expr_fn\");\n \n     let dest_addr = match dest {\n         expr::SaveIn(p) => p,\n@@ -468,7 +469,7 @@ pub fn make_closure_glue(\n         v: ValueRef,\n         t: ty::t,\n         glue_fn: @fn(block, v: ValueRef, t: ty::t) -> block) -> block {\n-    let _icx = cx.insn_ctxt(\"closure::make_closure_glue\");\n+    let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n@@ -492,7 +493,7 @@ pub fn make_opaque_cbox_take_glue(\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n-    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n+    let _icx = push_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match sigil {\n         ast::BorrowedSigil => {\n             return bcx;\n@@ -509,22 +510,22 @@ pub fn make_opaque_cbox_take_glue(\n     // ~fn requires a deep copy.\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n-    let llopaquecboxty = T_opaque_box_ptr(ccx);\n+    let llopaquecboxty = Type::opaque_box(ccx).ptr_to();\n     let cbox_in = Load(bcx, cboxptr);\n     do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n         let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n-        let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n+        let tydesc = PointerCast(bcx, tydesc, ccx.tydesc_type.ptr_to());\n         let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n-        let sz = Add(bcx, sz, machine::llsize_of(ccx, T_box_header(ccx)));\n+        let sz = Add(bcx, sz, machine::llsize_of(ccx, Type::box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n-        let opaque_tydesc = PointerCast(bcx, tydesc, T_ptr(T_i8()));\n-        let rval = alloca(bcx, T_ptr(T_i8()));\n+        let opaque_tydesc = PointerCast(bcx, tydesc, Type::i8p());\n+        let rval = alloca(bcx, Type::i8p());\n         let bcx = callee::trans_lang_call(\n             bcx,\n             bcx.tcx().lang_items.exchange_malloc_fn(),\n@@ -551,7 +552,7 @@ pub fn make_opaque_cbox_drop_glue(\n     sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n+    let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match sigil {\n         ast::BorrowedSigil => bcx,\n         ast::ManagedSigil => {\n@@ -572,7 +573,7 @@ pub fn make_opaque_cbox_free_glue(\n     sigil: ast::Sigil,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n+    let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match sigil {\n         ast::BorrowedSigil => {\n             return bcx;\n@@ -585,7 +586,7 @@ pub fn make_opaque_cbox_free_glue(\n     let ccx = bcx.ccx();\n     do with_cond(bcx, IsNotNull(bcx, cbox)) |bcx| {\n         // Load the type descr found in the cbox\n-        let lltydescty = T_ptr(ccx.tydesc_type);\n+        let lltydescty = ccx.tydesc_type.ptr_to();\n         let cbox = Load(bcx, cbox);\n         let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);"}, {"sha": "21e173fd0b435b3a27a8981122f6fe90694f3654", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 82, "deletions": 455, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -12,39 +12,36 @@\n \n use core::prelude::*;\n \n-use back::{abi};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n+use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n-use lib::llvm::{llvm, TypeNames, associate_type, name_has_type};\n+use lib::llvm::{llvm};\n use lib;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::datum;\n use middle::trans::glue;\n-use middle::trans::type_of;\n use middle::trans::write_guard;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n use middle::borrowck::root_map_key;\n use util::ppaux::{Repr};\n \n+use middle::trans::type_::Type;\n+\n use core::cast::transmute;\n use core::cast;\n use core::hashmap::{HashMap};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n-use core::str;\n use core::to_bytes;\n-use core::vec::raw::to_ptr;\n use core::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n use syntax::codemap::span;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n-use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::CrateContext;\n \n@@ -53,36 +50,16 @@ pub use middle::trans::context::CrateContext;\n pub type namegen = @fn(s: &str) -> ident;\n pub fn new_namegen() -> namegen {\n     let f: @fn(s: &str) -> ident = |prefix| {\n-        token::str_to_ident(fmt!(\"%s_%u\",\n-                                 prefix,\n-                                 token::gensym(prefix)))\n+        token::str_to_ident(fmt!(\"%s_%u\", prefix, token::gensym(prefix)))\n     };\n     f\n }\n \n-pub type addrspace = c_uint;\n-\n-// Address spaces communicate to LLVM which destructors need to run for\n-// specific types.\n-//    0 is ignored by the GC, and is used for all non-GC'd pointers.\n-//    1 is for opaque GC'd boxes.\n-//    >= 2 are for specific types (e.g. resources).\n-pub static default_addrspace: addrspace = 0;\n-pub static gc_box_addrspace: addrspace = 1;\n-\n-pub type addrspace_gen = @fn() -> addrspace;\n-pub fn new_addrspace_gen() -> addrspace_gen {\n-    let i = @mut 1;\n-    let result: addrspace_gen = || { *i += 1; *i };\n-    result\n-}\n-\n pub struct tydesc_info {\n     ty: ty::t,\n     tydesc: ValueRef,\n     size: ValueRef,\n     align: ValueRef,\n-    addrspace: addrspace,\n     take_glue: Option<ValueRef>,\n     drop_glue: Option<ValueRef>,\n     free_glue: Option<ValueRef>,\n@@ -124,7 +101,6 @@ pub struct Stats {\n     n_monos: uint,\n     n_inlines: uint,\n     n_closures: uint,\n-    llvm_insn_ctxt: ~[~str],\n     llvm_insns: HashMap<~str, uint>,\n     fn_times: ~[(~str, int)] // (ident, time)\n }\n@@ -347,47 +323,22 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-// This is not the same as datum::Datum::root(), which is used to keep copies\n-// of @ values live for as long as a borrowed pointer to the interior exists.\n-// In the new GC, we can identify immediates on the stack without difficulty,\n-// but have trouble knowing where non-immediates are on the stack. For\n-// non-immediates, we must add an additional level of indirection, which\n-// allows us to alloca a pointer with the right addrspace.\n-pub fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n-    -> (ValueRef, bool) {\n-    let ccx = bcx.ccx();\n-\n-    let addrspace = base::get_tydesc(ccx, t).addrspace;\n-    if addrspace > gc_box_addrspace {\n-        let llty = type_of::type_of_rooted(ccx, t);\n-        let root = base::alloca(bcx, llty);\n-        build::Store(bcx, build::PointerCast(bcx, v, llty), root);\n-        (root, true)\n-    } else {\n-        (v, false)\n-    }\n-}\n-\n pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n-    debug!(\"add_clean(%s, %s, %s)\",\n-           bcx.to_str(),\n-           val_str(bcx.ccx().tn, val),\n-           t.repr(bcx.tcx()));\n-    let (root, rooted) = root_for_cleanup(bcx, val, t);\n+\n+    debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean(|a| glue::drop_ty_root(a, root, rooted, t),\n-                  cleanup_type));\n+        scope_info.cleanups.push(clean(|a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n \n pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n-           cx.to_str(), val_str(cx.ccx().tn, val),\n+           cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |scope_info| {\n@@ -400,14 +351,11 @@ pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n-           bcx.to_str(), val_str(bcx.ccx().tn, val),\n+           bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n-    let (root, rooted) = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n-                       cleanup_type));\n+        scope_info.cleanups.push(clean_temp(val, |a| glue::drop_ty(a, val, t), cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -427,18 +375,14 @@ pub fn add_clean_return_to_mut(bcx: block,\n \n     debug!(\"add_clean_return_to_mut(%s, %s, %s)\",\n            bcx.to_str(),\n-           val_str(bcx.ccx().tn, frozen_val_ref),\n-           val_str(bcx.ccx().tn, bits_val_ref));\n+           bcx.val_to_str(frozen_val_ref),\n+           bcx.val_to_str(bits_val_ref));\n     do in_scope_cx(bcx) |scope_info| {\n         scope_info.cleanups.push(\n             clean_temp(\n                 frozen_val_ref,\n-                |bcx| write_guard::return_to_mut(bcx,\n-                                                 root_key,\n-                                                 frozen_val_ref,\n-                                                 bits_val_ref,\n-                                                 filename_val,\n-                                                 line_val),\n+                |bcx| write_guard::return_to_mut(bcx, root_key, frozen_val_ref, bits_val_ref,\n+                                                 filename_val, line_val),\n                 normal_exit_only));\n         grow_scope_clean(scope_info);\n     }\n@@ -623,20 +567,12 @@ impl Result {\n     }\n }\n \n-pub fn ty_str(tn: @TypeNames, t: TypeRef) -> @str {\n-    return lib::llvm::type_to_str(tn, t);\n-}\n-\n-pub fn val_ty(v: ValueRef) -> TypeRef {\n+pub fn val_ty(v: ValueRef) -> Type {\n     unsafe {\n-        return llvm::LLVMTypeOf(v);\n+        Type::from_ref(llvm::LLVMTypeOf(v))\n     }\n }\n \n-pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n-    return ty_str(tn, val_ty(v));\n-}\n-\n pub fn in_scope_cx(cx: block, f: &fn(si: @mut scope_info)) {\n     let mut cur = cx;\n     loop {\n@@ -664,27 +600,27 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n impl block_ {\n-    pub fn ccx(@mut self) -> @mut CrateContext { self.fcx.ccx }\n-    pub fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n-    pub fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n+    pub fn ccx(&self) -> @mut CrateContext { self.fcx.ccx }\n+    pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n-    pub fn node_id_to_str(@mut self, id: ast::node_id) -> ~str {\n+    pub fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n-    pub fn expr_to_str(@mut self, e: @ast::expr) -> ~str {\n+    pub fn expr_to_str(&self, e: @ast::expr) -> ~str {\n         e.repr(self.tcx())\n     }\n \n-    pub fn expr_is_lval(@mut self, e: @ast::expr) -> bool {\n+    pub fn expr_is_lval(&self, e: @ast::expr) -> bool {\n         ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    pub fn expr_kind(@mut self, e: @ast::expr) -> ty::ExprKind {\n+    pub fn expr_kind(&self, e: @ast::expr) -> ty::ExprKind {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    pub fn def(@mut self, nid: ast::node_id) -> ast::def {\n+    pub fn def(&self, nid: ast::node_id) -> ast::def {\n         match self.tcx().def_map.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -694,19 +630,19 @@ impl block_ {\n         }\n     }\n \n-    pub fn val_str(@mut self, val: ValueRef) -> @str {\n-        val_str(self.ccx().tn, val)\n+    pub fn val_to_str(&self, val: ValueRef) -> ~str {\n+        self.ccx().tn.val_to_str(val)\n     }\n \n-    pub fn llty_str(@mut self, llty: TypeRef) -> @str {\n-        ty_str(self.ccx().tn, llty)\n+    pub fn llty_str(&self, ty: Type) -> ~str {\n+        self.ccx().tn.type_to_str(ty)\n     }\n \n-    pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n         t.repr(self.tcx())\n     }\n \n-    pub fn to_str(@mut self) -> ~str {\n+    pub fn to_str(&self) -> ~str {\n         unsafe {\n             match self.node_info {\n                 Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n@@ -716,229 +652,6 @@ impl block_ {\n     }\n }\n \n-// LLVM type constructors.\n-pub fn T_void() -> TypeRef {\n-    unsafe { return llvm::LLVMVoidTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_nil() -> TypeRef {\n-    return T_struct([], false)\n-}\n-\n-pub fn T_metadata() -> TypeRef {\n-    unsafe { return llvm::LLVMMetadataTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i1() -> TypeRef {\n-    unsafe { return llvm::LLVMInt1TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i8() -> TypeRef {\n-    unsafe { return llvm::LLVMInt8TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i16() -> TypeRef {\n-    unsafe { return llvm::LLVMInt16TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i32() -> TypeRef {\n-    unsafe { return llvm::LLVMInt32TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_i64() -> TypeRef {\n-    unsafe { return llvm::LLVMInt64TypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_f32() -> TypeRef {\n-    unsafe { return llvm::LLVMFloatTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_f64() -> TypeRef {\n-    unsafe { return llvm::LLVMDoubleTypeInContext(base::task_llcx()); }\n-}\n-\n-pub fn T_bool() -> TypeRef { return T_i8(); }\n-\n-pub fn T_int(targ_cfg: &session::config) -> TypeRef {\n-    return match targ_cfg.arch {\n-        X86 => T_i32(),\n-        X86_64 => T_i64(),\n-        Arm => T_i32(),\n-        Mips => T_i32()\n-    };\n-}\n-\n-pub fn T_int_ty(cx: &CrateContext, t: ast::int_ty) -> TypeRef {\n-    match t {\n-      ast::ty_i => cx.int_type,\n-      ast::ty_char => T_char(),\n-      ast::ty_i8 => T_i8(),\n-      ast::ty_i16 => T_i16(),\n-      ast::ty_i32 => T_i32(),\n-      ast::ty_i64 => T_i64()\n-    }\n-}\n-\n-pub fn T_uint_ty(cx: &CrateContext, t: ast::uint_ty) -> TypeRef {\n-    match t {\n-      ast::ty_u => cx.int_type,\n-      ast::ty_u8 => T_i8(),\n-      ast::ty_u16 => T_i16(),\n-      ast::ty_u32 => T_i32(),\n-      ast::ty_u64 => T_i64()\n-    }\n-}\n-\n-pub fn T_float_ty(cx: &CrateContext, t: ast::float_ty) -> TypeRef {\n-    match t {\n-      ast::ty_f => cx.float_type,\n-      ast::ty_f32 => T_f32(),\n-      ast::ty_f64 => T_f64()\n-    }\n-}\n-\n-pub fn T_float(targ_cfg: &session::config) -> TypeRef {\n-    return match targ_cfg.arch {\n-        X86 => T_f64(),\n-        X86_64 => T_f64(),\n-        Arm => T_f64(),\n-        Mips => T_f64()\n-    };\n-}\n-\n-pub fn T_char() -> TypeRef { return T_i32(); }\n-\n-pub fn T_size_t(targ_cfg: &session::config) -> TypeRef {\n-    return T_int(targ_cfg);\n-}\n-\n-pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                                      inputs.len() as c_uint,\n-                                      False);\n-    }\n-}\n-\n-pub fn T_fn_pair(cx: &CrateContext, tfn: TypeRef) -> TypeRef {\n-    return T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)], false);\n-}\n-\n-pub fn T_ptr(t: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, default_addrspace);\n-    }\n-}\n-\n-pub fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, addrspace);\n-    }\n-}\n-\n-pub fn T_struct(elts: &[TypeRef], packed: bool) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMStructTypeInContext(base::task_llcx(),\n-                                             to_ptr(elts),\n-                                             elts.len() as c_uint,\n-                                             packed as Bool);\n-    }\n-}\n-\n-pub fn T_named_struct(name: &str) -> TypeRef {\n-    unsafe {\n-        return str::as_c_str(name, |buf| {\n-            llvm::LLVMStructCreateNamed(base::task_llcx(), buf)\n-        });\n-    }\n-}\n-\n-pub fn set_struct_body(t: TypeRef, elts: &[TypeRef], packed: bool) {\n-    unsafe {\n-        llvm::LLVMStructSetBody(t,\n-                                to_ptr(elts),\n-                                elts.len() as c_uint,\n-                                packed as Bool);\n-    }\n-}\n-\n-pub fn T_empty_struct() -> TypeRef { return T_struct([], false); }\n-\n-// A vtable is, in reality, a vtable pointer followed by zero or more pointers\n-// to tydescs and other vtables that it closes over. But the types and number\n-// of those are rarely known to the code that needs to manipulate them, so\n-// they are described by this opaque type.\n-pub fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n-\n-pub fn T_tydesc_field(cx: &CrateContext, field: uint) -> TypeRef {\n-    // Bit of a kludge: pick the fn typeref out of the tydesc..\n-\n-    unsafe {\n-        let mut tydesc_elts: ~[TypeRef] =\n-            vec::from_elem::<TypeRef>(abi::n_tydesc_fields,\n-                                     T_nil());\n-        llvm::LLVMGetStructElementTypes(cx.tydesc_type, &mut tydesc_elts[0]);\n-        let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n-        return t;\n-    }\n-}\n-\n-pub fn T_generic_glue_fn(cx: &mut CrateContext) -> TypeRef {\n-    let s = @\"glue_fn\";\n-    match name_has_type(cx.tn, s) {\n-      Some(t) => return t,\n-      _ => ()\n-    }\n-    let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n-    associate_type(cx.tn, s, t);\n-    return t;\n-}\n-\n-pub fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n-    let tydesc = T_named_struct(\"tydesc\");\n-    let tydescpp = T_ptr(T_ptr(tydesc));\n-    let pvoid = T_ptr(T_i8());\n-    let glue_fn_ty =\n-        T_ptr(T_fn([T_ptr(T_nil()), tydescpp, pvoid], T_void()));\n-\n-    let int_type = T_int(targ_cfg);\n-    let elems =\n-        ~[int_type, int_type,\n-          glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n-          T_ptr(T_i8()), T_ptr(T_i8())];\n-    set_struct_body(tydesc, elems, false);\n-    return tydesc;\n-}\n-\n-pub fn T_array(t: TypeRef, n: uint) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMArrayType(t, n as c_uint);\n-    }\n-}\n-\n-pub fn T_vector(t: TypeRef, n: uint) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMVectorType(t, n as c_uint);\n-    }\n-}\n-\n-// Interior vector.\n-pub fn T_vec2(targ_cfg: &session::config, t: TypeRef) -> TypeRef {\n-    return T_struct([T_int(targ_cfg), // fill\n-                     T_int(targ_cfg), // alloc\n-                     T_array(t, 0u)], // elements\n-                    false);\n-}\n-\n-pub fn T_vec(ccx: &CrateContext, t: TypeRef) -> TypeRef {\n-    return T_vec2(ccx.sess.targ_cfg, t);\n-}\n-\n-// Note that the size of this one is in bytes.\n-pub fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n-    return T_vec2(targ_cfg, T_i8());\n-}\n-\n // Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n@@ -952,163 +665,84 @@ pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n                          t]);\n }\n \n-pub fn T_box_header_fields(cx: &CrateContext) -> ~[TypeRef] {\n-    let ptr = T_ptr(T_i8());\n-    return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n-}\n-\n-pub fn T_box_header(cx: &CrateContext) -> TypeRef {\n-    return T_struct(T_box_header_fields(cx), false);\n-}\n-\n-pub fn T_box(cx: &CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n-}\n-\n-pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, gc_box_addrspace);\n-    }\n-}\n-\n-pub fn T_opaque_box(cx: &CrateContext) -> TypeRef {\n-    return T_box(cx, T_i8());\n-}\n-\n-pub fn T_opaque_box_ptr(cx: &CrateContext) -> TypeRef {\n-    return T_box_ptr(T_opaque_box(cx));\n-}\n-\n-pub fn T_unique(cx: &CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n-}\n-\n-pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n-    unsafe {\n-        return llvm::LLVMPointerType(t, gc_box_addrspace);\n-    }\n-}\n-\n-pub fn T_port(cx: &CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct([cx.int_type], false); // Refcount\n-\n-}\n-\n-pub fn T_chan(cx: &CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct([cx.int_type], false); // Refcount\n-\n-}\n-\n-\n-pub fn T_opaque_cbox_ptr(cx: &CrateContext) -> TypeRef {\n-    // closures look like boxes (even when they are ~fn or &fn)\n-    // see trans_closure.rs\n-    return T_opaque_box_ptr(cx);\n-}\n-\n-pub fn T_enum_discrim(cx: &CrateContext) -> TypeRef {\n-    return cx.int_type;\n-}\n-\n-pub fn T_captured_tydescs(cx: &CrateContext, n: uint) -> TypeRef {\n-    return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)), false);\n-}\n-\n-pub fn T_opaque_trait(cx: &CrateContext, store: ty::TraitStore) -> TypeRef {\n-    match store {\n-        ty::BoxTraitStore => {\n-            T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)], false)\n-        }\n-        ty::UniqTraitStore => {\n-            T_struct([T_ptr(cx.tydesc_type),\n-                      T_unique_ptr(T_unique(cx, T_i8()))],\n-                     false)\n-        }\n-        ty::RegionTraitStore(_) => {\n-            T_struct([T_ptr(cx.tydesc_type), T_ptr(T_i8())], false)\n-        }\n-    }\n-}\n-\n-pub fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }\n-\n-pub fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n-\n \n // LLVM constant constructors.\n-pub fn C_null(t: TypeRef) -> ValueRef {\n+pub fn C_null(t: Type) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstNull(t);\n+        llvm::LLVMConstNull(t.to_ref())\n     }\n }\n \n-pub fn C_undef(t: TypeRef) -> ValueRef {\n+pub fn C_undef(t: Type) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMGetUndef(t);\n+        llvm::LLVMGetUndef(t.to_ref())\n     }\n }\n \n-pub fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n+pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstInt(t, u, sign_extend);\n+        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n     }\n }\n \n-pub fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n+pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n+        do s.as_c_str |buf| {\n+            llvm::LLVMConstRealOfString(t.to_ref(), buf)\n+        }\n     }\n }\n \n pub fn C_nil() -> ValueRef {\n     return C_struct([]);\n }\n \n-pub fn C_bool(b: bool) -> ValueRef {\n-    C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n+pub fn C_bool(val: bool) -> ValueRef {\n+    C_integral(Type::bool(), val as u64, false)\n }\n \n-pub fn C_i1(b: bool) -> ValueRef {\n-    return C_integral(T_i1(), if b { 1 } else { 0 }, False);\n+pub fn C_i1(val: bool) -> ValueRef {\n+    C_integral(Type::i1(), val as u64, false)\n }\n \n pub fn C_i32(i: i32) -> ValueRef {\n-    return C_integral(T_i32(), i as u64, True);\n+    return C_integral(Type::i32(), i as u64, true);\n }\n \n pub fn C_i64(i: i64) -> ValueRef {\n-    return C_integral(T_i64(), i as u64, True);\n+    return C_integral(Type::i64(), i as u64, true);\n }\n \n pub fn C_int(cx: &CrateContext, i: int) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, True);\n+    return C_integral(cx.int_type, i as u64, true);\n }\n \n pub fn C_uint(cx: &CrateContext, i: uint) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, False);\n+    return C_integral(cx.int_type, i as u64, false);\n }\n \n pub fn C_u8(i: uint) -> ValueRef {\n-    return C_integral(T_i8(), i as u64, False);\n+    return C_integral(Type::i8(), i as u64, false);\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.find(&s) {\n+        match cx.const_cstr_cache.find_equiv(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n \n-        let sc = do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint,\n-                                           False)\n+        let sc = do s.as_c_str |buf| {\n+            llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint, False)\n+        };\n+\n+        let gsym = token::gensym(\"str\");\n+        let g = do fmt!(\"str%u\", gsym).as_c_str |buf| {\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n-        let g =\n-            str::as_c_str(fmt!(\"str%u\", (cx.names)(\"str\").name),\n-                        |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -1124,18 +758,17 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n-        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n+        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n         C_struct([cs, C_uint(cx, len + 1u /* +1 for null */)])\n     }\n }\n \n // Returns a Plain Old LLVM String:\n pub fn C_postr(s: &str) -> ValueRef {\n     unsafe {\n-        return do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstStringInContext(base::task_llcx(),\n-                                           buf, s.len() as c_uint, False)\n-        };\n+        do s.as_c_str |buf| {\n+            llvm::LLVMConstStringInContext(base::task_llcx(), buf, s.len() as c_uint, False)\n+        }\n     }\n }\n \n@@ -1144,72 +777,66 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n         let mut i = 0u;\n         let mut elts: ~[ValueRef] = ~[];\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n-        return llvm::LLVMConstArray(T_i8(),\n-                                    vec::raw::to_ptr(elts),\n-                                    elts.len() as c_uint);\n+        return llvm::LLVMConstArray(Type::i8().to_ref(),\n+                                    vec::raw::to_ptr(elts), elts.len() as c_uint);\n     }\n }\n \n pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstStructInContext(base::task_llcx(),\n-                                           ptr, len as c_uint, False)\n+            llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, False)\n         }\n     }\n }\n \n pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstStructInContext(base::task_llcx(),\n-                                           ptr, len as c_uint, True)\n+            llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, True)\n         }\n     }\n }\n \n-pub fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n-            llvm::LLVMConstNamedStruct(T, ptr, len as c_uint)\n+            llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n         }\n     }\n }\n \n-pub fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n-                                    elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty.to_ref(), vec::raw::to_ptr(elts), elts.len() as c_uint);\n     }\n }\n \n pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstStringInContext(base::task_llcx(),\n-            cast::transmute(vec::raw::to_ptr(bytes)),\n-            bytes.len() as c_uint, True);\n+        let ptr = cast::transmute(vec::raw::to_ptr(bytes));\n+        return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint, True);\n     }\n }\n \n pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstStringInContext(base::task_llcx(),\n-            cast::transmute(vec::raw::to_ptr(bytes)),\n-            bytes.len() as c_uint, False);\n+        let ptr = cast::transmute(vec::raw::to_ptr(bytes));\n+        return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint,False);\n     }\n }\n \n pub fn C_shape(ccx: &CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n-        let name = fmt!(\"shape%u\", (ccx.names)(\"shape\").name);\n-        let llglobal = str::as_c_str(name, |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n-        });\n+        let name = fmt!(\"shape%u\", token::gensym(\"shape\"));\n+        let llglobal = do name.as_c_str |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape).to_ref(), buf)\n+        };\n         llvm::LLVMSetInitializer(llglobal, llshape);\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n-        return llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n+        return llvm::LLVMConstPointerCast(llglobal, Type::i8p().to_ref());\n     }\n }\n \n@@ -1227,7 +854,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n         };\n \n         debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n-               val_str(cx.tn, v), us, val_str(cx.tn, r));\n+               cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n \n         return r;\n     }\n@@ -1484,7 +1111,7 @@ pub fn filename_and_line_num_from_span(bcx: block,\n                                        span: span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n-    let filename = build::PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n+    let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)\n }"}, {"sha": "e40534773c2d0916e1ff9c62eca4f86ce0928c00", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -11,16 +11,15 @@\n use core::prelude::*;\n \n use back::abi;\n-use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, TypeRef, Bool,\n-    True, False};\n+use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True};\n use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n     RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n \n use metadata::csearch;\n use middle::const_eval;\n use middle::trans::adt;\n use middle::trans::base;\n-use middle::trans::base::get_insn_ctxt;\n+use middle::trans::base::push_ctxt;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::expr;\n@@ -30,36 +29,38 @@ use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n+use middle::trans::type_::Type;\n+\n use core::libc::c_uint;\n use core::str;\n use syntax::{ast, ast_util, ast_map};\n \n pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"trans_lit\");\n+    let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n-      ast::lit_int(i, t) => C_integral(T_int_ty(cx, t), i as u64, True),\n-      ast::lit_uint(u, t) => C_integral(T_uint_ty(cx, t), u, False),\n+      ast::lit_int(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n+      ast::lit_uint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n       ast::lit_int_unsuffixed(i) => {\n         let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_int_ty).sty {\n           ty::ty_int(t) => {\n-            C_integral(T_int_ty(cx, t), i as u64, True)\n+            C_integral(Type::int_from_ty(cx, t), i as u64, true)\n           }\n           ty::ty_uint(t) => {\n-            C_integral(T_uint_ty(cx, t), i as u64, False)\n+            C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n           }\n           _ => cx.sess.span_bug(lit.span,\n                    fmt!(\"integer literal has type %s (expected int or uint)\",\n                         ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n-      ast::lit_float(fs, t) => C_floating(fs, T_float_ty(cx, t)),\n+      ast::lit_float(fs, t) => C_floating(fs, Type::float_from_ty(cx, t)),\n       ast::lit_float_unsuffixed(fs) => {\n         let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_float_ty).sty {\n           ty::ty_float(t) => {\n-            C_floating(fs, T_float_ty(cx, t))\n+            C_floating(fs, Type::float_from_ty(cx, t))\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,\n@@ -73,16 +74,16 @@ pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n+pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n-        let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n+        let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n         assert!(cx.const_globals.insert(b as int, a));\n         b\n     }\n }\n \n pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n-    -> (ValueRef, ValueRef, TypeRef) {\n+    -> (ValueRef, ValueRef, Type) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n         let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n@@ -102,8 +103,8 @@ pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n \n fn const_addr_of(cx: @mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let gv = do str::as_c_str(\"const\") |name| {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv), name)\n+        let gv = do \"const\".as_c_str |name| {\n+            llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n         };\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv, True);\n@@ -180,7 +181,7 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     match adjustment {\n         None => { }\n         Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n-            llconst = C_struct([llconst, C_null(T_opaque_box_ptr(cx))])\n+            llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())])\n         }\n         Some(@ty::AutoAddEnv(ref r, ref s)) => {\n             cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n@@ -248,7 +249,7 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n \n fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n-        let _icx = cx.insn_ctxt(\"const_expr\");\n+        let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n           ast::expr_binary(_, b, e1, e2) => {\n@@ -349,9 +350,9 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                     ty::ty_bool => {\n                         // Somewhat questionable, but I believe this is\n                         // correct.\n-                        let te = llvm::LLVMConstTrunc(te, T_i1());\n+                        let te = llvm::LLVMConstTrunc(te, Type::i1().to_ref());\n                         let te = llvm::LLVMConstNot(te);\n-                        llvm::LLVMConstZExt(te, T_bool())\n+                        llvm::LLVMConstZExt(te, Type::bool().to_ref())\n                     }\n                     _ => llvm::LLVMConstNot(te),\n                 }\n@@ -426,21 +427,21 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n-                llvm::LLVMConstIntCast(v, llty, s)\n+                llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n               (expr::cast_integral, expr::cast_float) => {\n                 if ty::type_is_signed(basety) {\n-                    llvm::LLVMConstSIToFP(v, llty)\n+                    llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n-                    llvm::LLVMConstUIToFP(v, llty)\n+                    llvm::LLVMConstUIToFP(v, llty.to_ref())\n                 }\n               }\n               (expr::cast_float, expr::cast_float) => {\n-                llvm::LLVMConstFPCast(v, llty)\n+                llvm::LLVMConstFPCast(v, llty.to_ref())\n               }\n               (expr::cast_float, expr::cast_integral) => {\n-                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty) }\n-                else { llvm::LLVMConstFPToUI(v, llty) }\n+                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n+                else { llvm::LLVMConstFPToUI(v, llty.to_ref()) }\n               }\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n@@ -451,18 +452,18 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                 match ety_cast {\n                     expr::cast_integral => {\n                         let s = ty::type_is_signed(ety) as Bool;\n-                        llvm::LLVMConstIntCast(iv, llty, s)\n+                        llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                     }\n-                    expr::cast_float => llvm::LLVMConstUIToFP(iv, llty),\n+                    expr::cast_float => llvm::LLVMConstUIToFP(iv, llty.to_ref()),\n                     _ => cx.sess.bug(\"enum cast destination is not \\\n                                       integral or float\")\n                 }\n               }\n               (expr::cast_pointer, expr::cast_pointer) => {\n-                llvm::LLVMConstPointerCast(v, llty)\n+                llvm::LLVMConstPointerCast(v, llty.to_ref())\n               }\n               (expr::cast_integral, expr::cast_pointer) => {\n-                llvm::LLVMConstIntToPtr(v, llty)\n+                llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n               _ => {\n                 cx.sess.impossible_case(e.span,\n@@ -513,7 +514,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                 let (cv, sz, llunitty) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n                 let gv = do str::as_c_str(\"const\") |name| {\n-                    llvm::LLVMAddGlobal(cx.llmod, llty, name)\n+                    llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n                 };\n                 llvm::LLVMSetInitializer(gv, cv);\n                 llvm::LLVMSetGlobalConstant(gv, True);\n@@ -588,7 +589,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n \n pub fn trans_const(ccx: @mut CrateContext, _e: @ast::expr, id: ast::node_id) {\n     unsafe {\n-        let _icx = ccx.insn_ctxt(\"trans_const\");\n+        let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type."}, {"sha": "715b1c88327f5e3feb191945eb8c3be7350a2ad6", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -12,10 +12,9 @@ use core::prelude::*;\n \n use back::{upcall};\n use driver::session;\n-use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef};\n+use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n-use lib::llvm::{mk_target_data, mk_type_names};\n-use lib;\n+use lib::llvm::{mk_target_data};\n use metadata::common::LinkMeta;\n use middle::astencode;\n use middle::resolve;\n@@ -27,15 +26,17 @@ use middle::trans::shape;\n use middle::trans::type_use;\n use middle::ty;\n \n+use middle::trans::type_::Type;\n+\n use core::hash;\n use core::hashmap::{HashMap, HashSet};\n use core::str;\n use core::local_data;\n+use extra::time;\n use syntax::ast;\n \n-use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res,Stats,namegen,addrspace_gen};\n-use middle::trans::common::{mono_id,T_int,T_float,T_tydesc,T_opaque_vec};\n-use middle::trans::common::{new_namegen,new_addrspace_gen};\n+use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res,Stats,namegen};\n+use middle::trans::common::{mono_id,new_namegen};\n \n use middle::trans::base::{decl_crate_map};\n \n@@ -46,7 +47,7 @@ pub struct CrateContext {\n      llmod: ModuleRef,\n      llcx: ContextRef,\n      td: TargetData,\n-     tn: @TypeNames,\n+     tn: TypeNames,\n      externs: ExternMap,\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n@@ -92,11 +93,10 @@ pub struct CrateContext {\n      impl_method_cache: HashMap<(ast::def_id, ast::ident), ast::def_id>,\n \n      module_data: HashMap<~str, ValueRef>,\n-     lltypes: HashMap<ty::t, TypeRef>,\n-     llsizingtypes: HashMap<ty::t, TypeRef>,\n+     lltypes: HashMap<ty::t, Type>,\n+     llsizingtypes: HashMap<ty::t, Type>,\n      adt_reprs: HashMap<ty::t, @adt::Repr>,\n      names: namegen,\n-     next_addrspace: addrspace_gen,\n      symbol_hasher: hash::State,\n      type_hashcodes: HashMap<ty::t, @str>,\n      type_short_names: HashMap<ty::t, ~str>,\n@@ -105,10 +105,10 @@ pub struct CrateContext {\n      maps: astencode::Maps,\n      stats: Stats,\n      upcalls: @upcall::Upcalls,\n-     tydesc_type: TypeRef,\n-     int_type: TypeRef,\n-     float_type: TypeRef,\n-     opaque_vec_type: TypeRef,\n+     tydesc_type: Type,\n+     int_type: Type,\n+     float_type: Type,\n+     opaque_vec_type: Type,\n      builder: BuilderRef_res,\n      shape_cx: shape::Ctxt,\n      crate_map: ValueRef,\n@@ -136,23 +136,36 @@ impl CrateContext {\n             str::as_c_str(data_layout, |buf| llvm::LLVMSetDataLayout(llmod, buf));\n             str::as_c_str(targ_triple, |buf| llvm::LLVMSetTarget(llmod, buf));\n             let targ_cfg = sess.targ_cfg;\n+\n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n-            let tn = mk_type_names();\n+            let mut tn = TypeNames::new();\n+\n             let mut intrinsics = base::declare_intrinsics(llmod);\n             if sess.opts.extra_debuginfo {\n                 base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n             }\n-            let int_type = T_int(targ_cfg);\n-            let float_type = T_float(targ_cfg);\n-            let tydesc_type = T_tydesc(targ_cfg);\n-            lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n+            let int_type = Type::int(targ_cfg.arch);\n+            let float_type = Type::float(targ_cfg.arch);\n+            let tydesc_type = Type::tydesc(targ_cfg.arch);\n+            let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n+\n+            let mut str_slice_ty = Type::named_struct(\"str_slice\");\n+            str_slice_ty.set_struct_body([Type::i8p(), int_type], false);\n+\n+            tn.associate_type(\"tydesc\", &tydesc_type);\n+            tn.associate_type(\"str_slice\", &str_slice_ty);\n+\n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n                 Some(debuginfo::DebugContext::new(llmod, name.to_owned()))\n             } else {\n                 None\n             };\n \n+            if sess.count_llvm_insns() {\n+                base::init_insn_ctxt()\n+            }\n+\n             CrateContext {\n                   sess: sess,\n                   llmod: llmod,\n@@ -186,7 +199,6 @@ impl CrateContext {\n                   llsizingtypes: HashMap::new(),\n                   adt_reprs: HashMap::new(),\n                   names: new_namegen(),\n-                  next_addrspace: new_addrspace_gen(),\n                   symbol_hasher: symbol_hasher,\n                   type_hashcodes: HashMap::new(),\n                   type_short_names: HashMap::new(),\n@@ -202,15 +214,14 @@ impl CrateContext {\n                     n_monos: 0u,\n                     n_inlines: 0u,\n                     n_closures: 0u,\n-                    llvm_insn_ctxt: ~[],\n                     llvm_insns: HashMap::new(),\n                     fn_times: ~[]\n                   },\n                   upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n                   tydesc_type: tydesc_type,\n                   int_type: int_type,\n                   float_type: float_type,\n-                  opaque_vec_type: T_opaque_vec(targ_cfg),\n+                  opaque_vec_type: opaque_vec_type,\n                   builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                   shape_cx: mk_ctxt(llmod),\n                   crate_map: crate_map,\n@@ -220,6 +231,12 @@ impl CrateContext {\n             }\n         }\n     }\n+\n+    pub fn log_fn_time(&mut self, name: ~str, start: time::Timespec, end: time::Timespec) {\n+        let elapsed = 1000 * ((end.sec - start.sec) as int) +\n+            ((end.nsec as int) - (start.nsec as int)) / 1000000;\n+        self.stats.fn_times.push((name, elapsed));\n+    }\n }\n \n #[unsafe_destructor]\n@@ -232,7 +249,6 @@ impl Drop for CrateContext {\n }\n \n fn task_local_llcx_key(_v: @ContextRef) {}\n-\n pub fn task_llcx() -> ContextRef {\n     let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")"}, {"sha": "6be26354db1635a74e24e862d123918c211a4647", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -24,6 +24,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use core::vec;\n use syntax::ast;\n@@ -33,7 +35,7 @@ use syntax::ast_util;\n use syntax::codemap::span;\n \n pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_block\");\n+    let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| {\n         bcx = alloc_local(bcx, local);\n@@ -65,7 +67,7 @@ pub fn trans_if(bcx: block,\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n-    let _icx = bcx.insn_ctxt(\"trans_if\");\n+    let _icx = push_ctxt(\"trans_if\");\n     let Result {bcx, val: cond_val} =\n         expr::trans_to_datum(bcx, cond).to_result();\n \n@@ -124,7 +126,7 @@ pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n }\n \n pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::blk) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_while\");\n+    let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n     //            bcx\n@@ -166,7 +168,7 @@ pub fn trans_loop(bcx:block,\n                   body: &ast::blk,\n                   opt_label: Option<ident>)\n                -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_loop\");\n+    let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n                                        body.info());\n@@ -180,7 +182,7 @@ pub fn trans_log(log_ex: @ast::expr,\n                  lvl: @ast::expr,\n                  bcx: block,\n                  e: @ast::expr) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_log\");\n+    let _icx = push_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n@@ -204,10 +206,10 @@ pub fn trans_log(log_ex: @ast::expr,\n         let global;\n         unsafe {\n             global = str::as_c_str(s, |buf| {\n-                llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+                llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n             });\n             llvm::LLVMSetGlobalConstant(global, False);\n-            llvm::LLVMSetInitializer(global, C_null(T_i32()));\n+            llvm::LLVMSetInitializer(global, C_null(Type::i32()));\n             lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n         }\n         ccx.module_data.insert(modname, global);\n@@ -242,7 +244,7 @@ pub fn trans_break_cont(bcx: block,\n                         opt_label: Option<ident>,\n                         to_end: bool)\n                      -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n+    let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut target;\n@@ -296,7 +298,7 @@ pub fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n }\n \n pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_ret\");\n+    let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let dest = match copy bcx.fcx.loop_ret {\n       Some((flagptr, retptr)) => {\n@@ -307,7 +309,7 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n         expr::SaveIn(match e {\n           Some(x) => PointerCast(bcx, retptr,\n-                                 T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n+                                 type_of(bcx.ccx(), expr_ty(bcx, x)).ptr_to()),\n           None => retptr\n         })\n       }\n@@ -331,7 +333,7 @@ pub fn trans_fail_expr(bcx: block,\n                        sp_opt: Option<span>,\n                        fail_expr: Option<@ast::expr>)\n                     -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n+    let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n         Some(arg_expr) => {\n@@ -359,7 +361,7 @@ pub fn trans_fail(bcx: block,\n                   sp_opt: Option<span>,\n                   fail_str: @str)\n                -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail\");\n+    let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n@@ -368,7 +370,7 @@ fn trans_fail_value(bcx: block,\n                     sp_opt: Option<span>,\n                     V_fail_str: ValueRef)\n                  -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n+    let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let (V_filename, V_line) = match sp_opt {\n       Some(sp) => {\n@@ -381,8 +383,8 @@ fn trans_fail_value(bcx: block,\n         (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n       }\n     };\n-    let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n-    let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let V_str = PointerCast(bcx, V_fail_str, Type::i8p());\n+    let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n     let args = ~[V_str, V_filename, C_int(ccx, V_line)];\n     let bcx = callee::trans_lang_call(\n         bcx, bcx.tcx().lang_items.fail_fn(), args, expr::Ignore);\n@@ -392,7 +394,7 @@ fn trans_fail_value(bcx: block,\n \n pub fn trans_fail_bounds_check(bcx: block, sp: span,\n                                index: ValueRef, len: ValueRef) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_fail_bounds_check\");\n+    let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];\n     let bcx = callee::trans_lang_call("}, {"sha": "32d0f8887b90dbfb8751331ddb34b6c002dc4c39", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -273,14 +273,14 @@ impl Datum {\n          * `store_to()` instead, which will move if possible but copy if\n          * neccessary. */\n \n-        let _icx = bcx.insn_ctxt(\"copy_to\");\n+        let _icx = push_ctxt(\"copy_to\");\n \n         if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n             return bcx;\n         }\n \n         debug!(\"copy_to(self=%s, action=%?, dst=%s)\",\n-               self.to_str(bcx.ccx()), action, bcx.val_str(dst));\n+               self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         // Watch out for the case where we are writing the copying the\n         // value into the same location we read it out from.  We want\n@@ -317,7 +317,7 @@ impl Datum {\n          * A helper for `copy_to()` which does not check to see if we\n          * are copying to/from the same value. */\n \n-        let _icx = bcx.insn_ctxt(\"copy_to_no_check\");\n+        let _icx = push_ctxt(\"copy_to_no_check\");\n         let mut bcx = bcx;\n \n         if action == DROP_EXISTING {\n@@ -341,11 +341,11 @@ impl Datum {\n     //\n     pub fn move_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n                    -> block {\n-        let _icx = bcx.insn_ctxt(\"move_to\");\n+        let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n         debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n-               self.to_str(bcx.ccx()), action, bcx.val_str(dst));\n+               self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n             return bcx;\n@@ -409,7 +409,7 @@ impl Datum {\n \n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         fmt!(\"Datum { val=%s, ty=%s, mode=%? }\",\n-             val_str(ccx.tn, self.val),\n+             ccx.tn.val_to_str(self.val),\n              ty_to_str(ccx.tcx, self.ty),\n              self.mode)\n     }\n@@ -474,7 +474,7 @@ impl Datum {\n             ByRef(_) => self.val,\n             ByValue => {\n                 if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n-                    C_null(T_ptr(type_of::type_of(bcx.ccx(), self.ty)))\n+                    C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n                 } else {\n                     let slot = alloc_ty(bcx, self.ty);\n                     Store(bcx, self.val, slot);\n@@ -740,7 +740,7 @@ impl Datum {\n                      expr_id: ast::node_id,\n                      max: uint)\n                      -> DatumBlock {\n-        let _icx = bcx.insn_ctxt(\"autoderef\");\n+        let _icx = push_ctxt(\"autoderef\");\n \n         debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n                expr_id, max, self.to_str(bcx.ccx()));"}, {"sha": "44e571dfb2ffee71e61a4080707b0e5e367addc1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -122,7 +122,7 @@ lvalues are *never* stored by value.\n use core::prelude::*;\n \n use back::abi;\n-use lib::llvm::{ValueRef, TypeRef, llvm};\n+use lib::llvm::{ValueRef, llvm};\n use lib;\n use metadata::csearch;\n use middle::trans::_match;\n@@ -152,6 +152,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n+use middle::trans::type_::Type;\n+\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::vec;\n@@ -173,7 +175,7 @@ pub enum Dest {\n impl Dest {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         match *self {\n-            SaveIn(v) => fmt!(\"SaveIn(%s)\", val_str(ccx.tn, v)),\n+            SaveIn(v) => fmt!(\"SaveIn(%s)\", ccx.tn.val_to_str(v)),\n             Ignore => ~\"Ignore\"\n         }\n     }\n@@ -449,7 +451,7 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_datum_unadjusted\");\n+    let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n@@ -500,7 +502,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n     let mut bcx = bcx;\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_stmt\");\n+    let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n     if bcx.unreachable {\n         return bcx;\n@@ -556,7 +558,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n \n fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                                dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_rvalue_dps_unadjusted\");\n+    let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -705,7 +707,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n \n fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                             def: ast::def, dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_def_dps_unadjusted\");\n+    let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n     let lldest = match dest {\n@@ -753,7 +755,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n                               ref_expr: @ast::expr,\n                               def: ast::def) -> DatumBlock\n {\n-    let _icx = bcx.insn_ctxt(\"trans_def_datum_unadjusted\");\n+    let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     match def {\n         ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n@@ -794,7 +796,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n                     ty: ty::mk_mach_uint(ast::ty_u8),\n                     mutbl: ast::m_imm\n                 }); // *u8\n-            (rust_ty, PointerCast(bcx, fn_data.llfn, T_ptr(T_i8())))\n+            (rust_ty, PointerCast(bcx, fn_data.llfn, Type::i8p()))\n         } else {\n             let fn_ty = expr_ty(bcx, ref_expr);\n             (fn_ty, fn_data.llfn)\n@@ -814,7 +816,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n      * Translates an lvalue expression, always yielding a by-ref\n      * datum.  Does not apply any adjustments. */\n \n-    let _icx = bcx.insn_ctxt(\"trans_lval\");\n+    let _icx = push_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n \n     debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n@@ -853,7 +855,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         //! Translates `base.field`.\n \n         let mut bcx = bcx;\n-        let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n+        let _icx = push_ctxt(\"trans_rec_field\");\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n         let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n@@ -876,7 +878,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                    idx: @ast::expr) -> DatumBlock {\n         //! Translates `base[idx]`.\n \n-        let _icx = bcx.insn_ctxt(\"trans_index\");\n+        let _icx = push_ctxt(\"trans_index\");\n         let ccx = bcx.ccx();\n         let base_ty = expr_ty(bcx, base);\n         let mut bcx = bcx;\n@@ -914,8 +916,8 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n         }\n \n-        debug!(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n-        debug!(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n+        debug!(\"trans_index: base %s\", bcx.val_to_str(base));\n+        debug!(\"trans_index: len %s\", bcx.val_to_str(len));\n \n         let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n         let bcx = do with_cond(bcx, bounds_check) |bcx| {\n@@ -924,7 +926,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                                  ix_val, unscaled_len)\n         };\n         let elt = InBoundsGEP(bcx, base, [ix_val]);\n-        let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n+        let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n         return DatumBlock {\n             bcx: bcx,\n             datum: Datum {val: elt,\n@@ -940,7 +942,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     {\n         //! Translates a reference to a path.\n \n-        let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n+        let _icx = push_ctxt(\"trans_def_lvalue\");\n         let ccx = bcx.ccx();\n         match def {\n             ast::def_const(did) => {\n@@ -963,7 +965,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                         // which may not be equal to the enum's type for\n                         // non-C-like enums.\n                         let val = base::get_item_val(bcx.ccx(), did.node);\n-                        let pty = T_ptr(type_of(bcx.ccx(), const_ty));\n+                        let pty = type_of(bcx.ccx(), const_ty).ptr_to();\n                         PointerCast(bcx, val, pty)\n                     } else {\n                         {\n@@ -981,9 +983,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n-                            let llval = llvm::LLVMAddGlobal(\n-                                bcx.ccx().llmod,\n-                                llty,\n+                            let llval = llvm::LLVMAddGlobal( bcx.ccx().llmod, llty.to_ref(),\n                                 transmute::<&u8,*i8>(&symbol[0]));\n                             let extern_const_values = &mut bcx.ccx().extern_const_values;\n                             extern_const_values.insert(did, llval);\n@@ -1012,7 +1012,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n-    let _icx = bcx.insn_ctxt(\"trans_local_var\");\n+    let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n         ast::def_upvar(nid, _, _, _) => {\n@@ -1054,7 +1054,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n             // This cast should not be necessary. We should cast self *once*,\n             // but right now this conflicts with default methods.\n             let real_self_ty = monomorphize_type(bcx, self_info.t);\n-            let llselfty = T_ptr(type_of::type_of(bcx.ccx(), real_self_ty));\n+            let llselfty = type_of::type_of(bcx.ccx(), real_self_ty).ptr_to();\n \n             let casted_val = PointerCast(bcx, self_info.v, llselfty);\n             Datum {\n@@ -1081,7 +1081,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n         };\n         let ty = node_id_type(bcx, nid);\n         debug!(\"take_local(nid=%?, v=%s, ty=%s)\",\n-               nid, bcx.val_str(v), bcx.ty_to_str(ty));\n+               nid, bcx.val_to_str(v), bcx.ty_to_str(ty));\n         Datum {\n             val: v,\n             ty: ty,\n@@ -1143,7 +1143,7 @@ fn trans_rec_or_struct(bcx: block,\n                        id: ast::node_id,\n                        dest: Dest) -> block\n {\n-    let _icx = bcx.insn_ctxt(\"trans_rec\");\n+    let _icx = push_ctxt(\"trans_rec\");\n     let bcx = bcx;\n \n     let ty = node_id_type(bcx, id);\n@@ -1217,7 +1217,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_adt\");\n+    let _icx = push_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n@@ -1263,7 +1263,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n-    let _icx = bcx.insn_ctxt(\"trans_immediate_lit\");\n+    let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n }\n@@ -1272,7 +1272,7 @@ fn trans_unary_datum(bcx: block,\n                      un_expr: @ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n+    let _icx = push_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n     assert!(op != ast::deref);\n@@ -1333,7 +1333,7 @@ fn trans_unary_datum(bcx: block,\n                         contents: @ast::expr,\n                         contents_ty: ty::t,\n                         heap: heap) -> DatumBlock {\n-        let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n+        let _icx = push_ctxt(\"trans_boxed_expr\");\n         let base::MallocResult { bcx, box: bx, body } =\n             base::malloc_general(bcx, contents_ty, heap);\n         add_clean_free(bcx, bx, heap);\n@@ -1345,7 +1345,7 @@ fn trans_unary_datum(bcx: block,\n \n fn trans_addr_of(bcx: block, expr: @ast::expr,\n                  subexpr: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_addr_of\");\n+    let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n     let llval = sub_datum.to_ref_llval(bcx);\n@@ -1361,7 +1361,7 @@ fn trans_eager_binop(bcx: block,\n                      lhs_datum: &Datum,\n                      rhs_datum: &Datum)\n                   -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n+    let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let lhs = lhs_datum.to_appropriate_llval(bcx);\n     let lhs_t = lhs_datum.ty;\n@@ -1438,7 +1438,7 @@ fn trans_eager_binop(bcx: block,\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            ZExt(bcx, cmpr.val, T_i8())\n+            ZExt(bcx, cmpr.val, Type::i8())\n         }\n       }\n       _ => {\n@@ -1457,7 +1457,7 @@ fn trans_lazy_binop(bcx: block,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n                     b: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n+    let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let bcx = bcx;\n \n@@ -1491,7 +1491,7 @@ fn trans_lazy_binop(bcx: block,\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, T_bool(), [lhs, rhs], [past_lhs.llbb,\n+    let phi = Phi(join, Type::bool(), [lhs, rhs], [past_lhs.llbb,\n                                                past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty);\n@@ -1503,7 +1503,7 @@ fn trans_binary(bcx: block,\n                 lhs: @ast::expr,\n                 rhs: @ast::expr) -> DatumBlock\n {\n-    let _icx = bcx.insn_ctxt(\"trans_binary\");\n+    let _icx = push_ctxt(\"trans_binary\");\n \n     match op {\n         ast::and => {\n@@ -1548,12 +1548,12 @@ fn trans_overloaded_op(bcx: block,\n                              DoAutorefArg)\n }\n \n-fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n+fn int_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"int_cast\");\n+    let _icx = push_ctxt(\"int_cast\");\n     unsafe {\n-        let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n-        let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n+        let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype.to_ref());\n+        let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype.to_ref());\n         return if dstsz == srcsz {\n             BitCast(bcx, llsrc, lldsttype)\n         } else if srcsz > dstsz {\n@@ -1566,11 +1566,11 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     }\n }\n \n-fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n+fn float_cast(bcx: block, lldsttype: Type, llsrctype: Type,\n               llsrc: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"float_cast\");\n-    let srcsz = lib::llvm::float_width(llsrctype);\n-    let dstsz = lib::llvm::float_width(lldsttype);\n+    let _icx = push_ctxt(\"float_cast\");\n+    let srcsz = llsrctype.float_width();\n+    let dstsz = lldsttype.float_width();\n     return if dstsz > srcsz {\n         FPExt(bcx, llsrc, lldsttype)\n     } else if srcsz > dstsz {\n@@ -1602,7 +1602,7 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n \n fn trans_imm_cast(bcx: block, expr: @ast::expr,\n                   id: ast::node_id) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_cast\");\n+    let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n \n     let t_out = node_id_type(bcx, id);\n@@ -1669,7 +1669,7 @@ fn trans_assign_op(bcx: block,\n                    dst: @ast::expr,\n                    src: @ast::expr) -> block\n {\n-    let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n+    let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n     debug!(\"trans_assign_op(expr=%s)\", bcx.expr_to_str(expr));"}, {"sha": "2d23942f601fd2e2c77fd2ab5093c08644a8098a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 129, "deletions": 186, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -11,8 +11,7 @@\n use core::prelude::*;\n \n use back::{link, abi};\n-use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n-use lib::llvm::{TypeRef, ValueRef};\n+use lib::llvm::{ValueRef};\n use lib;\n use middle::trans::base::*;\n use middle::trans::cabi;\n@@ -45,6 +44,7 @@ use syntax::parse::token;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n                   Cdecl, Aapcs, C};\n+use middle::trans::type_::Type;\n \n fn abi_info(ccx: @mut CrateContext) -> @cabi::ABIInfo {\n     return match ccx.sess.targ_cfg.arch {\n@@ -73,19 +73,19 @@ struct ShimTypes {\n \n     /// Type of the struct we will use to shuttle values back and forth.\n     /// This is always derived from the llsig.\n-    bundle_ty: TypeRef,\n+    bundle_ty: Type,\n \n     /// Type of the shim function itself.\n-    shim_fn_ty: TypeRef,\n+    shim_fn_ty: Type,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know).\n     fn_ty: cabi::FnType\n }\n \n struct LlvmSignature {\n-    llarg_tys: ~[TypeRef],\n-    llret_ty: TypeRef,\n+    llarg_tys: ~[Type],\n+    llret_ty: Type,\n     sret: bool,\n }\n \n@@ -114,20 +114,16 @@ fn shim_types(ccx: @mut CrateContext, id: ast::node_id) -> ShimTypes {\n         _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n-                                             T_ptr(llsig.llret_ty)),\n-                             false);\n+    let bundle_ty = Type::struct_(llsig.llarg_tys + [llsig.llret_ty.ptr_to()], false);\n     let ret_def = !ty::type_is_bot(fn_sig.output) &&\n                   !ty::type_is_nil(fn_sig.output);\n-    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys,\n-                                           llsig.llret_ty,\n-                                           ret_def);\n+    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);\n     ShimTypes {\n         fn_sig: fn_sig,\n         llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void()),\n+        shim_fn_ty: Type::func([bundle_ty.ptr_to()], &Type::void()),\n         fn_ty: fn_ty\n     }\n }\n@@ -192,7 +188,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n                   needs_c_return: bool,\n                   arg_builder: wrap_arg_builder,\n                   ret_builder: wrap_ret_builder) {\n-    let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n+    let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n \n     // Patch up the return type if it's not immediate and we're returning via\n@@ -211,8 +207,8 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     arg_builder(bcx, tys, llwrapfn, llargbundle);\n \n     // Create call itself.\n-    let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n-    let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n+    let llshimfnptr = PointerCast(bcx, llshimfn, Type::i8p());\n+    let llrawargbundle = PointerCast(bcx, llargbundle, Type::i8p());\n     Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n@@ -221,28 +217,21 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     tie_up_header_blocks(fcx, lltop);\n \n     // Then return according to the C ABI.\n-    unsafe {\n-        let return_context = raw_block(fcx, false, fcx.llreturn);\n-\n-        let llfunctiontype = val_ty(llwrapfn);\n-        let llfunctiontype =\n-            ::lib::llvm::llvm::LLVMGetElementType(llfunctiontype);\n-        let llfunctionreturntype =\n-            ::lib::llvm::llvm::LLVMGetReturnType(llfunctiontype);\n-        if ::lib::llvm::llvm::LLVMGetTypeKind(llfunctionreturntype) ==\n-                ::lib::llvm::Void {\n-            // XXX: This might be wrong if there are any functions for which\n-            // the C ABI specifies a void output pointer and the Rust ABI\n-            // does not.\n-            RetVoid(return_context);\n-        } else {\n-            // Cast if we have to...\n-            // XXX: This is ugly.\n-            let llretptr = BitCast(return_context,\n-                                   fcx.llretptr.get(),\n-                                   T_ptr(llfunctionreturntype));\n-            Ret(return_context, Load(return_context, llretptr));\n-        }\n+    let return_context = raw_block(fcx, false, fcx.llreturn);\n+\n+    let llfunctiontype = val_ty(llwrapfn);\n+    let llfunctiontype = llfunctiontype.element_type();\n+    let return_type = llfunctiontype.return_type();\n+    if return_type.kind() == ::lib::llvm::Void {\n+        // XXX: This might be wrong if there are any functions for which\n+        // the C ABI specifies a void output pointer and the Rust ABI\n+        // does not.\n+        RetVoid(return_context);\n+    } else {\n+        // Cast if we have to...\n+        // XXX: This is ugly.\n+        let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n+        Ret(return_context, Load(return_context, llretptr));\n     }\n }\n \n@@ -285,7 +274,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                          path: &ast_map::path,\n                          foreign_mod: &ast::foreign_mod) {\n-    let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n+    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n \n     let arch = ccx.sess.targ_cfg.arch;\n     let abi = match foreign_mod.abis.for_arch(arch) {\n@@ -381,19 +370,19 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n          *     }\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n+        let _icx = push_ctxt(\"foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n                    -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n+            let _icx = push_ctxt(\"foreign::shim::build_args\");\n             tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n         }\n \n         fn build_ret(bcx: block,\n                      tys: &ShimTypes,\n                      llargbundle: ValueRef,\n                      llretval: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n+            let _icx = push_ctxt(\"foreign::shim::build_ret\");\n             tys.fn_ty.build_shim_ret(bcx,\n                                      tys.llsig.llarg_tys,\n                                      tys.ret_def,\n@@ -499,7 +488,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n          * account for the Rust modes.\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n+        let _icx = push_ctxt(\"foreign::build_wrap_fn\");\n \n         build_wrap_fn_(ccx,\n                        tys,\n@@ -514,7 +503,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                       tys: &ShimTypes,\n                       llwrapfn: ValueRef,\n                       llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n+            let _icx = push_ctxt(\"foreign::wrap::build_args\");\n             let ccx = bcx.ccx();\n             let n = tys.llsig.llarg_tys.len();\n             for uint::range(0, n) |i| {\n@@ -539,7 +528,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         fn build_ret(bcx: block,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n+            let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n             let arg_count = shim_types.fn_sig.inputs.len();\n             for bcx.fcx.llretptr.iter().advance |&retptr| {\n                 let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n@@ -578,118 +567,76 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n     let mut bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n     let first_real_arg = fcx.arg_pos(0u);\n-    match ccx.sess.str_of(item.ident).as_slice() {\n-        \"atomic_cxchg\" => {\n-            let old = AtomicCmpXchg(bcx,\n-                                    get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    get_param(decl, first_real_arg + 2u),\n-                                    SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_cxchg_acq\" => {\n-            let old = AtomicCmpXchg(bcx,\n-                                    get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    get_param(decl, first_real_arg + 2u),\n-                                    Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_cxchg_rel\" => {\n-            let old = AtomicCmpXchg(bcx,\n-                                    get_param(decl, first_real_arg),\n+\n+    let nm = ccx.sess.str_of(item.ident);\n+    let name = nm.as_slice();\n+\n+    // This requires that atomic intrinsics follow a specific naming pattern:\n+    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n+    if name.starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.split_iter('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+        let order = if split.len() == 2 {\n+            lib::llvm::SequentiallyConsistent\n+        } else {\n+            match split[2] {\n+                \"relaxed\" => lib::llvm::Monotonic,\n+                \"acq\"     => lib::llvm::Acquire,\n+                \"rel\"     => lib::llvm::Release,\n+                \"acqrel\"  => lib::llvm::AcquireRelease,\n+                _ => ccx.sess.fatal(\"Unknown ordering in atomic intrinsic\")\n+            }\n+        };\n+\n+        match split[1] {\n+            \"cxchg\" => {\n+                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n+                                        get_param(decl, first_real_arg + 1u),\n+                                        get_param(decl, first_real_arg + 2u),\n+                                        order);\n+                Store(bcx, old, fcx.llretptr.get());\n+            }\n+            \"load\" => {\n+                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n+                                     order);\n+                Store(bcx, old, fcx.llretptr.get());\n+            }\n+            \"store\" => {\n+                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n+                            get_param(decl, first_real_arg),\n+                            order);\n+            }\n+            op => {\n+                // These are all AtomicRMW ops\n+                let atom_op = match op {\n+                    \"xchg\"  => lib::llvm::Xchg,\n+                    \"xadd\"  => lib::llvm::Add,\n+                    \"xsub\"  => lib::llvm::Sub,\n+                    \"and\"   => lib::llvm::And,\n+                    \"nand\"  => lib::llvm::Nand,\n+                    \"or\"    => lib::llvm::Or,\n+                    \"xor\"   => lib::llvm::Xor,\n+                    \"max\"   => lib::llvm::Max,\n+                    \"min\"   => lib::llvm::Min,\n+                    \"umax\"  => lib::llvm::UMax,\n+                    \"umin\"  => lib::llvm::UMin,\n+                    _ => ccx.sess.fatal(\"Unknown atomic operation\")\n+                };\n+\n+                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n-                                    get_param(decl, first_real_arg + 2u),\n-                                    Release);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_load\" => {\n-            let old = AtomicLoad(bcx,\n-                                 get_param(decl, first_real_arg),\n-                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_load_acq\" => {\n-            let old = AtomicLoad(bcx,\n-                                 get_param(decl, first_real_arg),\n-                                 Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_store\" => {\n-            AtomicStore(bcx,\n-                        get_param(decl, first_real_arg + 1u),\n-                        get_param(decl, first_real_arg),\n-                        SequentiallyConsistent);\n-        }\n-        \"atomic_store_rel\" => {\n-            AtomicStore(bcx,\n-                        get_param(decl, first_real_arg + 1u),\n-                        get_param(decl, first_real_arg),\n-                        Release);\n-        }\n-        \"atomic_xchg\" => {\n-            let old = AtomicRMW(bcx, Xchg,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xchg_acq\" => {\n-            let old = AtomicRMW(bcx, Xchg,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xchg_rel\" => {\n-            let old = AtomicRMW(bcx, Xchg,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Release);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xadd\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Add,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xadd_acq\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Add,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xadd_rel\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Add,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Release);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xsub\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xsub_acq\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xsub_rel\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Release);\n-            Store(bcx, old, fcx.llretptr.get());\n+                                    order);\n+                Store(bcx, old, fcx.llretptr.get());\n+            }\n         }\n+\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+\n+        return;\n+    }\n+\n+    match name {\n         \"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -734,9 +681,9 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n-            // FIXME (#3727): change this to T_ptr(ccx.tydesc_ty) when the\n+            // FIXME (#3727): change this to ccx.tydesc_ty.ptr_to() when the\n             // core::sys copy of the get_tydesc interface dies off.\n-            let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n+            let td = PointerCast(bcx, static_ti.tydesc, Type::nil().ptr_to());\n             Store(bcx, td, fcx.llretptr.get());\n         }\n         \"init\" => {\n@@ -780,7 +727,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 // code bloat when `transmute` is used on large structural\n                 // types.\n                 let lldestptr = fcx.llretptr.get();\n-                let lldestptr = PointerCast(bcx, lldestptr, T_ptr(T_i8()));\n+                let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n \n                 let llsrcval = get_param(decl, first_real_arg);\n                 let llsrcptr = if ty::type_is_immediate(in_type) {\n@@ -790,7 +737,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 } else {\n                     llsrcval\n                 };\n-                let llsrcptr = PointerCast(bcx, llsrcptr, T_ptr(T_i8()));\n+                let llsrcptr = PointerCast(bcx, llsrcptr, Type::i8p());\n \n                 let llsize = llsize_of(ccx, llintype);\n                 call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n@@ -807,12 +754,9 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let visitor = get_param(decl, first_real_arg + 1u);\n             //let llvisitorptr = alloca(bcx, val_ty(visitor));\n             //Store(bcx, visitor, llvisitorptr);\n-            let td = PointerCast(bcx, td, T_ptr(ccx.tydesc_type));\n-            glue::call_tydesc_glue_full(bcx,\n-                                        visitor,\n-                                        td,\n-                                        abi::tydesc_field_visit_glue,\n-                                        None);\n+            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n+            glue::call_tydesc_glue_full(bcx, visitor, td,\n+                                        abi::tydesc_field_visit_glue, None);\n         }\n         \"frame_address\" => {\n             let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n@@ -847,8 +791,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let llfty = type_of_fn(bcx.ccx(), [], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, \"__morestack\", llfty);\n-            let morestack_addr = PointerCast(bcx, morestack_addr,\n-                                             T_ptr(T_nil()));\n+            let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n         \"memcpy32\" => {\n@@ -857,8 +800,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n@@ -870,8 +813,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n@@ -883,8 +826,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i32\");\n@@ -896,8 +839,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i64\");\n@@ -909,7 +852,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n@@ -922,7 +865,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n             let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n \n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n@@ -1212,15 +1155,15 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                         body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n+    let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @mut CrateContext,\n                      path: ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      id: ast::node_id)\n                   -> ValueRef {\n-        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n+        let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         // XXX: Bad copy.\n         let ps = link::mangle_internal_name_by_path(\n@@ -1262,11 +1205,11 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n          * one of those types that is passed by pointer in Rust.\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n+        let _icx = push_ctxt(\"foreign::foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n                       -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n+            let _icx = push_ctxt(\"foreign::extern::shim::build_args\");\n             let ccx = bcx.ccx();\n             let mut llargvals = ~[];\n             let mut i = 0u;\n@@ -1277,7 +1220,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                 llargvals.push(llretptr);\n             }\n \n-            let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n+            let llenvptr = C_null(Type::opaque_box(bcx.ccx()).ptr_to());\n             llargvals.push(llenvptr);\n             while i < n {\n                 // Get a pointer to the argument:\n@@ -1341,7 +1284,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n          *    }\n          */\n \n-        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n+        let _icx = push_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n         build_wrap_fn_(ccx,\n                        tys,\n@@ -1356,15 +1299,15 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                       tys: &ShimTypes,\n                       llwrapfn: ValueRef,\n                       llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n+            let _icx = push_ctxt(\"foreign::foreign::wrap::build_args\");\n             tys.fn_ty.build_wrap_args(bcx,\n                                       tys.llsig.llret_ty,\n                                       llwrapfn,\n                                       llargbundle);\n         }\n \n         fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n+            let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n             tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n             build_return(bcx);\n         }\n@@ -1386,7 +1329,7 @@ pub fn register_foreign_fn(ccx: @mut CrateContext,\n                            node_id: ast::node_id,\n                            attrs: &[ast::attribute])\n                            -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n+    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n \n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n "}, {"sha": "3e3fdf686e34c186b1c5268d4fdf46d7793cc9d9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 68, "deletions": 109, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -18,7 +18,7 @@ use back::abi;\n use back::link::*;\n use driver::session;\n use lib;\n-use lib::llvm::{llvm, ValueRef, TypeRef, True};\n+use lib::llvm::{llvm, ValueRef, True};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::callee;\n@@ -29,12 +29,14 @@ use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n-use middle::trans::type_of::{type_of, type_of_glue_fn};\n+use middle::trans::type_of::type_of;\n use middle::trans::uniq;\n use middle::ty;\n use util::ppaux;\n use util::ppaux::ty_to_short_str;\n \n+use middle::trans::type_::Type;\n+\n use core::io;\n use core::libc::c_uint;\n use core::str;\n@@ -43,26 +45,24 @@ use extra::time;\n use syntax::ast;\n \n pub fn trans_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_free\");\n-    callee::trans_lang_call(\n-        cx,\n+    let _icx = push_ctxt(\"trans_free\");\n+    callee::trans_lang_call(cx,\n         cx.tcx().lang_items.free_fn(),\n-        [PointerCast(cx, v, T_ptr(T_i8()))],\n+        [PointerCast(cx, v, Type::i8p())],\n         expr::Ignore)\n }\n \n pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(\"trans_exchange_free\");\n-    callee::trans_lang_call(\n-        cx,\n+    let _icx = push_ctxt(\"trans_exchange_free\");\n+    callee::trans_lang_call(cx,\n         cx.tcx().lang_items.exchange_free_fn(),\n-        [PointerCast(cx, v, T_ptr(T_i8()))],\n+        [PointerCast(cx, v, Type::i8p())],\n         expr::Ignore)\n }\n \n pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(\"take_ty\");\n+    let _icx = push_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n@@ -71,46 +71,32 @@ pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(\"drop_ty\");\n+    let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     return cx;\n }\n \n-pub fn drop_ty_root(bcx: block,\n-                    v: ValueRef,\n-                    rooted: bool,\n-                    t: ty::t)\n-                 -> block {\n-    if rooted {\n-        // NB: v is a raw ptr to an addrspace'd ptr to the value.\n-        let v = PointerCast(bcx, Load(bcx, v), T_ptr(type_of(bcx.ccx(), t)));\n-        drop_ty(bcx, v, t)\n-    } else {\n-        drop_ty(bcx, v, t)\n-    }\n-}\n-\n pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n+    let _icx = push_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).sty {\n-      ty::ty_uniq(_) |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) => {\n+        ty::ty_uniq(_)\n+      | ty::ty_evec(_, ty::vstore_uniq)\n+      | ty::ty_estr(ty::vstore_uniq) => {\n         free_ty_immediate(bcx, v, t)\n       }\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) => {\n+        ty::ty_box(_) | ty::ty_opaque_box\n+      | ty::ty_evec(_, ty::vstore_box)\n+      | ty::ty_estr(ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, v, None, t)\n       }\n       _ => bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\")\n     }\n }\n \n pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n-    let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n+    let _icx = push_ctxt(\"take_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n@@ -131,15 +117,15 @@ pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n \n pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(\"free_ty\");\n+    let _icx = push_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     return cx;\n }\n \n pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n+    let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -221,7 +207,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n                                           field: uint,\n                                           ti: @mut tydesc_info) -> bool {\n-    let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n+    let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n         let simpl_ti = get_tydesc(ccx, simpl);\n@@ -246,7 +232,7 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n-    let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n+    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx);\n \n     if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n@@ -314,7 +300,7 @@ pub fn call_tydesc_glue_full(bcx: block,\n                              tydesc: ValueRef,\n                              field: uint,\n                              static_ti: Option<@mut tydesc_info>) {\n-    let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n+    let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n@@ -340,7 +326,7 @@ pub fn call_tydesc_glue_full(bcx: block,\n       }\n     };\n \n-    let llrawptr = PointerCast(bcx, v, T_ptr(T_i8()));\n+    let llrawptr = PointerCast(bcx, v, Type::i8p());\n \n     let llfn = {\n         match static_glue_fn {\n@@ -353,26 +339,26 @@ pub fn call_tydesc_glue_full(bcx: block,\n         }\n     };\n \n-    Call(bcx, llfn, [C_null(T_ptr(T_nil())),\n-                        C_null(T_ptr(T_ptr(bcx.ccx().tydesc_type))),\n+    Call(bcx, llfn, [C_null(Type::nil().ptr_to()),\n+                        C_null(bcx.ccx().tydesc_type.ptr_to().ptr_to()),\n                         llrawptr]);\n }\n \n // See [Note-arg-mode]\n pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n-    let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n+    let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n+    let _icx = push_ctxt(\"make_visit_glue\");\n     let bcx = do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n-        let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n+        let v = PointerCast(bcx, v, type_of::type_of(bcx.ccx(), object_ty).ptr_to());\n         bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);\n@@ -383,14 +369,11 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(\"make_free_glue\");\n-    let ccx = bcx.ccx();\n+    let _icx = push_ctxt(\"make_free_glue\");\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(body_mt) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n-        // Cast away the addrspace of the box pointer.\n-        let body = PointerCast(bcx, body, T_ptr(type_of(ccx, body_mt.ty)));\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n@@ -442,8 +425,8 @@ pub fn trans_struct_drop(bcx: block,\n \n         // The second argument is the \"self\" argument for drop\n         let params = unsafe {\n-            lib::llvm::fn_ty_param_tys(\n-                llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr)))\n+            let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n+            ty.element_type().func_params()\n         };\n \n         // Class dtors have no explicit args, so the params should\n@@ -475,7 +458,7 @@ pub fn trans_struct_drop(bcx: block,\n \n pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n+    let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -517,9 +500,8 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n               let llvtable = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n \n               // Cast the vtable to a pointer to a pointer to a tydesc.\n-              let llvtable = PointerCast(bcx,\n-                                         llvtable,\n-                                         T_ptr(T_ptr(ccx.tydesc_type)));\n+              let llvtable = PointerCast(bcx, llvtable,\n+                                         ccx.tydesc_type.ptr_to().ptr_to());\n               let lltydesc = Load(bcx, llvtable);\n               call_tydesc_glue_full(bcx,\n                                     lluniquevalue,\n@@ -547,7 +529,7 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n                               box_ptr_ptr: Option<ValueRef>,\n                               t: ty::t)\n                            -> block {\n-    let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n+    let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n     do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n@@ -566,7 +548,7 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n \n \n pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(\"make_take_glue\");\n+    let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     let bcx = match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -615,7 +597,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n }\n \n pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n-    let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n+    let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n@@ -624,20 +606,6 @@ pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n }\n \n \n-// Chooses the addrspace for newly declared types.\n-pub fn declare_tydesc_addrspace(ccx: &CrateContext, t: ty::t) -> addrspace {\n-    if !ty::type_needs_drop(ccx.tcx, t) {\n-        return default_addrspace;\n-    } else if ty::type_is_immediate(t) {\n-        // For immediate types, we don't actually need an addrspace, because\n-        // e.g. boxed types include pointers to their contents which are\n-        // already correctly tagged with addrspaces.\n-        return default_addrspace;\n-    } else {\n-        return (ccx.next_addrspace)();\n-    }\n-}\n-\n // Generates the declaration for (but doesn't emit) a type descriptor.\n pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n@@ -647,28 +615,25 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let llty = type_of(ccx, t);\n \n     if ccx.sess.count_type_sizes() {\n-        io::println(fmt!(\"%u\\t%s\",\n-                         llsize_of_real(ccx, llty),\n+        io::println(fmt!(\"%u\\t%s\", llsize_of_real(ccx, llty),\n                          ppaux::ty_to_str(ccx.tcx, t)));\n     }\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n-    let addrspace = declare_tydesc_addrspace(ccx, t);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n     let gvar = str::as_c_str(name, |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }\n     });\n     let inf = @mut tydesc_info {\n         ty: t,\n         tydesc: gvar,\n         size: llsize,\n         align: llalign,\n-        addrspace: addrspace,\n         take_glue: None,\n         drop_glue: None,\n         free_glue: None,\n@@ -680,9 +645,9 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n \n pub type glue_helper = @fn(block, ValueRef, ty::t);\n \n-pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: TypeRef,\n+pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: Type,\n                             name: ~str) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n+    let _icx = push_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n     debug!(\"%s is for type %s\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n@@ -697,7 +662,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n                                llfn: ValueRef,\n                                helper: glue_helper)\n                             -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n+    let _icx = push_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n@@ -711,9 +676,13 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     let rawptr0_arg = fcx.arg_pos(1u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let llty = type_of(ccx, t);\n-    let llrawptr0 = PointerCast(bcx, llrawptr0, T_ptr(llty));\n+    let llrawptr0 = PointerCast(bcx, llrawptr0, llty.ptr_to());\n     helper(bcx, llrawptr0, t);\n-    finish_fn(fcx, lltop);\n+\n+    // This is from the general finish fn, but that emits a ret {} that we don't want\n+    Br(raw_block(fcx, false, fcx.llstaticallocas), lltop);\n+    RetVoid(raw_block(fcx, false, fcx.llreturn));\n+\n     return llfn;\n }\n \n@@ -723,26 +692,23 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n                          helper: glue_helper,\n                          name: &str)\n                       -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n+    let _icx = push_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n         return make_generic_glue_inner(ccx, t, llfn, helper);\n     }\n \n     let start = time::get_time();\n     let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n     let end = time::get_time();\n-    log_fn_time(ccx,\n-                fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)),\n-                start,\n-                end);\n+    ccx.log_fn_time(fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)), start, end);\n     return llval;\n }\n \n pub fn emit_tydescs(ccx: &mut CrateContext) {\n-    //let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n+    let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n-    let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n+    let glue_fn_ty = Type::generic_glue_fn(ccx);\n     let tyds = &mut ccx.tydescs;\n     for tyds.each_value |&val| {\n         let ti = val;\n@@ -757,7 +723,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n@@ -767,7 +733,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n@@ -777,7 +743,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n@@ -787,16 +753,16 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               Some(v) => {\n                 unsafe {\n                     ccx.stats.n_real_glues += 1u;\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n                 }\n               }\n             };\n \n-        let shape = C_null(T_ptr(T_i8()));\n-        let shape_tables = C_null(T_ptr(T_i8()));\n \n-        let tydesc =\n-            C_named_struct(ccx.tydesc_type,\n+        let shape = C_null(Type::i8p());\n+        let shape_tables = C_null(Type::i8p());\n+\n+        let tydesc = C_named_struct(ccx.tydesc_type,\n                            [ti.size, // size\n                             ti.align, // align\n                             take_glue, // take_glue\n@@ -812,18 +778,11 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n             llvm::LLVMSetGlobalConstant(gvar, True);\n             lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n \n-            // Index tydesc by addrspace.\n-            if ti.addrspace > gc_box_addrspace {\n-                let llty = T_ptr(ccx.tydesc_type);\n-                let addrspace_name = fmt!(\"_gc_addrspace_metadata_%u\",\n-                                          ti.addrspace as uint);\n-                let addrspace_gvar = str::as_c_str(addrspace_name, |buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-                });\n-                lib::llvm::SetLinkage(addrspace_gvar,\n-                                      lib::llvm::InternalLinkage);\n-                llvm::LLVMSetInitializer(addrspace_gvar, gvar);\n-            }\n         }\n     };\n }\n+\n+fn type_of_glue_fn(ccx: &CrateContext) -> Type {\n+    let tydescpp = ccx.tydesc_type.ptr_to().ptr_to();\n+    Type::func([ Type::nil().ptr_to(), tydescpp, Type::i8p() ], &Type::void())\n+}"}, {"sha": "01849ac6e8f182c5e3636ac327c65e01e8be551a", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -12,8 +12,7 @@ use core::prelude::*;\n \n use metadata::csearch;\n use middle::astencode;\n-use middle::trans::base::{get_insn_ctxt};\n-use middle::trans::base::{impl_owned_self, impl_self, no_self};\n+use middle::trans::base::{push_ctxt,impl_owned_self, impl_self, no_self};\n use middle::trans::base::{trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n@@ -30,7 +29,7 @@ use syntax::ast_util::local_def;\n pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id,\n                                 translate: bool)\n     -> ast::def_id {\n-    let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n+    let _icx = push_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline"}, {"sha": "6fcab95996e8de5c3216238ccb42641ba2573c3b", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -10,29 +10,31 @@\n \n // Information concerning the machine representation of various types.\n \n-use lib::llvm::{ValueRef, TypeRef};\n+use lib::llvm::{ValueRef};\n use lib::llvm::False;\n use lib::llvm::llvm;\n use middle::trans::common::*;\n use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n // Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMStoreSizeOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMABISizeOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n@@ -44,9 +46,9 @@ pub fn llsize_of_alloc(cx: &CrateContext, t: TypeRef) -> uint {\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n-pub fn llsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as uint;\n         if nbits & 7u != 0u {\n             // Not an even number of bytes, spills into \"next\" byte.\n             1u + (nbits >> 3)\n@@ -57,61 +59,61 @@ pub fn llsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n }\n \n /// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint\n+        llvm::LLVMSizeOfTypeInBits(cx.td.lltd, ty.to_ref()) as uint\n     }\n }\n \n /// Returns the size of the type as an LLVM constant integer value.\n-pub fn llsize_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n+pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // Once upon a time, this called LLVMSizeOf, which does a\n     // getelementptr(1) on a null pointer and casts to an int, in\n     // order to obtain the type size as a value without requiring the\n     // target data layout.  But we have the target data layout, so\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, t));\n+    return C_uint(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the \"default\" size of t (see above), or 1 if the size would\n // be zero.  This is important for things like vectors that expect\n // space to be consumed.\n-pub fn nonzero_llsize_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n-    if llbitsize_of_real(cx, t) == 0 {\n-        unsafe { llvm::LLVMConstInt(cx.int_type, 1, False) }\n+pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n+    if llbitsize_of_real(cx, ty) == 0 {\n+        unsafe { llvm::LLVMConstInt(cx.int_type.to_ref(), 1, False) }\n     } else {\n-        llsize_of(cx, t)\n+        llsize_of(cx, ty)\n     }\n }\n \n // Returns the preferred alignment of the given type for the current target.\n // The preferred alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n // Returns the minimum alignment of a type required by the platform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: &CrateContext, t: TypeRef) -> uint {\n+pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> uint {\n     unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n+        return llvm::LLVMABIAlignmentOfType(cx.td.lltd, ty.to_ref()) as uint;\n     }\n }\n \n // Returns the \"default\" alignment of t, which is calculated by casting\n // null to a record containing a single-bit followed by a t value, then\n // doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-pub fn llalign_of(cx: &CrateContext, t: TypeRef) -> ValueRef {\n+pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstIntCast(\n-            llvm::LLVMAlignOf(t), cx.int_type, False);\n+            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n     }\n }\n \n@@ -140,9 +142,9 @@ pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n \n                 debug!(\"static_size_of_enum: variant %s type %s\",\n                        cx.tcx.sess.str_of(variant.name),\n-                       ty_str(cx.tn, T_struct(lltypes, false)));\n+                       cx.tn.type_to_str(Type::struct_(lltypes, false)));\n \n-                let this_size = llsize_of_real(cx, T_struct(lltypes, false));\n+                let this_size = llsize_of_real(cx, Type::struct_(lltypes, false));\n                 if max_size < this_size {\n                     max_size = this_size;\n                 }"}, {"sha": "3a8efb55c151bf6d02619c5b0c0da05c880d94af", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -30,6 +30,8 @@ use middle::typeck;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n+use middle::trans::type_::Type;\n+\n use core::str;\n use core::vec;\n use syntax::ast_map::{path, path_mod, path_name};\n@@ -49,7 +51,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n                   generics: &ast::Generics,\n                   self_ty: Option<ty::t>,\n                   id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n+    let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n     debug!(\"trans_impl(path=%s, name=%s, self_ty=%s, id=%?)\",\n@@ -157,7 +159,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n pub fn trans_self_arg(bcx: block,\n                       base: @ast::expr,\n                       mentry: typeck::method_map_entry) -> Result {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n+    let _icx = push_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n \n     // Compute the type of self.\n@@ -185,7 +187,7 @@ pub fn trans_method_callee(bcx: block,\n                            this: @ast::expr,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n+    let _icx = push_ctxt(\"impl::trans_method_callee\");\n     let tcx = bcx.tcx();\n \n     debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n@@ -291,7 +293,7 @@ pub fn trans_static_method_callee(bcx: block,\n                                   trait_id: ast::def_id,\n                                   callee_id: ast::node_id)\n                                -> FnData {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_static_method_callee\");\n+    let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_static_method_callee(method_id=%?, trait_id=%s, \\\n@@ -363,7 +365,7 @@ pub fn trans_static_method_callee(bcx: block,\n                                           Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, callee_id);\n-            let llty = T_ptr(type_of_fn_from_ty(ccx, callee_ty));\n+            let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n@@ -435,7 +437,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n                                   -> Callee {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n+    let _icx = push_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n@@ -463,7 +465,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n           // create a llvalue that represents the fn ptr\n           let fn_ty = node_id_type(bcx, callee_id);\n-          let llfn_ty = T_ptr(type_of_fn_from_ty(ccx, fn_ty));\n+          let llfn_ty = type_of_fn_from_ty(ccx, fn_ty).ptr_to();\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n@@ -584,7 +586,7 @@ pub fn trans_trait_callee(bcx: block,\n     // first evaluate the self expression (expected a by-ref result) and then\n     // extract the self data and vtable out of the pair.\n \n-    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n+    let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n     let self_datum = unpack_datum!(bcx,\n         expr::trans_to_datum(bcx, self_expr));\n@@ -617,18 +619,18 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     // Same as `trans_trait_callee()` above, except that it is given\n     // a by-ref pointer to the @Trait pair.\n \n-    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n+    let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n     // Load the vtable from the @Trait pair\n     debug!(\"(translating trait callee) loading vtable from pair %s\",\n-           val_str(bcx.ccx().tn, llpair));\n+           bcx.val_to_str(llpair));\n     let llvtable = Load(bcx,\n                       PointerCast(bcx,\n                                   GEPi(bcx, llpair,\n                                        [0u, abi::trt_field_vtable]),\n-                                  T_ptr(T_ptr(T_vtable()))));\n+                                  Type::vtable().ptr_to().ptr_to()));\n \n     // Load the box from the @Trait pair and GEP over the box header if\n     // necessary:\n@@ -705,7 +707,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     // Plus one in order to skip past the type descriptor.\n     let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n \n-    let mptr = PointerCast(bcx, mptr, T_ptr(llcallee_ty));\n+    let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n         bcx: bcx,\n@@ -768,7 +770,7 @@ pub fn make_vtable(ccx: @mut CrateContext,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n     unsafe {\n-        let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n+        let _icx = push_ctxt(\"impl::make_vtable\");\n \n         let mut components = ~[ tydesc.tydesc ];\n         for ptrs.each |&ptr| {\n@@ -778,7 +780,7 @@ pub fn make_vtable(ccx: @mut CrateContext,\n         let tbl = C_struct(components);\n         let vtable = ccx.sess.str_of((ccx.names)(\"vtable\"));\n         let vt_gvar = do str::as_c_str(vtable) |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n@@ -795,7 +797,7 @@ pub fn make_impl_vtable(bcx: block,\n                         vtables: typeck::vtable_res)\n                         -> ValueRef {\n     let ccx = bcx.ccx();\n-    let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n+    let _icx = push_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n@@ -814,7 +816,7 @@ pub fn make_impl_vtable(bcx: block,\n         if im.generics.has_type_params() || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    tcx.sess.str_of(im.ident));\n-            C_null(T_ptr(T_nil()))\n+            C_null(Type::nil().ptr_to())\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n                    tcx.sess.str_of(im.ident));\n@@ -839,7 +841,7 @@ pub fn trans_trait_cast(bcx: block,\n                         _store: ty::TraitStore)\n                      -> block {\n     let mut bcx = bcx;\n-    let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n+    let _icx = push_ctxt(\"impl::trans_cast\");\n \n     let lldest = match dest {\n         Ignore => {\n@@ -857,7 +859,7 @@ pub fn trans_trait_cast(bcx: block,\n     // have no type descriptor field.)\n     llboxdest = PointerCast(bcx,\n                             llboxdest,\n-                            T_ptr(type_of(bcx.ccx(), v_ty)));\n+                            type_of(bcx.ccx(), v_ty).ptr_to());\n     bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n@@ -866,7 +868,7 @@ pub fn trans_trait_cast(bcx: block,\n     let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,\n                                    GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n-                                   T_ptr(val_ty(vtable))));\n+                                   val_ty(vtable).ptr_to()));\n \n     bcx\n }"}, {"sha": "1345b92418e3d9d3b1076cb88896cb2ca83ce3bf", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -42,3 +42,4 @@ pub mod reachable;\n pub mod machine;\n pub mod adt;\n pub mod asm;\n+pub mod type_;"}, {"sha": "ac5f53c243ef87ef17c8b44b9c1c605838cfdd1e", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -13,9 +13,8 @@ use core::prelude::*;\n use back::link::mangle_exported_name;\n use driver::session;\n use lib::llvm::ValueRef;\n-use middle::trans::base::{get_insn_ctxt};\n use middle::trans::base::{set_inline_hint_if_appr, set_inline_hint};\n-use middle::trans::base::{trans_enum_variant};\n+use middle::trans::base::{trans_enum_variant,push_ctxt};\n use middle::trans::base::{trans_fn, decl_internal_cdecl_fn};\n use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n@@ -61,7 +60,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n            ref_id);\n \n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n-    let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n+    let _icx = push_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs.tps, |t| {\n         match normalize_for_monomorphization(ccx.tcx, *t) {"}, {"sha": "cb68a2af92bb78c3744cc219df4cc2438ca108b7", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n-use lib::llvm::{TypeRef, ValueRef, llvm};\n+use lib::llvm::{ValueRef, llvm};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -33,11 +33,13 @@ use syntax::ast;\n use syntax::ast_map::path_name;\n use syntax::parse::token::special_idents;\n \n+use middle::trans::type_::Type;\n+\n pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],\n     final_bcx: block,\n-    tydesc_ty: TypeRef,\n+    tydesc_ty: Type,\n     bcx: block\n }\n \n@@ -58,7 +60,7 @@ impl Reflector {\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, false);\n         let len = C_uint(bcx.ccx(), s.len() + 1);\n-        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), T_ptr(T_i8()));\n+        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n         scratch.val\n@@ -76,7 +78,7 @@ impl Reflector {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n         glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n-        PointerCast(bcx, static_ti.tydesc, T_ptr(self.tydesc_ty))\n+        PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n \n     pub fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n@@ -96,7 +98,7 @@ impl Reflector {\n         debug!(\"passing %u args:\", args.len());\n         let bcx = self.bcx;\n         for args.iter().enumerate().advance |(i, a)| {\n-            debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, *a));\n+            debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n         let scratch = scratch_datum(bcx, bool_ty, false);\n@@ -271,7 +273,7 @@ impl Reflector {\n             let ccx = bcx.ccx();\n             let repr = adt::represent_type(bcx.ccx(), t);\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n-            let llptrty = T_ptr(type_of(ccx, t));\n+            let llptrty = type_of(ccx, t).ptr_to();\n             let (_, opaquety) =\n                 ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(\"Opaque\"))\n                 .expect(\"Failed to resolve intrinsic::Opaque\");"}, {"sha": "4118291dca0d6875529a60d03a164682138bd793", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -15,7 +15,8 @@\n use lib::llvm::llvm;\n use lib::llvm::{True, ModuleRef, ValueRef};\n use middle::trans::common::*;\n-use middle::trans;\n+\n+use middle::trans::type_::Type;\n \n use core::str;\n \n@@ -32,7 +33,7 @@ pub fn mk_global(ccx: &CrateContext,\n               -> ValueRef {\n     unsafe {\n         let llglobal = do str::as_c_str(name) |buf| {\n-            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(llglobal, llval);\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n@@ -48,28 +49,15 @@ pub fn mk_global(ccx: &CrateContext,\n \n pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n     unsafe {\n-        let llshapetablesty = trans::common::T_named_struct(\"shapes\");\n-        let _llshapetables = str::as_c_str(\"shapes\", |buf| {\n-            llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n-        });\n+        let llshapetablesty = Type::named_struct(\"shapes\");\n+        do \"shapes\".as_c_str |buf| {\n+            llvm::LLVMAddGlobal(llmod, llshapetablesty.to_ref(), buf)\n+        };\n \n-        return Ctxt {\n+        Ctxt {\n             next_tag_id: 0u16,\n             pad: 0u16,\n             pad2: 0u32\n-        };\n+        }\n     }\n }\n-\n-/*\n-Although these two functions are never called, they are here\n-for a VERY GOOD REASON. See #3670\n-*/\n-pub fn add_u16(dest: &mut ~[u8], val: u16) {\n-    *dest += [(val & 0xffu16) as u8, (val >> 8u16) as u8];\n-}\n-\n-pub fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n-    add_u16(&mut *dest, src.len() as u16);\n-    *dest += src;\n-}"}, {"sha": "d543b2cc61c067eea85b9223acd2361bda678aac", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -11,7 +11,7 @@\n \n use back::abi;\n use lib;\n-use lib::llvm::{llvm, ValueRef, TypeRef};\n+use lib::llvm::{llvm, ValueRef};\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -27,6 +27,8 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n+use middle::trans::type_::Type;\n+\n use core::option::None;\n use syntax::ast;\n use syntax::codemap;\n@@ -51,7 +53,7 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n }\n \n pub fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n+    let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n pub fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n@@ -62,24 +64,24 @@ pub fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n }\n \n pub fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    base::non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n+    GEPi(bcx, vptr, [0u, abi::box_field_body])\n }\n \n pub fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n+    let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n pub fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n+    let _icx = push_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n-    let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n+    let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n                  fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n+    let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n@@ -103,7 +105,7 @@ pub fn alloc_vec(bcx: block,\n                  elts: uint,\n                  heap: heap)\n               -> Result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n+    let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = nonzero_llsize_of(ccx, llunitty);\n@@ -117,7 +119,7 @@ pub fn alloc_vec(bcx: block,\n }\n \n pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n-    let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n+    let _icx = push_ctxt(\"tvec::duplicate_uniq\");\n \n     let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -135,7 +137,7 @@ pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n \n pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n+    let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n@@ -146,7 +148,7 @@ pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n pub struct VecTypes {\n     vec_ty: ty::t,\n     unit_ty: ty::t,\n-    llunit_ty: TypeRef,\n+    llunit_ty: Type,\n     llunit_size: ValueRef\n }\n \n@@ -155,8 +157,8 @@ impl VecTypes {\n         fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),\n-             ty_str(ccx.tn, self.llunit_ty),\n-             val_str(ccx.tn, self.llunit_size))\n+             ccx.tn.type_to_str(self.llunit_ty),\n+             ccx.tn.val_to_str(self.llunit_size))\n     }\n }\n \n@@ -227,7 +229,7 @@ pub fn trans_slice_vstore(bcx: block,\n     let fixed_ty = ty::mk_evec(bcx.tcx(),\n                                ty::mt {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n                                ty::vstore_fixed(count));\n-    let llfixed_ty = T_ptr(type_of::type_of(bcx.ccx(), fixed_ty));\n+    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n     add_clean(bcx, llfixed_casted, fixed_ty);\n \n@@ -271,13 +273,10 @@ pub fn trans_lit_str(bcx: block,\n                 let bytes = str_lit.len() + 1; // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n-                let llcstr = llvm::LLVMConstPointerCast(llcstr,\n-                                                        T_ptr(T_i8()));\n-                Store(bcx,\n-                      llcstr,\n+                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n+                Store(bcx, llcstr,\n                       GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-                Store(bcx,\n-                      llbytes,\n+                Store(bcx, llbytes,\n                       GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n                 bcx\n             }\n@@ -286,9 +285,7 @@ pub fn trans_lit_str(bcx: block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: block,\n-                                    heap: heap,\n-                                    vstore_expr: @ast::expr,\n+pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::expr,\n                                     content_expr: @ast::expr) -> DatumBlock {\n     //!\n     //\n@@ -307,7 +304,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n                     node: ast::lit_str(s), _\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), s);\n-                    let llptrval = PointerCast(bcx, llptrval, T_ptr(T_i8()));\n+                    let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n                     let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = scratch_datum(bcx, typ, false);\n@@ -336,7 +333,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n     let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n \n     debug!(\"alloc_vec() returned val=%s, dataptr=%s\",\n-           bcx.val_str(val), bcx.val_str(dataptr));\n+           bcx.val_to_str(val), bcx.val_to_str(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,\n                             content_expr, SaveIn(dataptr));\n@@ -352,7 +349,7 @@ pub fn write_content(bcx: block,\n                      content_expr: @ast::expr,\n                      dest: Dest)\n                   -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::write_content\");\n+    let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n     debug!(\"write_content(vt=%s, dest=%s, vstore_expr=%?)\",\n@@ -389,7 +386,7 @@ pub fn write_content(bcx: block,\n                     for elements.iter().enumerate().advance |(i, element)| {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index %? with lleltptr=%?\",\n-                               i, bcx.val_str(lleltptr));\n+                               i, bcx.val_to_str(lleltptr));\n                         bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n@@ -551,7 +548,7 @@ pub type iter_vec_block<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                     fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n+    let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n@@ -582,14 +579,14 @@ pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n \n pub fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                      fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n+    let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n pub fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n                         f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n+    let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);\n     return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);"}, {"sha": "34a15033109129d69a0d1bbd276baf83da9dfca0", "filename": "src/librustc/middle/trans/type_.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -0,0 +1,374 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n+use lib::llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n+\n+use middle::ty;\n+\n+use middle::trans::context::CrateContext;\n+use middle::trans::base;\n+\n+use syntax::ast;\n+use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use back::abi;\n+\n+use core::vec;\n+use core::cast;\n+\n+use core::libc::{c_uint};\n+\n+#[deriving(Eq)]\n+pub struct Type {\n+    priv rf: TypeRef\n+}\n+\n+macro_rules! ty (\n+    ($e:expr) => ( Type::from_ref(unsafe { $e }))\n+)\n+\n+/**\n+ * Wrapper for LLVM TypeRef\n+ */\n+impl Type {\n+    #[inline(always)]\n+    pub fn from_ref(r: TypeRef) -> Type {\n+        Type {\n+            rf: r\n+        }\n+    }\n+\n+    #[inline(always)] // So it doesn't kill --opt-level=0 builds of the compiler\n+    pub fn to_ref(&self) -> TypeRef {\n+        self.rf\n+    }\n+\n+    pub fn void() -> Type {\n+        ty!(llvm::LLVMVoidTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn nil() -> Type {\n+        Type::empty_struct()\n+    }\n+\n+    pub fn metadata() -> Type {\n+        ty!(llvm::LLVMMetadataTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i1() -> Type {\n+        ty!(llvm::LLVMInt1TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i8() -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i16() -> Type {\n+        ty!(llvm::LLVMInt16TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i32() -> Type {\n+        ty!(llvm::LLVMInt32TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn i64() -> Type {\n+        ty!(llvm::LLVMInt64TypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn f32() -> Type {\n+        ty!(llvm::LLVMFloatTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn f64() -> Type {\n+        ty!(llvm::LLVMDoubleTypeInContext(base::task_llcx()))\n+    }\n+\n+    pub fn bool() -> Type {\n+        Type::i8()\n+    }\n+\n+    pub fn char() -> Type {\n+        Type::i32()\n+    }\n+\n+    pub fn i8p() -> Type {\n+        Type::i8().ptr_to()\n+    }\n+\n+    pub fn int(arch: Architecture) -> Type {\n+        match arch {\n+            X86 | Arm | Mips => Type::i32(),\n+            X86_64 => Type::i64()\n+        }\n+    }\n+\n+    pub fn float(_: Architecture) -> Type {\n+        // All architectures currently just use doubles as the default\n+        // float size\n+        Type::f64()\n+    }\n+\n+    pub fn int_from_ty(ctx: &CrateContext, t: ast::int_ty) -> Type {\n+        match t {\n+            ast::ty_i => ctx.int_type,\n+            ast::ty_char => Type::char(),\n+            ast::ty_i8 => Type::i8(),\n+            ast::ty_i16 => Type::i16(),\n+            ast::ty_i32 => Type::i32(),\n+            ast::ty_i64 => Type::i64()\n+        }\n+    }\n+\n+    pub fn uint_from_ty(ctx: &CrateContext, t: ast::uint_ty) -> Type {\n+        match t {\n+            ast::ty_u => ctx.int_type,\n+            ast::ty_u8 => Type::i8(),\n+            ast::ty_u16 => Type::i16(),\n+            ast::ty_u32 => Type::i32(),\n+            ast::ty_u64 => Type::i64()\n+        }\n+    }\n+\n+    pub fn float_from_ty(ctx: &CrateContext, t: ast::float_ty) -> Type {\n+        match t {\n+            ast::ty_f => ctx.float_type,\n+            ast::ty_f32 => Type::f32(),\n+            ast::ty_f64 => Type::f64()\n+        }\n+    }\n+\n+    pub fn size_t(arch: Architecture) -> Type {\n+        Type::int(arch)\n+    }\n+\n+    pub fn func(args: &[Type], ret: &Type) -> Type {\n+        let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+                                   args.len() as c_uint, False))\n+    }\n+\n+    pub fn func_pair(cx: &CrateContext, fn_ty: &Type) -> Type {\n+        Type::struct_([fn_ty.ptr_to(), Type::opaque_cbox_ptr(cx)], false)\n+    }\n+\n+    pub fn ptr(ty: Type) -> Type {\n+        ty!(llvm::LLVMPointerType(ty.to_ref(), 0 as c_uint))\n+    }\n+\n+    pub fn struct_(els: &[Type], packed: bool) -> Type {\n+        let els : &[TypeRef] = unsafe { cast::transmute(els) };\n+        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), vec::raw::to_ptr(els),\n+                                          els.len() as c_uint, packed as Bool))\n+    }\n+\n+    pub fn named_struct(name: &str) -> Type {\n+        let ctx = base::task_llcx();\n+        ty!(name.as_c_str(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n+    }\n+\n+    pub fn empty_struct() -> Type {\n+        Type::struct_([], false)\n+    }\n+\n+    pub fn vtable() -> Type {\n+        Type::array(&Type::i8().ptr_to(), 1)\n+    }\n+\n+    pub fn generic_glue_fn(cx: &mut CrateContext) -> Type {\n+        match cx.tn.find_type(\"glue_fn\") {\n+            Some(ty) => return ty,\n+            None => ()\n+        }\n+\n+        let ty = cx.tydesc_type.get_field(abi::tydesc_field_drop_glue);\n+        cx.tn.associate_type(\"glue_fn\", &ty);\n+\n+        return ty;\n+    }\n+\n+    pub fn tydesc(arch: Architecture) -> Type {\n+        let mut tydesc = Type::named_struct(\"tydesc\");\n+        let tydescpp = tydesc.ptr_to().ptr_to();\n+        let pvoid = Type::i8p();\n+        let glue_fn_ty = Type::func([ Type::nil().ptr_to(), tydescpp, pvoid ],\n+            &Type::void()).ptr_to();\n+\n+        let int_ty = Type::int(arch);\n+\n+        let elems = [\n+            int_ty, int_ty,\n+            glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n+            pvoid, pvoid\n+        ];\n+\n+        tydesc.set_struct_body(elems, false);\n+\n+        return tydesc;\n+    }\n+\n+    pub fn array(ty: &Type, len: u64) -> Type {\n+        ty!(llvm::LLVMArrayType(ty.to_ref(), len as c_uint))\n+    }\n+\n+    pub fn vector(ty: &Type, len: u64) -> Type {\n+        ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n+    }\n+\n+    pub fn vec(arch: Architecture, ty: &Type) -> Type {\n+        Type::struct_(\n+            [ Type::int(arch), Type::int(arch), Type::array(ty, 0) ],\n+        false)\n+    }\n+\n+    pub fn opaque_vec(arch: Architecture) -> Type {\n+        Type::vec(arch, &Type::i8())\n+    }\n+\n+    #[inline]\n+    pub fn box_header_fields(ctx: &CrateContext) -> ~[Type] {\n+        ~[\n+            ctx.int_type, ctx.tydesc_type.ptr_to(),\n+            Type::i8().ptr_to(), Type::i8().ptr_to()\n+        ]\n+    }\n+\n+    pub fn box_header(ctx: &CrateContext) -> Type {\n+        Type::struct_(Type::box_header_fields(ctx), false)\n+    }\n+\n+    pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n+        Type::struct_(Type::box_header_fields(ctx) + [*ty], false)\n+    }\n+\n+    pub fn opaque_box(ctx: &CrateContext) -> Type {\n+        Type::box(ctx, &Type::i8())\n+    }\n+\n+    pub fn unique(ctx: &CrateContext, ty: &Type) -> Type {\n+        Type::box(ctx, ty)\n+    }\n+\n+    pub fn opaque_cbox_ptr(cx: &CrateContext) -> Type {\n+        Type::opaque_box(cx).ptr_to()\n+    }\n+\n+    pub fn enum_discrim(cx: &CrateContext) -> Type {\n+        cx.int_type\n+    }\n+\n+    pub fn captured_tydescs(ctx: &CrateContext, num: uint) -> Type {\n+        Type::struct_(vec::from_elem(num, ctx.tydesc_type.ptr_to()), false)\n+    }\n+\n+    pub fn opaque_trait(ctx: &CrateContext, store: ty::TraitStore) -> Type {\n+        let tydesc_ptr = ctx.tydesc_type.ptr_to();\n+        match store {\n+            ty::BoxTraitStore => {\n+                Type::struct_(\n+                    [ tydesc_ptr, Type::opaque_box(ctx).ptr_to() ],\n+                false)\n+            }\n+            ty::UniqTraitStore => {\n+                Type::struct_(\n+                    [ tydesc_ptr, Type::unique(ctx, &Type::i8()).ptr_to()],\n+                false)\n+            }\n+            ty::RegionTraitStore(*) => {\n+                Type::struct_(\n+                    [ tydesc_ptr, Type::i8().ptr_to() ],\n+                false)\n+            }\n+        }\n+    }\n+\n+    pub fn kind(&self) -> TypeKind {\n+        unsafe {\n+            llvm::LLVMGetTypeKind(self.to_ref())\n+        }\n+    }\n+\n+    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n+        unsafe {\n+            let vec : &[TypeRef] = cast::transmute(els);\n+            llvm::LLVMStructSetBody(self.to_ref(), vec::raw::to_ptr(vec),\n+                                    els.len() as c_uint, packed as Bool)\n+        }\n+    }\n+\n+    pub fn ptr_to(&self) -> Type {\n+        ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n+    }\n+\n+    pub fn get_field(&self, idx: uint) -> Type {\n+        unsafe {\n+            let num_fields = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n+            let mut elems = vec::from_elem(num_fields, 0 as TypeRef);\n+\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), vec::raw::to_mut_ptr(elems));\n+\n+            Type::from_ref(elems[idx])\n+        }\n+    }\n+\n+    pub fn is_packed(&self) -> bool {\n+        unsafe {\n+            llvm::LLVMIsPackedStruct(self.to_ref()) == True\n+        }\n+    }\n+\n+    pub fn element_type(&self) -> Type {\n+        unsafe {\n+            Type::from_ref(llvm::LLVMGetElementType(self.to_ref()))\n+        }\n+    }\n+\n+    pub fn array_length(&self) -> uint {\n+        unsafe {\n+            llvm::LLVMGetArrayLength(self.to_ref()) as uint\n+        }\n+    }\n+\n+    pub fn field_types(&self) -> ~[Type] {\n+        unsafe {\n+            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n+            if n_elts == 0 {\n+                return ~[];\n+            }\n+            let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n+            cast::transmute(elts)\n+        }\n+    }\n+\n+    pub fn return_type(&self) -> Type {\n+        ty!(llvm::LLVMGetReturnType(self.to_ref()))\n+    }\n+\n+    pub fn func_params(&self) -> ~[Type] {\n+        unsafe {\n+            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n+            let args = vec::from_elem(n_args, 0 as TypeRef);\n+            llvm::LLVMGetParamTypes(self.to_ref(), vec::raw::to_ptr(args));\n+            cast::transmute(args)\n+        }\n+    }\n+\n+    pub fn float_width(&self) -> uint {\n+        match self.kind() {\n+            Float => 32,\n+            Double => 64,\n+            X86_FP80 => 80,\n+            FP128 | PPC_FP128 => 128,\n+            _ => fail!(\"llvm_float_width called on a non-float type\")\n+        }\n+    }\n+}"}, {"sha": "448ded6b70f2ab1215243f921ffc47a4554bff63", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 108, "deletions": 133, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -10,61 +10,60 @@\n \n use core::prelude::*;\n \n-use lib::llvm::llvm;\n-use lib::llvm::{TypeRef};\n use middle::trans::adt;\n-use middle::trans::base;\n use middle::trans::common::*;\n-use middle::trans::common;\n use middle::ty;\n use util::ppaux;\n \n+use middle::trans::type_::Type;\n+\n use syntax::ast;\n \n pub fn arg_is_indirect(_: &CrateContext, arg_ty: &ty::t) -> bool {\n     !ty::type_is_immediate(*arg_ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> TypeRef {\n+pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n     let llty = type_of(ccx, *arg_ty);\n-    if arg_is_indirect(ccx, arg_ty) {T_ptr(llty)} else {llty}\n+    if arg_is_indirect(ccx, arg_ty) {\n+        llty.ptr_to()\n+    } else {\n+        llty\n+    }\n }\n \n pub fn type_of_explicit_args(ccx: &mut CrateContext,\n-                             inputs: &[ty::t]) -> ~[TypeRef] {\n+                             inputs: &[ty::t]) -> ~[Type] {\n     inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t)\n-               -> TypeRef {\n-    unsafe {\n-        let mut atys: ~[TypeRef] = ~[];\n-\n-        // Arg 0: Output pointer.\n-        // (if the output type is non-immediate)\n-        let output_is_immediate = ty::type_is_immediate(output);\n-        let lloutputtype = type_of(cx, output);\n-        if !output_is_immediate {\n-            atys.push(T_ptr(lloutputtype));\n-        }\n+pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Type {\n+    let mut atys: ~[Type] = ~[];\n \n-        // Arg 1: Environment\n-        atys.push(T_opaque_box_ptr(cx));\n+    // Arg 0: Output pointer.\n+    // (if the output type is non-immediate)\n+    let output_is_immediate = ty::type_is_immediate(output);\n+    let lloutputtype = type_of(cx, output);\n+    if !output_is_immediate {\n+        atys.push(lloutputtype.ptr_to());\n+    }\n \n-        // ... then explicit args.\n-        atys.push_all(type_of_explicit_args(cx, inputs));\n+    // Arg 1: Environment\n+    atys.push(Type::opaque_box(cx).ptr_to());\n \n-        // Use the output as the actual return value if it's immediate.\n-        if output_is_immediate && !ty::type_is_nil(output) {\n-            T_fn(atys, lloutputtype)\n-        } else {\n-            T_fn(atys, llvm::LLVMVoidTypeInContext(cx.llcx))\n-        }\n+    // ... then explicit args.\n+    atys.push_all(type_of_explicit_args(cx, inputs));\n+\n+    // Use the output as the actual return value if it's immediate.\n+    if output_is_immediate && !ty::type_is_nil(output) {\n+        Type::func(atys, &lloutputtype)\n+    } else {\n+        Type::func(atys, &Type::void())\n     }\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> TypeRef {\n+pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n         ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n@@ -74,7 +73,7 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> TypeRef {\n     }\n }\n \n-pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> Type {\n     assert!(!ty::type_needs_infer(t));\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n@@ -84,11 +83,11 @@ pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n         match ty::get(t).sty {\n           ty::ty_box(mt) => {\n               let ty = type_of(cx, mt.ty);\n-              T_ptr(T_box(cx, ty))\n+              Type::box(cx, &ty).ptr_to()\n           }\n           ty::ty_uniq(mt) => {\n               let ty = type_of(cx, mt.ty);\n-              T_ptr(T_unique(cx, ty))\n+              Type::unique(cx, &ty).ptr_to()\n           }\n           _ => {\n             cx.sess.bug(\"non-box in type_of_non_gc_box\");\n@@ -109,18 +108,18 @@ pub fn type_of_non_gc_box(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n //     recursive types. For example, `static_size_of_enum()` relies on this\n //     behavior.\n \n-pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n-    match cx.llsizingtypes.find(&t) {\n-        Some(t) => return *t,\n+pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n+    match cx.llsizingtypes.find_copy(&t) {\n+        Some(t) => return t,\n         None => ()\n     }\n \n     let llsizingty = match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot => T_nil(),\n-        ty::ty_bool => T_bool(),\n-        ty::ty_int(t) => T_int_ty(cx, t),\n-        ty::ty_uint(t) => T_uint_ty(cx, t),\n-        ty::ty_float(t) => T_float_ty(cx, t),\n+        ty::ty_nil | ty::ty_bot => Type::nil(),\n+        ty::ty_bool => Type::bool(),\n+        ty::ty_int(t) => Type::int_from_ty(cx, t),\n+        ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n+        ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_estr(ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_box) |\n@@ -132,48 +131,46 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n         ty::ty_ptr(*) |\n         ty::ty_rptr(*) |\n         ty::ty_type |\n-        ty::ty_opaque_closure_ptr(*) => T_ptr(T_i8()),\n+        ty::ty_opaque_closure_ptr(*) => Type::i8p(),\n \n         ty::ty_estr(ty::vstore_slice(*)) |\n         ty::ty_evec(_, ty::vstore_slice(*)) => {\n-            T_struct([T_ptr(T_i8()), T_ptr(T_i8())], false)\n+            Type::struct_([Type::i8p(), Type::i8p()], false)\n         }\n \n-        ty::ty_bare_fn(*) => T_ptr(T_i8()),\n-        ty::ty_closure(*) => T_struct([T_ptr(T_i8()), T_ptr(T_i8())], false),\n-        ty::ty_trait(_, _, store, _) => T_opaque_trait(cx, store),\n+        ty::ty_bare_fn(*) => Type::i8p(),\n+        ty::ty_closure(*) => Type::struct_([Type::i8p(), Type::i8p()], false),\n+        ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n \n-        ty::ty_estr(ty::vstore_fixed(size)) => T_array(T_i8(), size),\n+        ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n         ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n-            T_array(sizing_type_of(cx, mt.ty), size)\n+            Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n         ty::ty_unboxed_vec(mt) => {\n             let sz_ty = sizing_type_of(cx, mt.ty);\n-            T_vec(cx, sz_ty)\n+            Type::vec(cx.sess.targ_cfg.arch, &sz_ty)\n         }\n \n         ty::ty_tup(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n-            T_struct(adt::sizing_fields_of(cx, repr), false)\n+            Type::struct_(adt::sizing_fields_of(cx, repr), false)\n         }\n \n         ty::ty_struct(did, _) => {\n             if ty::type_is_simd(cx.tcx, t) {\n                 let et = ty::simd_type(cx.tcx, t);\n                 let n = ty::simd_size(cx.tcx, t);\n-                T_vector(type_of(cx, et), n)\n+                Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n                 let packed = ty::lookup_packed(cx.tcx, did);\n-                T_struct(adt::sizing_fields_of(cx, repr), packed)\n+                Type::struct_(adt::sizing_fields_of(cx, repr), packed)\n             }\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n-            cx.tcx.sess.bug(\n-                fmt!(\"fictitious type %? in sizing_type_of()\",\n-                     ty::get(t).sty))\n+            cx.tcx.sess.bug(fmt!(\"fictitious type %? in sizing_type_of()\", ty::get(t).sty))\n         }\n     };\n \n@@ -182,7 +179,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n+pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n@@ -204,99 +201,94 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n         return llty;\n     }\n \n-    let llty = match ty::get(t).sty {\n-      ty::ty_nil | ty::ty_bot => T_nil(),\n-      ty::ty_bool => T_bool(),\n-      ty::ty_int(t) => T_int_ty(cx, t),\n-      ty::ty_uint(t) => T_uint_ty(cx, t),\n-      ty::ty_float(t) => T_float_ty(cx, t),\n+    let mut llty = match ty::get(t).sty {\n+      ty::ty_nil | ty::ty_bot => Type::nil(),\n+      ty::ty_bool => Type::bool(),\n+      ty::ty_int(t) => Type::int_from_ty(cx, t),\n+      ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n+      ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_estr(ty::vstore_uniq) => {\n-        T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n+        Type::unique(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n         // fill it in *after* placing it into the type cache. This\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n \n-        common::T_named_struct(llvm_type_name(cx,\n-                                              an_enum,\n-                                              did,\n-                                              substs.tps))\n+        Type::named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n       }\n       ty::ty_estr(ty::vstore_box) => {\n-        T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n+        Type::box(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n-          let v_ty = T_vec(cx, e_ty);\n-          T_box_ptr(T_box(cx, v_ty))\n+          let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n+          Type::box(cx, &v_ty).ptr_to()\n       }\n       ty::ty_box(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          T_box_ptr(T_box(cx, ty))\n+          Type::box(cx, &ty).ptr_to()\n       }\n-      ty::ty_opaque_box => T_box_ptr(T_box(cx, T_i8())),\n+      ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          T_unique_ptr(T_unique(cx, ty))\n+          Type::unique(cx, &ty).ptr_to()\n       }\n       ty::ty_evec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n-          let ty = T_vec(cx, ty);\n-          T_unique_ptr(T_unique(cx, ty))\n+          let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n+          Type::unique(cx, &ty).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n-          T_vec(cx, ty)\n+          Type::vec(cx.sess.targ_cfg.arch, &ty)\n       }\n-      ty::ty_ptr(ref mt) => T_ptr(type_of(cx, mt.ty)),\n-      ty::ty_rptr(_, ref mt) => T_ptr(type_of(cx, mt.ty)),\n+      ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n+      ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n       ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n-          let p_ty = T_ptr(type_of(cx, mt.ty));\n-          let u_ty = T_uint_ty(cx, ast::ty_u);\n-          T_struct([p_ty, u_ty], false)\n+          let p_ty = type_of(cx, mt.ty).ptr_to();\n+          let u_ty = Type::uint_from_ty(cx, ast::ty_u);\n+          Type::struct_([p_ty, u_ty], false)\n       }\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n-        T_struct([T_ptr(T_i8()), T_uint_ty(cx, ast::ty_u)], false)\n+          // This means we get a nicer name in the output\n+          cx.tn.find_type(\"str_slice\").get()\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {\n-        T_array(T_i8(), n + 1u /* +1 for trailing null */)\n+          Type::array(&Type::i8(), (n + 1u) as u64)\n       }\n \n       ty::ty_evec(ref mt, ty::vstore_fixed(n)) => {\n-        T_array(type_of(cx, mt.ty), n)\n+          Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n \n-      ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n+      ty::ty_bare_fn(_) => type_of_fn_from_ty(cx, t).ptr_to(),\n       ty::ty_closure(_) => {\n           let ty = type_of_fn_from_ty(cx, t);\n-          T_fn_pair(cx, ty)\n+          Type::func_pair(cx, &ty)\n       }\n-      ty::ty_trait(_, _, store, _) => T_opaque_trait(cx, store),\n-      ty::ty_type => T_ptr(cx.tydesc_type),\n+      ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n+      ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n-          T_struct(adt::fields_of(cx, repr), false)\n+          Type::struct_(adt::fields_of(cx, repr), false)\n       }\n-      ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n+      ty::ty_opaque_closure_ptr(_) => Type::opaque_box(cx).ptr_to(),\n       ty::ty_struct(did, ref substs) => {\n-        if ty::type_is_simd(cx.tcx, t) {\n-          let et = ty::simd_type(cx.tcx, t);\n-          let n = ty::simd_size(cx.tcx, t);\n-          T_vector(type_of(cx, et), n)\n-        } else {\n-          // Only create the named struct, but don't fill it in. We fill it\n-          // in *after* placing it into the type cache. This prevents\n-          // infinite recursion with recursive struct types.\n-          T_named_struct(llvm_type_name(cx,\n-                                        a_struct,\n-                                        did,\n-                                        substs.tps))\n-        }\n+          if ty::type_is_simd(cx.tcx, t) {\n+              let et = ty::simd_type(cx.tcx, t);\n+              let n = ty::simd_size(cx.tcx, t);\n+              Type::vector(&type_of(cx, et), n as u64)\n+          } else {\n+              // Only create the named struct, but don't fill it in. We fill it\n+              // in *after* placing it into the type cache. This prevents\n+              // infinite recursion with recursive struct types.\n+              Type::named_struct(llvm_type_name(cx, a_struct, did, substs.tps))\n+          }\n       }\n       ty::ty_self(*) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n@@ -310,16 +302,14 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> TypeRef {\n     match ty::get(t).sty {\n       ty::ty_enum(*) => {\n           let repr = adt::represent_type(cx, t);\n-          common::set_struct_body(llty, adt::fields_of(cx, repr),\n-                                  false);\n+          llty.set_struct_body(adt::fields_of(cx, repr), false);\n       }\n \n       ty::ty_struct(did, _) => {\n         if !ty::type_is_simd(cx.tcx, t) {\n           let repr = adt::represent_type(cx, t);\n           let packed = ty::lookup_packed(cx.tcx, did);\n-          common::set_struct_body(llty, adt::fields_of(cx, repr),\n-                                  packed);\n+          llty.set_struct_body(adt::fields_of(cx, repr), packed);\n         }\n       }\n       _ => ()\n@@ -336,33 +326,18 @@ pub fn llvm_type_name(cx: &CrateContext,\n                       did: ast::def_id,\n                       tps: &[ty::t]) -> ~str {\n     let name = match what {\n-        a_struct => { \"~struct\" }\n-        an_enum => { \"~enum\" }\n+        a_struct => { \"struct\" }\n+        an_enum => { \"enum\" }\n     };\n-    return fmt!(\n-        \"%s %s[#%d]\",\n-          name,\n-        ppaux::parameterized(\n-            cx.tcx,\n-            ty::item_path_str(cx.tcx, did),\n-            None,\n-            tps),\n-        did.crate\n-    );\n-}\n-\n-pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> TypeRef {\n-    T_fn([T_ptr(type_of(ccx, self_ty))] /* self */, T_void())\n-}\n-\n-pub fn type_of_rooted(ccx: &mut CrateContext, t: ty::t) -> TypeRef {\n-    let addrspace = base::get_tydesc(ccx, t).addrspace;\n-    debug!(\"type_of_rooted %s in addrspace %u\",\n-           ppaux::ty_to_str(ccx.tcx, t), addrspace as uint);\n-    return T_root(type_of(ccx, t), addrspace);\n+    let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did), None, tps);\n+    if did.crate == 0 {\n+        fmt!(\"%s.%s\", name, tstr)\n+    } else {\n+        fmt!(\"%s.%s[#%d]\", name, tstr, did.crate)\n+    }\n }\n \n-pub fn type_of_glue_fn(ccx: &CrateContext) -> TypeRef {\n-    let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n-    return T_fn([T_ptr(T_nil()), tydescpp, T_ptr(T_i8())], T_void());\n+pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> Type {\n+    let self_ty = type_of(ccx, self_ty).ptr_to();\n+    Type::func([self_ty], &Type::void())\n }"}, {"sha": "4f532885c92f24b867257685ba77bf323596b88a", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -117,46 +117,43 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                                  _,\n                                  _) => {\n         if abi.is_intrinsic() {\n-            let flags = match cx.ccx.sess.str_of(i.ident).as_slice() {\n-                \"size_of\"  | \"pref_align_of\" | \"min_align_of\" |\n-                \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n-                \"move_val_init\" => use_repr,\n-\n-                \"get_tydesc\" | \"needs_drop\" => use_tydesc,\n-\n-                \"atomic_cxchg\"    | \"atomic_cxchg_acq\"|\n-                \"atomic_cxchg_rel\"| \"atomic_load\"     |\n-                \"atomic_load_acq\" | \"atomic_store\"    |\n-                \"atomic_store_rel\"| \"atomic_xchg\"     |\n-                \"atomic_xadd\"     | \"atomic_xsub\"     |\n-                \"atomic_xchg_acq\" | \"atomic_xadd_acq\" |\n-                \"atomic_xsub_acq\" | \"atomic_xchg_rel\" |\n-                \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => 0,\n-\n-                \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n-                \"morestack_addr\" => 0,\n-\n-                \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n-                \"memset32\" | \"memset64\" => use_repr,\n-\n-                \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |\n-                \"sinf32\"  | \"sinf64\"  | \"cosf32\"  | \"cosf64\"  |\n-                \"powf32\"  | \"powf64\"  | \"expf32\"  | \"expf64\"  |\n-                \"exp2f32\" | \"exp2f64\" | \"logf32\"  | \"logf64\"  |\n-                \"log10f32\"| \"log10f64\"| \"log2f32\" | \"log2f64\" |\n-                \"fmaf32\"  | \"fmaf64\"  | \"fabsf32\" | \"fabsf64\" |\n-                \"floorf32\"| \"floorf64\"| \"ceilf32\" | \"ceilf64\" |\n-                \"truncf32\"| \"truncf64\" => 0,\n-\n-                \"ctpop8\" | \"ctpop16\" | \"ctpop32\" | \"ctpop64\" => 0,\n-\n-                \"ctlz8\" | \"ctlz16\" | \"ctlz32\" | \"ctlz64\" => 0,\n-                \"cttz8\" | \"cttz16\" | \"cttz32\" | \"cttz64\" => 0,\n-\n-                \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n-\n-                // would be cool to make these an enum instead of strings!\n-                _ => fail!(\"unknown intrinsic in type_use\")\n+            let nm = cx.ccx.sess.str_of(i.ident);\n+            let name = nm.as_slice();\n+            let flags = if name.starts_with(\"atomic_\") {\n+                0\n+            } else {\n+                match name {\n+                    \"size_of\"  | \"pref_align_of\" | \"min_align_of\" |\n+                    \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n+                    \"move_val_init\" => use_repr,\n+\n+                    \"get_tydesc\" | \"needs_drop\" => use_tydesc,\n+\n+                    \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n+                    \"morestack_addr\" => 0,\n+\n+                    \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n+                    \"memset32\" | \"memset64\" => use_repr,\n+\n+                    \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |\n+                    \"sinf32\"  | \"sinf64\"  | \"cosf32\"  | \"cosf64\"  |\n+                    \"powf32\"  | \"powf64\"  | \"expf32\"  | \"expf64\"  |\n+                    \"exp2f32\" | \"exp2f64\" | \"logf32\"  | \"logf64\"  |\n+                    \"log10f32\"| \"log10f64\"| \"log2f32\" | \"log2f64\" |\n+                    \"fmaf32\"  | \"fmaf64\"  | \"fabsf32\" | \"fabsf64\" |\n+                    \"floorf32\"| \"floorf64\"| \"ceilf32\" | \"ceilf64\" |\n+                    \"truncf32\"| \"truncf64\" => 0,\n+\n+                    \"ctpop8\" | \"ctpop16\" | \"ctpop32\" | \"ctpop64\" => 0,\n+\n+                    \"ctlz8\" | \"ctlz16\" | \"ctlz32\" | \"ctlz64\" => 0,\n+                    \"cttz8\" | \"cttz16\" | \"cttz32\" | \"cttz64\" => 0,\n+\n+                    \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n+\n+                    // would be cool to make these an enum instead of strings!\n+                    _ => fail!(\"unknown intrinsic in type_use\")\n+                }\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }"}, {"sha": "d27d6efb2416f59a2ba439c971222157581ca997", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n-    let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n+    let _icx = push_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n \n     let not_null = IsNotNull(bcx, box_datum.val);\n@@ -38,7 +38,7 @@ pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n }\n \n pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n-    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n+    let _icx = push_ctxt(\"uniq::duplicate\");\n \n     // Load the body of the source (*src)\n     let src_datum = immediate_rvalue(src_box, src_ty);"}, {"sha": "eb5376da69697cd48bc3999f15206540164dffb6", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -28,6 +28,8 @@ use middle::ty;\n use syntax::codemap::span;\n use syntax::ast;\n \n+use middle::trans::type_::Type;\n+\n pub fn root_and_write_guard(datum: &Datum,\n                             mut bcx: block,\n                             span: span,\n@@ -64,20 +66,15 @@ pub fn return_to_mut(mut bcx: block,\n     debug!(\"write_guard::return_to_mut(root_key=%?, %s, %s, %s)\",\n            root_key,\n            bcx.to_str(),\n-           val_str(bcx.ccx().tn, frozen_val_ref),\n-           val_str(bcx.ccx().tn, bits_val_ref));\n+           bcx.val_to_str(frozen_val_ref),\n+           bcx.val_to_str(bits_val_ref));\n \n-    let box_ptr =\n-        Load(bcx, PointerCast(bcx,\n-                              frozen_val_ref,\n-                              T_ptr(T_ptr(T_i8()))));\n+    let box_ptr = Load(bcx, PointerCast(bcx, frozen_val_ref, Type::i8p().ptr_to()));\n \n-    let bits_val =\n-        Load(bcx, bits_val_ref);\n+    let bits_val = Load(bcx, bits_val_ref);\n \n     if bcx.tcx().sess.debug_borrows() {\n-        bcx = callee::trans_lang_call(\n-            bcx,\n+        bcx = callee::trans_lang_call( bcx,\n             bcx.tcx().lang_items.unrecord_borrow_fn(),\n             [\n                 box_ptr,\n@@ -146,10 +143,7 @@ fn root(datum: &Datum,\n                 DynaMut => bcx.tcx().lang_items.borrow_as_mut_fn(),\n             };\n \n-            let box_ptr = Load(bcx,\n-                               PointerCast(bcx,\n-                                           scratch.val,\n-                                           T_ptr(T_ptr(T_i8()))));\n+            let box_ptr = Load(bcx, PointerCast(bcx, scratch.val, Type::i8p().ptr_to()));\n \n             bcx = callee::trans_lang_call(\n                 bcx,\n@@ -194,6 +188,6 @@ fn perform_write_guard(datum: &Datum,\n     callee::trans_lang_call(\n         bcx,\n         bcx.tcx().lang_items.check_not_borrowed_fn(),\n-        [PointerCast(bcx, llval, T_ptr(T_i8())), filename, line],\n+        [PointerCast(bcx, llval, Type::i8p()), filename, line],\n         expr::Ignore)\n }"}, {"sha": "e67955505f6d4ee833aec958b1e29f6f1c25566d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n use middle;\n-use util::ppaux::{note_and_explain_region, bound_region_to_str};\n+use util::ppaux::{note_and_explain_region, bound_region_to_str, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n@@ -3531,12 +3531,12 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_regions_insufficiently_polymorphic(br, _) => {\n             fmt!(\"expected bound lifetime parameter %s, \\\n                   but found concrete lifetime\",\n-                 bound_region_to_str(cx, br))\n+                 bound_region_ptr_to_str(cx, br))\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n             fmt!(\"expected concrete lifetime, \\\n                   but found bound lifetime parameter %s\",\n-                 bound_region_to_str(cx, br))\n+                 bound_region_ptr_to_str(cx, br))\n         }\n         terr_vstores_differ(k, ref values) => {\n             fmt!(\"%s storage differs: expected %s but found %s\","}, {"sha": "a8ae904148269d6be74f1752d06f7e7c4e7787c5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 263, "deletions": 247, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -107,7 +107,7 @@ use middle::typeck::{isr_alist, lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{bound_region_to_str};\n+use util::ppaux::{bound_region_to_str,bound_region_ptr_to_str};\n use util::ppaux;\n \n \n@@ -680,7 +680,7 @@ impl FnCtxt {\n                 } else {\n                     result::Err(RegionError {\n                         msg: fmt!(\"named region `%s` not in scope here\",\n-                                  bound_region_to_str(self.tcx(), br)),\n+                                  bound_region_ptr_to_str(self.tcx(), br)),\n                         replacement: self.infcx().next_region_var_nb(span)\n                     })\n                 }\n@@ -3434,252 +3434,268 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     }\n \n     let tcx = ccx.tcx;\n-    let str = ccx.tcx.sess.str_of(it.ident);\n-    let (n_tps, inputs, output) = match str.as_slice() {\n-        \"size_of\" |\n-        \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n-        \"init\" => (1u, ~[], param(ccx, 0u)),\n-        \"uninit\" => (1u, ~[], param(ccx, 0u)),\n-        \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n-        \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n-        \"move_val\" | \"move_val_init\" => {\n-            (1u,\n-             ~[\n-                ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n-                param(ccx, 0u)\n-              ],\n-           ty::mk_nil())\n-        }\n-        \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-\n-        \"atomic_cxchg\"    | \"atomic_cxchg_acq\"| \"atomic_cxchg_rel\" => {\n-          (0,\n-           ~[\n-              ty::mk_mut_rptr(tcx,\n-                              ty::re_bound(ty::br_anon(0)),\n-                              ty::mk_int()),\n-              ty::mk_int(),\n-              ty::mk_int()\n-           ],\n-           ty::mk_int())\n-        }\n-        \"atomic_load\"     | \"atomic_load_acq\" => {\n-          (0,\n-           ~[\n-              ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n-           ],\n-          ty::mk_int())\n-        }\n-        \"atomic_store\"    | \"atomic_store_rel\" => {\n-          (0,\n-           ~[\n-              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n-              ty::mk_int()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n-        \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n-        \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n-          (0,\n-           ~[\n-              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n-              ty::mk_int()\n-           ],\n-           ty::mk_int())\n-        }\n-\n-        \"get_tydesc\" => {\n-          // FIXME (#3730): return *intrinsic::tydesc, not *()\n-          (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n-        }\n-        \"visit_tydesc\" => {\n-          let tydesc_name = special_idents::tydesc;\n-          assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n-          let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n-          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n-              ty: tydesc_ty,\n-              mutbl: ast::m_imm\n-          });\n-          (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n-        }\n-        \"frame_address\" => {\n-          let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n-              purity: ast::impure_fn,\n-              sigil: ast::BorrowedSigil,\n-              onceness: ast::Once,\n-              region: ty::re_bound(ty::br_anon(0)),\n-              bounds: ty::EmptyBuiltinBounds(),\n-              sig: ty::FnSig {\n-                  bound_lifetime_names: opt_vec::Empty,\n-                  inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n-                  output: ty::mk_nil()\n-              }\n-          });\n-          (0u, ~[fty], ty::mk_nil())\n-        }\n-        \"morestack_addr\" => {\n-          (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n-        }\n-        \"memcpy32\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_imm\n-              }),\n-              ty::mk_u32()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memcpy64\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_imm\n-              }),\n-              ty::mk_u64()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memmove32\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_imm\n-              }),\n-              ty::mk_u32()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memmove64\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n+    let nm = ccx.tcx.sess.str_of(it.ident);\n+    let name = nm.as_slice();\n+    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.split_iter('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+\n+        //We only care about the operation here\n+        match split[1] {\n+            \"cxchg\" => (0, ~[ty::mk_mut_rptr(tcx,\n+                                             ty::re_bound(ty::br_anon(0)),\n+                                             ty::mk_int()),\n+                        ty::mk_int(),\n+                        ty::mk_int()\n+                        ], ty::mk_int()),\n+            \"load\" => (0,\n+               ~[\n+                  ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n+               ],\n+              ty::mk_int()),\n+            \"store\" => (0,\n+               ~[\n+                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_nil()),\n+\n+            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\"   | \"xor\"  | \"max\"  |\n+            \"min\"  | \"umax\" | \"umin\" => {\n+                (0, ~[ty::mk_mut_rptr(tcx,\n+                                      ty::re_bound(ty::br_anon(0)),\n+                                      ty::mk_int()), ty::mk_int() ], ty::mk_int())\n+            }\n+\n+            op => {\n+                tcx.sess.span_err(it.span,\n+                                  fmt!(\"unrecognized atomic operation function: `%s`\",\n+                                       op));\n+                return;\n+            }\n+        }\n+\n+    } else {\n+        match name {\n+            \"size_of\" |\n+            \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n+            \"init\" => (1u, ~[], param(ccx, 0u)),\n+            \"uninit\" => (1u, ~[], param(ccx, 0u)),\n+            \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n+            \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n+            \"move_val\" | \"move_val_init\" => {\n+                (1u,\n+                 ~[\n+                    ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n+                    param(ccx, 0u)\n+                  ],\n+               ty::mk_nil())\n+            }\n+            \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n+\n+            \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n+            \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n+            \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n+              (0,\n+               ~[\n+                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_int())\n+            }\n+\n+            \"get_tydesc\" => {\n+              // FIXME (#3730): return *intrinsic::tydesc, not *()\n+              (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+            }\n+            \"visit_tydesc\" => {\n+              let tydesc_name = special_idents::tydesc;\n+              assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+              let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n+              let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n+              let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n+                  ty: tydesc_ty,\n                   mutbl: ast::m_imm\n-              }),\n-              ty::mk_u64()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memset32\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_u8(),\n-              ty::mk_u32()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memset64\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_u8(),\n-              ty::mk_u64()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"powif32\" => {\n-           (0,\n-            ~[ ty::mk_f32(), ty::mk_i32() ],\n-            ty::mk_f32())\n-        }\n-        \"powif64\" => {\n-           (0,\n-            ~[ ty::mk_f64(), ty::mk_i32() ],\n-            ty::mk_f64())\n-        }\n-        \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"powf32\" => {\n-           (0,\n-            ~[ ty::mk_f32(), ty::mk_f32() ],\n-            ty::mk_f32())\n-        }\n-        \"powf64\" => {\n-           (0,\n-            ~[ ty::mk_f64(), ty::mk_f64() ],\n-            ty::mk_f64())\n-        }\n-        \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"fmaf32\" => {\n-            (0,\n-             ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n-             ty::mk_f32())\n-        }\n-        \"fmaf64\" => {\n-            (0,\n-             ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n-             ty::mk_f64())\n-        }\n-        \"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        \"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        \"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        \"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        \"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        \"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        \"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        ref other => {\n-            tcx.sess.span_err(it.span,\n-                              fmt!(\"unrecognized intrinsic function: `%s`\",\n-                                   *other));\n-            return;\n+              });\n+              (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n+            }\n+            \"frame_address\" => {\n+              let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n+                  purity: ast::impure_fn,\n+                  sigil: ast::BorrowedSigil,\n+                  onceness: ast::Once,\n+                  region: ty::re_bound(ty::br_anon(0)),\n+                  bounds: ty::EmptyBuiltinBounds(),\n+                  sig: ty::FnSig {\n+                      bound_lifetime_names: opt_vec::Empty,\n+                      inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n+                      output: ty::mk_nil()\n+                  }\n+              });\n+              (0u, ~[fty], ty::mk_nil())\n+            }\n+            \"morestack_addr\" => {\n+              (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+            }\n+            \"memcpy32\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u32()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memcpy64\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u64()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memmove32\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u32()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memmove64\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u64()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memset32\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_u8(),\n+                  ty::mk_u32()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memset64\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_u8(),\n+                  ty::mk_u64()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"powif32\" => {\n+               (0,\n+                ~[ ty::mk_f32(), ty::mk_i32() ],\n+                ty::mk_f32())\n+            }\n+            \"powif64\" => {\n+               (0,\n+                ~[ ty::mk_f64(), ty::mk_i32() ],\n+                ty::mk_f64())\n+            }\n+            \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"powf32\" => {\n+               (0,\n+                ~[ ty::mk_f32(), ty::mk_f32() ],\n+                ty::mk_f32())\n+            }\n+            \"powf64\" => {\n+               (0,\n+                ~[ ty::mk_f64(), ty::mk_f64() ],\n+                ty::mk_f64())\n+            }\n+            \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"fmaf32\" => {\n+                (0,\n+                 ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n+                 ty::mk_f32())\n+            }\n+            \"fmaf64\" => {\n+                (0,\n+                 ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n+                 ty::mk_f64())\n+            }\n+            \"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+            \"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+            \"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+            \"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            ref other => {\n+                tcx.sess.span_err(it.span,\n+                                  fmt!(\"unrecognized intrinsic function: `%s`\",\n+                                       *other));\n+                return;\n+            }\n         }\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {"}, {"sha": "2ff8ffdd6b21f286e20ce6469c072d8b898a17aa", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -690,13 +690,13 @@ fn constrain_regions_in_type(\n     let tcx = rcx.fcx.ccx.tcx;\n \n     debug!(\"constrain_regions_in_type(minimum_lifetime=%s, ty=%s)\",\n-           region_to_str(tcx, minimum_lifetime),\n+           region_to_str(tcx, \"\", false, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n     do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n         debug!(\"relate(r_sub=%s, r_sup=%s)\",\n-               region_to_str(tcx, r_sub),\n-               region_to_str(tcx, r_sup));\n+               region_to_str(tcx, \"\", false, r_sub),\n+               region_to_str(tcx, \"\", false, r_sup));\n \n         if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type."}, {"sha": "54b449eeb40f2aeecfa91d113fb36eedbce46fe0", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -149,7 +149,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                     tcx.sess.bug(\n                         fmt!(\"Bound region not found in \\\n                               in_scope_regions list: %s\",\n-                             region_to_str(tcx, r)));\n+                             region_to_str(tcx, \"\", false, r)));\n                   }\n                 }\n               }"}, {"sha": "2e83acfa9f4b16f92173de18aecb3fb930e44374", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -821,7 +821,7 @@ impl InferCtxt {\n                 // debug message.\n                 let rvar = self.next_region_var_nb(span);\n                 debug!(\"Bound region %s maps to %?\",\n-                       bound_region_to_str(self.tcx, br),\n+                       bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n             });"}, {"sha": "c5e0e2c8f016d7bfb9865e4a2ef560ff0b002fa6", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -179,7 +179,7 @@ impl Combine for Sub {\n                                               None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region %s skolemized to %?\",\n-                       bound_region_to_str(self.infcx.tcx, br),\n+                       bound_region_to_str(self.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             }"}, {"sha": "8994c81bfb967ad40429ade9a138888073ebd074", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -112,7 +112,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                                idx + 1),\n           br_fresh(_) => fmt!(\"an anonymous lifetime defined on\"),\n           _ => fmt!(\"the lifetime %s as defined on\",\n-                    bound_region_to_str(cx, fr.bound_region))\n+                    bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n         match cx.items.find(&fr.scope_id) {\n@@ -147,22 +147,23 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n-    bound_region_to_str_space(cx, \"&\", br)\n+pub fn bound_region_ptr_to_str(cx: ctxt, br: bound_region) -> ~str {\n+    bound_region_to_str(cx, \"&\", true, br)\n }\n \n-pub fn bound_region_to_str_space(cx: ctxt,\n-                                 prefix: &str,\n-                                 br: bound_region)\n-                              -> ~str {\n-    if cx.sess.verbose() { return fmt!(\"%s%? \", prefix, br); }\n+pub fn bound_region_to_str(cx: ctxt,\n+                           prefix: &str, space: bool,\n+                           br: bound_region) -> ~str {\n+    let space_str = if space { \" \" } else { \"\" };\n+\n+    if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, space_str); }\n \n     match br {\n-      br_named(id)         => fmt!(\"%s'%s \", prefix, cx.sess.str_of(id)),\n-      br_self              => fmt!(\"%s'self \", prefix),\n+      br_named(id)         => fmt!(\"%s'%s%s\", prefix, cx.sess.str_of(id), space_str),\n+      br_self              => fmt!(\"%s'self%s\", prefix, space_str),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n-      br_cap_avoid(_, br)  => bound_region_to_str_space(cx, prefix, *br)\n+      br_cap_avoid(_, br)  => bound_region_to_str(cx, prefix, space, *br)\n     }\n }\n \n@@ -208,13 +209,15 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-pub fn region_to_str(cx: ctxt, region: Region) -> ~str {\n-    region_to_str_space(cx, \"&\", region)\n+pub fn region_ptr_to_str(cx: ctxt, region: Region) -> ~str {\n+    region_to_str(cx, \"&\", true, region)\n }\n \n-pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n+pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~str {\n+    let space_str = if space { \" \" } else { \"\" };\n+\n     if cx.sess.verbose() {\n-        return fmt!(\"%s%? \", prefix, region);\n+        return fmt!(\"%s%?%s\", prefix, region, space_str);\n     }\n \n     // These printouts are concise.  They do not contain all the information\n@@ -223,14 +226,14 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n         re_scope(_) => prefix.to_str(),\n-        re_bound(br) => bound_region_to_str_space(cx, prefix, br),\n-        re_free(ref fr) => bound_region_to_str_space(cx, prefix, fr.bound_region),\n+        re_bound(br) => bound_region_to_str(cx, prefix, space, br),\n+        re_free(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n         re_infer(ReSkolemized(_, br)) => {\n-            bound_region_to_str_space(cx, prefix, br)\n+            bound_region_to_str(cx, prefix, space, br)\n         }\n         re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => fmt!(\"%s'static \", prefix),\n-        re_empty => fmt!(\"%s'<empty> \", prefix)\n+        re_static => fmt!(\"%s'static%s\", prefix, space_str),\n+        re_empty => fmt!(\"%s'<empty>%s\", prefix, space_str)\n     }\n }\n \n@@ -256,15 +259,15 @@ pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n       ty::vstore_fixed(n) => fmt!(\"%u\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_box => ~\"@\",\n-      ty::vstore_slice(r) => region_to_str_space(cx, \"&\", r)\n+      ty::vstore_slice(r) => region_ptr_to_str(cx, r)\n     }\n }\n \n pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n       ty::UniqTraitStore => ~\"~\",\n       ty::BoxTraitStore => ~\"@\",\n-      ty::RegionTraitStore(r) => region_to_str_space(cx, \"&\", r)\n+      ty::RegionTraitStore(r) => region_ptr_to_str(cx, r)\n     }\n }\n \n@@ -340,7 +343,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n             (ast::OwnedSigil, ty::re_static) => {}\n \n             (_, region) => {\n-                s.push_str(region_to_str_space(cx, \"\", region));\n+                s.push_str(region_to_str(cx, \"\", true, region));\n             }\n         }\n \n@@ -414,7 +417,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),\n       ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n       ty_rptr(r, ref tm) => {\n-        region_to_str_space(cx, \"&\", r) + mt_to_str(cx, tm)\n+        region_ptr_to_str(cx, r) + mt_to_str(cx, tm)\n       }\n       ty_unboxed_vec(ref tm) => { fmt!(\"unboxed_vec<%s>\", mt_to_str(cx, tm)) }\n       ty_type => ~\"type\",\n@@ -431,13 +434,15 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n       ty_param(param_ty {idx: id, def_id: did}) => {\n+          let mut parm = (('T' as uint) + id) as char;\n+          if (parm as uint) > ('Z' as uint) {\n+              parm = (parm as uint - 26) as char;\n+          }\n+\n           if cx.sess.verbose() {\n-              fmt!(\"'%s:%?\",\n-                   str::from_bytes([('a' as u8) + (id as u8)]),\n-                   did)\n+              fmt!(\"%c:%?\", parm, did)\n           } else {\n-              fmt!(\"'%s\",\n-                   str::from_bytes([('a' as u8) + (id as u8)]))\n+              fmt!(\"%c\", parm)\n           }\n       }\n       ty_self(*) => ~\"Self\",\n@@ -457,9 +462,9 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_box => ~\"@?\",\n-      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"closure&\",\n-      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"closure@\",\n-      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"closure~\",\n+      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n+      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n+      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"~closure\",\n     }\n }\n \n@@ -468,18 +473,20 @@ pub fn parameterized(cx: ctxt,\n                      self_r: Option<ty::Region>,\n                      tps: &[ty::t]) -> ~str {\n \n-    let r_str = match self_r {\n-      None => ~\"\",\n-      Some(r) => {\n-        fmt!(\"/%s\", region_to_str(cx, r))\n-      }\n+    let mut strs = ~[];\n+    match self_r {\n+        None => (),\n+        Some(r) => {\n+            strs.push(region_to_str(cx, \"\", false, r))\n+        }\n     };\n \n-    if tps.len() > 0u {\n-        let strs = vec::map(tps, |t| ty_to_str(cx, *t));\n-        fmt!(\"%s%s<%s>\", base, r_str, strs.connect(\",\"))\n+    strs += vec::map(tps, |t| ty_to_str(cx, *t));\n+\n+    if strs.len() > 0u {\n+        fmt!(\"%s<%s>\", base, strs.connect(\",\"))\n     } else {\n-        fmt!(\"%s%s\", base, r_str)\n+        fmt!(\"%s\", base)\n     }\n }\n \n@@ -597,7 +604,7 @@ impl Repr for @ast::pat {\n \n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        region_to_str(tcx, *self)\n+        region_to_str(tcx, \"\", false, *self)\n     }\n }\n "}, {"sha": "c38b013a75aa3f11b15d098c02a949fbf94333c3", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -42,36 +42,148 @@ pub extern \"rust-intrinsic\" {\n     /// Atomic compare and exchange, release ordering.\n     pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_acqrel(dst: &mut int, old: int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_relaxed(dst: &mut int, old: int, src: int) -> int;\n+\n+\n     /// Atomic load, sequentially consistent.\n     pub fn atomic_load(src: &int) -> int;\n     /// Atomic load, acquire ordering.\n     pub fn atomic_load_acq(src: &int) -> int;\n \n+    #[cfg(not(stage0))]\n+    pub fn atomic_load_relaxed(src: &int) -> int;\n+\n     /// Atomic store, sequentially consistent.\n     pub fn atomic_store(dst: &mut int, val: int);\n     /// Atomic store, release ordering.\n     pub fn atomic_store_rel(dst: &mut int, val: int);\n \n+    #[cfg(not(stage0))]\n+    pub fn atomic_store_relaxed(dst: &mut int, val: int);\n+\n     /// Atomic exchange, sequentially consistent.\n     pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n     /// Atomic exchange, acquire ordering.\n     pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n     /// Atomic exchange, release ordering.\n     pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xchg_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xchg_relaxed(dst: &mut int, src: int) -> int;\n \n     /// Atomic addition, sequentially consistent.\n     pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n     /// Atomic addition, acquire ordering.\n     pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n     /// Atomic addition, release ordering.\n     pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xadd_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xadd_relaxed(dst: &mut int, src: int) -> int;\n \n     /// Atomic subtraction, sequentially consistent.\n     pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n     /// Atomic subtraction, acquire ordering.\n     pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n     /// Atomic subtraction, release ordering.\n     pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xsub_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xsub_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umax(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umax_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umax_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umax_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umax_relaxed(dst: &mut int, src: int) -> int;\n \n     /// The size of a type in bytes.\n     ///"}, {"sha": "35ba386243807db7dac24cf279560739362c0cd5", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4560dc26498573516d833cb2333b54071070e3/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4560dc26498573516d833cb2333b54071070e3/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=dc4560dc26498573516d833cb2333b54071070e3", "patch": "@@ -16,11 +16,11 @@ struct an_enum<'self>(&'self int);\n struct a_class<'self> { x:&'self int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n-    return e; //~ ERROR mismatched types: expected `an_enum/&'b ` but found `an_enum/&'a `\n+    return e; //~ ERROR mismatched types: expected `an_enum<'b>` but found `an_enum<'a>`\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n-    return e; //~ ERROR mismatched types: expected `a_class/&'b ` but found `a_class/&'a `\n+    return e; //~ ERROR mismatched types: expected `a_class<'b>` but found `a_class<'a>`\n }\n \n fn a_fn4<'a,'b>() {"}]}