{"sha": "3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMmQyM2IyY2RjMjcwNzE1ZjU1OWQ3ZmMwY2ZlNDAxOTAxMWE3ZGU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-22T00:27:34Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-22T00:39:06Z"}, "message": "Move a bunch of trans into trans_common, including the context structures.\n\nProbably more should be moved or split off into other files. My algorithm\nwas something along the lines of: move the contexts and their transitive\ndependencies along with some functions to work with them. I stopped when\nI was going to have to start pulling glue generation, which really\nshould go into a trans_glue file.", "tree": {"sha": "5ec2a309947dcd2eccb1ec4cd9f0dda96c583ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ec2a309947dcd2eccb1ec4cd9f0dda96c583ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "html_url": "https://github.com/rust-lang/rust/commit/3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8bb5a3b580da660e2f55f0701a06798581c56ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8bb5a3b580da660e2f55f0701a06798581c56ae", "html_url": "https://github.com/rust-lang/rust/commit/f8bb5a3b580da660e2f55f0701a06798581c56ae"}], "stats": {"total": 757, "additions": 369, "deletions": 388}, "files": [{"sha": "2b61ca6078e5be4d0b667662c7503bf5395fe6d6", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -2,9 +2,9 @@\n import driver::session;\n import lib::llvm::llvm;\n import front::attr;\n-import middle::trans;\n import middle::ty;\n import metadata::encoder;\n+import middle::trans_common::crate_ctxt;\n import std::str;\n import std::fs;\n import std::ivec;\n@@ -13,7 +13,6 @@ import option::some;\n import option::none;\n import std::sha1::sha1;\n import std::sort;\n-import trans::crate_ctxt;\n import syntax::ast;\n import syntax::print::pprust;\n import lib::llvm::llvm::ModuleRef;"}, {"sha": "2896fa57ddffb19b911a671c505641bdea0424ae", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -11,7 +11,7 @@ import std::ebmlivec;\n import std::map;\n import syntax::ast::*;\n import common::*;\n-import middle::trans::crate_ctxt;\n+import middle::trans_common::crate_ctxt;\n import middle::ty;\n import middle::ty::node_id_to_monotype;\n import front::attr;"}, {"sha": "c6b9009288150510dd62ba5aed8052b92a54a4f7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 348, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -75,341 +75,6 @@ import trans_comm::trans_spawn;\n import trans_comm::trans_send;\n import trans_comm::trans_recv;\n \n-obj namegen(mutable int i) {\n-    fn next(str prefix) -> str { i += 1; ret prefix + int::str(i); }\n-}\n-\n-type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n-\n-type glue_fns = rec(ValueRef no_op_type_glue);\n-\n-type tydesc_info =\n-    rec(ty::t ty,\n-        ValueRef tydesc,\n-        ValueRef size,\n-        ValueRef align,\n-        mutable option::t[ValueRef] copy_glue,\n-        mutable option::t[ValueRef] drop_glue,\n-        mutable option::t[ValueRef] free_glue,\n-        mutable option::t[ValueRef] cmp_glue,\n-        uint[] ty_params);\n-\n-\n-/*\n- * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n- *\n- * An \"extern\" is an LLVM symbol we wind up emitting an undefined external\n- * reference to. This means \"we don't have the thing in this compilation unit,\n- * please make sure you link it in at runtime\". This could be a reference to\n- * C code found in a C library, or rust code found in a rust crate.\n- *\n- * A \"native\" is an extern that references C code. Called with cdecl.\n- *\n- * An upcall is a native call generated by the compiler (not corresponding to\n- * any user-written call in the code) into librustrt, to perform some helper\n- * task such as bringing a task to life, allocating memory, etc.\n- *\n- */\n-type stats =\n-    rec(mutable uint n_static_tydescs,\n-        mutable uint n_derived_tydescs,\n-        mutable uint n_glues_created,\n-        mutable uint n_null_glues,\n-        mutable uint n_real_glues,\n-        @mutable (tup(str,int)[]) fn_times);\n-\n-\n-// Crate context.  Every crate we compile has one of these.\n-type crate_ctxt =\n-    rec(session::session sess,\n-        ModuleRef llmod,\n-        target_data td,\n-        type_names tn,\n-        hashmap[str, ValueRef] externs,\n-        hashmap[str, ValueRef] intrinsics,\n-\n-        // A mapping from the def_id of each item in this crate to the address\n-        // of the first instruction of the item's definition in the executable\n-        // we're generating.\n-        hashmap[ast::node_id, ValueRef] item_ids,\n-        ast_map::map ast_map,\n-        hashmap[ast::node_id, str] item_symbols,\n-        mutable option::t[ValueRef] main_fn,\n-        link::link_meta link_meta,\n-\n-        // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n-        hashmap[ty::t, uint] tag_sizes,\n-        hashmap[ast::node_id, ValueRef] discrims,\n-        hashmap[ast::node_id, str] discrim_symbols,\n-        hashmap[ast::node_id, ValueRef] fn_pairs,\n-        hashmap[ast::node_id, ValueRef] consts,\n-        hashmap[ast::node_id, ()] obj_methods,\n-        hashmap[ty::t, @tydesc_info] tydescs,\n-        hashmap[str, ValueRef] module_data,\n-        hashmap[ty::t, TypeRef] lltypes,\n-        @glue_fns glues,\n-        namegen names,\n-        std::sha1::sha1 sha,\n-        hashmap[ty::t, str] type_sha1s,\n-        hashmap[ty::t, str] type_short_names,\n-        ty::ctxt tcx,\n-        stats stats,\n-        @upcall::upcalls upcalls,\n-        TypeRef rust_object_type,\n-        TypeRef tydesc_type,\n-        TypeRef task_type);\n-\n-type local_ctxt =\n-    rec(str[] path,\n-        str[] module_path,\n-        ast::ty_param[] obj_typarams,\n-        ast::obj_field[] obj_fields,\n-        @crate_ctxt ccx);\n-\n-\n-// Types used for llself.\n-type val_self_pair = rec(ValueRef v, ty::t t);\n-\n-\n-// Function context.  Every LLVM function we create will have one of these.\n-type fn_ctxt =\n-    rec(\n-        // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-        // address of the first instruction in the sequence of instructions\n-        // for this function that will go in the .text section of the\n-        // executable we're generating.\n-        ValueRef llfn,\n-\n-        // The three implicit arguments that arrive in the function we're\n-        // creating.  For instance, foo(int, int) is really foo(ret*, task*,\n-        // env*, int, int).  These are also available via\n-        // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0 respectively,\n-        // but we unpack them into these fields for convenience.\n-\n-        // Points to the current task.\n-        ValueRef lltaskptr,\n-\n-        // Points to the current environment (bindings of variables to\n-        // values), if this is a regular function; points to the current\n-        // object, if this is a method.\n-        ValueRef llenv,\n-\n-        // Points to where the return value of this function should end up.\n-        ValueRef llretptr,\n-\n-        // The next three elements: \"hoisted basic blocks\" containing\n-        // administrative activities that have to happen in only one place in\n-        // the function, due to LLVM's quirks.\n-\n-        // A block for all the function's static allocas, so that LLVM will\n-        // coalesce them into a single alloca call.\n-        mutable BasicBlockRef llstaticallocas,\n-\n-        // A block containing code that copies incoming arguments to space\n-        // already allocated by code in one of the llallocas blocks.  (LLVM\n-        // requires that arguments be copied to local allocas before allowing\n-        // most any operation to be performed on them.)\n-        mutable BasicBlockRef llcopyargs,\n-\n-        // The first block containing derived tydescs received from the\n-        // runtime.  See description of derived_tydescs, below.\n-        mutable BasicBlockRef llderivedtydescs_first,\n-\n-        // The last block of the llderivedtydescs group.\n-        mutable BasicBlockRef llderivedtydescs,\n-\n-        // A block for all of the dynamically sized allocas.  This must be\n-        // after llderivedtydescs, because these sometimes depend on\n-        // information computed from derived tydescs.\n-        mutable BasicBlockRef lldynamicallocas,\n-\n-        // FIXME: Is llcopyargs actually the block containing the allocas for\n-        // incoming function arguments?  Or is it merely the block containing\n-        // code that copies incoming args to space already alloca'd by code in\n-        // llallocas?\n-\n-        // The 'self' object currently in use in this function, if there is\n-        // one.\n-        mutable option::t[val_self_pair] llself,\n-\n-        // If this function is actually a iter, a block containing the code\n-        // called whenever the iter calls 'put'.\n-        mutable option::t[ValueRef] lliterbody,\n-\n-        // The next four items: hash tables mapping from AST def_ids to\n-        // LLVM-stuff-in-the-frame.\n-\n-        // Maps arguments to allocas created for them in llallocas.\n-        hashmap[ast::node_id, ValueRef] llargs,\n-\n-        // Maps fields in objects to pointers into the interior of llself's\n-        // body.\n-        hashmap[ast::node_id, ValueRef] llobjfields,\n-\n-        // Maps the def_ids for local variables to the allocas created for\n-        // them in llallocas.\n-        hashmap[ast::node_id, ValueRef] lllocals,\n-\n-        // The same as above, but for variables accessed via the frame pointer\n-        // we pass into an iter, for access to the static environment of the\n-        // iter-calling frame.\n-        hashmap[ast::node_id, ValueRef] llupvars,\n-\n-        // For convenience, a vector of the incoming tydescs for each of this\n-        // functions type parameters, fetched via llvm::LLVMGetParam.  For\n-        // example, for a function foo[A, B, C](), lltydescs contains the\n-        // ValueRefs for the tydescs for A, B, and C.\n-        mutable ValueRef[] lltydescs,\n-\n-        // Derived tydescs are tydescs created at runtime, for types that\n-        // involve type parameters inside type constructors.  For example,\n-        // suppose a function parameterized by T creates a vector of type\n-        // [T].  The function doesn't know what T is until runtime, and the\n-        // function's caller knows T but doesn't know that a vector is\n-        // involved.  So a tydesc for [T] can't be created until runtime,\n-        // when information about both \"[T]\" and \"T\" are available.  When such\n-        // a tydesc is created, we cache it in the derived_tydescs table for\n-        // the next time that such a tydesc is needed.\n-        hashmap[ty::t, derived_tydesc_info] derived_tydescs,\n-\n-        // The source span where this function comes from, for error\n-        // reporting.\n-        span sp,\n-\n-        // This function's enclosing local context.\n-        @local_ctxt lcx);\n-\n-tag cleanup {\n-    clean(fn(&@block_ctxt) -> result);\n-    clean_temp(ValueRef, fn(&@block_ctxt) -> result);\n-}\n-\n-fn add_clean(&@block_ctxt cx, ValueRef val, ty::t ty) {\n-    find_scope_cx(cx).cleanups += ~[clean(bind drop_slot(_, val, ty))];\n-}\n-fn add_clean_temp(&@block_ctxt cx, ValueRef val, ty::t ty) {\n-    find_scope_cx(cx).cleanups += ~[clean_temp(val,\n-                                               bind drop_ty(_, val, ty))];\n-}\n-\n-// Note that this only works for temporaries. We should, at some point, move\n-// to a system where we can also cancel the cleanup on local variables, but\n-// this will be more involved. For now, we simply zero out the local, and the\n-// drop glue checks whether it is zero.\n-fn revoke_clean(&@block_ctxt cx, ValueRef val) {\n-    auto sc_cx = find_scope_cx(cx);\n-    auto found = -1;\n-    auto i = 0;\n-    for (cleanup c in sc_cx.cleanups) {\n-        alt (c) {\n-            case (clean_temp(?v, _)) {\n-                if (v as uint == val as uint) { found = i; break; }\n-            }\n-            case (_) {}\n-        }\n-        i += 1;\n-    }\n-    // The value does not have a cleanup associated with it. Might be a\n-    // constant or some immediate value.\n-    if (found == -1) { ret; }\n-    // We found the cleanup and remove it\n-    sc_cx.cleanups = std::ivec::slice(sc_cx.cleanups, 0u, found as uint) +\n-        std::ivec::slice(sc_cx.cleanups, found as uint + 1u,\n-                         std::ivec::len(sc_cx.cleanups));\n-}\n-\n-tag block_kind {\n-\n-    // A scope block is a basic block created by translating a block { ... }\n-    // the the source language.  Since these blocks create variable scope, any\n-    // variables created in them that are still live at the end of the block\n-    // must be dropped and cleaned up when the block ends.\n-    SCOPE_BLOCK;\n-\n-    // A basic block created from the body of a loop.  Contains pointers to\n-    // which block to jump to in the case of \"continue\" or \"break\", with the\n-    // \"continue\" block optional, because \"while\" and \"do while\" don't support\n-    // \"continue\" (TODO: is this intentional?)\n-    LOOP_SCOPE_BLOCK(option::t[@block_ctxt], @block_ctxt);\n-\n-    // A non-scope block is a basic block created as a translation artifact\n-    // from translating code that expresses conditional logic rather than by\n-    // explicit { ... } block structure in the source language.  It's called a\n-    // non-scope block because it doesn't introduce a new variable scope.\n-    NON_SCOPE_BLOCK;\n-}\n-\n-\n-// Basic block context.  We create a block context for each basic block\n-// (single-entry, single-exit sequence of instructions) we generate from Rust\n-// code.  Each basic block we generate is attached to a function, typically\n-// with many basic blocks per function.  All the basic blocks attached to a\n-// function are organized as a directed graph.\n-type block_ctxt =\n-    rec(\n-        // The BasicBlockRef returned from a call to\n-        // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic block to\n-        // the function pointed to by llfn.  We insert instructions into that\n-        // block by way of this block context.\n-        BasicBlockRef llbb,\n-\n-        // The llvm::builder object serving as an interface to LLVM's\n-        // LLVMBuild* functions.\n-        builder build,\n-\n-        // The block pointing to this one in the function's digraph.\n-        block_parent parent,\n-\n-        // The 'kind' of basic block this is.\n-        block_kind kind,\n-\n-        // A list of functions that run at the end of translating this block,\n-        // cleaning up any variables that were introduced in the block and\n-        // need to go out of scope at the end of it.\n-        mutable cleanup[] cleanups,\n-\n-        // The source span where this block comes from, for error reporting.\n-        span sp,\n-\n-        // The function context for the function to which this block is\n-        // attached.\n-        @fn_ctxt fcx);\n-\n-\n-// FIXME: we should be able to use option::t[@block_parent] here but\n-// the infinite-tag check in rustboot gets upset.\n-tag block_parent { parent_none; parent_some(@block_ctxt); }\n-\n-type result = rec(@block_ctxt bcx, ValueRef val);\n-type result_t = rec(@block_ctxt bcx, ValueRef val, ty::t ty);\n-\n-fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n-    ret @rec(path=cx.path + ~[name] with *cx);\n-}\n-\n-fn rslt(@block_ctxt bcx, ValueRef val) -> result {\n-    ret rec(bcx=bcx, val=val);\n-}\n-\n-fn ty_str(type_names tn, TypeRef t) -> str {\n-    ret lib::llvm::type_to_str(tn, t);\n-}\n-\n-fn val_ty(ValueRef v) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n-\n-fn val_str(type_names tn, ValueRef v) -> str { ret ty_str(tn, val_ty(v)); }\n-\n-\n-// Returns the nth element of the given LLVM structure type.\n-fn struct_elt(TypeRef llstructty, uint n) -> TypeRef {\n-    auto elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n-    assert (n < elt_count);\n-    auto elt_tys = std::ivec::init_elt(T_nil(), elt_count);\n-    llvm::LLVMGetStructElementTypes(llstructty, std::ivec::to_ptr(elt_tys));\n-    ret llvm::LLVMGetElementType(elt_tys.(n));\n-}\n-\n-\n // This function now fails if called on a type with dynamic size (as its\n // return value was always meaningless in that case anyhow). Beware!\n //\n@@ -783,17 +448,6 @@ fn trans_shared_free(&@block_ctxt cx, ValueRef v) -> result {\n     ret rslt(cx, C_int(0));\n }\n \n-fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n-    if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n-    alt (cx.parent) {\n-        case (parent_some(?b)) { ret find_scope_cx(b); }\n-        case (parent_none) {\n-            cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n-                                        \"called on parentless block_ctxt\");\n-        }\n-    }\n-}\n-\n fn umax(&@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n     auto cond = cx.build.ICmp(lib::llvm::LLVMIntULT, a, b);\n     ret cx.build.Select(cond, b, a);\n@@ -8518,12 +8172,12 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n+fn write_metadata(&@crate_ctxt cx, &@ast::crate crate) {\n     if (!cx.sess.get_opts().library) { ret; }\n     auto llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n     auto llconst = trans_common::C_struct(~[llmeta]);\n     auto llglobal =\n-        llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst),\n                             str::buf(\"rust_metadata\"));\n     llvm::LLVMSetInitializer(llglobal, llconst);\n     llvm::LLVMSetSection(llglobal, str::buf(x86::get_meta_sect_name()));"}, {"sha": "fa53c868536feb34eec4ee9f39b5e8a24e4f3b1e", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -9,14 +9,9 @@ import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::llvm::TypeRef;\n import lib::llvm::llvm::BasicBlockRef;\n-import trans::result;\n-import trans::rslt;\n-import trans::crate_ctxt;\n-import trans::block_ctxt;\n import trans::new_sub_block_ctxt;\n import trans::new_scope_block_ctxt;\n import trans::load_if_immediate;\n-import trans::val_ty;\n import ty::pat_ty;\n import syntax::ast;\n import syntax::ast::def_id;"}, {"sha": "9f2014b2a2d65f5e9ecdc07d6c4708ace274ef3d", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 351, "deletions": 3, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -57,9 +57,358 @@ import syntax::print::pprust::expr_to_str;\n import syntax::print::pprust::path_to_str;\n \n // FIXME: These should probably be pulled in here too.\n-import trans::crate_ctxt;\n import trans::type_of_fn_full;\n-import trans::val_ty;\n+import trans::drop_slot;\n+import trans::drop_ty;\n+\n+obj namegen(mutable int i) {\n+    fn next(str prefix) -> str { i += 1; ret prefix + int::str(i); }\n+}\n+\n+type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n+\n+type glue_fns = rec(ValueRef no_op_type_glue);\n+\n+type tydesc_info =\n+    rec(ty::t ty,\n+        ValueRef tydesc,\n+        ValueRef size,\n+        ValueRef align,\n+        mutable option::t[ValueRef] copy_glue,\n+        mutable option::t[ValueRef] drop_glue,\n+        mutable option::t[ValueRef] free_glue,\n+        mutable option::t[ValueRef] cmp_glue,\n+        uint[] ty_params);\n+\n+/*\n+ * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n+ *\n+ * An \"extern\" is an LLVM symbol we wind up emitting an undefined external\n+ * reference to. This means \"we don't have the thing in this compilation unit,\n+ * please make sure you link it in at runtime\". This could be a reference to\n+ * C code found in a C library, or rust code found in a rust crate.\n+ *\n+ * A \"native\" is an extern that references C code. Called with cdecl.\n+ *\n+ * An upcall is a native call generated by the compiler (not corresponding to\n+ * any user-written call in the code) into librustrt, to perform some helper\n+ * task such as bringing a task to life, allocating memory, etc.\n+ *\n+ */\n+type stats =\n+    rec(mutable uint n_static_tydescs,\n+        mutable uint n_derived_tydescs,\n+        mutable uint n_glues_created,\n+        mutable uint n_null_glues,\n+        mutable uint n_real_glues,\n+        @mutable (tup(str,int)[]) fn_times);\n+\n+// Crate context.  Every crate we compile has one of these.\n+type crate_ctxt =\n+    rec(session::session sess,\n+        ModuleRef llmod,\n+        target_data td,\n+        type_names tn,\n+        hashmap[str, ValueRef] externs,\n+        hashmap[str, ValueRef] intrinsics,\n+\n+        // A mapping from the def_id of each item in this crate to the address\n+        // of the first instruction of the item's definition in the executable\n+        // we're generating.\n+        hashmap[ast::node_id, ValueRef] item_ids,\n+        ast_map::map ast_map,\n+        hashmap[ast::node_id, str] item_symbols,\n+        mutable option::t[ValueRef] main_fn,\n+        link::link_meta link_meta,\n+\n+        // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n+        hashmap[ty::t, uint] tag_sizes,\n+        hashmap[ast::node_id, ValueRef] discrims,\n+        hashmap[ast::node_id, str] discrim_symbols,\n+        hashmap[ast::node_id, ValueRef] fn_pairs,\n+        hashmap[ast::node_id, ValueRef] consts,\n+        hashmap[ast::node_id, ()] obj_methods,\n+        hashmap[ty::t, @tydesc_info] tydescs,\n+        hashmap[str, ValueRef] module_data,\n+        hashmap[ty::t, TypeRef] lltypes,\n+        @glue_fns glues,\n+        namegen names,\n+        std::sha1::sha1 sha,\n+        hashmap[ty::t, str] type_sha1s,\n+        hashmap[ty::t, str] type_short_names,\n+        ty::ctxt tcx,\n+        stats stats,\n+        @upcall::upcalls upcalls,\n+        TypeRef rust_object_type,\n+        TypeRef tydesc_type,\n+        TypeRef task_type);\n+\n+type local_ctxt =\n+    rec(str[] path,\n+        str[] module_path,\n+        ast::ty_param[] obj_typarams,\n+        ast::obj_field[] obj_fields,\n+        @crate_ctxt ccx);\n+\n+// Types used for llself.\n+type val_self_pair = rec(ValueRef v, ty::t t);\n+\n+// Function context.  Every LLVM function we create will have one of these.\n+type fn_ctxt =\n+    rec(\n+        // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n+        // address of the first instruction in the sequence of instructions\n+        // for this function that will go in the .text section of the\n+        // executable we're generating.\n+        ValueRef llfn,\n+\n+        // The three implicit arguments that arrive in the function we're\n+        // creating.  For instance, foo(int, int) is really foo(ret*, task*,\n+        // env*, int, int).  These are also available via\n+        // llvm::LLVMGetParam(llfn, uint) where uint = 1, 2, 0 respectively,\n+        // but we unpack them into these fields for convenience.\n+\n+        // Points to the current task.\n+        ValueRef lltaskptr,\n+\n+        // Points to the current environment (bindings of variables to\n+        // values), if this is a regular function; points to the current\n+        // object, if this is a method.\n+        ValueRef llenv,\n+\n+        // Points to where the return value of this function should end up.\n+        ValueRef llretptr,\n+\n+        // The next three elements: \"hoisted basic blocks\" containing\n+        // administrative activities that have to happen in only one place in\n+        // the function, due to LLVM's quirks.\n+\n+        // A block for all the function's static allocas, so that LLVM will\n+        // coalesce them into a single alloca call.\n+        mutable BasicBlockRef llstaticallocas,\n+\n+        // A block containing code that copies incoming arguments to space\n+        // already allocated by code in one of the llallocas blocks.  (LLVM\n+        // requires that arguments be copied to local allocas before allowing\n+        // most any operation to be performed on them.)\n+        mutable BasicBlockRef llcopyargs,\n+\n+        // The first block containing derived tydescs received from the\n+        // runtime.  See description of derived_tydescs, below.\n+        mutable BasicBlockRef llderivedtydescs_first,\n+\n+        // The last block of the llderivedtydescs group.\n+        mutable BasicBlockRef llderivedtydescs,\n+\n+        // A block for all of the dynamically sized allocas.  This must be\n+        // after llderivedtydescs, because these sometimes depend on\n+        // information computed from derived tydescs.\n+        mutable BasicBlockRef lldynamicallocas,\n+\n+        // FIXME: Is llcopyargs actually the block containing the allocas for\n+        // incoming function arguments?  Or is it merely the block containing\n+        // code that copies incoming args to space already alloca'd by code in\n+        // llallocas?\n+\n+        // The 'self' object currently in use in this function, if there is\n+        // one.\n+        mutable option::t[val_self_pair] llself,\n+\n+        // If this function is actually a iter, a block containing the code\n+        // called whenever the iter calls 'put'.\n+        mutable option::t[ValueRef] lliterbody,\n+\n+        // The next four items: hash tables mapping from AST def_ids to\n+        // LLVM-stuff-in-the-frame.\n+\n+        // Maps arguments to allocas created for them in llallocas.\n+        hashmap[ast::node_id, ValueRef] llargs,\n+\n+        // Maps fields in objects to pointers into the interior of llself's\n+        // body.\n+        hashmap[ast::node_id, ValueRef] llobjfields,\n+\n+        // Maps the def_ids for local variables to the allocas created for\n+        // them in llallocas.\n+        hashmap[ast::node_id, ValueRef] lllocals,\n+\n+        // The same as above, but for variables accessed via the frame pointer\n+        // we pass into an iter, for access to the static environment of the\n+        // iter-calling frame.\n+        hashmap[ast::node_id, ValueRef] llupvars,\n+\n+        // For convenience, a vector of the incoming tydescs for each of this\n+        // functions type parameters, fetched via llvm::LLVMGetParam.  For\n+        // example, for a function foo[A, B, C](), lltydescs contains the\n+        // ValueRefs for the tydescs for A, B, and C.\n+        mutable ValueRef[] lltydescs,\n+\n+        // Derived tydescs are tydescs created at runtime, for types that\n+        // involve type parameters inside type constructors.  For example,\n+        // suppose a function parameterized by T creates a vector of type\n+        // [T].  The function doesn't know what T is until runtime, and the\n+        // function's caller knows T but doesn't know that a vector is\n+        // involved.  So a tydesc for [T] can't be created until runtime,\n+        // when information about both \"[T]\" and \"T\" are available.  When such\n+        // a tydesc is created, we cache it in the derived_tydescs table for\n+        // the next time that such a tydesc is needed.\n+        hashmap[ty::t, derived_tydesc_info] derived_tydescs,\n+\n+        // The source span where this function comes from, for error\n+        // reporting.\n+        span sp,\n+\n+        // This function's enclosing local context.\n+        @local_ctxt lcx);\n+\n+tag cleanup {\n+    clean(fn(&@block_ctxt) -> result);\n+    clean_temp(ValueRef, fn(&@block_ctxt) -> result);\n+}\n+\n+fn add_clean(&@block_ctxt cx, ValueRef val, ty::t ty) {\n+    find_scope_cx(cx).cleanups += ~[clean(bind drop_slot(_, val, ty))];\n+}\n+fn add_clean_temp(&@block_ctxt cx, ValueRef val, ty::t ty) {\n+    find_scope_cx(cx).cleanups += ~[clean_temp(val,\n+                                               bind drop_ty(_, val, ty))];\n+}\n+\n+// Note that this only works for temporaries. We should, at some point, move\n+// to a system where we can also cancel the cleanup on local variables, but\n+// this will be more involved. For now, we simply zero out the local, and the\n+// drop glue checks whether it is zero.\n+fn revoke_clean(&@block_ctxt cx, ValueRef val) {\n+    auto sc_cx = find_scope_cx(cx);\n+    auto found = -1;\n+    auto i = 0;\n+    for (cleanup c in sc_cx.cleanups) {\n+        alt (c) {\n+            case (clean_temp(?v, _)) {\n+                if (v as uint == val as uint) { found = i; break; }\n+            }\n+            case (_) {}\n+        }\n+        i += 1;\n+    }\n+    // The value does not have a cleanup associated with it. Might be a\n+    // constant or some immediate value.\n+    if (found == -1) { ret; }\n+    // We found the cleanup and remove it\n+    sc_cx.cleanups = std::ivec::slice(sc_cx.cleanups, 0u, found as uint) +\n+        std::ivec::slice(sc_cx.cleanups, found as uint + 1u,\n+                         std::ivec::len(sc_cx.cleanups));\n+}\n+\n+tag block_kind {\n+\n+    // A scope block is a basic block created by translating a block { ... }\n+    // the the source language.  Since these blocks create variable scope, any\n+    // variables created in them that are still live at the end of the block\n+    // must be dropped and cleaned up when the block ends.\n+    SCOPE_BLOCK;\n+\n+    // A basic block created from the body of a loop.  Contains pointers to\n+    // which block to jump to in the case of \"continue\" or \"break\", with the\n+    // \"continue\" block optional, because \"while\" and \"do while\" don't support\n+    // \"continue\" (TODO: is this intentional?)\n+    LOOP_SCOPE_BLOCK(option::t[@block_ctxt], @block_ctxt);\n+\n+    // A non-scope block is a basic block created as a translation artifact\n+    // from translating code that expresses conditional logic rather than by\n+    // explicit { ... } block structure in the source language.  It's called a\n+    // non-scope block because it doesn't introduce a new variable scope.\n+    NON_SCOPE_BLOCK;\n+}\n+\n+\n+// Basic block context.  We create a block context for each basic block\n+// (single-entry, single-exit sequence of instructions) we generate from Rust\n+// code.  Each basic block we generate is attached to a function, typically\n+// with many basic blocks per function.  All the basic blocks attached to a\n+// function are organized as a directed graph.\n+type block_ctxt =\n+    rec(\n+        // The BasicBlockRef returned from a call to\n+        // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic block to\n+        // the function pointed to by llfn.  We insert instructions into that\n+        // block by way of this block context.\n+        BasicBlockRef llbb,\n+\n+        // The llvm::builder object serving as an interface to LLVM's\n+        // LLVMBuild* functions.\n+        builder build,\n+\n+        // The block pointing to this one in the function's digraph.\n+        block_parent parent,\n+\n+        // The 'kind' of basic block this is.\n+        block_kind kind,\n+\n+        // A list of functions that run at the end of translating this block,\n+        // cleaning up any variables that were introduced in the block and\n+        // need to go out of scope at the end of it.\n+        mutable cleanup[] cleanups,\n+\n+        // The source span where this block comes from, for error reporting.\n+        span sp,\n+\n+        // The function context for the function to which this block is\n+        // attached.\n+        @fn_ctxt fcx);\n+\n+// FIXME: we should be able to use option::t[@block_parent] here but\n+// the infinite-tag check in rustboot gets upset.\n+tag block_parent { parent_none; parent_some(@block_ctxt); }\n+\n+type result = rec(@block_ctxt bcx, ValueRef val);\n+type result_t = rec(@block_ctxt bcx, ValueRef val, ty::t ty);\n+\n+fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n+    ret @rec(path=cx.path + ~[name] with *cx);\n+}\n+\n+fn rslt(@block_ctxt bcx, ValueRef val) -> result {\n+    ret rec(bcx=bcx, val=val);\n+}\n+\n+fn ty_str(type_names tn, TypeRef t) -> str {\n+    ret lib::llvm::type_to_str(tn, t);\n+}\n+\n+fn val_ty(ValueRef v) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n+\n+fn val_str(type_names tn, ValueRef v) -> str { ret ty_str(tn, val_ty(v)); }\n+\n+// Returns the nth element of the given LLVM structure type.\n+fn struct_elt(TypeRef llstructty, uint n) -> TypeRef {\n+    auto elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n+    assert (n < elt_count);\n+    auto elt_tys = std::ivec::init_elt(T_nil(), elt_count);\n+    llvm::LLVMGetStructElementTypes(llstructty, std::ivec::to_ptr(elt_tys));\n+    ret llvm::LLVMGetElementType(elt_tys.(n));\n+}\n+\n+fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n+    if (cx.kind != NON_SCOPE_BLOCK) { ret cx; }\n+    alt (cx.parent) {\n+        case (parent_some(?b)) { ret find_scope_cx(b); }\n+        case (parent_none) {\n+            cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n+                                        \"called on parentless block_ctxt\");\n+        }\n+    }\n+}\n+\n+// Accessors\n+// TODO: When we have overloading, simplify these names!\n+\n+fn bcx_tcx(&@block_ctxt bcx) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n+fn bcx_ccx(&@block_ctxt bcx) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n+fn bcx_lcx(&@block_ctxt bcx) -> @local_ctxt { ret bcx.fcx.lcx; }\n+fn bcx_fcx(&@block_ctxt bcx) -> @fn_ctxt { ret bcx.fcx; }\n+fn lcx_ccx(&@local_ctxt lcx) -> @crate_ctxt { ret lcx.ccx; }\n+fn ccx_tcx(&@crate_ctxt ccx) -> ty::ctxt { ret ccx.tcx; }\n \n // LLVM type constructors.\n fn T_void() -> TypeRef {\n@@ -484,4 +833,3 @@ fn C_array(TypeRef ty, &ValueRef[] elts) -> ValueRef {\n     ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n                              std::ivec::len(elts));\n }\n-"}, {"sha": "f3d74ec4d3aae611cb11e9af52834e82daa09663", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -6,16 +6,12 @@ import back::link;\n import lib::llvm::llvm;\n import llvm::TypeRef;\n import llvm::ValueRef;\n-import middle::trans;\n+import middle::trans_common;\n import middle::ty;\n import syntax::ast;\n import syntax::codemap::span;\n-import trans::block_ctxt;\n-import trans::crate_ctxt;\n-import trans::fn_ctxt;\n-import trans::local_ctxt;\n import util::ppaux;\n-\n+import trans_common::*;\n import std::ivec;\n import std::option::none;\n import std::option::some;\n@@ -25,7 +21,7 @@ import std::uint;\n import LLFalse = lib::llvm::False;\n import LLTrue = lib::llvm::True;\n import ll = lib::llvm;\n-import lltype_of = trans::val_ty;\n+import lltype_of = trans_common::val_ty;\n import option = std::option::t;\n import tc = trans_common;\n import type_of_node = trans::node_id_type;\n@@ -47,7 +43,7 @@ fn llsize_of(&@crate_ctxt ccx, TypeRef llty) -> uint {\n \n fn mk_const(&@crate_ctxt ccx, &str name, bool exported, ValueRef llval)\n         -> ValueRef {\n-    auto llglobal = llvm::LLVMAddGlobal(ccx.llmod, trans::val_ty(llval),\n+    auto llglobal = llvm::LLVMAddGlobal(ccx.llmod, tc::val_ty(llval),\n                                         str::buf(name));\n \n     llvm::LLVMSetInitializer(llglobal, llval);\n@@ -140,23 +136,12 @@ fn dest_is_alias(&dest dest) -> bool {\n }\n \n \n-// Accessors\n-// TODO: When we have overloading, simplify these names!\n-\n-fn bcx_tcx(&@block_ctxt bcx) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n-fn bcx_ccx(&@block_ctxt bcx) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n-fn bcx_lcx(&@block_ctxt bcx) -> @local_ctxt { ret bcx.fcx.lcx; }\n-fn bcx_fcx(&@block_ctxt bcx) -> @fn_ctxt { ret bcx.fcx; }\n-fn lcx_ccx(&@local_ctxt lcx) -> @crate_ctxt { ret lcx.ccx; }\n-fn ccx_tcx(&@crate_ctxt ccx) -> ty::ctxt { ret ccx.tcx; }\n-\n-\n // Common operations\n \n fn memmove(&@block_ctxt bcx, ValueRef lldestptr, ValueRef llsrcptr,\n            ValueRef llsz) {\n-    auto lldestty = llelement_type(trans::val_ty(lldestptr));\n-    auto llsrcty = llelement_type(trans::val_ty(llsrcptr));\n+    auto lldestty = llelement_type(tc::val_ty(lldestptr));\n+    auto llsrcty = llelement_type(tc::val_ty(llsrcptr));\n     auto dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n     auto src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n     auto align = uint::min(dest_align, src_align);\n@@ -205,7 +190,7 @@ fn store_ptr(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n         *box = some(llsrcptr);\n       }\n       dst_copy(?lldestptr) | dst_move(?lldestptr) {\n-        auto llsrcty = llelement_type(trans::val_ty(llsrcptr));\n+        auto llsrcty = llelement_type(tc::val_ty(llsrcptr));\n         auto llsz = tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty));\n         memmove(bcx, lldestptr, llsrcptr, llsz);\n         ret bcx;\n@@ -421,7 +406,7 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n                        ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llarg]);\n \n     log_bcx = trans::trans_block_cleanups(log_bcx,\n-                                          trans::find_scope_cx(log_bcx));\n+                                          tc::find_scope_cx(log_bcx));\n     log_bcx.build.Br(next_bcx.llbb);\n     ret next_bcx;\n }\n@@ -481,7 +466,7 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::block block)\n       none { /* no-op */ }\n     }\n \n-    bcx = trans::trans_block_cleanups(bcx, trans::find_scope_cx(bcx));\n+    bcx = trans::trans_block_cleanups(bcx, tc::find_scope_cx(bcx));\n     ret bcx;\n }\n \n@@ -583,7 +568,7 @@ fn trans_init_local(&@block_ctxt bcx, &@ast::local local) -> @block_ctxt {\n     auto llptr = bcx_fcx(bcx).lllocals.get(local.node.id);\n \n     auto t = type_of_node(bcx_ccx(bcx), local.node.id);\n-    trans::add_clean(bcx, llptr, t);\n+    tc::add_clean(bcx, llptr, t);\n \n     alt (local.node.init) {\n       some(?init) {"}, {"sha": "1707c085869381caa9958d83407943607a0a30e7", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2d23b2cdc270715f559d7fc0cfe4019011a7de/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=3b2d23b2cdc270715f559d7fc0cfe4019011a7de", "patch": "@@ -10,11 +10,11 @@ import middle::ty;\n import syntax::ast;\n import syntax::codemap::span;\n import trans::alloca;\n-import trans::block_ctxt;\n import trans::load_inbounds;\n import trans::new_sub_block_ctxt;\n-import trans::struct_elt;\n import trans::type_of_or_i8;\n+import trans_common::block_ctxt;\n+import trans_common::struct_elt;\n import trans_common::C_int;\n import trans_common::C_null;\n import trans_common::C_uint;\n@@ -23,8 +23,8 @@ import trans_common::T_ivec_heap;\n import trans_common::T_ivec_heap_part;\n import trans_common::T_opaque_ivec;\n import trans_common::T_ptr;\n-import trans_dps::bcx_ccx;\n-import trans_dps::bcx_tcx;\n+import trans_common::bcx_ccx;\n+import trans_common::bcx_tcx;\n import trans_dps::dest;\n import trans_dps::llsize_of;\n import trans_dps::mk_temp;"}]}