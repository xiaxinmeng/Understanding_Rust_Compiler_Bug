{"sha": "1a0f3a285697b6238793ce3c1353f0d2f0c28938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMGYzYTI4NTY5N2I2MjM4NzkzY2UzYzEzNTNmMGQyZjBjMjg5Mzg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-20T12:00:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: streamline the Print/fmt::Display impls in ppaux and move them to ty::print::pretty.", "tree": {"sha": "a39467816f683397d28685fff5ab8d93c387b033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a39467816f683397d28685fff5ab8d93c387b033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a0f3a285697b6238793ce3c1353f0d2f0c28938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0f3a285697b6238793ce3c1353f0d2f0c28938", "html_url": "https://github.com/rust-lang/rust/commit/1a0f3a285697b6238793ce3c1353f0d2f0c28938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a0f3a285697b6238793ce3c1353f0d2f0c28938/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030cdc972930aa864fe89dd4c5125ba26ebd05ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/030cdc972930aa864fe89dd4c5125ba26ebd05ac", "html_url": "https://github.com/rust-lang/rust/commit/030cdc972930aa864fe89dd4c5125ba26ebd05ac"}], "stats": {"total": 728, "additions": 303, "deletions": 425}, "files": [{"sha": "b6677326227f4e00b365a36b7f53509f240bfa56", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a0f3a285697b6238793ce3c1353f0d2f0c28938/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0f3a285697b6238793ce3c1353f0d2f0c28938/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1a0f3a285697b6238793ce3c1353f0d2f0c28938", "patch": "@@ -135,7 +135,6 @@ pub mod ty;\n pub mod util {\n     pub mod captures;\n     pub mod common;\n-    mod ppaux;\n     pub mod nodemap;\n     pub mod profiling;\n     pub mod bug;"}, {"sha": "85786818a53e80a2712f0f0ca7a24539e6ac9f59", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a0f3a285697b6238793ce3c1353f0d2f0c28938/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0f3a285697b6238793ce3c1353f0d2f0c28938/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=1a0f3a285697b6238793ce3c1353f0d2f0c28938", "patch": "@@ -13,11 +13,8 @@ use std::ops::Deref;\n mod pretty;\n pub use self::pretty::*;\n \n-// FIXME(eddyb) this module uses `pub(crate)` for things used only\n-// from `ppaux` - when that is removed, they can be re-privatized.\n-\n #[derive(Default)]\n-pub(crate) struct PrintConfig {\n+struct PrintConfig {\n     used_region_names: Option<FxHashSet<InternedString>>,\n     region_index: usize,\n     binder_depth: usize,\n@@ -26,7 +23,7 @@ pub(crate) struct PrintConfig {\n pub struct PrintCx<'a, 'gcx, 'tcx, P> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub printer: P,\n-    pub(crate) config: &'a mut PrintConfig,\n+    config: &'a mut PrintConfig,\n }\n \n // HACK(eddyb) this is solely for `self: PrintCx<Self>`, e.g. to\n@@ -51,7 +48,7 @@ impl<'a, 'gcx, 'tcx, P> PrintCx<'a, 'gcx, 'tcx, P> {\n         })\n     }\n \n-    pub(crate) fn with_tls_tcx<R>(printer: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n+    pub fn with_tls_tcx<R>(printer: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n         ty::tls::with(|tcx| PrintCx::with(tcx, printer, f))\n     }\n }"}, {"sha": "f1ab58bc2e247303c52ac864325a93681556d13e", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/1a0f3a285697b6238793ce3c1353f0d2f0c28938/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a0f3a285697b6238793ce3c1353f0d2f0c28938/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=1a0f3a285697b6238793ce3c1353f0d2f0c28938", "patch": "@@ -9,6 +9,7 @@ use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n use crate::mir::interpret::ConstValue;\n use syntax::symbol::{keywords, Symbol};\n \n+use rustc_target::spec::abi::Abi;\n use syntax::symbol::InternedString;\n \n use std::cell::Cell;\n@@ -1357,3 +1358,302 @@ impl<T, P: PrettyPrinter> Print<'tcx, P> for ty::Binder<T>\n         cx.in_binder(self)\n     }\n }\n+\n+pub trait LiftAndPrintToFmt<'tcx> {\n+    fn lift_and_print_to_fmt(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result;\n+}\n+\n+impl<T> LiftAndPrintToFmt<'tcx> for T\n+    where T: ty::Lift<'tcx>,\n+          for<'a, 'b> <T as ty::Lift<'tcx>>::Lifted:\n+            Print<'tcx, FmtPrinter<&'a mut fmt::Formatter<'b>>, Error = fmt::Error>\n+{\n+    fn lift_and_print_to_fmt(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            cx.tcx.lift(self).expect(\"could not lift for printing\").print(cx)?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n+impl LiftAndPrintToFmt<'tcx> for ty::RegionKind {\n+    fn lift_and_print_to_fmt(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            self.print(cx)?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+macro_rules! forward_display_to_print {\n+    (<$($T:ident),*> $ty:ty) => {\n+        impl<$($T),*> fmt::Display for $ty\n+            where Self: for<'a> LiftAndPrintToFmt<'a>\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                ty::tls::with(|tcx| self.lift_and_print_to_fmt(tcx, f))\n+            }\n+        }\n+    };\n+\n+    ($ty:ty) => {\n+        forward_display_to_print!(<> $ty);\n+    };\n+}\n+\n+macro_rules! define_print_and_forward_display {\n+    (($self:ident, $cx:ident): <$($T:ident),*> $ty:ty $print:block) => {\n+        impl<$($T,)* P: PrettyPrinter> Print<'tcx, P> for $ty\n+            where $($T: Print<'tcx, P, Output = P, Error = P::Error>),*\n+        {\n+            type Output = P;\n+            type Error = fmt::Error;\n+            fn print(&$self, $cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+                #[allow(unused_mut)]\n+                let mut $cx = $cx;\n+                define_scoped_cx!($cx);\n+                let _: () = $print;\n+                #[allow(unreachable_code)]\n+                Ok($cx.printer)\n+            }\n+        }\n+\n+        forward_display_to_print!(<$($T),*> $ty);\n+    };\n+\n+    (($self:ident, $cx:ident): $($ty:ty $print:block)+) => {\n+        $(define_print_and_forward_display!(($self, $cx): <> $ty $print);)+\n+    };\n+}\n+\n+forward_display_to_print!(ty::RegionKind);\n+forward_display_to_print!(Ty<'tcx>);\n+forward_display_to_print!(<T> ty::Binder<T>);\n+\n+define_print_and_forward_display! {\n+    (self, cx):\n+\n+    <T, U> ty::OutlivesPredicate<T, U> {\n+        p!(print(self.0), write(\" : \"), print(self.1))\n+    }\n+}\n+\n+define_print_and_forward_display! {\n+    (self, cx):\n+\n+    &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n+        // Generate the main trait ref, including associated types.\n+        let mut first = true;\n+\n+        if let Some(principal) = self.principal() {\n+            let mut resugared_principal = false;\n+\n+            // Special-case `Fn(...) -> ...` and resugar it.\n+            let fn_trait_kind = cx.tcx.lang_items().fn_trait_kind(principal.def_id);\n+            if !cx.tcx.sess.verbose() && fn_trait_kind.is_some() {\n+                if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n+                    let mut projections = self.projection_bounds();\n+                    if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                        nest!(|cx| cx.print_def_path(principal.def_id, None, iter::empty()));\n+                        nest!(|cx| cx.pretty_fn_sig(args, false, proj.ty));\n+                        resugared_principal = true;\n+                    }\n+                }\n+            }\n+\n+            if !resugared_principal {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n+                let principal = principal.with_self_ty(cx.tcx, dummy_self);\n+                nest!(|cx| cx.print_def_path(\n+                    principal.def_id,\n+                    Some(principal.substs),\n+                    self.projection_bounds(),\n+                ));\n+            }\n+            first = false;\n+        }\n+\n+        // Builtin bounds.\n+        // FIXME(eddyb) avoid printing twice (needed to ensure\n+        // that the auto traits are sorted *and* printed via cx).\n+        let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n+            (cx.tcx.def_path_str(did), did)\n+        }).collect();\n+\n+        // The auto traits come ordered by `DefPathHash`. While\n+        // `DefPathHash` is *stable* in the sense that it depends on\n+        // neither the host nor the phase of the moon, it depends\n+        // \"pseudorandomly\" on the compiler version and the target.\n+        //\n+        // To avoid that causing instabilities in compiletest\n+        // output, sort the auto-traits alphabetically.\n+        auto_traits.sort();\n+\n+        for (_, def_id) in auto_traits {\n+            if !first {\n+                p!(write(\" + \"));\n+            }\n+            first = false;\n+\n+            nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n+        }\n+    }\n+\n+    &'tcx ty::List<Ty<'tcx>> {\n+        p!(write(\"{{\"));\n+        let mut tys = self.iter();\n+        if let Some(&ty) = tys.next() {\n+            p!(print(ty));\n+            for &ty in tys {\n+                p!(write(\", \"), print(ty));\n+            }\n+        }\n+        p!(write(\"}}\"))\n+    }\n+\n+    ty::TypeAndMut<'tcx> {\n+        p!(write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+            print(self.ty))\n+    }\n+\n+    ty::ExistentialTraitRef<'tcx> {\n+        let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n+\n+        let trait_ref = *ty::Binder::bind(*self)\n+            .with_self_ty(cx.tcx, dummy_self)\n+            .skip_binder();\n+        p!(print(trait_ref))\n+    }\n+\n+    ty::FnSig<'tcx> {\n+        if self.unsafety == hir::Unsafety::Unsafe {\n+            p!(write(\"unsafe \"));\n+        }\n+\n+        if self.abi != Abi::Rust {\n+            p!(write(\"extern {} \", self.abi));\n+        }\n+\n+        p!(write(\"fn\"));\n+        nest!(|cx| cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+    }\n+\n+    ty::InferTy {\n+        if cx.tcx.sess.verbose() {\n+            p!(write(\"{:?}\", self));\n+            return Ok(cx.printer);\n+        }\n+        match *self {\n+            ty::TyVar(_) => p!(write(\"_\")),\n+            ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n+            ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n+            ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n+            ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n+            ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n+        }\n+    }\n+\n+    ty::TraitRef<'tcx> {\n+        nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs), iter::empty()));\n+    }\n+\n+    ConstValue<'tcx> {\n+        match self {\n+            ConstValue::Infer(..) => p!(write(\"_\")),\n+            ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n+            _ => p!(write(\"{:?}\", self)),\n+        }\n+    }\n+\n+    ty::Const<'tcx> {\n+        p!(write(\"{} : {}\", self.val, self.ty))\n+    }\n+\n+    ty::LazyConst<'tcx> {\n+        match self {\n+            // FIXME(const_generics) this should print at least the type.\n+            ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n+            ty::LazyConst::Evaluated(c) => p!(write(\"{}\", c)),\n+        }\n+    }\n+\n+    ty::ParamTy {\n+        p!(write(\"{}\", self.name))\n+    }\n+\n+    ty::ParamConst {\n+        p!(write(\"{}\", self.name))\n+    }\n+\n+    ty::SubtypePredicate<'tcx> {\n+        p!(print(self.a), write(\" <: \"), print(self.b))\n+    }\n+\n+    ty::TraitPredicate<'tcx> {\n+        p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+    }\n+\n+    ty::ProjectionPredicate<'tcx> {\n+        p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n+    }\n+\n+    ty::ProjectionTy<'tcx> {\n+        nest!(|cx| cx.print_def_path(self.item_def_id, Some(self.substs), iter::empty()));\n+    }\n+\n+    ty::ClosureKind {\n+        match *self {\n+            ty::ClosureKind::Fn => p!(write(\"Fn\")),\n+            ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n+            ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n+        }\n+    }\n+\n+    ty::Predicate<'tcx> {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => p!(print(data)),\n+            ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n+            ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                p!(write(\"the trait `\"));\n+                nest!(|cx| cx.print_def_path(trait_def_id, None, iter::empty()));\n+                p!(write(\"` is object-safe\"))\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+                p!(write(\"the closure `\"));\n+                nest!(|cx| cx.print_value_path(closure_def_id, None));\n+                p!(write(\"` implements the trait `{}`\", kind))\n+            }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                p!(write(\"the constant `\"));\n+                nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n+                p!(write(\"` can be evaluated\"))\n+            }\n+        }\n+    }\n+\n+    Kind<'tcx> {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => p!(print(lt)),\n+            UnpackedKind::Type(ty) => p!(print(ty)),\n+            UnpackedKind::Const(ct) => p!(print(ct)),\n+        }\n+    }\n+}"}, {"sha": "f8d0c8f661c77c393d71ba182c70e3f6d3118ecc", "filename": "src/librustc/util/ppaux.rs", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=030cdc972930aa864fe89dd4c5125ba26ebd05ac", "patch": "@@ -1,418 +0,0 @@\n-use crate::hir;\n-use crate::hir::def::Namespace;\n-use crate::ty::subst::{Kind, UnpackedKind};\n-use crate::ty::{self, ParamConst, Ty, TyCtxt};\n-use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print};\n-use crate::mir::interpret::ConstValue;\n-\n-use std::fmt;\n-use std::iter;\n-\n-use rustc_target::spec::abi::Abi;\n-\n-pub trait LiftAndPrintToFmt<'tcx> {\n-    fn lift_and_print_to_fmt(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        f: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result;\n-}\n-\n-impl<T> LiftAndPrintToFmt<'tcx> for T\n-    where T: ty::Lift<'tcx>,\n-          for<'a, 'b> <T as ty::Lift<'tcx>>::Lifted:\n-            Print<'tcx, FmtPrinter<&'a mut fmt::Formatter<'b>>, Error = fmt::Error>\n-{\n-    fn lift_and_print_to_fmt(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        f: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.tcx.lift(self).expect(\"could not lift for printing\").print(cx)?;\n-            Ok(())\n-        })\n-    }\n-}\n-\n-// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n-impl LiftAndPrintToFmt<'tcx> for ty::RegionKind {\n-    fn lift_and_print_to_fmt(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        f: &mut fmt::Formatter<'_>,\n-    ) -> fmt::Result {\n-        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            self.print(cx)?;\n-            Ok(())\n-        })\n-    }\n-}\n-\n-macro_rules! define_print {\n-    (<$($T:ident),*> $target:ty) => {\n-        impl<$($T),*> fmt::Display for $target\n-            where Self: for<'a> LiftAndPrintToFmt<'a>\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                ty::tls::with(|tcx| self.lift_and_print_to_fmt(tcx, f))\n-            }\n-        }\n-    };\n-\n-    (<$($T:ident),*> $target:ty, ($self:ident, $cx:ident) { display $disp:block }) => {\n-        impl<$($T,)* P: PrettyPrinter> Print<'tcx, P> for $target\n-            where $($T: Print<'tcx, P, Output = P, Error = P::Error>),*\n-        {\n-            type Output = P;\n-            type Error = fmt::Error;\n-            fn print(&$self, $cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n-                #[allow(unused_mut)]\n-                let mut $cx = $cx;\n-                define_scoped_cx!($cx);\n-                let _: () = $disp;\n-                #[allow(unreachable_code)]\n-                Ok($cx.printer)\n-            }\n-        }\n-\n-        define_print!(<$($T),*> $target);\n-    };\n-\n-    ($target:ty) => {\n-        define_print!(<> $target);\n-    };\n-\n-    ($target:ty, ($self:ident, $cx:ident) { display $disp:block }) => {\n-        define_print!(<> $target, ($self, $cx) { display $disp });\n-    };\n-}\n-\n-macro_rules! nest {\n-    ($closure:expr) => {\n-        scoped_cx!() = scoped_cx!().nest($closure)?\n-    }\n-}\n-macro_rules! print_inner {\n-    (write ($($data:expr),+)) => {\n-        write!(scoped_cx!().printer, $($data),+)?\n-    };\n-    ($kind:ident ($data:expr)) => {\n-        nest!(|cx| $data.$kind(cx))\n-    };\n-}\n-macro_rules! p {\n-    ($($kind:ident $data:tt),+) => {\n-        {\n-            $(print_inner!($kind $data));+\n-        }\n-    };\n-}\n-macro_rules! define_scoped_cx {\n-    ($cx:ident) => {\n-        #[allow(unused_macros)]\n-        macro_rules! scoped_cx {\n-            () => ($cx)\n-        }\n-    };\n-}\n-\n-define_print! {\n-    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, cx) {\n-        display {\n-            // Generate the main trait ref, including associated types.\n-            let mut first = true;\n-\n-            if let Some(principal) = self.principal() {\n-                let mut resugared_principal = false;\n-\n-                // Special-case `Fn(...) -> ...` and resugar it.\n-                let fn_trait_kind = cx.tcx.lang_items().fn_trait_kind(principal.def_id);\n-                if !cx.tcx.sess.verbose() && fn_trait_kind.is_some() {\n-                    if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n-                        let mut projections = self.projection_bounds();\n-                        if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                            nest!(|cx| cx.print_def_path(principal.def_id, None, iter::empty()));\n-                            nest!(|cx| cx.pretty_fn_sig(args, false, proj.ty));\n-                            resugared_principal = true;\n-                        }\n-                    }\n-                }\n-\n-                if !resugared_principal {\n-                    // Use a type that can't appear in defaults of type parameters.\n-                    let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n-                    let principal = principal.with_self_ty(cx.tcx, dummy_self);\n-                    nest!(|cx| cx.print_def_path(\n-                        principal.def_id,\n-                        Some(principal.substs),\n-                        self.projection_bounds(),\n-                    ));\n-                }\n-                first = false;\n-            }\n-\n-            // Builtin bounds.\n-            // FIXME(eddyb) avoid printing twice (needed to ensure\n-            // that the auto traits are sorted *and* printed via cx).\n-            let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n-                (cx.tcx.def_path_str(did), did)\n-            }).collect();\n-\n-            // The auto traits come ordered by `DefPathHash`. While\n-            // `DefPathHash` is *stable* in the sense that it depends on\n-            // neither the host nor the phase of the moon, it depends\n-            // \"pseudorandomly\" on the compiler version and the target.\n-            //\n-            // To avoid that causing instabilities in compiletest\n-            // output, sort the auto-traits alphabetically.\n-            auto_traits.sort();\n-\n-            for (_, def_id) in auto_traits {\n-                if !first {\n-                    p!(write(\" + \"));\n-                }\n-                first = false;\n-\n-                nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    &'tcx ty::List<Ty<'tcx>>, (self, cx) {\n-        display {\n-            p!(write(\"{{\"));\n-            let mut tys = self.iter();\n-            if let Some(&ty) = tys.next() {\n-                p!(print(ty));\n-                for &ty in tys {\n-                    p!(write(\", \"), print(ty));\n-                }\n-            }\n-            p!(write(\"}}\"))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::TypeAndMut<'tcx>, (self, cx) {\n-        display {\n-            p!(\n-                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n-                   print(self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::ExistentialTraitRef<'tcx>, (self, cx) {\n-        display {\n-            let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n-\n-            let trait_ref = *ty::Binder::bind(*self)\n-                .with_self_ty(cx.tcx, dummy_self)\n-                .skip_binder();\n-            p!(print(trait_ref))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::RegionKind\n-}\n-\n-define_print! {\n-    ty::FnSig<'tcx>, (self, cx) {\n-        display {\n-            if self.unsafety == hir::Unsafety::Unsafe {\n-                p!(write(\"unsafe \"));\n-            }\n-\n-            if self.abi != Abi::Rust {\n-                p!(write(\"extern {} \", self.abi));\n-            }\n-\n-            p!(write(\"fn\"));\n-            nest!(|cx| cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::InferTy, (self, cx) {\n-        display {\n-            if cx.tcx.sess.verbose() {\n-                p!(write(\"{:?}\", self));\n-                return Ok(cx.printer);\n-            }\n-            match *self {\n-                ty::TyVar(_) => p!(write(\"_\")),\n-                ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n-                ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n-                ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n-                ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n-                ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    <T> ty::Binder<T>\n-}\n-\n-define_print! {\n-    ty::TraitRef<'tcx>, (self, cx) {\n-        display {\n-            nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs), iter::empty()));\n-        }\n-    }\n-}\n-\n-define_print! {\n-    Ty<'tcx>\n-}\n-\n-define_print! {\n-    ConstValue<'tcx>, (self, cx) {\n-        display {\n-            match self {\n-                ConstValue::Infer(..) => p!(write(\"_\")),\n-                ConstValue::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n-                _ => p!(write(\"{:?}\", self)),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::Const<'tcx>, (self, cx) {\n-        display {\n-            p!(write(\"{} : {}\", self.val, self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::LazyConst<'tcx>, (self, cx) {\n-        display {\n-            match self {\n-                // FIXME(const_generics) this should print at least the type.\n-                ty::LazyConst::Unevaluated(..) => p!(write(\"_ : _\")),\n-                ty::LazyConst::Evaluated(c) => p!(write(\"{}\", c)),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::ParamTy, (self, cx) {\n-        display {\n-            p!(write(\"{}\", self.name))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::ParamConst, (self, cx) {\n-        display {\n-            p!(write(\"{}\", self.name))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    <T, U> ty::OutlivesPredicate<T, U>, (self, cx) {\n-        display {\n-            p!(print(self.0), write(\" : \"), print(self.1))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::SubtypePredicate<'tcx>, (self, cx) {\n-        display {\n-            p!(print(self.a), write(\" <: \"), print(self.b))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::TraitPredicate<'tcx>, (self, cx) {\n-        display {\n-            p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::ProjectionPredicate<'tcx>, (self, cx) {\n-        display {\n-            p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::ProjectionTy<'tcx>, (self, cx) {\n-        display {\n-            nest!(|cx| cx.print_def_path(self.item_def_id, Some(self.substs), iter::empty()));\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::ClosureKind, (self, cx) {\n-        display {\n-            match *self {\n-                ty::ClosureKind::Fn => p!(write(\"Fn\")),\n-                ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n-                ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ty::Predicate<'tcx>, (self, cx) {\n-        display {\n-            match *self {\n-                ty::Predicate::Trait(ref data) => p!(print(data)),\n-                ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n-                ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n-                ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n-                ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n-                ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n-                ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    p!(write(\"the trait `\"));\n-                    nest!(|cx| cx.print_def_path(trait_def_id, None, iter::empty()));\n-                    p!(write(\"` is object-safe\"))\n-                }\n-                ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                    p!(write(\"the closure `\"));\n-                    nest!(|cx| cx.print_value_path(closure_def_id, None));\n-                    p!(write(\"` implements the trait `{}`\", kind))\n-                }\n-                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    p!(write(\"the constant `\"));\n-                    nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n-                    p!(write(\"` can be evaluated\"))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-define_print! {\n-    Kind<'tcx>, (self, cx) {\n-        display {\n-            match self.unpack() {\n-                UnpackedKind::Lifetime(lt) => p!(print(lt)),\n-                UnpackedKind::Type(ty) => p!(print(ty)),\n-                UnpackedKind::Const(ct) => p!(print(ct)),\n-            }\n-        }\n-    }\n-}"}]}