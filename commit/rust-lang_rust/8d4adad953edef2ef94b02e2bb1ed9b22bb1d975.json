{"sha": "8d4adad953edef2ef94b02e2bb1ed9b22bb1d975", "node_id": "C_kwDOAAsO6NoAKDhkNGFkYWQ5NTNlZGVmMmVmOTRiMDJlMmJiMWVkOWIyMmJiMWQ5NzU", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-07-05T08:13:40Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-07-05T08:15:35Z"}, "message": "Windows: Use `FindFirstFileW` if `metadata` fails\n\nUsually opening a file handle with access set to metadata only will always succeed, even if the file is locked. However some special system files, such as `C:\\hiberfil.sys`, are locked by the system in a way that denies even that. So as a fallback we try reading the cached metadata from the directory.", "tree": {"sha": "d0f78ce23e8d3a4301aa284e0396f4c4dec09f8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0f78ce23e8d3a4301aa284e0396f4c4dec09f8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmLD8ygACgkQcTRy8vRW\nJ97WLhAAidlxBURZ5H1Y1T75mik8uZwurAw6srff7NPtxX2SiCsP6CWINO6Sy/H4\n6VvKbS9AhDmQvmxhgmnIriUyq5V+7y3hPUlo20LgRXl3mRpmwfXmWGk3nkLmfnJ1\nnbkxuDPf/vf+T2thz4rFEj2QNsbr8dfuuZX51SaVTbblNhYs05iXTruNF/Vo1pyD\n26Dq8bOSbKaMXuirbxxWosEdVaaZC/VQmf0OgCIOJ47CvvOkkTQQRj2Fc6vSWF3x\nngMZXK0r2BA4KOSxco96FceKacbCSW5mUqakSkQN+P+G+s4ZFsgMdBZ6LfZyUO9S\nEOcis3ep3MoJkCvCy3pihrSplSI8PZcw0sFKwzVQzt+d8+Oi398U7OPnnD9g4JOP\nWfqnr5jNmuc5Xpee6j2ZrSXjD0tkpiXqGiXhUUKfgdOTk4QiQ0oHGht+5HcINcGU\n+Xj6+h/UB+4/X5BxF9ILsWDCl7RFiN4Iwz6PKgeMtTxgSuZq4RTfX5UyhWj+3JHG\ndEoIEFCpI/ns0HbXURSGVPcc5s0FPZei73Z5YgRQJkADha7cdifzvSd4oBhebE0q\nogVEb/X9SEjDHAEih+/HnEnaKtP67qgRb5WLqDESc9hBHgj227amBaMBsICBx5BK\n+dOx5mWo3hDy4Uovdv64n9mrTsBLgkhVlNHRahX22eFf1DgSRj0=\n=Q8x1\n-----END PGP SIGNATURE-----", "payload": "tree d0f78ce23e8d3a4301aa284e0396f4c4dec09f8a\nparent 13ab7962ac131733400356241c37e3ddd68d1aff\nauthor Chris Denton <christophersdenton@gmail.com> 1657008820 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1657008935 +0100\n\nWindows: Use `FindFirstFileW` if `metadata` fails\n\nUsually opening a file handle with access set to metadata only will always succeed, even if the file is locked. However some special system files, such as `C:\\hiberfil.sys`, are locked by the system in a way that denies even that. So as a fallback we try reading the cached metadata from the directory.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975", "html_url": "https://github.com/rust-lang/rust/commit/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13ab7962ac131733400356241c37e3ddd68d1aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/13ab7962ac131733400356241c37e3ddd68d1aff", "html_url": "https://github.com/rust-lang/rust/commit/13ab7962ac131733400356241c37e3ddd68d1aff"}], "stats": {"total": 82, "additions": 72, "deletions": 10}, "files": [{"sha": "e1ebb1a690b0aed35717803cb772e42105370860", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=8d4adad953edef2ef94b02e2bb1ed9b22bb1d975", "patch": "@@ -1534,3 +1534,14 @@ fn read_large_dir() {\n         entry.unwrap();\n     }\n }\n+\n+#[test]\n+#[cfg(windows)]\n+fn hiberfil_sys() {\n+    // Get the system drive, which is usually `C:`.\n+    let mut hiberfil = crate::env::var(\"SystemDrive\").unwrap();\n+    hiberfil.push_str(r\"\\hiberfil.sys\");\n+\n+    fs::metadata(&hiberfil).unwrap();\n+    fs::symlink_metadata(&hiberfil).unwrap();\n+}"}, {"sha": "4d3162f1254628e6560265c95c387dcb263ea395", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4adad953edef2ef94b02e2bb1ed9b22bb1d975/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=8d4adad953edef2ef94b02e2bb1ed9b22bb1d975", "patch": "@@ -1150,22 +1150,73 @@ pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n }\n \n pub fn stat(path: &Path) -> io::Result<FileAttr> {\n-    let mut opts = OpenOptions::new();\n-    // No read or write permissions are necessary\n-    opts.access_mode(0);\n-    // This flag is so we can open directories too\n-    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let file = File::open(path, &opts)?;\n-    file.file_attr()\n+    metadata(path, ReparsePoint::Follow)\n }\n \n pub fn lstat(path: &Path) -> io::Result<FileAttr> {\n+    metadata(path, ReparsePoint::Open)\n+}\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum ReparsePoint {\n+    Follow = 0,\n+    Open = c::FILE_FLAG_OPEN_REPARSE_POINT,\n+}\n+impl ReparsePoint {\n+    fn as_flag(self) -> u32 {\n+        self as u32\n+    }\n+}\n+\n+fn metadata(path: &Path, reparse: ReparsePoint) -> io::Result<FileAttr> {\n     let mut opts = OpenOptions::new();\n     // No read or write permissions are necessary\n     opts.access_mode(0);\n-    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n-    let file = File::open(path, &opts)?;\n-    file.file_attr()\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | reparse.as_flag());\n+\n+    // Attempt to open the file normally.\n+    // If that fails with `ERROR_SHARING_VIOLATION` then retry using `FindFirstFileW`.\n+    // If the fallback fails for any reason we return the original error.\n+    match File::open(path, &opts) {\n+        Ok(file) => file.file_attr(),\n+        Err(e) if e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {\n+            // `ERROR_SHARING_VIOLATION` will almost never be returned.\n+            // Usually if a file is locked you can still read some metadata.\n+            // However, there are special system files, such as\n+            // `C:\\hiberfil.sys`, that are locked in a way that denies even that.\n+            unsafe {\n+                let path = maybe_verbatim(path)?;\n+\n+                // `FindFirstFileW` accepts wildcard file names.\n+                // Fortunately wildcards are not valid file names and\n+                // `ERROR_SHARING_VIOLATION` means the file exists (but is locked)\n+                // therefore it's safe to assume the file name given does not\n+                // include wildcards.\n+                let mut wfd = mem::zeroed();\n+                let handle = c::FindFirstFileW(path.as_ptr(), &mut wfd);\n+\n+                if handle == c::INVALID_HANDLE_VALUE {\n+                    // This can fail if the user does not have read access to the\n+                    // directory.\n+                    Err(e)\n+                } else {\n+                    // We no longer need the find handle.\n+                    c::FindClose(handle);\n+\n+                    // `FindFirstFileW` reads the cached file information from the\n+                    // directory. The downside is that this metadata may be outdated.\n+                    let attrs = FileAttr::from(wfd);\n+                    if reparse == ReparsePoint::Follow && attrs.file_type().is_symlink() {\n+                        Err(e)\n+                    } else {\n+                        Ok(attrs)\n+                    }\n+                }\n+            }\n+        }\n+        Err(e) => Err(e),\n+    }\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {"}]}