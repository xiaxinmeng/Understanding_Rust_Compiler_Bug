{"sha": "e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYTFjY2U5YzU1OGZlODRlZjVhMmI4ZTNiMDdmMWVlMTUyMTY5NGE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-25T14:56:16Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-27T20:46:23Z"}, "message": "Rename hir::map::NodeKind to hir::Node", "tree": {"sha": "18b53e5b0a63362b7e07725507abad1471e31c79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18b53e5b0a63362b7e07725507abad1471e31c79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "html_url": "https://github.com/rust-lang/rust/commit/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "html_url": "https://github.com/rust-lang/rust/commit/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe"}], "stats": {"total": 1007, "additions": 500, "deletions": 507}, "files": [{"sha": "eeb41682601f5798125be49567f819665b2f1ab2", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -22,8 +22,8 @@\n //! for the `Code` associated with a particular NodeId.\n \n use hir as ast;\n-use hir::map::{self, NodeKind};\n-use hir::{Expr, FnDecl};\n+use hir::map;\n+use hir::{Expr, FnDecl, Node};\n use hir::intravisit::FnKind;\n use syntax::ast::{Attribute, Ident, Name, NodeId};\n use syntax_pos::Span;\n@@ -39,7 +39,7 @@ use syntax_pos::Span;\n ///\n /// To construct one, use the `Code::from_node` function.\n #[derive(Copy, Clone, Debug)]\n-pub struct FnLikeNode<'a> { node: NodeKind<'a> }\n+pub struct FnLikeNode<'a> { node: Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object\n /// corresponds to some FnLikeNode.\n@@ -95,11 +95,11 @@ impl<'a> Code<'a> {\n     /// Attempts to construct a Code from presumed FnLike or Expr node input.\n     pub fn from_node(map: &map::Map<'a>, id: NodeId) -> Option<Code<'a>> {\n         match map.get(id) {\n-            map::NodeKind::Block(_) => {\n+            map::Node::Block(_) => {\n                 //  Use the parent, hopefully an expression node.\n                 Code::from_node(map, map.get_parent_node(id))\n             }\n-            map::NodeKind::Expr(expr) => Some(Code::Expr(expr)),\n+            map::Node::Expr(expr) => Some(Code::Expr(expr)),\n             node => FnLikeNode::from_node(node).map(Code::FnLike)\n         }\n     }\n@@ -143,12 +143,12 @@ impl<'a> ClosureParts<'a> {\n \n impl<'a> FnLikeNode<'a> {\n     /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n-    pub fn from_node(node: NodeKind) -> Option<FnLikeNode> {\n+    pub fn from_node(node: Node) -> Option<FnLikeNode> {\n         let fn_like = match node {\n-            map::NodeKind::Item(item) => item.is_fn_like(),\n-            map::NodeKind::TraitItem(tm) => tm.is_fn_like(),\n-            map::NodeKind::ImplItem(it) => it.is_fn_like(),\n-            map::NodeKind::Expr(e) => e.is_fn_like(),\n+            map::Node::Item(item) => item.is_fn_like(),\n+            map::Node::TraitItem(tm) => tm.is_fn_like(),\n+            map::Node::ImplItem(it) => it.is_fn_like(),\n+            map::Node::Expr(e) => e.is_fn_like(),\n             _ => false\n         };\n         if fn_like {\n@@ -234,7 +234,7 @@ impl<'a> FnLikeNode<'a> {\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            map::NodeKind::Item(i) => match i.node {\n+            map::Node::Item(i) => match i.node {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n@@ -249,13 +249,13 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            map::NodeKind::TraitItem(ti) => match ti.node {\n+            map::Node::TraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n                     method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n-            map::NodeKind::ImplItem(ii) => {\n+            map::Node::ImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n@@ -265,7 +265,7 @@ impl<'a> FnLikeNode<'a> {\n                     }\n                 }\n             },\n-            map::NodeKind::Expr(e) => match e.node {\n+            map::Node::Expr(e) => match e.node {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),"}, {"sha": "2cb8120836efa91e4ce33805b3bac86f1240a5a2", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         collector.insert_entry(CRATE_NODE_ID, Entry {\n             parent: ast::DUMMY_NODE_ID,\n             dep_node: root_mod_sig_dep_index,\n-            node: NodeKind::Crate,\n+            node: Node::Crate,\n         });\n \n         collector\n@@ -190,7 +190,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.map[id.as_usize()] = Some(entry);\n     }\n \n-    fn insert(&mut self, id: NodeId, node: NodeKind<'hir>) {\n+    fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n         let entry = Entry {\n             parent: self.parent_node,\n             dep_node: if self.currently_in_body {\n@@ -309,13 +309,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.id, NodeKind::Item(i));\n+            this.insert(i.id, Node::Item(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) => {\n                         // If this is a tuple-like struct, register the constructor.\n                         if !struct_def.is_struct() {\n-                            this.insert(struct_def.id(), NodeKind::StructCtor(struct_def));\n+                            this.insert(struct_def.id(), Node::StructCtor(struct_def));\n                         }\n                     }\n                     _ => {}\n@@ -326,23 +326,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.id, NodeKind::ForeignItem(foreign_item));\n+        self.insert(foreign_item.id, Node::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.id, NodeKind::GenericParam(param));\n+        self.insert(param.id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.id, NodeKind::TraitItem(ti));\n+            this.insert(ti.id, Node::TraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -354,7 +354,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.id, NodeKind::ImplItem(ii));\n+            this.insert(ii.id, Node::ImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -364,9 +364,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_pat(&mut self, pat: &'hir Pat) {\n         let node = if let PatKind::Binding(..) = pat.node {\n-            NodeKind::Binding(pat)\n+            Node::Binding(pat)\n         } else {\n-            NodeKind::Pat(pat)\n+            Node::Pat(pat)\n         };\n         self.insert(pat.id, node);\n \n@@ -376,15 +376,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(constant.id, NodeKind::AnonConst(constant));\n+        self.insert(constant.id, Node::AnonConst(constant));\n \n         self.with_parent(constant.id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.id, NodeKind::Expr(expr));\n+        self.insert(expr.id, Node::Expr(expr));\n \n         self.with_parent(expr.id, |this| {\n             intravisit::walk_expr(this, expr);\n@@ -393,23 +393,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n         let id = stmt.node.id();\n-        self.insert(id, NodeKind::Stmt(stmt));\n+        self.insert(id, Node::Stmt(stmt));\n \n         self.with_parent(id, |this| {\n             intravisit::walk_stmt(this, stmt);\n         });\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.id, NodeKind::Ty(ty));\n+        self.insert(ty.id, Node::Ty(ty));\n \n         self.with_parent(ty.id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.ref_id, NodeKind::TraitRef(tr));\n+        self.insert(tr.ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n@@ -423,21 +423,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.id, NodeKind::Block(block));\n+        self.insert(block.id, Node::Block(block));\n         self.with_parent(block.id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.id, NodeKind::Local(l));\n+        self.insert(l.id, Node::Local(l));\n         self.with_parent(l.id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.id, NodeKind::Lifetime(lifetime));\n+        self.insert(lifetime.id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n@@ -446,7 +446,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { id, .. } => {\n-                self.insert(id, NodeKind::Visibility(visibility));\n+                self.insert(id, Node::Visibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n@@ -458,20 +458,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.id, NodeKind::MacroDef(macro_def));\n+            this.insert(macro_def.id, Node::MacroDef(macro_def));\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n         let id = v.node.data.id();\n-        self.insert(id, NodeKind::Variant(v));\n+        self.insert(id, Node::Variant(v));\n         self.with_parent(id, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.id, NodeKind::Field(field));\n+        self.insert(field.id, Node::Field(field));\n         self.with_parent(field.id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });"}, {"sha": "747c1ac13dd064f9e79d567095c0410251933269", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 179, "deletions": 211, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -40,88 +40,56 @@ mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n-\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum NodeKind<'hir> {\n-    Item(&'hir Item),\n-    ForeignItem(&'hir ForeignItem),\n-    TraitItem(&'hir TraitItem),\n-    ImplItem(&'hir ImplItem),\n-    Variant(&'hir Variant),\n-    Field(&'hir StructField),\n-    AnonConst(&'hir AnonConst),\n-    Expr(&'hir Expr),\n-    Stmt(&'hir Stmt),\n-    Ty(&'hir Ty),\n-    TraitRef(&'hir TraitRef),\n-    Binding(&'hir Pat),\n-    Pat(&'hir Pat),\n-    Block(&'hir Block),\n-    Local(&'hir Local),\n-    MacroDef(&'hir MacroDef),\n-\n-    /// StructCtor represents a tuple struct.\n-    StructCtor(&'hir VariantData),\n-\n-    Lifetime(&'hir Lifetime),\n-    GenericParam(&'hir GenericParam),\n-    Visibility(&'hir Visibility),\n-\n-    /// Roots for node trees. Its DepNodeIndex when in `Entry`\n-    /// is the dependency node of the crate's root module.\n-    Crate,\n-}\n-\n /// Represents an entry and its parent NodeId.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: NodeId,\n     dep_node: DepNodeIndex,\n-    node: NodeKind<'hir>,\n+    node: Node<'hir>,\n }\n \n impl<'hir> Entry<'hir> {\n     fn parent_node(self) -> Option<NodeId> {\n         match self.node {\n-            NodeKind::Crate | NodeKind::MacroDef(_) => None,\n+            Node::Crate | Node::MacroDef(_) => None,\n             _ => Some(self.parent),\n         }\n     }\n \n-    fn to_node(self) -> Option<NodeKind<'hir>> {\n+    fn to_node(self) -> Option<Node<'hir>> {\n         match self.node {\n-            NodeKind::Crate => None,\n+            Node::Crate => None,\n             _ => Some(self.node),\n         }\n     }\n \n     fn fn_decl(&self) -> Option<&FnDecl> {\n         match self.node {\n-            NodeKind::Item(ref item) => {\n+            Node::Item(ref item) => {\n                 match item.node {\n                     ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n \n-            NodeKind::TraitItem(ref item) => {\n+            Node::TraitItem(ref item) => {\n                 match item.node {\n                     TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None\n                 }\n             }\n \n-            NodeKind::ImplItem(ref item) => {\n+            Node::ImplItem(ref item) => {\n                 match item.node {\n                     ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None,\n                 }\n             }\n \n-            NodeKind::Expr(ref expr) => {\n+            Node::Expr(ref expr) => {\n                 match expr.node {\n                     ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n                     _ => None,\n@@ -134,7 +102,7 @@ impl<'hir> Entry<'hir> {\n \n     fn associated_body(self) -> Option<BodyId> {\n         match self.node {\n-            NodeKind::Item(item) => {\n+            Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n@@ -143,25 +111,25 @@ impl<'hir> Entry<'hir> {\n                 }\n             }\n \n-            NodeKind::TraitItem(item) => {\n+            Node::TraitItem(item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            NodeKind::ImplItem(item) => {\n+            Node::ImplItem(item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            NodeKind::AnonConst(constant) => Some(constant.body),\n+            Node::AnonConst(constant) => Some(constant.body),\n \n-            NodeKind::Expr(expr) => {\n+            Node::Expr(expr) => {\n                 match expr.node {\n                     ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n@@ -200,8 +168,8 @@ impl Forest {\n     }\n }\n \n-/// Represents a mapping from NodeKind IDs to AST elements and their parent\n-/// NodeKind IDs\n+/// Represents a mapping from Node IDs to AST elements and their parent\n+/// Node IDs\n #[derive(Clone)]\n pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n@@ -324,7 +292,7 @@ impl<'hir> Map<'hir> {\n         };\n \n         match node {\n-            NodeKind::Item(item) => {\n+            Node::Item(item) => {\n                 let def_id = || {\n                     self.local_def_id(item.id)\n                 };\n@@ -351,23 +319,23 @@ impl<'hir> Map<'hir> {\n                     ItemKind::Impl(..) => None,\n                 }\n             }\n-            NodeKind::ForeignItem(item) => {\n+            Node::ForeignItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n                     ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n                     ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n                 }\n             }\n-            NodeKind::TraitItem(item) => {\n+            Node::TraitItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n                     TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n                 }\n             }\n-            NodeKind::ImplItem(item) => {\n+            Node::ImplItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n                     ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n@@ -376,31 +344,31 @@ impl<'hir> Map<'hir> {\n                     ImplItemKind::Existential(..) => Some(Def::AssociatedExistential(def_id)),\n                 }\n             }\n-            NodeKind::Variant(variant) => {\n+            Node::Variant(variant) => {\n                 let def_id = self.local_def_id(variant.node.data.id());\n                 Some(Def::Variant(def_id))\n             }\n-            NodeKind::Field(_) |\n-            NodeKind::AnonConst(_) |\n-            NodeKind::Expr(_) |\n-            NodeKind::Stmt(_) |\n-            NodeKind::Ty(_) |\n-            NodeKind::TraitRef(_) |\n-            NodeKind::Pat(_) |\n-            NodeKind::Binding(_) |\n-            NodeKind::StructCtor(_) |\n-            NodeKind::Lifetime(_) |\n-            NodeKind::Visibility(_) |\n-            NodeKind::Block(_) |\n-            NodeKind::Crate => None,\n-            NodeKind::Local(local) => {\n+            Node::Field(_) |\n+            Node::AnonConst(_) |\n+            Node::Expr(_) |\n+            Node::Stmt(_) |\n+            Node::Ty(_) |\n+            Node::TraitRef(_) |\n+            Node::Pat(_) |\n+            Node::Binding(_) |\n+            Node::StructCtor(_) |\n+            Node::Lifetime(_) |\n+            Node::Visibility(_) |\n+            Node::Block(_) |\n+            Node::Crate => None,\n+            Node::Local(local) => {\n                 Some(Def::Local(local.id))\n             }\n-            NodeKind::MacroDef(macro_def) => {\n+            Node::MacroDef(macro_def) => {\n                 Some(Def::Macro(self.local_def_id(macro_def.id),\n                                 MacroKind::Bang))\n             }\n-            NodeKind::GenericParam(param) => {\n+            Node::GenericParam(param) => {\n                 Some(match param.kind {\n                     GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n                     GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n@@ -492,13 +460,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n         match self.get(id) {\n-            NodeKind::Item(&Item { node: ItemKind::Const(..), .. }) |\n-            NodeKind::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n-            NodeKind::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n-            NodeKind::AnonConst(_) => {\n+            Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n+            Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n+            Node::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n+            Node::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            NodeKind::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n+            Node::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n             // Default to function if it's not a constant or static.\n@@ -508,8 +476,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n-            NodeKind::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n-            NodeKind::GenericParam(_) => self.get_parent_node(id),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n+            Node::GenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n                     self.node_to_string(id))\n@@ -519,10 +487,10 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeKind::Item(&Item { node: ItemKind::Trait(..), .. }) => {\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeKind::GenericParam(param) => param.name.ident().name,\n+            Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n@@ -557,25 +525,25 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    /// Retrieve the NodeKind corresponding to `id`, panicking if it cannot\n+    /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n-    pub fn get(&self, id: NodeId) -> NodeKind<'hir> {\n+    pub fn get(&self, id: NodeId) -> Node<'hir> {\n         match self.find(id) {\n             Some(node) => node, // read recorded by `find`\n             None => bug!(\"couldn't find node id {} in the AST map\", id)\n         }\n     }\n \n-    pub fn get_if_local(&self, id: DefId) -> Option<NodeKind<'hir>> {\n+    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n         self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics> {\n         self.get_if_local(id).and_then(|node| {\n             match node {\n-                NodeKind::ImplItem(ref impl_item) => Some(&impl_item.generics),\n-                NodeKind::TraitItem(ref trait_item) => Some(&trait_item.generics),\n-                NodeKind::Item(ref item) => {\n+                Node::ImplItem(ref impl_item) => Some(&impl_item.generics),\n+                Node::TraitItem(ref trait_item) => Some(&trait_item.generics),\n+                Node::Item(ref item) => {\n                     match item.node {\n                         ItemKind::Fn(_, _, ref generics, _) |\n                         ItemKind::Ty(_, ref generics) |\n@@ -597,9 +565,9 @@ impl<'hir> Map<'hir> {\n         self.get_generics(id).map(|generics| generics.span).filter(|sp| *sp != DUMMY_SP)\n     }\n \n-    /// Retrieve the NodeKind corresponding to `id`, returning None if\n+    /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n-    pub fn find(&self, id: NodeId) -> Option<NodeKind<'hir>> {\n+    pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n         let result = self.find_entry(id).and_then(|x| x.to_node());\n         if result.is_some() {\n             self.read(id);\n@@ -631,14 +599,14 @@ impl<'hir> Map<'hir> {\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: NodeId) -> bool {\n         match self.find(id) {\n-            Some(NodeKind::Binding(_)) => (),\n+            Some(Node::Binding(_)) => (),\n             _ => return false,\n         }\n         match self.find(self.get_parent_node(id)) {\n-            Some(NodeKind::Item(_)) |\n-            Some(NodeKind::TraitItem(_)) |\n-            Some(NodeKind::ImplItem(_)) => true,\n-            Some(NodeKind::Expr(e)) => {\n+            Some(Node::Item(_)) |\n+            Some(Node::TraitItem(_)) |\n+            Some(Node::ImplItem(_)) => true,\n+            Some(Node::Expr(e)) => {\n                 match e.node {\n                     ExprKind::Closure(..) => true,\n                     _ => false,\n@@ -658,7 +626,7 @@ impl<'hir> Map<'hir> {\n                                 found: F,\n                                 bail_early: F2)\n         -> Result<NodeId, NodeId>\n-        where F: Fn(&NodeKind<'hir>) -> bool, F2: Fn(&NodeKind<'hir>) -> bool\n+        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n     {\n         let mut id = start_id;\n         loop {\n@@ -711,18 +679,18 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n-        let match_fn = |node: &NodeKind| {\n+        let match_fn = |node: &Node| {\n             match *node {\n-                NodeKind::Item(_) |\n-                NodeKind::ForeignItem(_) |\n-                NodeKind::TraitItem(_) |\n-                NodeKind::ImplItem(_) => true,\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => true,\n                 _ => false,\n             }\n         };\n-        let match_non_returning_block = |node: &NodeKind| {\n+        let match_non_returning_block = |node: &Node| {\n             match *node {\n-                NodeKind::Expr(ref expr) => {\n+                Node::Expr(ref expr) => {\n                     match expr.node {\n                         ExprKind::While(..) | ExprKind::Loop(..) => true,\n                         _ => false,\n@@ -744,10 +712,10 @@ impl<'hir> Map<'hir> {\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n-            NodeKind::Item(_) |\n-            NodeKind::ForeignItem(_) |\n-            NodeKind::TraitItem(_) |\n-            NodeKind::ImplItem(_) => true,\n+            Node::Item(_) |\n+            Node::ForeignItem(_) |\n+            Node::TraitItem(_) |\n+            Node::ImplItem(_) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -759,7 +727,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         let id = match self.walk_parent_nodes(id, |node| match *node {\n-            NodeKind::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n+            Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -774,11 +742,11 @@ impl<'hir> Map<'hir> {\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n         match self.walk_parent_nodes(id, |node| match *node {\n-            NodeKind::Item(_) |\n-            NodeKind::ForeignItem(_) |\n-            NodeKind::TraitItem(_) |\n-            NodeKind::ImplItem(_) |\n-            NodeKind::Block(_) => true,\n+            Node::Item(_) |\n+            Node::ForeignItem(_) |\n+            Node::TraitItem(_) |\n+            Node::ImplItem(_) |\n+            Node::Block(_) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => Some(id),\n@@ -794,7 +762,7 @@ impl<'hir> Map<'hir> {\n         let parent = self.get_parent(id);\n         if let Some(entry) = self.find_entry(parent) {\n             match entry {\n-                Entry { node: NodeKind::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. }\n+                Entry { node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. }\n                     => {\n                     self.read(id); // reveals some of the content of a node\n                     return nm.abi;\n@@ -807,28 +775,28 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n         match self.find(id) { // read recorded by `find`\n-            Some(NodeKind::Item(item)) => item,\n+            Some(Node::Item(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n         match self.find(id) {\n-            Some(NodeKind::ImplItem(item)) => item,\n+            Some(Node::ImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n         match self.find(id) {\n-            Some(NodeKind::TraitItem(item)) => item,\n+            Some(Node::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_variant_data(&self, id: NodeId) -> &'hir VariantData {\n         match self.find(id) {\n-            Some(NodeKind::Item(i)) => {\n+            Some(Node::Item(i)) => {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n@@ -838,8 +806,8 @@ impl<'hir> Map<'hir> {\n                     }\n                 }\n             }\n-            Some(NodeKind::StructCtor(data)) => data,\n-            Some(NodeKind::Variant(variant)) => &variant.node.data,\n+            Some(Node::StructCtor(data)) => data,\n+            Some(Node::Variant(variant)) => &variant.node.data,\n             _ => {\n                 bug!(\"expected struct or variant, found {}\",\n                      self.node_to_string(id));\n@@ -849,59 +817,59 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_variant(&self, id: NodeId) -> &'hir Variant {\n         match self.find(id) {\n-            Some(NodeKind::Variant(variant)) => variant,\n+            Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: NodeId) -> &'hir ForeignItem {\n         match self.find(id) {\n-            Some(NodeKind::ForeignItem(item)) => item,\n+            Some(Node::ForeignItem(item)) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n         match self.find(id) { // read recorded by find\n-            Some(NodeKind::Expr(expr)) => expr,\n+            Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeKind::Item(i) => i.name,\n-            NodeKind::ForeignItem(i) => i.name,\n-            NodeKind::ImplItem(ii) => ii.ident.name,\n-            NodeKind::TraitItem(ti) => ti.ident.name,\n-            NodeKind::Variant(v) => v.node.name,\n-            NodeKind::Field(f) => f.ident.name,\n-            NodeKind::Lifetime(lt) => lt.name.ident().name,\n-            NodeKind::GenericParam(param) => param.name.ident().name,\n-            NodeKind::Binding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n-            NodeKind::StructCtor(_) => self.name(self.get_parent(id)),\n+            Node::Item(i) => i.name,\n+            Node::ForeignItem(i) => i.name,\n+            Node::ImplItem(ii) => ii.ident.name,\n+            Node::TraitItem(ti) => ti.ident.name,\n+            Node::Variant(v) => v.node.name,\n+            Node::Field(f) => f.ident.name,\n+            Node::Lifetime(lt) => lt.name.ident().name,\n+            Node::GenericParam(param) => param.name.ident().name,\n+            Node::Binding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n+            Node::StructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Given a node ID, get a list of attributes associated with the AST\n-    /// corresponding to the NodeKind ID\n+    /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find(id) {\n-            Some(NodeKind::Item(i)) => Some(&i.attrs[..]),\n-            Some(NodeKind::ForeignItem(fi)) => Some(&fi.attrs[..]),\n-            Some(NodeKind::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n-            Some(NodeKind::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(NodeKind::Variant(ref v)) => Some(&v.node.attrs[..]),\n-            Some(NodeKind::Field(ref f)) => Some(&f.attrs[..]),\n-            Some(NodeKind::Expr(ref e)) => Some(&*e.attrs),\n-            Some(NodeKind::Stmt(ref s)) => Some(s.node.attrs()),\n-            Some(NodeKind::GenericParam(param)) => Some(&param.attrs[..]),\n+            Some(Node::Item(i)) => Some(&i.attrs[..]),\n+            Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n+            Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n+            Some(Node::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n+            Some(Node::Variant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n+            Some(Node::Expr(ref e)) => Some(&*e.attrs),\n+            Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n+            Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n-            Some(NodeKind::StructCtor(_)) => {\n+            Some(Node::StructCtor(_)) => {\n                 return self.attrs(self.get_parent(id));\n             }\n             _ => None\n@@ -929,31 +897,31 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n         match self.find_entry(id).map(|entry| entry.node) {\n-            Some(NodeKind::Item(item)) => item.span,\n-            Some(NodeKind::ForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeKind::TraitItem(trait_method)) => trait_method.span,\n-            Some(NodeKind::ImplItem(impl_item)) => impl_item.span,\n-            Some(NodeKind::Variant(variant)) => variant.span,\n-            Some(NodeKind::Field(field)) => field.span,\n-            Some(NodeKind::AnonConst(constant)) => self.body(constant.body).value.span,\n-            Some(NodeKind::Expr(expr)) => expr.span,\n-            Some(NodeKind::Stmt(stmt)) => stmt.span,\n-            Some(NodeKind::Ty(ty)) => ty.span,\n-            Some(NodeKind::TraitRef(tr)) => tr.path.span,\n-            Some(NodeKind::Binding(pat)) => pat.span,\n-            Some(NodeKind::Pat(pat)) => pat.span,\n-            Some(NodeKind::Block(block)) => block.span,\n-            Some(NodeKind::StructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n-            Some(NodeKind::Lifetime(lifetime)) => lifetime.span,\n-            Some(NodeKind::GenericParam(param)) => param.span,\n-            Some(NodeKind::Visibility(&Spanned {\n+            Some(Node::Item(item)) => item.span,\n+            Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n+            Some(Node::TraitItem(trait_method)) => trait_method.span,\n+            Some(Node::ImplItem(impl_item)) => impl_item.span,\n+            Some(Node::Variant(variant)) => variant.span,\n+            Some(Node::Field(field)) => field.span,\n+            Some(Node::AnonConst(constant)) => self.body(constant.body).value.span,\n+            Some(Node::Expr(expr)) => expr.span,\n+            Some(Node::Stmt(stmt)) => stmt.span,\n+            Some(Node::Ty(ty)) => ty.span,\n+            Some(Node::TraitRef(tr)) => tr.path.span,\n+            Some(Node::Binding(pat)) => pat.span,\n+            Some(Node::Pat(pat)) => pat.span,\n+            Some(Node::Block(block)) => block.span,\n+            Some(Node::StructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(Node::Lifetime(lifetime)) => lifetime.span,\n+            Some(Node::GenericParam(param)) => param.span,\n+            Some(Node::Visibility(&Spanned {\n                 node: VisibilityKind::Restricted { ref path, .. }, ..\n             })) => path.span,\n-            Some(NodeKind::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(NodeKind::Local(local)) => local.span,\n-            Some(NodeKind::MacroDef(macro_def)) => macro_def.span,\n+            Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(Node::Local(local)) => local.span,\n+            Some(Node::MacroDef(macro_def)) => macro_def.span,\n \n-            Some(NodeKind::Crate) => self.forest.krate.span,\n+            Some(Node::Crate) => self.forest.krate.span,\n             None => bug!(\"hir::map::Map::span: id not in map: {:?}\", id),\n         }\n     }\n@@ -1012,7 +980,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n             loop {\n                 match map.find(id)? {\n-                    NodeKind::Item(item) if item_is_mod(&item) =>\n+                    Node::Item(item) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }\n@@ -1048,12 +1016,12 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx).map(|entry| entry.node) {\n-                Some(NodeKind::Item(n)) => n.name(),\n-                Some(NodeKind::ForeignItem(n)) => n.name(),\n-                Some(NodeKind::TraitItem(n)) => n.name(),\n-                Some(NodeKind::ImplItem(n)) => n.name(),\n-                Some(NodeKind::Variant(n)) => n.name(),\n-                Some(NodeKind::Field(n)) => n.name(),\n+                Some(Node::Item(n)) => n.name(),\n+                Some(Node::ForeignItem(n)) => n.name(),\n+                Some(Node::TraitItem(n)) => n.name(),\n+                Some(Node::ImplItem(n)) => n.name(),\n+                Some(Node::Variant(n)) => n.name(),\n+                Some(Node::Field(n)) => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1144,21 +1112,21 @@ impl<'hir> print::PpAnn for Map<'hir> {\n }\n \n impl<'a> print::State<'a> {\n-    pub fn print_node(&mut self, node: NodeKind) -> io::Result<()> {\n+    pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n         match node {\n-            NodeKind::Item(a)         => self.print_item(&a),\n-            NodeKind::ForeignItem(a)  => self.print_foreign_item(&a),\n-            NodeKind::TraitItem(a)    => self.print_trait_item(a),\n-            NodeKind::ImplItem(a)     => self.print_impl_item(a),\n-            NodeKind::Variant(a)      => self.print_variant(&a),\n-            NodeKind::AnonConst(a)    => self.print_anon_const(&a),\n-            NodeKind::Expr(a)         => self.print_expr(&a),\n-            NodeKind::Stmt(a)         => self.print_stmt(&a),\n-            NodeKind::Ty(a)           => self.print_type(&a),\n-            NodeKind::TraitRef(a)     => self.print_trait_ref(&a),\n-            NodeKind::Binding(a)      |\n-            NodeKind::Pat(a)          => self.print_pat(&a),\n-            NodeKind::Block(a)        => {\n+            Node::Item(a)         => self.print_item(&a),\n+            Node::ForeignItem(a)  => self.print_foreign_item(&a),\n+            Node::TraitItem(a)    => self.print_trait_item(a),\n+            Node::ImplItem(a)     => self.print_impl_item(a),\n+            Node::Variant(a)      => self.print_variant(&a),\n+            Node::AnonConst(a)    => self.print_anon_const(&a),\n+            Node::Expr(a)         => self.print_expr(&a),\n+            Node::Stmt(a)         => self.print_stmt(&a),\n+            Node::Ty(a)           => self.print_type(&a),\n+            Node::TraitRef(a)     => self.print_trait_ref(&a),\n+            Node::Binding(a)      |\n+            Node::Pat(a)          => self.print_pat(&a),\n+            Node::Block(a)        => {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n@@ -1167,17 +1135,17 @@ impl<'a> print::State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&a)\n             }\n-            NodeKind::Lifetime(a)     => self.print_lifetime(&a),\n-            NodeKind::Visibility(a)   => self.print_visibility(&a),\n-            NodeKind::GenericParam(_) => bug!(\"cannot print NodeKind::GenericParam\"),\n-            NodeKind::Field(_)        => bug!(\"cannot print StructField\"),\n+            Node::Lifetime(a)     => self.print_lifetime(&a),\n+            Node::Visibility(a)   => self.print_visibility(&a),\n+            Node::GenericParam(_) => bug!(\"cannot print Node::GenericParam\"),\n+            Node::Field(_)        => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeKind::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n-            NodeKind::Local(a)        => self.print_local_decl(&a),\n-            NodeKind::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n-            NodeKind::Crate     => bug!(\"cannot print Crate\"),\n+            Node::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            Node::Local(a)        => self.print_local_decl(&a),\n+            Node::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n+            Node::Crate     => bug!(\"cannot print Crate\"),\n         }\n     }\n }\n@@ -1203,7 +1171,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     };\n \n     match map.find(id) {\n-        Some(NodeKind::Item(item)) => {\n+        Some(Node::Item(item)) => {\n             let item_str = match item.node {\n                 ItemKind::ExternCrate(..) => \"extern crate\",\n                 ItemKind::Use(..) => \"use\",\n@@ -1224,10 +1192,10 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }\n-        Some(NodeKind::ForeignItem(_)) => {\n+        Some(Node::ForeignItem(_)) => {\n             format!(\"foreign item {}{}\", path_str(), id_str)\n         }\n-        Some(NodeKind::ImplItem(ii)) => {\n+        Some(Node::ImplItem(ii)) => {\n             match ii.node {\n                 ImplItemKind::Const(..) => {\n                     format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n@@ -1243,7 +1211,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 }\n             }\n         }\n-        Some(NodeKind::TraitItem(ti)) => {\n+        Some(Node::TraitItem(ti)) => {\n             let kind = match ti.node {\n                 TraitItemKind::Const(..) => \"assoc constant\",\n                 TraitItemKind::Method(..) => \"trait method\",\n@@ -1252,59 +1220,59 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n             format!(\"{} {} in {}{}\", kind, ti.ident, path_str(), id_str)\n         }\n-        Some(NodeKind::Variant(ref variant)) => {\n+        Some(Node::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n                     variant.node.name,\n                     path_str(), id_str)\n         }\n-        Some(NodeKind::Field(ref field)) => {\n+        Some(Node::Field(ref field)) => {\n             format!(\"field {} in {}{}\",\n                     field.ident,\n                     path_str(), id_str)\n         }\n-        Some(NodeKind::AnonConst(_)) => {\n+        Some(Node::AnonConst(_)) => {\n             format!(\"const {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Expr(_)) => {\n+        Some(Node::Expr(_)) => {\n             format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Stmt(_)) => {\n+        Some(Node::Stmt(_)) => {\n             format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Ty(_)) => {\n+        Some(Node::Ty(_)) => {\n             format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::TraitRef(_)) => {\n+        Some(Node::TraitRef(_)) => {\n             format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Binding(_)) => {\n+        Some(Node::Binding(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Pat(_)) => {\n+        Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Block(_)) => {\n+        Some(Node::Block(_)) => {\n             format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::Local(_)) => {\n+        Some(Node::Local(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::StructCtor(_)) => {\n+        Some(Node::StructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }\n-        Some(NodeKind::Lifetime(_)) => {\n+        Some(Node::Lifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeKind::GenericParam(ref param)) => {\n+        Some(Node::GenericParam(ref param)) => {\n             format!(\"generic_param {:?}{}\", param, id_str)\n         }\n-        Some(NodeKind::Visibility(ref vis)) => {\n+        Some(Node::Visibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n-        Some(NodeKind::MacroDef(_)) => {\n+        Some(Node::MacroDef(_)) => {\n             format!(\"macro {}{}\",  path_str(), id_str)\n         }\n-        Some(NodeKind::Crate) => format!(\"root_crate\"),\n+        Some(Node::Crate) => format!(\"root_crate\"),\n         None => format!(\"unknown node{}\", id_str),\n     }\n }"}, {"sha": "bae7fa391c0bc8e7d3dc1406db8440c0c129dea6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -2370,3 +2370,34 @@ impl CodegenFnAttrs {\n         self.flags.contains(CodegenFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n     }\n }\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Node<'hir> {\n+    Item(&'hir Item),\n+    ForeignItem(&'hir ForeignItem),\n+    TraitItem(&'hir TraitItem),\n+    ImplItem(&'hir ImplItem),\n+    Variant(&'hir Variant),\n+    Field(&'hir StructField),\n+    AnonConst(&'hir AnonConst),\n+    Expr(&'hir Expr),\n+    Stmt(&'hir Stmt),\n+    Ty(&'hir Ty),\n+    TraitRef(&'hir TraitRef),\n+    Binding(&'hir Pat),\n+    Pat(&'hir Pat),\n+    Block(&'hir Block),\n+    Local(&'hir Local),\n+    MacroDef(&'hir MacroDef),\n+\n+    /// StructCtor represents a tuple struct.\n+    StructCtor(&'hir VariantData),\n+\n+    Lifetime(&'hir Lifetime),\n+    GenericParam(&'hir GenericParam),\n+    Visibility(&'hir Visibility),\n+\n+    /// Roots for node trees. Its DepNodeIndex when in `Entry`\n+    /// is the dependency node of the crate's root module.\n+    Crate,\n+}"}, {"sha": "8eab07ece05ef24219901d3e0ddab8eca7931b1e", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use hir;\n-use hir::map::NodeKind;\n+use hir::Node;\n use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n@@ -698,7 +698,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n                         };\n                         let in_definition_scope = match tcx.hir.find(anon_node_id) {\n-                            Some(NodeKind::Item(item)) => match item.node {\n+                            Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n@@ -715,7 +715,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n-                            Some(NodeKind::ImplItem(item)) => match item.node {\n+                            Some(Node::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,"}, {"sha": "cf0d0ceadca910b68e2c029698f1ed86af7b819c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -62,7 +62,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n \n use std::{cmp, fmt};\n use hir;\n-use hir::map::NodeKind;\n+use hir::Node;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n@@ -100,8 +100,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n-                    Some(NodeKind::Block(_)) => \"block\",\n-                    Some(NodeKind::Expr(expr)) => match expr.node {\n+                    Some(Node::Block(_)) => \"block\",\n+                    Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n                         hir::ExprKind::MethodCall(..) => \"method call\",\n                         hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -110,10 +110,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprKind::Match(..) => \"match\",\n                         _ => \"expression\",\n                     },\n-                    Some(NodeKind::Stmt(_)) => \"statement\",\n-                    Some(NodeKind::Item(it)) => Self::item_scope_tag(&it),\n-                    Some(NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-                    Some(NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n+                    Some(Node::Stmt(_)) => \"statement\",\n+                    Some(Node::Item(it)) => Self::item_scope_tag(&it),\n+                    Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+                    Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -194,10 +194,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let tag = match self.hir.find(node) {\n-            Some(NodeKind::Block(_)) | Some(NodeKind::Expr(_)) => \"body\",\n-            Some(NodeKind::Item(it)) => Self::item_scope_tag(&it),\n-            Some(NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-            Some(NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n+            Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n+            Some(Node::Item(it)) => Self::item_scope_tag(&it),\n+            Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+            Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n             _ => unreachable!()\n         };\n         let (prefix, span) = match *region {\n@@ -1127,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let NodeKind::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(ref param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "e3faf755672a10c55916cd51f101faddd15de726", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -10,7 +10,7 @@\n \n use hir;\n use ty::{self, Region, TyCtxt};\n-use hir::map::NodeKind;\n+use hir::Node;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n use infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -40,15 +40,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {\n-                    NodeKind::Item(&hir::Item {\n+                    Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n-                    NodeKind::TraitItem(&hir::TraitItem {\n+                    Node::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(ref m, ..),\n                         ..\n                     })\n-                    | NodeKind::ImplItem(&hir::ImplItem {\n+                    | Node::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(ref m, ..),\n                         ..\n                     }) => &m.decl,"}, {"sha": "5c27cdb6fb55392198cb30678f1895d81b4ff040", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -15,7 +15,7 @@ use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::SubregionOrigin;\n use ty::RegionKind;\n use hir::{Expr, ExprKind::Closure};\n-use hir::map::NodeKind;\n+use hir::Node;\n use util::common::ErrorReported;\n use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n@@ -59,7 +59,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 let hir = &self.tcx.hir;\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     match hir.get(node_id) {\n-                        NodeKind::Expr(Expr {\n+                        Node::Expr(Expr {\n                             node: Closure(_, _, _, closure_span, None),\n                             ..\n                         }) => {"}, {"sha": "30406f1fec55cd208ce6c56779f64c84deaa17b4", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -15,7 +15,7 @@ use hir;\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n-use hir::map::NodeKind;\n+use hir::Node;\n use syntax_pos::Span;\n \n // The struct contains the information about the anonymous region\n@@ -138,8 +138,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n         let is_impl_item = match self.tcx.hir.find(node_id) {\n-            Some(NodeKind::Item(..)) | Some(NodeKind::TraitItem(..)) => false,\n-            Some(NodeKind::ImplItem(..)) => {\n+            Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n+            Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n             }\n             _ => return None,"}, {"sha": "d320173f9f47d01d95361323f5e58db16819f902", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -12,7 +12,7 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use hir::map::NodeKind;\n+use hir::Node;\n use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -29,16 +29,16 @@ use syntax::attr;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n-// explored. For example, if it's a live NodeKind::Item that is a\n+// explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n     match tcx.hir.find(node_id) {\n-        Some(NodeKind::Item(..)) |\n-        Some(NodeKind::ImplItem(..)) |\n-        Some(NodeKind::ForeignItem(..)) |\n-        Some(NodeKind::TraitItem(..)) =>\n+        Some(Node::Item(..)) |\n+        Some(Node::ImplItem(..)) |\n+        Some(Node::ForeignItem(..)) |\n+        Some(Node::TraitItem(..)) =>\n             true,\n         _ =>\n             false\n@@ -145,13 +145,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &NodeKind<'tcx>) {\n+    fn visit_node(&mut self, node: &Node<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n         match *node {\n-            NodeKind::Item(item) => {\n+            Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -173,13 +173,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            NodeKind::TraitItem(trait_item) => {\n+            Node::TraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n-            NodeKind::ImplItem(impl_item) => {\n+            Node::ImplItem(impl_item) => {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n-            NodeKind::ForeignItem(foreign_item) => {\n+            Node::ForeignItem(foreign_item) => {\n                 intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()"}, {"sha": "2697d62cf467aa0d4cf857cc018db30fb5e0c6db", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -108,7 +108,7 @@ use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use hir::def::*;\n-use hir::map::NodeKind;\n+use hir::Node;\n use ty::{self, TyCtxt};\n use lint;\n use errors::Applicability;\n@@ -364,7 +364,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir.get_parent(id);\n-        if let Some(NodeKind::Item(i)) = ir.tcx.hir.find(parent) {\n+        if let Some(Node::Item(i)) = ir.tcx.hir.find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }"}, {"sha": "b63cde0f205f78031363d851a4e6d718291f8620", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -70,7 +70,7 @@ use self::Aliasability::*;\n \n use middle::region;\n use hir::def_id::{DefId, LocalDefId};\n-use hir::map::NodeKind;\n+use hir::Node;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n@@ -343,7 +343,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n-            NodeKind::Binding(p) => match p.node {\n+            Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)"}, {"sha": "55ee8987e8ad54ccbe49313878ef403d7888e3b8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -16,7 +16,7 @@\n // reachable as well.\n \n use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n-use hir::map::NodeKind;\n+use hir::Node;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n@@ -64,7 +64,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n-            Some(NodeKind::Item(item)) =>\n+            Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n@@ -156,22 +156,22 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         };\n \n         match self.tcx.hir.find(node_id) {\n-            Some(NodeKind::Item(item)) => {\n+            Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n-            Some(NodeKind::TraitItem(trait_method)) => {\n+            Some(Node::TraitItem(trait_method)) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n-            Some(NodeKind::ImplItem(impl_item)) => {\n+            Some(Node::ImplItem(impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n@@ -219,12 +219,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &NodeKind<'tcx>,\n+    fn propagate_node(&mut self, node: &Node<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n-            if let NodeKind::Item(item) = *node {\n+            if let Node::Item(item) = *node {\n                 let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n                     header.abi != Abi::Rust\n                 } else {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n \n         match *node {\n-            NodeKind::Item(item) => {\n+            Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ItemKind::GlobalAsm(..) => {}\n                 }\n             }\n-            NodeKind::TraitItem(trait_method) => {\n+            Node::TraitItem(trait_method) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, None) |\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n-            NodeKind::ImplItem(impl_item) => {\n+            Node::ImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n@@ -313,16 +313,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n+            Node::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these\n-            NodeKind::ForeignItem(_) |\n-            NodeKind::Variant(_) |\n-            NodeKind::StructCtor(_) |\n-            NodeKind::Field(_) |\n-            NodeKind::Ty(_) |\n-            NodeKind::MacroDef(_) => {}\n+            Node::ForeignItem(_) |\n+            Node::Variant(_) |\n+            Node::StructCtor(_) |\n+            Node::Field(_) |\n+            Node::Ty(_) |\n+            Node::MacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "20ee5f0b04635fbc8dae8d5ca02c75da6f584da6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -30,7 +30,7 @@ use ty::TyCtxt;\n use ty::query::Providers;\n \n use hir;\n-use hir::map::NodeKind;\n+use hir::Node;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n@@ -258,7 +258,7 @@ impl Scope {\n         }\n         let span = tcx.hir.span(node_id);\n         if let ScopeData::Remainder(r) = self.data() {\n-            if let NodeKind::Block(ref blk) = tcx.hir.get(node_id) {\n+            if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -1421,8 +1421,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n         match tcx.hir.get(id) {\n-            NodeKind::ImplItem(_) |\n-            NodeKind::TraitItem(_) => {\n+            Node::ImplItem(_) |\n+            Node::TraitItem(_) => {\n                 visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n             }\n             _ => {}"}, {"sha": "d0f801e661b438d56bbff0798e8768a27b450e86", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -17,8 +17,8 @@\n \n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use hir::map::{NodeKind, Map};\n-use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName};\n+use hir::map::Map;\n+use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName, Node};\n use ty::{self, TyCtxt, GenericParamDefKind};\n \n use errors::DiagnosticBuilder;\n@@ -1440,10 +1440,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        NodeKind::Lifetime(hir_lifetime) => {\n+                        Node::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        NodeKind::GenericParam(param) => {\n+                        Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1466,10 +1466,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        NodeKind::Lifetime(hir_lifetime) => {\n+                        Node::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        NodeKind::GenericParam(param) => {\n+                        Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1643,15 +1643,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir.body_owner(body_id);\n                 match self.tcx.hir.get(fn_id) {\n-                    NodeKind::Item(&hir::Item {\n+                    Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n                     })\n-                    | NodeKind::TraitItem(&hir::TraitItem {\n+                    | Node::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(..),\n                         ..\n                     })\n-                    | NodeKind::ImplItem(&hir::ImplItem {\n+                    | Node::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n@@ -1868,12 +1868,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let parent = self.tcx.hir.get_parent_node(output.id);\n         let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n-            NodeKind::Item(&hir::Item {\n+            Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n-            NodeKind::TraitItem(&hir::TraitItem {\n+            Node::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n@@ -1896,7 +1896,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            NodeKind::ImplItem(&hir::ImplItem {\n+            Node::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n@@ -1918,7 +1918,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            NodeKind::ForeignItem(_) | NodeKind::Ty(_) | NodeKind::TraitRef(_) => None,\n+            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => None,\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {"}, {"sha": "b34378151ccb32c9ea25a2acfcb7d55cc28eec78", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -29,7 +29,7 @@ use super::{\n \n use errors::{Applicability, DiagnosticBuilder};\n use hir;\n-use hir::map::NodeKind;\n+use hir::Node;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n@@ -865,7 +865,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        err: &mut DiagnosticBuilder<'tcx>) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n             let parent_node = self.tcx.hir.get_parent_node(node_id);\n-            if let Some(NodeKind::Local(ref local)) = self.tcx.hir.find(parent_node) {\n+            if let Some(Node::Local(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -933,9 +933,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    pub fn get_fn_like_arguments(&self, node: NodeKind) -> (Span, Vec<ArgKind>) {\n+    pub fn get_fn_like_arguments(&self, node: Node) -> (Span, Vec<ArgKind>) {\n         match node {\n-            NodeKind::Expr(&hir::Expr {\n+            Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n@@ -962,17 +962,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     })\n                     .collect::<Vec<ArgKind>>())\n             }\n-            NodeKind::Item(&hir::Item {\n+            Node::Item(&hir::Item {\n                 span,\n                 node: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n-            NodeKind::ImplItem(&hir::ImplItem {\n+            Node::ImplItem(&hir::ImplItem {\n                 span,\n                 node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) |\n-            NodeKind::TraitItem(&hir::TraitItem {\n+            Node::TraitItem(&hir::TraitItem {\n                 span,\n                 node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n@@ -988,7 +988,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n                 }).collect::<Vec<ArgKind>>())\n             }\n-            NodeKind::Variant(&hir::Variant {\n+            Node::Variant(&hir::Variant {\n                 span,\n                 node: hir::VariantKind {\n                     data: hir::VariantData::Tuple(ref fields, _),\n@@ -1001,7 +1001,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n-            NodeKind::StructCtor(ref variant_data) => {\n+            Node::StructCtor(ref variant_data) => {\n                 (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n                  variant_data.fields()\n                     .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))"}, {"sha": "63308ac46d10f4b7b28eb3a9e77756f6f587a5a0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -15,7 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n use hir::{map as hir_map, FreevarMap, TraitMap};\n-use hir::map::NodeKind;\n+use hir::Node;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use hir::map::DefPathData;\n@@ -2479,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n-            Some(NodeKind::Expr(e)) => {\n+            Some(Node::Expr(e)) => {\n                 e.span\n             }\n             Some(f) => {\n@@ -2506,7 +2506,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n         let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n             match self.hir.get(node_id) {\n-                NodeKind::TraitItem(_) | NodeKind::ImplItem(_) => true,\n+                Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n         } else {\n@@ -2896,7 +2896,7 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition\n pub fn is_impl_trait_defn(tcx: TyCtxt, def_id: DefId) -> Option<DefId> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let NodeKind::Item(item) = tcx.hir.get(node_id) {\n+        if let Node::Item(item) = tcx.hir.get(node_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }"}, {"sha": "f7679dc8ce0f02470a71112fbecc92572b38038e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -12,8 +12,8 @@\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use hir::map::{DefPathData, NodeKind};\n-use hir;\n+use hir::map::DefPathData;\n+use hir::{self, Node};\n use ich::NodeIdHashingMode;\n use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n@@ -604,10 +604,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n-                NodeKind::Item(&hir::Item {\n+                Node::Item(&hir::Item {\n                     node: hir::ItemKind::Static(_, mutbl, _), ..\n                 }) => Some(mutbl),\n-                NodeKind::ForeignItem(&hir::ForeignItem {\n+                Node::ForeignItem(&hir::ForeignItem {\n                     node: hir::ForeignItemKind::Static(_, is_mutbl), ..\n                 }) =>\n                     Some(if is_mutbl {"}, {"sha": "1af117c97f569abbe829c82945a849bb40e262ed", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::{self, TyCtxt, RegionKind};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::rc::Rc;\n@@ -203,7 +203,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir.get(node_id) {\n-        NodeKind::Expr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,"}, {"sha": "ffc4fbfb4c9cb12839824eef37f04373f1dda358", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -24,7 +24,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::*;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n \n struct GatherMoveInfo<'c, 'tcx: 'c> {\n     id: hir::ItemLocalId,\n@@ -60,15 +60,15 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n     let parent = tcx.hir.get_parent_node(pat.id);\n \n     match tcx.hir.get(parent) {\n-        NodeKind::Expr(ref e) => {\n+        Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n                         ExprKind::Match(..) => true,\n                         _ => return PatternSource::Other,\n                     });\n             PatternSource::MatchExpr(e)\n         }\n-        NodeKind::Local(local) => PatternSource::LetDecl(local),\n+        Node::Local(local) => PatternSource::LetDecl(local),\n         _ => return PatternSource::Other,\n \n     }"}, {"sha": "ad45c5429a512b3214a1a6544673f471f2150a88", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -21,7 +21,7 @@ pub use self::MovedValueUseKind::*;\n use self::InteriorKind::*;\n \n use rustc::hir::HirId;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n@@ -95,8 +95,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n \n     match tcx.hir.get(owner_id) {\n-        NodeKind::StructCtor(_) |\n-        NodeKind::Variant(_) => {\n+        Node::StructCtor(_) |\n+        Node::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n@@ -419,7 +419,7 @@ fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n     let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n-        NodeKind::Expr(expr) => match expr.node {\n+        Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     let node =  self.tcx.hir.get(node_id);\n \n                     // This pattern probably always matches.\n-                    if let NodeKind::Expr(\n+                    if let Node::Expr(\n                         hir::Expr { node: hir::ExprKind::Index(lhs, _), ..}\n                     ) = node {\n                         let ty = self.tables.expr_ty(lhs);\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let ty::ReScope(scope) = *super_scope {\n                     let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n                     match self.tcx.hir.find(node_id) {\n-                        Some(NodeKind::Stmt(_)) => {\n+                        Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n                             }\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n-            NodeKind::Binding(pat) => pat,\n+            Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n \n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => return\n                 };\n \n-                if let NodeKind::Field(ref field) = self.tcx.hir.get(node_id) {\n+                if let Node::Field(ref field) = self.tcx.hir.get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }"}, {"sha": "6b1b0b94fd9d7f747eb5d701add7e67064f28aba", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -13,7 +13,7 @@ use std::sync::Arc;\n \n use monomorphize::Instance;\n use rustc::hir;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -95,7 +95,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n             match tcx.hir.get(node_id) {\n-                NodeKind::ForeignItem(..) => {\n+                Node::ForeignItem(..) => {\n                     let def_id = tcx.hir.local_def_id(node_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n@@ -105,14 +105,14 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n \n                 // Only consider nodes that actually have exported symbols.\n-                NodeKind::Item(&hir::Item {\n+                Node::Item(&hir::Item {\n                     node: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n-                NodeKind::Item(&hir::Item {\n+                Node::Item(&hir::Item {\n                     node: hir::ItemKind::Fn(..), ..\n                 }) |\n-                NodeKind::ImplItem(&hir::ImplItem {\n+                Node::ImplItem(&hir::ImplItem {\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {"}, {"sha": "522de2f15e0a95806b15fc2f3023b54a9ae3ed4b", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -11,7 +11,7 @@\n use libc::c_uint;\n use llvm::{self, SetUnnamedAddr, True};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use debuginfo;\n use base;\n use monomorphize::MonoItem;\n@@ -135,7 +135,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n-            NodeKind::Item(&hir::Item {\n+            Node::Item(&hir::Item {\n                 ref attrs, span, node: hir::ItemKind::Static(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n@@ -153,7 +153,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n                 (g, attrs)\n             }\n \n-            NodeKind::ForeignItem(&hir::ForeignItem {\n+            Node::ForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n                 let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);"}, {"sha": "39b88b225edc75c22da63a492b74d51fcf157f55", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -98,7 +98,7 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n@@ -261,7 +261,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n-            NodeKind::ForeignItem(_) => true,\n+            Node::ForeignItem(_) => true,\n             _ => false,\n         }\n     } else {"}, {"sha": "f715057541ffaa7476ef5ff2f49424344b8f7cd6", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -30,7 +30,7 @@ use std::vec::Vec;\n use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n use rustc::hir::{ItemKind as HirItem, ImplItemKind, TraitItemKind};\n-use rustc::hir::map::NodeKind as HirNode;\n+use rustc::hir::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n@@ -400,22 +400,22 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                         attr.span,\n                         &format!(\n                             \"clean/dirty auto-assertions not yet defined \\\n-                             for NodeKind::Item.node={:?}\",\n+                             for Node::Item.node={:?}\",\n                             item.node\n                         )\n                     ),\n                 }\n             },\n             HirNode::TraitItem(item) => {\n                 match item.node {\n-                    TraitItemKind::Method(..) => (\"NodeKind::TraitItem\", LABELS_FN_IN_TRAIT),\n+                    TraitItemKind::Method(..) => (\"Node::TraitItem\", LABELS_FN_IN_TRAIT),\n                     TraitItemKind::Const(..) => (\"NodeTraitConst\", LABELS_CONST_IN_TRAIT),\n                     TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n                 }\n             },\n             HirNode::ImplItem(item) => {\n                 match item.node {\n-                    ImplItemKind::Method(..) => (\"NodeKind::ImplItem\", LABELS_FN_IN_IMPL),\n+                    ImplItemKind::Method(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                     ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::Existential(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),"}, {"sha": "9b3dbe5bed6851dded0474246cad4e31e1ec2777", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -34,7 +34,7 @@ use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use rustc::traits;\n-use hir::map::NodeKind;\n+use hir::Node;\n use util::nodemap::NodeSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 let real_trait = trait_ref.path.def.def_id();\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n-                        Some(NodeKind::Item(item)) => {\n+                        Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n@@ -981,7 +981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match cx.tcx.hir.get(id) {\n-                NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n+                Node::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n                     let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             use rustc::ty::adjustment::*;\n \n             // Ignore non-expressions.\n-            let expr = if let NodeKind::Expr(e) = cx.tcx.hir.get(id) {\n+            let expr = if let Node::Expr(e) = cx.tcx.hir.get(id) {\n                 e\n             } else {\n                 return false;\n@@ -1864,7 +1864,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n                     if attr.name() == \"test\" {\n                         let parent = cx.tcx.hir.get_parent(it.id);\n                         match cx.tcx.hir.find(parent) {\n-                            Some(NodeKind::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n+                            Some(Node::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n                             None => {}\n                             _ => {\n                                 cx.struct_span_lint("}, {"sha": "2c410e8efb10a65fb0e852b92a83eed75954a6b7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_snake_case)]\n \n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf};\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n-                            if let NodeKind::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                            if let Node::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint("}, {"sha": "16d34082642bd57aa137b486e50bf114529ab59a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -12,7 +12,7 @@\n \n use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n@@ -233,7 +233,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     let movable_generator = match tcx.hir.get(id) {\n-        NodeKind::Expr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,"}, {"sha": "f96ef909c0df8ace584c08ca153c59455446e851", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Mir};\n use rustc::mir::{Mutability, Place, Projection, ProjectionElem, Static};\n use rustc::ty::{self, TyCtxt};\n@@ -247,7 +247,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     .var_hir_id\n                     .assert_crate_local();\n                 let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(NodeKind::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                if let Some(Node::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,"}, {"sha": "f178ea8bdbab12c63d5ca8eaeb7450993b200f4b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -14,7 +14,7 @@ use build::scope::{CachedBlock, DropKind};\n use hair::cx::Cx;\n use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -41,9 +41,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let body_id = match tcx.hir.get(id) {\n-        NodeKind::Variant(variant) =>\n+        Node::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n-        NodeKind::StructCtor(ctor) =>\n+        Node::StructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n \n         _ => match tcx.hir.maybe_body_owned_by(id) {\n@@ -521,7 +521,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref,\n                 mutability: Mutability::Not,\n             };\n-            if let Some(NodeKind::Binding(pat)) = tcx.hir.find(var_id) {\n+            if let Some(Node::Binding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n "}, {"sha": "c9fd1d04e547b7f0a8a8b1d4a1e9562cc00c3dbc", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -19,7 +19,7 @@ use hair::*;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let p = match tcx.hir.get(p.id) {\n-            NodeKind::Pat(p) | NodeKind::Binding(p) => p,\n+            Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n         Pattern::from_hir(tcx,"}, {"sha": "f19c4532b47d88c0a6767ec8ead7f34a441440db", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -191,7 +191,7 @@\n use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{AllocId, ConstValue, ScalarMaybeUndef};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -740,7 +740,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n     };\n \n     return match tcx.hir.get_if_local(def_id) {\n-        Some(NodeKind::ForeignItem(..)) => {\n+        Some(Node::ForeignItem(..)) => {\n             false // foreign items are linked against, not codegened.\n         }\n         Some(_) => true,"}, {"sha": "6efefdaa004008e66e52d9e3daad3b5b3efcbf4a", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -85,7 +85,7 @@ fn place_context<'a, 'tcx, D>(\n fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n     use rustc::hir::intravisit::{self, Visitor, FnKind};\n     use rustc::hir::map::blocks::FnLikeNode;\n-    use rustc::hir::map::NodeKind;\n+    use rustc::hir::Node;\n \n     /// Decide if this is an unsafe block\n     fn block_is_unsafe(block: &hir::Block) -> bool {\n@@ -142,13 +142,13 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n             }\n             // Check if this is an unsafe block, or an item\n             match node {\n-                NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n+                Node::Expr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n                     if block_is_unsafe(&*block) {\n                         // Found an unsafe block, we can bail out here.\n                         return true;\n                     }\n                 }\n-                NodeKind::Item(..) => {\n+                Node::Item(..) => {\n                     // No walking up beyond items.  This makes sure the loop always terminates.\n                     break;\n                 }"}, {"sha": "f6006ae045ee787e238d520d2c2836378fafab30", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n use rustc::mir::*;\n@@ -408,7 +408,7 @@ fn is_enclosed(tcx: TyCtxt,\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n-        } else if let Some(NodeKind::Item(&hir::Item {\n+        } else if let Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {"}, {"sha": "44030c284fd812227b8d550e7e8a4aafd60ae62b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -11,9 +11,9 @@ use self::Context::*;\n \n use rustc::session::Session;\n \n-use rustc::hir::map::{Map, NodeKind};\n+use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Destination};\n+use rustc::hir::{self, Node, Destination};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -115,7 +115,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 if loop_id != ast::DUMMY_NODE_ID {\n                     match self.hir_map.find(loop_id).unwrap() {\n-                        NodeKind::Block(_) => return,\n+                        Node::Block(_) => return,\n                         _=> (),\n                     }\n                 }\n@@ -158,7 +158,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 match label.target_id {\n                     Ok(loop_id) => {\n-                        if let NodeKind::Block(block) = self.hir_map.find(loop_id).unwrap() {\n+                        if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n                                             \"`continue` pointing to a labeled block\")\n                                 .span_label(e.span,"}, {"sha": "5166f69ba03304c49572d760cb514139184e2436", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -25,7 +25,7 @@ extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n use rustc::hir::{self, PatKind};\n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -660,17 +660,17 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         match self.tcx.hir.as_local_node_id(did) {\n             Some(node_id) => {\n                 let vis = match self.tcx.hir.get(node_id) {\n-                    NodeKind::Item(item) => &item.vis,\n-                    NodeKind::ForeignItem(foreign_item) => &foreign_item.vis,\n-                    NodeKind::ImplItem(impl_item) => &impl_item.vis,\n-                    NodeKind::TraitItem(..) |\n-                    NodeKind::Variant(..) => {\n+                    Node::Item(item) => &item.vis,\n+                    Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                    Node::ImplItem(impl_item) => &impl_item.vis,\n+                    Node::TraitItem(..) |\n+                    Node::Variant(..) => {\n                         return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n                     }\n-                    NodeKind::StructCtor(vdata) => {\n+                    Node::StructCtor(vdata) => {\n                         let struct_node_id = self.tcx.hir.get_parent(node_id);\n                         let struct_vis = match self.tcx.hir.get(struct_node_id) {\n-                            NodeKind::Item(item) => &item.vis,\n+                            Node::Item(item) => &item.vis,\n                             node => bug!(\"unexpected node kind: {:?}\", node),\n                         };\n                         let mut ctor_vis\n@@ -1038,7 +1038,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.hir.find(node_id) {\n-                Some(NodeKind::Item(ref item)) => !item.vis.node.is_pub(),\n+                Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1470,8 +1470,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let hir_vis = match self.tcx.hir.find(node_id) {\n-                    Some(NodeKind::Item(item)) => &item.vis,\n-                    Some(NodeKind::ForeignItem(item)) => &item.vis,\n+                    Some(Node::Item(item)) => &item.vis,\n+                    Some(Node::ForeignItem(item)) => &item.vis,\n                     _ => bug!(\"expected item of foreign item\"),\n                 };\n "}, {"sha": "fd29dac5af8cc87a72e62767698067eaee508f15", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -43,7 +43,7 @@ mod sig;\n \n use rustc::hir;\n use rustc::hir::def::Def as HirDef;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::ExternCrate;\n use rustc::session::config::CrateType;\n@@ -420,7 +420,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n             match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n                 Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n-                    Some(NodeKind::Item(item)) => match item.node {\n+                    Some(Node::Item(item)) => match item.node {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n@@ -429,7 +429,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut decl_id = None;\n                             let mut docs = String::new();\n                             let mut attrs = vec![];\n-                            if let Some(NodeKind::ImplItem(item)) = self.tcx.hir.find(id) {\n+                            if let Some(Node::ImplItem(item)) = self.tcx.hir.find(id) {\n                                 docs = self.docs_for_attrs(&item.attrs);\n                                 attrs = item.attrs.to_vec();\n                             }\n@@ -471,7 +471,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n \n-                        if let Some(NodeKind::TraitItem(item)) = self.tcx.hir.find(id) {\n+                        if let Some(Node::TraitItem(item)) = self.tcx.hir.find(id) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -541,7 +541,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let hir_node = match self.tcx.hir.find(sub_ex.id) {\n-                    Some(NodeKind::Expr(expr)) => expr,\n+                    Some(Node::Expr(expr)) => expr,\n                     _ => {\n                         debug!(\n                             \"Missing or weird node for sub-expression {} in {:?}\",\n@@ -628,45 +628,45 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_path_def(&self, id: NodeId) -> HirDef {\n         match self.tcx.hir.get(id) {\n-            NodeKind::TraitRef(tr) => tr.path.def,\n+            Node::TraitRef(tr) => tr.path.def,\n \n-            NodeKind::Item(&hir::Item {\n+            Node::Item(&hir::Item {\n                 node: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n-            NodeKind::Visibility(&Spanned {\n+            Node::Visibility(&Spanned {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n-            NodeKind::Expr(&hir::Expr {\n+            Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n-            NodeKind::Expr(&hir::Expr {\n+            Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n-            NodeKind::Pat(&hir::Pat {\n+            Node::Pat(&hir::Pat {\n                 node: hir::PatKind::Path(ref qpath),\n                 ..\n             }) |\n-            NodeKind::Pat(&hir::Pat {\n+            Node::Pat(&hir::Pat {\n                 node: hir::PatKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n-            NodeKind::Pat(&hir::Pat {\n+            Node::Pat(&hir::Pat {\n                 node: hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             }) => {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 self.tables.qpath_def(qpath, hir_id)\n             }\n \n-            NodeKind::Binding(&hir::Pat {\n+            Node::Binding(&hir::Pat {\n                 node: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n             }) => HirDef::Local(canonical_id),\n \n-            NodeKind::Ty(ty) => if let hir::Ty {\n+            Node::Ty(ty) => if let hir::Ty {\n                 node: hir::TyKind::Path(ref qpath),\n                 ..\n             } = *ty"}, {"sha": "85646b9ab675af19da19ce9ce470e30aa9a47326", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -17,7 +17,7 @@ use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n@@ -199,13 +199,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir.get_parent_node(id);\n-                if let Some(NodeKind::Expr(hir::Expr {\n+                if let Some(Node::Expr(hir::Expr {\n                     id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir.find(parent) {\n                     let parent = self.tcx.hir.get_parent_node(*id);\n-                    if let (Some(NodeKind::Expr(hir::Expr {\n+                    if let (Some(Node::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n@@ -377,7 +377,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.find(parent_id) {\n             Some(parent) => {\n                 // Shouldn't suggest `.into()` on `const`s.\n-                if let NodeKind::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n+                if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                     // FIXME(estebank): modify once we decide to suggest `as` casts\n                     return false;\n                 }"}, {"sha": "abc32ed2ea0433d2576dac7fd5e86d0f2f0f029e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -13,7 +13,7 @@\n \n use check::FnCtxt;\n use rustc::hir::map as hir_map;\n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc_data_structures::sync::Lrc;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         );\n \n                                         match (filename, parent_node) {\n-                                            (FileName::Real(_), NodeKind::Local(hir::Local {\n+                                            (FileName::Real(_), Node::Local(hir::Local {\n                                                 source: hir::LocalSource::Normal,\n                                                 ty,\n                                                 .."}, {"sha": "bbb45c04e4e9823d2ba8aed0c79c994c2b2c8fbe", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -132,7 +132,7 @@ use syntax_pos::{self, BytePos, Span, MultiSpan};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::{self, PatKind, ItemKind};\n use rustc::middle::lang_items;\n \n@@ -761,7 +761,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n     match tcx.hir.get(id) {\n-        NodeKind::Item(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n                 hir::ItemKind::Static(_, _, body) =>\n@@ -772,7 +772,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        NodeKind::TraitItem(item) => {\n+        Node::TraitItem(item) => {\n             match item.node {\n                 hir::TraitItemKind::Const(_, Some(body)) =>\n                     Some((body, None)),\n@@ -782,7 +782,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        NodeKind::ImplItem(item) => {\n+        Node::ImplItem(item) => {\n             match item.node {\n                 hir::ImplItemKind::Const(_, body) =>\n                     Some((body, None)),\n@@ -792,7 +792,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        NodeKind::AnonConst(constant) => Some((constant.body, None)),\n+        Node::AnonConst(constant) => Some((constant.body, None)),\n         _ => None,\n     }\n }\n@@ -1167,7 +1167,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let NodeKind::Item(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir.get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1214,7 +1214,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let NodeKind::Item(item) = fcx.tcx.hir.get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir.get(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -4646,7 +4646,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(fn_id) = self.tcx.hir.get_return_block(blk_id) {\n             let parent = self.tcx.hir.get(fn_id);\n \n-            if let NodeKind::Item(&hir::Item {\n+            if let Node::Item(&hir::Item {\n                 name, node: hir::ItemKind::Fn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n@@ -4655,15 +4655,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // but it will still present it as the reason for the expected type.\n                     Some((decl, name != Symbol::intern(\"main\")))\n                 })\n-            } else if let NodeKind::TraitItem(&hir::TraitItem {\n+            } else if let Node::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     Some((decl, true))\n                 })\n-            } else if let NodeKind::ImplItem(&hir::ImplItem {\n+            } else if let Node::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n@@ -5174,7 +5174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n         match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n-            NodeKind::Expr(expr) => {\n+            Node::Expr(expr) => {\n                 match expr.node {\n                     hir::ExprKind::Call(ref callee, ..) => {\n                         if callee.id == node_id {"}, {"sha": "efc35fad820c820c8c52924be8729e890ad1ba81", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n \n use rustc::hir::def_id::DefId;\n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::hir::{self, ItemKind};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n@@ -60,7 +60,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n                 match tcx.hir.find(impl_node_id) {\n-                    Some(NodeKind::Item(item)) => {\n+                    Some(Node::Item(item)) => {\n                         let span = match item.node {\n                             ItemKind::Impl(.., ref ty, _) => ty.span,\n                             _ => item.span,"}, {"sha": "a42667ab45fc8726993b72d44000b4054f6ff702", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -50,7 +50,7 @@ use syntax::symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Def};\n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n@@ -239,7 +239,6 @@ fn type_param_predicates<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (item_def_id, def_id): (DefId, DefId),\n ) -> ty::GenericPredicates<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n@@ -273,11 +272,11 @@ fn type_param_predicates<'a, 'tcx>(\n \n     let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n     let ast_generics = match tcx.hir.get(item_node_id) {\n-        NodeKind::TraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => &item.generics,\n \n-        NodeKind::ImplItem(item) => &item.generics,\n+        Node::ImplItem(item) => &item.generics,\n \n-        NodeKind::Item(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n@@ -303,7 +302,7 @@ fn type_param_predicates<'a, 'tcx>(\n             }\n         }\n \n-        NodeKind::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             _ => return result,\n         },\n@@ -596,12 +595,11 @@ fn convert_struct_variant<'a, 'tcx>(\n }\n \n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = match tcx.hir.get(node_id) {\n-        NodeKind::Item(item) => item,\n+        Node::Item(item) => item,\n         _ => bug!(),\n     };\n \n@@ -672,7 +670,7 @@ fn super_predicates_of<'a, 'tcx>(\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n     let item = match tcx.hir.get(trait_node_id) {\n-        NodeKind::Item(item) => item,\n+        Node::Item(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n     };\n \n@@ -741,7 +739,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n \n fn has_late_bound_regions<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    node: NodeKind<'tcx>,\n+    node: Node<'tcx>,\n ) -> Option<Span> {\n     struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -827,25 +825,25 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n \n     match node {\n-        NodeKind::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        NodeKind::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        NodeKind::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        NodeKind::Item(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n@@ -856,23 +854,22 @@ fn has_late_bound_regions<'a, 'tcx>(\n }\n \n fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let node = tcx.hir.get(node_id);\n     let parent_def_id = match node {\n-        NodeKind::ImplItem(_) | NodeKind::TraitItem(_) | NodeKind::Variant(_)\n-        | NodeKind::StructCtor(_) | NodeKind::Field(_) => {\n+        Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_)\n+        | Node::StructCtor(_) | Node::Field(_) => {\n             let parent_id = tcx.hir.get_parent(node_id);\n             Some(tcx.hir.local_def_id(parent_id))\n         }\n-        NodeKind::Expr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n-        NodeKind::Item(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n@@ -884,11 +881,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n     let no_generics = hir::Generics::empty();\n     let ast_generics = match node {\n-        NodeKind::TraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => &item.generics,\n \n-        NodeKind::ImplItem(item) => &item.generics,\n+        Node::ImplItem(item) => &item.generics,\n \n-        NodeKind::Item(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     generics\n@@ -931,7 +928,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             }\n         }\n \n-        NodeKind::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1026,7 +1023,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeKind::Expr(&hir::Expr {\n+    if let Node::Expr(&hir::Expr {\n         node: hir::ExprKind::Closure(.., gen),\n         ..\n     }) = node\n@@ -1096,15 +1093,14 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n }\n \n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeKind::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1115,7 +1111,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeKind::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             ImplItemKind::Method(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1143,7 +1139,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeKind::Item(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Static(ref t, ..)\n                 | ItemKind::Const(ref t, _)\n@@ -1201,7 +1197,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         }\n \n-        NodeKind::ForeignItem(foreign_item) => match foreign_item.node {\n+        Node::ForeignItem(foreign_item) => match foreign_item.node {\n             ForeignItemKind::Fn(..) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1210,8 +1206,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        NodeKind::StructCtor(&ref def)\n-        | NodeKind::Variant(&Spanned {\n+        Node::StructCtor(&ref def)\n+        | Node::Variant(&Spanned {\n             node: hir::VariantKind { data: ref def, .. },\n             ..\n         }) => match *def {\n@@ -1224,9 +1220,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeKind::Field(field) => icx.to_ty(&field.ty),\n+        Node::Field(field) => icx.to_ty(&field.ty),\n \n-        NodeKind::Expr(&hir::Expr {\n+        Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., gen),\n             ..\n         }) => {\n@@ -1242,24 +1238,24 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        NodeKind::AnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeKind::Ty(&hir::Ty {\n+        Node::AnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n+            Node::Ty(&hir::Ty {\n                 node: hir::TyKind::Array(_, ref constant),\n                 ..\n             })\n-            | NodeKind::Ty(&hir::Ty {\n+            | Node::Ty(&hir::Ty {\n                 node: hir::TyKind::Typeof(ref constant),\n                 ..\n             })\n-            | NodeKind::Expr(&hir::Expr {\n+            | Node::Expr(&hir::Expr {\n                 node: ExprKind::Repeat(_, ref constant),\n                 ..\n             }) if constant.id == node_id =>\n             {\n                 tcx.types.usize\n             }\n \n-            NodeKind::Variant(&Spanned {\n+            Node::Variant(&Spanned {\n                 node:\n                     VariantKind {\n                         disr_expr: Some(ref e),\n@@ -1279,7 +1275,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             }\n         },\n \n-        NodeKind::GenericParam(param) => match param.kind {\n+        Node::GenericParam(param) => match param.kind {\n             hir::GenericParamKind::Type {\n                 default: Some(ref ty),\n                 ..\n@@ -1297,7 +1293,6 @@ fn find_existential_constraints<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> ty::Ty<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     struct ConstraintLocator<'a, 'tcx: 'a> {\n@@ -1377,9 +1372,9 @@ fn find_existential_constraints<'a, 'tcx>(\n     } else {\n         trace!(\"parent: {:?}\", tcx.hir.get(parent));\n         match tcx.hir.get(parent) {\n-            NodeKind::Item(ref it) => intravisit::walk_item(&mut locator, it),\n-            NodeKind::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n-            NodeKind::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n+            Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n+            Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n+            Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\n                 \"{:?} is not a valid parent of an existential type item\",\n                 other\n@@ -1398,7 +1393,7 @@ fn find_existential_constraints<'a, 'tcx>(\n \n fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n     use rustc::hir::*;\n-    use rustc::hir::map::NodeKind::*;\n+    use rustc::hir::Node::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n@@ -1627,7 +1622,6 @@ fn explicit_predicates_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> ty::GenericPredicates<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n \n     debug!(\"explicit_predicates_of(def_id={:?})\", def_id);\n@@ -1644,9 +1638,9 @@ fn explicit_predicates_of<'a, 'tcx>(\n     let mut predicates = vec![];\n \n     let ast_generics = match node {\n-        NodeKind::TraitItem(item) => &item.generics,\n+        Node::TraitItem(item) => &item.generics,\n \n-        NodeKind::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             ImplItemKind::Existential(ref bounds) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n                 let anon_ty = tcx.mk_anon(def_id, substs);\n@@ -1666,7 +1660,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             _ => &item.generics,\n         },\n \n-        NodeKind::Item(item) => {\n+        Node::Item(item) => {\n             match item.node {\n                 ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n@@ -1718,7 +1712,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             }\n         }\n \n-        NodeKind::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1878,7 +1872,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let NodeKind::Item(&Item {\n+    if let Node::Item(&Item {\n         node: ItemKind::Impl(..),\n         ..\n     }) = node\n@@ -2028,7 +2022,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir.get_if_local(def_id) {\n-        Some(NodeKind::ForeignItem(..)) => true,\n+        Some(Node::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }"}, {"sha": "e31ae8eb8c7aecde6624fc02756c9e4cc32eef66", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -103,7 +103,7 @@ use rustc::middle;\n use rustc::session;\n use rustc::util;\n \n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -187,7 +187,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match main_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(main_id) {\n-                Some(NodeKind::Item(it)) => {\n+                Some(Node::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n@@ -259,7 +259,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match start_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(start_id) {\n-                Some(NodeKind::Item(it)) => {\n+                Some(Node::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;"}, {"sha": "092e4d62e2e9fa5724d4618bea8f6bf957897cb8", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n@@ -71,7 +71,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n             .as_local_node_id(item_did)\n             .expect(\"expected local def-id\");\n         let item = match self.tcx.hir.get(node_id) {\n-            NodeKind::Item(item) => item,\n+            Node::Item(item) => item,\n             _ => bug!(),\n         };\n "}, {"sha": "63a424936eb4c75d9ac08fec999dbbc882c51b04", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::query::Providers;\n@@ -40,7 +40,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n         .expect(\"expected local def-id\");\n \n     match tcx.hir.get(id) {\n-        NodeKind::Item(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n "}, {"sha": "aaa0fd8e099efa47c492f1987ccdfc57853bd0dd", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -15,7 +15,7 @@\n \n use arena;\n use rustc::hir;\n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n use rustc::ty::query::Providers;\n@@ -62,7 +62,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n         span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir.get(id) {\n-        NodeKind::Item(item) => match item.node {\n+        Node::Item(item) => match item.node {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n@@ -71,25 +71,25 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             _ => unsupported()\n         },\n \n-        NodeKind::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        NodeKind::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        NodeKind::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },\n \n-        NodeKind::Variant(_) | NodeKind::StructCtor(_) => {}\n+        Node::Variant(_) | Node::StructCtor(_) => {}\n \n         _ => unsupported()\n     }"}, {"sha": "451e24d6c0dc938ecf90a79c4bdb6462a388ba23", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -18,7 +18,7 @@ use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n-use rustc::hir::map::NodeKind;\n+use rustc::hir::Node;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n@@ -295,7 +295,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n         let ret = match tcx.hir.get(def_node_id) {\n-            NodeKind::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n+            Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir.expect_item(i.id);\n@@ -304,13 +304,13 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 self.inlining = prev;\n                 true\n             }\n-            NodeKind::Item(it) if !glob => {\n+            Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 self.visit_item(it, renamed, om);\n                 self.inlining = prev;\n                 true\n             }\n-            NodeKind::ForeignItem(it) if !glob => {\n+            Node::ForeignItem(it) if !glob => {\n                 // generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n                     abi: tcx.hir.get_foreign_abi(it.id),"}, {"sha": "f525e0f082a44b723facd5f3f5aae20274762a8a", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=e2a1cce9c558fe84ef5a2b8e3b07f1ee1521694a", "patch": "@@ -27,7 +27,7 @@ use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::map as hir_map;\n-use hir::map::NodeKind;\n+use hir::Node;\n use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n use rustc::ty;\n use syntax::{ast, source_map};\n@@ -59,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 id: ast::NodeId) {\n \n         let item = match cx.tcx.hir.get(id) {\n-            NodeKind::Item(item) => item,\n+            Node::Item(item) => item,\n             _ => cx.tcx.hir.expect_item(cx.tcx.hir.get_parent(id)),\n         };\n "}]}