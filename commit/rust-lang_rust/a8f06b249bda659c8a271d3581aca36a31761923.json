{"sha": "a8f06b249bda659c8a271d3581aca36a31761923", "node_id": "C_kwDOAAsO6NoAKGE4ZjA2YjI0OWJkYTY1OWM4YTI3MWQzNTgxYWNhMzZhMzE3NjE5MjM", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-28T13:54:11Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-28T13:54:11Z"}, "message": "Move some functions into `rustc_infer`.\nThey don't depend on trait selection anymore, so there is no need for an extension trait.", "tree": {"sha": "d3776508ae56887a247edb5d919d9b7026414c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3776508ae56887a247edb5d919d9b7026414c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8f06b249bda659c8a271d3581aca36a31761923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f06b249bda659c8a271d3581aca36a31761923", "html_url": "https://github.com/rust-lang/rust/commit/a8f06b249bda659c8a271d3581aca36a31761923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8f06b249bda659c8a271d3581aca36a31761923/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "849b73b8d9f563bfc64ce0e4c311347a4263f258", "url": "https://api.github.com/repos/rust-lang/rust/commits/849b73b8d9f563bfc64ce0e4c311347a4263f258", "html_url": "https://github.com/rust-lang/rust/commit/849b73b8d9f563bfc64ce0e4c311347a4263f258"}], "stats": {"total": 634, "additions": 316, "deletions": 318}, "files": [{"sha": "25489b736139974a3c0514464492469f90e9db60", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 315, "deletions": 1, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/a8f06b249bda659c8a271d3581aca36a31761923/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f06b249bda659c8a271d3581aca36a31761923/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=a8f06b249bda659c8a271d3581aca36a31761923", "patch": "@@ -1,8 +1,13 @@\n+use crate::infer::InferCtxt;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_middle::ty::{OpaqueTypeKey, Ty};\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n+use std::ops::ControlFlow;\n+\n pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we\n@@ -45,3 +50,312 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// The origin of the opaque type.\n     pub origin: hir::OpaqueTyOrigin,\n }\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    /// Given the map `opaque_types` containing the opaque\n+    /// `impl Trait` types whose underlying, hidden types are being\n+    /// inferred, this method adds constraints to the regions\n+    /// appearing in those underlying hidden types to ensure that they\n+    /// at least do not refer to random scopes within the current\n+    /// function. These constraints are not (quite) sufficient to\n+    /// guarantee that the regions are actually legal values; that\n+    /// final condition is imposed after region inference is done.\n+    ///\n+    /// # The Problem\n+    ///\n+    /// Let's work through an example to explain how it works. Assume\n+    /// the current function is as follows:\n+    ///\n+    /// ```text\n+    /// fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    /// ```\n+    ///\n+    /// Here, we have two `impl Trait` types whose values are being\n+    /// inferred (the `impl Bar<'a>` and the `impl\n+    /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n+    /// define underlying opaque types (`Foo1`, `Foo2`) and then, in\n+    /// the return type of `foo`, we *reference* those definitions:\n+    ///\n+    /// ```text\n+    /// type Foo1<'x> = impl Bar<'x>;\n+    /// type Foo2<'x> = impl Bar<'x>;\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///                    //  ^^^^ ^^\n+    ///                    //  |    |\n+    ///                    //  |    substs\n+    ///                    //  def_id\n+    /// ```\n+    ///\n+    /// As indicating in the comments above, each of those references\n+    /// is (in the compiler) basically a substitution (`substs`)\n+    /// applied to the type of a suitable `def_id` (which identifies\n+    /// `Foo1` or `Foo2`).\n+    ///\n+    /// Now, at this point in compilation, what we have done is to\n+    /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n+    /// fresh inference variables C1 and C2. We wish to use the values\n+    /// of these variables to infer the underlying types of `Foo1` and\n+    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n+    /// constraints like:\n+    ///\n+    /// ```text\n+    /// for<'a> (Foo1<'a> = C1)\n+    /// for<'b> (Foo1<'b> = C2)\n+    /// ```\n+    ///\n+    /// For these equation to be satisfiable, the types `C1` and `C2`\n+    /// can only refer to a limited set of regions. For example, `C1`\n+    /// can only refer to `'static` and `'a`, and `C2` can only refer\n+    /// to `'static` and `'b`. The job of this function is to impose that\n+    /// constraint.\n+    ///\n+    /// Up to this point, C1 and C2 are basically just random type\n+    /// inference variables, and hence they may contain arbitrary\n+    /// regions. In fact, it is fairly likely that they do! Consider\n+    /// this possible definition of `foo`:\n+    ///\n+    /// ```text\n+    /// fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n+    ///         (&*x, &*y)\n+    ///     }\n+    /// ```\n+    ///\n+    /// Here, the values for the concrete types of the two impl\n+    /// traits will include inference variables:\n+    ///\n+    /// ```text\n+    /// &'0 i32\n+    /// &'1 i32\n+    /// ```\n+    ///\n+    /// Ordinarily, the subtyping rules would ensure that these are\n+    /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n+    /// type per se, we don't get such constraints by default. This\n+    /// is where this function comes into play. It adds extra\n+    /// constraints to ensure that all the regions which appear in the\n+    /// inferred type are regions that could validly appear.\n+    ///\n+    /// This is actually a bit of a tricky constraint in general. We\n+    /// want to say that each variable (e.g., `'0`) can only take on\n+    /// values that were supplied as arguments to the opaque type\n+    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n+    /// scope. We don't have a constraint quite of this kind in the current\n+    /// region checker.\n+    ///\n+    /// # The Solution\n+    ///\n+    /// We generally prefer to make `<=` constraints, since they\n+    /// integrate best into the region solver. To do that, we find the\n+    /// \"minimum\" of all the arguments that appear in the substs: that\n+    /// is, some region which is less than all the others. In the case\n+    /// of `Foo1<'a>`, that would be `'a` (it's the only choice, after\n+    /// all). Then we apply that as a least bound to the variables\n+    /// (e.g., `'a <= '0`).\n+    ///\n+    /// In some cases, there is no minimum. Consider this example:\n+    ///\n+    /// ```text\n+    /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    /// ```\n+    ///\n+    /// Here we would report a more complex \"in constraint\", like `'r\n+    /// in ['a, 'b, 'static]` (where `'r` is some region appearing in\n+    /// the hidden type).\n+    ///\n+    /// # Constrain regions, not the hidden concrete type\n+    ///\n+    /// Note that generating constraints on each region `Rc` is *not*\n+    /// the same as generating an outlives constraint on `Tc` iself.\n+    /// For example, if we had a function like this:\n+    ///\n+    /// ```rust\n+    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n+    ///   (x, y)\n+    /// }\n+    ///\n+    /// // Equivalent to:\n+    /// type FooReturn<'a, T> = impl Foo<'a>;\n+    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n+    /// ```\n+    ///\n+    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n+    /// is an inference variable). If we generated a constraint that\n+    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n+    /// but this is not necessary, because the opaque type we\n+    /// create will be allowed to reference `T`. So we only generate a\n+    /// constraint that `'0: 'a`.\n+    ///\n+    /// # The `free_region_relations` parameter\n+    ///\n+    /// The `free_region_relations` argument is used to find the\n+    /// \"minimum\" of the regions supplied to a given opaque type.\n+    /// It must be a relation that can answer whether `'a <= 'b`,\n+    /// where `'a` and `'b` are regions that appear in the \"substs\"\n+    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n+    ///\n+    /// Note that we do not impose the constraints based on the\n+    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n+    /// is because the constraints we are imposing here is basically\n+    /// the concern of the one generating the constraining type C1,\n+    /// which is the current function. It also means that we can\n+    /// take \"implied bounds\" into account in some cases:\n+    ///\n+    /// ```text\n+    /// trait SomeTrait<'a, 'b> { }\n+    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    /// ```\n+    ///\n+    /// Here, the fact that `'b: 'a` is known only because of the\n+    /// implied bounds from the `&'a &'b u32` parameter, and is not\n+    /// \"inherent\" to the opaque type definition.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n+    /// - `free_region_relations` -- something that can be used to relate\n+    ///   the free regions (`'a`) that appear in the impl trait.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub fn constrain_opaque_type(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+    ) {\n+        let def_id = opaque_type_key.def_id;\n+\n+        let tcx = self.tcx;\n+\n+        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n+\n+        debug!(?concrete_ty);\n+\n+        let first_own_region = match opaque_defn.origin {\n+            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+                // We lower\n+                //\n+                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                //\n+                // into\n+                //\n+                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                //\n+                // For these types we only iterate over `'l0..lm` below.\n+                tcx.generics_of(def_id).parent_count\n+            }\n+            // These opaque type inherit all lifetime parameters from their\n+            // parent, so we have to check them all.\n+            hir::OpaqueTyOrigin::TyAlias => 0,\n+        };\n+\n+        // For a case like `impl Foo<'a, 'b>`, we would generate a constraint\n+        // `'r in ['a, 'b, 'static]` for each region `'r` that appears in the\n+        // hidden type (i.e., it must be equal to `'a`, `'b`, or `'static`).\n+        //\n+        // `conflict1` and `conflict2` are the two region bounds that we\n+        // detected which were unrelated. They are used for diagnostics.\n+\n+        // Create the set of choice regions: each region in the hidden\n+        // type can be equal to any of the region parameters of the\n+        // opaque type definition.\n+        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n+            opaque_type_key.substs[first_own_region..]\n+                .iter()\n+                .filter_map(|arg| match arg.unpack() {\n+                    GenericArgKind::Lifetime(r) => Some(r),\n+                    GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n+                })\n+                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n+                .collect(),\n+        );\n+\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| {\n+                self.member_constraint(\n+                    opaque_type_key.def_id,\n+                    opaque_defn.definition_span,\n+                    concrete_ty,\n+                    r,\n+                    &choice_regions,\n+                )\n+            },\n+        });\n+    }\n+}\n+\n+// Visitor that requires that (almost) all regions in the type visited outlive\n+// `least_region`. We cannot use `push_outlives_components` because regions in\n+// closure signatures are not included in their outlives components. We need to\n+// ensure all regions outlive the given bound so that we don't end up with,\n+// say, `ReVar` appearing in a return type and causing ICEs when other\n+// functions end up with region constraints involving regions from other\n+// functions.\n+//\n+// We also cannot use `for_each_free_region` because for closures it includes\n+// the regions parameters from the enclosing item.\n+//\n+// We ignore any type parameters because impl trait values are assumed to\n+// capture all the in-scope type parameters.\n+struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n+    tcx: TyCtxt<'tcx>,\n+    op: OP,\n+}\n+\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+where\n+    OP: FnMut(ty::Region<'tcx>),\n+{\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &ty::Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        t.as_ref().skip_binder().visit_with(self);\n+        ControlFlow::CONTINUE\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match *r {\n+            // ignore bound regions, keep visiting\n+            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n+            _ => {\n+                (self.op)(r);\n+                ControlFlow::CONTINUE\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // We're only interested in types involving regions\n+        if !ty.flags().intersects(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n+            return ControlFlow::CONTINUE;\n+        }\n+\n+        match ty.kind() {\n+            ty::Closure(_, ref substs) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+\n+                substs.as_closure().tupled_upvars_ty().visit_with(self);\n+                substs.as_closure().sig_as_fn_ptr_ty().visit_with(self);\n+            }\n+\n+            ty::Generator(_, ref substs, _) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+                // Also skip the witness type, because that has no free regions.\n+\n+                substs.as_generator().tupled_upvars_ty().visit_with(self);\n+                substs.as_generator().return_ty().visit_with(self);\n+                substs.as_generator().yield_ty().visit_with(self);\n+                substs.as_generator().resume_ty().visit_with(self);\n+            }\n+            _ => {\n+                ty.super_visit_with(self);\n+            }\n+        }\n+\n+        ControlFlow::CONTINUE\n+    }\n+}"}, {"sha": "3be5f2e59dbec0aaba053045f4a262fd5172fe5d", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 317, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/a8f06b249bda659c8a271d3581aca36a31761923/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f06b249bda659c8a271d3581aca36a31761923/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=a8f06b249bda659c8a271d3581aca36a31761923", "patch": "@@ -1,19 +1,16 @@\n use crate::traits::{self, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferCtxt, InferOk};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n-use std::ops::ControlFlow;\n-\n pub trait InferCtxtExt<'tcx> {\n     fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n@@ -23,12 +20,6 @@ pub trait InferCtxtExt<'tcx> {\n         value_span: Span,\n     ) -> InferOk<'tcx, T>;\n \n-    fn constrain_opaque_type(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-    );\n-\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n@@ -81,236 +72,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         InferOk { value, obligations: instantiator.obligations }\n     }\n \n-    /// Given the map `opaque_types` containing the opaque\n-    /// `impl Trait` types whose underlying, hidden types are being\n-    /// inferred, this method adds constraints to the regions\n-    /// appearing in those underlying hidden types to ensure that they\n-    /// at least do not refer to random scopes within the current\n-    /// function. These constraints are not (quite) sufficient to\n-    /// guarantee that the regions are actually legal values; that\n-    /// final condition is imposed after region inference is done.\n-    ///\n-    /// # The Problem\n-    ///\n-    /// Let's work through an example to explain how it works. Assume\n-    /// the current function is as follows:\n-    ///\n-    /// ```text\n-    /// fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n-    /// ```\n-    ///\n-    /// Here, we have two `impl Trait` types whose values are being\n-    /// inferred (the `impl Bar<'a>` and the `impl\n-    /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n-    /// define underlying opaque types (`Foo1`, `Foo2`) and then, in\n-    /// the return type of `foo`, we *reference* those definitions:\n-    ///\n-    /// ```text\n-    /// type Foo1<'x> = impl Bar<'x>;\n-    /// type Foo2<'x> = impl Bar<'x>;\n-    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    ///                    //  ^^^^ ^^\n-    ///                    //  |    |\n-    ///                    //  |    substs\n-    ///                    //  def_id\n-    /// ```\n-    ///\n-    /// As indicating in the comments above, each of those references\n-    /// is (in the compiler) basically a substitution (`substs`)\n-    /// applied to the type of a suitable `def_id` (which identifies\n-    /// `Foo1` or `Foo2`).\n-    ///\n-    /// Now, at this point in compilation, what we have done is to\n-    /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n-    /// fresh inference variables C1 and C2. We wish to use the values\n-    /// of these variables to infer the underlying types of `Foo1` and\n-    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n-    /// constraints like:\n-    ///\n-    /// ```text\n-    /// for<'a> (Foo1<'a> = C1)\n-    /// for<'b> (Foo1<'b> = C2)\n-    /// ```\n-    ///\n-    /// For these equation to be satisfiable, the types `C1` and `C2`\n-    /// can only refer to a limited set of regions. For example, `C1`\n-    /// can only refer to `'static` and `'a`, and `C2` can only refer\n-    /// to `'static` and `'b`. The job of this function is to impose that\n-    /// constraint.\n-    ///\n-    /// Up to this point, C1 and C2 are basically just random type\n-    /// inference variables, and hence they may contain arbitrary\n-    /// regions. In fact, it is fairly likely that they do! Consider\n-    /// this possible definition of `foo`:\n-    ///\n-    /// ```text\n-    /// fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n-    ///         (&*x, &*y)\n-    ///     }\n-    /// ```\n-    ///\n-    /// Here, the values for the concrete types of the two impl\n-    /// traits will include inference variables:\n-    ///\n-    /// ```text\n-    /// &'0 i32\n-    /// &'1 i32\n-    /// ```\n-    ///\n-    /// Ordinarily, the subtyping rules would ensure that these are\n-    /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default. This\n-    /// is where this function comes into play. It adds extra\n-    /// constraints to ensure that all the regions which appear in the\n-    /// inferred type are regions that could validly appear.\n-    ///\n-    /// This is actually a bit of a tricky constraint in general. We\n-    /// want to say that each variable (e.g., `'0`) can only take on\n-    /// values that were supplied as arguments to the opaque type\n-    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n-    /// scope. We don't have a constraint quite of this kind in the current\n-    /// region checker.\n-    ///\n-    /// # The Solution\n-    ///\n-    /// We generally prefer to make `<=` constraints, since they\n-    /// integrate best into the region solver. To do that, we find the\n-    /// \"minimum\" of all the arguments that appear in the substs: that\n-    /// is, some region which is less than all the others. In the case\n-    /// of `Foo1<'a>`, that would be `'a` (it's the only choice, after\n-    /// all). Then we apply that as a least bound to the variables\n-    /// (e.g., `'a <= '0`).\n-    ///\n-    /// In some cases, there is no minimum. Consider this example:\n-    ///\n-    /// ```text\n-    /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n-    /// ```\n-    ///\n-    /// Here we would report a more complex \"in constraint\", like `'r\n-    /// in ['a, 'b, 'static]` (where `'r` is some region appearing in\n-    /// the hidden type).\n-    ///\n-    /// # Constrain regions, not the hidden concrete type\n-    ///\n-    /// Note that generating constraints on each region `Rc` is *not*\n-    /// the same as generating an outlives constraint on `Tc` iself.\n-    /// For example, if we had a function like this:\n-    ///\n-    /// ```rust\n-    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n-    ///   (x, y)\n-    /// }\n-    ///\n-    /// // Equivalent to:\n-    /// type FooReturn<'a, T> = impl Foo<'a>;\n-    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n-    /// ```\n-    ///\n-    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n-    /// is an inference variable). If we generated a constraint that\n-    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n-    /// but this is not necessary, because the opaque type we\n-    /// create will be allowed to reference `T`. So we only generate a\n-    /// constraint that `'0: 'a`.\n-    ///\n-    /// # The `free_region_relations` parameter\n-    ///\n-    /// The `free_region_relations` argument is used to find the\n-    /// \"minimum\" of the regions supplied to a given opaque type.\n-    /// It must be a relation that can answer whether `'a <= 'b`,\n-    /// where `'a` and `'b` are regions that appear in the \"substs\"\n-    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n-    ///\n-    /// Note that we do not impose the constraints based on the\n-    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n-    /// is because the constraints we are imposing here is basically\n-    /// the concern of the one generating the constraining type C1,\n-    /// which is the current function. It also means that we can\n-    /// take \"implied bounds\" into account in some cases:\n-    ///\n-    /// ```text\n-    /// trait SomeTrait<'a, 'b> { }\n-    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n-    /// ```\n-    ///\n-    /// Here, the fact that `'b: 'a` is known only because of the\n-    /// implied bounds from the `&'a &'b u32` parameter, and is not\n-    /// \"inherent\" to the opaque type definition.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n-    /// - `free_region_relations` -- something that can be used to relate\n-    ///   the free regions (`'a`) that appear in the impl trait.\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn constrain_opaque_type(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-    ) {\n-        let def_id = opaque_type_key.def_id;\n-\n-        let tcx = self.tcx;\n-\n-        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n-\n-        debug!(?concrete_ty);\n-\n-        let first_own_region = match opaque_defn.origin {\n-            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n-                // We lower\n-                //\n-                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-                //\n-                // into\n-                //\n-                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-                //\n-                // For these types we only iterate over `'l0..lm` below.\n-                tcx.generics_of(def_id).parent_count\n-            }\n-            // These opaque type inherit all lifetime parameters from their\n-            // parent, so we have to check them all.\n-            hir::OpaqueTyOrigin::TyAlias => 0,\n-        };\n-\n-        // For a case like `impl Foo<'a, 'b>`, we would generate a constraint\n-        // `'r in ['a, 'b, 'static]` for each region `'r` that appears in the\n-        // hidden type (i.e., it must be equal to `'a`, `'b`, or `'static`).\n-        //\n-        // `conflict1` and `conflict2` are the two region bounds that we\n-        // detected which were unrelated. They are used for diagnostics.\n-\n-        // Create the set of choice regions: each region in the hidden\n-        // type can be equal to any of the region parameters of the\n-        // opaque type definition.\n-        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_key.substs[first_own_region..]\n-                .iter()\n-                .filter_map(|arg| match arg.unpack() {\n-                    GenericArgKind::Lifetime(r) => Some(r),\n-                    GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n-                })\n-                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n-                .collect(),\n-        );\n-\n-        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-            tcx: self.tcx,\n-            op: |r| {\n-                self.member_constraint(\n-                    opaque_type_key.def_id,\n-                    opaque_defn.definition_span,\n-                    concrete_ty,\n-                    r,\n-                    &choice_regions,\n-                )\n-            },\n-        });\n-    }\n-\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an opaque type\n@@ -372,83 +133,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n-// Visitor that requires that (almost) all regions in the type visited outlive\n-// `least_region`. We cannot use `push_outlives_components` because regions in\n-// closure signatures are not included in their outlives components. We need to\n-// ensure all regions outlive the given bound so that we don't end up with,\n-// say, `ReVar` appearing in a return type and causing ICEs when other\n-// functions end up with region constraints involving regions from other\n-// functions.\n-//\n-// We also cannot use `for_each_free_region` because for closures it includes\n-// the regions parameters from the enclosing item.\n-//\n-// We ignore any type parameters because impl trait values are assumed to\n-// capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n-    tcx: TyCtxt<'tcx>,\n-    op: OP,\n-}\n-\n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n-where\n-    OP: FnMut(ty::Region<'tcx>),\n-{\n-    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n-        Some(self.tcx)\n-    }\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &ty::Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        t.as_ref().skip_binder().visit_with(self);\n-        ControlFlow::CONTINUE\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match *r {\n-            // ignore bound regions, keep visiting\n-            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n-            _ => {\n-                (self.op)(r);\n-                ControlFlow::CONTINUE\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // We're only interested in types involving regions\n-        if !ty.flags().intersects(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n-            return ControlFlow::CONTINUE;\n-        }\n-\n-        match ty.kind() {\n-            ty::Closure(_, ref substs) => {\n-                // Skip lifetime parameters of the enclosing item(s)\n-\n-                substs.as_closure().tupled_upvars_ty().visit_with(self);\n-                substs.as_closure().sig_as_fn_ptr_ty().visit_with(self);\n-            }\n-\n-            ty::Generator(_, ref substs, _) => {\n-                // Skip lifetime parameters of the enclosing item(s)\n-                // Also skip the witness type, because that has no free regions.\n-\n-                substs.as_generator().tupled_upvars_ty().visit_with(self);\n-                substs.as_generator().return_ty().visit_with(self);\n-                substs.as_generator().yield_ty().visit_with(self);\n-                substs.as_generator().resume_ty().visit_with(self);\n-            }\n-            _ => {\n-                ty.super_visit_with(self);\n-            }\n-        }\n-\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n "}]}