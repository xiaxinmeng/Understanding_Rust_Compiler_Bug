{"sha": "413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMzk5NGVhM2VlZDk3NmE2ZmU5N2YzZDZjZmViMGMyZjQ1M2U3N2Y=", "commit": {"author": {"name": "Jon Morton", "email": "jonanin@gmail.com", "date": "2012-04-02T02:14:16Z"}, "committer": {"name": "Jon Morton", "email": "jonanin@gmail.com", "date": "2012-04-02T02:14:16Z"}, "message": "replace assertion macros with plain asserts", "tree": {"sha": "653313277b5712ea63d7e381ae74397f62f435bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/653313277b5712ea63d7e381ae74397f62f435bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "html_url": "https://github.com/rust-lang/rust/commit/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/comments", "author": {"login": "jamorton", "id": 18852, "node_id": "MDQ6VXNlcjE4ODUy", "avatar_url": "https://avatars.githubusercontent.com/u/18852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamorton", "html_url": "https://github.com/jamorton", "followers_url": "https://api.github.com/users/jamorton/followers", "following_url": "https://api.github.com/users/jamorton/following{/other_user}", "gists_url": "https://api.github.com/users/jamorton/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamorton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamorton/subscriptions", "organizations_url": "https://api.github.com/users/jamorton/orgs", "repos_url": "https://api.github.com/users/jamorton/repos", "events_url": "https://api.github.com/users/jamorton/events{/privacy}", "received_events_url": "https://api.github.com/users/jamorton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamorton", "id": 18852, "node_id": "MDQ6VXNlcjE4ODUy", "avatar_url": "https://avatars.githubusercontent.com/u/18852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamorton", "html_url": "https://github.com/jamorton", "followers_url": "https://api.github.com/users/jamorton/followers", "following_url": "https://api.github.com/users/jamorton/following{/other_user}", "gists_url": "https://api.github.com/users/jamorton/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamorton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamorton/subscriptions", "organizations_url": "https://api.github.com/users/jamorton/orgs", "repos_url": "https://api.github.com/users/jamorton/repos", "events_url": "https://api.github.com/users/jamorton/events{/privacy}", "received_events_url": "https://api.github.com/users/jamorton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ec21933f1b730862f85c4dc6a4e46359e84a865", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ec21933f1b730862f85c4dc6a4e46359e84a865", "html_url": "https://github.com/rust-lang/rust/commit/9ec21933f1b730862f85c4dc6a4e46359e84a865"}], "stats": {"total": 224, "additions": 100, "deletions": 124}, "files": [{"sha": "a4f73f2362a10249a0fa3ccd8739333c89a052f2", "filename": "src/rt/circular_buffer.cpp", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -12,26 +12,26 @@ circular_buffer::circular_buffer(rust_kernel *kernel, size_t unit_sz) :\n     _unread(0),\n     _buffer((uint8_t *)kernel->malloc(_buffer_sz, \"circular_buffer\")) {\n \n-    A(kernel, unit_sz, \"Unit size must be larger than zero.\");\n+    assert(unit_sz && \"Unit size must be larger than zero.\");\n \n     KLOG(kernel, mem, \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n          \"-> circular_buffer=0x%\" PRIxPTR,\n          _buffer_sz, _unread, this);\n \n-    A(kernel, _buffer, \"Failed to allocate buffer.\");\n+    assert(_buffer && \"Failed to allocate buffer.\");\n }\n \n circular_buffer::~circular_buffer() {\n     KLOG(kernel, mem, \"~circular_buffer 0x%\" PRIxPTR, this);\n-    I(kernel, _buffer);\n+    assert(_buffer);\n     W(kernel, _unread == 0,\n       \"freeing circular_buffer with %d unread bytes\", _unread);\n     kernel->free(_buffer);\n }\n \n size_t\n circular_buffer::initial_size() {\n-    I(kernel, unit_sz > 0);\n+    assert(unit_sz > 0);\n     return INITIAL_CIRCULAR_BUFFER_SIZE_IN_UNITS * unit_sz;\n }\n \n@@ -40,8 +40,8 @@ circular_buffer::initial_size() {\n  */\n void\n circular_buffer::transfer(void *dst) {\n-    I(kernel, dst);\n-    I(kernel, _unread <= _buffer_sz);\n+    assert(dst);\n+    assert(_unread <= _buffer_sz);\n \n     uint8_t *ptr = (uint8_t *) dst;\n \n@@ -53,13 +53,13 @@ circular_buffer::transfer(void *dst) {\n     } else {\n         head_sz = _buffer_sz - _next;\n     }\n-    I(kernel, _next + head_sz <= _buffer_sz);\n+    assert(_next + head_sz <= _buffer_sz);\n     memcpy(ptr, _buffer + _next, head_sz);\n \n     // Then copy any other items from the beginning of the buffer\n-    I(kernel, _unread >= head_sz);\n+    assert(_unread >= head_sz);\n     size_t tail_sz = _unread - head_sz;\n-    I(kernel, head_sz + tail_sz <= _buffer_sz);\n+    assert(head_sz + tail_sz <= _buffer_sz);\n     memcpy(ptr + head_sz, _buffer, tail_sz);\n }\n \n@@ -69,9 +69,9 @@ circular_buffer::transfer(void *dst) {\n  */\n void\n circular_buffer::enqueue(void *src) {\n-    I(kernel, src);\n-    I(kernel, _unread <= _buffer_sz);\n-    I(kernel, _buffer);\n+    assert(src);\n+    assert(_unread <= _buffer_sz);\n+    assert(_buffer);\n \n     // Grow if necessary.\n     if (_unread == _buffer_sz) {\n@@ -82,20 +82,20 @@ circular_buffer::enqueue(void *src) {\n          \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n          _unread, _next, _buffer_sz, unit_sz);\n \n-    I(kernel, _unread < _buffer_sz);\n-    I(kernel, _unread + unit_sz <= _buffer_sz);\n+    assert(_unread < _buffer_sz);\n+    assert(_unread + unit_sz <= _buffer_sz);\n \n     // Copy data\n     size_t dst_idx = _next + _unread;\n-    I(kernel, dst_idx >= _buffer_sz || dst_idx + unit_sz <= _buffer_sz);\n+    assert(dst_idx >= _buffer_sz || dst_idx + unit_sz <= _buffer_sz);\n     if (dst_idx >= _buffer_sz) {\n         dst_idx -= _buffer_sz;\n \n-        I(kernel, _next >= unit_sz);\n-        I(kernel, dst_idx <= _next - unit_sz);\n+        assert(_next >= unit_sz);\n+        assert(dst_idx <= _next - unit_sz);\n     }\n \n-    I(kernel, dst_idx + unit_sz <= _buffer_sz);\n+    assert(dst_idx + unit_sz <= _buffer_sz);\n     memcpy(&_buffer[dst_idx], src, unit_sz);\n     _unread += unit_sz;\n \n@@ -109,17 +109,17 @@ circular_buffer::enqueue(void *src) {\n  */\n void\n circular_buffer::dequeue(void *dst) {\n-    I(kernel, unit_sz > 0);\n-    I(kernel, _unread >= unit_sz);\n-    I(kernel, _unread <= _buffer_sz);\n-    I(kernel, _buffer);\n+    assert(unit_sz > 0);\n+    assert(_unread >= unit_sz);\n+    assert(_unread <= _buffer_sz);\n+    assert(_buffer);\n \n     KLOG(kernel, mem,\n              \"circular_buffer dequeue \"\n              \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n              _unread, _next, _buffer_sz, unit_sz);\n \n-    I(kernel, _next + unit_sz <= _buffer_sz);\n+    assert(_next + unit_sz <= _buffer_sz);\n     if (dst != NULL) {\n         memcpy(dst, &_buffer[_next], unit_sz);\n     }\n@@ -153,7 +153,7 @@ circular_buffer::grow() {\n void\n circular_buffer::shrink() {\n     size_t new_buffer_sz = _buffer_sz / 2;\n-    I(kernel, initial_size() <= new_buffer_sz);\n+    assert(initial_size() <= new_buffer_sz);\n     KLOG(kernel, mem, \"circular_buffer is shrinking to %d bytes\",\n          new_buffer_sz);\n     void *new_buffer = kernel->malloc(new_buffer_sz,"}, {"sha": "baa6e9ed369dcd3fbedaeb75c23790b0ac175c8d", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -55,7 +55,7 @@ void memory_region::free(void *mem) {\n #   endif\n \n     if (_live_allocations < 1) {\n-        _srv->fatal(\"live_allocs < 1\", __FILE__, __LINE__, \"\");\n+        assert(false && \"live_allocs < 1\");\n     }\n     release_alloc(mem);\n     maybe_poison(mem);\n@@ -88,7 +88,7 @@ memory_region::realloc(void *mem, size_t orig_size) {\n                alloc->index, _allocation_list[alloc->index], alloc);\n         printf(\"realloc: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n                (uintptr_t) get_data(alloc), alloc->tag);\n-        _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n+        assert(false && \"not in allocation_list\");\n     }\n     else {\n         _allocation_list[newMem->index] = newMem;\n@@ -166,8 +166,8 @@ memory_region::~memory_region() {\n #   endif\n \n     if (_live_allocations > 0) {\n-        _srv->fatal(msg, __FILE__, __LINE__,\n-                    \"%d objects\", _live_allocations);\n+        fprintf(stderr, \"%s\\n\", msg);\n+        assert(false);\n     }\n     if (_synchronized) { _lock.unlock(); }\n }\n@@ -184,7 +184,7 @@ memory_region::release_alloc(void *mem) {\n     if (_allocation_list[alloc->index] != alloc) {\n         printf(\"free: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n                (uintptr_t) get_data(alloc), alloc->tag);\n-        _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n+        assert(false && \"not in allocation_list\");\n     }\n     else {\n         // printf(\"freed index %d\\n\", index);"}, {"sha": "fd6664cf6a3dde557441ebf9850446a574cab3a7", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -450,8 +450,7 @@ rust_get_sched_id() {\n extern \"C\" CDECL rust_sched_id\n rust_new_sched(uintptr_t threads) {\n     rust_task *task = rust_sched_loop::get_task();\n-    A(task->sched_loop, threads > 0,\n-      \"Can't create a scheduler with no threads, silly!\");\n+    assert(threads > 0 && \"Can't create a scheduler with no threads, silly!\");\n     return task->kernel->create_scheduler(threads);\n }\n \n@@ -606,36 +605,31 @@ rust_dbg_lock_create() {\n \n extern \"C\" CDECL void\n rust_dbg_lock_destroy(lock_and_signal *lock) {\n-    rust_task *task = rust_sched_loop::get_task();\n-    I(task->sched_loop, lock);\n+    assert(lock);\n     delete lock;\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_lock(lock_and_signal *lock) {\n-    rust_task *task = rust_sched_loop::get_task();\n-    I(task->sched_loop, lock);\n+    assert(lock);\n     lock->lock();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_unlock(lock_and_signal *lock) {\n-    rust_task *task = rust_sched_loop::get_task();\n-    I(task->sched_loop, lock);\n+    assert(lock);\n     lock->unlock();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_wait(lock_and_signal *lock) {\n-    rust_task *task = rust_sched_loop::get_task();\n-    I(task->sched_loop, lock);\n+    assert(lock);\n     lock->wait();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_signal(lock_and_signal *lock) {\n-    rust_task *task = rust_sched_loop::get_task();\n-    I(task->sched_loop, lock);\n+    assert(lock);\n     lock->signal();\n }\n "}, {"sha": "27f4336f49ee64c1c8c804e7456c298fe0869bb3", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -24,18 +24,6 @@ typedef intptr_t rust_sched_id;\n typedef intptr_t rust_task_id;\n typedef intptr_t rust_port_id;\n \n-#define I(dom, e) ((e) ? (void)0 : \\\n-         (dom)->srv->fatal(#e, __FILE__, __LINE__, \"\"))\n-\n-#define W(dom, e, s, ...) ((e) ? (void)0 : \\\n-         (dom)->srv->warning(#e, __FILE__, __LINE__, s, ## __VA_ARGS__))\n-\n-#define A(dom, e, s, ...) ((e) ? (void)0 : \\\n-         (dom)->srv->fatal(#e, __FILE__, __LINE__, s, ## __VA_ARGS__))\n-\n-#define K(srv, e, s, ...) ((e) ? (void)0 : \\\n-         srv->fatal(#e, __FILE__, __LINE__, s, ## __VA_ARGS__))\n-\n #define PTR \"0x%\" PRIxPTR\n \n // This drives our preemption scheme."}, {"sha": "8c2b0030bce299187be638d367a40957189affe3", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -67,13 +67,13 @@ rust_kernel::create_scheduler(size_t num_threads) {\n         // the scheduler reaper.\n         bool start_reaper = sched_table.empty();\n         id = max_sched_id++;\n-        K(srv, id != INTPTR_MAX, \"Hit the maximum scheduler id\");\n+        assert(id != INTPTR_MAX && \"Hit the maximum scheduler id\");\n         sched = new (this, \"rust_scheduler\")\n             rust_scheduler(this, srv, num_threads, id);\n         bool is_new = sched_table\n             .insert(std::pair<rust_sched_id,\n                               rust_scheduler*>(id, sched)).second;\n-        A(this, is_new, \"Reusing a sched id?\");\n+        assert(is_new && \"Reusing a sched id?\");\n         if (start_reaper) {\n             sched_reaper.start();\n         }\n@@ -118,7 +118,7 @@ rust_kernel::wait_for_schedulers()\n             rust_sched_id id = join_list.back();\n             join_list.pop_back();\n             sched_map::iterator iter = sched_table.find(id);\n-            I(this, iter != sched_table.end());\n+            assert(iter != sched_table.end());\n             rust_scheduler *sched = iter->second;\n             sched_table.erase(iter);\n             sched->join_task_threads();\n@@ -175,7 +175,7 @@ rust_kernel::fail() {\n rust_task_id\n rust_kernel::generate_task_id() {\n     rust_task_id id = sync::increment(max_task_id);\n-    K(srv, id != INTPTR_MAX, \"Hit the maximum task id\");\n+    assert(id != INTPTR_MAX && \"Hit the maximum task id\");\n     return id;\n }\n \n@@ -189,7 +189,7 @@ rust_kernel::register_port(rust_port *port) {\n         port_table.put(new_port_id, port);\n         new_live_ports = port_table.count();\n     }\n-    K(srv, new_port_id != INTPTR_MAX, \"Hit the maximum port id\");\n+    assert(new_port_id != INTPTR_MAX && \"Hit the maximum port id\");\n     KLOG_(\"Registered port %\" PRIdPTR, new_port_id);\n     KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n     return new_port_id;\n@@ -233,7 +233,7 @@ rust_kernel::win32_require(LPCTSTR fn, BOOL ok) {\n                       (LPTSTR) &buf, 0, NULL );\n         KLOG_ERR_(dom, \"%s failed with error %ld: %s\", fn, err, buf);\n         LocalFree((HLOCAL)buf);\n-        I(this, ok);\n+        assert(ok);\n     }\n }\n #endif"}, {"sha": "3d8765859621bafbeffd860d6840e93173d55e5a", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -51,7 +51,7 @@ void rust_port::end_detach() {\n     // Just take the lock to make sure that the thread that signaled\n     // the detach_cond isn't still holding it\n     scoped_lock with(ref_lock);\n-    I(task->sched_loop, ref_count == 0);\n+    assert(ref_count == 0);\n }\n \n void rust_port::send(void *sptr) {\n@@ -61,8 +61,8 @@ void rust_port::send(void *sptr) {\n \n         buffer.enqueue(sptr);\n \n-        A(kernel, !buffer.is_empty(),\n-          \"rust_chan::transmit with nothing to send.\");\n+        assert(!buffer.is_empty() &&\n+               \"rust_chan::transmit with nothing to send.\");\n \n         if (task->blocked_on(this)) {\n             KLOG(kernel, comm, \"dequeued in rendezvous_ptr\");"}, {"sha": "51018bf95a95fe9f043756c03c40a0b766c64665", "filename": "src/rt/rust_port_selector.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -10,12 +10,12 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n                            rust_port **ports,\n                            size_t n_ports, uintptr_t *yield) {\n \n-    I(task->sched_loop, this->ports == NULL);\n-    I(task->sched_loop, this->n_ports == 0);\n-    I(task->sched_loop, dptr != NULL);\n-    I(task->sched_loop, ports != NULL);\n-    I(task->sched_loop, n_ports != 0);\n-    I(task->sched_loop, yield != NULL);\n+    assert(this->ports == NULL);\n+    assert(this->n_ports == 0);\n+    assert(dptr != NULL);\n+    assert(ports != NULL);\n+    assert(n_ports != 0);\n+    assert(yield != NULL);\n \n     *yield = false;\n     size_t locks_taken = 0;\n@@ -31,7 +31,7 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n     for (size_t i = 0; i < n_ports; i++) {\n         size_t k = (i + j) % n_ports;\n         rust_port *port = ports[k];\n-        I(task->sched_loop, port != NULL);\n+        assert(port != NULL);\n \n         port->lock.lock();\n         locks_taken++;\n@@ -46,7 +46,7 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n     if (!found_msg) {\n         this->ports = ports;\n         this->n_ports = n_ports;\n-        I(task->sched_loop, task->rendezvous_ptr == NULL);\n+        assert(task->rendezvous_ptr == NULL);\n         task->rendezvous_ptr = (uintptr_t*)dptr;\n         task->block(this, \"waiting for select rendezvous\");\n "}, {"sha": "1b22dcfdbba8b2250af2ced8c3f1fcc955f8c518", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -130,7 +130,7 @@ rust_sched_loop::reap_dead_tasks() {\n void\n rust_sched_loop::release_task(rust_task *task) {\n     // Nobody should have a ref to the task at this point\n-    I(this, task->get_ref_count() == 0);\n+    assert(task->get_ref_count() == 0);\n     // Now delete the task, which will require using this thread's\n     // memory region.\n     delete task;\n@@ -149,9 +149,9 @@ rust_sched_loop::release_task(rust_task *task) {\n rust_task *\n rust_sched_loop::schedule_task() {\n     lock.must_have_lock();\n-    I(this, this);\n+    assert(this);\n     // FIXME: in the face of failing tasks, this is not always right.\n-    // I(this, n_live_tasks() > 0);\n+    // assert(n_live_tasks() > 0);\n     if (running_tasks.length() > 0) {\n         size_t k = isaac_rand(&rctx);\n         // Look around for a runnable task, starting at k.\n@@ -190,14 +190,14 @@ rust_sched_loop::log_state() {\n \n void\n rust_sched_loop::on_pump_loop(rust_signal *signal) {\n-    I(this, pump_signal == NULL);\n-    I(this, signal != NULL);\n+    assert(pump_signal == NULL);\n+    assert(signal != NULL);\n     pump_signal = signal;\n }\n \n void\n rust_sched_loop::pump_loop() {\n-    I(this, pump_signal != NULL);\n+    assert(pump_signal != NULL);\n     pump_signal->signal();\n }\n \n@@ -209,8 +209,7 @@ rust_sched_loop::run_single_turn() {\n     lock.lock();\n \n     if (!should_exit) {\n-        A(this, dead_task == NULL,\n-          \"Tasks should only die after running\");\n+        assert(dead_task == NULL && \"Tasks should only die after running\");\n \n         DLOG(this, dom, \"worker %d, number_of_live_tasks = %d\",\n              id, number_of_live_tasks());\n@@ -227,7 +226,7 @@ rust_sched_loop::run_single_turn() {\n             return sched_loop_state_block;\n         }\n \n-        I(this, scheduled_task->running());\n+        assert(scheduled_task->running());\n \n         DLOG(this, task,\n              \"activating task %s 0x%\" PRIxPTR\n@@ -256,15 +255,15 @@ rust_sched_loop::run_single_turn() {\n         lock.unlock();\n         return sched_loop_state_keep_going;\n     } else {\n-        A(this, running_tasks.is_empty(), \"Should have no running tasks\");\n-        A(this, blocked_tasks.is_empty(), \"Should have no blocked tasks\");\n-        A(this, dead_task == NULL, \"Should have no dead tasks\");\n+        assert(running_tasks.is_empty() && \"Should have no running tasks\");\n+        assert(blocked_tasks.is_empty() && \"Should have no blocked tasks\");\n+        assert(dead_task == NULL && \"Should have no dead tasks\");\n \n         DLOG(this, dom, \"finished main-loop %d\", id);\n \n         lock.unlock();\n \n-        I(this, !extra_c_stack);\n+        assert(!extra_c_stack);\n         if (cached_c_stack) {\n             destroy_stack(kernel->region(), cached_c_stack);\n             cached_c_stack = NULL;\n@@ -326,7 +325,7 @@ rust_sched_loop::transition(rust_task *task,\n          \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n          name, (uintptr_t)this, state_name(src), state_name(dst),\n          state_name(task->get_state()));\n-    I(this, task->get_state() == src);\n+    assert(task->get_state() == src);\n     rust_task_list *src_list = state_list(src);\n     if (src_list) {\n         src_list->remove(task);\n@@ -336,7 +335,7 @@ rust_sched_loop::transition(rust_task *task,\n         dst_list->append(task);\n     }\n     if (dst == task_state_dead) {\n-        I(this, dead_task == NULL);\n+        assert(dead_task == NULL);\n         dead_task = task;\n     }\n     task->set_state(dst, cond, cond_name);\n@@ -388,7 +387,7 @@ rust_sched_loop::exit() {\n // room to do the allocation\n void\n rust_sched_loop::prepare_c_stack(rust_task *task) {\n-    I(this, !extra_c_stack);\n+    assert(!extra_c_stack);\n     if (!cached_c_stack && !task->have_c_stack()) {\n         cached_c_stack = create_stack(kernel->region(), C_STACK_SIZE);\n     }"}, {"sha": "795bca702fd32767b52dd927911fb880f9de13ea", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -165,7 +165,7 @@ rust_sched_loop::get_task() {\n // NB: Runs on the Rust stack\n inline stk_seg *\n rust_sched_loop::borrow_c_stack() {\n-    I(this, cached_c_stack);\n+    assert(cached_c_stack);\n     stk_seg *your_stack;\n     if (extra_c_stack) {\n         your_stack = extra_c_stack;\n@@ -180,7 +180,7 @@ rust_sched_loop::borrow_c_stack() {\n // NB: Runs on the Rust stack\n inline void\n rust_sched_loop::return_c_stack(stk_seg *stack) {\n-    I(this, !extra_c_stack);\n+    assert(!extra_c_stack);\n     if (!cached_c_stack) {\n         cached_c_stack = stack;\n     } else {"}, {"sha": "f9e092d36617924930601a7ed226044d594cdf14", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -70,7 +70,7 @@ rust_task::delete_this()\n \n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    I(sched_loop, ref_count == 0); // ||\n+    assert(ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n \n     sched_loop->release_task(this);\n@@ -125,7 +125,7 @@ cleanup_task(cleanup_args *args) {\n #ifndef __WIN32__\n         task->conclude_failure();\n #else\n-        A(task->sched_loop, false, \"Shouldn't happen\");\n+        assert(false && \"Shouldn't happen\");\n #endif\n     }\n }\n@@ -141,8 +141,7 @@ void task_start_wrapper(spawn_args *a)\n         // must have void return type, we can safely pass 0.\n         a->f(0, a->envptr, a->argptr);\n     } catch (rust_task *ex) {\n-        A(task->sched_loop, ex == task,\n-          \"Expected this task to be thrown for unwinding\");\n+        assert(ex == task && \"Expected this task to be thrown for unwinding\");\n         threw_exception = true;\n \n         if (task->c_stack) {\n@@ -155,7 +154,7 @@ void task_start_wrapper(spawn_args *a)\n     }\n \n     // We should have returned any C stack by now\n-    I(task->sched_loop, task->c_stack == NULL);\n+    assert(task->c_stack == NULL);\n \n     rust_opaque_box* env = a->envptr;\n     if(env) {\n@@ -181,7 +180,7 @@ rust_task::start(spawn_fn spawnee_fn,\n         \" with env 0x%\" PRIxPTR \" and arg 0x%\" PRIxPTR,\n         spawnee_fn, envptr, argptr);\n \n-    I(sched_loop, stk->data != NULL);\n+    assert(stk->data != NULL);\n \n     char *sp = (char *)stk->end;\n \n@@ -220,7 +219,7 @@ rust_task::must_fail_from_being_killed_unlocked() {\n void\n rust_task::yield(bool *killed) {\n     if (must_fail_from_being_killed()) {\n-        I(sched_loop, !blocked());\n+        assert(!blocked());\n         *killed = true;\n     }\n \n@@ -389,8 +388,8 @@ rust_task::block(rust_cond *on, const char* name) {\n \n     LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n-    A(sched_loop, cond == NULL, \"Cannot block an already blocked task.\");\n-    A(sched_loop, on != NULL, \"Cannot block on a NULL object.\");\n+    assert(cond == NULL && \"Cannot block an already blocked task.\");\n+    assert(on != NULL && \"Cannot block on a NULL object.\");\n \n     transition(task_state_running, task_state_blocked, on, name);\n \n@@ -399,11 +398,10 @@ rust_task::block(rust_cond *on, const char* name) {\n \n void\n rust_task::wakeup(rust_cond *from) {\n-    A(sched_loop, cond != NULL, \"Cannot wake up unblocked task.\");\n+    assert(cond != NULL && \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n-    A(sched_loop, cond == from,\n-      \"Cannot wake up blocked task on wrong condition.\");\n+    assert(cond == from && \"Cannot wake up blocked task on wrong condition.\");\n \n     transition(task_state_blocked, task_state_running, NULL, \"none\");\n }\n@@ -462,7 +460,7 @@ rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n     sz = std::max(sz, next);\n \n     LOG(this, mem, \"next stack size: %\" PRIdPTR, sz);\n-    I(sched_loop, requested <= sz);\n+    assert(requested <= sz);\n     return sz;\n }\n \n@@ -539,7 +537,7 @@ void\n rust_task::cleanup_after_turn() {\n     // Delete any spare stack segments that were left\n     // behind by calls to prev_stack\n-    I(sched_loop, stk);\n+    assert(stk);\n     while (stk->next) {\n         stk_seg *new_next = stk->next->next;\n         free_stack(stk->next);\n@@ -569,8 +567,7 @@ reset_stack_limit_on_c_stack(reset_args *args) {\n     uintptr_t sp = args->sp;\n     while (!sp_in_stk_seg(sp, task->stk)) {\n         task->stk = task->stk->prev;\n-        A(task->sched_loop, task->stk != NULL,\n-          \"Failed to find the current stack\");\n+        assert(task->stk != NULL && \"Failed to find the current stack\");\n     }\n     task->record_stack_limit();\n }\n@@ -598,10 +595,10 @@ rust_task::check_stack_canary() {\n \n void\n rust_task::delete_all_stacks() {\n-    I(sched_loop, !on_rust_stack());\n+    assert(!on_rust_stack());\n     // Delete all the stacks. There may be more than one if the task failed\n     // and no landing pads stopped to clean up.\n-    I(sched_loop, stk->next == NULL);\n+    assert(stk->next == NULL);\n     while (stk != NULL) {\n         stk_seg *prev = stk->prev;\n         free_stack(stk);"}, {"sha": "b1427c137cd3c3bdc54156f09d6009165692b9fa", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -304,7 +304,7 @@ sanitize_next_sp(uintptr_t next_sp) {\n inline void\n rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n     // Too expensive to check\n-    // I(thread, on_rust_stack());\n+    // assert(on_rust_stack());\n \n     uintptr_t prev_rust_sp = next_rust_sp;\n     next_rust_sp = get_sp();\n@@ -334,9 +334,9 @@ rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n inline void\n rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n     // Too expensive to check\n-    // I(thread, !on_rust_stack());\n-    A(sched_loop, get_sp_limit() != 0, \"Stack must be configured\");\n-    I(sched_loop, next_rust_sp);\n+    // assert(!on_rust_stack());\n+    assert(get_sp_limit() != 0 && \"Stack must be configured\");\n+    assert(next_rust_sp);\n \n     bool had_reentered_rust_stack = reentered_rust_stack;\n     reentered_rust_stack = true;\n@@ -357,8 +357,8 @@ rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n inline void\n rust_task::return_c_stack() {\n     // Too expensive to check\n-    // I(thread, on_rust_stack());\n-    I(sched_loop, c_stack != NULL);\n+    // assert(on_rust_stack());\n+    assert(c_stack != NULL);\n     sched_loop->return_c_stack(c_stack);\n     c_stack = NULL;\n     next_c_sp = 0;\n@@ -368,8 +368,8 @@ rust_task::return_c_stack() {\n inline void *\n rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n     new_stack_fast(stk_sz + args_sz);\n-    A(sched_loop, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n-      \"Did not receive enough stack\");\n+    assert(stk->end - (uintptr_t)stk->data >= stk_sz + args_sz\n+      && \"Did not receive enough stack\");\n     uint8_t *new_sp = (uint8_t*)stk->end;\n     // Push the function arguments to the new stack\n     new_sp = align_down(new_sp - args_sz);\n@@ -438,11 +438,10 @@ record_sp_limit(void *limit);\n \n inline void\n rust_task::record_stack_limit() {\n-    I(sched_loop, stk);\n-    A(sched_loop,\n-      (uintptr_t)stk->end - RED_ZONE_SIZE\n-      - (uintptr_t)stk->data >= LIMIT_OFFSET,\n-      \"Stack size must be greater than LIMIT_OFFSET\");\n+    assert(stk);\n+    assert((uintptr_t)stk->end - RED_ZONE_SIZE\n+      - (uintptr_t)stk->data >= LIMIT_OFFSET\n+           && \"Stack size must be greater than LIMIT_OFFSET\");\n     record_sp_limit(stk->data + LIMIT_OFFSET + RED_ZONE_SIZE);\n }\n "}, {"sha": "0af16978390cee4b08789283b0248e8cfede6f0c", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/413994ea3eed976a6fe97f3d6cfeb0c2f453e77f/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=413994ea3eed976a6fe97f3d6cfeb0c2f453e77f", "patch": "@@ -61,11 +61,10 @@ isaac_init(rust_kernel *kernel, randctx *rctx)\n                  CryptReleaseContext(hProv, 0));\n #else\n             int fd = open(\"/dev/urandom\", O_RDONLY);\n-            I(kernel, fd > 0);\n-            I(kernel,\n-              read(fd, (void*) &rctx->randrsl, sizeof(rctx->randrsl))\n-              == sizeof(rctx->randrsl));\n-            I(kernel, close(fd) == 0);\n+            assert(fd > 0);\n+            assert(read(fd, (void*) &rctx->randrsl, sizeof(rctx->randrsl))\n+                   == sizeof(rctx->randrsl));\n+            assert(close(fd) == 0);\n #endif\n         }\n "}]}