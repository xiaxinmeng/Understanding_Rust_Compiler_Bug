{"sha": "a670ff888437f4b6a3d24cc2996e9f969a87cbae", "node_id": "C_kwDOAAsO6NoAKGE2NzBmZjg4ODQzN2Y0YjZhM2QyNGNjMjk5NmU5Zjk2OWE4N2NiYWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T12:21:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T12:21:33Z"}, "message": "Auto merge of #13074 - lowr:fix/method-resolution-with-impl-predicate, r=lowr\n\nConsider bounds on inherent impl in method resolution\n\nThere are three type-related things we should consider in method resolution: `Self` type, receiver type, and impl bounds. While we check the first two and impl bounds on trait impls, we've been ignoring the impl bounds on inherent impls. With this patch rust-analyzer now takes them into account and is able to select the appropriate inherent method.\n\nResolves #5441\nResolves #12308", "tree": {"sha": "a88648337e105bbe8320f141f5d65277ded7ac8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a88648337e105bbe8320f141f5d65277ded7ac8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a670ff888437f4b6a3d24cc2996e9f969a87cbae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a670ff888437f4b6a3d24cc2996e9f969a87cbae", "html_url": "https://github.com/rust-lang/rust/commit/a670ff888437f4b6a3d24cc2996e9f969a87cbae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a670ff888437f4b6a3d24cc2996e9f969a87cbae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1623635aa7281f73f96d4f2098e056641797eb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1623635aa7281f73f96d4f2098e056641797eb0", "html_url": "https://github.com/rust-lang/rust/commit/e1623635aa7281f73f96d4f2098e056641797eb0"}, {"sha": "dd22aa48bab8ff47025d806df481cad412b2747f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd22aa48bab8ff47025d806df481cad412b2747f", "html_url": "https://github.com/rust-lang/rust/commit/dd22aa48bab8ff47025d806df481cad412b2747f"}], "stats": {"total": 185, "additions": 140, "deletions": 45}, "files": [{"sha": "9a63d5013b4671274e8c93747049a5aa11fd33c7", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a670ff888437f4b6a3d24cc2996e9f969a87cbae/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a670ff888437f4b6a3d24cc2996e9f969a87cbae/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=a670ff888437f4b6a3d24cc2996e9f969a87cbae", "patch": "@@ -1064,6 +1064,14 @@ pub fn resolve_indexing_op(\n     None\n }\n \n+macro_rules! check_that {\n+    ($cond:expr) => {\n+        if !$cond {\n+            return false;\n+        }\n+    };\n+}\n+\n fn is_valid_candidate(\n     table: &mut InferenceTable<'_>,\n     name: Option<&Name>,\n@@ -1072,54 +1080,10 @@ fn is_valid_candidate(\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n ) -> bool {\n-    macro_rules! check_that {\n-        ($cond:expr) => {\n-            if !$cond {\n-                return false;\n-            }\n-        };\n-    }\n-\n     let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n-            let data = db.function_data(m);\n-\n-            check_that!(name.map_or(true, |n| n == &data.name));\n-            check_that!(visible_from_module.map_or(true, |from_module| {\n-                let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n-                if !v {\n-                    cov_mark::hit!(autoderef_candidate_not_visible);\n-                }\n-                v\n-            }));\n-\n-            table.run_in_snapshot(|table| {\n-                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-                let expect_self_ty = match m.lookup(db.upcast()).container {\n-                    ItemContainerId::TraitId(_) => {\n-                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n-                    }\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-                    }\n-                    // We should only get called for associated items (impl/trait)\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        unreachable!()\n-                    }\n-                };\n-                check_that!(table.unify(&expect_self_ty, self_ty));\n-                if let Some(receiver_ty) = receiver_ty {\n-                    check_that!(data.has_self_param());\n-\n-                    let sig = db.callable_item_signature(m.into());\n-                    let expected_receiver =\n-                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-\n-                    check_that!(table.unify(&receiver_ty, &expected_receiver));\n-                }\n-                true\n-            })\n+            is_valid_fn_candidate(table, m, name, receiver_ty, self_ty, visible_from_module)\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n@@ -1152,6 +1116,94 @@ fn is_valid_candidate(\n     }\n }\n \n+fn is_valid_fn_candidate(\n+    table: &mut InferenceTable<'_>,\n+    fn_id: FunctionId,\n+    name: Option<&Name>,\n+    receiver_ty: Option<&Ty>,\n+    self_ty: &Ty,\n+    visible_from_module: Option<ModuleId>,\n+) -> bool {\n+    let db = table.db;\n+    let data = db.function_data(fn_id);\n+\n+    check_that!(name.map_or(true, |n| n == &data.name));\n+    check_that!(visible_from_module.map_or(true, |from_module| {\n+        let v = db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module);\n+        if !v {\n+            cov_mark::hit!(autoderef_candidate_not_visible);\n+        }\n+        v\n+    }));\n+\n+    table.run_in_snapshot(|table| {\n+        let container = fn_id.lookup(db.upcast()).container;\n+        let impl_subst = match container {\n+            ItemContainerId::ImplId(it) => {\n+                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+            }\n+            ItemContainerId::TraitId(it) => {\n+                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n+            .use_parent_substs(&impl_subst)\n+            .fill_with_inference_vars(table)\n+            .build();\n+\n+        let expect_self_ty = match container {\n+            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n+            ItemContainerId::ImplId(impl_id) => {\n+                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+            }\n+            // We should only get called for associated items (impl/trait)\n+            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                unreachable!()\n+            }\n+        };\n+        check_that!(table.unify(&expect_self_ty, self_ty));\n+\n+        if let Some(receiver_ty) = receiver_ty {\n+            check_that!(data.has_self_param());\n+\n+            let sig = db.callable_item_signature(fn_id.into());\n+            let expected_receiver =\n+                sig.map(|s| s.params()[0].clone()).substitute(Interner, &fn_subst);\n+\n+            check_that!(table.unify(&receiver_ty, &expected_receiver));\n+        }\n+\n+        if let ItemContainerId::ImplId(impl_id) = container {\n+            // We need to consider the bounds on the impl to distinguish functions of the same name\n+            // for a type.\n+            let predicates = db.generic_predicates(impl_id.into());\n+            predicates\n+                .iter()\n+                .map(|predicate| {\n+                    let (p, b) = predicate\n+                        .clone()\n+                        .substitute(Interner, &impl_subst)\n+                        // Skipping the inner binders is ok, as we don't handle quantified where\n+                        // clauses yet.\n+                        .into_value_and_skipped_binders();\n+                    stdx::always!(b.len(Interner) == 0);\n+                    p\n+                })\n+                // It's ok to get ambiguity here, as we may not have enough information to prove\n+                // obligations. We'll check if the user is calling the selected method properly\n+                // later anyway.\n+                .all(|p| table.try_obligation(p.cast(Interner)).is_some())\n+        } else {\n+            // For `ItemContainerId::TraitId`, we check if `self_ty` implements the trait in\n+            // `iterate_trait_method_candidates()`.\n+            // For others, this function shouldn't be called.\n+            true\n+        }\n+    })\n+}\n+\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "81588a7c4ffd668bb6ccfb92f65e3628b09cb5a7", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a670ff888437f4b6a3d24cc2996e9f969a87cbae/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a670ff888437f4b6a3d24cc2996e9f969a87cbae/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=a670ff888437f4b6a3d24cc2996e9f969a87cbae", "patch": "@@ -1790,3 +1790,46 @@ impl u16 {\n         \"#,\n     )\n }\n+\n+#[test]\n+fn with_impl_bounds() {\n+    check_types(\n+        r#\"\n+trait Trait {}\n+struct Foo<T>(T);\n+impl Trait for isize {}\n+\n+impl<T: Trait> Foo<T> {\n+  fn foo() -> isize { 0 }\n+  fn bar(&self) -> isize { 0 }\n+}\n+\n+impl Foo<()> {\n+  fn foo() {}\n+  fn bar(&self) {}\n+}\n+\n+fn f() {\n+  let _ = Foo::<isize>::foo();\n+    //^isize\n+  let _ = Foo(0isize).bar();\n+    //^isize\n+  let _ = Foo::<()>::foo();\n+    //^()\n+  let _ = Foo(()).bar();\n+    //^()\n+  let _ = Foo::<usize>::foo();\n+    //^{unknown}\n+  let _ = Foo(0usize).bar();\n+    //^{unknown}\n+}\n+\n+fn g<T: Trait>(a: T) {\n+    let _ = Foo::<T>::foo();\n+      //^isize\n+    let _ = Foo(a).bar();\n+      //^isize\n+}\n+        \"#,\n+    );\n+}"}]}