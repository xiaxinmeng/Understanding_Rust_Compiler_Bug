{"sha": "8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZjhkZDljZWIwYTQ3OTBkNjVjMWRkODMyN2EwZDU2MThjM2E0NmY=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-12T05:37:01Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-08-25T03:16:40Z"}, "message": "Make enum discriminants u64 instead of the host uint.", "tree": {"sha": "488a741163ed87ba9165cc8ae8a9246e2b74f398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/488a741163ed87ba9165cc8ae8a9246e2b74f398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "html_url": "https://github.com/rust-lang/rust/commit/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f1d896497b10cb56389730e784aff6e513b0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f1d896497b10cb56389730e784aff6e513b0e8", "html_url": "https://github.com/rust-lang/rust/commit/f7f1d896497b10cb56389730e784aff6e513b0e8"}], "stats": {"total": 95, "additions": 49, "deletions": 46}, "files": [{"sha": "3fdd1587c0d7adbde4d8add3b46b947c843bb90f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -26,7 +26,7 @@ use middle::astencode::vtable_decoder_helpers;\n \n \n use std::hash::HashUtil;\n-use std::uint;\n+use std::u64;\n use std::io::WriterUtil;\n use std::io;\n use std::option;\n@@ -207,9 +207,9 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n-fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n+fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n-        do reader::with_doc_data(val_doc) |data| { uint::parse_bytes(data, 10u) }\n+        do reader::with_doc_data(val_doc) |data| { u64::parse_bytes(data, 10u) }\n     }\n }\n "}, {"sha": "21eee26620c0d74d25f2c63022184a306c81bc98", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -292,7 +292,7 @@ fn encode_symbol(ecx: &EncodeContext,\n \n fn encode_disr_val(_: &EncodeContext,\n                    ebml_w: &mut writer::Encoder,\n-                   disr_val: uint) {\n+                   disr_val: ty::Disr) {\n     ebml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_str();\n     ebml_w.writer.write(s.as_bytes());"}, {"sha": "9a92d91ab5041032f0fdbcecdaada1abbba29a39", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -245,7 +245,7 @@ pub enum VecLenOpt {\n // range)\n enum Opt {\n     lit(Lit),\n-    var(/* disr val */ uint, @adt::Repr),\n+    var(ty::Disr, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n@@ -992,7 +992,7 @@ struct ExtractedBlock {\n \n fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n-                            disr_val: uint,\n+                            disr_val: ty::Disr,\n                             val: ValueRef)\n     -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_variant_args\");"}, {"sha": "010b2f8f9f49df375343c80362cb7c89d701f1cc", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -55,6 +55,7 @@ use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::ty;\n+use middle::ty::Disr;\n use syntax::ast;\n use util::ppaux::ty_to_str;\n \n@@ -64,7 +65,7 @@ use middle::trans::type_::Type;\n /// Representations.\n pub enum Repr {\n     /// C-like enums; basically an int.\n-    CEnum(uint, uint), // discriminant range\n+    CEnum(Disr, Disr), // discriminant range\n     /**\n      * Single-case variants, and structs/tuples/records.\n      *\n@@ -89,7 +90,7 @@ pub enum Repr {\n      * is represented such that `None` is a null pointer and `Some` is the\n      * identity function.\n      */\n-    NullablePointer{ nonnull: Struct, nndiscr: uint, ptrfield: uint,\n+    NullablePointer{ nonnull: Struct, nndiscr: Disr, ptrfield: uint,\n                      nullfields: ~[ty::t] }\n }\n \n@@ -140,7 +141,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, ftys, packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            struct Case { discr: uint, tys: ~[ty::t] };\n+            struct Case { discr: Disr, tys: ~[ty::t] };\n             impl Case {\n                 fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n                     mk_struct(cx, self.tys, false).size == 0\n@@ -177,7 +178,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n-            if !cases.iter().enumerate().all(|(i,c)| c.discr == i) {\n+            if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))\n@@ -306,15 +307,15 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     match *r {\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n         Univariant(*) => C_uint(bcx.ccx(), 0),\n-        General(ref cases) => load_discr(bcx, scrutinee, 0, cases.len() - 1),\n+        General(ref cases) => load_discr(bcx, scrutinee, 0, (cases.len() - 1) as Disr),\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n                  Type::enum_discrim(bcx.ccx()))\n         }\n     }\n }\n \n-fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: uint, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -323,7 +324,7 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: uint, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: uint, max: uint)\n+fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let ptr = GEPi(bcx, scrutinee, [0, 0]);\n     if max + 1 == min {\n@@ -347,16 +348,16 @@ fn load_discr(bcx: @mut Block, scrutinee: ValueRef, min: uint, max: uint)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: @mut Block, r: &Repr, discr: uint) -> _match::opt_result {\n+pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result {\n     match *r {\n         CEnum(*) => {\n-            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr)))\n+            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr /*bad*/as uint)))\n         }\n         Univariant(*) => {\n             bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n         General(*) => {\n-            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr)))\n+            _match::single_result(rslt(bcx, C_uint(bcx.ccx(), discr /*bad*/as uint)))\n         }\n         NullablePointer{ _ } => {\n             assert!(discr == 0 || discr == 1);\n@@ -370,11 +371,11 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: uint) -> _match::opt_result\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n+pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(min, max) => {\n             assert!(min <= discr && discr <= max);\n-            Store(bcx, C_uint(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+            Store(bcx, C_uint(bcx.ccx(), discr/*bad*/ as uint), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n@@ -385,7 +386,7 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n             assert_eq!(discr, 0);\n         }\n         General(*) => {\n-            Store(bcx, C_uint(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+            Store(bcx, C_uint(bcx.ccx(), discr/*bad*/ as uint), GEPi(bcx, val, [0, 0]))\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             if discr != nndiscr {\n@@ -401,7 +402,7 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint) {\n  * The number of fields in a given case; for use when obtaining this\n  * information from the type or definition is less convenient.\n  */\n-pub fn num_args(r: &Repr, discr: uint) -> uint {\n+pub fn num_args(r: &Repr, discr: Disr) -> uint {\n     match *r {\n         CEnum(*) => 0,\n         Univariant(ref st, dtor) => {\n@@ -416,7 +417,7 @@ pub fn num_args(r: &Repr, discr: uint) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: uint,\n+pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -494,13 +495,13 @@ pub fn trans_drop_flag_ptr(bcx: @mut Block, r: &Repr, val: ValueRef) -> ValueRef\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n+pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(min, max) => {\n             assert_eq!(vals.len(), 0);\n             assert!(min <= discr && discr <= max);\n-            C_uint(ccx, discr)\n+            C_uint(ccx, discr/*bad*/ as uint)\n         }\n         Univariant(ref st, _dro) => {\n             assert_eq!(discr, 0);\n@@ -509,7 +510,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n         General(ref cases) => {\n             let case = &cases[discr];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n-            let discr_ty = C_uint(ccx, discr);\n+            let discr_ty = C_uint(ccx, discr/*bad*/ as uint);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n             C_struct(contents + &[padding(max_sz - case.size)])\n@@ -581,15 +582,15 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n-    -> uint {\n+    -> Disr {\n     match *r {\n-        CEnum(*) => const_to_uint(val) as uint,\n+        CEnum(*) => const_to_uint(val) as Disr,\n         Univariant(*) => 0,\n-        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as uint,\n+        General(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr,\n         NullablePointer{ nndiscr, ptrfield, _ } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n-                (1 - nndiscr) as uint\n+                (1 - nndiscr) as Disr\n             } else {\n                 nndiscr\n             }\n@@ -605,7 +606,7 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n  * raw LLVM-level structs and arrays.)\n  */\n pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: uint, ix: uint) -> ValueRef {\n+                       _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(*) => ccx.sess.bug(\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),"}, {"sha": "634e339e03de068bf7ac9220f1ac2e2e944bbf70", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -2014,7 +2014,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n                           _enum_id: ast::NodeId,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n-                          disr: uint,\n+                          disr: ty::Disr,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n@@ -2063,7 +2063,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     ccx: @mut CrateContext,\n     ctor_id: ast::NodeId,\n     args: &[A],\n-    disr: uint,\n+    disr: ty::Disr,\n     param_substs: Option<@param_substs>,\n     llfndecl: ValueRef)\n {"}, {"sha": "dc45632a2d3da8f9a71c789736cdb141fc3096b0", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -453,7 +453,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               (expr::cast_enum, expr::cast_float)  => {\n                 let repr = adt::represent_type(cx, basety);\n                 let discr = adt::const_get_discrim(cx, repr, v);\n-                let iv = C_uint(cx, discr);\n+                let iv = C_uint(cx, discr /*bad*/ as uint);\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {"}, {"sha": "06c45e563c0da36622e7671e90ce5aa7d1de8251", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -1118,7 +1118,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::NodeId>,\n-                         op: &fn(uint, (&[ty::field])) -> R) -> R {\n+                         op: &fn(ty::Disr, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs))\n@@ -1235,7 +1235,7 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: uint,\n+fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n              fields: &[(uint, @ast::expr)],\n              optbase: Option<StructBaseInfo>,\n              dest: Dest) -> @mut Block {"}, {"sha": "a58cf35c015e2c4f1c2cdbc0017888e36f1cc268", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -317,7 +317,7 @@ impl Reflector {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n-                                         this.c_uint(v.disr_val),\n+                                         this.c_uint(v.disr_val /*bad*/ as uint),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(\"enum_variant\", variant_args) |this| {"}, {"sha": "6593e5632fbd84567fb7098f17ec8a3d93939e17", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -48,7 +48,9 @@ use syntax::abi::AbiSet;\n use syntax;\n use extra::enum_set::{EnumSet, CLike};\n \n-pub static INITIAL_DISCRIMINANT_VALUE: uint = 0;\n+pub type Disr = u64;\n+\n+pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n@@ -3803,7 +3805,7 @@ pub struct VariantInfo {\n     ctor_ty: t,\n     name: ast::ident,\n     id: ast::def_id,\n-    disr_val: uint,\n+    disr_val: Disr,\n     vis: visibility\n }\n \n@@ -3814,7 +3816,7 @@ impl VariantInfo {\n     /// Does not do any caching of the value in the type context.\n     pub fn from_ast_variant(cx: ctxt,\n                             ast_variant: &ast::variant,\n-                            discriminant: uint) -> VariantInfo {\n+                            discriminant: Disr) -> VariantInfo {\n \n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n \n@@ -4008,7 +4010,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n                 }, _) => {\n-            let mut last_discriminant: Option<uint> = None;\n+            let mut last_discriminant: Option<Disr> = None;\n             @enum_definition.variants.iter().map(|variant| {\n \n                 let mut discriminant = match last_discriminant {\n@@ -4018,8 +4020,8 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n \n                 match variant.node.disr_expr {\n                     Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n-                        Ok(const_eval::const_int(val)) => discriminant = val as uint,\n-                        Ok(const_eval::const_uint(val)) => discriminant = val as uint,\n+                        Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n+                        Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n                         Ok(_) => {\n                             cx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}, {"sha": "a839ea976e62e60a44481aadac5f2b9a315b8556", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8ef8dd9ceb0a4790d65c1dd8327a0d5618c3a46f", "patch": "@@ -83,7 +83,7 @@ use middle::pat_util;\n use middle::lint::unreachable_code;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n-use middle::ty::{substs, param_ty, ExprTyProvider};\n+use middle::ty::{substs, param_ty, Disr, ExprTyProvider};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n@@ -3000,8 +3000,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: ~[@ty::VariantInfo] = ~[];\n-        let mut disr_vals: ~[uint] = ~[];\n-        let mut prev_disr_val: Option<uint> = None;\n+        let mut disr_vals: ~[ty::Disr] = ~[];\n+        let mut prev_disr_val: Option<ty::Disr> = None;\n \n         for v in vs.iter() {\n \n@@ -3024,8 +3024,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                     // handle, so we may still get an internal compiler error\n \n                     match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n-                        Ok(const_eval::const_int(val)) => current_disr_val = val as uint,\n-                        Ok(const_eval::const_uint(val)) => current_disr_val = val as uint,\n+                        Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n+                        Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }"}]}