{"sha": "785643a5eb6727d788b218e10ce60219b1c3c27f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NTY0M2E1ZWI2NzI3ZDc4OGIyMThlMTBjZTYwMjE5YjFjM2MyN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-06T23:30:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-06T23:30:57Z"}, "message": "Auto merge of #45668 - nikomatsakis:nll-free-region, r=arielb1\n\nextend NLL with preliminary support for free regions on functions\n\nThis PR extends https://github.com/rust-lang/rust/pull/45538 with support for free regions. This is pretty preliminary and will no doubt want to change in various ways, particularly as we add support for closures, but it's enough to get the basic idea in place:\n\n- We now create specific regions to represent each named lifetime declared on the function.\n- Region values can contain references to these regions (represented for now as a `BTreeSet<RegionIndex>`).\n- If we wind up trying to infer that `'a: 'b` must hold, but no such relationship was declared, we report an error.\n\nIt also does a number of drive-by refactorings.\n\nr? @arielb1\n\ncc @spastorino", "tree": {"sha": "c2e071a6e9a6d1e5ded1ce781dace6eda4d4dc14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2e071a6e9a6d1e5ded1ce781dace6eda4d4dc14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/785643a5eb6727d788b218e10ce60219b1c3c27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/785643a5eb6727d788b218e10ce60219b1c3c27f", "html_url": "https://github.com/rust-lang/rust/commit/785643a5eb6727d788b218e10ce60219b1c3c27f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/785643a5eb6727d788b218e10ce60219b1c3c27f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0e45a323f85a1940d997ac237023c00670da67", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0e45a323f85a1940d997ac237023c00670da67", "html_url": "https://github.com/rust-lang/rust/commit/bd0e45a323f85a1940d997ac237023c00670da67"}, {"sha": "7b4282e02bdff3b91c4a317af94ce18149044830", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4282e02bdff3b91c4a317af94ce18149044830", "html_url": "https://github.com/rust-lang/rust/commit/7b4282e02bdff3b91c4a317af94ce18149044830"}], "stats": {"total": 882, "additions": 660, "deletions": 222}, "files": [{"sha": "e9916bd77e7582ea59880046bd41e4a0fe468653", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -262,6 +262,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n+        if self.tcx.sess.opts.debugging_opts.nll {\n+            for error in errors {\n+                match *error {\n+                    RegionResolutionError::ConcreteFailure(ref origin, ..) |\n+                    RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n+                        self.tcx.sess.span_warn(\n+                            origin.span(),\n+                            \"not reporting region error due to -Znll\");\n+                    }\n+\n+                    RegionResolutionError::SubSupConflict(ref rvo, ..) => {\n+                        self.tcx.sess.span_warn(\n+                            rvo.span(),\n+                            \"not reporting region error due to -Znll\");\n+                    }\n+                }\n+            }\n+\n+            return;\n+        }\n+\n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);"}, {"sha": "3bcdc4f7e2c630a860a483c733a9adbe69f95b2d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -182,6 +182,19 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n         result\n     }\n+\n+    /// Returns all regions that are known to outlive `r_a`. For\n+    /// example, in a function:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b: 'a, 'c: 'b>() { .. }\n+    /// ```\n+    ///\n+    /// if `r_a` represents `'a`, this function would return `{'b, 'c}`.\n+    pub fn regions_that_outlive<'a, 'gcx>(&self, r_a: Region<'tcx>) -> Vec<&Region<'tcx>> {\n+        assert!(is_free(r_a));\n+        self.relation.greater_than(&r_a)\n+    }\n }\n \n fn is_free(r: Region) -> bool {"}, {"sha": "00863abc84deeb61b4e5652aadbdb399b34895fc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -209,7 +209,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_ty(&mut self,\n                         ty: & $($mutability)* Ty<'tcx>,\n-                        _: Lookup) {\n+                        _: TyContext) {\n                 self.super_ty(ty);\n             }\n \n@@ -256,8 +256,9 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_local_decl(&mut self,\n+                                local: Local,\n                                 local_decl: & $($mutability)* LocalDecl<'tcx>) {\n-                self.super_local_decl(local_decl);\n+                self.super_local_decl(local, local_decl);\n             }\n \n             fn visit_local(&mut self,\n@@ -291,14 +292,14 @@ macro_rules! make_mir_visitor {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                let lookup = Lookup::Src(SourceInfo {\n+                let lookup = TyContext::SourceInfo(SourceInfo {\n                     span: mir.span,\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n                 });\n                 self.visit_ty(&$($mutability)* mir.return_ty, lookup);\n \n-                for local_decl in &$($mutability)* mir.local_decls {\n-                    self.visit_local_decl(local_decl);\n+                for local in mir.local_decls.indices() {\n+                    self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n                 }\n \n                 self.visit_span(&$($mutability)* mir.span);\n@@ -359,7 +360,8 @@ macro_rules! make_mir_visitor {\n                         for operand in lvalues {\n                             self.visit_lvalue(& $($mutability)* operand.lval,\n                                               LvalueContext::Validate, location);\n-                            self.visit_ty(& $($mutability)* operand.ty, Lookup::Loc(location));\n+                            self.visit_ty(& $($mutability)* operand.ty,\n+                                          TyContext::Location(location));\n                         }\n                     }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n@@ -421,7 +423,7 @@ macro_rules! make_mir_visitor {\n                                                 ref values,\n                                                 ref targets } => {\n                         self.visit_operand(discr, source_location);\n-                        self.visit_ty(switch_ty, Lookup::Loc(source_location));\n+                        self.visit_ty(switch_ty, TyContext::Location(source_location));\n                         for value in &values[..] {\n                             self.visit_const_int(value, source_location);\n                         }\n@@ -545,7 +547,7 @@ macro_rules! make_mir_visitor {\n                                  ref $($mutability)* operand,\n                                  ref $($mutability)* ty) => {\n                         self.visit_operand(operand, location);\n-                        self.visit_ty(ty, Lookup::Loc(location));\n+                        self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n                     Rvalue::BinaryOp(_bin_op,\n@@ -567,15 +569,15 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n-                        self.visit_ty(ty, Lookup::Loc(location));\n+                        self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n                     Rvalue::Aggregate(ref $($mutability)* kind,\n                                       ref $($mutability)* operands) => {\n                         let kind = &$($mutability)* **kind;\n                         match *kind {\n                             AggregateKind::Array(ref $($mutability)* ty) => {\n-                                self.visit_ty(ty, Lookup::Loc(location));\n+                                self.visit_ty(ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n@@ -645,7 +647,7 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* ty,\n                 } = *static_;\n                 self.visit_def_id(def_id, location);\n-                self.visit_ty(ty, Lookup::Loc(location));\n+                self.visit_ty(ty, TyContext::Location(location));\n             }\n \n             fn super_projection(&mut self,\n@@ -675,7 +677,7 @@ macro_rules! make_mir_visitor {\n                     ProjectionElem::Subslice { from: _, to: _ } => {\n                     }\n                     ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n-                        self.visit_ty(ty, Lookup::Loc(location));\n+                        self.visit_ty(ty, TyContext::Location(location));\n                     }\n                     ProjectionElem::Index(ref $($mutability)* local) => {\n                         self.visit_local(local, LvalueContext::Consume, location);\n@@ -690,6 +692,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_local_decl(&mut self,\n+                                local: Local,\n                                 local_decl: & $($mutability)* LocalDecl<'tcx>) {\n                 let LocalDecl {\n                     mutability: _,\n@@ -701,7 +704,10 @@ macro_rules! make_mir_visitor {\n                     is_user_variable: _,\n                 } = *local_decl;\n \n-                self.visit_ty(ty, Lookup::Src(*source_info));\n+                self.visit_ty(ty, TyContext::LocalDecl {\n+                    local,\n+                    source_info: *source_info,\n+                });\n                 self.visit_source_info(source_info);\n                 self.visit_visibility_scope(lexical_scope);\n             }\n@@ -725,7 +731,7 @@ macro_rules! make_mir_visitor {\n                 } = *constant;\n \n                 self.visit_span(span);\n-                self.visit_ty(ty, Lookup::Loc(location));\n+                self.visit_ty(ty, TyContext::Location(location));\n                 self.visit_literal(literal, location);\n             }\n \n@@ -803,10 +809,21 @@ macro_rules! make_mir_visitor {\n make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n \n+/// Extra information passed to `visit_ty` and friends to give context\n+/// about where the type etc appears.\n #[derive(Copy, Clone, Debug)]\n-pub enum Lookup {\n-    Loc(Location),\n-    Src(SourceInfo),\n+pub enum TyContext {\n+    LocalDecl {\n+        /// The index of the local variable we are visiting.\n+        local: Local,\n+\n+        /// The source location where this local variable was declared.\n+        source_info: SourceInfo,\n+    },\n+\n+    Location(Location),\n+\n+    SourceInfo(SourceInfo),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "94edaa746f915b08a6d2f83f77888288e4affd72", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -145,7 +145,7 @@ pub struct BitMatrix {\n }\n \n impl BitMatrix {\n-    // Create a new `rows x columns` matrix, initially empty.\n+    /// Create a new `rows x columns` matrix, initially empty.\n     pub fn new(rows: usize, columns: usize) -> BitMatrix {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of u64s.\n@@ -163,29 +163,33 @@ impl BitMatrix {\n         (start, start + u64s_per_row)\n     }\n \n-    pub fn add(&mut self, source: usize, target: usize) -> bool {\n-        let (start, _) = self.range(source);\n-        let (word, mask) = word_mask(target);\n+    /// Sets the cell at `(row, column)` to true. Put another way, add\n+    /// `column` to the bitset for `row`.\n+    ///\n+    /// Returns true if this changed the matrix, and false otherwies.\n+    pub fn add(&mut self, row: usize, column: usize) -> bool {\n+        let (start, _) = self.range(row);\n+        let (word, mask) = word_mask(column);\n         let vector = &mut self.vector[..];\n         let v1 = vector[start + word];\n         let v2 = v1 | mask;\n         vector[start + word] = v2;\n         v1 != v2\n     }\n \n-    /// Do the bits from `source` contain `target`?\n-    ///\n-    /// Put another way, if the matrix represents (transitive)\n-    /// reachability, can `source` reach `target`?\n-    pub fn contains(&self, source: usize, target: usize) -> bool {\n-        let (start, _) = self.range(source);\n-        let (word, mask) = word_mask(target);\n+    /// Do the bits from `row` contain `column`? Put another way, is\n+    /// the matrix cell at `(row, column)` true?  Put yet another way,\n+    /// if the matrix represents (transitive) reachability, can\n+    /// `row` reach `column`?\n+    pub fn contains(&self, row: usize, column: usize) -> bool {\n+        let (start, _) = self.range(row);\n+        let (word, mask) = word_mask(column);\n         (self.vector[start + word] & mask) != 0\n     }\n \n-    /// Returns those indices that are reachable from both `a` and\n-    /// `b`. This is an O(n) operation where `n` is the number of\n-    /// elements (somewhat independent from the actual size of the\n+    /// Returns those indices that are true in rows `a` and `b`.  This\n+    /// is an O(n) operation where `n` is the number of elements\n+    /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n     pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n         let (a_start, a_end) = self.range(a);\n@@ -206,7 +210,7 @@ impl BitMatrix {\n         result\n     }\n \n-    /// Add the bits from `read` to the bits from `write`,\n+    /// Add the bits from row `read` to the bits from row `write`,\n     /// return true if anything changed.\n     ///\n     /// This is used when computing transitive reachability because if\n@@ -227,6 +231,8 @@ impl BitMatrix {\n         changed\n     }\n \n+    /// Iterates through all the columns set to true in a given row of\n+    /// the matrix.\n     pub fn iter<'a>(&'a self, row: usize) -> BitVectorIter<'a> {\n         let (start, end) = self.range(row);\n         BitVectorIter {"}, {"sha": "933e08811ce5d6a647de68f4f8e08e6b855a9d15", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -134,12 +134,12 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n         }\n     }\n \n-    /// Returns a vector of all things less than `a`.\n+    /// Returns a vector of all things greater than `a`.\n     ///\n     /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n     /// I'm too lazy to make that work, and -- given the caching\n     /// strategy -- it'd be a touch tricky anyhow.\n-    pub fn less_than(&self, a: &T) -> Vec<&T> {\n+    pub fn greater_than(&self, a: &T) -> Vec<&T> {\n         match self.index(a) {\n             Some(a) => self.with_closure(|closure| {\n                 closure.iter(a.0).map(|i| &self.elements[i]).collect()"}, {"sha": "2073d49530061fc728d97a44cec2e4409a97c5d5", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n-use rustc::mir::visit::{MutVisitor, Lookup};\n+use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n@@ -165,7 +165,7 @@ struct GlobalizeMir<'a, 'gcx: 'a> {\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         if let Some(lifted) = self.tcx.lift(ty) {\n             *ty = lifted;\n         } else {"}, {"sha": "e8bf543b70b6a1d443151888d81290cef66722ee", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -38,7 +38,7 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<&'a RegionInferenceContext>,\n+    nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -69,7 +69,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<&'a RegionInferenceContext>)\n+               nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>)\n                -> Self {\n         let mut visitor = GatherBorrows { idx_vec: IndexVec::new(),\n                                           location_map: FxHashMap(),\n@@ -139,11 +139,21 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                                            location: Location) {\n         if let Some(regioncx) = self.nonlexical_regioncx {\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n-                let borrow_region = regioncx.region_value(borrow_data.region.to_region_index());\n-                if !borrow_region.may_contain(location) && location != borrow_data.location {\n-                    debug!(\"kill_loans_out_of_scope_at_location: kill{:?} \\\n-                           location={:?} borrow_data={:?}\", borrow_index, location, borrow_data);\n-                    sets.kill(&borrow_index);\n+                let borrow_region = borrow_data.region.to_region_index();\n+                if !regioncx.region_contains_point(borrow_region, location) {\n+                    // The region checker really considers the borrow\n+                    // to start at the point **after** the location of\n+                    // the borrow, but the borrow checker puts the gen\n+                    // directly **on** the location of the\n+                    // borrow. This results in a gen/kill both being\n+                    // generated for same point if we are not\n+                    // careful. Probably we should change the point of\n+                    // the gen, but for now we hackily account for the\n+                    // mismatch here by not generating a kill for the\n+                    // location on the borrow itself.\n+                    if location != borrow_data.location {\n+                        sets.kill(&borrow_index);\n+                    }\n                 }\n             }\n         }"}, {"sha": "d356d3b5a850874da1acd393a1968b37d19b680d", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc::middle::region;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::{BasicBlock, Location, Mir, Rvalue, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Visitor, Lookup};\n+use rustc::mir::visit::{MutVisitor, Visitor, TyContext};\n use rustc::ty::{Ty, RegionKind, TyCtxt};\n \n pub struct CleanEndRegions;\n@@ -67,7 +67,7 @@ impl<'tcx> Visitor<'tcx> for GatherBorrowedRegions {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_ty(&mut self, ty: &Ty<'tcx>, _: Lookup) {\n+    fn visit_ty(&mut self, ty: &Ty<'tcx>, _: TyContext) {\n         // Gather regions that occur in types\n         for re in ty.walk().flat_map(|t| t.regions()) {\n             match *re {"}, {"sha": "08ca20e50eb7f8eef5f021ad82678a234bb10aec", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -17,7 +17,7 @@\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::*;\n-use rustc::mir::visit::{MutVisitor, Lookup};\n+use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::mir::transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n@@ -35,7 +35,7 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         if !self.in_validation_statement {\n             *ty = self.tcx.erase_regions(ty);\n         }"}, {"sha": "a2f9bbb174eb737b2b6a91e8a51615b350650c0e", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -29,7 +29,7 @@ use super::region_infer::RegionInferenceContext;\n \n pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    regioncx: &mut RegionInferenceContext,\n+    regioncx: &mut RegionInferenceContext<'tcx>,\n     mir: &Mir<'tcx>,\n     mir_source: MirSource,\n     liveness: &LivenessResults,\n@@ -45,7 +45,7 @@ pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n \n struct ConstraintGeneration<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    regioncx: &'cx mut RegionInferenceContext,\n+    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n     mir: &'cx Mir<'tcx>,\n     liveness: &'cx LivenessResults,\n     mir_source: MirSource,\n@@ -191,14 +191,16 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n         _borrowed_lv: &Lvalue<'tcx>,\n     ) {\n         let tcx = self.infcx.tcx;\n+        let span = self.mir.source_info(location).span;\n         let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n \n         let destination_region = match destination_ty.sty {\n             ty::TyRef(r, _) => r,\n             _ => bug!()\n         };\n \n-        self.regioncx.add_outlives(borrow_region.to_region_index(),\n+        self.regioncx.add_outlives(span,\n+                                   borrow_region.to_region_index(),\n                                    destination_region.to_region_index(),\n                                    location.successor_within_block());\n     }\n@@ -226,7 +228,9 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n                         },\n                     }\n \n-                    self.regioncx.add_outlives(base_region.to_region_index(),\n+                    let span = self.mir.source_info(location).span;\n+                    self.regioncx.add_outlives(span,\n+                                               base_region.to_region_index(),\n                                                borrow_region.to_region_index(),\n                                                location.successor_within_block());\n                 }\n@@ -259,8 +263,9 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n             let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n             let rv_ty = rv.ty(self.mir, tcx);\n \n+            let span = self.mir.source_info(location).span;\n             for (a, b) in subtype::outlives_pairs(tcx, rv_ty, destination_ty) {\n-                self.regioncx.add_outlives(a, b, location.successor_within_block());\n+                self.regioncx.add_outlives(span, a, b, location.successor_within_block());\n             }\n         }\n "}, {"sha": "006a2f9047ad9a64211f14721562d2f1309353be", "filename": "src/librustc_mir/transform/nll/free_regions.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Ffree_regions.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to extract the free regions declared on a function and the\n+//! relationships between them. For example:\n+//!\n+//! ```\n+//! fn foo<'a, 'b, 'c: 'b>() { }\n+//! ```\n+//!\n+//! here we would be returning a map assigning each of `{'a, 'b, 'c}`\n+//! to an index, as well as the `FreeRegionMap` which can compute\n+//! relationships between them.\n+//!\n+//! The code in this file doesn't *do anything* with those results; it\n+//! just returns them for other code to use.\n+\n+use rustc::infer::InferCtxt;\n+use rustc::middle::free_region::FreeRegionMap;\n+use rustc::mir::transform::MirSource;\n+use rustc::ty;\n+use rustc::ty::subst::Substs;\n+use rustc::util::nodemap::FxHashMap;\n+\n+#[derive(Debug)]\n+pub struct FreeRegions<'tcx> {\n+    /// Given a free region defined on this function (either early- or\n+    /// late-bound), this maps it to its internal region index. The\n+    /// corresponding variable will be \"capped\" so that it cannot\n+    /// grow.\n+    pub indices: FxHashMap<ty::Region<'tcx>, usize>,\n+\n+    /// The map from the typeck tables telling us how to relate free regions.\n+    pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n+}\n+\n+pub fn free_regions<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    source: MirSource,\n+) -> FreeRegions<'tcx> {\n+    debug!(\"free_regions(source={:?})\", source);\n+\n+    let item_id = source.item_id();\n+    let item_def_id = infcx.tcx.hir.local_def_id(item_id);\n+\n+    let mut indices = FxHashMap();\n+\n+    // Extract the early regions.\n+    let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n+    for item_subst in item_substs {\n+        if let Some(region) = item_subst.as_region() {\n+            insert_free_region(&mut indices, region);\n+        }\n+    }\n+\n+    // Extract the late-bound regions. Use the liberated fn sigs,\n+    // where the late-bound regions will have been converted into free\n+    // regions, and add them to the map.\n+    let fn_hir_id = infcx.tcx.hir.node_to_hir_id(item_id);\n+    let tables = infcx.tcx.typeck_tables_of(item_def_id);\n+    let fn_sig = tables.liberated_fn_sigs()[fn_hir_id].clone();\n+    infcx\n+        .tcx\n+        .for_each_free_region(&fn_sig.inputs_and_output, |region| {\n+            if let ty::ReFree(_) = *region {\n+                insert_free_region(&mut indices, region);\n+            }\n+        });\n+\n+    debug!(\"free_regions: indices={:#?}\", indices);\n+\n+    FreeRegions { indices, free_region_map: &tables.free_region_map }\n+}\n+\n+fn insert_free_region<'tcx>(\n+    free_regions: &mut FxHashMap<ty::Region<'tcx>, usize>,\n+    region: ty::Region<'tcx>,\n+) {\n+    let len = free_regions.len();\n+    free_regions.entry(region).or_insert(len);\n+}"}, {"sha": "e24def2292ec6e0656f328696cb10c65e79fdb11", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n use rustc::ty::{self, RegionKind};\n-use rustc::mir::{Location, Mir};\n+use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::infer::InferCtxt;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::collections::BTreeSet;\n-use std::fmt;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n+mod free_regions;\n mod subtype;\n \n pub(crate) mod region_infer;\n@@ -36,9 +36,12 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source: MirSource,\n     mir: &mut Mir<'tcx>,\n-) -> RegionInferenceContext {\n+) -> RegionInferenceContext<'tcx> {\n+    // Compute named region information.\n+    let free_regions = &free_regions::free_regions(infcx, source);\n+\n     // Replace all regions with fresh inference variables.\n-    let num_region_variables = renumber::renumber_mir(infcx, mir);\n+    let num_region_variables = renumber::renumber_mir(infcx, free_regions, mir);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -61,11 +64,9 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n \n     // Create the region inference context, generate the constraints,\n     // and then solve them.\n-    let mut regioncx = RegionInferenceContext::new(num_region_variables);\n+    let mut regioncx = RegionInferenceContext::new(free_regions, num_region_variables, mir);\n     constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, source, liveness);\n-    let errors = regioncx.solve(infcx, &mir);\n-\n-    assert!(errors.is_empty(), \"FIXME: report region inference failures\");\n+    regioncx.solve(infcx, &mir);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests.\n@@ -149,27 +150,6 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     });\n }\n \n-#[derive(Clone, Default, PartialEq, Eq)]\n-pub struct Region {\n-    points: BTreeSet<Location>,\n-}\n-\n-impl fmt::Debug for Region {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(formatter, \"{:?}\", self.points)\n-    }\n-}\n-\n-impl Region {\n-    pub fn add_point(&mut self, point: Location) -> bool {\n-        self.points.insert(point)\n-    }\n-\n-    pub fn may_contain(&self, point: Location) -> bool {\n-        self.points.contains(&point)\n-    }\n-}\n-\n newtype_index!(RegionIndex {\n     DEBUG_FORMAT = \"'_#{}r\",\n });"}, {"sha": "553d5ad4a320ab687aea1c9d8f6a115b2914f7a2", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 255, "deletions": 93, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -8,161 +8,328 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{Region, RegionIndex};\n-use std::mem;\n+use super::RegionIndex;\n+use super::free_regions::FreeRegions;\n use rustc::infer::InferCtxt;\n use rustc::mir::{Location, Mir};\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::ty;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n+use std::collections::BTreeSet;\n+use std::fmt;\n+use syntax_pos::Span;\n \n-pub struct RegionInferenceContext {\n+pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n     /// variables are identified by their index (`RegionIndex`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n-    definitions: IndexVec<RegionIndex, RegionDefinition>,\n+    definitions: IndexVec<RegionIndex, RegionDefinition<'tcx>>,\n+\n+    /// The indices of all \"free regions\" in scope. These are the\n+    /// lifetime parameters (anonymous and named) declared in the\n+    /// function signature:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &Foo<'a, 'b>)\n+    ///            ^^  ^^     ^\n+    ///\n+    /// These indices will be from 0..N, as it happens, but we collect\n+    /// them into a vector for convenience.\n+    free_regions: Vec<RegionIndex>,\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n+}\n+\n+#[derive(Default)]\n+struct RegionDefinition<'tcx> {\n+    /// If this is a free-region, then this is `Some(X)` where `X` is\n+    /// the name of the region.\n+    name: Option<ty::Region<'tcx>>,\n+\n+    /// If true, this is a constant region which cannot grow larger.\n+    /// This is used for named regions as well as `'static`.\n+    constant: bool,\n+\n+    /// The current value of this inference variable. This starts out\n+    /// empty, but grows as we add constraints. The final value is\n+    /// determined when `solve()` is executed.\n+    value: Region,\n+}\n \n-    /// List of errors we have accumulated as we add constraints.\n-    /// After solving is done, this is replaced with an empty vector.\n-    errors: Vec<InferenceError>,\n+/// The value of an individual region variable. Region variables\n+/// consist of a set of points in the CFG as well as a set of \"free\n+/// regions\", which are sometimes written as `end(R)`. These\n+/// correspond to the named lifetimes and refer to portions of the\n+/// caller's control-flow graph -- specifically some portion that can\n+/// be reached after we return.\n+#[derive(Clone, Default, PartialEq, Eq)]\n+struct Region {\n+    points: BTreeSet<Location>,\n+    free_regions: BTreeSet<RegionIndex>,\n }\n \n-pub struct InferenceError {\n-    pub constraint_point: Location,\n-    pub name: (), // FIXME(nashenas88) RegionName\n+impl fmt::Debug for Region {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        formatter\n+            .debug_set()\n+            .entries(&self.points)\n+            .entries(&self.free_regions)\n+            .finish()\n+    }\n }\n \n-#[derive(Default)]\n-struct RegionDefinition {\n-    name: (), // FIXME(nashenas88) RegionName\n-    value: Region,\n-    capped: bool,\n+impl Region {\n+    fn add_point(&mut self, point: Location) -> bool {\n+        self.points.insert(point)\n+    }\n+\n+    fn add_free_region(&mut self, region: RegionIndex) -> bool {\n+        self.free_regions.insert(region)\n+    }\n+\n+    fn contains_point(&self, point: Location) -> bool {\n+        self.points.contains(&point)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Constraint {\n-    sub: RegionIndex,\n+    /// Where did this constraint arise?\n+    span: Span,\n+\n+    /// The region SUP must outlive SUB...\n     sup: RegionIndex,\n+\n+    /// Region that must be outlived.\n+    sub: RegionIndex,\n+\n+    /// At this location.\n     point: Location,\n }\n \n-impl RegionInferenceContext {\n-    pub fn new(num_region_variables: usize) -> Self {\n-        Self {\n+impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n+    /// Creates a new region inference context with a total of\n+    /// `num_region_variables` valid inference variables; the first N\n+    /// of those will be constant regions representing the free\n+    /// regions defined in `free_regions`.\n+    pub fn new(\n+        free_regions: &FreeRegions<'tcx>,\n+        num_region_variables: usize,\n+        mir: &Mir<'tcx>,\n+    ) -> Self {\n+        let mut result = Self {\n             definitions: (0..num_region_variables)\n                 .map(|_| RegionDefinition::default())\n                 .collect(),\n             constraints: Vec::new(),\n-            errors: Vec::new(),\n-        }\n+            free_regions: Vec::new(),\n+        };\n+\n+        result.init_free_regions(free_regions, mir);\n+\n+        result\n     }\n \n+    /// Initializes the region variables for each free region\n+    /// (lifetime parameter). The first N variables always correspond\n+    /// to the free regions appearing in the function signature (both\n+    /// named and anonymous) and where clauses. This function iterates\n+    /// over those regions and initializes them with minimum values.\n+    ///\n+    /// For example:\n+    ///\n+    ///     fn foo<'a, 'b>(..) where 'a: 'b\n+    ///\n+    /// would initialize two variables like so:\n+    ///\n+    ///     R0 = { CFG, R0 } // 'a\n+    ///     R1 = { CFG, R0, R1 } // 'b\n+    ///\n+    /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n+    /// and (b) any free regions that it outlives, which in this case\n+    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n+    /// hence contains R0 and R1.\n+    fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) {\n+        let &FreeRegions {\n+            ref indices,\n+            ref free_region_map,\n+        } = free_regions;\n+\n+        // For each free region X:\n+        for (free_region, index) in indices {\n+            let variable = RegionIndex::new(*index);\n+\n+            self.free_regions.push(variable);\n+\n+            // Initialize the name and a few other details.\n+            self.definitions[variable].name = Some(free_region);\n+            self.definitions[variable].constant = true;\n+\n+            // Add all nodes in the CFG to `definition.value`.\n+            for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+                let definition = &mut self.definitions[variable];\n+                for statement_index in 0..block_data.statements.len() + 1 {\n+                    let location = Location {\n+                        block,\n+                        statement_index,\n+                    };\n+                    definition.value.add_point(location);\n+                }\n+            }\n+\n+            // Add `end(X)` into the set for X.\n+            self.definitions[variable].value.add_free_region(variable);\n+\n+            // Go through each region Y that outlives X (i.e., where\n+            // Y: X is true). Add `end(X)` into the set for `Y`.\n+            for superregion in free_region_map.regions_that_outlive(&free_region) {\n+                let superregion_index = RegionIndex::new(indices[superregion]);\n+                self.definitions[superregion_index]\n+                    .value\n+                    .add_free_region(variable);\n+            }\n+\n+            debug!(\n+                \"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n+                free_region,\n+                variable,\n+                self.definitions[variable].value\n+            );\n+        }\n+    }\n \n     /// Returns an iterator over all the region indices.\n     pub fn regions(&self) -> impl Iterator<Item = RegionIndex> {\n         self.definitions.indices()\n     }\n \n-    /// Returns the inferred value for the region `r`.\n+    /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Until `solve()` executes, this value is not particularly meaningful.\n-    pub fn region_value(&self, r: RegionIndex) -> &Region {\n-        &self.definitions[r].value\n+    pub fn region_contains_point(&self, r: RegionIndex, p: Location) -> bool {\n+        self.definitions[r].value.contains_point(p)\n     }\n \n-    /// Flags a region as being \"capped\" -- this means that if its\n-    /// value is required to grow as a result of some constraint\n-    /// (e.g., `add_live_point` or `add_outlives`), that indicates an\n-    /// error. This is used for the regions representing named\n-    /// lifetime parameters on a function: they get initialized to\n-    /// their complete value, and then \"capped\" so that they can no\n-    /// longer grow.\n-    #[allow(dead_code)]\n-    pub(super) fn cap_var(&mut self, v: RegionIndex) {\n-        self.definitions[v].capped = true;\n+    /// Returns access to the value of `r` for debugging purposes.\n+    pub(super) fn region_value(&self, r: RegionIndex) -> &fmt::Debug {\n+        &self.definitions[r].value\n     }\n \n+    /// Indicates that the region variable `v` is live at the point `point`.\n     pub(super) fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         let definition = &mut self.definitions[v];\n-        if definition.value.add_point(point) {\n-            if definition.capped {\n-                self.errors.push(InferenceError {\n-                    constraint_point: point,\n-                    name: definition.name,\n-                });\n-            }\n+        if !definition.constant {\n+            definition.value.add_point(point);\n+        } else {\n+            // Constants are used for free regions, which already\n+            // contain all the points in the control-flow graph.\n+            assert!(definition.value.contains_point(point));\n         }\n     }\n \n-    pub(super) fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n+    pub(super) fn add_outlives(\n+        &mut self,\n+        span: Span,\n+        sup: RegionIndex,\n+        sub: RegionIndex,\n+        point: Location,\n+    ) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n-        self.constraints.push(Constraint { sup, sub, point });\n+        self.constraints.push(Constraint {\n+            span,\n+            sup,\n+            sub,\n+            point,\n+        });\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve<'a, 'gcx, 'tcx>(\n+    pub(super) fn solve(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n+        let errors = self.propagate_constraints(mir);\n+\n+        // worst error msg ever\n+        for (fr1, span, fr2) in errors {\n+            infcx.tcx.sess.span_err(\n+                span,\n+                &format!(\n+                    \"free region `{}` does not outlive `{}`\",\n+                    self.definitions[fr1].name.unwrap(),\n+                    self.definitions[fr2].name.unwrap()\n+                ),\n+            );\n+        }\n+    }\n+\n+    /// Propagate the region constraints: this will grow the values\n+    /// for each region variable until all the constraints are\n+    /// satisfied. Note that some values may grow **too** large to be\n+    /// feasible, but we check this later.\n+    fn propagate_constraints(\n         &mut self,\n-        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Mir<'tcx>,\n-    ) -> Vec<InferenceError>\n-    where\n-        'gcx: 'tcx + 'a,\n-        'tcx: 'a,\n-    {\n+        mir: &Mir<'tcx>,\n+    ) -> Vec<(RegionIndex, Span, RegionIndex)> {\n         let mut changed = true;\n-        let mut dfs = Dfs::new(infcx, mir);\n+        let mut dfs = Dfs::new(mir);\n+        let mut error_regions = FxHashSet();\n+        let mut errors = vec![];\n         while changed {\n             changed = false;\n             for constraint in &self.constraints {\n+                debug!(\"constraint: {:?}\", constraint);\n                 let sub = &self.definitions[constraint.sub].value.clone();\n                 let sup_def = &mut self.definitions[constraint.sup];\n-                debug!(\"constraint: {:?}\", constraint);\n+\n                 debug!(\"    sub (before): {:?}\", sub);\n                 debug!(\"    sup (before): {:?}\", sup_def.value);\n \n-                if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n-                    changed = true;\n-                    if sup_def.capped {\n-                        // This is kind of a hack, but when we add a\n-                        // constraint, the \"point\" is always the point\n-                        // AFTER the action that induced the\n-                        // constraint. So report the error on the\n-                        // action BEFORE that.\n-                        assert!(constraint.point.statement_index > 0);\n-                        let p = Location {\n-                            block: constraint.point.block,\n-                            statement_index: constraint.point.statement_index - 1,\n-                        };\n-\n-                        self.errors.push(InferenceError {\n-                            constraint_point: p,\n-                            name: sup_def.name,\n-                        });\n+                if !sup_def.constant {\n+                    // If this is not a constant, then grow the value as needed to\n+                    // accommodate the outlives constraint.\n+\n+                    if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                        changed = true;\n                     }\n-                }\n \n-                debug!(\"    sup (after) : {:?}\", sup_def.value);\n-                debug!(\"    changed     : {:?}\", changed);\n+                    debug!(\"    sup (after) : {:?}\", sup_def.value);\n+                    debug!(\"    changed     : {:?}\", changed);\n+                } else {\n+                    // If this is a constant, check whether it *would\n+                    // have* to grow in order for the constraint to be\n+                    // satisfied. If so, create an error.\n+\n+                    let mut sup_value = sup_def.value.clone();\n+                    if dfs.copy(sub, &mut sup_value, constraint.point) {\n+                        // Constant values start out with the entire\n+                        // CFG, so it must be some new free region\n+                        // that was added. Find one.\n+                        let &new_region = sup_value\n+                            .free_regions\n+                            .difference(&sup_def.value.free_regions)\n+                            .next()\n+                            .unwrap();\n+                        debug!(\"    new_region : {:?}\", new_region);\n+                        if error_regions.insert(constraint.sup) {\n+                            errors.push((constraint.sup, constraint.span, new_region));\n+                        }\n+                    }\n+                }\n             }\n             debug!(\"\\n\");\n         }\n-\n-        mem::replace(&mut self.errors, Vec::new())\n+        errors\n     }\n }\n \n-struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n-    #[allow(dead_code)] infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+struct Dfs<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n-        Self { infcx, mir }\n+impl<'a, 'tcx> Dfs<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>) -> Self {\n+        Self { mir }\n     }\n \n     fn copy(\n@@ -180,7 +347,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n         while let Some(p) = stack.pop() {\n             debug!(\"        dfs: p={:?}\", p);\n \n-            if !from_region.may_contain(p) {\n+            if !from_region.contains_point(p) {\n                 debug!(\"            not in from-region\");\n                 continue;\n             }\n@@ -215,19 +382,14 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n             };\n \n             if successor_points.is_empty() {\n-                // FIXME handle free regions\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n-                // for region_decl in self.infcx.tcx.tables.borrow().free_region_map() {\n-                //     // FIXME(nashenas88) figure out skolemized_end points\n-                //     let block = self.env.graph.skolemized_end(region_decl.name);\n-                //     let skolemized_end_point = Location {\n-                //         block,\n-                //         statement_index: 0,\n-                //     };\n-                //     changed |= to_region.add_point(skolemized_end_point);\n-                // }\n+\n+                debug!(\"        dfs: free_regions={:?}\", from_region.free_regions);\n+                for &fr in &from_region.free_regions {\n+                    changed |= to_region.free_regions.insert(fr);\n+                }\n             } else {\n                 stack.extend(successor_points);\n             }"}, {"sha": "a3ff7a041ca0714bd2d963274d377cd4ab03f18b", "filename": "src/librustc_mir/transform/nll/renumber.rs", "status": "modified", "additions": 94, "deletions": 44, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -8,81 +8,131 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::TypeFoldable;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{Ty, ClosureSubsts, RegionVid, RegionKind};\n-use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Lookup};\n+use rustc::ty::{self, ClosureSubsts, RegionKind, RegionVid, Ty, TypeFoldable};\n+use rustc::mir::{BasicBlock, Local, Location, Mir, Rvalue, Statement, StatementKind};\n+use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{self as rustc_infer, InferCtxt};\n use syntax_pos::DUMMY_SP;\n use std::collections::HashMap;\n \n+use super::free_regions::FreeRegions;\n+\n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                    mir: &mut Mir<'tcx>)\n-                                    -> usize\n-{\n-    let mut visitor = NLLVisitor::new(infcx);\n+pub fn renumber_mir<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    free_regions: &FreeRegions<'tcx>,\n+    mir: &mut Mir<'tcx>,\n+) -> usize {\n+    // Create inference variables for each of the free regions\n+    // declared on the function signature.\n+    let free_region_inference_vars = (0..free_regions.indices.len())\n+        .map(|_| {\n+            infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+        })\n+        .collect();\n+\n+    let mut visitor = NLLVisitor {\n+        infcx,\n+        lookup_map: HashMap::new(),\n+        num_region_variables: free_regions.indices.len(),\n+        free_regions,\n+        free_region_inference_vars,\n+        arg_count: mir.arg_count,\n+    };\n     visitor.visit_mir(mir);\n     visitor.num_region_variables\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    lookup_map: HashMap<RegionVid, Lookup>,\n+    lookup_map: HashMap<RegionVid, TyContext>,\n     num_region_variables: usize,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    free_regions: &'a FreeRegions<'tcx>,\n+    free_region_inference_vars: Vec<ty::Region<'tcx>>,\n+    arg_count: usize,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        NLLVisitor {\n-            infcx,\n-            lookup_map: HashMap::new(),\n-            num_region_variables: 0\n-        }\n+    /// Replaces all regions appearing in `value` with fresh inference\n+    /// variables. This is what we do for almost the entire MIR, with\n+    /// the exception of the declared types of our arguments.\n+    fn renumber_regions<T>(&mut self, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx\n+            .tcx\n+            .fold_regions(value, &mut false, |_region, _depth| {\n+                self.num_region_variables += 1;\n+                self.infcx\n+                    .next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+            })\n     }\n \n-    fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n-        self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n-            self.num_region_variables += 1;\n-            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n-        })\n+    /// Renumbers the regions appearing in `value`, but those regions\n+    /// are expected to be free regions from the function signature.\n+    fn renumber_free_regions<T>(&mut self, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx\n+            .tcx\n+            .fold_regions(value, &mut false, |region, _depth| {\n+                let index = self.free_regions.indices[&region];\n+                self.free_region_inference_vars[index]\n+            })\n     }\n \n-    fn store_region(&mut self, region: &RegionKind, lookup: Lookup) {\n+    fn store_region(&mut self, region: &RegionKind, lookup: TyContext) {\n         if let RegionKind::ReVar(rid) = *region {\n             self.lookup_map.entry(rid).or_insert(lookup);\n         }\n     }\n \n-    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, lookup: Lookup) {\n+    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, ty_context: TyContext) {\n         for region in ty.regions() {\n-            self.store_region(region, lookup);\n+            self.store_region(region, ty_context);\n         }\n     }\n \n-    fn store_kind_regions(&mut self, kind: &'tcx Kind, lookup: Lookup) {\n+    fn store_kind_regions(&mut self, kind: &'tcx Kind, ty_context: TyContext) {\n         if let Some(ty) = kind.as_type() {\n-            self.store_ty_regions(&ty, lookup);\n+            self.store_ty_regions(&ty, ty_context);\n         } else if let Some(region) = kind.as_region() {\n-            self.store_region(region, lookup);\n+            self.store_region(region, ty_context);\n         }\n     }\n+\n+    fn is_argument_or_return_slot(&self, local: Local) -> bool {\n+        // The first argument is return slot, next N are arguments.\n+        local.index() <= self.arg_count\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, lookup: Lookup) {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n+        let is_arg = match ty_context {\n+            TyContext::LocalDecl { local, .. } => self.is_argument_or_return_slot(local),\n+            _ => false,\n+        };\n+\n         let old_ty = *ty;\n-        *ty = self.renumber_regions(&old_ty);\n-        self.store_ty_regions(ty, lookup);\n+        *ty = if is_arg {\n+            self.renumber_free_regions(&old_ty)\n+        } else {\n+            self.renumber_regions(&old_ty)\n+        };\n+        self.store_ty_regions(ty, ty_context);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(&{*substs});\n-        let lookup = Lookup::Loc(location);\n+        *substs = self.renumber_regions(&{ *substs });\n+        let ty_context = TyContext::Location(location);\n         for kind in *substs {\n-            self.store_kind_regions(kind, lookup);\n+            self.store_kind_regions(kind, ty_context);\n         }\n     }\n \n@@ -91,8 +141,8 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n             Rvalue::Ref(ref mut r, _, _) => {\n                 let old_r = *r;\n                 *r = self.renumber_regions(&old_r);\n-                let lookup = Lookup::Loc(location);\n-                self.store_region(r, lookup);\n+                let ty_context = TyContext::Location(location);\n+                self.store_region(r, ty_context);\n             }\n             Rvalue::Use(..) |\n             Rvalue::Repeat(..) |\n@@ -110,20 +160,20 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n-                            location: Location) {\n+    fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n         *substs = self.renumber_regions(substs);\n-        let lookup = Lookup::Loc(location);\n+        let ty_context = TyContext::Location(location);\n         for kind in substs.substs {\n-            self.store_kind_regions(kind, lookup);\n+            self.store_kind_regions(kind, ty_context);\n         }\n     }\n \n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &mut Statement<'tcx>,\n+        location: Location,\n+    ) {\n         if let StatementKind::EndRegion(_) = statement.kind {\n             statement.kind = StatementKind::Nop;\n         }"}, {"sha": "b07e818ee87525045e6d237d575d74cb66117cef", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -92,8 +92,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n-    fn visit_local_decl(&mut self, local_decl: &LocalDecl<'tcx>) {\n-        self.super_local_decl(local_decl);\n+    fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n+        self.super_local_decl(local, local_decl);\n         self.sanitize_type(local_decl, local_decl.ty);\n     }\n "}, {"sha": "ab41ad1e0995056c46635618869377fffad65af6", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -14,7 +14,7 @@\n \n use rustc_const_math::{ConstUsize};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n-use rustc::mir::{Constant, Literal, Location, LocalDecl};\n+use rustc::mir::{Constant, Literal, Location, Local, LocalDecl};\n use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n@@ -270,9 +270,10 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n     }\n \n     fn visit_local_decl(&mut self,\n+                        local: Local,\n                         local_decl: &LocalDecl<'tcx>) {\n         self.record(\"LocalDecl\", local_decl);\n-        self.super_local_decl(local_decl);\n+        self.super_local_decl(local, local_decl);\n     }\n \n     fn visit_visibility_scope(&mut self,"}, {"sha": "c4f3a6fea5353110a40dea4b46a1428917e9228b", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for named lifetime translation. Check that we\n+// instantiate the types that appear in function arguments with\n+// suitable variables and that we setup the outlives relationship\n+// between R0 and R1 properly.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+// ignore-tidy-linelength\n+\n+#![allow(warnings)]\n+\n+fn use_x<'a, 'b: 'a, 'c>(w: &'a mut i32, x: &'b u32, y: &'a u32, z: &'c u32) -> bool { true }\n+\n+fn main() {\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.nll.0.mir\n+// | '_#0r: {bb0[0], bb0[1], '_#0r}\n+// | '_#1r: {bb0[0], bb0[1], '_#0r, '_#1r}\n+// | '_#2r: {bb0[0], bb0[1], '_#2r}\n+// ...\n+// fn use_x(_1: &'_#0r mut i32, _2: &'_#1r u32, _3: &'_#0r u32, _4: &'_#2r u32) -> bool {\n+// END rustc.node4.nll.0.mir"}, {"sha": "539c2017ea6c03ce91acb1c3fae9108064512fdb", "filename": "src/test/ui/nll/named-region-basic.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.rs?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test ought to\n+// report an error due to a reborrowing constraint. Right now, we get\n+// a variety of errors from the older, AST-based machinery (notably\n+// borrowck), and then we get the NLL error at the end.\n+\n+// compile-flags:-Znll\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n+    &*x\n+}\n+\n+fn main() { }"}, {"sha": "42b2aea01f0df3b5ea68985a74eb9d617648164d", "filename": "src/test/ui/nll/named-region-basic.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/785643a5eb6727d788b218e10ce60219b1c3c27f/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr?ref=785643a5eb6727d788b218e10ce60219b1c3c27f", "patch": "@@ -0,0 +1,29 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/named-region-basic.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error[E0597]: `*x` does not live long enough\n+  --> $DIR/named-region-basic.rs:19:6\n+   |\n+19 |     &*x\n+   |      ^^ does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+note: ...but borrowed value is only valid for the lifetime 'a as defined on the function body at 18:1\n+  --> $DIR/named-region-basic.rs:18:1\n+   |\n+18 | / fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n+19 | |     &*x\n+20 | | }\n+   | |_^\n+\n+error: free region `'a` does not outlive `'b`\n+  --> $DIR/named-region-basic.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}