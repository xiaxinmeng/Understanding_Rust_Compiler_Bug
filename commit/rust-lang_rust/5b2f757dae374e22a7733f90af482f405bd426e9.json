{"sha": "5b2f757dae374e22a7733f90af482f405bd426e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMmY3NTdkYWUzNzRlMjJhNzczM2Y5MGFmNDgyZjQwNWJkNDI2ZTk=", "commit": {"author": {"name": "Andreas Liljeqvist", "email": "bonega@gmail.com", "date": "2021-08-29T09:06:55Z"}, "committer": {"name": "Andreas Liljeqvist", "email": "bonega@gmail.com", "date": "2021-09-09T08:41:19Z"}, "message": "Make `abi::Abi` `Copy` and remove a *lot* of refs\n\nfix\n\nfix\n\nRemove more refs and clones\n\nfix\n\nmore\n\nfix", "tree": {"sha": "34306d74efe24f835d407d34e4f55c175cdb7257", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34306d74efe24f835d407d34e4f55c175cdb7257"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b2f757dae374e22a7733f90af482f405bd426e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2f757dae374e22a7733f90af482f405bd426e9", "html_url": "https://github.com/rust-lang/rust/commit/5b2f757dae374e22a7733f90af482f405bd426e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b2f757dae374e22a7733f90af482f405bd426e9/comments", "author": {"login": "bonega", "id": 411677, "node_id": "MDQ6VXNlcjQxMTY3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonega", "html_url": "https://github.com/bonega", "followers_url": "https://api.github.com/users/bonega/followers", "following_url": "https://api.github.com/users/bonega/following{/other_user}", "gists_url": "https://api.github.com/users/bonega/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonega/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonega/subscriptions", "organizations_url": "https://api.github.com/users/bonega/orgs", "repos_url": "https://api.github.com/users/bonega/repos", "events_url": "https://api.github.com/users/bonega/events{/privacy}", "received_events_url": "https://api.github.com/users/bonega/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bonega", "id": 411677, "node_id": "MDQ6VXNlcjQxMTY3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonega", "html_url": "https://github.com/bonega", "followers_url": "https://api.github.com/users/bonega/followers", "following_url": "https://api.github.com/users/bonega/following{/other_user}", "gists_url": "https://api.github.com/users/bonega/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonega/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonega/subscriptions", "organizations_url": "https://api.github.com/users/bonega/orgs", "repos_url": "https://api.github.com/users/bonega/repos", "events_url": "https://api.github.com/users/bonega/events{/privacy}", "received_events_url": "https://api.github.com/users/bonega/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ff6aeb82fd68ec2a0ea2cd74120bf0852bcff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ff6aeb82fd68ec2a0ea2cd74120bf0852bcff4", "html_url": "https://github.com/rust-lang/rust/commit/86ff6aeb82fd68ec2a0ea2cd74120bf0852bcff4"}], "stats": {"total": 302, "additions": 139, "deletions": 163}, "files": [{"sha": "2144e7ed67acbc75a7e4ca0c3781e27148f5294c", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -92,9 +92,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]> {\n         match self.mode {\n             PassMode::Ignore => smallvec![],\n-            PassMode::Direct(attrs) => match &self.layout.abi {\n+            PassMode::Direct(attrs) => match self.layout.abi {\n                 Abi::Scalar(scalar) => smallvec![apply_arg_attrs_to_abi_param(\n-                    AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                    AbiParam::new(scalar_to_clif_type(tcx, scalar)),\n                     attrs\n                 )],\n                 Abi::Vector { .. } => {\n@@ -103,10 +103,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Pair(attrs_a, attrs_b) => match &self.layout.abi {\n+            PassMode::Pair(attrs_a, attrs_b) => match self.layout.abi {\n                 Abi::ScalarPair(a, b) => {\n-                    let a = scalar_to_clif_type(tcx, a.clone());\n-                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    let a = scalar_to_clif_type(tcx, a);\n+                    let b = scalar_to_clif_type(tcx, b);\n                     smallvec![\n                         apply_arg_attrs_to_abi_param(AbiParam::new(a), attrs_a),\n                         apply_arg_attrs_to_abi_param(AbiParam::new(b), attrs_b),\n@@ -139,20 +139,20 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>) {\n         match self.mode {\n             PassMode::Ignore => (None, vec![]),\n-            PassMode::Direct(_) => match &self.layout.abi {\n+            PassMode::Direct(_) => match self.layout.abi {\n                 Abi::Scalar(scalar) => {\n-                    (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))])\n+                    (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar))])\n                 }\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     (None, vec![AbiParam::new(vector_ty)])\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Pair(_, _) => match &self.layout.abi {\n+            PassMode::Pair(_, _) => match self.layout.abi {\n                 Abi::ScalarPair(a, b) => {\n-                    let a = scalar_to_clif_type(tcx, a.clone());\n-                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    let a = scalar_to_clif_type(tcx, a);\n+                    let b = scalar_to_clif_type(tcx, b);\n                     (None, vec![AbiParam::new(a), AbiParam::new(b)])\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),"}, {"sha": "8b62b44df8ab30a0be927472792cee36ced3a8a6", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -143,8 +143,8 @@ macro validate_simd_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n }\n \n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n-    let (element, count) = match &layout.abi {\n-        Abi::Vector { element, count } => (element.clone(), *count),\n+    let (element, count) = match layout.abi {\n+        Abi::Vector { element, count } => (element, count),\n         _ => unreachable!(),\n     };\n "}, {"sha": "30d5340935f14d90ea4773316340420a2fa11334", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -49,11 +49,7 @@ fn codegen_field<'tcx>(\n     }\n }\n \n-fn scalar_pair_calculate_b_offset(\n-    tcx: TyCtxt<'_>,\n-    a_scalar: &Scalar,\n-    b_scalar: &Scalar,\n-) -> Offset32 {\n+fn scalar_pair_calculate_b_offset(tcx: TyCtxt<'_>, a_scalar: Scalar, b_scalar: Scalar) -> Offset32 {\n     let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n     Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n@@ -124,12 +120,10 @@ impl<'tcx> CValue<'tcx> {\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n                 let clif_ty = match layout.abi {\n-                    Abi::Scalar(ref scalar) => scalar_to_clif_type(fx.tcx, scalar.clone()),\n-                    Abi::Vector { ref element, count } => {\n-                        scalar_to_clif_type(fx.tcx, element.clone())\n-                            .by(u16::try_from(count).unwrap())\n-                            .unwrap()\n-                    }\n+                    Abi::Scalar(scalar) => scalar_to_clif_type(fx.tcx, scalar),\n+                    Abi::Vector { element, count } => scalar_to_clif_type(fx.tcx, element)\n+                        .by(u16::try_from(count).unwrap())\n+                        .unwrap(),\n                     _ => unreachable!(\"{:?}\", layout.ty),\n                 };\n                 let mut flags = MemFlags::new();\n@@ -147,13 +141,13 @@ impl<'tcx> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n-                let (a_scalar, b_scalar) = match &layout.abi {\n+                let (a_scalar, b_scalar) = match layout.abi {\n                     Abi::ScalarPair(a, b) => (a, b),\n                     _ => unreachable!(\"load_scalar_pair({:?})\", self),\n                 };\n                 let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n-                let clif_ty1 = scalar_to_clif_type(fx.tcx, a_scalar.clone());\n-                let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar.clone());\n+                let clif_ty1 = scalar_to_clif_type(fx.tcx, a_scalar);\n+                let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar);\n                 let mut flags = MemFlags::new();\n                 flags.set_notrap();\n                 let val1 = ptr.load(fx, clif_ty1, flags);\n@@ -564,7 +558,7 @@ impl<'tcx> CPlace<'tcx> {\n                 to_ptr.store(fx, val, flags);\n                 return;\n             }\n-            Abi::ScalarPair(ref a_scalar, ref b_scalar) => {\n+            Abi::ScalarPair(a_scalar, b_scalar) => {\n                 let (value, extra) = from.load_scalar_pair(fx);\n                 let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n                 to_ptr.store(fx, value, flags);"}, {"sha": "785f9b09ff3d3e469d2ed2f5ec9cb499465fd2a5", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -536,13 +536,13 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             }\n             _ => {}\n         }\n-        if let abi::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n+        if let abi::Abi::Scalar(scalar) = self.ret.layout.abi {\n             // If the value is a boolean, the range is 0..2 and that ultimately\n             // become 0..0 when the type becomes i1, which would be rejected\n             // by the LLVM verifier.\n             if let Int(..) = scalar.value {\n                 if !scalar.is_bool() && !scalar.is_always_valid_for(bx) {\n-                    bx.range_metadata(callsite, &scalar.valid_range);\n+                    bx.range_metadata(callsite, scalar.valid_range);\n                 }\n             }\n         }"}, {"sha": "9690ad8b24603a17490099c9218d7d414f49dee3", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -792,7 +792,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n \n /// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n /// the equivalent integer type.\n-fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: &Scalar) -> &'ll Type {\n+fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: Scalar) -> &'ll Type {\n     match scalar.value {\n         Primitive::Int(Integer::I8, _) => cx.type_i8(),\n         Primitive::Int(Integer::I16, _) => cx.type_i16(),\n@@ -812,7 +812,7 @@ fn llvm_fixup_input(\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n ) -> &'ll Value {\n-    match (reg, &layout.abi) {\n+    match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n             if let Primitive::Int(Integer::I8, _) = s.value {\n                 let vec_ty = bx.cx.type_vector(bx.cx.type_i8(), 8);\n@@ -835,7 +835,7 @@ fn llvm_fixup_input(\n             Abi::Vector { element, count },\n         ) if layout.size.bytes() == 8 => {\n             let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n-            let vec_ty = bx.cx.type_vector(elem_ty, *count);\n+            let vec_ty = bx.cx.type_vector(elem_ty, count);\n             let indices: Vec<_> = (0..count * 2).map(|x| bx.const_i32(x as i32)).collect();\n             bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n         }\n@@ -890,7 +890,7 @@ fn llvm_fixup_output(\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n ) -> &'ll Value {\n-    match (reg, &layout.abi) {\n+    match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n             if let Primitive::Int(Integer::I8, _) = s.value {\n                 bx.extract_element(value, bx.const_i32(0))\n@@ -910,8 +910,8 @@ fn llvm_fixup_output(\n             Abi::Vector { element, count },\n         ) if layout.size.bytes() == 8 => {\n             let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n-            let vec_ty = bx.cx.type_vector(elem_ty, *count * 2);\n-            let indices: Vec<_> = (0..*count).map(|x| bx.const_i32(x as i32)).collect();\n+            let vec_ty = bx.cx.type_vector(elem_ty, count * 2);\n+            let indices: Vec<_> = (0..count).map(|x| bx.const_i32(x as i32)).collect();\n             bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n         }\n         (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n@@ -965,7 +965,7 @@ fn llvm_fixup_output_type(\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n ) -> &'ll Type {\n-    match (reg, &layout.abi) {\n+    match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n             if let Primitive::Int(Integer::I8, _) = s.value {\n                 cx.type_vector(cx.type_i8(), 8)"}, {"sha": "8fddefa163b4c736902dccad92cd1b55a8b062db", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -382,7 +382,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             val\n         }\n     }\n-    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &abi::Scalar) -> Self::Value {\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: abi::Scalar) -> Self::Value {\n         if scalar.is_bool() {\n             return self.trunc(val, self.cx().type_i1());\n         }\n@@ -460,12 +460,12 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         fn scalar_load_metadata<'a, 'll, 'tcx>(\n             bx: &mut Builder<'a, 'll, 'tcx>,\n             load: &'ll Value,\n-            scalar: &abi::Scalar,\n+            scalar: abi::Scalar,\n         ) {\n             match scalar.value {\n                 abi::Int(..) => {\n                     if !scalar.is_always_valid_for(bx) {\n-                        bx.range_metadata(load, &scalar.valid_range);\n+                        bx.range_metadata(load, scalar.valid_range);\n                     }\n                 }\n                 abi::Pointer if !scalar.valid_range.contains(0) => {\n@@ -488,17 +488,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             let llval = const_llval.unwrap_or_else(|| {\n                 let load = self.load(place.layout.llvm_type(self), place.llval, place.align);\n-                if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n+                if let abi::Abi::Scalar(scalar) = place.layout.abi {\n                     scalar_load_metadata(self, load, scalar);\n                 }\n                 load\n             });\n             OperandValue::Immediate(self.to_immediate(llval, place.layout))\n-        } else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n+        } else if let abi::Abi::ScalarPair(a, b) = place.layout.abi {\n             let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n             let pair_ty = place.layout.llvm_type(self);\n \n-            let mut load = |i, scalar: &abi::Scalar, align| {\n+            let mut load = |i, scalar: abi::Scalar, align| {\n                 let llptr = self.struct_gep(pair_ty, place.llval, i as u64);\n                 let llty = place.layout.scalar_pair_element_llvm_type(self, i, false);\n                 let load = self.load(llty, llptr, align);\n@@ -554,7 +554,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         next_bx\n     }\n \n-    fn range_metadata(&mut self, load: &'ll Value, range: &WrappingRange) {\n+    fn range_metadata(&mut self, load: &'ll Value, range: WrappingRange) {\n         if self.sess().target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks an i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,"}, {"sha": "73a8d4644316346c3347da6ed857777521f089c1", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -228,7 +228,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         })\n     }\n \n-    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: &'ll Type) -> &'ll Value {\n+    fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: &'ll Type) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n             Scalar::Int(ScalarInt::ZST) => {"}, {"sha": "ef3a90fdecaaa7874479e8659119ba69416e7050", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -111,7 +111,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            &Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n+            Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n             cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "f913c3e4b703d4bcc00306d595de20c372c1c188", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -1656,7 +1656,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n             Variants::Multiple {\n                 tag_encoding:\n                     TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n-                ref tag,\n+                tag,\n                 ref variants,\n                 tag_field,\n             } => {\n@@ -2082,19 +2082,17 @@ fn prepare_enum_metadata(\n \n     let layout = cx.layout_of(enum_type);\n \n-    if let (\n-        &Abi::Scalar(_),\n-        &Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. },\n-    ) = (&layout.abi, &layout.variants)\n+    if let (Abi::Scalar(_), Variants::Multiple { tag_encoding: TagEncoding::Direct, tag, .. }) =\n+        (layout.abi, &layout.variants)\n     {\n         return FinalMetadata(discriminant_type_metadata(tag.value));\n     }\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             Variants::Single { .. } => None,\n-            Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, ref tag, .. }\n-            | Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+            Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, .. }\n+            | Variants::Multiple { tag_encoding: TagEncoding::Direct, tag, .. } => {\n                 Some(discriminant_type_metadata(tag.value))\n             }\n         };\n@@ -2146,9 +2144,7 @@ fn prepare_enum_metadata(\n         // A single-variant enum has no discriminant.\n         Variants::Single { .. } => None,\n \n-        Variants::Multiple {\n-            tag_encoding: TagEncoding::Niche { .. }, ref tag, tag_field, ..\n-        } => {\n+        Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, tag_field, .. } => {\n             // Find the integer type of the correct size.\n             let size = tag.value.size(cx);\n             let align = tag.value.align(cx);\n@@ -2179,7 +2175,7 @@ fn prepare_enum_metadata(\n             }\n         }\n \n-        Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, tag_field, .. } => {\n+        Variants::Multiple { tag_encoding: TagEncoding::Direct, tag, tag_field, .. } => {\n             let discr_type = tag.value.to_ty(cx.tcx);\n             let (size, align) = cx.size_and_align_of(discr_type);\n "}, {"sha": "1060f911a9ed48739a9e4de5cff53559e0944b13", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -133,7 +133,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n             sym::va_arg => {\n                 match fn_abi.ret.layout.abi {\n-                    abi::Abi::Scalar(ref scalar) => {\n+                    abi::Abi::Scalar(scalar) => {\n                         match scalar.value {\n                             Primitive::Int(..) => {\n                                 if self.cx().size_of(ret_ty).bytes() < 4 {"}, {"sha": "3e39bf3e995a25cea16d1ae100d020729c64783b", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -23,7 +23,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n ) -> &'a Type {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n-        Abi::Vector { ref element, count } => {\n+        Abi::Vector { element, count } => {\n             let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n             return cx.type_vector(element, count);\n         }\n@@ -177,7 +177,7 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn scalar_llvm_type_at<'a>(\n         &self,\n         cx: &CodegenCx<'a, 'tcx>,\n-        scalar: &Scalar,\n+        scalar: Scalar,\n         offset: Size,\n     ) -> &'a Type;\n     fn scalar_pair_element_llvm_type<'a>(\n@@ -218,7 +218,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n     fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n-        if let Abi::Scalar(ref scalar) = self.abi {\n+        if let Abi::Scalar(scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n             if let Some(&llty) = cx.scalar_lltypes.borrow().get(&self.ty) {\n@@ -286,7 +286,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     }\n \n     fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n-        if let Abi::Scalar(ref scalar) = self.abi {\n+        if let Abi::Scalar(scalar) = self.abi {\n             if scalar.is_bool() {\n                 return cx.type_i1();\n             }\n@@ -297,7 +297,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     fn scalar_llvm_type_at<'a>(\n         &self,\n         cx: &CodegenCx<'a, 'tcx>,\n-        scalar: &Scalar,\n+        scalar: Scalar,\n         offset: Size,\n     ) -> &'a Type {\n         match scalar.value {\n@@ -337,7 +337,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         }\n \n         let (a, b) = match self.abi {\n-            Abi::ScalarPair(ref a, ref b) => (a, b),\n+            Abi::ScalarPair(a, b) => (a, b),\n             _ => bug!(\"TyAndLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n         };\n         let scalar = [a, b][index];"}, {"sha": "e842f5e9391c806b0ba62d6b98b3ab4d4cd2c299", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -404,7 +404,7 @@ fn push_debuginfo_type_name<'tcx>(\n \n             // calculate the range of values for the dataful variant\n             let dataful_discriminant_range =\n-                &dataful_variant_layout.largest_niche.as_ref().unwrap().scalar.valid_range;\n+                dataful_variant_layout.largest_niche.unwrap().scalar.valid_range;\n \n             let min = dataful_discriminant_range.start;\n             let min = tag.value.size(&tcx).truncate(min);"}, {"sha": "cd0e9354c2441b419e49dd6a728b226e81234a02", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -1102,9 +1102,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n                 llval = bx.load(bx.backend_type(arg.layout), llval, align);\n-                if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let abi::Abi::Scalar(scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n-                        bx.range_metadata(llval, &WrappingRange { start: 0, end: 1 });\n+                        bx.range_metadata(llval, WrappingRange { start: 0, end: 1 });\n                     }\n                 }\n                 // We store bools as `i8` so we need to truncate to `i1`.\n@@ -1424,7 +1424,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let src = self.codegen_operand(bx, src);\n \n         // Special-case transmutes between scalars as simple bitcasts.\n-        match (&src.layout.abi, &dst.layout.abi) {\n+        match (src.layout.abi, dst.layout.abi) {\n             (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n                 // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n                 if (src_scalar.value == abi::Pointer) == (dst_scalar.value == abi::Pointer) {"}, {"sha": "93b39dc8e9ee102c8015ca4b21ebfd9f5c5d5fd1", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         if let Some(prim) = field.val.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let scalar = match layout.abi {\n-                                Abi::Scalar(ref x) => x,\n+                                Abi::Scalar(x) => x,\n                                 _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n                             };\n                             bx.scalar_to_backend(prim, scalar, bx.immediate_backend_type(layout))"}, {"sha": "ce6cec67ad41ef7b17f7f73bf31925d3671c6c2b", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -79,15 +79,15 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         let val = match val {\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n-                    Abi::Scalar(ref x) => x,\n+                    Abi::Scalar(x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n                 };\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n             ConstValue::Slice { data, start, end } => {\n                 let a_scalar = match layout.abi {\n-                    Abi::ScalarPair(ref a, _) => a,\n+                    Abi::ScalarPair(a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n                 let a = Scalar::from_pointer(\n@@ -162,7 +162,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         llval: V,\n         layout: TyAndLayout<'tcx>,\n     ) -> Self {\n-        let val = if let Abi::ScalarPair(ref a, ref b) = layout.abi {\n+        let val = if let Abi::ScalarPair(a, b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\", llval, layout);\n \n             // Deconstruct the immediate aggregate.\n@@ -185,7 +185,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         let field = self.layout.field(bx.cx(), i);\n         let offset = self.layout.fields.offset(i);\n \n-        let mut val = match (self.val, &self.layout.abi) {\n+        let mut val = match (self.val, self.layout.abi) {\n             // If the field is ZST, it has no data.\n             _ if field.is_zst() => {\n                 return OperandRef::new_zst(bx, field);\n@@ -200,7 +200,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             }\n \n             // Extract a scalar component from a pair.\n-            (OperandValue::Pair(a_llval, b_llval), &Abi::ScalarPair(ref a, ref b)) => {\n+            (OperandValue::Pair(a_llval, b_llval), Abi::ScalarPair(a, b)) => {\n                 if offset.bytes() == 0 {\n                     assert_eq!(field.size, a.value.size(bx.cx()));\n                     OperandValue::Immediate(a_llval)\n@@ -212,14 +212,14 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n-            (OperandValue::Immediate(llval), &Abi::Vector { .. }) => {\n+            (OperandValue::Immediate(llval), Abi::Vector { .. }) => {\n                 OperandValue::Immediate(bx.extract_element(llval, bx.cx().const_usize(i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self),\n         };\n \n-        match (&mut val, &field.abi) {\n+        match (&mut val, field.abi) {\n             (OperandValue::Immediate(llval), _) => {\n                 // Bools in union fields needs to be truncated.\n                 *llval = bx.to_immediate(*llval, field);\n@@ -308,7 +308,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n             }\n             OperandValue::Pair(a, b) => {\n                 let (a_scalar, b_scalar) = match dest.layout.abi {\n-                    Abi::ScalarPair(ref a, ref b) => (a, b),\n+                    Abi::ScalarPair(a, b) => (a, b),\n                     _ => bug!(\"store_with_flags: invalid ScalarPair layout: {:#?}\", dest.layout),\n                 };\n                 let ty = bx.backend_type(dest.layout);"}, {"sha": "4b07ed1a1e6c2b2bf884db3b94d42b206c58b9d4", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     // Also handles the first field of Scalar, ScalarPair, and Vector layouts.\n                     self.llval\n                 }\n-                Abi::ScalarPair(ref a, ref b)\n+                Abi::ScalarPair(a, b)\n                     if offset == a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi) =>\n                 {\n                     // Offset matches second field.\n@@ -222,7 +222,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n                 (tag, tag_encoding, tag_field)\n             }\n         };"}, {"sha": "e7da96f0adafdaf53b510f3084c7f4ad684b59c3", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -124,13 +124,13 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn from_immediate(&mut self, val: Self::Value) -> Self::Value;\n     fn to_immediate(&mut self, val: Self::Value, layout: TyAndLayout<'_>) -> Self::Value {\n-        if let Abi::Scalar(ref scalar) = layout.abi {\n+        if let Abi::Scalar(scalar) = layout.abi {\n             self.to_immediate_scalar(val, scalar)\n         } else {\n             val\n         }\n     }\n-    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &Scalar) -> Self::Value;\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: Scalar) -> Self::Value;\n \n     fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n@@ -156,7 +156,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n         dest: PlaceRef<'tcx, Self::Value>,\n     ) -> Self;\n \n-    fn range_metadata(&mut self, load: Self::Value, range: &WrappingRange);\n+    fn range_metadata(&mut self, load: Self::Value, range: WrappingRange);\n     fn nonnull_metadata(&mut self, load: Self::Value);\n \n     fn store(&mut self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value;"}, {"sha": "5260b7cc33120e0e36c05d3d79eb0ad537b7d317", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -28,7 +28,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n \n     fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value;\n \n-    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: Self::Type) -> Self::Value;\n+    fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: Self::Type) -> Self::Value;\n     fn from_const_alloc(\n         &self,\n         layout: TyAndLayout<'tcx>,"}, {"sha": "bcc4d11e64bf1ecd84a5c7f05b1a1826379b9205", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -194,7 +194,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val = self.read_scalar(&args[0])?.check_init()?;\n                 let bits = val.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n-                    Abi::Scalar(ref scalar) => scalar.value,\n+                    Abi::Scalar(scalar) => scalar.value,\n                     _ => span_bug!(\n                         self.cur_span(),\n                         \"{} called on invalid type {:?}\","}, {"sha": "de870bd5c6cf1be3972ad5eede57b696572a7501", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -274,11 +274,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n                 Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }))\n             }\n-            Abi::ScalarPair(ref a, ref b) => {\n+            Abi::ScalarPair(a, b) => {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n                 // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let (a, b) = (&a.value, &b.value);\n+                let (a, b) = (a.value, b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n@@ -648,7 +648,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 return Ok((discr, index));\n             }\n-            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n                 (tag, tag_encoding, tag_field)\n             }\n         };"}, {"sha": "0da6d8169bd3a7b36c25f7d9aca0d7fbb1b3f871", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -752,7 +752,7 @@ where\n                 // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n-                    Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n+                    Abi::ScalarPair(a, b) => (a.value, b.value),\n                     _ => span_bug!(\n                         self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n@@ -1000,7 +1000,7 @@ where\n             }\n             Variants::Multiple {\n                 tag_encoding: TagEncoding::Direct,\n-                tag: ref tag_layout,\n+                tag: tag_layout,\n                 tag_field,\n                 ..\n             } => {\n@@ -1022,7 +1022,7 @@ where\n             Variants::Multiple {\n                 tag_encoding:\n                     TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n-                tag: ref tag_layout,\n+                tag: tag_layout,\n                 tag_field,\n                 ..\n             } => {"}, {"sha": "a06903aedf6499a167e499e27cf7502f42958e3a", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -187,17 +187,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return false;\n         }\n         // Compare layout\n-        match (&caller.abi, &callee.abi) {\n+        match (caller.abi, callee.abi) {\n             // Different valid ranges are okay (once we enforce validity,\n             // that will take care to make it UB to leave the range, just\n             // like for transmute).\n-            (abi::Abi::Scalar(ref caller), abi::Abi::Scalar(ref callee)) => {\n-                caller.value == callee.value\n+            (abi::Abi::Scalar(caller), abi::Abi::Scalar(callee)) => caller.value == callee.value,\n+            (abi::Abi::ScalarPair(caller1, caller2), abi::Abi::ScalarPair(callee1, callee2)) => {\n+                caller1.value == callee1.value && caller2.value == callee2.value\n             }\n-            (\n-                abi::Abi::ScalarPair(ref caller1, ref caller2),\n-                abi::Abi::ScalarPair(ref callee1, ref callee2),\n-            ) => caller1.value == callee1.value && caller2.value == callee2.value,\n             // Be conservative\n             _ => false,\n         }"}, {"sha": "393c3e43b5d3044ed68c32dc4bfe40c208dd744b", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -618,7 +618,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn visit_scalar(\n         &mut self,\n         op: &OpTy<'tcx, M::PointerTag>,\n-        scalar_layout: &ScalarAbi,\n+        scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         if scalar_layout.valid_range.is_full_for(op.layout.size) {\n             // Nothing to check\n@@ -784,7 +784,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     { \"a value of uninhabited type {:?}\", op.layout.ty }\n                 );\n             }\n-            Abi::Scalar(ref scalar_layout) => {\n+            Abi::Scalar(scalar_layout) => {\n                 self.visit_scalar(op, scalar_layout)?;\n             }\n             Abi::ScalarPair { .. } | Abi::Vector { .. } => {"}, {"sha": "0143978cfba5f0eaa629bbe0f29b92cfbec4fa80", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -1327,10 +1327,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n             };\n             let (variants, tag) = match layout.variants {\n                 Variants::Multiple {\n-                    tag_encoding: TagEncoding::Direct,\n-                    ref tag,\n-                    ref variants,\n-                    ..\n+                    tag_encoding: TagEncoding::Direct, tag, ref variants, ..\n                 } => (variants, tag),\n                 _ => return,\n             };"}, {"sha": "67d33a0321f4d9ef2be2102ec8d15c6af48d395b", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -290,9 +290,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n         // returns the last maximum.\n-        let largest_niche = Niche::from_scalar(dl, b_offset, b.clone())\n+        let largest_niche = Niche::from_scalar(dl, b_offset, b)\n             .into_iter()\n-            .chain(Niche::from_scalar(dl, Size::ZERO, a.clone()))\n+            .chain(Niche::from_scalar(dl, Size::ZERO, a))\n             .max_by_key(|niche| niche.available(dl));\n \n         Layout {\n@@ -401,7 +401,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             offsets[i as usize] = offset;\n \n             if !repr.hide_niche() {\n-                if let Some(mut niche) = field.largest_niche.clone() {\n+                if let Some(mut niche) = field.largest_niche {\n                     let available = niche.available(dl);\n                     if available > largest_niche_available {\n                         largest_niche_available = available;\n@@ -449,12 +449,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             // For plain scalars, or vectors of them, we can't unpack\n                             // newtypes for `#[repr(C)]`, as that affects C ABIs.\n                             Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                abi = field.abi.clone();\n+                                abi = field.abi;\n                             }\n                             // But scalar pairs are Rust-specific and get\n                             // treated as aggregates by C ABIs anyway.\n                             Abi::ScalarPair(..) => {\n-                                abi = field.abi.clone();\n+                                abi = field.abi;\n                             }\n                             _ => {}\n                         }\n@@ -463,14 +463,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // Two non-ZST fields, and they're both scalars.\n                 (\n-                    Some((i, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref a), .. }, .. })),\n-                    Some((j, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref b), .. }, .. })),\n+                    Some((i, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(a), .. }, .. })),\n+                    Some((j, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(b), .. }, .. })),\n                     None,\n                 ) => {\n                     // Order by the memory placement, not source order.\n                     let ((i, a), (j, b)) =\n                         if offsets[i] < offsets[j] { ((i, a), (j, b)) } else { ((j, b), (i, a)) };\n-                    let pair = self.scalar_pair(a.clone(), b.clone());\n+                    let pair = self.scalar_pair(a, b);\n                     let pair_offsets = match pair.fields {\n                         FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                             assert_eq!(memory_index, &[0, 1]);\n@@ -609,7 +609,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         Abi::Aggregate { sized: true }\n                     };\n \n-                let largest_niche = if count != 0 { element.largest_niche.clone() } else { None };\n+                let largest_niche = if count != 0 { element.largest_niche } else { None };\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n@@ -768,8 +768,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // Compute the ABI of the element type:\n                 let e_ly = self.layout_of(e_ty)?;\n-                let e_abi = if let Abi::Scalar(ref scalar) = e_ly.abi {\n-                    scalar.clone()\n+                let e_abi = if let Abi::Scalar(scalar) = e_ly.abi {\n+                    scalar\n                 } else {\n                     // This error isn't caught in typeck, e.g., if\n                     // the element type of the vector is generic.\n@@ -796,7 +796,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields,\n                     abi: Abi::Vector { element: e_abi, count: e_len },\n-                    largest_niche: e_ly.largest_niche.clone(),\n+                    largest_niche: e_ly.largest_niche,\n                     size,\n                     align,\n                 })\n@@ -843,13 +843,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n                             // Normalize scalar_unit to the maximal valid range\n-                            let field_abi = match &field.abi {\n+                            let field_abi = match field.abi {\n                                 Abi::Scalar(x) => Abi::Scalar(scalar_unit(x.value)),\n                                 Abi::ScalarPair(x, y) => {\n                                     Abi::ScalarPair(scalar_unit(x.value), scalar_unit(y.value))\n                                 }\n                                 Abi::Vector { element: x, count } => {\n-                                    Abi::Vector { element: scalar_unit(x.value), count: *count }\n+                                    Abi::Vector { element: scalar_unit(x.value), count }\n                                 }\n                                 Abi::Uninhabited | Abi::Aggregate { .. } => {\n                                     Abi::Aggregate { sized: true }\n@@ -970,7 +970,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 Niche::from_scalar(dl, Size::ZERO, scalar.clone())\n                             };\n                             if let Some(niche) = niche {\n-                                match &st.largest_niche {\n+                                match st.largest_niche {\n                                     Some(largest_niche) => {\n                                         // Replace the existing niche even if they're equal,\n                                         // because this one is at a lower offset.\n@@ -1045,7 +1045,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         let niche_candidate = variants[i]\n                             .iter()\n                             .enumerate()\n-                            .filter_map(|(j, &field)| Some((j, field.largest_niche.as_ref()?)))\n+                            .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n                             .max_by_key(|(_, niche)| niche.available(dl));\n \n                         if let Some((field_index, niche, (niche_start, niche_scalar))) =\n@@ -1078,31 +1078,24 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 Abi::Uninhabited\n                             } else {\n                                 match st[i].abi {\n-                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n-                                    Abi::ScalarPair(ref first, ref second) => {\n+                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n+                                    Abi::ScalarPair(first, second) => {\n                                         // We need to use scalar_unit to reset the\n                                         // valid range to the maximal one for that\n                                         // primitive, because only the niche is\n                                         // guaranteed to be initialised, not the\n                                         // other primitive.\n                                         if offset.bytes() == 0 {\n-                                            Abi::ScalarPair(\n-                                                niche_scalar.clone(),\n-                                                scalar_unit(second.value),\n-                                            )\n+                                            Abi::ScalarPair(niche_scalar, scalar_unit(second.value))\n                                         } else {\n-                                            Abi::ScalarPair(\n-                                                scalar_unit(first.value),\n-                                                niche_scalar.clone(),\n-                                            )\n+                                            Abi::ScalarPair(scalar_unit(first.value), niche_scalar)\n                                         }\n                                     }\n                                     _ => Abi::Aggregate { sized: true },\n                                 }\n                             };\n \n-                            let largest_niche =\n-                                Niche::from_scalar(dl, offset, niche_scalar.clone());\n+                            let largest_niche = Niche::from_scalar(dl, offset, niche_scalar);\n \n                             niche_filling_layout = Some(Layout {\n                                 variants: Variants::Multiple {\n@@ -1283,7 +1276,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 };\n                 let mut abi = Abi::Aggregate { sized: true };\n                 if tag.value.size(dl) == size {\n-                    abi = Abi::Scalar(tag.clone());\n+                    abi = Abi::Scalar(tag);\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n@@ -1303,7 +1296,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             }\n                         };\n                         let prim = match field.abi {\n-                            Abi::Scalar(ref scalar) => scalar.value,\n+                            Abi::Scalar(scalar) => scalar.value,\n                             _ => {\n                                 common_prim = None;\n                                 break;\n@@ -1323,7 +1316,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         }\n                     }\n                     if let Some((prim, offset)) = common_prim {\n-                        let pair = self.scalar_pair(tag.clone(), scalar_unit(prim));\n+                        let pair = self.scalar_pair(tag, scalar_unit(prim));\n                         let pair_offsets = match pair.fields {\n                             FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);\n@@ -1347,7 +1340,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     abi = Abi::Uninhabited;\n                 }\n \n-                let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag.clone());\n+                let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n \n                 let tagged_layout = Layout {\n                     variants: Variants::Multiple {\n@@ -1372,8 +1365,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         // pick the layout with the larger niche; otherwise,\n                         // pick tagged as it has simpler codegen.\n                         cmp::min_by_key(tagged_layout, niche_filling_layout, |layout| {\n-                            let niche_size =\n-                                layout.largest_niche.as_ref().map_or(0, |n| n.available(dl));\n+                            let niche_size = layout.largest_niche.map_or(0, |n| n.available(dl));\n                             (layout.size, cmp::Reverse(niche_size))\n                         })\n                     }\n@@ -1560,7 +1552,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             value: Primitive::Int(discr_int, false),\n             valid_range: WrappingRange { start: 0, end: max_discr },\n         };\n-        let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag.clone()));\n+        let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag));\n         let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n         let promoted_layouts = ineligible_locals\n@@ -1832,7 +1824,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n             }\n \n-            Variants::Multiple { ref tag, ref tag_encoding, .. } => {\n+            Variants::Multiple { tag, ref tag_encoding, .. } => {\n                 debug!(\n                     \"print-type-size `{:#?}` adt general variants def {}\",\n                     layout.ty,\n@@ -2240,7 +2232,7 @@ where\n             i: usize,\n         ) -> TyMaybeWithLayout<'tcx> {\n             let tcx = cx.tcx();\n-            let tag_layout = |tag: &Scalar| -> TyAndLayout<'tcx> {\n+            let tag_layout = |tag: Scalar| -> TyAndLayout<'tcx> {\n                 let layout = Layout::scalar(cx, tag.clone());\n                 TyAndLayout { layout: tcx.intern_layout(layout), ty: tag.value.to_ty(tcx) }\n             };\n@@ -2329,7 +2321,7 @@ where\n                             .nth(i)\n                             .unwrap(),\n                     ),\n-                    Variants::Multiple { ref tag, tag_field, .. } => {\n+                    Variants::Multiple { tag, tag_field, .. } => {\n                         if i == tag_field {\n                             return TyMaybeWithLayout::TyAndLayout(tag_layout(tag));\n                         }\n@@ -2347,7 +2339,7 @@ where\n                         }\n \n                         // Discriminant field for enums (where applicable).\n-                        Variants::Multiple { ref tag, .. } => {\n+                        Variants::Multiple { tag, .. } => {\n                             assert_eq!(i, 0);\n                             return TyMaybeWithLayout::TyAndLayout(tag_layout(tag));\n                         }\n@@ -2906,7 +2898,7 @@ where\n \n         // Handle safe Rust thin and fat pointers.\n         let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n-                                      scalar: &Scalar,\n+                                      scalar: Scalar,\n                                       layout: TyAndLayout<'tcx>,\n                                       offset: Size,\n                                       is_return: bool| {"}, {"sha": "2e00ffc7e14730a916f95b3d3514ad74dc9dfe9d", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -3,7 +3,7 @@ use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n-    if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n+    if let abi::Abi::Scalar(scalar) = arg.layout.abi {\n         if let abi::Int(i, signed) = scalar.value {\n             if !signed && i.size().bits() == 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n@@ -23,7 +23,7 @@ where\n     C: HasDataLayout,\n {\n     match ret.layout.field(cx, i).abi {\n-        abi::Abi::Scalar(ref scalar) => match scalar.value {\n+        abi::Abi::Scalar(scalar) => match scalar.value {\n             abi::F32 => Some(Reg::f32()),\n             abi::F64 => Some(Reg::f64()),\n             _ => None,\n@@ -107,7 +107,7 @@ where\n                 let offset = arg.layout.fields.offset(i);\n \n                 // We only care about aligned doubles\n-                if let abi::Abi::Scalar(ref scalar) = field.abi {\n+                if let abi::Abi::Scalar(scalar) = field.abi {\n                     if let abi::F64 = scalar.value {\n                         if offset.is_aligned(dl.f64_align.abi) {\n                             // Insert enough integers to cover [last_offset, offset)"}, {"sha": "927bebd8157a629aac8499de65420baece8947c7", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -322,7 +322,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             Abi::Uninhabited => Err(Heterogeneous),\n \n             // The primitive for this algorithm.\n-            Abi::Scalar(ref scalar) => {\n+            Abi::Scalar(scalar) => {\n                 let kind = match scalar.value {\n                     abi::Int(..) | abi::Pointer => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n@@ -450,9 +450,9 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     pub fn new(\n         cx: &impl HasDataLayout,\n         layout: TyAndLayout<'a, Ty>,\n-        scalar_attrs: impl Fn(&TyAndLayout<'a, Ty>, &abi::Scalar, Size) -> ArgAttributes,\n+        scalar_attrs: impl Fn(&TyAndLayout<'a, Ty>, abi::Scalar, Size) -> ArgAttributes,\n     ) -> Self {\n-        let mode = match &layout.abi {\n+        let mode = match layout.abi {\n             Abi::Uninhabited => PassMode::Ignore,\n             Abi::Scalar(scalar) => PassMode::Direct(scalar_attrs(&layout, scalar, Size::ZERO)),\n             Abi::ScalarPair(a, b) => PassMode::Pair(\n@@ -504,7 +504,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n-        if let Abi::Scalar(ref scalar) = self.layout.abi {\n+        if let Abi::Scalar(scalar) = self.layout.abi {\n             if let abi::Int(i, signed) = scalar.value {\n                 if i.size().bits() < bits {\n                     if let PassMode::Direct(ref mut attrs) = self.mode {"}, {"sha": "bbefc73a076d7dd7ccb0b10efc8b7a6ac5a21e99", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -44,7 +44,7 @@ where\n     Ty: TyAbiInterface<'a, C> + Copy,\n {\n     match arg_layout.abi {\n-        Abi::Scalar(ref scalar) => match scalar.value {\n+        Abi::Scalar(scalar) => match scalar.value {\n             abi::Int(..) | abi::Pointer => {\n                 if arg_layout.size.bits() > xlen {\n                     return Err(CannotUseFpConv);\n@@ -297,7 +297,7 @@ fn classify_arg<'a, Ty, C>(\n }\n \n fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n-    if let Abi::Scalar(ref scalar) = arg.layout.abi {\n+    if let Abi::Scalar(scalar) = arg.layout.abi {\n         if let abi::Int(i, _) = scalar.value {\n             // 32-bit integers are always sign-extended\n             if i.size().bits() == 32 && xlen > 32 {"}, {"sha": "38aaee64a4d6b6978daa0a02c0933aed38542958", "filename": "compiler/rustc_target/src/abi/call/s390x.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -18,7 +18,7 @@ where\n     C: HasDataLayout,\n {\n     match layout.abi {\n-        abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n+        abi::Abi::Scalar(scalar) => scalar.value.is_float(),\n         abi::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(cx, layout.field(cx, 0))"}, {"sha": "28064d85bf1710ae6a218d43060951af9a763e5b", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -14,7 +14,7 @@ where\n     C: HasDataLayout,\n {\n     match layout.abi {\n-        abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n+        abi::Abi::Scalar(scalar) => scalar.value.is_float(),\n         abi::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(cx, layout.field(cx, 0))"}, {"sha": "fae3c3af61bf01f02c41f72f1978ff7036513671", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -49,7 +49,7 @@ where\n         let mut c = match layout.abi {\n             Abi::Uninhabited => return Ok(()),\n \n-            Abi::Scalar(ref scalar) => match scalar.value {\n+            Abi::Scalar(scalar) => match scalar.value {\n                 abi::Int(..) | abi::Pointer => Class::Int,\n                 abi::F32 | abi::F64 => Class::Sse,\n             },"}, {"sha": "8764b851affad0999d010a8a1921325b6db6f08e", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -955,7 +955,7 @@ impl AddressSpace {\n \n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum Abi {\n     Uninhabited,\n     Scalar(Scalar),\n@@ -983,8 +983,8 @@ impl Abi {\n     /// Returns `true` if this is a single signed integer scalar\n     #[inline]\n     pub fn is_signed(&self) -> bool {\n-        match *self {\n-            Abi::Scalar(ref scal) => match scal.value {\n+        match self {\n+            Abi::Scalar(scal) => match scal.value {\n                 Primitive::Int(_, signed) => signed,\n                 _ => false,\n             },\n@@ -1053,7 +1053,7 @@ pub enum TagEncoding {\n     },\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct Niche {\n     pub offset: Size,\n     pub scalar: Scalar,\n@@ -1259,7 +1259,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         Ty: TyAbiInterface<'a, C>,\n         C: HasDataLayout,\n     {\n-        let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n+        let scalar_allows_raw_init = move |s: Scalar| -> bool {\n             if zero {\n                 // The range must contain 0.\n                 s.valid_range.contains(0)\n@@ -1270,11 +1270,11 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         };\n \n         // Check the ABI.\n-        let valid = match &self.abi {\n+        let valid = match self.abi {\n             Abi::Uninhabited => false, // definitely UB\n             Abi::Scalar(s) => scalar_allows_raw_init(s),\n             Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n-            Abi::Vector { element: s, count } => *count == 0 || scalar_allows_raw_init(s),\n+            Abi::Vector { element: s, count } => count == 0 || scalar_allows_raw_init(s),\n             Abi::Aggregate { .. } => true, // Fields are checked below.\n         };\n         if !valid {"}, {"sha": "0ecfda19141fa4c32ac2249c469344374ef92fa9", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2f757dae374e22a7733f90af482f405bd426e9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=5b2f757dae374e22a7733f90af482f405bd426e9", "patch": "@@ -465,9 +465,9 @@ fn virtual_call_violation_for_method<'tcx>(\n \n             let param_env = tcx.param_env(method.def_id);\n \n-            let abi_of_ty = |ty: Ty<'tcx>| -> Option<&Abi> {\n+            let abi_of_ty = |ty: Ty<'tcx>| -> Option<Abi> {\n                 match tcx.layout_of(param_env.and(ty)) {\n-                    Ok(layout) => Some(&layout.abi),\n+                    Ok(layout) => Some(layout.abi),\n                     Err(err) => {\n                         // #78372\n                         tcx.sess.delay_span_bug("}]}