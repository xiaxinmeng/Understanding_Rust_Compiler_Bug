{"sha": "092de78fab2bf346a548e59f98db9d7df27a6b56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MmRlNzhmYWIyYmYzNDZhNTQ4ZTU5Zjk4ZGI5ZDdkZjI3YTZiNTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-02T18:57:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-02T19:02:48Z"}, "message": "Update to current rules, make (more) examples build", "tree": {"sha": "e1df8ab0c5b46de2590808072d04ab27f2e0b93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1df8ab0c5b46de2590808072d04ab27f2e0b93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/092de78fab2bf346a548e59f98db9d7df27a6b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/092de78fab2bf346a548e59f98db9d7df27a6b56", "html_url": "https://github.com/rust-lang/rust/commit/092de78fab2bf346a548e59f98db9d7df27a6b56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/092de78fab2bf346a548e59f98db9d7df27a6b56/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c7459de99fa017f4fdd30bf3436b611f8e68910", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c7459de99fa017f4fdd30bf3436b611f8e68910", "html_url": "https://github.com/rust-lang/rust/commit/6c7459de99fa017f4fdd30bf3436b611f8e68910"}], "stats": {"total": 419, "additions": 224, "deletions": 195}, "files": [{"sha": "8b264a9d609d1778884ae79209010058b59fdf0b", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 224, "deletions": 195, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/092de78fab2bf346a548e59f98db9d7df27a6b56/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/092de78fab2bf346a548e59f98db9d7df27a6b56/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=092de78fab2bf346a548e59f98db9d7df27a6b56", "patch": "@@ -4,7 +4,7 @@\n \n Borrowed pointers are one of the more flexible and powerful tools\n available in Rust. A borrowed pointer can be used to point anywhere:\n-into the shared and exchange heaps, into the stack, and even into the\n+into the managed and exchange heaps, into the stack, and even into the\n interior of another data structure. With regard to flexibility, it is\n comparable to a C pointer or C++ reference. However, unlike C and C++,\n the Rust compiler includes special checks that ensure that borrowed\n@@ -29,21 +29,21 @@ a limit duration. Borrowed pointers never claim any kind of ownership\n over the data that they point at: instead, they are used for cases\n where you like to make use of data for a short time.\n \n-As an example, consider a simple struct type `point`:\n+As an example, consider a simple struct type `Point`:\n \n ~~~\n-struct point {x: float, y: float}\n+struct Point {x: float, y: float}\n ~~~\n \n We can use this simple definition to allocate points in many ways. For\n example, in this code, each of these three local variables contains a\n point, but allocated in a different place:\n \n ~~~\n-# type point = {x: float, y: float};\n-let on_the_stack : point  =  {x: 3.0, y: 4.0};\n-let shared_box   : @point = @{x: 5.0, y: 1.0};\n-let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n+# struct Point {x: float, y: float}\n+let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\n+let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n+let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance\n@@ -59,9 +59,9 @@ define a function that takes the points by pointer. We can use\n borrowed pointers to do this:\n \n ~~~\n-# type point = {x: float, y: float};\n+# struct Point {x: float, y: float}\n # fn sqrt(f: float) -> float { 0f }\n-fn compute_distance(p1: &point, p2: &point) -> float {\n+fn compute_distance(p1: &Point, p2: &Point) -> float {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n     sqrt(x_d * x_d + y_d * y_d)\n@@ -71,26 +71,26 @@ fn compute_distance(p1: &point, p2: &point) -> float {\n Now we can call `compute_distance()` in various ways:\n \n ~~~\n-# type point = {x: float, y: float};\n-# let on_the_stack : point  =  {x: 3.0, y: 4.0};\n-# let shared_box   : @point = @{x: 5.0, y: 1.0};\n-# let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n-# fn compute_distance(p1: &point, p2: &point) -> float { 0f }\n+# struct Point {x: float, y: float}\n+# let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\n+# let shared_box   : @Point = @Point{x: 5.0, y: 1.0};\n+# let unique_box   : ~Point = ~Point{x: 7.0, y: 9.0};\n+# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n compute_distance(&on_the_stack, shared_box);\n compute_distance(shared_box, unique_box);\n ~~~\n \n Here the `&` operator is used to take the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `point`\n+`on_the_stack`; this is because `on_the_stack` has the type `Point`\n (that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we are created an alias: that is, another\n route to the same data.\n \n In the case of the boxes `shared_box` and `unique_box`, however, no\n explicit action is necessary. The compiler will automatically convert\n-a box like `@point` or `~point` to a borrowed pointer like\n-`&point`. This is another form of borrowing; in this case, the\n+a box like `@Point` or `~Point` to a borrowed pointer like\n+`&Point`. This is another form of borrowing; in this case, the\n contents of the shared/unique box is being lent out.\n \n Whenever a value is borrowed, there are some limitations on what you\n@@ -108,8 +108,8 @@ it again.\n In the previous example, the value `on_the_stack` was defined like so:\n \n ~~~\n-# type point = {x: float, y: float};\n-let on_the_stack : point = {x: 3.0, y: 4.0};\n+# struct Point {x: float, y: float}\n+let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n ~~~\n \n This results in a by-value variable. As a consequence, we had to\n@@ -118,60 +118,66 @@ pointer. Sometimes however it is more convenient to move the &\n operator into the definition of `on_the_stack`:\n \n ~~~\n-# type point = {x: float, y: float};\n-let on_the_stack2 : &point = &{x: 3.0, y: 4.0};\n+# struct Point {x: float, y: float}\n+let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n ~~~\n \n Applying `&` to an rvalue (non-assignable location) is just a convenient\n shorthand for creating a temporary and taking its address:\n \n ~~~\n-# type point = {x: float, y: float};\n-let tmp = {x: 3.0, y: 4.0};\n-let on_the_stack2 : &point = &tmp;\n+# struct Point {x: float, y: float}\n+let tmp = Point {x: 3.0, y: 4.0};\n+let on_the_stack2 : &Point = &tmp;\n ~~~\n \n-Taking the address of fields\n+# Taking the address of fields\n \n As in C, the `&` operator is not limited to taking the address of\n local variables. It can also be used to take the address of fields or\n individual array elements. For example, consider this type definition\n for `rectangle`:\n \n ~~~\n-type point = {x: float, y: float}; // as before\n-type size = {w: float, h: float}; // as before\n-type rectangle = {origin: point, size: size};\n+struct Point {x: float, y: float} // as before\n+struct Size {w: float, h: float} // as before\n+struct Rectangle {origin: Point, size: Size}\n ~~~\n \n Now again I can define rectangles in a few different ways:\n \n ~~~\n-let rect_stack  = &{origin: {x: 1f, y: 2f}, size: {w: 3f, h: 4f}};\n-let rect_shared = @{origin: {x: 3f, y: 4f}, size: {w: 3f, h: 4f}};\n-let rect_unique = ~{origin: {x: 5f, y: 6f}, size: {w: 3f, h: 4f}};\n+# struct Point {x: float, y: float}\n+# struct Size {w: float, h: float} // as before\n+# struct Rectangle {origin: Point, size: Size}\n+let rect_stack   = &Rectangle {origin: Point {x: 1f, y: 2f},\n+                               size: Size {w: 3f, h: 4f}};\n+let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f},\n+                               size: Size {w: 3f, h: 4f}};\n+let rect_unique  = ~Rectangle {origin: Point {x: 5f, y: 6f},\n+                               size: Size {w: 3f, h: 4f}};\n ~~~\n \n In each case I can use the `&` operator to extact out individual\n subcomponents. For example, I could write:\n \n ~~~\n-# type point = {x: float, y: float};\n-# type size = {w: float, h: float}; // as before\n-# type rectangle = {origin: point, size: size};\n-# let rect_stack  = &{origin: {x: 1f, y: 2f}, size: {w: 3f, h: 4f}};\n-# let rect_shared = @{origin: {x: 3f, y: 4f}, size: {w: 3f, h: 4f}};\n-# let rect_unique = ~{origin: {x: 5f, y: 6f}, size: {w: 3f, h: 4f}};\n-# fn compute_distance(p1: &point, p2: &point) -> float { 0f }\n-compute_distance(&rect_stack.origin, &rect_shared.origin);\n+# struct Point {x: float, y: float} // as before\n+# struct Size {w: float, h: float} // as before\n+# struct Rectangle {origin: Point, size: Size}\n+# let rect_stack  = &{origin: Point {x: 1f, y: 2f}, size: Size {w: 3f, h: 4f}};\n+# let rect_managed = @{origin: Point {x: 3f, y: 4f}, size: Size {w: 3f, h: 4f}};\n+# let rect_unique = ~{origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n+# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n+compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n \n which would borrow the field `origin` from the rectangle on the stack\n-from the shared box and then compute the distance between them.\n+from the managed box and then compute the distance between them.\n \n-# Borrowing shared boxes and rooting\n+# Borrowing managed boxes and rooting\n \n-We\u2019ve seen a few examples so far where heap boxes (both shared and\n+We\u2019ve seen a few examples so far where heap boxes (both managed and\n unique) are borrowed. Up till this point, we\u2019ve glossed over issues of\n safety. As stated in the introduction, at runtime a borrowed pointer\n is simply a pointer, nothing more. Therefore, if we wish to avoid the\n@@ -192,8 +198,9 @@ relatively easy, such as when taking the address of a local variable\n or a field that is stored on the stack:\n \n ~~~\n+struct X { f: int }\n fn example1() {\n-    let mut x = {f: 3};\n+    let mut x = X { f: 3 };\n     let y = &mut x.f;  // -+ L\n     ...                //  |\n }                      // -+\n@@ -207,8 +214,9 @@ The situation gets more complex when borrowing data that resides in\n heap boxes:\n \n ~~~\n+# struct X { f: int }\n fn example2() {\n-    let mut x = @{f: 3};\n+    let mut x = @X { f: 3 };\n     let y = &x.f;      // -+ L\n     ...                //  |\n }                      // -+\n@@ -218,40 +226,41 @@ In this example, the value `x` is in fact a heap box, and `y` is\n therefore a pointer into that heap box. Again the lifetime of `y` will\n be L, the remainder of the function body. But there is a crucial\n difference: suppose `x` were reassigned during the lifetime L? If\n-we\u2019re not careful, that could mean that the shared box would become\n+we\u2019re not careful, that could mean that the managed box would become\n unrooted and therefore be subject to garbage collection\n \n > ***Note:***In our current implementation, the garbage collector is\n > implemented using reference counting and cycle detection.\n \n-For this reason, whenever the interior of a shared box stored in a\n+For this reason, whenever the interior of a managed box stored in a\n mutable location is borrowed, the compiler will insert a temporary\n-that ensures that the shared box remains live for the entire\n+that ensures that the managed box remains live for the entire\n lifetime. So, the above example would be compiled as:\n \n ~~~\n+# struct X { f: int }\n fn example2() {\n-    let mut x = @{f: 3};\n+    let mut x = @X {f: 3};\n     let x1 = x;\n     let y = &x1.f;     // -+ L\n     ...                //  |\n }                      // -+\n ~~~\n \n Now if `x` is reassigned, the pointer `y` will still remain valid. This\n-process is called \u201crooting\u201d.\n+process is called *rooting*.\n \n # Borrowing unique boxes\n \n-The previous example demonstrated `rooting`, the process by which the\n-compiler ensures that shared boxes remain live for the duration of a\n+The previous example demonstrated *rooting*, the process by which the\n+compiler ensures that managed boxes remain live for the duration of a\n borrow. Unfortunately, rooting does not work if the data being\n borrowed is a unique box, as it is not possible to have two references\n to a unique box.\n \n-For unique boxes, therefore, the compiler will only allow a borrow `if\n+For unique boxes, therefore, the compiler will only allow a borrow *if\n the compiler can guarantee that the unique box will not be reassigned\n-or moved for the lifetime of the pointer`. This does not necessarily\n+or moved for the lifetime of the pointer*. This does not necessarily\n mean that the unique box is stored in immutable memory. For example,\n the following function is legal:\n \n@@ -283,7 +292,7 @@ rejected by the compiler):\n \n ~~~ {.xfail-test}\n fn example3() -> int {\n-    let mut x = ~{f: 3};\n+    let mut x = ~X {f: 3};\n     let y = &x.f;\n     x = ~{f: 4};  // Error reported here.\n     *y\n@@ -349,17 +358,20 @@ Things get tricker when the unique box is not uniquely owned by the\n stack frame (or when the compiler doesn\u2019t know who the owner\n is). Consider a program like this:\n \n-~~~ {.xfail-test}\n-fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n+~~~\n+struct R { g: int }\n+struct S { mut f: ~R }\n+fn example5a(x: @S ...) -> int {\n     let y = &x.f.g;   // Error reported here.\n     ...\n+#   return 0;\n }\n ~~~\n \n Here the heap looks something like:\n \n ~~~ {.notrust}\n-     Stack            Shared Heap       Exchange Heap\n+     Stack            Managed Heap       Exchange Heap\n \n   x +------+        +-------------+       +------+\n     | @... | ---->  | mut f: ~... | --+-> | g: 3 |\n@@ -371,7 +383,7 @@ Here the heap looks something like:\n In this case, the owning reference to the value being borrowed is in\n fact `x.f`. Moreover, `x.f` is both mutable and aliasable. Aliasable\n means that it is possible that there are other pointers to that same\n-shared box, so even if the compiler were to prevent `x.f` from being\n+managed box, so even if the compiler were to prevent `x.f` from being\n mutated, the field might still be changed through some alias of\n `x`. Therefore, to be safe, the compiler only accepts pure actions\n during the lifetime of `y`. We\u2019ll have a final example on purity but\n@@ -382,7 +394,9 @@ unique found in aliasable memory is to ensure that it is stored within\n unique fields, as in the following example:\n \n ~~~\n-fn example5b(x: @{f: ~{g: int}}) -> int {\n+struct R { g: int }\n+struct S { f: ~R }\n+fn example5b(x: @S) -> int {\n     let y = &x.f.g;\n     ...\n # return 0;\n@@ -397,21 +411,32 @@ If you do have a unique box in a mutable field, and you wish to borrow\n it, one option is to use the swap operator to bring that unique box\n onto your stack:\n \n-~~~ {.xfail-test}\n-fn example5c(x: @{mut f: ~int}) -> int {\n-    let mut v = ~0;\n+~~~\n+struct R { g: int }\n+struct S { mut f: ~R }\n+fn example5c(x: @S) -> int {\n+    let mut v = ~R {g: 0};\n     v <-> x.f;         // Swap v and x.f\n-    let y = &v;\n-    ...\n+    { // Block constrains the scope of `y`:\n+        let y = &v.g;\n+        ...\n+    }\n     x.f <- v;          // Replace x.f\n     ...\n # return 0;\n }\n ~~~\n \n-Of course, this has the side effect of modifying your shared box for\n-the duration of the borrow, so it works best when you know that you\n-won\u2019t be accessing that same box again.\n+Of course, this has the side effect of modifying your managed box for\n+the duration of the borrow, so it only works when you know that you\n+won\u2019t be accessing that same box for the duration of the loan.  Note\n+also that sometimes it is necessary to introduce additional blocks to\n+constrain the scope of the loan.  In this example, the borrowed\n+pointer `y` would still be in scope when you moved the value `v` back\n+into `x.f`, and hence moving `v` would be considered illegal.  You\n+cannot move values if they are outstanding loans which are still\n+valid.  By introducing the block, the scope of `y` is restricted and so\n+the move is legal.\n \n # Borrowing and enums\n \n@@ -425,11 +450,11 @@ As an example, let\u2019s look at the following `shape` type that can\n represent both rectangles and circles:\n \n ~~~\n-type point = {x: float, y: float}; // as before\n-type size = {w: float, h: float}; // as before\n-enum shape {\n-    circle(point, float),   // origin, radius\n-    rectangle(point, size)  // upper-left, dimensions\n+struct Point {x: float, y: float}; // as before\n+struct Size {w: float, h: float}; // as before\n+enum Shape {\n+    Circle(Point, float),   // origin, radius\n+    Rectangle(Point, Size)  // upper-left, dimensions\n }\n ~~~\n \n@@ -438,17 +463,17 @@ function takes a borrowed pointer to a shape to avoid the need of\n copying them.\n \n ~~~\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n # const tau: float = 6.28f;\n-fn compute_area(shape: &shape) -> float {\n+fn compute_area(shape: &Shape) -> float {\n     match *shape {\n-        circle(_, radius) => 0.5 * tau * radius * radius,\n-        rectangle(_, ref size) => size.w * size.h\n+        Circle(_, radius) => 0.5 * tau * radius * radius,\n+        Rectangle(_, ref size) => size.w * size.h\n     }\n }\n ~~~\n@@ -514,53 +539,60 @@ same rules as the ones we saw for borrowing the interior of a unique\n box: it must be able to guarantee that the enum will not be\n overwritten for the duration of the borrow.  In fact, the example I\n gave earlier would be considered safe. This is because the shape\n-pointer has type `&shape`, which means \u201cborrowed pointer to immutable\n+pointer has type `&Shape`, which means \u201cborrowed pointer to immutable\n memory containing a shape\u201d. If however the type of that pointer were\n-`&const shape` or `&mut shape`, then the ref binding would not be\n+`&const Shape` or `&mut Shape`, then the ref binding would not be\n permitted. Just as with unique boxes, the compiler will permit ref\n bindings into data owned by the stack frame even if it is mutable, but\n otherwise it requires that the data reside in immutable memory.\n \n-> ***Note:*** Right now, all pattern bindings are by-reference. We\n-> expect this to change so that copies are the default and references\n-> must be noted explicitly.\n+> ***Note:*** Right now, pattern bindings not explicitly annotated\n+> with `ref` or `copy` use a special mode of \"implicit by reference\".\n+> This is changing as soon as we finish updating all the existing code\n+> in the compiler that relies on the current settings.\n \n # Returning borrowed pointers\n \n So far, all of the examples we\u2019ve looked at use borrowed pointers in a\n \u201cdownward\u201d direction. That is, the borrowed pointer is created and\n-then used during the method or code block which created it. In some\n-cases, it is also possible to return borrowed pointers to the caller,\n-but as we\u2019ll see this is more limited.\n+then used during the method or code block which created it. It is also\n+possible to return borrowed pointers to the caller, but as we'll see\n+this requires some explicit annotation.\n \n For example, we could write a subroutine like this:\n \n-~~~ {.xfail-test}\n-type point = {x: float, y: float};\n-fn get_x(p: &point) -> &float { &p.x }\n+~~~\n+struct Point {x: float, y: float}\n+fn get_x(p: &r/Point) -> &r/float { &p.x }\n ~~~\n \n Here, the function `get_x()` returns a pointer into the structure it was\n-given. You\u2019ll note that _both_ the parameter and the return value are\n-borrowed pointers; this is important. In general, it is only possible\n-to return borrowed pointers if they are derived from a borrowed\n-pointer which was given as input to the procedure.\n-\n-In the example, `get_x()` took a borrowed pointer to a `point` as\n-input. In general, for all borrowed pointers that appear in the\n-signature of a function (such as the parameter and return types), the\n-compiler assigns the same symbolic lifetime L (we will see later that\n-there are ways to differentiate the lifetimes of different parameters\n-if that should be necessary). This means that, from the compiler\u2019s\n-point of view, `get_x()` takes and returns two pointers with the same\n-lifetime. Now, unlike other lifetimes, this lifetime is a bit\n-abstract: it doesn\u2019t refer to a specific expression within `get_x()`,\n-but rather to some expression within the caller. This is called a\n-_lifetime parameter_, because the lifetime L is effectively defined by\n-the caller to `get_x()`, just as the value for the parameter `p` is\n-defined by the caller.\n-\n-In any case, whatever the lifetime L is, the pointer produced by\n+given. The type of the parameter (`&r/Point`) and return type (`&r/float`) both\n+make use of a new syntactic form that we have not seen so far.  Here the identifier `r`\n+serves as an explicit name for the lifetime of the pointer.  So in effect\n+this function is declaring that it takes in a pointer with lifetime `r` and returns\n+a pointer with that same lifetime.\n+\n+In general, it is only possible to return borrowed pointers if they\n+are derived from a borrowed pointer which was given as input to the\n+procedure.  In that case, they will always have the same lifetime as\n+one of the parameters; named lifetimes are used to indicate which\n+parameter that is.\n+\n+In the examples before, function parameter types did not include a\n+lifetime name.  In this case, the compiler simply creates a new,\n+anonymous name, meaning that the parameter is assumed to have a\n+distinct lifetime from all other parameters.\n+\n+Named lifetimes that appear in function signatures are conceptually\n+the same as the other lifetimes we've seen before, but they are a bit\n+abstract: they don\u2019t refer to a specific expression within `get_x()`,\n+but rather to some expression within the *caller of `get_x()`*.  The\n+lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n+by the caller to `get_x()`, just as the value for the parameter `p` is\n+defined by that caller.\n+\n+In any case, whatever the lifetime `r` is, the pointer produced by\n `&p.x` always has the same lifetime as `p` itself, as a pointer to a\n field of a struct is valid as long as the struct is valid. Therefore,\n the compiler is satisfied with the function `get_x()`.\n@@ -569,13 +601,13 @@ To drill in this point, let\u2019s look at a variation on the example, this\n time one which does not compile:\n \n ~~~ {.xfail-test}\n-struct point {x: float, y: float}\n-fn get_x_sh(p: @point) -> &float {\n+struct Point {x: float, y: float}\n+fn get_x_sh(p: @Point) -> &float {\n     &p.x // Error reported here\n }\n ~~~\n \n-Here, the function `get_x_sh()` takes a shared box as input and\n+Here, the function `get_x_sh()` takes a managed box as input and\n returns a borrowed pointer. As before, the lifetime of the borrowed\n pointer that will be returned is a parameter (specified by the\n caller). That means that effectively `get_x_sh()` is promising to\n@@ -585,121 +617,114 @@ promised to return a pointer that was valid for as long as the pointer\n it was given.\n \n Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a shared box. This implies that the compiler\n+address of a field of a managed box. This implies that the compiler\n must guarantee that, so long as the resulting pointer is valid, the\n-shared box will not be reclaimed by the garbage collector. But recall\n-that get_x_sh() also promised to return a pointer that was valid for\n+managed box will not be reclaimed by the garbage collector. But recall\n+that `get_x_sh()` also promised to return a pointer that was valid for\n as long as the caller wanted it to be. Clearly, `get_x_sh()` is not in\n a position to make both of these guarantees; in fact, it cannot\n guarantee that the pointer will remain valid at all once it returns,\n as the parameter `p` may or may not be live in the caller. Therefore,\n the compiler will report an error here.\n \n-In general, if you borrow a shared (or unique) box to create a\n+In general, if you borrow a managed (or unique) box to create a\n borrowed pointer, the pointer will only be valid within the function\n-and cannot be returned. Generally, the only way to return borrowed\n-pointers is to take borrowed pointers as input.\n+and cannot be returned. This is why the typical way to return borrowed\n+pointers is to take borrowed pointers as input (the only other case in\n+which it can be legal to return a borrowed pointer is if the pointer\n+points at a static constant).\n \n # Named lifetimes\n \n-So far we have always used the notation `&T` for a borrowed\n-pointer. However, sometimes if a function takes many parameters, it is\n-useful to be able to group those parameters by lifetime. For example,\n-consider this function:\n+Let's look at named lifetimes in more detail.  In effect, the use of\n+named lifetimes allows you to group parameters by lifetime.  For\n+example, consider this function:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-fn select<T>(shape: &shape, threshold: float,\n-             a: &T, b: &T) -> &T {\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+fn select<T>(shape: &r/Shape, threshold: float,\n+             a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~\n \n-This function takes three borrowed pointers. Because of the way that\n-the system works, each will be assigned the same lifetime: the default\n-lifetime parameter. In practice, this means that, in the caller, the\n-lifetime of the returned value will be the intersection of the\n-lifetime of the three region parameters. This may be overloy\n-conservative, as in this example:\n+This function takes three borrowed pointers and assigns each the same\n+lifetime `r`.  In practice, this means that, in the caller, the\n+lifetime `r` will be the *intersection of the lifetime of the three\n+region parameters*. This may be overly conservative, as in this\n+example:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-# fn select<T>(shape: &shape, threshold: float,\n-#              a: &T, b: &T) -> &T {\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+# fn select<T>(shape: &Shape, threshold: float,\n+#              a: &r/T, b: &r/T) -> &r/T {\n #     if compute_area(shape) > threshold {a} else {b}\n # }\n-\n-                                              // -+ L\n-fn select_based_on_unit_circle<T>(            //  |-+ B\n-    threshold: float, a: &T, b: &T) -> &T {   //  | |\n-                                              //  | |\n-    let shape = circle({x: 0, y: 0}, 1);      //  | |\n-    select(&shape, threshold, a, b)           //  | |\n-}                                             //  |-+\n-                                              // -+\n+                                                  // -+ r\n+fn select_based_on_unit_circle<T>(                //  |-+ B\n+    threshold: float, a: &r/T, b: &r/T) -> &r/T { //  | |\n+                                                  //  | |\n+    let shape = Circle(Point {x: 0., y: 0.}, 1.); //  | |\n+    select(&shape, threshold, a, b)               //  | |\n+}                                                 //  |-+\n+                                                  // -+\n ~~~\n \n In this call to `select()`, the lifetime of the first parameter shape\n is B, the function body. Both of the second two parameters `a` and `b`\n-share the same lifetime, L, which is the lifetime parameter of\n+share the same lifetime, `r`, which is a lifetime parameter of\n `select_based_on_unit_circle()`. The caller will infer the\n-intersection of these three lifetimes as the lifetime of the returned\n+intersection of these two lifetimes as the lifetime of the returned\n value, and hence the return value of `shape()` will be assigned a\n-return value of B. This will in turn lead to a compilation error,\n-because `select_based_on_unit_circle()` is supposed to return a value\n-with the lifetime L.\n+lifetime of B. This will in turn lead to a compilation error, because\n+`select_based_on_unit_circle()` is supposed to return a value with the\n+lifetime `r`.\n \n-To address this, we could modify the definition of `select()` to\n+To address this, we can modify the definition of `select()` to\n distinguish the lifetime of the first parameter from the lifetime of\n the latter two. After all, the first parameter is not being\n-returned. To do so, we make use of the notation `&lt/T`, which is a\n-borrowed pointer with an explicit lifetime. This effectively creates a\n-second lifetime parameter for the function; named lifetime parameters\n-do not need to be declared, you just use them. Here is how the new\n-`select()` might look:\n+returned. Here is how the new `select()` might look:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-fn select<T>(shape: &tmp/shape, threshold: float,\n-             a: &T, b: &T) -> &T {\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+fn select<T>(shape: &tmp/Shape, threshold: float,\n+             a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~\n \n Here you can see the lifetime of shape is now being called `tmp`. The\n-parameters `a`, `b`, and the return value all remain with the default\n-lifetime parameter.\n+parameters `a`, `b`, and the return value are all given the lifetime\n+`r`.  However, since the lifetime `tmp` is not returned, it would be shorter\n+to just omit the named lifetime for `shape` altogether:\n \n-You could also write `select()` using all named lifetime parameters,\n-which might look like:\n-\n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-fn select<T>(shape: &tmp/shape, threshold: float,\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+fn select<T>(shape: &Shape, threshold: float,\n              a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n@@ -724,7 +749,9 @@ a unique box found in an aliasable, mutable location, only now we\u2019ve\n replaced the `...` with some specific code:\n \n ~~~\n-fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n+struct R { g: int }\n+struct S { mut f: ~R }\n+fn example5a(x: @S ...) -> int {\n     let y = &x.f.g;   // Unsafe\n     *y + 1        \n }\n@@ -742,9 +769,11 @@ fn add_one(x: &int) -> int { *x + 1 }\n \n We can now update `example5a()` to use `add_one()`:\n \n-~~~ {.xfail-test}\n-# fn add_one(x: &int) -> int { *x + 1 }\n-fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n+~~~\n+# struct R { g: int }\n+# struct S { mut f: ~R }\n+# pure fn add_one(x: &int) -> int { *x + 1 }\n+fn example5a(x: @S ...) -> int {\n     let y = &x.f.g;\n     add_one(y)        // Error reported here\n }\n@@ -766,4 +795,4 @@ With this change, the modified version of `example5a()` will again compile.\n So there you have it. A (relatively) brief tour of borrowed pointer\n system. For more details, I refer to the (yet to be written) reference\n document on borrowed pointers, which will explain the full notation\n-and give more examples.\n\\ No newline at end of file\n+and give more examples."}]}