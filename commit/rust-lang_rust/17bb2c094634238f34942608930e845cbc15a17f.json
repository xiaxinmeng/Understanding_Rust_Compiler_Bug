{"sha": "17bb2c094634238f34942608930e845cbc15a17f", "node_id": "C_kwDOAAsO6NoAKDE3YmIyYzA5NDYzNDIzOGYzNDk0MjYwODkzMGU4NDVjYmMxNWExN2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T00:06:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T00:06:12Z"}, "message": "Auto merge of #2428 - RalfJung:cargo-miri-runner, r=RalfJung\n\ncargo-miri: use '--config target.runner' rather than the TARGET_RUNNER env vars\n\nThat means we can properly escape spaces in our filename. This should fix https://github.com/rust-lang/miri/issues/2417, hopefully for real this time. We can also specify a \"leading command\" which makes it much easier to disambiguate runner invocations from rustdoc invocations!\n\nThanks to `@ehuss` for suggesting this.", "tree": {"sha": "fc2933265b56b95b48b4f1a20e9c70ef9b53a3eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc2933265b56b95b48b4f1a20e9c70ef9b53a3eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17bb2c094634238f34942608930e845cbc15a17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17bb2c094634238f34942608930e845cbc15a17f", "html_url": "https://github.com/rust-lang/rust/commit/17bb2c094634238f34942608930e845cbc15a17f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17bb2c094634238f34942608930e845cbc15a17f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62efc6201bcf6d5fd665ce19747b3f06c0514883", "url": "https://api.github.com/repos/rust-lang/rust/commits/62efc6201bcf6d5fd665ce19747b3f06c0514883", "html_url": "https://github.com/rust-lang/rust/commit/62efc6201bcf6d5fd665ce19747b3f06c0514883"}, {"sha": "b93fcd99e84f31becfb205c858b2054a9ce9b902", "url": "https://api.github.com/repos/rust-lang/rust/commits/b93fcd99e84f31becfb205c858b2054a9ce9b902", "html_url": "https://github.com/rust-lang/rust/commit/b93fcd99e84f31becfb205c858b2054a9ce9b902"}], "stats": {"total": 129, "additions": 62, "deletions": 67}, "files": [{"sha": "1b14d4da9cc476a0bbbfa29d6b6822bb17afabf0", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/17bb2c094634238f34942608930e845cbc15a17f/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bb2c094634238f34942608930e845cbc15a17f/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=17bb2c094634238f34942608930e845cbc15a17f", "patch": "@@ -9,7 +9,7 @@ use std::ffi::{OsStr, OsString};\n use std::fmt::Write as _;\n use std::fs::{self, File};\n use std::io::{self, BufRead, BufReader, BufWriter, Read, Write};\n-use std::iter::TakeWhile;\n+use std::iter::{self, TakeWhile};\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n@@ -35,6 +35,11 @@ The cargo options are exactly the same as for `cargo run` and `cargo test`, resp\n Examples:\n     cargo miri run\n     cargo miri test -- test-suite-filter\n+\n+    cargo miri setup --print sysroot\n+        This will print the path to the generated sysroot (and nothing else) on stdout.\n+        stderr will still contain progress information about how the build is doing.\n+\n \"#;\n \n #[derive(Clone, Debug)]\n@@ -206,6 +211,14 @@ fn forward_miri_sysroot(cmd: &mut Command) {\n     cmd.arg(sysroot);\n }\n \n+/// Escapes `s` in a way that is suitable for using it as a string literal in TOML syntax.\n+fn escape_for_toml(s: &str) -> String {\n+    // We want to surround this string in quotes `\"`. So we first escape all quotes,\n+    // and also all backslashes (that are used to escape quotes).\n+    let s = s.replace('\\\\', r#\"\\\\\"#).replace('\"', r#\"\\\"\"#);\n+    format!(\"\\\"{}\\\"\", s)\n+}\n+\n /// Returns the path to the `miri` binary\n fn find_miri() -> PathBuf {\n     if let Some(path) = env::var_os(\"MIRI\") {\n@@ -353,17 +366,15 @@ fn write_to_file(filename: &Path, content: &str) {\n /// done all this already.\n fn setup(subcommand: &MiriCommand) {\n     let only_setup = matches!(subcommand, MiriCommand::Setup);\n+    let ask_user = !only_setup;\n+    let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n     if std::env::var_os(\"MIRI_SYSROOT\").is_some() {\n         if only_setup {\n             println!(\"WARNING: MIRI_SYSROOT already set, not doing anything.\")\n         }\n         return;\n     }\n \n-    // Subcommands other than `setup` will do a setup if necessary, but\n-    // interactively confirm first.\n-    let ask_user = !only_setup;\n-\n     // First, we need xargo.\n     if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n         if std::env::var_os(\"XARGO_CHECK\").is_some() {\n@@ -499,8 +510,14 @@ path = \"lib.rs\"\n     command.env(\"RUSTFLAGS\", \"-Cdebug-assertions=off -Coverflow-checks=on\");\n     // Manage the output the user sees.\n     if only_setup {\n+        // We want to be explicit.\n         eprintln!(\"Preparing a sysroot for Miri...\");\n+        if print_sysroot {\n+            // Be extra sure there is no noise on stdout.\n+            command.stdout(process::Stdio::null());\n+        }\n     } else {\n+        // We want to be quiet, but still let the user know that something is happening.\n         eprint!(\"Preparing a sysroot for Miri... \");\n         command.stdout(process::Stdio::null());\n         command.stderr(process::Stdio::null());\n@@ -515,22 +532,21 @@ path = \"lib.rs\"\n             ))\n         }\n     }\n-    if !only_setup {\n-        eprintln!(\"done\");\n-    }\n \n     // That should be it! But we need to figure out where xargo built stuff.\n     // Unfortunately, it puts things into a different directory when the\n     // architecture matches the host.\n     let sysroot = if target == &host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot); // pass the env var to the processes we spawn, which will turn it into \"--sysroot\" flags\n     // Figure out what to print.\n-    let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n+    if only_setup {\n+        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n+    } else {\n+        eprintln!(\"done\");\n+    }\n     if print_sysroot {\n         // Print just the sysroot and nothing else to stdout; this way we do not need any escaping.\n         println!(\"{}\", sysroot.display());\n-    } else if only_setup {\n-        eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot.display());\n     }\n }\n \n@@ -669,7 +685,11 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n     // approach that uses `cargo check`, making that part easier but target and binary handling\n     // harder.\n-    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    let cargo_miri_path = std::env::current_exe()\n+        .expect(\"current executable path invalid\")\n+        .into_os_string()\n+        .into_string()\n+        .expect(\"current executable path is not valid UTF-8\");\n     let cargo_cmd = match subcommand {\n         MiriCommand::Forward(s) => s,\n         MiriCommand::Setup => return, // `cargo miri setup` stops here.\n@@ -699,20 +719,21 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     target_dir.push(\"miri\");\n     cmd.arg(\"--target-dir\").arg(target_dir);\n \n-    // Make sure we know the build target, and cargo does, too.\n-    // This is needed to make the `CARGO_TARGET_*_RUNNER` env var do something,\n+    // Make sure the build target is explicitly set.\n+    // This is needed to make the `target.runner` settings do something,\n     // and it later helps us detect which crates are proc-macro/build-script\n     // (host crates) and which crates are needed for the program itself.\n-    let host = version_info().host;\n-    let target = get_arg_flag_value(\"--target\");\n-    let target = if let Some(ref target) = target {\n-        target\n-    } else {\n-        // No target given. Pick default and tell cargo about it.\n+    if get_arg_flag_value(\"--target\").is_none() {\n+        // No target given. Explicitly pick the host.\n         cmd.arg(\"--target\");\n-        cmd.arg(&host);\n-        &host\n-    };\n+        cmd.arg(version_info().host);\n+    }\n+\n+    // Set ourselves as runner for al binaries invoked by cargo.\n+    // We use `all()` since `true` is not a thing in cfg-lang, but the empty conjunction is. :)\n+    let cargo_miri_path_for_toml = escape_for_toml(&cargo_miri_path);\n+    cmd.arg(\"--config\")\n+        .arg(format!(\"target.'cfg(all())'.runner=[{cargo_miri_path_for_toml}, 'runner']\"));\n \n     // Forward all further arguments after `--` to cargo.\n     cmd.arg(\"--\").args(args);\n@@ -743,16 +764,6 @@ fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     // bootstrap `rustc` thing in our way! Instead, we have MIRI_HOST_SYSROOT to use for host builds.\n     cmd.env(\"RUSTC\", &fs::canonicalize(find_miri()).unwrap());\n \n-    let runner_env_name =\n-        |triple: &str| format!(\"CARGO_TARGET_{}_RUNNER\", triple.to_uppercase().replace('-', \"_\"));\n-    let host_runner_env_name = runner_env_name(&host);\n-    let target_runner_env_name = runner_env_name(target);\n-    // Set the target runner to us, so we can interpret the binaries.\n-    cmd.env(&target_runner_env_name, &cargo_miri_path);\n-    // Unit tests of `proc-macro` crates are run on the host, so we set the host runner to\n-    // us in order to skip them.\n-    cmd.env(&host_runner_env_name, &cargo_miri_path);\n-\n     // Set rustdoc to us as well, so we can run doctests.\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n@@ -1194,38 +1205,25 @@ fn main() {\n         return;\n     }\n \n-    let mut args = args.peekable();\n-    if args.next_if(|a| a == \"miri\").is_some() {\n-        phase_cargo_miri(args);\n-    } else if let Some(arg) = args.peek().cloned() {\n-        // Cargo calls us for everything it does. We could be invoked as rustc, rustdoc, or the runner.\n-\n-        // If the first arg is equal to the RUSTC variable (which should be set at this point),\n-        // then we need to behave as rustc. This is the somewhat counter-intuitive behavior of\n-        // having both RUSTC and RUSTC_WRAPPER set (see\n-        // https://github.com/rust-lang/cargo/issues/10886).\n-        if arg == env::var(\"RUSTC\").unwrap() {\n-            args.next().unwrap(); // consume wrapped RUSTC command.\n-            return phase_rustc(args, RustcPhase::Build);\n-        }\n-        // We have to distinguish the \"runner\" and \"rustdoc\" cases.\n-        // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n-        // as rustdoc, the first argument is a flag (`--something`).\n-        let binary = Path::new(&arg);\n-        if binary.exists() {\n-            assert!(!arg.starts_with(\"--\")); // not a flag\n-            phase_runner(args, RunnerPhase::Cargo);\n-        } else if arg.starts_with(\"--\") {\n-            phase_rustdoc(args);\n-        } else {\n-            show_error(format!(\n-                \"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\",\n-                arg\n-            ));\n-        }\n-    } else {\n+    let Some(first) = args.next() else {\n         show_error(format!(\n             \"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\"\n-        ));\n+        ))\n+    };\n+    match first.as_str() {\n+        \"miri\" => phase_cargo_miri(args),\n+        \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n+        arg if arg == env::var(\"RUSTC\").unwrap() => {\n+            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n+            // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n+            // behavior of having both RUSTC and RUSTC_WRAPPER set\n+            // (see https://github.com/rust-lang/cargo/issues/10886).\n+            phase_rustc(args, RustcPhase::Build)\n+        }\n+        _ => {\n+            // Everything else must be rustdoc. But we need to get `first` \"back onto the iterator\",\n+            // it is some part of the rustdoc invocation.\n+            phase_rustdoc(iter::once(first).chain(args));\n+        }\n     }\n }"}, {"sha": "8bef9d1291a90eb9da8b7514106487fbdd4cc31a", "filename": "miri", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/17bb2c094634238f34942608930e845cbc15a17f/miri", "raw_url": "https://github.com/rust-lang/rust/raw/17bb2c094634238f34942608930e845cbc15a17f/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=17bb2c094634238f34942608930e845cbc15a17f", "patch": "@@ -131,9 +131,6 @@ export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$LIBDIR $RUSTFLAGS\"\n \n # Build a sysroot and set MIRI_SYSROOT to use it. Arguments are passed to `cargo miri setup`.\n build_sysroot() {\n-    # Build once, for the user to see.\n-    $CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -- miri setup \"$@\"\n-    # Call again, to just set env var.\n     export MIRI_SYSROOT=\"$($CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -q -- miri setup --print-sysroot \"$@\")\"\n }\n "}]}