{"sha": "a64ef7d07d0411315be85a646586cb85eeb9c136", "node_id": "C_kwDOAAsO6NoAKGE2NGVmN2QwN2QwNDExMzE1YmU4NWE2NDY1ODZjYjg1ZWViOWMxMzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T10:20:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T10:20:58Z"}, "message": "Auto merge of #100754 - davidtwco:translation-incremental, r=compiler-errors\n\nincremental: migrate diagnostics\n\n- Apply the diagnostic migration lints to more functions on `Session`, namely: `span_warn`, `span_warn_with_code`, `warn` `note_without_error`, `span_note_without_error`, `struct_note_without_error`.\n- Add impls of `IntoDiagnosticArg` for `std::io::Error`, `std::path::Path` and `std::path::PathBuf`.\n- Migrate the `rustc_incremental` crate's diagnostics to translatable diagnostic structs.\n\nr? `@compiler-errors`\ncc #100717", "tree": {"sha": "e4b006e2f97095541ee5ff8b1beab16675e5eb86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4b006e2f97095541ee5ff8b1beab16675e5eb86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a64ef7d07d0411315be85a646586cb85eeb9c136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a64ef7d07d0411315be85a646586cb85eeb9c136", "html_url": "https://github.com/rust-lang/rust/commit/a64ef7d07d0411315be85a646586cb85eeb9c136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a64ef7d07d0411315be85a646586cb85eeb9c136/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4a9a971ca6962533bed01ffbd0c1f6b5250abc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4a9a971ca6962533bed01ffbd0c1f6b5250abc", "html_url": "https://github.com/rust-lang/rust/commit/7c4a9a971ca6962533bed01ffbd0c1f6b5250abc"}, {"sha": "2ff46641a92c27a32db3e0dc94ae86295e6c3277", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff46641a92c27a32db3e0dc94ae86295e6c3277", "html_url": "https://github.com/rust-lang/rust/commit/2ff46641a92c27a32db3e0dc94ae86295e6c3277"}], "stats": {"total": 1585, "additions": 1157, "deletions": 428}, "files": [{"sha": "2440f20502ab192674f339842513138c5c4b71a2", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -187,6 +187,12 @@ impl Display for RegionName {\n     }\n }\n \n+impl rustc_errors::IntoDiagnosticArg for RegionName {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     pub(crate) fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n         self.body.source.def_id().expect_local()"}, {"sha": "c71413e8e7c04f96c548b12d354528127a315bf5", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -369,6 +369,8 @@ pub(super) fn dump_mir_results<'tcx>(\n     };\n }\n \n+#[allow(rustc::diagnostic_outside_of_impl)]\n+#[allow(rustc::untranslatable_diagnostic)]\n pub(super) fn dump_annotation<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     body: &Body<'tcx>,"}, {"sha": "13199d03852550687aa595f6f0450f65c4177a23", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::{IntoDiagnosticArg, MultiSpan};\n+use rustc_errors::MultiSpan;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::{GenericArg, Ty};\n use rustc_span::Span;\n@@ -128,18 +128,6 @@ pub(crate) enum LifetimeReturnCategoryErr<'a> {\n     },\n }\n \n-impl IntoDiagnosticArg for &RegionName {\n-    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n-        format!(\"{}\", self).into_diagnostic_arg()\n-    }\n-}\n-\n-impl IntoDiagnosticArg for RegionName {\n-    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n-        format!(\"{}\", self).into_diagnostic_arg()\n-    }\n-}\n-\n #[derive(Subdiagnostic)]\n pub(crate) enum RequireStaticErr {\n     #[note(borrowck_used_impl_require_static)]"}, {"sha": "5ab87feb98b1152ad306dfaac35ab4f66c5ee944", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -200,6 +200,7 @@ unsafe impl Sync for GccContext {}\n impl WriteBackendMethods for GccCodegenBackend {\n     type Module = GccContext;\n     type TargetMachine = ();\n+    type TargetMachineError = ();\n     type ModuleBuffer = ModuleBuffer;\n     type ThinData = ();\n     type ThinBuffer = ThinBuffer;"}, {"sha": "d2e01708a37bc3c53f3ef6773e31dd5aba24081c", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,5 +1,7 @@\n use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n-use crate::errors::DynamicLinkingWithLTO;\n+use crate::errors::{\n+    DynamicLinkingWithLTO, LlvmError, LtoBitcodeFromRlib, LtoDisallowed, LtoDylib,\n+};\n use crate::llvm::{self, build_string};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n@@ -77,15 +79,12 @@ fn prepare_lto(\n         // Make sure we actually can run LTO\n         for crate_type in cgcx.crate_types.iter() {\n             if !crate_type_allows_lto(*crate_type) {\n-                let e = diag_handler.fatal(\n-                    \"lto can only be run for executables, cdylibs and \\\n-                                            static library outputs\",\n-                );\n-                return Err(e);\n+                diag_handler.emit_err(LtoDisallowed);\n+                return Err(FatalError);\n             } else if *crate_type == CrateType::Dylib {\n                 if !cgcx.opts.unstable_opts.dylib_lto {\n-                    return Err(diag_handler\n-                        .fatal(\"lto cannot be used for `dylib` crate type without `-Zdylib-lto`\"));\n+                    diag_handler.emit_err(LtoDylib);\n+                    return Err(FatalError);\n                 }\n             }\n         }\n@@ -127,7 +126,10 @@ fn prepare_lto(\n                         let module = SerializedModule::FromRlib(data.to_vec());\n                         upstream_modules.push((module, CString::new(name).unwrap()));\n                     }\n-                    Err(msg) => return Err(diag_handler.fatal(&msg)),\n+                    Err(e) => {\n+                        diag_handler.emit_err(e);\n+                        return Err(FatalError);\n+                    }\n                 }\n             }\n         }\n@@ -140,7 +142,7 @@ fn prepare_lto(\n     Ok((symbols_below_threshold, upstream_modules))\n }\n \n-fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], String> {\n+fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], LtoBitcodeFromRlib> {\n     let mut len = 0;\n     let data =\n         unsafe { llvm::LLVMRustGetBitcodeSliceFromObjectData(obj.as_ptr(), obj.len(), &mut len) };\n@@ -155,8 +157,9 @@ fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], String> {\n         Ok(bc)\n     } else {\n         assert!(len == 0);\n-        let msg = llvm::last_error().unwrap_or_else(|| \"unknown LLVM error\".to_string());\n-        Err(format!(\"failed to get bitcode from object file for LTO ({})\", msg))\n+        Err(LtoBitcodeFromRlib {\n+            llvm_err: llvm::last_error().unwrap_or_else(|| \"unknown LLVM error\".to_string()),\n+        })\n     }\n }\n \n@@ -328,10 +331,9 @@ fn fat_lto(\n                 });\n             info!(\"linking {:?}\", name);\n             let data = bc_decoded.data();\n-            linker.add(data).map_err(|()| {\n-                let msg = format!(\"failed to load bitcode of module {:?}\", name);\n-                write::llvm_err(diag_handler, &msg)\n-            })?;\n+            linker\n+                .add(data)\n+                .map_err(|()| write::llvm_err(diag_handler, LlvmError::LoadBitcode { name }))?;\n             serialized_bitcode.push(bc_decoded);\n         }\n         drop(linker);\n@@ -489,7 +491,7 @@ fn thin_lto(\n             symbols_below_threshold.as_ptr(),\n             symbols_below_threshold.len() as u32,\n         )\n-        .ok_or_else(|| write::llvm_err(diag_handler, \"failed to prepare thin LTO context\"))?;\n+        .ok_or_else(|| write::llvm_err(diag_handler, LlvmError::PrepareThinLtoContext))?;\n \n         let data = ThinData(data);\n \n@@ -562,8 +564,7 @@ fn thin_lto(\n         // session, overwriting the previous serialized data (if any).\n         if let Some(path) = key_map_path {\n             if let Err(err) = curr_key_map.save_to_file(&path) {\n-                let msg = format!(\"Error while writing ThinLTO key data: {}\", err);\n-                return Err(write::llvm_err(diag_handler, &msg));\n+                return Err(write::llvm_err(diag_handler, LlvmError::WriteThinLtoKey { err }));\n             }\n         }\n \n@@ -689,8 +690,7 @@ pub unsafe fn optimize_thin_module(\n \n     let module_name = &thin_module.shared.module_names[thin_module.idx];\n     let tm_factory_config = TargetMachineFactoryConfig::new(cgcx, module_name.to_str().unwrap());\n-    let tm =\n-        (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, &e))?;\n+    let tm = (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, e))?;\n \n     // Right now the implementation we've got only works over serialized\n     // modules, so we create a fresh new LLVM context and parse the module\n@@ -717,8 +717,7 @@ pub unsafe fn optimize_thin_module(\n         let mut cu2 = ptr::null_mut();\n         llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n         if !cu2.is_null() {\n-            let msg = \"multiple source DICompileUnits found\";\n-            return Err(write::llvm_err(&diag_handler, msg));\n+            return Err(write::llvm_err(&diag_handler, LlvmError::MultipleSourceDiCompileUnit));\n         }\n \n         // Up next comes the per-module local analyses that we do for Thin LTO.\n@@ -733,8 +732,7 @@ pub unsafe fn optimize_thin_module(\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_rename\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod, target) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n         }\n@@ -744,8 +742,7 @@ pub unsafe fn optimize_thin_module(\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_thin_lto_resolve_weak\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n         }\n@@ -755,8 +752,7 @@ pub unsafe fn optimize_thin_module(\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_thin_lto_internalize\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n         }\n@@ -765,8 +761,7 @@ pub unsafe fn optimize_thin_module(\n             let _timer =\n                 cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_import\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod, target) {\n-                let msg = \"failed to prepare thin LTO module\";\n-                return Err(write::llvm_err(&diag_handler, msg));\n+                return Err(write::llvm_err(&diag_handler, LlvmError::PrepareThinLtoModule));\n             }\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n         }\n@@ -886,11 +881,7 @@ pub fn parse_module<'a>(\n     diag_handler: &Handler,\n ) -> Result<&'a llvm::Module, FatalError> {\n     unsafe {\n-        llvm::LLVMRustParseBitcodeForLTO(cx, data.as_ptr(), data.len(), name.as_ptr()).ok_or_else(\n-            || {\n-                let msg = \"failed to parse bitcode for LTO module\";\n-                write::llvm_err(diag_handler, msg)\n-            },\n-        )\n+        llvm::LLVMRustParseBitcodeForLTO(cx, data.as_ptr(), data.len(), name.as_ptr())\n+            .ok_or_else(|| write::llvm_err(diag_handler, LlvmError::ParseBitcode))\n     }\n }"}, {"sha": "38f8733763dfa9200bef4e06a03b2d07de56395b", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -5,6 +5,9 @@ use crate::back::profiling::{\n use crate::base;\n use crate::common;\n use crate::consts;\n+use crate::errors::{\n+    CopyBitcode, FromLlvmDiag, FromLlvmOptimizationDiag, LlvmError, WithLlvmError, WriteBytecode,\n+};\n use crate::llvm::{self, DiagnosticInfo, PassManager};\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -37,10 +40,10 @@ use std::slice;\n use std::str;\n use std::sync::Arc;\n \n-pub fn llvm_err(handler: &rustc_errors::Handler, msg: &str) -> FatalError {\n+pub fn llvm_err<'a>(handler: &rustc_errors::Handler, err: LlvmError<'a>) -> FatalError {\n     match llvm::last_error() {\n-        Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n-        None => handler.fatal(msg),\n+        Some(llvm_err) => handler.emit_almost_fatal(WithLlvmError(err, llvm_err)),\n+        None => handler.emit_almost_fatal(err),\n     }\n }\n \n@@ -85,10 +88,9 @@ pub fn write_output_file<'ll>(\n             }\n         }\n \n-        result.into_result().map_err(|()| {\n-            let msg = format!(\"could not write output to {}\", output.display());\n-            llvm_err(handler, &msg)\n-        })\n+        result\n+            .into_result()\n+            .map_err(|()| llvm_err(handler, LlvmError::WriteOutput { path: output }))\n     }\n }\n \n@@ -98,7 +100,7 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n     // system/tcx is set up.\n     let features = llvm_util::global_llvm_features(sess, false);\n     target_machine_factory(sess, config::OptLevel::No, &features)(config)\n-        .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n+        .unwrap_or_else(|err| llvm_err(sess.diagnostic(), err).raise())\n }\n \n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n@@ -117,7 +119,7 @@ pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut ll\n         tcx.backend_optimization_level(()),\n         tcx.global_backend_features(()),\n     )(config)\n-    .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n+    .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), err).raise())\n }\n \n pub fn to_llvm_opt_settings(\n@@ -240,9 +242,7 @@ pub fn target_machine_factory(\n             )\n         };\n \n-        tm.ok_or_else(|| {\n-            format!(\"Could not create LLVM TargetMachine for triple: {}\", triple.to_str().unwrap())\n-        })\n+        tm.ok_or_else(|| LlvmError::CreateTargetMachine { triple: triple.clone() })\n     })\n }\n \n@@ -355,25 +355,28 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n             };\n \n             if enabled {\n-                diag_handler.note_without_error(&format!(\n-                    \"{}:{}:{}: {}: {}\",\n-                    opt.filename, opt.line, opt.column, opt.pass_name, opt.message,\n-                ));\n+                diag_handler.emit_note(FromLlvmOptimizationDiag {\n+                    filename: &opt.filename,\n+                    line: opt.line,\n+                    column: opt.column,\n+                    pass_name: &opt.pass_name,\n+                    message: &opt.message,\n+                });\n             }\n         }\n         llvm::diagnostic::PGO(diagnostic_ref) | llvm::diagnostic::Linker(diagnostic_ref) => {\n-            let msg = llvm::build_string(|s| {\n+            let message = llvm::build_string(|s| {\n                 llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n             })\n             .expect(\"non-UTF8 diagnostic\");\n-            diag_handler.warn(&msg);\n+            diag_handler.emit_warning(FromLlvmDiag { message });\n         }\n         llvm::diagnostic::Unsupported(diagnostic_ref) => {\n-            let msg = llvm::build_string(|s| {\n+            let message = llvm::build_string(|s| {\n                 llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n             })\n             .expect(\"non-UTF8 diagnostic\");\n-            diag_handler.err(&msg);\n+            diag_handler.emit_err(FromLlvmDiag { message });\n         }\n         llvm::diagnostic::UnknownDiagnostic(..) => {}\n     }\n@@ -494,7 +497,7 @@ pub(crate) unsafe fn llvm_optimize(\n         llvm_plugins.as_ptr().cast(),\n         llvm_plugins.len(),\n     );\n-    result.into_result().map_err(|()| llvm_err(diag_handler, \"failed to run LLVM passes\"))\n+    result.into_result().map_err(|()| llvm_err(diag_handler, LlvmError::RunLlvmPasses))\n }\n \n // Unsafe due to LLVM calls.\n@@ -547,8 +550,7 @@ pub(crate) fn link(\n         let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", &*module.name);\n         let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n         linker.add(buffer.data()).map_err(|()| {\n-            let msg = format!(\"failed to serialize module {:?}\", module.name);\n-            llvm_err(diag_handler, &msg)\n+            llvm_err(diag_handler, LlvmError::SerializeModule { name: &module.name })\n         })?;\n     }\n     drop(linker);\n@@ -626,9 +628,8 @@ pub(crate) unsafe fn codegen(\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_bitcode\", &*module.name);\n-                if let Err(e) = fs::write(&bc_out, data) {\n-                    let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n-                    diag_handler.err(&msg);\n+                if let Err(err) = fs::write(&bc_out, data) {\n+                    diag_handler.emit_err(WriteBytecode { path: &bc_out, err });\n                 }\n             }\n \n@@ -678,10 +679,9 @@ pub(crate) unsafe fn codegen(\n                 record_artifact_size(&cgcx.prof, \"llvm_ir\", &out);\n             }\n \n-            result.into_result().map_err(|()| {\n-                let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n-                llvm_err(diag_handler, &msg)\n-            })?;\n+            result\n+                .into_result()\n+                .map_err(|()| llvm_err(diag_handler, LlvmError::WriteIr { path: &out }))?;\n         }\n \n         if config.emit_asm {\n@@ -749,8 +749,8 @@ pub(crate) unsafe fn codegen(\n \n             EmitObj::Bitcode => {\n                 debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-                if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-                    diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+                if let Err(err) = link_or_copy(&bc_out, &obj_out) {\n+                    diag_handler.emit_err(CopyBitcode { err });\n                 }\n \n                 if !config.emit_bc {"}, {"sha": "81072edc475c4a2f2f27890c584cd5c1b35a9174", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 114, "deletions": 9, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,10 +1,11 @@\n use std::borrow::Cow;\n+use std::ffi::CString;\n+use std::path::Path;\n \n-use rustc_errors::fluent;\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_errors::ErrorGuaranteed;\n-use rustc_errors::Handler;\n-use rustc_errors::IntoDiagnostic;\n+use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_errors::{\n+    fluent, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed, Handler, IntoDiagnostic,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n \n@@ -81,10 +82,18 @@ pub(crate) struct DlltoolFailImportLibrary<'a> {\n #[note]\n pub(crate) struct DynamicLinkingWithLTO;\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_fail_parsing_target_machine_config_to_target_machine)]\n-pub(crate) struct FailParsingTargetMachineConfigToTargetMachine {\n-    pub error: String,\n+pub(crate) struct ParseTargetMachineConfig<'a>(pub LlvmError<'a>);\n+\n+impl<EM: EmissionGuarantee> IntoDiagnostic<'_, EM> for ParseTargetMachineConfig<'_> {\n+    fn into_diagnostic(self, sess: &'_ Handler) -> DiagnosticBuilder<'_, EM> {\n+        let diag: DiagnosticBuilder<'_, EM> = self.0.into_diagnostic(sess);\n+        let (message, _) = diag.styled_message().first().expect(\"`LlvmError` with no message\");\n+        let message = sess.eagerly_translate_to_string(message.clone(), diag.args());\n+\n+        let mut diag = sess.struct_diagnostic(fluent::codegen_llvm_parse_target_machine_config);\n+        diag.set_arg(\"error\", message);\n+        diag\n+    }\n }\n \n pub(crate) struct TargetFeatureDisableOrEnable<'a> {\n@@ -110,3 +119,99 @@ impl IntoDiagnostic<'_, ErrorGuaranteed> for TargetFeatureDisableOrEnable<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_lto_disallowed)]\n+pub(crate) struct LtoDisallowed;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_lto_dylib)]\n+pub(crate) struct LtoDylib;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_lto_bitcode_from_rlib)]\n+pub(crate) struct LtoBitcodeFromRlib {\n+    pub llvm_err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum LlvmError<'a> {\n+    #[diag(codegen_llvm_write_output)]\n+    WriteOutput { path: &'a Path },\n+    #[diag(codegen_llvm_target_machine)]\n+    CreateTargetMachine { triple: SmallCStr },\n+    #[diag(codegen_llvm_run_passes)]\n+    RunLlvmPasses,\n+    #[diag(codegen_llvm_serialize_module)]\n+    SerializeModule { name: &'a str },\n+    #[diag(codegen_llvm_write_ir)]\n+    WriteIr { path: &'a Path },\n+    #[diag(codegen_llvm_prepare_thin_lto_context)]\n+    PrepareThinLtoContext,\n+    #[diag(codegen_llvm_load_bitcode)]\n+    LoadBitcode { name: CString },\n+    #[diag(codegen_llvm_write_thinlto_key)]\n+    WriteThinLtoKey { err: std::io::Error },\n+    #[diag(codegen_llvm_multiple_source_dicompileunit)]\n+    MultipleSourceDiCompileUnit,\n+    #[diag(codegen_llvm_prepare_thin_lto_module)]\n+    PrepareThinLtoModule,\n+    #[diag(codegen_llvm_parse_bitcode)]\n+    ParseBitcode,\n+}\n+\n+pub(crate) struct WithLlvmError<'a>(pub LlvmError<'a>, pub String);\n+\n+impl<EM: EmissionGuarantee> IntoDiagnostic<'_, EM> for WithLlvmError<'_> {\n+    fn into_diagnostic(self, sess: &'_ Handler) -> DiagnosticBuilder<'_, EM> {\n+        use LlvmError::*;\n+        let msg_with_llvm_err = match &self.0 {\n+            WriteOutput { .. } => fluent::codegen_llvm_write_output_with_llvm_err,\n+            CreateTargetMachine { .. } => fluent::codegen_llvm_target_machine_with_llvm_err,\n+            RunLlvmPasses => fluent::codegen_llvm_run_passes_with_llvm_err,\n+            SerializeModule { .. } => fluent::codegen_llvm_serialize_module_with_llvm_err,\n+            WriteIr { .. } => fluent::codegen_llvm_write_ir_with_llvm_err,\n+            PrepareThinLtoContext => fluent::codegen_llvm_prepare_thin_lto_context_with_llvm_err,\n+            LoadBitcode { .. } => fluent::codegen_llvm_load_bitcode_with_llvm_err,\n+            WriteThinLtoKey { .. } => fluent::codegen_llvm_write_thinlto_key_with_llvm_err,\n+            MultipleSourceDiCompileUnit => {\n+                fluent::codegen_llvm_multiple_source_dicompileunit_with_llvm_err\n+            }\n+            PrepareThinLtoModule => fluent::codegen_llvm_prepare_thin_lto_module_with_llvm_err,\n+            ParseBitcode => fluent::codegen_llvm_parse_bitcode_with_llvm_err,\n+        };\n+        let mut diag = self.0.into_diagnostic(sess);\n+        diag.set_primary_message(msg_with_llvm_err);\n+        diag.set_arg(\"llvm_err\", self.1);\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_from_llvm_optimization_diag)]\n+pub(crate) struct FromLlvmOptimizationDiag<'a> {\n+    pub filename: &'a str,\n+    pub line: std::ffi::c_uint,\n+    pub column: std::ffi::c_uint,\n+    pub pass_name: &'a str,\n+    pub message: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_from_llvm_diag)]\n+pub(crate) struct FromLlvmDiag {\n+    pub message: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_write_bytecode)]\n+pub(crate) struct WriteBytecode<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_copy_bitcode)]\n+pub(crate) struct CopyBitcode {\n+    pub err: std::io::Error,\n+}"}, {"sha": "111d14b265cdee055a3c19c370de8b95a8cde699", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -5,11 +5,12 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(extern_types)]\n #![feature(hash_raw_entry)]\n+#![feature(iter_intersperse)]\n #![feature(let_chains)]\n-#![feature(extern_types)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n-#![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -22,7 +23,7 @@ extern crate tracing;\n \n use back::write::{create_informational_target_machine, create_target_machine};\n \n-use errors::FailParsingTargetMachineConfigToTargetMachine;\n+use errors::ParseTargetMachineConfig;\n pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n@@ -169,6 +170,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     type Module = ModuleLlvm;\n     type ModuleBuffer = back::lto::ModuleBuffer;\n     type TargetMachine = &'static mut llvm::TargetMachine;\n+    type TargetMachineError = crate::errors::LlvmError<'static>;\n     type ThinData = back::lto::ThinData;\n     type ThinBuffer = back::lto::ThinBuffer;\n     fn print_pass_timings(&self) {\n@@ -416,8 +418,7 @@ impl ModuleLlvm {\n             let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n-                    handler.emit_err(FailParsingTargetMachineConfigToTargetMachine { error: e });\n-                    return Err(FatalError);\n+                    return Err(handler.emit_almost_fatal(ParseTargetMachineConfig(e)));\n                 }\n             };\n "}, {"sha": "8508ab87532c27e1478abe7f82d4523f5d9554e4", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -305,8 +305,12 @@ impl TargetMachineFactoryConfig {\n }\n \n pub type TargetMachineFactoryFn<B> = Arc<\n-    dyn Fn(TargetMachineFactoryConfig) -> Result<<B as WriteBackendMethods>::TargetMachine, String>\n-        + Send\n+    dyn Fn(\n+            TargetMachineFactoryConfig,\n+        ) -> Result<\n+            <B as WriteBackendMethods>::TargetMachine,\n+            <B as WriteBackendMethods>::TargetMachineError,\n+        > + Send\n         + Sync,\n >;\n "}, {"sha": "9826256a4c5d5a8117b53e0e0ee839d20b65b5e5", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -8,6 +8,7 @@ use rustc_middle::dep_graph::WorkProduct;\n pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type Module: Send + Sync;\n     type TargetMachine;\n+    type TargetMachineError;\n     type ModuleBuffer: ModuleBufferMethods;\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;"}, {"sha": "02e0b042ad2631eadad94771b4a2dfab2c2defd4", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -43,7 +43,6 @@ use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n use rustc_target::json::ToJson;\n \n-use std::borrow::Cow;\n use std::cmp::max;\n use std::env;\n use std::ffi::OsString;\n@@ -1205,29 +1204,20 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         handler.emit_diagnostic(&mut d);\n     }\n \n-    let mut xs: Vec<Cow<'static, str>> = vec![\n-        \"the compiler unexpectedly panicked. this is a bug.\".into(),\n-        format!(\"we would appreciate a bug report: {bug_report_url}\").into(),\n-        format!(\n-            \"rustc {} running on {}\",\n-            util::version_str!().unwrap_or(\"unknown_version\"),\n-            config::host_triple()\n-        )\n-        .into(),\n-    ];\n+    handler.emit_note(session_diagnostics::Ice);\n+    handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n+    handler.emit_note(session_diagnostics::IceVersion {\n+        version: util::version_str!().unwrap_or(\"unknown_version\"),\n+        triple: config::host_triple(),\n+    });\n \n     if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-        xs.push(format!(\"compiler flags: {}\", flags.join(\" \")).into());\n-\n+        handler.emit_note(session_diagnostics::IceFlags { flags: flags.join(\" \") });\n         if excluded_cargo_defaults {\n-            xs.push(\"some of the compiler flags provided by cargo are hidden\".into());\n+            handler.emit_note(session_diagnostics::IceExcludeCargoDefaults);\n         }\n     }\n \n-    for note in &xs {\n-        handler.note_without_error(note.as_ref());\n-    }\n-\n     // If backtraces are enabled, also print the query stack\n     let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n "}, {"sha": "a7aef9cbc2c8af5b00bae47a92920e10825248d7", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -38,3 +38,30 @@ pub(crate) struct UnprettyDumpFail {\n     pub path: String,\n     pub err: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice)]\n+pub(crate) struct Ice;\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_bug_report)]\n+pub(crate) struct IceBugReport<'a> {\n+    pub bug_report_url: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_version)]\n+pub(crate) struct IceVersion<'a> {\n+    pub version: &'a str,\n+    pub triple: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_flags)]\n+pub(crate) struct IceFlags {\n+    pub flags: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(driver_ice_exclude_cargo_defaults)]\n+pub(crate) struct IceExcludeCargoDefaults;"}, {"sha": "e5df417370bb9030abf8ad18fe765b4bc0f265fc", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -39,5 +39,51 @@ codegen_llvm_dynamic_linking_with_lto =\n     cannot prefer dynamic linking when performing LTO\n     .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n \n-codegen_llvm_fail_parsing_target_machine_config_to_target_machine =\n+codegen_llvm_parse_target_machine_config =\n     failed to parse target machine config to target machine: {$error}\n+\n+codegen_llvm_lto_disallowed = lto can only be run for executables, cdylibs and static library outputs\n+\n+codegen_llvm_lto_dylib = lto cannot be used for `dylib` crate type without `-Zdylib-lto`\n+\n+codegen_llvm_lto_bitcode_from_rlib = failed to get bitcode from object file for LTO ({$llvm_err})\n+\n+codegen_llvm_write_output = could not write output to {$path}\n+codegen_llvm_write_output_with_llvm_err = could not write output to {$path}: {$llvm_err}\n+\n+codegen_llvm_target_machine = could not create LLVM TargetMachine for triple: {$triple}\n+codegen_llvm_target_machine_with_llvm_err = could not create LLVM TargetMachine for triple: {$triple}: {$llvm_err}\n+\n+codegen_llvm_run_passes = failed to run LLVM passes\n+codegen_llvm_run_passes_with_llvm_err = failed to run LLVM passes: {$llvm_err}\n+\n+codegen_llvm_serialize_module = failed to serialize module {$name}\n+codegen_llvm_serialize_module_with_llvm_err = failed to serialize module {$name}: {$llvm_err}\n+\n+codegen_llvm_write_ir = failed to write LLVM IR to {$path}\n+codegen_llvm_write_ir_with_llvm_err = failed to write LLVM IR to {$path}: {$llvm_err}\n+\n+codegen_llvm_prepare_thin_lto_context = failed to prepare thin LTO context\n+codegen_llvm_prepare_thin_lto_context_with_llvm_err = failed to prepare thin LTO context: {$llvm_err}\n+\n+codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n+codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}\n+\n+codegen_llvm_write_thinlto_key = error while writing ThinLTO key data: {$err}\n+codegen_llvm_write_thinlto_key_with_llvm_err = error while writing ThinLTO key data: {$err}: {$llvm_err}\n+\n+codegen_llvm_multiple_source_dicompileunit = multiple source DICompileUnits found\n+codegen_llvm_multiple_source_dicompileunit_with_llvm_err = multiple source DICompileUnits found: {$llvm_err}\n+\n+codegen_llvm_prepare_thin_lto_module = failed to prepare thin LTO module\n+codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO module: {$llvm_err}\n+\n+codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n+codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n+\n+codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name}: {$message}\n+codegen_llvm_from_llvm_diag = {$message}\n+\n+codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}\n+\n+codegen_llvm_copy_bitcode = failed to copy bitcode to object file: {$err}"}, {"sha": "79ffc82c6c67d096d0f51b3b3030f6263d39ce85", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -11,3 +11,9 @@ driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version\n driver_rlink_no_a_file = rlink must be a file\n \n driver_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n+\n+driver_ice = the compiler unexpectedly panicked. this is a bug.\n+driver_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n+driver_ice_version = rustc {$version} running on {$triple}\n+driver_ice_flags = compiler flags: {$flags}\n+driver_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden"}, {"sha": "dbd80954382dbbaf52c9f287da7748d7b8c63fc8", "filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -127,3 +127,5 @@ expand_module_file_not_found =\n expand_module_multiple_candidates =\n     file for module `{$name}` found at both \"{$default_path}\" and \"{$secondary_path}\"\n     .help = delete or rename one of them to remove the ambiguity\n+\n+expand_trace_macro = trace_macro"}, {"sha": "4852ee0d9595cce228848c111ade539948223938", "filename": "compiler/rustc_error_messages/locales/en-US/incremental.ftl", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fincremental.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fincremental.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fincremental.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -0,0 +1,118 @@\n+incremental_unrecognized_depnode = unrecognized `DepNode` variant: {$name}\n+\n+incremental_missing_depnode = missing `DepNode` variant\n+\n+incremental_missing_if_this_changed = no `#[rustc_if_this_changed]` annotation detected\n+\n+incremental_no_path = no path from `{$source}` to `{$target}`\n+\n+incremental_ok = OK\n+\n+incremental_unknown_reuse_kind = unknown cgu-reuse-kind `{$kind}` specified\n+\n+incremental_missing_query_depgraph =\n+    found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\n+\n+incremental_malformed_cgu_name =\n+    found malformed codegen unit name `{$user_path}`. codegen units names must always start with the name of the crate (`{$crate_name}` in this case).\n+\n+incremental_no_module_named =\n+    no module named `{$user_path}` (mangled: {$cgu_name}). available modules: {$cgu_names}\n+\n+incremental_field_associated_value_expected = associated value expected for `{$name}`\n+\n+incremental_no_field = no field `{$name}`\n+\n+incremental_assertion_auto =\n+    `except` specified DepNodes that can not be affected for \\\"{$name}\\\": \\\"{$e}\\\"\n+\n+incremental_undefined_clean_dirty_assertions_item =\n+    clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}\n+\n+incremental_undefined_clean_dirty_assertions =\n+    clean/dirty auto-assertions not yet defined for {$kind}\n+\n+incremental_repeated_depnode_label = dep-node label `{$label}` is repeated\n+\n+incremental_unrecognized_depnode_label = dep-node label `{$label}` not recognized\n+\n+incremental_not_dirty = `{$dep_node_str}` should be dirty but is not\n+\n+incremental_not_clean = `{$dep_node_str}` should be clean but is not\n+\n+incremental_not_loaded = `{$dep_node_str}` should have been loaded from disk but it was not\n+\n+incremental_unknown_item = unknown item `{$name}`\n+\n+incremental_no_cfg = no cfg attribute\n+\n+incremental_associated_value_expected_for = associated value expected for `{$ident}`\n+\n+incremental_associated_value_expected = expected an associated value\n+\n+incremental_unchecked_clean = found unchecked `#[rustc_clean]` attribute\n+\n+incremental_delete_old = unable to delete old {$name} at `{$path}`: {$err}\n+\n+incremental_create_new = failed to create {$name} at `{$path}`: {$err}\n+\n+incremental_write_new = failed to write {$name} to `{$path}`: {$err}\n+\n+incremental_canonicalize_path = incremental compilation: error canonicalizing path `{$path}`: {$err}\n+\n+incremental_create_incr_comp_dir =\n+    could not create incremental compilation {$tag} directory `{$path}`: {$err}\n+\n+incremental_create_lock =\n+    incremental compilation: could not create session directory lock file: {$lock_err}\n+incremental_lock_unsupported =\n+    the filesystem for the incremental path at {$session_dir} does not appear to support locking, consider changing the incremental path to a filesystem that supports locking or disable incremental compilation\n+incremental_cargo_help_1 =\n+    incremental compilation can be disabled by setting the environment variable CARGO_INCREMENTAL=0 (see https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\n+incremental_cargo_help_2 =\n+    the entire build directory can be changed to a different filesystem by setting the environment variable CARGO_TARGET_DIR to a different path (see https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\n+\n+incremental_delete_lock =\n+    error deleting lock file for incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_hard_link_failed =\n+    hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `{$path}`\n+\n+incremental_delete_partial = failed to delete partly initialized session dir `{$path}`: {$err}\n+\n+incremental_delete_full = error deleting incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_finalize = error finalizing incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_invalid_gc_failed =\n+    failed to garbage collect invalid incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_finalized_gc_failed =\n+    failed to garbage collect finalized incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_session_gc_failed =\n+    failed to garbage collect incremental compilation session directory `{$path}`: {$err}\n+\n+incremental_assert_not_loaded =\n+    we asserted that the incremental cache should not be loaded, but it was loaded\n+\n+incremental_assert_loaded =\n+    we asserted that an existing incremental cache directory should be successfully loaded, but it was not\n+\n+incremental_delete_incompatible =\n+    failed to delete invalidated or incompatible incremental compilation session directory contents `{$path}`: {$err}\n+\n+incremental_load_dep_graph = could not load dep-graph from `{$path}`: {$err}\n+\n+incremental_decode_incr_cache = could not decode incremental cache: {$err}\n+\n+incremental_write_dep_graph = failed to write dependency graph to `{$path}`: {$err}\n+\n+incremental_move_dep_graph = failed to move dependency graph from `{$from}` to `{$to}`: {$err}\n+\n+incremental_create_dep_graph = failed to create dependency graph at `{$path}`: {$err}\n+\n+incremental_copy_workproduct_to_cache =\n+    error copying object file `{$from}` to incremental directory as `{$to}`: {$err}\n+\n+incremental_delete_workproduct = file-system error deleting outdated file `{$path}`: {$err}"}, {"sha": "a7bc0e7af1fe9e2a7ed8c3f349ad68171b1d3e35", "filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -44,3 +44,13 @@ interface_failed_writing_file =\n \n interface_proc_macro_crate_panic_abort =\n     building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n+\n+interface_unsupported_crate_type_for_target =\n+    dropping unsupported crate type `{$crate_type}` for target `{$target_triple}`\n+\n+interface_multiple_output_types_adaption =\n+    due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\n+\n+interface_ignoring_extra_filename = ignoring -C extra-filename flag due to -o flag\n+\n+interface_ignoring_out_dir = ignoring --out-dir flag due to -o flag"}, {"sha": "6cea6a603f336564c77b24dc8930eeaa48fc9ca7", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -24,3 +24,9 @@ monomorphize_large_assignments =\n \n monomorphize_couldnt_dump_mono_stats =\n     unexpected error occurred while dumping monomorphization stats: {$error}\n+\n+monomorphize_encountered_error_while_instantiating =\n+    the above error was encountered while instantiating `{$formatted_item}`\n+\n+monomorphize_unknown_cgu_collection_mode =\n+    unknown codegen-item collection mode '{$mode}', falling back to 'lazy' mode"}, {"sha": "6ebb188288f0016e604ebfcd3b1ce207fdc2e14c", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -731,3 +731,5 @@ passes_proc_macro_missing_args = mismatched {$kind} signature\n passes_proc_macro_invalid_abi = proc macro functions may not be `extern \"{$abi}\"`\n \n passes_proc_macro_unsafe = proc macro functions may not be `unsafe`\n+\n+passes_skipping_const_checks = skipping const checks"}, {"sha": "5984c201af0d01ba0a70e21985d0deff0a40c54e", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -89,3 +89,5 @@ session_int_literal_too_large = integer literal is too large\n \n session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n     .help = valid widths are 8, 16, 32, 64 and 128\n+\n+session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}"}, {"sha": "1882d4b698e61c481462ce5be8b8ed09d5f13411", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -52,6 +52,7 @@ fluent_messages! {\n     expand => \"../locales/en-US/expand.ftl\",\n     hir_analysis => \"../locales/en-US/hir_analysis.ftl\",\n     hir_typeck => \"../locales/en-US/hir_typeck.ftl\",\n+    incremental => \"../locales/en-US/incremental.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n     lint => \"../locales/en-US/lint.ftl\","}, {"sha": "df949e46fbde507e9bdeee514e4d979fca56c7de", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1051,6 +1051,7 @@ impl Diagnostic {\n     ) -> (\n         &Level,\n         &[(DiagnosticMessage, Style)],\n+        Vec<(&Cow<'static, str>, &DiagnosticArgValue<'static>)>,\n         &Option<DiagnosticId>,\n         &MultiSpan,\n         &Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n@@ -1059,6 +1060,7 @@ impl Diagnostic {\n         (\n             &self.level,\n             &self.message,\n+            self.args().collect(),\n             &self.code,\n             &self.span,\n             &self.suggestions,"}, {"sha": "c9d662ad43fe50ed08359748f921deec6c1e11e0", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -408,6 +408,59 @@ impl EmissionGuarantee for ! {\n     }\n }\n \n+impl<'a> DiagnosticBuilder<'a, rustc_span::fatal_error::FatalError> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n+    pub(crate) fn new_almost_fatal(\n+        handler: &'a Handler,\n+        message: impl Into<DiagnosticMessage>,\n+    ) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n+        Self::new_diagnostic_almost_fatal(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_almost_fatal(\n+        handler: &'a Handler,\n+        diagnostic: Diagnostic,\n+    ) -> Self {\n+        debug!(\"Created new diagnostic\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for rustc_span::fatal_error::FatalError {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+        // Then fatally error..\n+        rustc_span::fatal_error::FatalError\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_almost_fatal(handler, msg)\n+    }\n+}\n+\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to"}, {"sha": "7a94ce3777a29c8337b3439a50ce8e376ddc3cb6", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -36,6 +36,12 @@ impl<'a, T: fmt::Display> From<&'a T> for DiagnosticArgFromDisplay<'a> {\n     }\n }\n \n+impl<'a, T: Clone + IntoDiagnosticArg> IntoDiagnosticArg for &'a T {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.clone().into_diagnostic_arg()\n+    }\n+}\n+\n macro_rules! into_diagnostic_arg_using_display {\n     ($( $ty:ty ),+ $(,)?) => {\n         $(\n@@ -153,12 +159,6 @@ impl IntoDiagnosticArg for ast::Path {\n     }\n }\n \n-impl IntoDiagnosticArg for &ast::Path {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(pprust::path_to_string(self)))\n-    }\n-}\n-\n impl IntoDiagnosticArg for ast::token::Token {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(pprust::token_to_string(&self))\n@@ -177,6 +177,18 @@ impl IntoDiagnosticArg for type_ir::FloatTy {\n     }\n }\n \n+impl IntoDiagnosticArg for std::ffi::CString {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string_lossy().into_owned()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for rustc_data_structures::small_c_str::SmallCStr {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string_lossy().into_owned()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(self.to_cmd_flag()))"}, {"sha": "ec04e865d53b105ae1ddf3101f10c511889e6369", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -617,22 +617,24 @@ impl Handler {\n         }\n     }\n \n-    /// Translate `message` eagerly with `args`.\n+    /// Translate `message` eagerly with `args` to `SubdiagnosticMessage::Eager`.\n     pub fn eagerly_translate<'a>(\n         &self,\n         message: DiagnosticMessage,\n         args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n     ) -> SubdiagnosticMessage {\n+        SubdiagnosticMessage::Eager(self.eagerly_translate_to_string(message, args))\n+    }\n+\n+    /// Translate `message` eagerly with `args` to `String`.\n+    pub fn eagerly_translate_to_string<'a>(\n+        &self,\n+        message: DiagnosticMessage,\n+        args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n+    ) -> String {\n         let inner = self.inner.borrow();\n         let args = crate::translation::to_fluent_args(args);\n-        SubdiagnosticMessage::Eager(\n-            inner\n-                .emitter\n-                .translate_message(&message, &args)\n-                .map_err(Report::new)\n-                .unwrap()\n-                .to_string(),\n-        )\n+        inner.emitter.translate_message(&message, &args).map_err(Report::new).unwrap().to_string()\n     }\n \n     // This is here to not allow mutation of flags;\n@@ -1010,6 +1012,7 @@ impl Handler {\n     }\n \n     #[track_caller]\n+    #[rustc_lint_diagnostics]\n     pub fn span_note_without_error(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -1019,6 +1022,7 @@ impl Handler {\n     }\n \n     #[track_caller]\n+    #[rustc_lint_diagnostics]\n     pub fn span_note_diag(\n         &self,\n         span: Span,\n@@ -1030,19 +1034,23 @@ impl Handler {\n     }\n \n     // NOTE: intentionally doesn't raise an error so rustc_codegen_ssa only reports fatal errors in the main thread\n+    #[rustc_lint_diagnostics]\n     pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.inner.borrow_mut().err(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n     pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         let mut db = DiagnosticBuilder::new(self, Warning(None), msg);\n         db.emit();\n     }\n \n+    #[rustc_lint_diagnostics]\n     pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n@@ -1059,6 +1067,7 @@ impl Handler {\n     pub fn has_errors(&self) -> Option<ErrorGuaranteed> {\n         if self.inner.borrow().has_errors() { Some(ErrorGuaranteed(())) } else { None }\n     }\n+\n     pub fn has_errors_or_lint_errors(&self) -> Option<ErrorGuaranteed> {\n         if self.inner.borrow().has_errors_or_lint_errors() {\n             Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n@@ -1132,6 +1141,20 @@ impl Handler {\n         self.create_warning(warning).emit()\n     }\n \n+    pub fn create_almost_fatal<'a>(\n+        &'a self,\n+        fatal: impl IntoDiagnostic<'a, FatalError>,\n+    ) -> DiagnosticBuilder<'a, FatalError> {\n+        fatal.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_almost_fatal<'a>(\n+        &'a self,\n+        fatal: impl IntoDiagnostic<'a, FatalError>,\n+    ) -> FatalError {\n+        self.create_almost_fatal(fatal).emit()\n+    }\n+\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,\n@@ -1157,6 +1180,17 @@ impl Handler {\n         self.create_bug(bug).emit()\n     }\n \n+    pub fn emit_note<'a>(&'a self, note: impl IntoDiagnostic<'a, Noted>) -> Noted {\n+        self.create_note(note).emit()\n+    }\n+\n+    pub fn create_note<'a>(\n+        &'a self,\n+        note: impl IntoDiagnostic<'a, Noted>,\n+    ) -> DiagnosticBuilder<'a, Noted> {\n+        note.into_diagnostic(self)\n+    }\n+\n     fn emit_diag_at_span(\n         &self,\n         mut diag: Diagnostic,"}, {"sha": "5a48473d5b07c90646808d0daa86112b2a124f21", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -4,7 +4,7 @@ use crate::errors::{\n     ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n     AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n     MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n-    ResolveRelativePath, TakesNoArguments,\n+    ResolveRelativePath, TakesNoArguments, TraceMacro,\n };\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n@@ -1142,8 +1142,8 @@ impl<'a> ExtCtxt<'a> {\n         self.sess.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n     pub fn trace_macros_diag(&mut self) {\n-        for (sp, notes) in self.expansions.iter() {\n-            let mut db = self.sess.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n+        for (span, notes) in self.expansions.iter() {\n+            let mut db = self.sess.parse_sess.create_note(TraceMacro { span: *span });\n             for note in notes {\n                 db.note(note);\n             }"}, {"sha": "9b9697ab13d26a767e4cf5c922ed7caf3a0192f4", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -368,3 +368,10 @@ pub(crate) struct ModuleMultipleCandidates {\n     pub default_path: String,\n     pub secondary_path: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_trace_macro)]\n+pub struct TraceMacro {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "22bd12f2e63616cb48508fc621d6e417ecffb0ee", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -33,6 +33,7 @@\n //! fn baz() { foo(); }\n //! ```\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{Direction, NodeIndex, INCOMING, OUTGOING};\n@@ -133,12 +134,10 @@ impl<'tcx> IfThisChanged<'tcx> {\n                     Some(n) => {\n                         match DepNode::from_label_string(self.tcx, n.as_str(), def_path_hash) {\n                             Ok(n) => n,\n-                            Err(()) => {\n-                                self.tcx.sess.span_fatal(\n-                                    attr.span,\n-                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n-                                );\n-                            }\n+                            Err(()) => self.tcx.sess.emit_fatal(errors::UnrecognizedDepNode {\n+                                span: attr.span,\n+                                name: n,\n+                            }),\n                         }\n                     }\n                 };\n@@ -149,16 +148,14 @@ impl<'tcx> IfThisChanged<'tcx> {\n                     Some(n) => {\n                         match DepNode::from_label_string(self.tcx, n.as_str(), def_path_hash) {\n                             Ok(n) => n,\n-                            Err(()) => {\n-                                self.tcx.sess.span_fatal(\n-                                    attr.span,\n-                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n-                                );\n-                            }\n+                            Err(()) => self.tcx.sess.emit_fatal(errors::UnrecognizedDepNode {\n+                                span: attr.span,\n+                                name: n,\n+                            }),\n                         }\n                     }\n                     None => {\n-                        self.tcx.sess.span_fatal(attr.span, \"missing DepNode variant\");\n+                        self.tcx.sess.emit_fatal(errors::MissingDepNode { span: attr.span });\n                     }\n                 };\n                 self.then_this_would_need.push((\n@@ -204,7 +201,7 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n         for &(target_span, _, _, _) in then_this_would_need {\n-            tcx.sess.span_err(target_span, \"no `#[rustc_if_this_changed]` annotation detected\");\n+            tcx.sess.emit_err(errors::MissingIfThisChanged { span: target_span });\n         }\n         return;\n     }\n@@ -213,16 +210,13 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n             let dependents = query.transitive_predecessors(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n                 if !dependents.contains(&target_dep_node) {\n-                    tcx.sess.span_err(\n-                        target_span,\n-                        &format!(\n-                            \"no path from `{}` to `{}`\",\n-                            tcx.def_path_str(source_def_id),\n-                            target_pass\n-                        ),\n-                    );\n+                    tcx.sess.emit_err(errors::NoPath {\n+                        span: target_span,\n+                        source: tcx.def_path_str(source_def_id),\n+                        target: *target_pass,\n+                    });\n                 } else {\n-                    tcx.sess.span_err(target_span, \"OK\");\n+                    tcx.sess.emit_err(errors::Ok { span: target_span });\n                 }\n             }\n         }"}, {"sha": "2968a0e1203a991028a11b9006e7f54e28c74574", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -22,6 +22,7 @@\n //! allows for doing a more fine-grained check to see if pre- or post-lto data\n //! was re-used.\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -66,21 +67,17 @@ impl<'tcx> AssertModuleSource<'tcx> {\n                 sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n                 sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n                 other => {\n-                    self.tcx.sess.span_fatal(\n-                        attr.span,\n-                        &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n-                    );\n+                    self.tcx\n+                        .sess\n+                        .emit_fatal(errors::UnknownReuseKind { span: attr.span, kind: other });\n                 }\n             }\n         } else {\n             return;\n         };\n \n         if !self.tcx.sess.opts.unstable_opts.query_dep_graph {\n-            self.tcx.sess.span_fatal(\n-                attr.span,\n-                \"found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\",\n-            );\n+            self.tcx.sess.emit_fatal(errors::MissingQueryDepGraph { span: attr.span });\n         }\n \n         if !self.check_config(attr) {\n@@ -92,13 +89,11 @@ impl<'tcx> AssertModuleSource<'tcx> {\n         let crate_name = self.tcx.crate_name(LOCAL_CRATE).to_string();\n \n         if !user_path.starts_with(&crate_name) {\n-            let msg = format!(\n-                \"Found malformed codegen unit name `{}`. \\\n-                Codegen units names must always start with the name of the \\\n-                crate (`{}` in this case).\",\n-                user_path, crate_name\n-            );\n-            self.tcx.sess.span_fatal(attr.span, &msg);\n+            self.tcx.sess.emit_fatal(errors::MalformedCguName {\n+                span: attr.span,\n+                user_path,\n+                crate_name,\n+            });\n         }\n \n         // Split of the \"special suffix\" if there is one.\n@@ -125,15 +120,12 @@ impl<'tcx> AssertModuleSource<'tcx> {\n             let mut cgu_names: Vec<&str> =\n                 self.available_cgus.iter().map(|cgu| cgu.as_str()).collect();\n             cgu_names.sort();\n-            self.tcx.sess.span_err(\n-                attr.span,\n-                &format!(\n-                    \"no module named `{}` (mangled: {}). Available modules: {}\",\n-                    user_path,\n-                    cgu_name,\n-                    cgu_names.join(\", \")\n-                ),\n-            );\n+            self.tcx.sess.emit_err(errors::NoModuleNamed {\n+                span: attr.span,\n+                user_path,\n+                cgu_name,\n+                cgu_names: cgu_names.join(\", \"),\n+            });\n         }\n \n         self.tcx.sess.cgu_reuse_tracker.set_expectation(\n@@ -151,15 +143,15 @@ impl<'tcx> AssertModuleSource<'tcx> {\n                 if let Some(value) = item.value_str() {\n                     return value;\n                 } else {\n-                    self.tcx.sess.span_fatal(\n-                        item.span(),\n-                        &format!(\"associated value expected for `{}`\", name),\n-                    );\n+                    self.tcx.sess.emit_fatal(errors::FieldAssociatedValueExpected {\n+                        span: item.span(),\n+                        name,\n+                    });\n                 }\n             }\n         }\n \n-        self.tcx.sess.span_fatal(attr.span, &format!(\"no field `{}`\", name));\n+        self.tcx.sess.emit_fatal(errors::NoField { span: attr.span, name });\n     }\n \n     /// Scan for a `cfg=\"foo\"` attribute and check whether we have a"}, {"sha": "deb8767836543470144a8c3952ef6ab07e8f63a9", "filename": "compiler/rustc_incremental/src/errors.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -0,0 +1,364 @@\n+use rustc_macros::Diagnostic;\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+use std::path::{Path, PathBuf};\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unrecognized_depnode)]\n+pub struct UnrecognizedDepNode {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_missing_depnode)]\n+pub struct MissingDepNode {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_missing_if_this_changed)]\n+pub struct MissingIfThisChanged {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_ok)]\n+pub struct Ok {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_path)]\n+pub struct NoPath {\n+    #[primary_span]\n+    pub span: Span,\n+    pub target: Symbol,\n+    pub source: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unknown_reuse_kind)]\n+pub struct UnknownReuseKind {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_missing_query_depgraph)]\n+pub struct MissingQueryDepGraph {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_malformed_cgu_name)]\n+pub struct MalformedCguName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub user_path: String,\n+    pub crate_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_module_named)]\n+pub struct NoModuleNamed<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub user_path: &'a str,\n+    pub cgu_name: Symbol,\n+    pub cgu_names: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_field_associated_value_expected)]\n+pub struct FieldAssociatedValueExpected {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_field)]\n+pub struct NoField {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_assertion_auto)]\n+pub struct AssertionAuto<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: &'a str,\n+    pub e: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_undefined_clean_dirty_assertions_item)]\n+pub struct UndefinedCleanDirtyItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_undefined_clean_dirty_assertions)]\n+pub struct UndefinedCleanDirty {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_repeated_depnode_label)]\n+pub struct RepeatedDepNodeLabel<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub label: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unrecognized_depnode_label)]\n+pub struct UnrecognizedDepNodeLabel<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub label: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_not_dirty)]\n+pub struct NotDirty<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dep_node_str: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_not_clean)]\n+pub struct NotClean<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dep_node_str: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_not_loaded)]\n+pub struct NotLoaded<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dep_node_str: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unknown_item)]\n+pub struct UnknownItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_no_cfg)]\n+pub struct NoCfg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_associated_value_expected_for)]\n+pub struct AssociatedValueExpectedFor {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_associated_value_expected)]\n+pub struct AssociatedValueExpected {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_unchecked_clean)]\n+pub struct UncheckedClean {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_old)]\n+pub struct DeleteOld<'a> {\n+    pub name: &'a str,\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_new)]\n+pub struct CreateNew<'a> {\n+    pub name: &'a str,\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_write_new)]\n+pub struct WriteNew<'a> {\n+    pub name: &'a str,\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_canonicalize_path)]\n+pub struct CanonicalizePath {\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_incr_comp_dir)]\n+pub struct CreateIncrCompDir<'a> {\n+    pub tag: &'a str,\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_lock)]\n+pub struct CreateLock<'a> {\n+    pub lock_err: std::io::Error,\n+    pub session_dir: &'a Path,\n+    #[note(incremental_lock_unsupported)]\n+    pub is_unsupported_lock: Option<()>,\n+    #[help(incremental_cargo_help_1)]\n+    #[help(incremental_cargo_help_2)]\n+    pub is_cargo: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_lock)]\n+pub struct DeleteLock<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_hard_link_failed)]\n+pub struct HardLinkFailed<'a> {\n+    pub path: &'a Path,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_partial)]\n+pub struct DeletePartial<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_full)]\n+pub struct DeleteFull<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_finalize)]\n+pub struct Finalize<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_invalid_gc_failed)]\n+pub struct InvalidGcFailed<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_finalized_gc_failed)]\n+pub struct FinalizedGcFailed<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_session_gc_failed)]\n+pub struct SessionGcFailed<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_assert_not_loaded)]\n+pub struct AssertNotLoaded;\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_assert_loaded)]\n+pub struct AssertLoaded;\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_incompatible)]\n+pub struct DeleteIncompatible {\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_load_dep_graph)]\n+pub struct LoadDepGraph {\n+    pub path: PathBuf,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_decode_incr_cache)]\n+pub struct DecodeIncrCache {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_write_dep_graph)]\n+pub struct WriteDepGraph<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_move_dep_graph)]\n+pub struct MoveDepGraph<'a> {\n+    pub from: &'a Path,\n+    pub to: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_create_dep_graph)]\n+pub struct CreateDepGraph<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_copy_workproduct_to_cache)]\n+pub struct CopyWorkProductToCache<'a> {\n+    pub from: &'a Path,\n+    pub to: &'a Path,\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(incremental_delete_workproduct)]\n+pub struct DeleteWorkProduct<'a> {\n+    pub path: &'a Path,\n+    pub err: std::io::Error,\n+}"}, {"sha": "3c58cfa38f28021241f8a70c0538d1cf8bf3f807", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -2,8 +2,11 @@\n \n #![deny(missing_docs)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -12,6 +15,7 @@ extern crate tracing;\n \n mod assert_dep_graph;\n pub mod assert_module_sources;\n+mod errors;\n mod persist;\n \n use assert_dep_graph::assert_dep_graph;"}, {"sha": "c6e63998c7935fe887445845a65cf794cb579d81", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -19,6 +19,7 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n+use crate::errors;\n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::LocalDefId;\n@@ -196,11 +197,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n         let loaded_from_disk = self.loaded_from_disk(attr);\n         for e in except.iter() {\n             if !auto.remove(e) {\n-                let msg = format!(\n-                    \"`except` specified DepNodes that can not be affected for \\\"{}\\\": \\\"{}\\\"\",\n-                    name, e\n-                );\n-                self.tcx.sess.span_fatal(attr.span, &msg);\n+                self.tcx.sess.emit_fatal(errors::AssertionAuto { span: attr.span, name, e });\n             }\n         }\n         Assertion { clean: auto, dirty: except, loaded_from_disk }\n@@ -282,14 +279,10 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n                     HirItem::Impl { .. } => (\"ItemKind::Impl\", LABELS_IMPL),\n \n-                    _ => self.tcx.sess.span_fatal(\n-                        attr.span,\n-                        &format!(\n-                            \"clean/dirty auto-assertions not yet defined \\\n-                             for Node::Item.node={:?}\",\n-                            item.kind\n-                        ),\n-                    ),\n+                    _ => self.tcx.sess.emit_fatal(errors::UndefinedCleanDirtyItem {\n+                        span: attr.span,\n+                        kind: format!(\"{:?}\", item.kind),\n+                    }),\n                 }\n             }\n             HirNode::TraitItem(item) => match item.kind {\n@@ -302,10 +295,10 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                 ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                 ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n             },\n-            _ => self.tcx.sess.span_fatal(\n-                attr.span,\n-                &format!(\"clean/dirty auto-assertions not yet defined for {:?}\", node),\n-            ),\n+            _ => self.tcx.sess.emit_fatal(errors::UndefinedCleanDirty {\n+                span: attr.span,\n+                kind: format!(\"{:?}\", node),\n+            }),\n         };\n         let labels =\n             Labels::from_iter(labels.iter().flat_map(|s| s.iter().map(|l| (*l).to_string())));\n@@ -318,16 +311,15 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n             let label = label.trim();\n             if DepNode::has_label_string(label) {\n                 if out.contains(label) {\n-                    self.tcx.sess.span_fatal(\n-                        item.span(),\n-                        &format!(\"dep-node label `{}` is repeated\", label),\n-                    );\n+                    self.tcx\n+                        .sess\n+                        .emit_fatal(errors::RepeatedDepNodeLabel { span: item.span(), label });\n                 }\n                 out.insert(label.to_string());\n             } else {\n                 self.tcx\n                     .sess\n-                    .span_fatal(item.span(), &format!(\"dep-node label `{}` not recognized\", label));\n+                    .emit_fatal(errors::UnrecognizedDepNodeLabel { span: item.span(), label });\n             }\n         }\n         out\n@@ -348,7 +340,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n-                .span_err(item_span, &format!(\"`{}` should be dirty but is not\", dep_node_str));\n+                .emit_err(errors::NotDirty { span: item_span, dep_node_str: &dep_node_str });\n         }\n     }\n \n@@ -359,7 +351,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n-                .span_err(item_span, &format!(\"`{}` should be clean but is not\", dep_node_str));\n+                .emit_err(errors::NotClean { span: item_span, dep_node_str: &dep_node_str });\n         }\n     }\n \n@@ -368,10 +360,9 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n         if !self.tcx.dep_graph.debug_was_loaded_from_disk(dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n-            self.tcx.sess.span_err(\n-                item_span,\n-                &format!(\"`{}` should have been loaded from disk but it was not\", dep_node_str),\n-            );\n+            self.tcx\n+                .sess\n+                .emit_err(errors::NotLoaded { span: item_span, dep_node_str: &dep_node_str });\n         }\n     }\n \n@@ -412,12 +403,12 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             cfg = Some(config.contains(&(value, None)));\n         } else if !(item.has_name(EXCEPT) || item.has_name(LOADED_FROM_DISK)) {\n-            tcx.sess.span_err(attr.span, &format!(\"unknown item `{}`\", item.name_or_empty()));\n+            tcx.sess.emit_err(errors::UnknownItem { span: attr.span, name: item.name_or_empty() });\n         }\n     }\n \n     match cfg {\n-        None => tcx.sess.span_fatal(attr.span, \"no cfg attribute\"),\n+        None => tcx.sess.emit_fatal(errors::NoCfg { span: attr.span }),\n         Some(c) => c,\n     }\n }\n@@ -426,13 +417,11 @@ fn expect_associated_value(tcx: TyCtxt<'_>, item: &NestedMetaItem) -> Symbol {\n     if let Some(value) = item.value_str() {\n         value\n     } else {\n-        let msg = if let Some(ident) = item.ident() {\n-            format!(\"associated value expected for `{}`\", ident)\n+        if let Some(ident) = item.ident() {\n+            tcx.sess.emit_fatal(errors::AssociatedValueExpectedFor { span: item.span(), ident });\n         } else {\n-            \"expected an associated value\".to_string()\n-        };\n-\n-        tcx.sess.span_fatal(item.span(), &msg);\n+            tcx.sess.emit_fatal(errors::AssociatedValueExpected { span: item.span() });\n+        }\n     }\n }\n \n@@ -456,7 +445,7 @@ impl<'tcx> FindAllAttrs<'tcx> {\n     fn report_unchecked_attrs(&self, mut checked_attrs: FxHashSet<ast::AttrId>) {\n         for attr in &self.found_attrs {\n             if !checked_attrs.contains(&attr.id) {\n-                self.tcx.sess.span_err(attr.span, \"found unchecked `#[rustc_clean]` attribute\");\n+                self.tcx.sess.emit_err(errors::UncheckedClean { span: attr.span });\n                 checked_attrs.insert(attr.id);\n             }\n         }"}, {"sha": "dc981c6179eeb5b66d7f6f11190a762e115e5b46", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -9,15 +9,15 @@\n //! compiler versions don't change frequently for the typical user, being\n //! conservative here practically has no downside.\n \n-use std::env;\n-use std::fs;\n-use std::io::{self, Read};\n-use std::path::{Path, PathBuf};\n-\n+use crate::errors;\n use rustc_data_structures::memmap::Mmap;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encoder;\n use rustc_session::Session;\n+use std::env;\n+use std::fs;\n+use std::io::{self, Read};\n+use std::path::{Path, PathBuf};\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";\n@@ -60,20 +60,15 @@ where\n         }\n         Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n         Err(err) => {\n-            sess.err(&format!(\n-                \"unable to delete old {} at `{}`: {}\",\n-                name,\n-                path_buf.display(),\n-                err\n-            ));\n+            sess.emit_err(errors::DeleteOld { name, path: path_buf, err });\n             return;\n         }\n     }\n \n     let mut encoder = match FileEncoder::new(&path_buf) {\n         Ok(encoder) => encoder,\n         Err(err) => {\n-            sess.err(&format!(\"failed to create {} at `{}`: {}\", name, path_buf.display(), err));\n+            sess.emit_err(errors::CreateNew { name, path: path_buf, err });\n             return;\n         }\n     };\n@@ -90,7 +85,7 @@ where\n             debug!(\"save: data written to disk successfully\");\n         }\n         Err(err) => {\n-            sess.err(&format!(\"failed to write {} to `{}`: {}\", name, path_buf.display(), err));\n+            sess.emit_err(errors::WriteNew { name, path: path_buf, err });\n         }\n     }\n }"}, {"sha": "73d7e3becab484725e15f8b9bb7e51e4d6acd1b5", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 18, "deletions": 93, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -103,6 +103,7 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n+use crate::errors;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::{base_n, flock};\n@@ -225,12 +226,7 @@ pub fn prepare_session_directory(\n     let crate_dir = match crate_dir.canonicalize() {\n         Ok(v) => v,\n         Err(err) => {\n-            let reported = sess.err(&format!(\n-                \"incremental compilation: error canonicalizing path `{}`: {}\",\n-                crate_dir.display(),\n-                err\n-            ));\n-            return Err(reported);\n+            return Err(sess.emit_err(errors::CanonicalizePath { path: crate_dir, err }));\n         }\n     };\n \n@@ -273,14 +269,7 @@ pub fn prepare_session_directory(\n             debug!(\"successfully copied data from: {}\", source_directory.display());\n \n             if !allows_links {\n-                sess.warn(&format!(\n-                    \"Hard linking files in the incremental \\\n-                                        compilation cache failed. Copying files \\\n-                                        instead. Consider moving the cache \\\n-                                        directory to a file system which supports \\\n-                                        hard linking in session dir `{}`\",\n-                    session_dir.display()\n-                ));\n+                sess.emit_warning(errors::HardLinkFailed { path: &session_dir });\n             }\n \n             sess.init_incr_comp_session(session_dir, directory_lock, true);\n@@ -295,12 +284,7 @@ pub fn prepare_session_directory(\n             // Try to remove the session directory we just allocated. We don't\n             // know if there's any garbage in it from the failed copy action.\n             if let Err(err) = safe_remove_dir_all(&session_dir) {\n-                sess.warn(&format!(\n-                    \"Failed to delete partly initialized \\\n-                                    session dir `{}`: {}\",\n-                    session_dir.display(),\n-                    err\n-                ));\n+                sess.emit_warning(errors::DeletePartial { path: &session_dir, err });\n             }\n \n             delete_session_dir_lock_file(sess, &lock_file_path);\n@@ -332,12 +316,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n         );\n \n         if let Err(err) = safe_remove_dir_all(&*incr_comp_session_dir) {\n-            sess.warn(&format!(\n-                \"Error deleting incremental compilation \\\n-                                session directory `{}`: {}\",\n-                incr_comp_session_dir.display(),\n-                err\n-            ));\n+            sess.emit_warning(errors::DeleteFull { path: &incr_comp_session_dir, err });\n         }\n \n         let lock_file_path = lock_file_path(&*incr_comp_session_dir);\n@@ -380,12 +359,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n         }\n         Err(e) => {\n             // Warn about the error. However, no need to abort compilation now.\n-            sess.warn(&format!(\n-                \"Error finalizing incremental compilation \\\n-                               session directory `{}`: {}\",\n-                incr_comp_session_dir.display(),\n-                e\n-            ));\n+            sess.emit_warning(errors::Finalize { path: &incr_comp_session_dir, err: e });\n \n             debug!(\"finalize_session_directory() - error, marking as invalid\");\n             // Drop the file lock, so we can garage collect\n@@ -488,16 +462,7 @@ fn create_dir(sess: &Session, path: &Path, dir_tag: &str) -> Result<(), ErrorGua\n             debug!(\"{} directory created successfully\", dir_tag);\n             Ok(())\n         }\n-        Err(err) => {\n-            let reported = sess.err(&format!(\n-                \"Could not create incremental compilation {} \\\n-                               directory `{}`: {}\",\n-                dir_tag,\n-                path.display(),\n-                err\n-            ));\n-            Err(reported)\n-        }\n+        Err(err) => Err(sess.emit_err(errors::CreateIncrCompDir { tag: dir_tag, path, err })),\n     }\n }\n \n@@ -518,46 +483,20 @@ fn lock_directory(\n         // the lock should be exclusive\n         Ok(lock) => Ok((lock, lock_file_path)),\n         Err(lock_err) => {\n-            let mut err = sess.struct_err(&format!(\n-                \"incremental compilation: could not create \\\n-                 session directory lock file: {}\",\n-                lock_err\n-            ));\n-            if flock::Lock::error_unsupported(&lock_err) {\n-                err.note(&format!(\n-                    \"the filesystem for the incremental path at {} \\\n-                     does not appear to support locking, consider changing the \\\n-                     incremental path to a filesystem that supports locking \\\n-                     or disable incremental compilation\",\n-                    session_dir.display()\n-                ));\n-                if std::env::var_os(\"CARGO\").is_some() {\n-                    err.help(\n-                        \"incremental compilation can be disabled by setting the \\\n-                         environment variable CARGO_INCREMENTAL=0 (see \\\n-                         https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\",\n-                    );\n-                    err.help(\n-                        \"the entire build directory can be changed to a different \\\n-                        filesystem by setting the environment variable CARGO_TARGET_DIR \\\n-                        to a different path (see \\\n-                        https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\",\n-                    );\n-                }\n-            }\n-            Err(err.emit())\n+            let is_unsupported_lock = flock::Lock::error_unsupported(&lock_err).then_some(());\n+            Err(sess.emit_err(errors::CreateLock {\n+                lock_err,\n+                session_dir,\n+                is_unsupported_lock,\n+                is_cargo: std::env::var_os(\"CARGO\").map(|_| ()),\n+            }))\n         }\n     }\n }\n \n fn delete_session_dir_lock_file(sess: &Session, lock_file_path: &Path) {\n     if let Err(err) = safe_remove_file(&lock_file_path) {\n-        sess.warn(&format!(\n-            \"Error deleting lock file for incremental \\\n-                            compilation session directory `{}`: {}\",\n-            lock_file_path.display(),\n-            err\n-        ));\n+        sess.emit_warning(errors::DeleteLock { path: lock_file_path, err });\n     }\n }\n \n@@ -774,12 +713,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n         if !lock_file_to_session_dir.values().any(|dir| *dir == directory_name) {\n             let path = crate_directory.join(directory_name);\n             if let Err(err) = safe_remove_dir_all(&path) {\n-                sess.warn(&format!(\n-                    \"Failed to garbage collect invalid incremental \\\n-                                    compilation session directory `{}`: {}\",\n-                    path.display(),\n-                    err\n-                ));\n+                sess.emit_warning(errors::InvalidGcFailed { path: &path, err });\n             }\n         }\n     }\n@@ -885,12 +819,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n         debug!(\"garbage_collect_session_directories() - deleting `{}`\", path.display());\n \n         if let Err(err) = safe_remove_dir_all(&path) {\n-            sess.warn(&format!(\n-                \"Failed to garbage collect finalized incremental \\\n-                                compilation session directory `{}`: {}\",\n-                path.display(),\n-                err\n-            ));\n+            sess.emit_warning(errors::FinalizedGcFailed { path: &path, err });\n         } else {\n             delete_session_dir_lock_file(sess, &lock_file_path(&path));\n         }\n@@ -907,11 +836,7 @@ fn delete_old(sess: &Session, path: &Path) {\n     debug!(\"garbage_collect_session_directories() - deleting `{}`\", path.display());\n \n     if let Err(err) = safe_remove_dir_all(&path) {\n-        sess.warn(&format!(\n-            \"Failed to garbage collect incremental compilation session directory `{}`: {}\",\n-            path.display(),\n-            err\n-        ));\n+        sess.emit_warning(errors::SessionGcFailed { path: &path, err });\n     } else {\n         delete_session_dir_lock_file(sess, &lock_file_path(&path));\n     }"}, {"sha": "d5097065dda2e8c5eb3d7cbdd012329f1ac9f4bf", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,5 +1,6 @@\n //! Code to save/load the dep-graph from files.\n \n+use crate::errors;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n@@ -8,7 +9,7 @@ use rustc_serialize::opaque::MemDecoder;\n use rustc_serialize::Decodable;\n use rustc_session::config::IncrementalStateAssertion;\n use rustc_session::Session;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use super::data::*;\n use super::file_format;\n@@ -27,11 +28,10 @@ pub enum LoadResult<T> {\n     },\n     /// The file either didn't exist or was produced by an incompatible compiler version.\n     DataOutOfDate,\n-    /// An error occurred.\n-    Error {\n-        #[allow(missing_docs)]\n-        message: String,\n-    },\n+    /// Loading the dep graph failed.\n+    LoadDepGraph(PathBuf, std::io::Error),\n+    /// Decoding loaded incremental cache failed.\n+    DecodeIncrCache(Box<dyn std::any::Any + Send>),\n }\n \n impl<T: Default> LoadResult<T> {\n@@ -40,36 +40,31 @@ impl<T: Default> LoadResult<T> {\n         // Check for errors when using `-Zassert-incremental-state`\n         match (sess.opts.assert_incr_state, &self) {\n             (Some(IncrementalStateAssertion::NotLoaded), LoadResult::Ok { .. }) => {\n-                sess.fatal(\n-                    \"We asserted that the incremental cache should not be loaded, \\\n-                         but it was loaded.\",\n-                );\n+                sess.emit_fatal(errors::AssertNotLoaded);\n             }\n             (\n                 Some(IncrementalStateAssertion::Loaded),\n-                LoadResult::Error { .. } | LoadResult::DataOutOfDate,\n+                LoadResult::LoadDepGraph(..)\n+                | LoadResult::DecodeIncrCache(..)\n+                | LoadResult::DataOutOfDate,\n             ) => {\n-                sess.fatal(\n-                    \"We asserted that an existing incremental cache directory should \\\n-                         be successfully loaded, but it was not.\",\n-                );\n+                sess.emit_fatal(errors::AssertLoaded);\n             }\n             _ => {}\n         };\n \n         match self {\n-            LoadResult::Error { message } => {\n-                sess.warn(&message);\n+            LoadResult::LoadDepGraph(path, err) => {\n+                sess.emit_warning(errors::LoadDepGraph { path, err });\n+                Default::default()\n+            }\n+            LoadResult::DecodeIncrCache(err) => {\n+                sess.emit_warning(errors::DecodeIncrCache { err: format!(\"{err:?}\") });\n                 Default::default()\n             }\n             LoadResult::DataOutOfDate => {\n                 if let Err(err) = delete_all_session_dir_contents(sess) {\n-                    sess.err(&format!(\n-                        \"Failed to delete invalidated or incompatible \\\n-                         incremental compilation session directory contents `{}`: {}.\",\n-                        dep_graph_path(sess).display(),\n-                        err\n-                    ));\n+                    sess.emit_err(errors::DeleteIncompatible { path: dep_graph_path(sess), err });\n                 }\n                 Default::default()\n             }\n@@ -90,9 +85,7 @@ fn load_data(\n             // compiler version. Neither is an error.\n             LoadResult::DataOutOfDate\n         }\n-        Err(err) => LoadResult::Error {\n-            message: format!(\"could not load dep-graph from `{}`: {}\", path.display(), err),\n-        },\n+        Err(err) => LoadResult::LoadDepGraph(path.to_path_buf(), err),\n     }\n }\n \n@@ -114,9 +107,9 @@ impl<T> MaybeAsync<LoadResult<T>> {\n     pub fn open(self) -> LoadResult<T> {\n         match self {\n             MaybeAsync::Sync(result) => result,\n-            MaybeAsync::Async(handle) => handle.join().unwrap_or_else(|e| LoadResult::Error {\n-                message: format!(\"could not decode incremental cache: {:?}\", e),\n-            }),\n+            MaybeAsync::Async(handle) => {\n+                handle.join().unwrap_or_else(|e| LoadResult::DecodeIncrCache(e))\n+            }\n         }\n     }\n }\n@@ -185,7 +178,8 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n         match load_data(report_incremental_info, &path, nightly_build) {\n             LoadResult::DataOutOfDate => LoadResult::DataOutOfDate,\n-            LoadResult::Error { message } => LoadResult::Error { message },\n+            LoadResult::LoadDepGraph(path, err) => LoadResult::LoadDepGraph(path, err),\n+            LoadResult::DecodeIncrCache(err) => LoadResult::DecodeIncrCache(err),\n             LoadResult::Ok { data: (bytes, start_pos) } => {\n                 let mut decoder = MemDecoder::new(&bytes, start_pos);\n                 let prev_commandline_args_hash = u64::decode(&mut decoder);"}, {"sha": "27be56eac6f998091b0a39bc6a64400e07b27608", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n use rustc_middle::dep_graph::{DepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n@@ -59,19 +60,14 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n             move || {\n                 sess.time(\"incr_comp_persist_dep_graph\", || {\n                     if let Err(err) = tcx.dep_graph.encode(&tcx.sess.prof) {\n-                        sess.err(&format!(\n-                            \"failed to write dependency graph to `{}`: {}\",\n-                            staging_dep_graph_path.display(),\n-                            err\n-                        ));\n+                        sess.emit_err(errors::WriteDepGraph { path: &staging_dep_graph_path, err });\n                     }\n                     if let Err(err) = fs::rename(&staging_dep_graph_path, &dep_graph_path) {\n-                        sess.err(&format!(\n-                            \"failed to move dependency graph from `{}` to `{}`: {}\",\n-                            staging_dep_graph_path.display(),\n-                            dep_graph_path.display(),\n-                            err\n-                        ));\n+                        sess.emit_err(errors::MoveDepGraph {\n+                            from: &staging_dep_graph_path,\n+                            to: &dep_graph_path,\n+                            err,\n+                        });\n                     }\n                 });\n             },\n@@ -163,11 +159,7 @@ pub fn build_dep_graph(\n     let mut encoder = match FileEncoder::new(&path_buf) {\n         Ok(encoder) => encoder,\n         Err(err) => {\n-            sess.err(&format!(\n-                \"failed to create dependency graph at `{}`: {}\",\n-                path_buf.display(),\n-                err\n-            ));\n+            sess.emit_err(errors::CreateDepGraph { path: &path_buf, err });\n             return None;\n         }\n     };"}, {"sha": "dc98fbeb0d1669f9bbcd54dd3e392ca0fdc4ea92", "filename": "compiler/rustc_incremental/src/persist/work_product.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -2,6 +2,7 @@\n //!\n //! [work products]: WorkProduct\n \n+use crate::errors;\n use crate::persist::fs::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_fs_util::link_or_copy;\n@@ -28,12 +29,11 @@ pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n                 let _ = saved_files.insert(ext.to_string(), file_name);\n             }\n             Err(err) => {\n-                sess.warn(&format!(\n-                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n-                    path.display(),\n-                    path_in_incr_dir.display(),\n-                    err\n-                ));\n+                sess.emit_warning(errors::CopyWorkProductToCache {\n+                    from: &path,\n+                    to: &path_in_incr_dir,\n+                    err,\n+                });\n             }\n         }\n     }\n@@ -49,11 +49,7 @@ pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n     for (_, path) in &work_product.saved_files {\n         let path = in_incr_comp_dir_sess(sess, path);\n         if let Err(err) = std_fs::remove_file(&path) {\n-            sess.warn(&format!(\n-                \"file-system error deleting outdated file `{}`: {}\",\n-                path.display(),\n-                err\n-            ));\n+            sess.emit_warning(errors::DeleteWorkProduct { path: &path, err });\n         }\n     }\n }"}, {"sha": "1199ff287c4302a09ee879e103084ad78e2fd200", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -49,9 +49,6 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n \n-[dev-dependencies]\n-rustc_target = { path = \"../rustc_target\" }\n-\n [features]\n llvm = ['rustc_codegen_llvm']\n rustc_use_parallel_compiler = ['rayon', 'rustc-rayon-core', 'rustc_query_impl/rustc_use_parallel_compiler', 'rustc_errors/rustc_use_parallel_compiler']"}, {"sha": "29543fe2f932c62564eba76826ccc779c68633eb", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,5 +1,7 @@\n use rustc_macros::Diagnostic;\n+use rustc_session::config::CrateType;\n use rustc_span::{Span, Symbol};\n+use rustc_target::spec::TargetTriple;\n \n use std::io;\n use std::path::Path;\n@@ -91,3 +93,22 @@ pub struct FailedWritingFile<'a> {\n #[derive(Diagnostic)]\n #[diag(interface_proc_macro_crate_panic_abort)]\n pub struct ProcMacroCratePanicAbort;\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_unsupported_crate_type_for_target)]\n+pub struct UnsupportedCrateTypeForTarget<'a> {\n+    pub crate_type: CrateType,\n+    pub target_triple: &'a TargetTriple,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_multiple_output_types_adaption)]\n+pub struct MultipleOutputTypesAdaption;\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_ignoring_extra_filename)]\n+pub struct IgnoringExtraFilename;\n+\n+#[derive(Diagnostic)]\n+#[diag(interface_ignoring_out_dir)]\n+pub struct IgnoringOutDir;"}, {"sha": "e4b4d5375e64a4d94c8e464108713e2590415e00", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use info;\n use libloading::Library;\n use rustc_ast as ast;\n@@ -472,16 +473,15 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     }\n \n     base.retain(|crate_type| {\n-        let res = !output::invalid_output_for_target(session, *crate_type);\n-\n-        if !res {\n-            session.warn(&format!(\n-                \"dropping unsupported crate type `{}` for target `{}`\",\n-                *crate_type, session.opts.target_triple\n-            ));\n+        if output::invalid_output_for_target(session, *crate_type) {\n+            session.emit_warning(errors::UnsupportedCrateTypeForTarget {\n+                crate_type: *crate_type,\n+                target_triple: &session.opts.target_triple,\n+            });\n+            false\n+        } else {\n+            true\n         }\n-\n-        res\n     });\n \n     base\n@@ -517,19 +517,16 @@ pub fn build_output_filenames(attrs: &[ast::Attribute], sess: &Session) -> Outpu\n             let unnamed_output_types =\n                 sess.opts.output_types.values().filter(|a| a.is_none()).count();\n             let ofile = if unnamed_output_types > 1 {\n-                sess.warn(\n-                    \"due to multiple output types requested, the explicitly specified \\\n-                     output file name will be adapted for each output type\",\n-                );\n+                sess.emit_warning(errors::MultipleOutputTypesAdaption);\n                 None\n             } else {\n                 if !sess.opts.cg.extra_filename.is_empty() {\n-                    sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n+                    sess.emit_warning(errors::IgnoringExtraFilename);\n                 }\n                 Some(out_file.clone())\n             };\n             if sess.io.output_dir != None {\n-                sess.warn(\"ignoring --out-dir flag due to -o flag\");\n+                sess.emit_warning(errors::IgnoringOutDir);\n             }\n \n             OutputFilenames::new("}, {"sha": "31a3ffbb1d8915e55283626392b5c17aa6377194", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -201,7 +201,9 @@ use rustc_target::abi::Size;\n use std::ops::Range;\n use std::path::PathBuf;\n \n-use crate::errors::{LargeAssignmentsLint, RecursionLimit, TypeLengthLimit};\n+use crate::errors::{\n+    EncounteredErrorWhileInstantiating, LargeAssignmentsLint, RecursionLimit, TypeLengthLimit,\n+};\n \n #[derive(PartialEq)]\n pub enum MonoItemCollectionMode {\n@@ -524,10 +526,10 @@ fn collect_items_rec<'tcx>(\n         && starting_point.node.is_user_defined()\n     {\n         let formatted_item = with_no_trimmed_paths!(starting_point.node.to_string());\n-        tcx.sess.span_note_without_error(\n-            starting_point.span,\n-            &format!(\"the above error was encountered while instantiating `{formatted_item}`\"),\n-        );\n+        tcx.sess.emit_note(EncounteredErrorWhileInstantiating {\n+            span: starting_point.span,\n+            formatted_item,\n+        });\n     }\n     inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n "}, {"sha": "a53bd7e1fef5e9b76fbc7d664333c284f880b19b", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -83,3 +83,17 @@ pub struct SymbolAlreadyDefined {\n pub struct CouldntDumpMonoStats {\n     pub error: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(monomorphize_encountered_error_while_instantiating)]\n+pub struct EncounteredErrorWhileInstantiating {\n+    #[primary_span]\n+    pub span: Span,\n+    pub formatted_item: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(monomorphize_unknown_cgu_collection_mode)]\n+pub struct UnknownCguCollectionMode<'a> {\n+    pub mode: &'a str,\n+}"}, {"sha": "524c51d88d75519260e767a6980036206b2932c2", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -114,7 +114,9 @@ use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownPartitionStrategy};\n+use crate::errors::{\n+    CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode, UnknownPartitionStrategy,\n+};\n \n pub struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -348,17 +350,13 @@ where\n fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n     let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n         Some(ref s) => {\n-            let mode_string = s.to_lowercase();\n-            let mode_string = mode_string.trim();\n-            if mode_string == \"eager\" {\n+            let mode = s.to_lowercase();\n+            let mode = mode.trim();\n+            if mode == \"eager\" {\n                 MonoItemCollectionMode::Eager\n             } else {\n-                if mode_string != \"lazy\" {\n-                    let message = format!(\n-                        \"Unknown codegen-item collection mode '{mode_string}'. \\\n-                                           Falling back to 'lazy' mode.\"\n-                    );\n-                    tcx.sess.warn(&message);\n+                if mode != \"lazy\" {\n+                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n                 }\n \n                 MonoItemCollectionMode::Lazy"}, {"sha": "526b829bf676ae2e952cbcad78e3a21fe666817d", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n-use crate::errors::ExprNotAllowedInContext;\n+use crate::errors::{ExprNotAllowedInContext, SkippingConstChecks};\n \n /// An expression that is not *always* legal in a const context.\n #[derive(Clone, Copy)]\n@@ -124,7 +124,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             // corresponding feature gate. This encourages nightly users to use feature gates when\n             // possible.\n             None if tcx.sess.opts.unstable_opts.unleash_the_miri_inside_of_you => {\n-                tcx.sess.span_warn(span, \"skipping const checks\");\n+                tcx.sess.emit_warning(SkippingConstChecks { span });\n                 return;\n             }\n "}, {"sha": "97169a6367c3d97447f9b13e383b85b856c86ccb", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -1565,3 +1565,10 @@ pub(crate) struct ProcMacroUnsafe {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_skipping_const_checks)]\n+pub struct SkippingConstChecks {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "973d860118ef14a1399c6d2170eb426c8dd80e3a", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -24,7 +24,7 @@ use rustc_span::RealFileName;\n use rustc_span::SourceFileHashAlgorithm;\n \n use rustc_errors::emitter::HumanReadableErrorType;\n-use rustc_errors::{ColorConfig, HandlerFlags};\n+use rustc_errors::{ColorConfig, DiagnosticArgValue, HandlerFlags, IntoDiagnosticArg};\n \n use std::collections::btree_map::{\n     Iter as BTreeMapIter, Keys as BTreeMapKeysIter, Values as BTreeMapValuesIter,\n@@ -2694,6 +2694,12 @@ impl fmt::Display for CrateType {\n     }\n }\n \n+impl IntoDiagnosticArg for CrateType {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     /// `-Zunpretty=normal`"}, {"sha": "8e8fba5e236f5970af069ac9193fbf0ce58db032", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -375,3 +375,9 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(session_optimization_fuel_exhausted)]\n+pub struct OptimisationFuelExhausted {\n+    pub msg: String,\n+}"}, {"sha": "91d23f1041fe9e6581a796cbee7d723268feedb8", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -5,9 +5,10 @@ use crate::config::Input;\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n use crate::errors::{\n     BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n-    LinkerPluginToWindowsNotSupported, NotCircumventFeature, ProfileSampleUseFileDoesNotExist,\n-    ProfileUseFileDoesNotExist, SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported,\n-    SkippingConstChecks, SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n+    LinkerPluginToWindowsNotSupported, NotCircumventFeature, OptimisationFuelExhausted,\n+    ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist, SanitizerCfiEnabled,\n+    SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n+    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n     TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n     UnsupportedDwarfVersion,\n };\n@@ -483,6 +484,8 @@ impl Session {\n         self.diagnostic().span_err_with_code(sp, msg, code)\n     }\n     #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }\n@@ -583,12 +586,16 @@ impl Session {\n             ))\n         }\n     }\n+\n+    #[rustc_lint_diagnostics]\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     #[track_caller]\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n+\n+    #[rustc_lint_diagnostics]\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_warn_with_code<S: Into<MultiSpan>>(\n@@ -599,6 +606,10 @@ impl Session {\n     ) {\n         self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n+\n+    #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().warn(msg)\n     }\n@@ -641,18 +652,26 @@ impl Session {\n         self.diagnostic().delay_good_path_bug(msg)\n     }\n \n+    #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().note_without_error(msg)\n     }\n \n     #[track_caller]\n+    #[rustc_lint_diagnostics]\n+    #[allow(rustc::untranslatable_diagnostic)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_note_without_error<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n         msg: impl Into<DiagnosticMessage>,\n     ) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n+\n+    #[rustc_lint_diagnostics]\n     #[allow(rustc::untranslatable_diagnostic)]\n     #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_note_without_error(\n@@ -882,7 +901,7 @@ impl Session {\n                         // We only call `msg` in case we can actually emit warnings.\n                         // Otherwise, this could cause a `delay_good_path_bug` to\n                         // trigger (issue #79546).\n-                        self.warn(&format!(\"optimization-fuel-exhausted: {}\", msg()));\n+                        self.emit_warning(OptimisationFuelExhausted { msg: msg() });\n                     }\n                     fuel.out_of_fuel = true;\n                 } else if fuel.remaining > 0 {"}, {"sha": "6ce1370927bc1eb776da0deb2514064f22cfaee2", "filename": "tests/run-make/incremental-session-fail/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64ef7d07d0411315be85a646586cb85eeb9c136/tests%2Frun-make%2Fincremental-session-fail%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a64ef7d07d0411315be85a646586cb85eeb9c136/tests%2Frun-make%2Fincremental-session-fail%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fincremental-session-fail%2FMakefile?ref=a64ef7d07d0411315be85a646586cb85eeb9c136", "patch": "@@ -9,6 +9,6 @@ all:\n \ttouch $(SESSION_DIR)\n \t# Check exit code is 1 for an error, and not 101 for ICE.\n \t$(RUSTC) foo.rs --crate-type=rlib -C incremental=$(SESSION_DIR) > $(OUTPUT_FILE) 2>&1; [ $$? -eq 1 ]\n-\t$(CGREP) \"Could not create incremental compilation crate directory\" < $(OUTPUT_FILE)\n+\t$(CGREP) \"could not create incremental compilation crate directory\" < $(OUTPUT_FILE)\n \t# -v tests are fragile, hopefully this text won't change\n \t$(CGREP) -v \"internal compiler error\" < $(OUTPUT_FILE)"}]}