{"sha": "717bf35366e2baf44e0c9a6594041d58d35a0f13", "node_id": "C_kwDOAAsO6NoAKDcxN2JmMzUzNjZlMmJhZjQ0ZTBjOWE2NTk0MDQxZDU4ZDM1YTBmMTM", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-10-21T13:38:44Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-10-21T13:38:44Z"}, "message": "Different suggestions for when associated functions are referred to", "tree": {"sha": "c416ef76695615f1037ea7bdf3cb01e3086d8c71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c416ef76695615f1037ea7bdf3cb01e3086d8c71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/717bf35366e2baf44e0c9a6594041d58d35a0f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/717bf35366e2baf44e0c9a6594041d58d35a0f13", "html_url": "https://github.com/rust-lang/rust/commit/717bf35366e2baf44e0c9a6594041d58d35a0f13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/717bf35366e2baf44e0c9a6594041d58d35a0f13/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0940040c0486a536be4f8685c7dd9a078f9e87c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0940040c0486a536be4f8685c7dd9a078f9e87c2", "html_url": "https://github.com/rust-lang/rust/commit/0940040c0486a536be4f8685c7dd9a078f9e87c2"}], "stats": {"total": 42, "additions": 29, "deletions": 13}, "files": [{"sha": "6de63282df4e26054c90341c8222b968ad8a0325", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/717bf35366e2baf44e0c9a6594041d58d35a0f13/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717bf35366e2baf44e0c9a6594041d58d35a0f13/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=717bf35366e2baf44e0c9a6594041d58d35a0f13", "patch": "@@ -38,8 +38,8 @@ type Res = def::Res<ast::NodeId>;\n /// A field or associated item from self type suggested in case of resolution failure.\n enum AssocSuggestion {\n     Field,\n-    MethodWithSelf,\n-    AssocFn,\n+    MethodWithSelf { called: bool },\n+    AssocFn { called: bool },\n     AssocType,\n     AssocConst,\n }\n@@ -48,8 +48,14 @@ impl AssocSuggestion {\n     fn action(&self) -> &'static str {\n         match self {\n             AssocSuggestion::Field => \"use the available field\",\n-            AssocSuggestion::MethodWithSelf => \"call the method with the fully-qualified path\",\n-            AssocSuggestion::AssocFn => \"call the associated function\",\n+            AssocSuggestion::MethodWithSelf { called: true } => {\n+                \"call the method with the fully-qualified path\"\n+            }\n+            AssocSuggestion::MethodWithSelf { called: false } => {\n+                \"refer to the method with the fully-qualified path\"\n+            }\n+            AssocSuggestion::AssocFn { called: true } => \"call the associated function\",\n+            AssocSuggestion::AssocFn { called: false } => \"refer to the associated function\",\n             AssocSuggestion::AssocConst => \"use the associated `const`\",\n             AssocSuggestion::AssocType => \"use the associated type\",\n         }\n@@ -498,7 +504,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         // Try Levenshtein algorithm.\n         let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         if path.len() == 1 && self.self_type_is_available() {\n-            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n+            if let Some(candidate) =\n+                self.lookup_assoc_candidate(ident, ns, is_expected, source.is_call())\n+            {\n                 let self_is_available = self.self_value_is_available(path[0].ident.span);\n                 match candidate {\n                     AssocSuggestion::Field => {\n@@ -513,16 +521,21 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             err.span_label(span, \"a field by this name exists in `Self`\");\n                         }\n                     }\n-                    AssocSuggestion::MethodWithSelf if self_is_available => {\n+                    AssocSuggestion::MethodWithSelf { called } if self_is_available => {\n+                        let msg = if called {\n+                            \"you might have meant to call the method\"\n+                        } else {\n+                            \"you might have meant to refer to the method\"\n+                        };\n                         err.span_suggestion(\n                             span,\n-                            \"you might have meant to call the method\",\n+                            msg,\n                             format!(\"self.{path_str}\"),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-                    AssocSuggestion::MethodWithSelf\n-                    | AssocSuggestion::AssocFn\n+                    AssocSuggestion::MethodWithSelf { .. }\n+                    | AssocSuggestion::AssocFn { .. }\n                     | AssocSuggestion::AssocConst\n                     | AssocSuggestion::AssocType => {\n                         err.span_suggestion(\n@@ -1494,6 +1507,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         ident: Ident,\n         ns: Namespace,\n         filter_fn: FilterFn,\n+        called: bool,\n     ) -> Option<AssocSuggestion>\n     where\n         FilterFn: Fn(Res) -> bool,\n@@ -1535,9 +1549,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     return Some(match &assoc_item.kind {\n                         ast::AssocItemKind::Const(..) => AssocSuggestion::AssocConst,\n                         ast::AssocItemKind::Fn(box ast::Fn { sig, .. }) if sig.decl.has_self() => {\n-                            AssocSuggestion::MethodWithSelf\n+                            AssocSuggestion::MethodWithSelf { called }\n                         }\n-                        ast::AssocItemKind::Fn(..) => AssocSuggestion::AssocFn,\n+                        ast::AssocItemKind::Fn(..) => AssocSuggestion::AssocFn { called },\n                         ast::AssocItemKind::Type(..) => AssocSuggestion::AssocType,\n                         ast::AssocItemKind::MacCall(_) => continue,\n                     });\n@@ -1556,10 +1570,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 let res = binding.res();\n                 if filter_fn(res) {\n                     if self.r.has_self.contains(&res.def_id()) {\n-                        return Some(AssocSuggestion::MethodWithSelf);\n+                        return Some(AssocSuggestion::MethodWithSelf { called });\n                     } else {\n                         match res {\n-                            Res::Def(DefKind::AssocFn, _) => return Some(AssocSuggestion::AssocFn),\n+                            Res::Def(DefKind::AssocFn, _) => {\n+                                return Some(AssocSuggestion::AssocFn { called });\n+                            }\n                             Res::Def(DefKind::AssocConst, _) => {\n                                 return Some(AssocSuggestion::AssocConst);\n                             }"}]}