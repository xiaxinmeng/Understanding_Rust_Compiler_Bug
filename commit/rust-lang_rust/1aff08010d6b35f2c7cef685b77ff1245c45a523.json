{"sha": "1aff08010d6b35f2c7cef685b77ff1245c45a523", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZmYwODAxMGQ2YjM1ZjJjN2NlZjY4NWI3N2ZmMTI0NWM0NWE1MjM=", "commit": {"author": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2020-01-24T11:49:34Z"}, "committer": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2020-01-28T18:30:34Z"}, "message": "Add `Iterator::map_while` method and corresponding `MapWhile` adapter", "tree": {"sha": "98ede4f78eabe4974ef7dcba664c0d59b8d7d245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98ede4f78eabe4974ef7dcba664c0d59b8d7d245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aff08010d6b35f2c7cef685b77ff1245c45a523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aff08010d6b35f2c7cef685b77ff1245c45a523", "html_url": "https://github.com/rust-lang/rust/commit/1aff08010d6b35f2c7cef685b77ff1245c45a523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aff08010d6b35f2c7cef685b77ff1245c45a523/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b181835a6bacfa449f55d46764a10e25d1c471dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b181835a6bacfa449f55d46764a10e25d1c471dc", "html_url": "https://github.com/rust-lang/rust/commit/b181835a6bacfa449f55d46764a10e25d1c471dc"}], "stats": {"total": 196, "additions": 195, "deletions": 1}, "files": [{"sha": "6ef4a49434002347ad75cd3fd1bca52f1717d764", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=1aff08010d6b35f2c7cef685b77ff1245c45a523", "patch": "@@ -1752,6 +1752,95 @@ where\n     }\n }\n \n+/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n+///\n+/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map_while`]: trait.Iterator.html#method.map_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"none\")]\n+#[derive(Clone)]\n+pub struct MapWhile<I, P> {\n+    iter: I,\n+    finished: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> MapWhile<I, P> {\n+    pub(super) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n+        MapWhile { iter, finished: false, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"none\")]\n+impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.finished).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"none\")]\n+impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        if self.finished {\n+            None\n+        } else {\n+            let x = self.iter.next()?;\n+            let ret = (self.predicate)(x);\n+            self.finished = ret.is_none();\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, B, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| match p(x) {\n+                Some(item) => LoopState::from_try(fold(acc, item)),\n+                None => {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }\n+        }\n+\n+        if self.finished {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.finished;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n+        }\n+    }\n+}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for TakeWhile<I, P>\n where"}, {"sha": "c9f5e77d14b3eb1d707283dcc1c57e7e681ec242", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=1aff08010d6b35f2c7cef685b77ff1245c45a523", "patch": "@@ -351,6 +351,8 @@ pub use self::adapters::Cloned;\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"none\")]\n+pub use self::adapters::MapWhile;\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n pub use self::adapters::StepBy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "6bb92099ced5117105ec955c48730db85ac12ae9", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=1aff08010d6b35f2c7cef685b77ff1245c45a523", "patch": "@@ -1,4 +1,6 @@\n // ignore-tidy-filelength\n+// This file almost exclusively consists of the definition of `Iterator`. We\n+// can't split that into multiple files.\n \n use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n@@ -7,7 +9,9 @@ use super::super::LoopState;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Product, Sum, Zip};\n-use super::super::{Inspect, Map, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile};\n+use super::super::{\n+    Inspect, Map, MapWhile, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile,\n+};\n \n fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n \n@@ -1026,6 +1030,102 @@ pub trait Iterator {\n         TakeWhile::new(self, predicate)\n     }\n \n+    /// Creates an iterator that both yields elements based on a predicate and maps.\n+    ///\n+    /// `map_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and yield elements\n+    /// while it returns [`Some(_)`][`Some`].\n+    ///\n+    /// After [`None`] is returned, `map_while()`'s job is over, and the\n+    /// rest of the elements are ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// let a = [-1i32, 4, 0, 1];\n+    ///\n+    /// let mut iter = a.iter().map_while(|x| 16i32.checked_div(*x));\n+    ///\n+    /// assert_eq!(iter.next(), Some(-16));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Here's the same example, but with [`take_while`] and [`map`]:\n+    ///\n+    /// [`take_while`]: #method.take_while\n+    /// [`map`]: #method.map\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 4, 0, 1];\n+    ///\n+    /// let mut iter = a.iter()\n+    ///                 .map(|x| 16i32.checked_div(*x))\n+    ///                 .take_while(|x| x.is_some())\n+    ///                 .map(|x| x.unwrap());\n+    ///\n+    /// assert_eq!(iter.next(), Some(-16));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial [`None`]:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// use std::convert::TryFrom;\n+    ///\n+    /// let a = [0, -1, 1, -2];\n+    ///\n+    /// let mut iter = a.iter().map_while(|x| u32::try_from(*x).ok());\n+    ///\n+    /// assert_eq!(iter.next(), Some(0u32));\n+    ///\n+    /// // We have more elements that are fit in u32, but since we already\n+    /// // got a None, map_while() isn't used any more\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because `map_while()` needs to look at the value in order to see if it\n+    /// should be included or not, consuming iterators will see that it is\n+    /// removed:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// use std::convert::TryFrom;\n+    ///\n+    /// let a = [1, 2, -3, 4];\n+    /// let mut iter = a.iter();\n+    ///\n+    /// let result: Vec<u32> = iter.by_ref()\n+    ///                            .map_while(|n| u32::try_from(*n).ok())\n+    ///                            .collect();\n+    ///\n+    /// assert_eq!(result, &[1, 2]);\n+    ///\n+    /// let result: Vec<i32> = iter.cloned().collect();\n+    ///\n+    /// assert_eq!(result, &[4]);\n+    /// ```\n+    ///\n+    /// The `-3` is no longer there, because it was consumed in order to see if\n+    /// the iteration should stop, but wasn't placed back into the iterator.\n+    ///\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    #[inline]\n+    #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"none\")]\n+    fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>\n+    where\n+        Self: Sized,\n+        P: FnMut(Self::Item) -> Option<B>,\n+    {\n+        MapWhile::new(self, predicate)\n+    }\n+\n     /// Creates an iterator that skips the first `n` elements.\n     ///\n     /// After they have been consumed, the rest of the elements are yielded."}, {"sha": "bd3218ec27f3212112f585a440970b830e2896fc", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=1aff08010d6b35f2c7cef685b77ff1245c45a523", "patch": "@@ -1477,6 +1477,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n     assert_eq!(c.clone().skip(5).size_hint().1, None);\n     assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map_while(|_| None::<()>).size_hint(), (0, None));\n     assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.clone().enumerate().size_hint(), (usize::MAX, None));\n     assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (usize::MAX, None));\n@@ -1491,6 +1492,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n     assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n     assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map_while(|_| None::<()>).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n     assert_eq!(vi.clone().chain(v2).size_hint(), (13, Some(13)));"}, {"sha": "8fd19ef67fccf33e53d9e22a41d2d91f17963bc5", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aff08010d6b35f2c7cef685b77ff1245c45a523/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=1aff08010d6b35f2c7cef685b77ff1245c45a523", "patch": "@@ -36,6 +36,7 @@\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n #![feature(cmp_min_max_by)]\n+#![feature(iter_map_while)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_raw_ptr_deref)]\n #![feature(never_type)]"}]}