{"sha": "3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYTNkOWVlZDZkMTEwYzNhYzk3MDdjOWZjZTc3ZjU3MjdhNzU0MGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T21:53:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T21:54:10Z"}, "message": "rustc: Make the parser use the interner", "tree": {"sha": "12ed1aeee8b7cb848f5738f662c7c21037c4d48f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12ed1aeee8b7cb848f5738f662c7c21037c4d48f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "html_url": "https://github.com/rust-lang/rust/commit/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b91ef944c8719933b66b4b649cfe3d5e1a676402", "url": "https://api.github.com/repos/rust-lang/rust/commits/b91ef944c8719933b66b4b649cfe3d5e1a676402", "html_url": "https://github.com/rust-lang/rust/commit/b91ef944c8719933b66b4b649cfe3d5e1a676402"}], "stats": {"total": 60, "additions": 31, "deletions": 29}, "files": [{"sha": "16f75b4ab058d699e7c98e01661c9138f4542f8c", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "patch": "@@ -10,6 +10,7 @@ import std::option::none;\n import driver::session::session;\n import util::common;\n import util::common::new_str_hash;\n+import util::interner;\n \n state type reader = state obj {\n     fn is_eof() -> bool;\n@@ -19,15 +20,15 @@ state type reader = state obj {\n     fn bump();\n     fn mark();\n     fn get_mark_chpos() -> uint;\n-    fn add_str(str) -> token::str_num;\n-    fn get_str(token::str_num) -> str;\n+    fn get_interner() -> @interner::interner[str];\n     fn get_chpos() -> uint;\n     fn get_filemap() -> codemap::filemap;\n     fn err(str m);\n };\n \n fn new_reader(session sess, io::reader rdr,\n-              codemap::filemap filemap) -> reader {\n+              codemap::filemap filemap,\n+              @interner::interner[str] itr) -> reader {\n \n     state obj reader(session sess,\n                      str file,\n@@ -37,7 +38,8 @@ fn new_reader(session sess, io::reader rdr,\n                      mutable uint mark_chpos,\n                      mutable uint chpos,\n                      mutable vec[str] strs,\n-                     codemap::filemap fm) {\n+                     codemap::filemap fm,\n+                     @interner::interner[str] itr) {\n \n         fn is_eof() -> bool {\n             ret ch == -1 as char;\n@@ -78,14 +80,7 @@ fn new_reader(session sess, io::reader rdr,\n             }\n         }\n \n-        fn add_str(str s) -> token::str_num {\n-            strs += vec(s);\n-            ret _vec::len[str](strs) - 1u;\n-        }\n-\n-        fn get_str(token::str_num i) -> str {\n-            ret strs.(i);\n-        }\n+        fn get_interner() -> @interner::interner[str] { ret itr; }\n \n         fn get_filemap() -> codemap::filemap {\n             ret fm;\n@@ -99,7 +94,7 @@ fn new_reader(session sess, io::reader rdr,\n     let vec[str] strs = vec();\n     auto rd = reader(sess, file, _str::byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n-                     strs, filemap);\n+                     strs, filemap, itr);\n     rd.init();\n     ret rd;\n }\n@@ -387,28 +382,30 @@ fn scan_number(char c, reader rdr) -> token::token {\n             if (c == '3' && n == '2') {\n                 rdr.bump(); rdr.bump();\n                 ret token::LIT_MACH_FLOAT(util::common::ty_f32,\n-                                         rdr.add_str(float_str));\n+                    interner::intern[str](*rdr.get_interner(), float_str));\n             }\n             else if (c == '6' && n == '4') {\n                 rdr.bump(); rdr.bump();\n                 ret token::LIT_MACH_FLOAT(util::common::ty_f64,\n-                                         rdr.add_str(float_str));\n+                    interner::intern[str](*rdr.get_interner(), float_str));\n                 /* FIXME: if this is out of range for either a 32-bit or\n                    64-bit float, it won't be noticed till the back-end */\n             }\n         }\n         else {\n-            ret token::LIT_FLOAT(rdr.add_str(float_str));\n+            ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n+                                                       float_str));\n         }\n     }\n \n     auto maybe_exponent = scan_exponent(rdr);\n     alt(maybe_exponent) {\n         case(some[str](?s)) {\n-            ret token::LIT_FLOAT(rdr.add_str(dec_str + s));\n+            ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n+                                                       dec_str + s));\n         }\n         case(none[str]) {\n-                ret token::LIT_INT(accum_int);\n+            ret token::LIT_INT(accum_int);\n         }\n     }\n }\n@@ -471,7 +468,8 @@ fn next_token(reader rdr) -> token::token {\n         }\n \n         auto is_mod_name = c == ':' && rdr.next() == ':';\n-        ret token::IDENT(rdr.add_str(accum_str), is_mod_name);\n+        ret token::IDENT(interner::intern[str](*rdr.get_interner(),\n+                                               accum_str), is_mod_name);\n     }\n \n     if (is_dec_digit(c)) {\n@@ -671,7 +669,8 @@ fn next_token(reader rdr) -> token::token {\n                 rdr.bump();\n             }\n             rdr.bump();\n-            ret token::LIT_STR(rdr.add_str(accum_str));\n+            ret token::LIT_STR(interner::intern[str](*rdr.get_interner(),\n+                                                     accum_str));\n         }\n \n         case ('-') {\n@@ -801,7 +800,8 @@ fn read_block_comment(reader rdr) -> cmnt {\n \n fn gather_comments(session sess, str path) -> vec[cmnt] {\n     auto srdr = io::file_reader(path);\n-    auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u));\n+    auto itr = @interner::mk_interner[str](_str::hash, _str::eq);\n+    auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u), itr);\n     let vec[cmnt] comments = vec();\n     while (!rdr.is_eof()) {\n         while (true) {"}, {"sha": "d0b49b106371615b0e904ed8c7153dc48d41ba60", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "patch": "@@ -11,6 +11,7 @@ import util::common;\n import util::common::filename;\n import util::common::span;\n import util::common::new_str_hash;\n+import util::interner;\n \n tag restriction {\n     UNRESTRICTED;\n@@ -123,7 +124,7 @@ fn new_parser(session::session sess,\n             }\n \n             fn get_str(token::str_num i) -> str {\n-                ret rdr.get_str(i);\n+                ret interner::get[str](*rdr.get_interner(), i);\n             }\n \n             fn get_reader() -> lexer::reader {\n@@ -156,7 +157,8 @@ fn new_parser(session::session sess,\n     auto srdr = io::file_reader(path);\n     auto filemap = codemap::new_filemap(path, pos);\n     _vec::push[codemap::filemap](sess.get_codemap().files, filemap);\n-    auto rdr = lexer::new_reader(sess, srdr, filemap);\n+    auto itr = @interner::mk_interner[str](_str::hash, _str::eq);\n+    auto rdr = lexer::new_reader(sess, srdr, filemap, itr);\n     // Make sure npos points at first actual token:\n     lexer::consume_any_whitespace(rdr);\n     auto npos = rdr.get_chpos();"}, {"sha": "b72d41e7d24d3eb35c001ad3be58ff90932e3024", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea3d9eed6d110c3ac9707c9fce77f5727a7540d/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=3ea3d9eed6d110c3ac9707c9fce77f5727a7540d", "patch": "@@ -1,6 +1,7 @@\n import util::common::ty_mach;\n import util::common::ty_mach_to_str;\n import util::common::new_str_hash;\n+import util::interner;\n import std::_int;\n import std::_uint;\n import std::_str;\n@@ -139,13 +140,14 @@ fn to_str(lexer::reader r, token t) -> str {\n                 + \"_\" + ty_mach_to_str(tm);\n         }\n         case (LIT_MACH_FLOAT(?tm, ?s)) {\n-            ret r.get_str(s) + \"_\" + ty_mach_to_str(tm);\n+            ret interner::get[str](*r.get_interner(), s) + \"_\" +\n+                ty_mach_to_str(tm);\n         }\n \n-        case (LIT_FLOAT(?s)) { ret r.get_str(s); }\n+        case (LIT_FLOAT(?s)) { ret interner::get[str](*r.get_interner(), s); }\n         case (LIT_STR(?s)) {\n             // FIXME: escape.\n-            ret \"\\\"\" + r.get_str(s) + \"\\\"\";\n+            ret \"\\\"\" + interner::get[str](*r.get_interner(), s) + \"\\\"\";\n         }\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape.\n@@ -160,9 +162,7 @@ fn to_str(lexer::reader r, token t) -> str {\n         }\n \n         /* Name components */\n-        case (IDENT(?s, _)) {\n-            ret r.get_str(s);\n-        }\n+        case (IDENT(?s, _)) { ret interner::get[str](*r.get_interner(), s); }\n         case (IDX(?i)) { ret \"_\" + _int::to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n "}]}