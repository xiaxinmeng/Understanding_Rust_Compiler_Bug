{"sha": "287114a3b9ecc2062482271fabe608d8df0f0aa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NzExNGEzYjllY2MyMDYyNDgyMjcxZmFiZTYwOGQ4ZGYwZjBhYTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-12T22:09:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-12T22:09:21Z"}, "message": "Remove some transitional code", "tree": {"sha": "71a7acf5d06083b8bc09933830065b55e7d2eeb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71a7acf5d06083b8bc09933830065b55e7d2eeb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/287114a3b9ecc2062482271fabe608d8df0f0aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/287114a3b9ecc2062482271fabe608d8df0f0aa1", "html_url": "https://github.com/rust-lang/rust/commit/287114a3b9ecc2062482271fabe608d8df0f0aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/287114a3b9ecc2062482271fabe608d8df0f0aa1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa74edf1a00c12c9e37ccf9a43c68b0f1a453678", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa74edf1a00c12c9e37ccf9a43c68b0f1a453678", "html_url": "https://github.com/rust-lang/rust/commit/fa74edf1a00c12c9e37ccf9a43c68b0f1a453678"}], "stats": {"total": 179, "additions": 53, "deletions": 126}, "files": [{"sha": "47ff32a855b6c161767d2f9d2234dad8ba6b0bb8", "filename": "src/libcore/core.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=287114a3b9ecc2062482271fabe608d8df0f0aa1", "patch": "@@ -4,10 +4,6 @@\n \n use option::{Some, None};\n use Option = option::Option;\n-// XXX: snapshot rustc is generating code that wants lower-case option\n-#[cfg(stage0)]\n-use option = option::Option;\n-\n use result::{Result, Ok, Err};\n \n use Path = path::Path;"}, {"sha": "e0d0b322e3ea95e51966b93d20901785776064d8", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=287114a3b9ecc2062482271fabe608d8df0f0aa1", "patch": "@@ -268,13 +268,11 @@ mod ct {\n     }\n }\n \n-\n // Functions used by the fmt extension at runtime. For now there are a lot of\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n-// XXX Rename to rt after snapshot\n-mod rt2 {\n+mod rt {\n     const flag_none : u32 = 0u32;\n     const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n     const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n@@ -461,22 +459,21 @@ mod rt2 {\n     }\n }\n \n-// XXX remove after snappies\n-#[allow(non_camel_case_types)]\n-mod rt {\n+// XXX remove after snapshots\n+mod rt2 {\n     const flag_none : u32 = 0u32;\n     const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n     const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n     const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n     const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n     const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n \n-    enum count { count_is(int), count_implied, }\n-    enum ty { ty_default, ty_bits, ty_hex_upper, ty_hex_lower, ty_octal, }\n+    enum Count { CountIs(int), CountImplied, }\n+    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n-    type conv = {flags: u32, width: count, precision: count, ty: ty};\n+    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n-    pure fn conv_int(cv: conv, i: int) -> ~str {\n+    pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -487,47 +484,47 @@ mod rt {\n                 unchecked { str::unshift_char(s, ' ') };\n             }\n         }\n-        return unchecked { pad(cv, s, pad_signed) };\n+        return unchecked { pad(cv, s, PadSigned) };\n     }\n-    pure fn conv_uint(cv: conv, u: uint) -> ~str {\n+    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n-              ty_default => uint_to_str_prec(u, 10u, prec),\n-              ty_hex_lower => uint_to_str_prec(u, 16u, prec),\n-              ty_hex_upper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n-              ty_bits => uint_to_str_prec(u, 2u, prec),\n-              ty_octal => uint_to_str_prec(u, 8u, prec)\n+              TyDefault => uint_to_str_prec(u, 10u, prec),\n+              TyHexLower => uint_to_str_prec(u, 16u, prec),\n+              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n+              TyBits => uint_to_str_prec(u, 2u, prec),\n+              TyOctal => uint_to_str_prec(u, 8u, prec)\n             };\n-        return unchecked { pad(cv, rs, pad_unsigned) };\n+        return unchecked { pad(cv, rs, PadUnsigned) };\n     }\n-    pure fn conv_bool(cv: conv, b: bool) -> ~str {\n+    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pure fn conv_char(cv: conv, c: char) -> ~str {\n+    pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unchecked { pad(cv, s, pad_nozero) };\n+        return unchecked { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: conv, s: &str) -> ~str {\n+    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n-          count_implied => s.to_unique(),\n-          count_is(max) => if max as uint < str::char_len(s) {\n+          CountImplied => s.to_unique(),\n+          CountIs(max) => if max as uint < str::char_len(s) {\n             str::substr(s, 0u, max as uint)\n           } else {\n             s.to_unique()\n           }\n         };\n-        return unchecked { pad(cv, unpadded, pad_nozero) };\n+        return unchecked { pad(cv, unpadded, PadNozero) };\n     }\n-    pure fn conv_float(cv: conv, f: float) -> ~str {\n+    pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n-              count_is(c) => (float::to_str_exact, c as uint),\n-              count_implied => (float::to_str, 6u)\n+              CountIs(c) => (float::to_str_exact, c as uint),\n+              CountImplied => (float::to_str, 6u)\n         };\n         let mut s = unchecked { to_str(f, digits) };\n         if 0.0 <= f {\n@@ -537,9 +534,9 @@ mod rt {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unchecked { pad(cv, s, pad_float) };\n+        return unchecked { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: conv, v: T) -> ~str {\n+    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n         let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n@@ -568,35 +565,35 @@ mod rt {\n                 } else { move s }\n             };\n     }\n-    pure fn get_int_precision(cv: conv) -> uint {\n+    pure fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n-              count_is(c) => c as uint,\n-              count_implied => 1u\n+              CountIs(c) => c as uint,\n+              CountImplied => 1u\n             };\n     }\n \n-    enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n+    enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-    impl pad_mode: Eq {\n-        pure fn eq(&&other: pad_mode) -> bool {\n+    impl PadMode: Eq {\n+        pure fn eq(&&other: PadMode) -> bool {\n             match (self, other) {\n-                (pad_signed, pad_signed) => true,\n-                (pad_unsigned, pad_unsigned) => true,\n-                (pad_nozero, pad_nozero) => true,\n-                (pad_float, pad_float) => true,\n-                (pad_signed, _) => false,\n-                (pad_unsigned, _) => false,\n-                (pad_nozero, _) => false,\n-                (pad_float, _) => false\n+                (PadSigned, PadSigned) => true,\n+                (PadUnsigned, PadUnsigned) => true,\n+                (PadNozero, PadNozero) => true,\n+                (PadFloat, PadFloat) => true,\n+                (PadSigned, _) => false,\n+                (PadUnsigned, _) => false,\n+                (PadNozero, _) => false,\n+                (PadFloat, _) => false\n             }\n         }\n-        pure fn ne(&&other: pad_mode) -> bool { !self.eq(other) }\n+        pure fn ne(&&other: PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: conv, &s: ~str, mode: pad_mode) -> ~str {\n+    fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n         let uwidth : uint = match cv.width {\n-          count_implied => return copy s,\n-          count_is(width) => {\n+          CountImplied => return copy s,\n+          CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n@@ -610,17 +607,17 @@ mod rt {\n             return s + padstr;\n         }\n         let {might_zero_pad, signed} = match mode {\n-          pad_nozero => {might_zero_pad:false, signed:false},\n-          pad_signed => {might_zero_pad:true,  signed:true },\n-          pad_float => {might_zero_pad:true,  signed:true},\n-          pad_unsigned => {might_zero_pad:true,  signed:false}\n+          PadNozero => {might_zero_pad:false, signed:false},\n+          PadSigned => {might_zero_pad:true,  signed:true },\n+          PadFloat => {might_zero_pad:true,  signed:true},\n+          PadUnsigned => {might_zero_pad:true,  signed:false}\n         };\n-        pure fn have_precision(cv: conv) -> bool {\n-            return match cv.precision { count_implied => false, _ => true };\n+        pure fn have_precision(cv: Conv) -> bool {\n+            return match cv.precision { CountImplied => false, _ => true };\n         }\n         let zero_padding = {\n             if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-                (!have_precision(cv) || mode == pad_float) {\n+                (!have_precision(cv) || mode == PadFloat) {\n                 padchar = '0';\n                 true\n             } else {\n@@ -650,7 +647,6 @@ mod rt {\n     }\n }\n \n-\n #[cfg(test)]\n mod test {\n     #[test]"}, {"sha": "0a84d2f0d636dfa772df364fa8be61adce65e178", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=287114a3b9ecc2062482271fabe608d8df0f0aa1", "patch": "@@ -101,14 +101,6 @@ export recv_one, try_recv_one, send_one, try_send_one;\n // Functions used by the protocol compiler\n export rt;\n \n-// XXX remove me\n-#[cfg(stage0)]\n-export has_buffer, buffer_header, packet;\n-#[cfg(stage0)]\n-export recv_packet_buffered, send_packet_buffered;\n-#[cfg(stage0)]\n-export send_packet, recv_packet, buffer_header;\n-\n #[doc(hidden)]\n const SPIN_COUNT: uint = 0;\n \n@@ -146,10 +138,6 @@ fn BufferHeader() -> BufferHeader{\n     }\n }\n \n-// XXX remove me\n-#[cfg(stage0)]\n-fn buffer_header() -> BufferHeader { BufferHeader() }\n-\n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n type Buffer<T: Send> = {\n@@ -212,11 +200,6 @@ type Packet<T: Send> = {\n     mut payload: Option<T>,\n };\n \n-// XXX remove me\n-#[cfg(stage0)]\n-#[allow(non_camel_case_types)]\n-type packet<T: Send> = Packet<T>;\n-\n #[doc(hidden)]\n trait HasBuffer {\n     // XXX This should not have a trailing underscore\n@@ -229,20 +212,6 @@ impl<T: Send> Packet<T>: HasBuffer {\n     }\n }\n \n-#[cfg(stage0)] // XXX remove me\n-#[doc(hidden)]\n-#[allow(non_camel_case_types)]\n-trait has_buffer {\n-    fn set_buffer(b: *libc::c_void);\n-}\n-\n-#[cfg(stage0)] // XXX remove me\n-impl<T: Send> packet<T>: has_buffer {\n-    fn set_buffer(b: *libc::c_void) {\n-        self.header.buffer = b;\n-    }\n-}\n-\n #[doc(hidden)]\n fn mk_packet<T: Send>() -> Packet<T> {\n     {\n@@ -768,17 +737,6 @@ fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n-// XXX remove me\n-#[cfg(stage0)]\n-#[allow(non_camel_case_types)]\n-type send_packet<T: Send> = SendPacket<T>;\n-\n-// XXX remove me\n-#[cfg(stage0)]\n-fn send_packet<T: Send>(p: *packet<T>) -> SendPacket<T> {\n-    SendPacket(p)\n-}\n-\n struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n@@ -837,12 +795,6 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n     }\n }\n \n-// XXX remove me\n-#[cfg(stage0)]\n-#[allow(non_camel_case_types)]\n-type send_packet_buffered<T: Send, Tbuffer: Send> =\n-    SendPacketBuffered<T, Tbuffer>;\n-\n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n@@ -852,17 +804,6 @@ fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n \n-// XXX remove me\n-#[cfg(stage0)]\n-#[allow(non_camel_case_types)]\n-type recv_packet<T: Send> = RecvPacket<T>;\n-\n-// XXX remove me\n-#[cfg(stage0)]\n-fn recv_packet<T: Send>(p: *packet<T>) -> RecvPacket<T> {\n-    RecvPacket(p)\n-}\n-\n struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n@@ -921,12 +862,6 @@ fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     }\n }\n \n-// XXX remove me\n-#[cfg(stage0)]\n-#[allow(non_camel_case_types)]\n-type recv_packet_buffered<T: Send, Tbuffer: Send> =\n-    RecvPacketBuffered<T, Tbuffer>;\n-\n #[doc(hidden)]\n fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();"}, {"sha": "4c5435d11236fbe8bc906f9b6059e9fd44133342", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287114a3b9ecc2062482271fabe608d8df0f0aa1/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=287114a3b9ecc2062482271fabe608d8df0f0aa1", "patch": "@@ -39,7 +39,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n         let intr = _cx.parse_sess().interner;\n-        return ~[intr.intern(@~\"extfmt\"), intr.intern(@~\"rt2\"),\n+        return ~[intr.intern(@~\"extfmt\"), intr.intern(@~\"rt\"),\n                  intr.intern(ident)];\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span, nm: @~str) -> @ast::expr {"}]}