{"sha": "4ab704c57df52569eaf6feec22a38d80d1b85bea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYjcwNGM1N2RmNTI1NjllYWY2ZmVlYzIyYTM4ZDgwZDFiODViZWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-20T14:05:30Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-20T14:05:30Z"}, "message": "implement more intrinsics", "tree": {"sha": "bb060c92d5a55a3c369bae801e6cde72a806a7fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb060c92d5a55a3c369bae801e6cde72a806a7fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ab704c57df52569eaf6feec22a38d80d1b85bea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX4UIqAAoJEFbW7qD8Z6xGsd8QAIi4o2em/6zdaqHTUd4T1Koa\nG45je/6Kk6zsrgdkitZGxH94KtWaF0RnLR8wJK468w8k6VebMl3quiLuDpaHGBDv\nDocN/CrmgIk55IO6jArSiVaZ0bYugr9Y4SYiaMfrf0gW7DpIY906OWInfLK2AI4f\n8jW7bonBcQDQ7Vh+C0Ui7AnPUyctEz47G1WEn5MhesCYTlL8gIVtV6fYdE2A1QjX\nSUrhimPt6bABq3ssFuKyc83GSuHKnwK4AxSAo32zZGpKHj0449F0fLb2hAT/a8Cu\nODxdN46E3HLjlk7x8TRk64cR72zzumMtFNzyFCCQQsQR3db1DZpdNV20MlSmqEjk\nj7GtPyYZ/U0bOSzXgbr9+uus7GSQubg+Yr1GzrAQ81KOSkccll+nyWxylEUSkqmg\nSyVhDrj4FWBU63gDs0nL4A61FnwDqs8yLnYZJxaqKtdASnNa2Eg+2834XuYzB5/n\nvpUJHLzvosN37UOn7EATEzBNp8epkO0Rdg0ka2QoFeq5uqa8zCXw2ljmi76Jqg49\nOy6rgw/IYP8esbhUgRFT0+Vx04zMbzeqYs3PswsVnr59kHER1+A8L0gnUr4sRQbH\n8QU5JsFlcpUXwQ9kPKnF1XK+WBJARh02UwaNE99kudUHRsK7bOn7BwRoF5PrWRtB\nHQuxUXqgIKnX3a/u9thc\n=XP7N\n-----END PGP SIGNATURE-----", "payload": "tree bb060c92d5a55a3c369bae801e6cde72a806a7fb\nparent 8df6e7275ab3530eb5c35768a3a82c7bf7fef515\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474380330 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474380330 +0200\n\nimplement more intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab704c57df52569eaf6feec22a38d80d1b85bea", "html_url": "https://github.com/rust-lang/rust/commit/4ab704c57df52569eaf6feec22a38d80d1b85bea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ab704c57df52569eaf6feec22a38d80d1b85bea/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8df6e7275ab3530eb5c35768a3a82c7bf7fef515", "url": "https://api.github.com/repos/rust-lang/rust/commits/8df6e7275ab3530eb5c35768a3a82c7bf7fef515", "html_url": "https://github.com/rust-lang/rust/commit/8df6e7275ab3530eb5c35768a3a82c7bf7fef515"}], "stats": {"total": 399, "additions": 253, "deletions": 146}, "files": [{"sha": "e2381d59e2cd64a0376ca31b09e44d6df819537a", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/4ab704c57df52569eaf6feec22a38d80d1b85bea/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab704c57df52569eaf6feec22a38d80d1b85bea/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=4ab704c57df52569eaf6feec22a38d80d1b85bea", "patch": "@@ -0,0 +1,251 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::repr as mir;\n+use rustc::ty::layout::Layout;\n+use rustc::ty::subst::Substs;\n+use rustc::ty;\n+\n+use error::{EvalError, EvalResult};\n+use memory::Pointer;\n+use interpreter::EvalContext;\n+use primval;\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(super) fn call_intrinsic(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Pointer,\n+        dest_layout: &'tcx Layout,\n+    ) -> EvalResult<'tcx, ()> {\n+        // TODO(solson): We can probably remove this _to_ptr easily.\n+        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n+            .map(|arg| self.eval_operand_to_ptr(arg))\n+            .collect();\n+        let args_ptrs = args_res?;\n+        let pointer_size = self.memory.pointer_size();\n+\n+        match &self.tcx.item_name(def_id).as_str()[..] {\n+            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n+            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n+            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n+\n+            \"arith_offset\" => {\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let offset = self.memory.read_int(args_ptrs[1], pointer_size)?;\n+                let new_ptr = ptr.offset(offset as isize);\n+                self.memory.write_ptr(dest, new_ptr)?;\n+            }\n+\n+            \"assume\" => {\n+                if !self.memory.read_bool(args_ptrs[0])? {\n+                    return Err(EvalError::AssumptionNotHeld);\n+                }\n+            }\n+\n+            \"breakpoint\" => unimplemented!(), // halt miri\n+\n+            \"copy\" |\n+            \"copy_nonoverlapping\" => {\n+                // FIXME: check whether overlapping occurs\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let elem_align = self.type_align(elem_ty);\n+                let src = self.memory.read_ptr(args_ptrs[0])?;\n+                let dest = self.memory.read_ptr(args_ptrs[1])?;\n+                let count = self.memory.read_isize(args_ptrs[2])?;\n+                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n+            }\n+\n+            \"ctpop\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n+                self.memory.write_uint(dest, num.into(), elem_size)?;\n+            }\n+\n+            \"ctlz\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_size = self.type_size(elem_ty);\n+                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n+                self.memory.write_uint(dest, num.into(), elem_size)?;\n+            }\n+\n+            \"discriminant_value\" => {\n+                let ty = substs.type_at(0);\n+                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n+                self.memory.write_uint(dest, discr_val, 8)?;\n+            }\n+\n+            \"fabsf32\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                self.memory.write_f32(dest, f.abs())?;\n+            }\n+\n+            \"fabsf64\" => {\n+                let f = self.memory.read_f64(args_ptrs[0])?;\n+                self.memory.write_f64(dest, f.abs())?;\n+            }\n+\n+            \"fadd_fast\" => {\n+                let ty = substs.type_at(0);\n+                let a = self.read_primval(args_ptrs[0], ty)?;\n+                let b = self.read_primval(args_ptrs[0], ty)?;\n+                let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n+                self.memory.write_primval(dest, result.0)?;\n+            }\n+\n+            \"likely\" |\n+            \"unlikely\" |\n+            \"forget\" => {}\n+\n+            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n+\n+            \"min_align_of\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_align = self.type_align(elem_ty);\n+                self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n+            }\n+\n+            \"pref_align_of\" => {\n+                let ty = substs.type_at(0);\n+                let layout = self.type_layout(ty);\n+                let align = layout.align(&self.tcx.data_layout).pref();\n+                self.memory.write_uint(dest, align, pointer_size)?;\n+            }\n+\n+            \"move_val_init\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], ptr, ty)?;\n+            }\n+\n+            \"needs_drop\" => {\n+                let ty = substs.type_at(0);\n+                self.memory.write_bool(dest, self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment()))?;\n+            }\n+\n+            \"offset\" => {\n+                let pointee_ty = substs.type_at(0);\n+                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let ptr_arg = args_ptrs[0];\n+                let offset = self.memory.read_isize(args_ptrs[1])?;\n+\n+                match self.memory.read_ptr(ptr_arg) {\n+                    Ok(ptr) => {\n+                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n+                        self.memory.write_ptr(dest, result_ptr)?;\n+                    }\n+                    Err(EvalError::ReadBytesAsPointer) => {\n+                        let addr = self.memory.read_isize(ptr_arg)?;\n+                        let result_addr = addr + offset * pointee_size as i64;\n+                        self.memory.write_isize(dest, result_addr)?;\n+                    }\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            \"overflowing_sub\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"overflowing_mul\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"overflowing_add\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"powif32\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let i = self.memory.read_int(args_ptrs[1], 4)?;\n+                self.memory.write_f32(dest, f.powi(i as i32))?;\n+            }\n+\n+            \"powif64\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                let i = self.memory.read_int(args_ptrs[1], 4)?;\n+                self.memory.write_f32(dest, f.powi(i as i32))?;\n+            }\n+\n+            \"sqrtf32\" => {\n+                let f = self.memory.read_f32(args_ptrs[0])?;\n+                self.memory.write_f32(dest, f.sqrt())?;\n+            }\n+\n+            \"sqrtf64\" => {\n+                let f = self.memory.read_f64(args_ptrs[0])?;\n+                self.memory.write_f64(dest, f.sqrt())?;\n+            }\n+\n+            \"size_of\" => {\n+                let ty = substs.type_at(0);\n+                let size = self.type_size(ty) as u64;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n+            }\n+\n+            \"size_of_val\" => {\n+                let ty = substs.type_at(0);\n+                if self.type_is_sized(ty) {\n+                    let size = self.type_size(ty) as u64;\n+                    self.memory.write_uint(dest, size, pointer_size)?;\n+                } else {\n+                    match ty.sty {\n+                        ty::TySlice(_) | ty::TyStr => {\n+                            let elem_ty = ty.sequence_element_type(self.tcx);\n+                            let elem_size = self.type_size(elem_ty) as u64;\n+                            let ptr_size = self.memory.pointer_size() as isize;\n+                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n+                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n+                        }\n+\n+                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n+                    }\n+                }\n+            }\n+            // FIXME: wait for eval_operand_to_ptr to be gone\n+            /*\n+            \"type_name\" => {\n+                let ty = substs.type_at(0);\n+                let ty_name = ty.to_string();\n+                let s = self.str_to_value(&ty_name)?;\n+                self.memory.write_ptr(dest, s)?;\n+            }*/\n+            \"type_id\" => {\n+                let ty = substs.type_at(0);\n+                let n = self.tcx.type_id_hash(ty);\n+                self.memory.write_uint(dest, n, 8)?;\n+            }\n+\n+            \"transmute\" => {\n+                let ty = substs.type_at(0);\n+                self.move_(args_ptrs[0], dest, ty)?;\n+            }\n+\n+            \"try\" => unimplemented!(),\n+\n+            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n+\n+            \"volatile_load\" => {\n+                let ty = substs.type_at(0);\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(ptr, dest, ty)?;\n+            }\n+\n+            \"volatile_store\" => {\n+                let ty = substs.type_at(0);\n+                let dest = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], dest, ty)?;\n+            }\n+\n+            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        Ok(())\n+    }\n+}"}, {"sha": "600bccfa404cbca26255d1c2c1dac82e36ecb285", "filename": "src/interpreter/terminator/mod.rs", "status": "renamed", "additions": 2, "deletions": 146, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4ab704c57df52569eaf6feec22a38d80d1b85bea/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab704c57df52569eaf6feec22a38d80d1b85bea/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=4ab704c57df52569eaf6feec22a38d80d1b85bea", "patch": "@@ -15,6 +15,8 @@ use error::{EvalError, EvalResult};\n use memory::Pointer;\n use super::{EvalContext, IntegerExt, StackPopCleanup};\n \n+mod intrinsics;\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n@@ -270,152 +272,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n \n-    fn call_intrinsic(\n-        &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n-        dest: Pointer,\n-        dest_layout: &'tcx Layout,\n-    ) -> EvalResult<'tcx, ()> {\n-        // TODO(solson): We can probably remove this _to_ptr easily.\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand_to_ptr(arg))\n-            .collect();\n-        let args_ptrs = args_res?;\n-        let pointer_size = self.memory.pointer_size();\n-\n-        match &self.tcx.item_name(def_id).as_str()[..] {\n-            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n-            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n-            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n-\n-            \"assume\" => {\n-                if !self.memory.read_bool(args_ptrs[0])? {\n-                    return Err(EvalError::AssumptionNotHeld);\n-                }\n-            }\n-\n-            \"copy_nonoverlapping\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let elem_align = self.type_align(elem_ty);\n-                let src = self.memory.read_ptr(args_ptrs[0])?;\n-                let dest = self.memory.read_ptr(args_ptrs[1])?;\n-                let count = self.memory.read_isize(args_ptrs[2])?;\n-                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n-            }\n-\n-            \"ctpop\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.count_ones();\n-                self.memory.write_uint(dest, num.into(), elem_size)?;\n-            }\n-\n-            \"ctlz\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n-                let num = self.memory.read_uint(args_ptrs[0], elem_size)?.leading_zeros();\n-                self.memory.write_uint(dest, num.into(), elem_size)?;\n-            }\n-\n-            \"discriminant_value\" => {\n-                let ty = substs.type_at(0);\n-                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.memory.write_uint(dest, discr_val, 8)?;\n-            }\n-\n-            \"forget\" => {}\n-\n-            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n-\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = self.type_align(elem_ty);\n-                self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n-            }\n-\n-            \"move_val_init\" => {\n-                let ty = substs.type_at(0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], ptr, ty)?;\n-            }\n-\n-            \"offset\" => {\n-                let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args_ptrs[0];\n-                let offset = self.memory.read_isize(args_ptrs[1])?;\n-\n-                match self.memory.read_ptr(ptr_arg) {\n-                    Ok(ptr) => {\n-                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                        self.memory.write_ptr(dest, result_ptr)?;\n-                    }\n-                    Err(EvalError::ReadBytesAsPointer) => {\n-                        let addr = self.memory.read_isize(ptr_arg)?;\n-                        let result_addr = addr + offset * pointee_size as i64;\n-                        self.memory.write_isize(dest, result_addr)?;\n-                    }\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            \"overflowing_sub\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"overflowing_mul\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"overflowing_add\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = self.type_size(ty) as u64;\n-                self.memory.write_uint(dest, size, pointer_size)?;\n-            }\n-\n-            \"size_of_val\" => {\n-                let ty = substs.type_at(0);\n-                if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, pointer_size)?;\n-                } else {\n-                    match ty.sty {\n-                        ty::TySlice(_) | ty::TyStr => {\n-                            let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n-                            let ptr_size = self.memory.pointer_size() as isize;\n-                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n-                        }\n-\n-                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n-                    }\n-                }\n-            }\n-\n-            \"transmute\" => {\n-                let ty = substs.type_at(0);\n-                self.move_(args_ptrs[0], dest, ty)?;\n-            }\n-            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n-\n-            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n-    }\n-\n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,", "previous_filename": "src/interpreter/terminator.rs"}]}