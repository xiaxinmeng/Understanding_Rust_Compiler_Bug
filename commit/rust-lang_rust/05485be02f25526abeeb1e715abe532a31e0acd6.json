{"sha": "05485be02f25526abeeb1e715abe532a31e0acd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDg1YmUwMmYyNTUyNmFiZWViMWU3MTVhYmU1MzJhMzFlMGFjZDY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-25T06:11:01Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-25T06:11:01Z"}, "message": "Rollup merge of #31793 - alexcrichton:add-real-option-gating, r=nikomatsakis\n\nThis commit adds support for *truly* unstable options in the compiler, as well\nas adding warnings for the start of the deprecation path of\nunstable-but-not-really options. Specifically, the following behavior is now in\nplace for handling unstable options:\n\n* As before, an unconditional error is emitted if an unstable option is passed\n  and the `-Z unstable-options` flag is not present. Note that passing another\n  `-Z` flag does not require passing `-Z unstable-options` as well.\n* New flags added to the compiler will be in the `Unstable` category as opposed\n  to the `UnstableButNotReally` category which means they will unconditionally\n  emit an error when used on stable.\n* All current flags are in a category where they will emit warnings when used\n  that the option will soon be a hard error.\n\nAlso as before, it is intended that `-Z` is akin to `#![feature]` in a crate\nwhere it is required to unlock unstable functionality. A nightly compiler which\nis used without any `-Z` flags should only be exercising stable behavior.", "tree": {"sha": "16d12c84532abaaa22725b89da5ea09347877da4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16d12c84532abaaa22725b89da5ea09347877da4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05485be02f25526abeeb1e715abe532a31e0acd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05485be02f25526abeeb1e715abe532a31e0acd6", "html_url": "https://github.com/rust-lang/rust/commit/05485be02f25526abeeb1e715abe532a31e0acd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05485be02f25526abeeb1e715abe532a31e0acd6/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a48f95879d4a6a62176ad37910782ede9f24f30f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a48f95879d4a6a62176ad37910782ede9f24f30f", "html_url": "https://github.com/rust-lang/rust/commit/a48f95879d4a6a62176ad37910782ede9f24f30f"}, {"sha": "128283347086ff307b39c8c848d0831c6dcf576a", "url": "https://api.github.com/repos/rust-lang/rust/commits/128283347086ff307b39c8c848d0831c6dcf576a", "html_url": "https://github.com/rust-lang/rust/commit/128283347086ff307b39c8c848d0831c6dcf576a"}], "stats": {"total": 331, "additions": 215, "deletions": 116}, "files": [{"sha": "ea08bf021fbba3b464c1ce50c0ecb9cb8cee0542", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 117, "deletions": 64, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/05485be02f25526abeeb1e715abe532a31e0acd6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05485be02f25526abeeb1e715abe532a31e0acd6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=05485be02f25526abeeb1e715abe532a31e0acd6", "patch": "@@ -749,24 +749,20 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     }\n }\n \n-/// Returns the \"short\" subset of the stable rustc command line options.\n-pub fn short_optgroups() -> Vec<getopts::OptGroup> {\n-    rustc_short_optgroups().into_iter()\n-        .filter(|g|g.is_stable())\n-        .map(|g|g.opt_group)\n-        .collect()\n-}\n-\n-/// Returns all of the stable rustc command line options.\n-pub fn optgroups() -> Vec<getopts::OptGroup> {\n-    rustc_optgroups().into_iter()\n-        .filter(|g|g.is_stable())\n-        .map(|g|g.opt_group)\n-        .collect()\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum OptionStability { Stable, Unstable }\n+pub enum OptionStability {\n+    Stable,\n+\n+    // FIXME: historically there were some options which were either `-Z` or\n+    //        required the `-Z unstable-options` flag, which were all intended\n+    //        to be unstable. Unfortunately we didn't actually gate usage of\n+    //        these options on the stable compiler, so we still allow them there\n+    //        today. There are some warnings printed out about this in the\n+    //        driver.\n+    UnstableButNotReally,\n+\n+    Unstable,\n+}\n \n #[derive(Clone, PartialEq, Eq)]\n pub struct RustcOptGroup {\n@@ -783,9 +779,17 @@ impl RustcOptGroup {\n         RustcOptGroup { opt_group: g, stability: OptionStability::Stable }\n     }\n \n+    #[allow(dead_code)] // currently we have no \"truly unstable\" options\n     fn unstable(g: getopts::OptGroup) -> RustcOptGroup {\n         RustcOptGroup { opt_group: g, stability: OptionStability::Unstable }\n     }\n+\n+    fn unstable_bnr(g: getopts::OptGroup) -> RustcOptGroup {\n+        RustcOptGroup {\n+            opt_group: g,\n+            stability: OptionStability::UnstableButNotReally,\n+        }\n+    }\n }\n \n // The `opt` local module holds wrappers around the `getopts` API that\n@@ -807,69 +811,102 @@ mod opt {\n \n     fn stable(g: getopts::OptGroup) -> R { RustcOptGroup::stable(g) }\n     fn unstable(g: getopts::OptGroup) -> R { RustcOptGroup::unstable(g) }\n+    fn unstable_bnr(g: getopts::OptGroup) -> R { RustcOptGroup::unstable_bnr(g) }\n \n-    // FIXME (pnkfelix): We default to stable since the current set of\n-    // options is defacto stable.  However, it would be good to revise the\n-    // code so that a stable option is the thing that takes extra effort\n-    // to encode.\n-\n-    pub fn     opt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optopt(a, b, c, d)) }\n-    pub fn   multi(a: S, b: S, c: S, d: S) -> R { stable(getopts::optmulti(a, b, c, d)) }\n-    pub fn    flag(a: S, b: S, c: S)       -> R { stable(getopts::optflag(a, b, c)) }\n-    pub fn flagopt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optflagopt(a, b, c, d)) }\n-    pub fn flagmulti(a: S, b: S, c: S)     -> R { stable(getopts::optflagmulti(a, b, c)) }\n+    pub fn opt_s(a: S, b: S, c: S, d: S) -> R {\n+        stable(getopts::optopt(a, b, c, d))\n+    }\n+    pub fn multi_s(a: S, b: S, c: S, d: S) -> R {\n+        stable(getopts::optmulti(a, b, c, d))\n+    }\n+    pub fn flag_s(a: S, b: S, c: S) -> R {\n+        stable(getopts::optflag(a, b, c))\n+    }\n+    pub fn flagopt_s(a: S, b: S, c: S, d: S) -> R {\n+        stable(getopts::optflagopt(a, b, c, d))\n+    }\n+    pub fn flagmulti_s(a: S, b: S, c: S) -> R {\n+        stable(getopts::optflagmulti(a, b, c))\n+    }\n \n+    pub fn opt(a: S, b: S, c: S, d: S) -> R {\n+        unstable(getopts::optopt(a, b, c, d))\n+    }\n+    pub fn multi(a: S, b: S, c: S, d: S) -> R {\n+        unstable(getopts::optmulti(a, b, c, d))\n+    }\n+    pub fn flag(a: S, b: S, c: S) -> R {\n+        unstable(getopts::optflag(a, b, c))\n+    }\n+    pub fn flagopt(a: S, b: S, c: S, d: S) -> R {\n+        unstable(getopts::optflagopt(a, b, c, d))\n+    }\n+    pub fn flagmulti(a: S, b: S, c: S) -> R {\n+        unstable(getopts::optflagmulti(a, b, c))\n+    }\n \n-    pub fn     opt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optopt(a, b, c, d)) }\n-    pub fn   multi_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optmulti(a, b, c, d)) }\n-    pub fn    flag_u(a: S, b: S, c: S)       -> R { unstable(getopts::optflag(a, b, c)) }\n-    pub fn flagopt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optflagopt(a, b, c, d)) }\n-    pub fn flagmulti_u(a: S, b: S, c: S)     -> R { unstable(getopts::optflagmulti(a, b, c)) }\n+    // Do not use these functions for any new options added to the compiler, all\n+    // new options should use the `*_u` variants above to be truly unstable.\n+    pub fn opt_ubnr(a: S, b: S, c: S, d: S) -> R {\n+        unstable_bnr(getopts::optopt(a, b, c, d))\n+    }\n+    pub fn multi_ubnr(a: S, b: S, c: S, d: S) -> R {\n+        unstable_bnr(getopts::optmulti(a, b, c, d))\n+    }\n+    pub fn flag_ubnr(a: S, b: S, c: S) -> R {\n+        unstable_bnr(getopts::optflag(a, b, c))\n+    }\n+    pub fn flagopt_ubnr(a: S, b: S, c: S, d: S) -> R {\n+        unstable_bnr(getopts::optflagopt(a, b, c, d))\n+    }\n+    pub fn flagmulti_ubnr(a: S, b: S, c: S) -> R {\n+        unstable_bnr(getopts::optflagmulti(a, b, c))\n+    }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n /// including metadata for each option, such as whether the option is\n /// part of the stable long-term interface for rustc.\n pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n     vec![\n-        opt::flag(\"h\", \"help\", \"Display this message\"),\n-        opt::multi(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n-        opt::multi(\"L\", \"\",   \"Add a directory to the library search path\",\n+        opt::flag_s(\"h\", \"help\", \"Display this message\"),\n+        opt::multi_s(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n+        opt::multi_s(\"L\", \"\",   \"Add a directory to the library search path\",\n                    \"[KIND=]PATH\"),\n-        opt::multi(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n+        opt::multi_s(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n                              library NAME. The optional KIND can be one of,\n                              static, dylib, or framework. If omitted, dylib is\n                              assumed.\", \"[KIND=]NAME\"),\n-        opt::multi(\"\", \"crate-type\", \"Comma separated list of types of crates\n+        opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n                    \"[bin|lib|rlib|dylib|staticlib]\"),\n-        opt::opt(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n+        opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n-        opt::multi(\"\", \"emit\", \"Comma separated list of types of output for \\\n+        opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\\n                               the compiler to emit\",\n                  \"[asm|llvm-bc|llvm-ir|obj|link|dep-info]\"),\n-        opt::multi(\"\", \"print\", \"Comma separated list of compiler information to \\\n+        opt::multi_s(\"\", \"print\", \"Comma separated list of compiler information to \\\n                                print on stdout\",\n                  \"[crate-name|file-names|sysroot|target-list]\"),\n-        opt::flagmulti(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n-        opt::flagmulti(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n-        opt::opt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n-        opt::opt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n+        opt::flagmulti_s(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+        opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n+        opt::opt_s(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n+        opt::opt_s(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n                                 in <dir>\", \"DIR\"),\n-        opt::opt(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n+        opt::opt_s(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n                                message\", \"OPT\"),\n-        opt::flag(\"\", \"test\", \"Build a test harness\"),\n-        opt::opt(\"\", \"target\", \"Target triple for which the code is compiled\", \"TARGET\"),\n-        opt::multi(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n-        opt::multi(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n-        opt::multi(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n-        opt::multi(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n-        opt::multi(\"\", \"cap-lints\", \"Set the most restrictive lint level. \\\n+        opt::flag_s(\"\", \"test\", \"Build a test harness\"),\n+        opt::opt_s(\"\", \"target\", \"Target triple for which the code is compiled\", \"TARGET\"),\n+        opt::multi_s(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n+        opt::multi_s(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n+        opt::multi_s(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n+        opt::multi_s(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n+        opt::multi_s(\"\", \"cap-lints\", \"Set the most restrictive lint level. \\\n                                      More restrictive lints are capped at this \\\n                                      level\", \"LEVEL\"),\n-        opt::multi(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n-        opt::flag(\"V\", \"version\", \"Print version info and exit\"),\n-        opt::flag(\"v\", \"verbose\", \"Use verbose output\"),\n+        opt::multi_s(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n+        opt::flag_s(\"V\", \"version\", \"Print version info and exit\"),\n+        opt::flag_s(\"v\", \"verbose\", \"Use verbose output\"),\n     ]\n }\n \n@@ -879,31 +916,41 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     let mut opts = rustc_short_optgroups();\n     opts.extend_from_slice(&[\n-        opt::multi(\"\", \"extern\", \"Specify where an external rust library is \\\n+        opt::multi_s(\"\", \"extern\", \"Specify where an external rust library is \\\n                                 located\",\n                  \"NAME=PATH\"),\n-        opt::opt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n-        opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        opt::opt_u(\"\", \"error-format\", \"How errors and other messages are produced\", \"human|json\"),\n-        opt::opt(\"\", \"color\", \"Configure coloring of output:\n+        opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n+        opt::multi_ubnr(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n+        opt::opt_ubnr(\"\", \"error-format\",\n+                      \"How errors and other messages are produced\",\n+                      \"human|json\"),\n+        opt::opt_s(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n \n-        opt::flagopt_u(\"\", \"pretty\",\n+        opt::flagopt_ubnr(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n                    `expanded` (crates expanded), or\n                    `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n                  \"TYPE\"),\n-        opt::flagopt_u(\"\", \"unpretty\",\n+        opt::flagopt_ubnr(\"\", \"unpretty\",\n                      \"Present the input source, unstable (and less-pretty) variants;\n                       valid types are any of the types for `--pretty`, as well as:\n                       `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n                       `everybody_loops` (all function bodies replaced with `loop {}`),\n                       `hir` (the HIR), `hir,identified`, or\n                       `hir,typed` (HIR with types for each node).\",\n                      \"TYPE\"),\n+\n+        // new options here should **not** use the `_ubnr` functions, all new\n+        // unstable options should use the short variants to indicate that they\n+        // are truly unstable. All `_ubnr` flags are just that way because they\n+        // were so historically.\n+        //\n+        // You may also wish to keep this comment at the bottom of this list to\n+        // ensure that others see it.\n     ]);\n     opts\n }\n@@ -1242,15 +1289,21 @@ impl fmt::Display for CrateType {\n #[cfg(test)]\n mod tests {\n     use middle::cstore::DummyCrateStore;\n-    use session::config::{build_configuration, optgroups, build_session_options};\n+    use session::config::{build_configuration, build_session_options};\n     use session::build_session;\n \n     use std::rc::Rc;\n-    use getopts::getopts;\n+    use getopts::{getopts, OptGroup};\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n     use syntax::diagnostics;\n \n+    fn optgroups() -> Vec<OptGroup> {\n+        super::rustc_optgroups().into_iter()\n+                                .map(|a| a.opt_group)\n+                                .collect()\n+    }\n+\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {"}, {"sha": "d0f86cfcb46babaa030404ced5026709f17ead45", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 98, "deletions": 52, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/05485be02f25526abeeb1e715abe532a31e0acd6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05485be02f25526abeeb1e715abe532a31e0acd6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=05485be02f25526abeeb1e715abe532a31e0acd6", "patch": "@@ -65,6 +65,7 @@ use rustc_trans::back::link;\n use rustc_trans::save;\n use rustc::session::{config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n+use rustc::session::config::{get_unstable_features_setting, OptionStability};\n use rustc::middle::cstore::CrateStore;\n use rustc::lint::Lint;\n use rustc::lint;\n@@ -85,14 +86,15 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-use rustc::session::early_error;\n+use rustc::session::{early_error, early_warn};\n \n use syntax::ast;\n use syntax::parse;\n use syntax::errors;\n use syntax::errors::emitter::Emitter;\n use syntax::diagnostics;\n use syntax::parse::token;\n+use syntax::feature_gate::UnstableFeatures;\n \n #[cfg(test)]\n pub mod test;\n@@ -819,8 +821,31 @@ fn print_flag_list<T>(cmdline_opt: &str,\n }\n \n /// Process command line options. Emits messages as appropriate. If compilation\n-/// should continue, returns a getopts::Matches object parsed from args, otherwise\n-/// returns None.\n+/// should continue, returns a getopts::Matches object parsed from args,\n+/// otherwise returns None.\n+///\n+/// The compiler's handling of options is a little complication as it ties into\n+/// our stability story, and it's even *more* complicated by historical\n+/// accidents. The current intention of each compiler option is to have one of\n+/// three modes:\n+///\n+/// 1. An option is stable and can be used everywhere.\n+/// 2. An option is unstable, but was historically allowed on the stable\n+///    channel.\n+/// 3. An option is unstable, and can only be used on nightly.\n+///\n+/// Like unstable library and language features, however, unstable options have\n+/// always required a form of \"opt in\" to indicate that you're using them. This\n+/// provides the easy ability to scan a code base to check to see if anything\n+/// unstable is being used. Currently, this \"opt in\" is the `-Z` \"zed\" flag.\n+///\n+/// All options behind `-Z` are considered unstable by default. Other top-level\n+/// options can also be considered unstable, and they were unlocked through the\n+/// `-Z unstable-options` flag. Note that `-Z` remains to be the root of\n+/// instability in both cases, though.\n+///\n+/// So with all that in mind, the comments below have some more detail about the\n+/// contortions done here to get things to work out correctly.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n     let _binary = args.remove(0);\n@@ -832,62 +857,83 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    fn allows_unstable_options(matches: &getopts::Matches) -> bool {\n-        let r = matches.opt_strs(\"Z\");\n-        r.iter().any(|x| *x == \"unstable-options\")\n-    }\n+    // Parse with *all* options defined in the compiler, we don't worry about\n+    // option stability here we just want to parse as much as possible.\n+    let all_groups: Vec<getopts::OptGroup> = config::rustc_optgroups()\n+                                                 .into_iter()\n+                                                 .map(|x| x.opt_group)\n+                                                 .collect();\n+    let matches = match getopts::getopts(&args[..], &all_groups) {\n+        Ok(m) => m,\n+        Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n+    };\n \n-    fn parse_all_options(args: &Vec<String>) -> getopts::Matches {\n-        let all_groups: Vec<getopts::OptGroup> = config::rustc_optgroups()\n-                                                     .into_iter()\n-                                                     .map(|x| x.opt_group)\n-                                                     .collect();\n-        match getopts::getopts(&args[..], &all_groups) {\n-            Ok(m) => {\n-                if !allows_unstable_options(&m) {\n-                    // If -Z unstable-options was not specified, verify that\n-                    // no unstable options were present.\n-                    for opt in config::rustc_optgroups().into_iter().filter(|x| !x.is_stable()) {\n-                        let opt_name = if !opt.opt_group.long_name.is_empty() {\n-                            &opt.opt_group.long_name\n-                        } else {\n-                            &opt.opt_group.short_name\n-                        };\n-                        if m.opt_present(opt_name) {\n-                            early_error(ErrorOutputType::default(),\n-                                        &format!(\"use of unstable option '{}' requires -Z \\\n-                                                  unstable-options\",\n-                                                 opt_name));\n-                        }\n-                    }\n-                }\n-                m\n-            }\n-            Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n+    // For all options we just parsed, we check a few aspects:\n+    //\n+    // * If the option is stable, we're all good\n+    // * If the option wasn't passed, we're all good\n+    // * If `-Z unstable-options` wasn't passed (and we're not a -Z option\n+    //   ourselves), then we require the `-Z unstable-options` flag to unlock\n+    //   this option that was passed.\n+    // * If we're a nightly compiler, then unstable options are now unlocked, so\n+    //   we're good to go.\n+    // * Otherwise, if we're a truly unstable option then we generate an error\n+    //   (unstable option being used on stable)\n+    // * If we're a historically stable-but-should-be-unstable option then we\n+    //   emit a warning that we're going to turn this into an error soon.\n+    let has_z_unstable_options = matches.opt_strs(\"Z\")\n+                                        .iter()\n+                                        .any(|x| *x == \"unstable-options\");\n+    let really_allows_unstable_options = match get_unstable_features_setting() {\n+        UnstableFeatures::Disallow => false,\n+        _ => true,\n+    };\n+    for opt in config::rustc_optgroups() {\n+        if opt.stability == OptionStability::Stable {\n+            continue\n         }\n-    }\n-\n-    // As a speed optimization, first try to parse the command-line using just\n-    // the stable options.\n-    let matches = match getopts::getopts(&args[..], &config::optgroups()) {\n-        Ok(ref m) if allows_unstable_options(m) => {\n-            // If -Z unstable-options was specified, redo parsing with the\n-            // unstable options to ensure that unstable options are defined\n-            // in the returned getopts::Matches.\n-            parse_all_options(&args)\n+        let opt_name = if !opt.opt_group.long_name.is_empty() {\n+            &opt.opt_group.long_name\n+        } else {\n+            &opt.opt_group.short_name\n+        };\n+        if !matches.opt_present(opt_name) {\n+            continue\n         }\n-        Ok(m) => m,\n-        Err(_) => {\n-            // redo option parsing, including unstable options this time,\n-            // in anticipation that the mishandled option was one of the\n-            // unstable ones.\n-            parse_all_options(&args)\n+        if opt_name != \"Z\" && !has_z_unstable_options {\n+            let msg = format!(\"the `-Z unstable-options` flag must also be \\\n+                               passed to enable the flag `{}`\", opt_name);\n+            early_error(ErrorOutputType::default(), &msg);\n         }\n-    };\n+        if really_allows_unstable_options {\n+            continue\n+        }\n+        match opt.stability {\n+            OptionStability::Unstable => {\n+                let msg = format!(\"the option `{}` is only accepted on the \\\n+                                   nightly compiler\", opt_name);\n+                early_error(ErrorOutputType::default(), &msg);\n+            }\n+            OptionStability::UnstableButNotReally => {\n+                let msg = format!(\"the option `{}` is is unstable and should \\\n+                                   only be used on the nightly compiler, but \\\n+                                   it is currently accepted for backwards \\\n+                                   compatibility; this will soon change, \\\n+                                   see issue #31847 for more details\",\n+                                  opt_name);\n+                early_warn(ErrorOutputType::default(), &msg);\n+            }\n+            OptionStability::Stable => {}\n+        }\n+    }\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        // Only show unstable options in --help if we *really* accept unstable\n+        // options, which catches the case where we got `-Z unstable-options` on\n+        // the stable channel of Rust which was accidentally allowed\n+        // historically.\n         usage(matches.opt_present(\"verbose\"),\n-              allows_unstable_options(&matches));\n+              has_z_unstable_options && really_allows_unstable_options);\n         return None;\n     }\n "}]}