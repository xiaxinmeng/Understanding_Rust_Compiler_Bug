{"sha": "3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYWE0NjY0NDRmY2FhN2UyNWYwNTc4NDMxZjRkZGViYTBkYzRhMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T23:11:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T23:11:07Z"}, "message": "Auto merge of #88626 - cjgillot:lfitb, r=petrochenkov\n\nSimplify lifetimes_from_impl_trait_bounds\n\nPart of https://github.com/rust-lang/rust/pull/87234\n\nr? `@petrochenkov`", "tree": {"sha": "35d442f21a89f4e0e3ccf217d63be210005a9ff9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35d442f21a89f4e0e3ccf217d63be210005a9ff9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "html_url": "https://github.com/rust-lang/rust/commit/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d2a410ff78247c418e28b69f7cad02bdd2168d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2a410ff78247c418e28b69f7cad02bdd2168d6", "html_url": "https://github.com/rust-lang/rust/commit/5d2a410ff78247c418e28b69f7cad02bdd2168d6"}, {"sha": "fed4410def78cf459c746100817d22487621b88c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed4410def78cf459c746100817d22487621b88c", "html_url": "https://github.com/rust-lang/rust/commit/fed4410def78cf459c746100817d22487621b88c"}], "stats": {"total": 430, "additions": 195, "deletions": 235}, "files": [{"sha": "16cd7a0bcdd394af214d0a0235fab976fb3c3636", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "patch": "@@ -1186,9 +1186,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n             }\n             None => self\n-                .loop_scopes\n-                .last()\n-                .cloned()\n+                .loop_scope\n                 .map(|id| Ok(self.lower_node_id(id)))\n                 .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)),\n         };\n@@ -1208,18 +1206,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn with_catch_scope<T>(&mut self, catch_id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let len = self.catch_scopes.len();\n-        self.catch_scopes.push(catch_id);\n-\n+        let old_scope = self.catch_scope.replace(catch_id);\n         let result = f(self);\n-        assert_eq!(\n-            len + 1,\n-            self.catch_scopes.len(),\n-            \"catch scopes should be added and removed in stack order\"\n-        );\n-\n-        self.catch_scopes.pop().unwrap();\n-\n+        self.catch_scope = old_scope;\n         result\n     }\n \n@@ -1228,17 +1217,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n-        let len = self.loop_scopes.len();\n-        self.loop_scopes.push(loop_id);\n-\n+        let old_scope = self.loop_scope.replace(loop_id);\n         let result = f(self);\n-        assert_eq!(\n-            len + 1,\n-            self.loop_scopes.len(),\n-            \"loop scopes should be added and removed in stack order\"\n-        );\n-\n-        self.loop_scopes.pop().unwrap();\n+        self.loop_scope = old_scope;\n \n         self.is_in_loop_condition = was_in_loop_condition;\n \n@@ -1565,8 +1546,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 unstable_span,\n             );\n             let thin_attrs = ThinVec::from(attrs);\n-            let catch_scope = self.catch_scopes.last().copied();\n-            let ret_expr = if let Some(catch_node) = catch_scope {\n+            let ret_expr = if let Some(catch_node) = self.catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n                 self.arena.alloc(self.expr(\n                     try_span,"}, {"sha": "5391d4b0c93638295cfe30fccc84afef52507dc2", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 189, "deletions": 209, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa466444fcaa7e25f0578431f4ddeba0dc4a1b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3baa466444fcaa7e25f0578431f4ddeba0dc4a1b", "patch": "@@ -64,7 +64,6 @@ use rustc_span::{Span, DUMMY_SP};\n \n use smallvec::SmallVec;\n use std::collections::BTreeMap;\n-use std::mem;\n use tracing::{debug, trace};\n \n macro_rules! arena_vec {\n@@ -117,8 +116,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// outside of an `async fn`.\n     current_item: Option<Span>,\n \n-    catch_scopes: Vec<NodeId>,\n-    loop_scopes: Vec<NodeId>,\n+    catch_scope: Option<NodeId>,\n+    loop_scope: Option<NodeId>,\n     is_in_loop_condition: bool,\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n@@ -323,8 +322,8 @@ pub fn lower_crate<'a, 'hir>(\n         bodies: BTreeMap::new(),\n         modules: BTreeMap::new(),\n         attrs: BTreeMap::default(),\n-        catch_scopes: Vec::new(),\n-        loop_scopes: Vec::new(),\n+        catch_scope: None,\n+        loop_scope: None,\n         is_in_loop_condition: false,\n         is_in_trait_impl: false,\n         is_in_dyn_type: false,\n@@ -911,11 +910,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n-        let catch_scopes = mem::take(&mut self.catch_scopes);\n-        let loop_scopes = mem::take(&mut self.loop_scopes);\n+        let catch_scope = self.catch_scope.take();\n+        let loop_scope = self.loop_scope.take();\n         let ret = f(self);\n-        self.catch_scopes = catch_scopes;\n-        self.loop_scopes = loop_scopes;\n+        self.catch_scope = catch_scope;\n+        self.loop_scope = loop_scope;\n \n         self.is_in_loop_condition = was_in_loop_condition;\n \n@@ -1497,20 +1496,50 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n-        let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n+        let collected_lifetimes = self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n+            let hir_bounds = lower_bounds(lctx);\n \n-        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-            opaque_ty_node_id,\n-            opaque_ty_def_id,\n-            &hir_bounds,\n-            capturable_lifetimes,\n-        );\n+            let collected_lifetimes = lifetimes_from_impl_trait_bounds(\n+                opaque_ty_node_id,\n+                &hir_bounds,\n+                capturable_lifetimes,\n+            );\n \n-        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n+            let lifetime_defs =\n+                lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(|&(name, span)| {\n+                    let def_node_id = lctx.resolver.next_node_id();\n+                    let hir_id = lctx.lower_node_id(def_node_id);\n+                    lctx.resolver.create_def(\n+                        opaque_ty_def_id,\n+                        def_node_id,\n+                        DefPathData::LifetimeNs(name.ident().name),\n+                        ExpnId::root(),\n+                        span,\n+                    );\n \n-        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n+                    let (name, kind) = match name {\n+                        hir::LifetimeName::Underscore => (\n+                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n+                            hir::LifetimeParamKind::Elided,\n+                        ),\n+                        hir::LifetimeName::Param(param_name) => {\n+                            (param_name, hir::LifetimeParamKind::Explicit)\n+                        }\n+                        _ => panic!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n+                    };\n+\n+                    hir::GenericParam {\n+                        hir_id,\n+                        name,\n+                        span,\n+                        pure_wrt_drop: false,\n+                        bounds: &[],\n+                        kind: hir::GenericParamKind::Lifetime { kind },\n+                    }\n+                }));\n+\n+            debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n-        self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n@@ -1525,9 +1554,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n             lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n-            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n-        })\n+            collected_lifetimes\n+        });\n+\n+        let lifetimes =\n+            self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(|(name, span)| {\n+                hir::GenericArg::Lifetime(hir::Lifetime { hir_id: self.next_id(), span, name })\n+            }));\n+\n+        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n+\n+        // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n+        hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n@@ -1556,193 +1594,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.insert_item(opaque_ty_item);\n     }\n \n-    fn lifetimes_from_impl_trait_bounds(\n-        &mut self,\n-        opaque_ty_id: NodeId,\n-        parent_def_id: LocalDefId,\n-        bounds: hir::GenericBounds<'hir>,\n-        lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n-    ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n-        debug!(\n-            \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n-             parent_def_id={:?}, \\\n-             bounds={:#?})\",\n-            opaque_ty_id, parent_def_id, bounds,\n-        );\n-\n-        // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n-        // appear in the bounds, excluding lifetimes that are created within the bounds.\n-        // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n-        struct ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n-            context: &'r mut LoweringContext<'a, 'hir>,\n-            parent: LocalDefId,\n-            opaque_ty_id: NodeId,\n-            collect_elided_lifetimes: bool,\n-            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n-            already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n-            output_lifetimes: Vec<hir::GenericArg<'hir>>,\n-            output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n-            lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n-        }\n-\n-        impl<'r, 'a, 'v, 'hir> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n-            type Map = intravisit::ErasedMap<'v>;\n-\n-            fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-                intravisit::NestedVisitorMap::None\n-            }\n-\n-            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n-                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n-                if parameters.parenthesized {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-                    intravisit::walk_generic_args(self, span, parameters);\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    intravisit::walk_generic_args(self, span, parameters);\n-                }\n-            }\n-\n-            fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax.\n-                if let hir::TyKind::BareFn(_) = t.kind {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-\n-                    // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                    // to be able to later fully undo their introduction.\n-                    let old_len = self.currently_bound_lifetimes.len();\n-                    intravisit::walk_ty(self, t);\n-                    self.currently_bound_lifetimes.truncate(old_len);\n-\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    intravisit::walk_ty(self, t)\n-                }\n-            }\n-\n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &'v hir::PolyTraitRef<'v>,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                // to be able to later fully undo their introduction.\n-                let old_len = self.currently_bound_lifetimes.len();\n-                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.currently_bound_lifetimes.truncate(old_len);\n-            }\n-\n-            fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n-                // Record the introduction of 'a in `for<'a> ...`.\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n-                    let lt_name = hir::LifetimeName::Param(param.name);\n-                    self.currently_bound_lifetimes.push(lt_name);\n-                }\n-\n-                intravisit::walk_generic_param(self, param);\n-            }\n-\n-            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-                let name = match lifetime.name {\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n-                        if self.collect_elided_lifetimes {\n-                            // Use `'_` for both implicit and underscore lifetimes in\n-                            // `type Foo<'_> = impl SomeTrait<'_>;`.\n-                            hir::LifetimeName::Underscore\n-                        } else {\n-                            return;\n-                        }\n-                    }\n-                    hir::LifetimeName::Param(_) => lifetime.name,\n-\n-                    // Refers to some other lifetime that is \"in\n-                    // scope\" within the type.\n-                    hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n-\n-                    hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n-                };\n-\n-                if !self.currently_bound_lifetimes.contains(&name)\n-                    && !self.already_defined_lifetimes.contains(&name)\n-                    && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n-                {\n-                    self.already_defined_lifetimes.insert(name);\n-\n-                    self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        hir_id: self.context.next_id(),\n-                        span: self.context.lower_span(lifetime.span),\n-                        name,\n-                    }));\n-\n-                    let def_node_id = self.context.resolver.next_node_id();\n-                    let hir_id =\n-                        self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n-                    self.context.resolver.create_def(\n-                        self.parent,\n-                        def_node_id,\n-                        DefPathData::LifetimeNs(name.ident().name),\n-                        ExpnId::root(),\n-                        lifetime.span,\n-                    );\n-\n-                    let (name, kind) = match name {\n-                        hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n-                            hir::LifetimeParamKind::Elided,\n-                        ),\n-                        hir::LifetimeName::Param(param_name) => {\n-                            (param_name, hir::LifetimeParamKind::Explicit)\n-                        }\n-                        _ => panic!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n-                    };\n-                    let name = match name {\n-                        hir::ParamName::Plain(ident) => {\n-                            hir::ParamName::Plain(self.context.lower_ident(ident))\n-                        }\n-                        name => name,\n-                    };\n-\n-                    self.output_lifetime_params.push(hir::GenericParam {\n-                        hir_id,\n-                        name,\n-                        span: self.context.lower_span(lifetime.span),\n-                        pure_wrt_drop: false,\n-                        bounds: &[],\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                    });\n-                }\n-            }\n-        }\n-\n-        let mut lifetime_collector = ImplTraitLifetimeCollector {\n-            context: self,\n-            parent: parent_def_id,\n-            opaque_ty_id,\n-            collect_elided_lifetimes: true,\n-            currently_bound_lifetimes: Vec::new(),\n-            already_defined_lifetimes: FxHashSet::default(),\n-            output_lifetimes: Vec::new(),\n-            output_lifetime_params: Vec::new(),\n-            lifetimes_to_include,\n-        };\n-\n-        for bound in bounds {\n-            intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n-        }\n-\n-        let ImplTraitLifetimeCollector { output_lifetimes, output_lifetime_params, .. } =\n-            lifetime_collector;\n-\n-        (\n-            self.arena.alloc_from_iter(output_lifetimes),\n-            self.arena.alloc_from_iter(output_lifetime_params),\n-        )\n-    }\n-\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n@@ -2723,3 +2574,132 @@ impl<'hir> GenericArgsCtor<'hir> {\n         this.arena.alloc(ga)\n     }\n }\n+\n+fn lifetimes_from_impl_trait_bounds(\n+    opaque_ty_id: NodeId,\n+    bounds: hir::GenericBounds<'_>,\n+    lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n+) -> Vec<(hir::LifetimeName, Span)> {\n+    debug!(\n+        \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n+             bounds={:#?})\",\n+        opaque_ty_id, bounds,\n+    );\n+\n+    // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n+    // appear in the bounds, excluding lifetimes that are created within the bounds.\n+    // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n+    struct ImplTraitLifetimeCollector<'r> {\n+        collect_elided_lifetimes: bool,\n+        currently_bound_lifetimes: Vec<hir::LifetimeName>,\n+        already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n+        lifetimes: Vec<(hir::LifetimeName, Span)>,\n+        lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n+    }\n+\n+    impl<'r, 'v> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r> {\n+        type Map = intravisit::ErasedMap<'v>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n+            // Don't collect elided lifetimes used inside of `Fn()` syntax.\n+            if parameters.parenthesized {\n+                let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                self.collect_elided_lifetimes = false;\n+                intravisit::walk_generic_args(self, span, parameters);\n+                self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+            } else {\n+                intravisit::walk_generic_args(self, span, parameters);\n+            }\n+        }\n+\n+        fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n+            // Don't collect elided lifetimes used inside of `fn()` syntax.\n+            if let hir::TyKind::BareFn(_) = t.kind {\n+                let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                self.collect_elided_lifetimes = false;\n+\n+                // Record the \"stack height\" of `for<'a>` lifetime bindings\n+                // to be able to later fully undo their introduction.\n+                let old_len = self.currently_bound_lifetimes.len();\n+                intravisit::walk_ty(self, t);\n+                self.currently_bound_lifetimes.truncate(old_len);\n+\n+                self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+            } else {\n+                intravisit::walk_ty(self, t)\n+            }\n+        }\n+\n+        fn visit_poly_trait_ref(\n+            &mut self,\n+            trait_ref: &'v hir::PolyTraitRef<'v>,\n+            modifier: hir::TraitBoundModifier,\n+        ) {\n+            // Record the \"stack height\" of `for<'a>` lifetime bindings\n+            // to be able to later fully undo their introduction.\n+            let old_len = self.currently_bound_lifetimes.len();\n+            intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+            self.currently_bound_lifetimes.truncate(old_len);\n+        }\n+\n+        fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n+            // Record the introduction of 'a in `for<'a> ...`.\n+            if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n+                // Introduce lifetimes one at a time so that we can handle\n+                // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n+                let lt_name = hir::LifetimeName::Param(param.name);\n+                self.currently_bound_lifetimes.push(lt_name);\n+            }\n+\n+            intravisit::walk_generic_param(self, param);\n+        }\n+\n+        fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+            let name = match lifetime.name {\n+                hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n+                    if self.collect_elided_lifetimes {\n+                        // Use `'_` for both implicit and underscore lifetimes in\n+                        // `type Foo<'_> = impl SomeTrait<'_>;`.\n+                        hir::LifetimeName::Underscore\n+                    } else {\n+                        return;\n+                    }\n+                }\n+                hir::LifetimeName::Param(_) => lifetime.name,\n+\n+                // Refers to some other lifetime that is \"in\n+                // scope\" within the type.\n+                hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n+\n+                hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n+            };\n+\n+            if !self.currently_bound_lifetimes.contains(&name)\n+                && !self.already_defined_lifetimes.contains(&name)\n+                && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n+            {\n+                self.already_defined_lifetimes.insert(name);\n+\n+                self.lifetimes.push((name, lifetime.span));\n+            }\n+        }\n+    }\n+\n+    let mut lifetime_collector = ImplTraitLifetimeCollector {\n+        collect_elided_lifetimes: true,\n+        currently_bound_lifetimes: Vec::new(),\n+        already_defined_lifetimes: FxHashSet::default(),\n+        lifetimes: Vec::new(),\n+        lifetimes_to_include,\n+    };\n+\n+    for bound in bounds {\n+        intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n+    }\n+\n+    lifetime_collector.lifetimes\n+}"}]}