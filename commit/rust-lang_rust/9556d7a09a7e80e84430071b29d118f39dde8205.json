{"sha": "9556d7a09a7e80e84430071b29d118f39dde8205", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NTZkN2EwOWE3ZTgwZTg0NDMwMDcxYjI5ZDExOGYzOWRkZTgyMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-29T22:54:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-29T22:54:26Z"}, "message": "Auto merge of #88337 - eddyb:field-failure-is-not-an-option, r=nagisa\n\nrustc_target: `TyAndLayout::field` should never error.\n\nThis refactor (making `TyAndLayout::field` return `TyAndLayout` without any `Result` around it) is based on a simple observation, regarding `TyAndLayout::field`:\n\nIf `cx.layout_of(ty)` succeeds (for some `cx` and `ty`), then `.field(cx, i)` on the resulting `TyAndLayout` should *always* succeed in computing `cx.layout_of(field_ty)` (where `field_ty` is the type of the `i`th field of `ty`).\n\nThe reason for this is that no matter which field is chosen, `cx.layout_of(field_ty)` *will have already been computed*, as part of computing `cx.layout_of(ty)`, as we cannot determine the layout of *any* type without considering the layouts of *all* of its fields.\n\nAnd so it should be fine to turn any errors into ICEs, since they likely indicate a `cx` mismatch, or some other edge case that is due to a compiler bug (as opposed to ever being an user-facing error).\n\n<hr/>\n\nEach commit should probably be reviewed separately, though note that there's some `where` clauses (in `rustc_target::abi::call::*`) that change in most commits.\n\ncc `@nagisa` `@oli-obk`", "tree": {"sha": "0573eff24dad76cec0aec88bc0af55c2213d9856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0573eff24dad76cec0aec88bc0af55c2213d9856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9556d7a09a7e80e84430071b29d118f39dde8205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9556d7a09a7e80e84430071b29d118f39dde8205", "html_url": "https://github.com/rust-lang/rust/commit/9556d7a09a7e80e84430071b29d118f39dde8205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9556d7a09a7e80e84430071b29d118f39dde8205/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f662b14033c4369b0a7b5c2656592ef08edf434", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f662b14033c4369b0a7b5c2656592ef08edf434", "html_url": "https://github.com/rust-lang/rust/commit/2f662b14033c4369b0a7b5c2656592ef08edf434"}, {"sha": "78778fc6aa87d6f9735b73b4136fb26043d84158", "url": "https://api.github.com/repos/rust-lang/rust/commits/78778fc6aa87d6f9735b73b4136fb26043d84158", "html_url": "https://github.com/rust-lang/rust/commit/78778fc6aa87d6f9735b73b4136fb26043d84158"}], "stats": {"total": 579, "additions": 308, "deletions": 271}, "files": [{"sha": "03f462a63b31bf211a33fcdee3323c4764054d3e", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -256,7 +256,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) inline_asm_index: u32,\n }\n \n-impl<'tcx> LayoutOf for FunctionCx<'_, '_, 'tcx> {\n+impl<'tcx> LayoutOf<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n@@ -364,7 +364,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n \n pub(crate) struct RevealAllLayoutCx<'tcx>(pub(crate) TyCtxt<'tcx>);\n \n-impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n+impl<'tcx> LayoutOf<'tcx> for RevealAllLayoutCx<'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n "}, {"sha": "95216f1c3d7872fe2237fbc9cd77fe6d39309d09", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -160,12 +160,10 @@ impl<'tcx> DebugContext<'tcx> {\n \n                 for (field_idx, field_def) in variant.fields.iter().enumerate() {\n                     let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout\n-                        .field(\n-                            &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                            field_idx,\n-                        )\n-                        .unwrap();\n+                    let field_layout = layout.field(\n+                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n+                        field_idx,\n+                    );\n \n                     let field_type = self.dwarf_ty(field_layout.ty);\n "}, {"sha": "12f61e0c564aab39944b735e7d4f34057a8df842", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -789,7 +789,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n+            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true) {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n@@ -798,7 +798,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n+            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false) {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),"}, {"sha": "47529f719b514a880a1409d8d42120680186e832", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -88,7 +88,7 @@ impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl abi::LayoutOf for Builder<'_, '_, 'tcx> {\n+impl abi::LayoutOf<'tcx> for Builder<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n "}, {"sha": "45da18d4a24f3e003c06a301d274d395bd3a9622", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -835,7 +835,7 @@ impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl LayoutOf for CodegenCx<'ll, 'tcx> {\n+impl LayoutOf<'tcx> for CodegenCx<'ll, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n "}, {"sha": "9818905464dce4e8ba8b0d2e6d29f7d233737e99", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n-use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAndLayoutMethods, Variants};\n+use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n@@ -393,12 +393,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         }\n     }\n \n+    // FIXME(eddyb) this having the same name as `TyAndLayout::pointee_info_at`\n+    // (the inherent method, which is lacking this caching logic) can result in\n+    // the uncached version being called - not wrong, but potentially inefficient.\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo> {\n         if let Some(&pointee) = cx.pointee_infos.borrow().get(&(self.ty, offset)) {\n             return pointee;\n         }\n \n-        let result = Ty::pointee_info_at(*self, cx, offset);\n+        let result = Ty::ty_and_layout_pointee_info_at(*self, cx, offset);\n \n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result"}, {"sha": "2a76ad0fb1356ebb1b244e19ba413444a1fcb6b5", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -472,10 +472,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                // We unwrap as the error type is `!`.\n-                ZeroValid => !layout.might_permit_raw_init(bx, /*zero:*/ true).unwrap(),\n-                // We unwrap as the error type is `!`.\n-                UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false).unwrap(),\n+                ZeroValid => !layout.might_permit_raw_init(bx, /*zero:*/ true),\n+                UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false),\n             };\n             if do_panic {\n                 let msg_str = with_no_trimmed_paths(|| {"}, {"sha": "1393fc71d6bc3fdd75903f28f2b82d7372691303", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -39,12 +39,17 @@ pub trait BackendTypes {\n }\n \n pub trait Backend<'tcx>:\n-    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n+    Sized\n+    + BackendTypes\n+    + HasTyCtxt<'tcx>\n+    + LayoutOf<'tcx, Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n {\n }\n \n impl<'tcx, T> Backend<'tcx> for T where\n-    Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n+    Self: BackendTypes\n+        + HasTyCtxt<'tcx>\n+        + LayoutOf<'tcx, Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n {\n }\n "}, {"sha": "7dbc3d60439c4e64881e645197f6eaebf01180ea", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -41,7 +41,7 @@ use rustc_session::Session;\n use rustc_session::SessionLintStore;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::{symbol::Symbol, MultiSpan, Span, DUMMY_SP};\n-use rustc_target::abi::LayoutOf;\n+use rustc_target::abi::{self, LayoutOf};\n use tracing::debug;\n \n use std::cell::Cell;\n@@ -1059,7 +1059,28 @@ impl<'tcx> LateContext<'tcx> {\n     }\n }\n \n-impl<'tcx> LayoutOf for LateContext<'tcx> {\n+impl<'tcx> abi::HasDataLayout for LateContext<'tcx> {\n+    #[inline]\n+    fn data_layout(&self) -> &abi::TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'tcx> ty::layout::HasTyCtxt<'tcx> for LateContext<'tcx> {\n+    #[inline]\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'tcx> ty::layout::HasParamEnv<'tcx> for LateContext<'tcx> {\n+    #[inline]\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+}\n+\n+impl<'tcx> LayoutOf<'tcx> for LateContext<'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n "}, {"sha": "5e5902abe662f9063d4b96cb7d005bf4179e3e87", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 108, "deletions": 83, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1788,22 +1788,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             let field_info: Vec<_> = flds\n                 .iter()\n                 .enumerate()\n-                .map(|(i, &name)| match layout.field(self, i) {\n-                    Err(err) => {\n-                        bug!(\"no layout found for field {}: `{:?}`\", name, err);\n+                .map(|(i, &name)| {\n+                    let field_layout = layout.field(self, i);\n+                    let offset = layout.fields.offset(i);\n+                    let field_end = offset + field_layout.size;\n+                    if min_size < field_end {\n+                        min_size = field_end;\n                     }\n-                    Ok(field_layout) => {\n-                        let offset = layout.fields.offset(i);\n-                        let field_end = offset + field_layout.size;\n-                        if min_size < field_end {\n-                            min_size = field_end;\n-                        }\n-                        FieldInfo {\n-                            name: name.to_string(),\n-                            offset: offset.bytes(),\n-                            size: field_layout.size.bytes(),\n-                            align: field_layout.align.abi.bytes(),\n-                        }\n+                    FieldInfo {\n+                        name: name.to_string(),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size.bytes(),\n+                        align: field_layout.align.abi.bytes(),\n                     }\n                 })\n                 .collect();\n@@ -2034,6 +2030,20 @@ impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n     }\n }\n \n+impl<'tcx> HasDataLayout for ty::query::TyCtxtAt<'tcx> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.data_layout\n+    }\n+}\n+\n+impl<'tcx> HasTyCtxt<'tcx> for ty::query::TyCtxtAt<'tcx> {\n+    #[inline]\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        **self\n+    }\n+}\n+\n impl<'tcx, C> HasParamEnv<'tcx> for LayoutCx<'tcx, C> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n@@ -2054,7 +2064,7 @@ impl<'tcx, T: HasTyCtxt<'tcx>> HasTyCtxt<'tcx> for LayoutCx<'tcx, T> {\n \n pub type TyAndLayout<'tcx> = rustc_target::abi::TyAndLayout<'tcx, Ty<'tcx>>;\n \n-impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n+impl LayoutOf<'tcx> for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -2066,7 +2076,7 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     }\n }\n \n-impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n+impl LayoutOf<'tcx> for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -2078,13 +2088,11 @@ impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     }\n }\n \n-impl<'tcx, C> TyAndLayoutMethods<'tcx, C> for Ty<'tcx>\n+impl<'tcx, C> TyAbiInterface<'tcx, C> for Ty<'tcx>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout: MaybeResult<TyAndLayout<'tcx>>>\n-        + HasTyCtxt<'tcx>\n-        + HasParamEnv<'tcx>,\n+    C: HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n {\n-    fn for_variant(\n+    fn ty_and_layout_for_variant(\n         this: TyAndLayout<'tcx>,\n         cx: &C,\n         variant_index: VariantIdx,\n@@ -2101,8 +2109,11 @@ where\n             }\n \n             Variants::Single { index } => {\n+                let tcx = cx.tcx();\n+                let param_env = cx.param_env();\n+\n                 // Deny calling for_variant more than once for non-Single enums.\n-                if let Ok(original_layout) = cx.layout_of(this.ty).to_result() {\n+                if let Ok(original_layout) = tcx.layout_of(param_env.and(this.ty)) {\n                     assert_eq!(original_layout.variants, Variants::Single { index });\n                 }\n \n@@ -2112,7 +2123,6 @@ where\n                     ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!(),\n                 };\n-                let tcx = cx.tcx();\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: variant_index },\n                     fields: match NonZeroUsize::new(fields) {\n@@ -2134,32 +2144,24 @@ where\n         TyAndLayout { ty: this.ty, layout }\n     }\n \n-    fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n-        enum TyMaybeWithLayout<C: LayoutOf> {\n-            Ty(C::Ty),\n-            TyAndLayout(C::TyAndLayout),\n+    fn ty_and_layout_field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> TyAndLayout<'tcx> {\n+        enum TyMaybeWithLayout<'tcx> {\n+            Ty(Ty<'tcx>),\n+            TyAndLayout(TyAndLayout<'tcx>),\n         }\n \n-        fn ty_and_layout_kind<\n-            C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout: MaybeResult<TyAndLayout<'tcx>>>\n-                + HasTyCtxt<'tcx>\n-                + HasParamEnv<'tcx>,\n-        >(\n+        fn field_ty_or_layout(\n             this: TyAndLayout<'tcx>,\n-            cx: &C,\n+            cx: &(impl HasTyCtxt<'tcx> + HasParamEnv<'tcx>),\n             i: usize,\n-            ty: C::Ty,\n-        ) -> TyMaybeWithLayout<C> {\n+        ) -> TyMaybeWithLayout<'tcx> {\n             let tcx = cx.tcx();\n-            let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+            let tag_layout = |tag: &Scalar| -> TyAndLayout<'tcx> {\n                 let layout = Layout::scalar(cx, tag.clone());\n-                MaybeResult::from(Ok(TyAndLayout {\n-                    layout: tcx.intern_layout(layout),\n-                    ty: tag.value.to_ty(tcx),\n-                }))\n+                TyAndLayout { layout: tcx.intern_layout(layout), ty: tag.value.to_ty(tcx) }\n             };\n \n-            match *ty.kind() {\n+            match *this.ty.kind() {\n                 ty::Bool\n                 | ty::Char\n                 | ty::Int(_)\n@@ -2170,7 +2172,7 @@ where\n                 | ty::FnDef(..)\n                 | ty::GeneratorWitness(..)\n                 | ty::Foreign(..)\n-                | ty::Dynamic(..) => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n+                | ty::Dynamic(..) => bug!(\"TyAndLayout::field({:?}): not applicable\", this),\n \n                 // Potentially-fat pointers.\n                 ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n@@ -2182,17 +2184,19 @@ where\n                     // as the `Abi` or `FieldsShape` is checked by users.\n                     if i == 0 {\n                         let nil = tcx.mk_unit();\n-                        let ptr_ty = if ty.is_unsafe_ptr() {\n+                        let unit_ptr_ty = if this.ty.is_unsafe_ptr() {\n                             tcx.mk_mut_ptr(nil)\n                         } else {\n                             tcx.mk_mut_ref(tcx.lifetimes.re_static, nil)\n                         };\n-                        return TyMaybeWithLayout::TyAndLayout(MaybeResult::from(\n-                            cx.layout_of(ptr_ty).to_result().map(|mut ptr_layout| {\n-                                ptr_layout.ty = ty;\n-                                ptr_layout\n-                            }),\n-                        ));\n+\n+                        // NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing\n+                        // the `Result` should always work because the type is\n+                        // always either `*mut ()` or `&'static mut ()`.\n+                        return TyMaybeWithLayout::TyAndLayout(TyAndLayout {\n+                            ty: this.ty,\n+                            ..tcx.layout_of(ty::ParamEnv::reveal_all().and(unit_ptr_ty)).unwrap()\n+                        });\n                     }\n \n                     match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n@@ -2216,7 +2220,7 @@ where\n                             ])\n                             */\n                         }\n-                        _ => bug!(\"TyAndLayout::field_type({:?}): not applicable\", this),\n+                        _ => bug!(\"TyAndLayout::field({:?}): not applicable\", this),\n                     }\n                 }\n \n@@ -2225,9 +2229,11 @@ where\n                 ty::Str => TyMaybeWithLayout::Ty(tcx.types.u8),\n \n                 // Tuples, generators and closures.\n-                ty::Closure(_, ref substs) => {\n-                    ty_and_layout_kind(this, cx, i, substs.as_closure().tupled_upvars_ty())\n-                }\n+                ty::Closure(_, ref substs) => field_ty_or_layout(\n+                    TyAndLayout { ty: substs.as_closure().tupled_upvars_ty(), ..this },\n+                    cx,\n+                    i,\n+                ),\n \n                 ty::Generator(def_id, ref substs, _) => match this.variants {\n                     Variants::Single { index } => TyMaybeWithLayout::Ty(\n@@ -2270,43 +2276,58 @@ where\n                 | ty::Opaque(..)\n                 | ty::Param(_)\n                 | ty::Infer(_)\n-                | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n+                | ty::Error(_) => bug!(\"TyAndLayout::field: unexpected type `{}`\", this.ty),\n             }\n         }\n \n-        cx.layout_of(match ty_and_layout_kind(this, cx, i, this.ty) {\n-            TyMaybeWithLayout::Ty(result) => result,\n-            TyMaybeWithLayout::TyAndLayout(result) => return result,\n-        })\n+        match field_ty_or_layout(this, cx, i) {\n+            TyMaybeWithLayout::Ty(field_ty) => {\n+                cx.tcx().layout_of(cx.param_env().and(field_ty)).unwrap_or_else(|e| {\n+                    bug!(\n+                        \"failed to get layout for `{}`: {},\\n\\\n+                         despite it being a field (#{}) of an existing layout: {:#?}\",\n+                        field_ty,\n+                        e,\n+                        i,\n+                        this\n+                    )\n+                })\n+            }\n+            TyMaybeWithLayout::TyAndLayout(field_layout) => field_layout,\n+        }\n     }\n \n-    fn pointee_info_at(this: TyAndLayout<'tcx>, cx: &C, offset: Size) -> Option<PointeeInfo> {\n+    fn ty_and_layout_pointee_info_at(\n+        this: TyAndLayout<'tcx>,\n+        cx: &C,\n+        offset: Size,\n+    ) -> Option<PointeeInfo> {\n+        let tcx = cx.tcx();\n+        let param_env = cx.param_env();\n+\n         let addr_space_of_ty = |ty: Ty<'tcx>| {\n             if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n         };\n \n         let pointee_info = match *this.ty.kind() {\n             ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                cx.layout_of(mt.ty).to_result().ok().map(|layout| PointeeInfo {\n+                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n                     size: layout.size,\n                     align: layout.align.abi,\n                     safe: None,\n                     address_space: addr_space_of_ty(mt.ty),\n                 })\n             }\n             ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                cx.layout_of(cx.tcx().mk_fn_ptr(fn_sig)).to_result().ok().map(|layout| {\n-                    PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: None,\n-                        address_space: cx.data_layout().instruction_address_space,\n-                    }\n+                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                    address_space: cx.data_layout().instruction_address_space,\n                 })\n             }\n             ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n                 let address_space = addr_space_of_ty(ty);\n-                let tcx = cx.tcx();\n                 let kind = if tcx.sess.opts.optimize == OptLevel::No {\n                     // Use conservative pointer kind if not optimizing. This saves us the\n                     // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n@@ -2335,7 +2356,7 @@ where\n                     }\n                 };\n \n-                cx.layout_of(ty).to_result().ok().map(|layout| PointeeInfo {\n+                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n                     size: layout.size,\n                     align: layout.align.abi,\n                     safe: Some(kind),\n@@ -2538,7 +2559,7 @@ impl<'tcx> ty::Instance<'tcx> {\n \n pub trait FnAbiExt<'tcx, C>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n+    C: LayoutOf<'tcx, Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n         + HasDataLayout\n         + HasTargetSpec\n         + HasTyCtxt<'tcx>\n@@ -2725,7 +2746,7 @@ pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n \n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n+    C: LayoutOf<'tcx, Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n         + HasDataLayout\n         + HasTargetSpec\n         + HasTyCtxt<'tcx>\n@@ -3004,16 +3025,15 @@ where\n     }\n }\n \n-fn make_thin_self_ptr<'tcx, C>(cx: &C, mut layout: TyAndLayout<'tcx>) -> TyAndLayout<'tcx>\n-where\n-    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n-        + HasTyCtxt<'tcx>\n-        + HasParamEnv<'tcx>,\n-{\n+fn make_thin_self_ptr<'tcx>(\n+    cx: &(impl HasTyCtxt<'tcx> + HasParamEnv<'tcx>),\n+    layout: TyAndLayout<'tcx>,\n+) -> TyAndLayout<'tcx> {\n+    let tcx = cx.tcx();\n     let fat_pointer_ty = if layout.is_unsized() {\n         // unsized `self` is passed as a pointer to `self`\n         // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-        cx.tcx().mk_mut_ptr(layout.ty)\n+        tcx.mk_mut_ptr(layout.ty)\n     } else {\n         match layout.abi {\n             Abi::ScalarPair(..) => (),\n@@ -3047,8 +3067,13 @@ where\n     // we now have a type like `*mut RcBox<dyn Trait>`\n     // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n     // this is understood as a special case elsewhere in the compiler\n-    let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n-    layout = cx.layout_of(unit_pointer_ty);\n-    layout.ty = fat_pointer_ty;\n-    layout\n+    let unit_ptr_ty = tcx.mk_mut_ptr(tcx.mk_unit());\n+\n+    TyAndLayout {\n+        ty: fat_pointer_ty,\n+\n+        // NOTE(eddyb) using an empty `ParamEnv`, and `unwrap`-ing the `Result`\n+        // should always work because the type is always `*mut ()`.\n+        ..tcx.layout_of(ty::ParamEnv::reveal_all().and(unit_ptr_ty)).unwrap()\n+    }\n }"}, {"sha": "6f18009cf47304c5d615f4cbe57e8e25df094e3d", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -340,7 +340,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let cast_ty_field = cast_ty.field(self, i)?;\n+                    let cast_ty_field = cast_ty.field(self, i);\n                     if cast_ty_field.is_zst() {\n                         continue;\n                     }"}, {"sha": "bfb3de04c59fbd518ff4575faf71709a6b1ff7d1", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -312,7 +312,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf<'tcx> for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = InterpResult<'tcx, TyAndLayout<'tcx>>;\n \n@@ -592,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Recurse to get the size of the dynamically sized field (must be\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n-                let field = layout.field(self, layout.fields.count() - 1)?;\n+                let field = layout.field(self, layout.fields.count() - 1);\n                 let (unsized_size, unsized_align) =\n                     match self.size_and_align_of(metadata, &field)? {\n                         Some(size_and_align) => size_and_align,\n@@ -645,7 +645,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             ty::Slice(_) | ty::Str => {\n                 let len = metadata.unwrap_meta().to_machine_usize(self)?;\n-                let elem = layout.field(self, 0)?;\n+                let elem = layout.field(self, 0);\n \n                 // Make sure the slice is not too big.\n                 let size = elem.size.checked_mul(len, self).ok_or_else(|| {"}, {"sha": "4afce2b6b80f2477f82b5eb46cb4011c0cf58523", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -364,7 +364,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field_layout = op.layout.field(self, field)?;\n+        let field_layout = op.layout.field(self, field);\n         if field_layout.is_zst() {\n             let immediate = Scalar::ZST.into();\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });"}, {"sha": "afad9716b3fe1ca712fcff8d2ca13a066072cdb6", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -355,7 +355,7 @@ where\n         field: usize,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let offset = base.layout.fields.offset(field);\n-        let field_layout = base.layout.field(self, field)?;\n+        let field_layout = base.layout.field(self, field);\n \n         // Offset may need adjustment for unsized fields.\n         let (meta, offset) = if field_layout.is_unsized() {\n@@ -405,7 +405,7 @@ where\n                 }\n                 let offset = stride * index; // `Size` multiplication\n                 // All fields have the same layout.\n-                let field_layout = base.layout.field(self, 0)?;\n+                let field_layout = base.layout.field(self, 0);\n \n                 assert!(!field_layout.is_unsized());\n                 base.offset(offset, MemPlaceMeta::None, field_layout, self)\n@@ -430,7 +430,7 @@ where\n             FieldsShape::Array { stride, .. } => stride,\n             _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n         };\n-        let layout = base.layout.field(self, 0)?;\n+        let layout = base.layout.field(self, 0);\n         let dl = &self.tcx.data_layout;\n         // `Size` multiplication\n         Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))"}, {"sha": "63496045e0d73cf69f826e823986a94a971eed8d", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -461,7 +461,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // a thin pointer.\n                 assert!(receiver_place.layout.is_unsized());\n                 let receiver_ptr_ty = self.tcx.mk_mut_ptr(receiver_place.layout.ty);\n-                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0)?;\n+                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0);\n                 // Adjust receiver argument.\n                 args[0] = OpTy::from(ImmTy::from_immediate(\n                     Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),"}, {"sha": "5c51aa4ed679b8bb449d32be6795b67270b14425", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::{\n     Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n     StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n-use rustc_middle::ty::layout::{HasTyCtxt, LayoutError, TyAndLayout};\n+use rustc_middle::ty::layout::{LayoutError, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{\n     self, ConstInt, ConstKind, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeFoldable,\n@@ -330,7 +330,7 @@ struct ConstPropagator<'mir, 'tcx> {\n     source_info: Option<SourceInfo>,\n }\n \n-impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n+impl<'mir, 'tcx> LayoutOf<'tcx> for ConstPropagator<'mir, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -346,13 +346,20 @@ impl<'mir, 'tcx> HasDataLayout for ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n+impl<'mir, 'tcx> ty::layout::HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }\n \n+impl<'mir, 'tcx> ty::layout::HasParamEnv<'tcx> for ConstPropagator<'mir, 'tcx> {\n+    #[inline]\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+}\n+\n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n         body: &Body<'tcx>,"}, {"sha": "64ea4ee570e821d97a9269693f27c8182a6f7e4a", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -113,7 +113,7 @@ struct UnwrapLayoutCx<'tcx> {\n     param_env: ParamEnv<'tcx>,\n }\n \n-impl LayoutOf for UnwrapLayoutCx<'tcx> {\n+impl LayoutOf<'tcx> for UnwrapLayoutCx<'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n "}, {"sha": "4613a459c51d6d281dcf09d14b39d9fa3a16c2e3", "filename": "compiler/rustc_target/src/abi/call/aarch64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -26,8 +26,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -48,8 +48,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n@@ -70,8 +70,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "9be97476ce8f09efc49d83d6aa76684c1abf72c3", "filename": "compiler/rustc_target/src/abi/call/amdgpu.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,26 +1,26 @@\n use crate::abi::call::{ArgAbi, FnAbi};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn classify_ret<'a, Ty, C>(_cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n }\n \n fn classify_arg<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "e66c2132b8677b824f740007517cb8389ac4eab1", "filename": "compiler/rustc_target/src/abi/call/arm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,11 +1,11 @@\n use crate::abi::call::{ArgAbi, Conv, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n use crate::spec::HasTargetSpec;\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -27,8 +27,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -53,8 +53,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n@@ -75,8 +75,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates."}, {"sha": "cc443197680e47c6aea6df744dbd6e0f4a158d07", "filename": "compiler/rustc_target/src/abi/call/mips.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,10 +1,9 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, Size};\n \n-fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n+fn classify_ret<Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -14,10 +13,9 @@ where\n     }\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n+fn classify_arg<Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     let dl = cx.data_layout();\n     let size = arg.layout.size;\n@@ -35,10 +33,9 @@ where\n     *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n+pub fn compute_abi_info<Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     let mut offset = Size::ZERO;\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "28ca93c46921e1cd7f69e770f89e99a7c722b40b", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n-use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n@@ -19,8 +19,8 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n \n fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgAbi<'a, Ty>, i: usize) -> Option<Reg>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     match ret.layout.field(cx, i).abi {\n         abi::Abi::Scalar(ref scalar) => match scalar.value {\n@@ -34,8 +34,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         extend_integer_width_mips(ret, 64);\n@@ -74,8 +74,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         extend_integer_width_mips(arg, 64);\n@@ -144,8 +144,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "6d3c7318091076fbcbb0b2f7b5fab6c70ef5cfc7", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::{self, Abi, Align, FieldsShape, Size};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n \n mod aarch64;\n@@ -316,8 +316,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     /// specific targets.\n     pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n-        Ty: TyAndLayoutMethods<'a, C> + Copy,\n-        C: LayoutOf<Ty = Ty, TyAndLayout = Self>,\n+        Ty: TyAbiInterface<'a, C> + Copy,\n     {\n         match self.abi {\n             Abi::Uninhabited => Err(Heterogeneous),\n@@ -603,8 +602,8 @@ pub struct FnAbi<'a, Ty> {\n impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n     where\n-        Ty: TyAndLayoutMethods<'a, C> + Copy,\n-        C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+        Ty: TyAbiInterface<'a, C> + Copy,\n+        C: HasDataLayout + HasTargetSpec,\n     {\n         if abi == spec::abi::Abi::X86Interrupt {\n             if let Some(arg) = self.args.first_mut() {"}, {"sha": "c22ef9c8f2a7f54d19448901a0ad939055939f76", "filename": "compiler/rustc_target/src/abi/call/powerpc64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -3,7 +3,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{Endian, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{Endian, HasDataLayout, TyAbiInterface};\n use crate::spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -19,8 +19,8 @@ fn is_homogeneous_aggregate<'a, Ty, C>(\n     abi: ABI,\n ) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n@@ -43,8 +43,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n@@ -86,8 +86,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n@@ -116,8 +116,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     let abi = if cx.target_spec().env == \"musl\" {\n         ELFv2"}, {"sha": "8c2ef8c7a017dfe130e2ac1799faee0241fdaff3", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -5,9 +5,7 @@\n // https://github.com/llvm/llvm-project/blob/8e780252a7284be45cf1ba224cabd884847e8e92/clang/lib/CodeGen/TargetInfo.cpp#L9311-L9773\n \n use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n-use crate::abi::{\n-    self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n-};\n+use crate::abi::{self, Abi, FieldsShape, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n #[derive(Copy, Clone)]\n@@ -43,8 +41,7 @@ fn should_use_fp_conv_helper<'a, Ty, C>(\n     field2_kind: &mut RegPassKind,\n ) -> Result<(), CannotUseFpConv>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n {\n     match arg_layout.abi {\n         Abi::Scalar(ref scalar) => match scalar.value {\n@@ -130,8 +127,7 @@ fn should_use_fp_conv<'a, Ty, C>(\n     flen: u64,\n ) -> Option<FloatConv>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n {\n     let mut field1_kind = RegPassKind::Unknown;\n     let mut field2_kind = RegPassKind::Unknown;\n@@ -149,8 +145,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n {\n     if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n         match conv {\n@@ -212,8 +207,7 @@ fn classify_arg<'a, Ty, C>(\n     avail_gprs: &mut u64,\n     avail_fprs: &mut u64,\n ) where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n {\n     if !is_vararg {\n         match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n@@ -320,8 +314,8 @@ fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     let flen = match &cx.target_spec().llvm_abiname[..] {\n         \"ilp32f\" | \"lp64f\" => 32,"}, {"sha": "594108925de8093e4ac90159ab035c714aff2c9b", "filename": "compiler/rustc_target/src/abi/call/s390x.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -2,13 +2,9 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, HasDataLayout, TyAbiInterface, TyAndLayout};\n \n-fn classify_ret<'a, Ty, C>(ret: &mut ArgAbi<'_, Ty>)\n-where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n-{\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n         ret.extend_integer_width_to(64);\n     } else {\n@@ -18,8 +14,8 @@ where\n \n fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C>,\n+    C: HasDataLayout,\n {\n     match layout.abi {\n         abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n@@ -36,8 +32,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n@@ -63,8 +59,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(&mut fn_abi.ret);"}, {"sha": "cc443197680e47c6aea6df744dbd6e0f4a158d07", "filename": "compiler/rustc_target/src/abi/call/sparc.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,10 +1,9 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, Size};\n \n-fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n+fn classify_ret<Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n@@ -14,10 +13,9 @@ where\n     }\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n+fn classify_arg<Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     let dl = cx.data_layout();\n     let size = arg.layout.size;\n@@ -35,10 +33,9 @@ where\n     *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n+pub fn compute_abi_info<Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n-    C: LayoutOf<Ty = Ty> + HasDataLayout,\n+    C: HasDataLayout,\n {\n     let mut offset = Size::ZERO;\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "5d74c94e2c6f67c32c91632f1642115822425061", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,12 +1,12 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n@@ -26,8 +26,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n@@ -52,8 +52,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n@@ -76,8 +76,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "3237cde10654ac4a1a70120843f95fb74165c8ed", "filename": "compiler/rustc_target/src/abi/call/wasm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, FnAbi, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgAbi<'a, Ty>) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n         if let Some(unit) = val.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()) {\n@@ -20,8 +20,8 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n     if ret.layout.is_aggregate() && !unwrap_trivial_aggregate(cx, ret) {\n@@ -31,8 +31,8 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n     if arg.layout.is_aggregate() && !unwrap_trivial_aggregate(cx, arg) {\n@@ -43,8 +43,8 @@ where\n /// The purpose of this ABI is to match the C ABI (aka clang) exactly.\n pub fn compute_c_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n         classify_ret(cx, &mut fn_abi.ret);"}, {"sha": "3fc197b5d7537f494c7e830c776c19526b3324d5", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAttribute, FnAbi, PassMode, Reg, RegKind};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n #[derive(PartialEq)]\n@@ -10,8 +10,8 @@ pub enum Flavor {\n \n fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     match layout.abi {\n         abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n@@ -28,8 +28,8 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>, flavor: Flavor)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout + HasTargetSpec,\n {\n     if !fn_abi.ret.is_ignore() {\n         if fn_abi.ret.layout.is_aggregate() {"}, {"sha": "08f0aaba59af4891333db4179448682a8f314464", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -2,7 +2,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use crate::abi::call::{ArgAbi, CastTarget, FnAbi, Reg, RegKind};\n-use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, Abi, HasDataLayout, Size, TyAbiInterface, TyAndLayout};\n \n /// Classification of \"eightbyte\" components.\n // N.B., the order of the variants is from general to specific,\n@@ -26,8 +26,8 @@ fn classify_arg<'a, Ty, C>(\n     arg: &ArgAbi<'a, Ty>,\n ) -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     fn classify<'a, Ty, C>(\n         cx: &C,\n@@ -36,8 +36,8 @@ where\n         off: Size,\n     ) -> Result<(), Memory>\n     where\n-        Ty: TyAndLayoutMethods<'a, C> + Copy,\n-        C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+        Ty: TyAbiInterface<'a, C> + Copy,\n+        C: HasDataLayout,\n     {\n         if !off.is_aligned(layout.align.abi) {\n             if !layout.is_zst() {\n@@ -172,8 +172,8 @@ const MAX_SSE_REGS: usize = 8; // XMM0-7\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n-    C: LayoutOf<Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n {\n     let mut int_regs = MAX_INT_REGS;\n     let mut sse_regs = MAX_SSE_REGS;"}, {"sha": "820399943f0afc91f62b36e38e0c5781bc549352", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9556d7a09a7e80e84430071b29d118f39dde8205/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=9556d7a09a7e80e84430071b29d118f39dde8205", "patch": "@@ -1174,19 +1174,16 @@ impl<'a, Ty> Deref for TyAndLayout<'a, Ty> {\n }\n \n /// Trait for context types that can compute layouts of things.\n-pub trait LayoutOf {\n-    type Ty;\n-    type TyAndLayout;\n+pub trait LayoutOf<'a>: Sized {\n+    type Ty: TyAbiInterface<'a, Self>;\n+    type TyAndLayout: MaybeResult<TyAndLayout<'a, Self::Ty>>;\n \n     fn layout_of(&self, ty: Self::Ty) -> Self::TyAndLayout;\n     fn spanned_layout_of(&self, ty: Self::Ty, _span: Span) -> Self::TyAndLayout {\n         self.layout_of(ty)\n     }\n }\n \n-/// The `TyAndLayout` above will always be a `MaybeResult<TyAndLayout<'_, Self>>`.\n-/// We can't add the bound due to the lifetime, but this trait is still useful when\n-/// writing code that's generic over the `LayoutOf` impl.\n pub trait MaybeResult<T> {\n     type Error;\n \n@@ -1239,41 +1236,42 @@ pub struct PointeeInfo {\n     pub address_space: AddressSpace,\n }\n \n-pub trait TyAndLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n-    fn for_variant(\n+/// Trait that needs to be implemented by the higher-level type representation\n+/// (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality.\n+pub trait TyAbiInterface<'a, C>: Sized {\n+    fn ty_and_layout_for_variant(\n         this: TyAndLayout<'a, Self>,\n         cx: &C,\n         variant_index: VariantIdx,\n     ) -> TyAndLayout<'a, Self>;\n-    fn field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> C::TyAndLayout;\n-    fn pointee_info_at(this: TyAndLayout<'a, Self>, cx: &C, offset: Size) -> Option<PointeeInfo>;\n+    fn ty_and_layout_field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> TyAndLayout<'a, Self>;\n+    fn ty_and_layout_pointee_info_at(\n+        this: TyAndLayout<'a, Self>,\n+        cx: &C,\n+        offset: Size,\n+    ) -> Option<PointeeInfo>;\n }\n \n impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where\n-        Ty: TyAndLayoutMethods<'a, C>,\n-        C: LayoutOf<Ty = Ty>,\n+        Ty: TyAbiInterface<'a, C>,\n     {\n-        Ty::for_variant(self, cx, variant_index)\n+        Ty::ty_and_layout_for_variant(self, cx, variant_index)\n     }\n \n-    /// Callers might want to use `C: LayoutOf<Ty=Ty, TyAndLayout: MaybeResult<Self>>`\n-    /// to allow recursion (see `might_permit_zero_init` below for an example).\n-    pub fn field<C>(self, cx: &C, i: usize) -> C::TyAndLayout\n+    pub fn field<C>(self, cx: &C, i: usize) -> Self\n     where\n-        Ty: TyAndLayoutMethods<'a, C>,\n-        C: LayoutOf<Ty = Ty>,\n+        Ty: TyAbiInterface<'a, C>,\n     {\n-        Ty::field(self, cx, i)\n+        Ty::ty_and_layout_field(self, cx, i)\n     }\n \n     pub fn pointee_info_at<C>(self, cx: &C, offset: Size) -> Option<PointeeInfo>\n     where\n-        Ty: TyAndLayoutMethods<'a, C>,\n-        C: LayoutOf<Ty = Ty>,\n+        Ty: TyAbiInterface<'a, C>,\n     {\n-        Ty::pointee_info_at(self, cx, offset)\n+        Ty::ty_and_layout_pointee_info_at(self, cx, offset)\n     }\n }\n \n@@ -1301,11 +1299,11 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     /// FIXME: Once we removed all the conservatism, we could alternatively\n     /// create an all-0/all-undef constant and run the const value validator to see if\n     /// this is a valid value for the given type.\n-    pub fn might_permit_raw_init<C, E>(self, cx: &C, zero: bool) -> Result<bool, E>\n+    pub fn might_permit_raw_init<C>(self, cx: &C, zero: bool) -> bool\n     where\n         Self: Copy,\n-        Ty: TyAndLayoutMethods<'a, C>,\n-        C: LayoutOf<Ty = Ty, TyAndLayout: MaybeResult<Self, Error = E>> + HasDataLayout,\n+        Ty: TyAbiInterface<'a, C>,\n+        C: HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n             if zero {\n@@ -1330,7 +1328,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         };\n         if !valid {\n             // This is definitely not okay.\n-            return Ok(false);\n+            return false;\n         }\n \n         // If we have not found an error yet, we need to recursively descend into fields.\n@@ -1341,16 +1339,15 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             }\n             FieldsShape::Arbitrary { offsets, .. } => {\n                 for idx in 0..offsets.len() {\n-                    let field = self.field(cx, idx).to_result()?;\n-                    if !field.might_permit_raw_init(cx, zero)? {\n+                    if !self.field(cx, idx).might_permit_raw_init(cx, zero) {\n                         // We found a field that is unhappy with this kind of initialization.\n-                        return Ok(false);\n+                        return false;\n                     }\n                 }\n             }\n         }\n \n         // FIXME(#66151): For now, we are conservative and do not check `self.variants`.\n-        Ok(true)\n+        true\n     }\n }"}]}