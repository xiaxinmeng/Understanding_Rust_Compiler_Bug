{"sha": "60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZDFmYTcwYmJiMDE3NjMyZjQzYzIwNmU1ZjE2YjBiNWJiZDAxNDk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-31T00:02:40Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-31T22:39:55Z"}, "message": "Address review comments\n\nSay \"trait\" instead of \"type\" in diagnostics for `dyn Trait`", "tree": {"sha": "40d1ed636a0646964bbc18f07448bf0ff5c6db70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40d1ed636a0646964bbc18f07448bf0ff5c6db70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "html_url": "https://github.com/rust-lang/rust/commit/60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b1c424b6d1cb001907e0fc0401e5242e297a83e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b1c424b6d1cb001907e0fc0401e5242e297a83e", "html_url": "https://github.com/rust-lang/rust/commit/8b1c424b6d1cb001907e0fc0401e5242e297a83e"}], "stats": {"total": 222, "additions": 126, "deletions": 96}, "files": [{"sha": "318d7adb1901107f70a0fbf539968fc0908ad176", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -709,6 +709,9 @@ define_print! {\n \n define_print! {\n     ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n         debug {\n             ty::tls::with(|tcx| {\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));"}, {"sha": "c6626c1551f4a17e66faf7c2881b6e65cd60ae1d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 104, "deletions": 77, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -23,6 +23,7 @@ use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt, Ty, TraitRef, TypeFoldable, GenericParamDefKind};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::query::Providers;\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -31,8 +32,7 @@ use syntax::attr;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use std::{cmp, fmt};\n-use std::mem::replace;\n+use std::{cmp, fmt, mem};\n use std::marker::PhantomData;\n \n mod diagnostics;\n@@ -43,6 +43,12 @@ mod diagnostics;\n \n /// Implemented to visit all `DefId`s in a type.\n /// Visiting `DefId`s is useful because visibilities and reachabilities are attached to them.\n+/// The idea is to visit \"all components of a type\", as documented in\n+/// https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md#how-to-determine-visibility-of-a-type\n+/// Default type visitor (`TypeVisitor`) does most of the job, but it has some shortcomings.\n+/// First, it doesn't have overridable `fn visit_trait_ref`, so we have to catch trait def-ids\n+/// manually. Second, it doesn't visit some type components like signatures of fn types, or traits\n+/// in `impl Trait`, see individual commits in `DefIdVisitorSkeleton::visit_ty`.\n trait DefIdVisitor<'a, 'tcx: 'a> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n     fn recurse_into_assoc_tys(&self) -> bool { true }\n@@ -79,33 +85,38 @@ impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n     where V: DefIdVisitor<'a, 'tcx> + ?Sized\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n-        self.def_id_visitor.visit_def_id(trait_ref.def_id, \"trait\", &trait_ref) ||\n-        trait_ref.visit_with(self)\n+        let TraitRef { def_id, substs } = trait_ref;\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) || substs.visit_with(self)\n     }\n \n     fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n-        for (predicate, _) in &predicates.predicates {\n-            let trait_ref = match predicate {\n+        let ty::GenericPredicates { parent: _, predicates } = &*predicates;\n+        for (predicate, _span) in predicates {\n+            match predicate {\n                 ty::Predicate::Trait(poly_predicate) => {\n-                    poly_predicate.skip_binder().trait_ref\n+                    let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n+                    if self.visit_trait(trait_ref) {\n+                        return true;\n+                    }\n                 }\n                 ty::Predicate::Projection(poly_predicate) => {\n-                    if poly_predicate.skip_binder().ty.visit_with(self) {\n+                    let ty::ProjectionPredicate { projection_ty, ty } =\n+                        *poly_predicate.skip_binder();\n+                    if ty.visit_with(self) {\n+                        return true;\n+                    }\n+                    if self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx())) {\n                         return true;\n                     }\n-                    poly_predicate.skip_binder().projection_ty.trait_ref(self.def_id_visitor.tcx())\n                 }\n                 ty::Predicate::TypeOutlives(poly_predicate) => {\n-                    if poly_predicate.skip_binder().0.visit_with(self) {\n+                    let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n+                    if ty.visit_with(self) {\n                         return true;\n                     }\n-                    continue;\n                 }\n-                ty::Predicate::RegionOutlives(..) => continue,\n+                ty::Predicate::RegionOutlives(..) => {},\n                 _ => bug!(\"unexpected predicate: {:?}\", predicate),\n-            };\n-            if self.visit_trait(trait_ref) {\n-                return true;\n             }\n         }\n         false\n@@ -117,6 +128,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let tcx = self.def_id_visitor.tcx();\n+        // Substs are not visited here because they are visited below in `super_visit_with`.\n         match ty.sty {\n             ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n             ty::Foreign(def_id) |\n@@ -126,14 +138,18 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n                 if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n                     return true;\n                 }\n-                // Default type visitor doesn't visit fn signatures.\n+                // Default type visitor doesn't visit signatures of fn types.\n+                // Something like `fn() -> Priv {my_func}` is considered a private type even if\n+                // `my_func` is public, so we need to visit signatures.\n                 if let ty::FnDef(..) = ty.sty {\n                     if tcx.fn_sig(def_id).visit_with(self) {\n                         return true;\n                     }\n                 }\n-                // Inherent static methods don't have self type in substs,\n-                // we have to check it additionally.\n+                // Inherent static methods don't have self type in substs.\n+                // Something like `fn() {my_method}` type of the method\n+                // `impl Pub<Priv> { pub fn my_method() {} }` is considered a private type,\n+                // so we need to visit the self type additionally.\n                 if let Some(assoc_item) = tcx.opt_associated_item(def_id) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n                         if tcx.type_of(impl_def_id).visit_with(self) {\n@@ -156,19 +172,24 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n             }\n             ty::Dynamic(predicates, ..) => {\n                 for predicate in *predicates.skip_binder() {\n-                    let def_id = match *predicate {\n-                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n-                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx).def_id,\n-                        ty::ExistentialPredicate::AutoTrait(def_id) => def_id,\n+                    let trait_ref = match *predicate {\n+                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n+                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n+                        ty::ExistentialPredicate::AutoTrait(def_id) =>\n+                            ty::ExistentialTraitRef { def_id, substs: Substs::empty() },\n                     };\n-                    if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n+                    let ty::ExistentialTraitRef { def_id, substs: _ } = trait_ref;\n+                    if self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) {\n                         return true;\n                     }\n                 }\n             }\n             ty::Opaque(def_id, ..) => {\n                 // Skip repeated `Opaque`s to avoid infinite recursion.\n                 if self.visited_opaque_tys.insert(def_id) {\n+                    // Default type visitor doesn't visit traits in `impl Trait`.\n+                    // Something like `impl PrivTr` is considered a private type,\n+                    // so we need to visit the traits additionally.\n                     if self.visit_predicates(tcx.predicates_of(def_id)) {\n                         return true;\n                     }\n@@ -249,24 +270,22 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             };\n             (ty::Visibility::from_hir(vis, node_id, tcx), vis.span, vis.node.descr())\n         }\n-        None => (tcx.visibility(def_id), tcx.def_span(def_id), \"private\"),\n+        None => {\n+            let vis = tcx.visibility(def_id);\n+            let descr = if vis == ty::Visibility::Public { \"public\" } else { \"private\" };\n+            (vis, tcx.def_span(def_id), descr)\n+        }\n     }\n }\n \n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n-fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           item_id: ast::NodeId,\n-                           tables: &mut &'a ty::TypeckTables<'tcx>,\n-                           empty_tables: &'a ty::TypeckTables<'tcx>)\n-                           -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(item_id);\n-\n-    if tcx.has_typeck_tables(def_id) {\n-        replace(tables, tcx.typeck_tables_of(def_id))\n-    } else {\n-        replace(tables, empty_tables)\n-    }\n+fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         node_id: ast::NodeId,\n+                         empty_tables: &'a ty::TypeckTables<'tcx>)\n+                         -> &'a ty::TypeckTables<'tcx> {\n+    let def_id = tcx.hir().local_def_id(node_id);\n+    if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -298,23 +317,45 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n /// Visitor used to determine impl visibility and reachability.\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct FindMin<'a, 'tcx, M: Min> {\n+struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n-    min: M,\n+    min: VL,\n+}\n+\n+impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn recurse_into_assoc_tys(&self) -> bool { false }\n+    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+        self.min = VL::new_min(self, def_id);\n+        false\n+    }\n }\n \n-trait Min: Sized {\n+trait VisibilityLike: Sized {\n     const MAX: Self;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self;\n+\n+    // Returns an over-approximation (`recurse_into_assoc_tys` = false) of visibility due to\n+    // associated types for which we can't determine visibility precisely.\n+    fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         access_levels: &'a AccessLevels) -> Self {\n+        let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n+        let def_id = tcx.hir().local_def_id(node_id);\n+        find.visit(tcx.type_of(def_id));\n+        if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n+            find.visit_trait(trait_ref);\n+        }\n+        find.min\n+    }\n }\n-impl Min for ty::Visibility {\n+impl VisibilityLike for ty::Visibility {\n     const MAX: Self = ty::Visibility::Public;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n         min(def_id_visibility(find.tcx, def_id).0, find.min, find.tcx)\n     }\n }\n-impl Min for Option<AccessLevel> {\n+impl VisibilityLike for Option<AccessLevel> {\n     const MAX: Self = Some(AccessLevel::Public);\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n         cmp::min(if let Some(node_id) = find.tcx.hir().as_local_node_id(def_id) {\n@@ -325,26 +366,6 @@ impl Min for Option<AccessLevel> {\n     }\n }\n \n-impl<'a, 'tcx, M: Min> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, M> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n-    fn recurse_into_assoc_tys(&self) -> bool { false }\n-    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n-        self.min = M::new_min(self, def_id);\n-        false\n-    }\n-}\n-\n-fn impl_min<'a, 'tcx, M: Min>(tcx: TyCtxt<'a, 'tcx, 'tcx>, access_levels: &'a AccessLevels,\n-                              node_id: ast::NodeId) -> M {\n-    let mut find = FindMin { tcx, access_levels, min: M::MAX };\n-    let def_id = tcx.hir().local_def_id(node_id);\n-    find.visit(tcx.type_of(def_id));\n-    if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n-        find.visit_trait(trait_ref);\n-    }\n-    find.min\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n@@ -404,7 +425,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             hir::ItemKind::Impl(..) =>\n-                impl_min::<Option<AccessLevel>>(self.tcx, &self.access_levels, item.id),\n+                Option::<AccessLevel>::of_impl(item.id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod(..) => self.prev_level,\n             // Other `pub` items inherit levels from parents.\n@@ -575,7 +596,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let orig_level = replace(&mut self.prev_level, item_level);\n+        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n         self.prev_level = orig_level;\n     }\n@@ -584,7 +605,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n-        let orig_level = replace(&mut self.prev_level, None);\n+        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n         self.prev_level = orig_level;\n     }\n@@ -732,28 +753,31 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = replace(&mut self.current_item, item.id);\n-        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.id);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n         self.tables = orig_tables;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -864,8 +888,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n-        let orig_in_body = replace(&mut self.in_body, true);\n+        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_in_body = mem::replace(&mut self.in_body, true);\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n@@ -1003,23 +1027,26 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item =\n-            replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n-        let orig_in_body = replace(&mut self.in_body, false);\n-        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n+            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n+        let orig_in_body = mem::replace(&mut self.in_body, false);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n         self.current_item = orig_current_item;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -1576,7 +1603,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n-                let impl_vis = impl_min::<ty::Visibility>(tcx, &Default::default(), item.id);\n+                let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n                 self.check(item.id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);"}, {"sha": "591e9df81eb0b7ce8d1d6b58923bde60f26aa47d", "filename": "src/test/ui/privacy/associated-item-privacy-type-binding.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -9,19 +9,19 @@ mod priv_trait {\n \n     pub macro mac1() {\n         let _: Box<PubTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n-        //~| ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n+        //~| ERROR trait `priv_trait::PrivTr` is private\n         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + 'static)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n     }\n     pub macro mac2() {\n         let _: Box<PrivTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n-        //~| ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n+        //~| ERROR trait `priv_trait::PrivTr` is private\n         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + 'static)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         trait InSignatureTr1: PrivTr<AssocTy = u8> {}\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n     }"}, {"sha": "7f6886d7f9ad446e17b6dbda3cf5e44a5ad0198b", "filename": "src/test/ui/privacy/associated-item-privacy-type-binding.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -1,4 +1,4 @@\n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:11:13\n    |\n LL |         let _: Box<PubTr<AssocTy = u8>>;\n@@ -7,7 +7,7 @@ LL |         let _: Box<PubTr<AssocTy = u8>>;\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:11:16\n    |\n LL |         let _: Box<PubTr<AssocTy = u8>>;\n@@ -16,7 +16,7 @@ LL |         let _: Box<PubTr<AssocTy = u8>>;\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + 'static)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:14:31\n    |\n LL |         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n@@ -34,7 +34,7 @@ LL |         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:20:13\n    |\n LL |         let _: Box<PrivTr<AssocTy = u8>>;\n@@ -43,7 +43,7 @@ LL |         let _: Box<PrivTr<AssocTy = u8>>;\n LL |     priv_trait::mac2!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:20:16\n    |\n LL |         let _: Box<PrivTr<AssocTy = u8>>;\n@@ -52,7 +52,7 @@ LL |         let _: Box<PrivTr<AssocTy = u8>>;\n LL |     priv_trait::mac2!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + 'static)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:23:31\n    |\n LL |         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;"}, {"sha": "02fd92aa7a4ef95573d8ba68605b0bb030bbc644", "filename": "src/test/ui/privacy/private-in-public-non-principal-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -9,5 +9,5 @@ mod m {\n \n fn main() {\n     m::leak_dyn_nonprincipal();\n-    //~^ ERROR type `(dyn m::PubPrincipal + m::PrivNonPrincipal + 'static)` is private\n+    //~^ ERROR trait `m::PrivNonPrincipal` is private\n }"}, {"sha": "2db49257226424fad138f7520313007411104320", "filename": "src/test/ui/privacy/private-in-public-non-principal-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -1,4 +1,4 @@\n-error: type `(dyn m::PubPrincipal + m::PrivNonPrincipal + 'static)` is private\n+error: trait `m::PrivNonPrincipal` is private\n   --> $DIR/private-in-public-non-principal-2.rs:11:5\n    |\n LL |     m::leak_dyn_nonprincipal();"}, {"sha": "5de5a685208cde885035827d35f66bf92231836a", "filename": "src/test/ui/privacy/private-in-public-non-principal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -4,7 +4,7 @@ pub trait PubPrincipal {}\n auto trait PrivNonPrincipal {}\n \n pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n-//~^ WARN private type `(dyn PubPrincipal + PrivNonPrincipal + 'static)` in public interface\n+//~^ WARN private trait `PrivNonPrincipal` in public interface\n //~| WARN this was previously accepted\n \n #[deny(missing_docs)]"}, {"sha": "996740558977709fb5c5f8402c337aa7e9c4845e", "filename": "src/test/ui/privacy/private-in-public-non-principal.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -1,4 +1,4 @@\n-warning: private type `(dyn PubPrincipal + PrivNonPrincipal + 'static)` in public interface (error E0446)\n+warning: private trait `PrivNonPrincipal` in public interface (error E0445)\n   --> $DIR/private-in-public-non-principal.rs:6:1\n    |\n LL | pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }"}, {"sha": "69b60a56c67f1c8313f02a896c3c3979c94c05b7", "filename": "src/test/ui/privacy/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -119,7 +119,7 @@ fn main() {\n     m::leak_anon2(); //~ ERROR type `m::Priv` is private\n     m::leak_anon3(); //~ ERROR type `m::Priv` is private\n \n-    m::leak_dyn1(); //~ ERROR type `(dyn m::Trait + 'static)` is private\n+    m::leak_dyn1(); //~ ERROR trait `m::Trait` is private\n     m::leak_dyn2(); //~ ERROR type `m::Priv` is private\n     m::leak_dyn3(); //~ ERROR type `m::Priv` is private\n "}, {"sha": "80a475f7dceea2266002e1897d0d930768aa09e0", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60d1fa70bbb017632f43c206e5f16b0b5bbd0149/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "patch": "@@ -160,10 +160,10 @@ error: type `m::Priv` is private\n LL |     m::leak_anon3(); //~ ERROR type `m::Priv` is private\n    |     ^^^^^^^^^^^^^^^\n \n-error: type `(dyn m::Trait + 'static)` is private\n+error: trait `m::Trait` is private\n   --> $DIR/private-inferred-type.rs:122:5\n    |\n-LL |     m::leak_dyn1(); //~ ERROR type `(dyn m::Trait + 'static)` is private\n+LL |     m::leak_dyn1(); //~ ERROR trait `m::Trait` is private\n    |     ^^^^^^^^^^^^^^\n \n error: type `m::Priv` is private"}]}