{"sha": "a12982cdc2fee3d892015ee981a2f98481f831f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMjk4MmNkYzJmZWUzZDg5MjAxNWVlOTgxYTJmOTg0ODFmODMxZjA=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-02-20T15:15:27Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-02-20T15:15:27Z"}, "message": "Run rustfmt", "tree": {"sha": "c21685031db3568e5084383ba07df1e576ccba1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c21685031db3568e5084383ba07df1e576ccba1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a12982cdc2fee3d892015ee981a2f98481f831f0", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlxtbxEACgkQiMlBzaHU\nZDIByw//fTPIrU4G1bQfIHYCggGRsCJagS3a8hPmBeV7mrf1YBi32jWK+rfG7QrK\npSWIx7HYm98EQgoST6I8IE1pqs6acAn34opDaScR2WNGH7n4XD7n/3Wbxxjx1Tbs\nb6zKZTDwelnNQ888/pjuzxA/OfvCtYGCtB4X7tZA8MDDcEtjUk4w7dcTG77wr90x\nd041Eng3e641pkpTYlMFDYtvVVpHjHVcp/Vkgg4on57CDRLvXzyS1u45PhjqS00i\nnsnAnazlU6R3jZVhLf85w7HrMDzoneKvz4jlMayg3AFx2rP1YunU/euFHJegrTWR\nmPRcQag3+Nck8edI+r5UWhjS2SJ0+QTf+dOYJeBCUbVXruQjRXZcagi45TZP8iOi\ns9oesSQQgp6doalgLJShqzWJRzi9F8LseN+0n1Zefq+0oL/eJuqvJbxTqZNcurdC\nUn0fihmlQJSoiD49EdhBxohPkQ2xZSS/2dVcYROgkVwOo10V6gZfFGCdYZJYpqkw\nkaEoggi9NpOiMHu+2/KF5RebnnUPoTxA2tS7eG+EvYB3VypAJR8HLURBi/cRJpTo\nRk92SW78o1dOjwUwbOEXNyPCgF976neC7Z7WIeSSCYeindrj8JXLwykrHOa2v2B1\nM5Nsi/gskUING8l6KHEYB0oPVBSQlPbs77cXOQvbf37LoZUGPgI=\n=UpOR\n-----END PGP SIGNATURE-----", "payload": "tree c21685031db3568e5084383ba07df1e576ccba1a\nparent 801c3f060fc3bf25a730d89aa0b80da4493f3584\nauthor Santiago Pastorino <spastorino@gmail.com> 1550675727 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1550675727 -0300\n\nRun rustfmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a12982cdc2fee3d892015ee981a2f98481f831f0", "html_url": "https://github.com/rust-lang/rust/commit/a12982cdc2fee3d892015ee981a2f98481f831f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a12982cdc2fee3d892015ee981a2f98481f831f0/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "801c3f060fc3bf25a730d89aa0b80da4493f3584", "url": "https://api.github.com/repos/rust-lang/rust/commits/801c3f060fc3bf25a730d89aa0b80da4493f3584", "html_url": "https://github.com/rust-lang/rust/commit/801c3f060fc3bf25a730d89aa0b80da4493f3584"}], "stats": {"total": 272, "additions": 155, "deletions": 117}, "files": [{"sha": "8ea249959dd2c284e1c113770784f74a92a5d497", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 155, "deletions": 117, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/a12982cdc2fee3d892015ee981a2f98481f831f0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12982cdc2fee3d892015ee981a2f98481f831f0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=a12982cdc2fee3d892015ee981a2f98481f831f0", "patch": "@@ -2,15 +2,14 @@ use std::collections::VecDeque;\n \n use crate::borrow_check::borrow_set::BorrowData;\n use crate::borrow_check::error_reporting::UseSpans;\n-use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n+use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::ty::{self, TyCtxt};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand,\n-    Place, Projection, ProjectionElem, Rvalue, Statement, StatementKind,\n-    TerminatorKind\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, Projection,\n+    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n };\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n@@ -63,50 +62,58 @@ impl BorrowExplanation {\n                 let message = match later_use_kind {\n                     LaterUseKind::TraitCapture => \"borrow later captured here by trait object\",\n                     LaterUseKind::ClosureCapture => \"borrow later captured here by closure\",\n-                    LaterUseKind::Call =>  \"borrow later used by call\",\n+                    LaterUseKind::Call => \"borrow later used by call\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n                     LaterUseKind::Other => \"borrow later used here\",\n                 };\n                 err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n-            },\n+            }\n             BorrowExplanation::UsedLaterInLoop(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n-                    LaterUseKind::TraitCapture =>\n-                        \"borrow captured here by trait object, in later iteration of loop\",\n-                    LaterUseKind::ClosureCapture =>\n-                        \"borrow captured here by closure, in later iteration of loop\",\n-                    LaterUseKind::Call =>  \"borrow used by call, in later iteration of loop\",\n+                    LaterUseKind::TraitCapture => {\n+                        \"borrow captured here by trait object, in later iteration of loop\"\n+                    }\n+                    LaterUseKind::ClosureCapture => {\n+                        \"borrow captured here by closure, in later iteration of loop\"\n+                    }\n+                    LaterUseKind::Call => \"borrow used by call, in later iteration of loop\",\n                     LaterUseKind::FakeLetRead => \"borrow later stored here\",\n                     LaterUseKind::Other => \"borrow used here, in later iteration of loop\",\n                 };\n                 err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n-            },\n-            BorrowExplanation::UsedLaterWhenDropped { drop_loc, dropped_local,\n-                                                      should_note_order } =>\n-            {\n+            }\n+            BorrowExplanation::UsedLaterWhenDropped {\n+                drop_loc,\n+                dropped_local,\n+                should_note_order,\n+            } => {\n                 let local_decl = &mir.local_decls[dropped_local];\n                 let (dtor_desc, type_desc) = match local_decl.ty.sty {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n-                    ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                        (\"`Drop` code\", format!(\"type `{}`\", tcx.item_path_str(adt.did))),\n+                    ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => (\n+                        \"`Drop` code\",\n+                        format!(\"type `{}`\", tcx.item_path_str(adt.did)),\n+                    ),\n \n                     // Otherwise, just report the whole type (and use\n                     // the intentionally fuzzy phrase \"destructor\")\n-                    ty::Closure(..) =>\n-                        (\"destructor\", \"closure\".to_owned()),\n-                    ty::Generator(..) =>\n-                        (\"destructor\", \"generator\".to_owned()),\n+                    ty::Closure(..) => (\"destructor\", \"closure\".to_owned()),\n+                    ty::Generator(..) => (\"destructor\", \"generator\".to_owned()),\n \n                     _ => (\"destructor\", format!(\"type `{}`\", local_decl.ty)),\n                 };\n \n                 match local_decl.name {\n                     Some(local_name) => {\n-                        let message =\n-                            format!(\"{B}borrow might be used here, when `{LOC}` is dropped \\\n-                                     and runs the {DTOR} for {TYPE}\",\n-                                    B=borrow_desc, LOC=local_name, TYPE=type_desc, DTOR=dtor_desc);\n+                        let message = format!(\n+                            \"{B}borrow might be used here, when `{LOC}` is dropped \\\n+                             and runs the {DTOR} for {TYPE}\",\n+                            B = borrow_desc,\n+                            LOC = local_name,\n+                            TYPE = type_desc,\n+                            DTOR = dtor_desc\n+                        );\n                         err.span_label(mir.source_info(drop_loc).span, message);\n \n                         if should_note_order {\n@@ -117,15 +124,22 @@ impl BorrowExplanation {\n                         }\n                     }\n                     None => {\n-                        err.span_label(local_decl.source_info.span,\n-                                       format!(\"a temporary with access to the {B}borrow \\\n-                                                is created here ...\",\n-                                               B=borrow_desc));\n-                        let message =\n-                            format!(\"... and the {B}borrow might be used here, \\\n-                                     when that temporary is dropped \\\n-                                     and runs the {DTOR} for {TYPE}\",\n-                                    B=borrow_desc, TYPE=type_desc, DTOR=dtor_desc);\n+                        err.span_label(\n+                            local_decl.source_info.span,\n+                            format!(\n+                                \"a temporary with access to the {B}borrow \\\n+                                 is created here ...\",\n+                                B = borrow_desc\n+                            ),\n+                        );\n+                        let message = format!(\n+                            \"... and the {B}borrow might be used here, \\\n+                             when that temporary is dropped \\\n+                             and runs the {DTOR} for {TYPE}\",\n+                            B = borrow_desc,\n+                            TYPE = type_desc,\n+                            DTOR = dtor_desc\n+                        );\n                         err.span_label(mir.source_info(drop_loc).span, message);\n \n                         if let Some(info) = &local_decl.is_block_tail {\n@@ -149,7 +163,7 @@ impl BorrowExplanation {\n                         }\n                     }\n                 }\n-            },\n+            }\n             BorrowExplanation::MustBeValidFor {\n                 category,\n                 span,\n@@ -160,18 +174,28 @@ impl BorrowExplanation {\n                 region_name.highlight_region_name(err);\n \n                 if let Some(desc) = opt_place_desc {\n-                    err.span_label(span, format!(\n-                        \"{}requires that `{}` is borrowed for `{}`\",\n-                        category.description(), desc, region_name,\n-                    ));\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"{}requires that `{}` is borrowed for `{}`\",\n+                            category.description(),\n+                            desc,\n+                            region_name,\n+                        ),\n+                    );\n                 } else {\n-                    err.span_label(span, format!(\n-                        \"{}requires that {}borrow lasts for `{}`\",\n-                        category.description(), borrow_desc, region_name,\n-                    ));\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"{}requires that {}borrow lasts for `{}`\",\n+                            category.description(),\n+                            borrow_desc,\n+                            region_name,\n+                        ),\n+                    );\n                 };\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n     }\n }\n@@ -217,10 +241,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             region_sub\n         );\n \n-         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n-                let spans = self.move_spans(&Place::Local(local), location)\n+                let spans = self\n+                    .move_spans(&Place::Local(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 let borrow_location = context.loc;\n@@ -236,55 +261,56 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-             Some(Cause::DropVar(local, location)) => {\n-                 let mut should_note_order = false;\n-                 if mir.local_decls[local].name.is_some() {\n-                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                         if let Place::Local(borrowed_local) = place {\n-                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n-                             let borrowed_local_scope =\n-                                 mir.local_decls[*borrowed_local].visibility_scope;\n-\n-                             if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n-                                 && local != *borrowed_local\n-                             {\n-                                 should_note_order = true;\n-                             }\n-                         }\n-                     }\n-                 }\n-\n-                 BorrowExplanation::UsedLaterWhenDropped {\n-                     drop_loc: location,\n-                     dropped_local: local,\n-                     should_note_order,\n-                 }\n+            Some(Cause::DropVar(local, location)) => {\n+                let mut should_note_order = false;\n+                if mir.local_decls[local].name.is_some() {\n+                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                        if let Place::Local(borrowed_local) = place {\n+                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n+                            let borrowed_local_scope =\n+                                mir.local_decls[*borrowed_local].visibility_scope;\n+\n+                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n+                                && local != *borrowed_local\n+                            {\n+                                should_note_order = true;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                BorrowExplanation::UsedLaterWhenDropped {\n+                    drop_loc: location,\n+                    dropped_local: local,\n+                    should_note_order,\n+                }\n             }\n \n-            None => if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n-                let (category, from_closure, span, region_name) = self\n-                    .nonlexical_regioncx\n-                    .free_region_constraint_info(\n-                        self.mir,\n-                        self.mir_def_id,\n-                        self.infcx,\n-                        borrow_region_vid,\n-                        region,\n-                    );\n-                if let Some(region_name) = region_name {\n-                    let opt_place_desc = self.describe_place(&borrow.borrowed_place);\n-                    BorrowExplanation::MustBeValidFor {\n-                        category,\n-                        from_closure,\n-                        span,\n-                        region_name,\n-                        opt_place_desc,\n+            None => {\n+                if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n+                    let (category, from_closure, span, region_name) =\n+                        self.nonlexical_regioncx.free_region_constraint_info(\n+                            self.mir,\n+                            self.mir_def_id,\n+                            self.infcx,\n+                            borrow_region_vid,\n+                            region,\n+                        );\n+                    if let Some(region_name) = region_name {\n+                        let opt_place_desc = self.describe_place(&borrow.borrowed_place);\n+                        BorrowExplanation::MustBeValidFor {\n+                            category,\n+                            from_closure,\n+                            span,\n+                            region_name,\n+                            opt_place_desc,\n+                        }\n+                    } else {\n+                        BorrowExplanation::Unexplained\n                     }\n                 } else {\n                     BorrowExplanation::Unexplained\n                 }\n-            } else {\n-                BorrowExplanation::Unexplained\n             }\n         }\n     }\n@@ -427,27 +453,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         borrow: &BorrowData<'tcx>,\n         use_spans: UseSpans,\n-        location: Location\n+        location: Location,\n     ) -> (LaterUseKind, Span) {\n         match use_spans {\n             UseSpans::ClosureUse { var_span, .. } => {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n-            },\n+            }\n             UseSpans::OtherUse(span) => {\n                 let block = &self.mir.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n                     ..\n-                }) = block.statements.get(location.statement_index) {\n+                }) = block.statements.get(location.statement_index)\n+                {\n                     LaterUseKind::FakeLetRead\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {\n                     if let TerminatorKind::Call {\n-                        ref func, from_hir_call: true, ..\n-                    } = block.terminator().kind {\n+                        ref func,\n+                        from_hir_call: true,\n+                        ..\n+                    } = block.terminator().kind\n+                    {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n@@ -458,7 +488,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 } else {\n                                     span\n                                 }\n-                            },\n+                            }\n                             _ => span,\n                         };\n                         return (LaterUseKind::Call, function_span);\n@@ -482,7 +512,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let location = borrow.reserve_location;\n         let block = &self.mir[location.block];\n         let stmt = block.statements.get(location.statement_index);\n-        debug!(\"was_captured_by_trait_object: location={:?} stmt={:?}\", location, stmt);\n+        debug!(\n+            \"was_captured_by_trait_object: location={:?} stmt={:?}\",\n+            location, stmt\n+        );\n \n         // We make a `queue` vector that has the locations we want to visit. As of writing, this\n         // will only ever have one item at any given time, but by using a vector, we can pop from\n@@ -491,13 +524,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut target = if let Some(&Statement {\n             kind: StatementKind::Assign(Place::Local(local), _),\n             ..\n-        }) = stmt {\n+        }) = stmt\n+        {\n             local\n         } else {\n             return false;\n         };\n \n-        debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n+        debug!(\n+            \"was_captured_by_trait: target={:?} queue={:?}\",\n+            target, queue\n+        );\n         while let Some(current_location) = queue.pop() {\n             debug!(\"was_captured_by_trait: target={:?}\", target);\n             let block = &self.mir[current_location.block];\n@@ -508,55 +545,55 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n \n                 // The only kind of statement that we care about is assignments...\n-                if let StatementKind::Assign(\n-                    place,\n-                    box rvalue,\n-                ) = &stmt.kind {\n+                if let StatementKind::Assign(place, box rvalue) = &stmt.kind {\n                     let into = match place {\n                         Place::Local(into) => into,\n                         Place::Projection(box Projection {\n                             base: Place::Local(into),\n                             elem: ProjectionElem::Deref,\n                         }) => into,\n-                        _ =>  {\n+                        _ => {\n                             // Continue at the next location.\n                             queue.push(current_location.successor_within_block());\n                             continue;\n-                        },\n+                        }\n                     };\n \n                     match rvalue {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place::Local(from)) |\n-                            Operand::Move(Place::Local(from)) if *from == target => {\n+                            Operand::Copy(Place::Local(from))\n+                            | Operand::Move(Place::Local(from))\n+                                if *from == target =>\n+                            {\n                                 target = *into;\n-                            },\n-                            _ => {},\n+                            }\n+                            _ => {}\n                         },\n                         // If we see a unsized cast, then if it is our data we should check\n                         // whether it is being cast to a trait object.\n                         Rvalue::Cast(CastKind::Unsize, operand, ty) => match operand {\n-                            Operand::Copy(Place::Local(from)) |\n-                            Operand::Move(Place::Local(from)) if *from == target => {\n+                            Operand::Copy(Place::Local(from))\n+                            | Operand::Move(Place::Local(from))\n+                                if *from == target =>\n+                            {\n                                 debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n                                 // Check the type for a trait object.\n                                 return match ty.sty {\n                                     // `&dyn Trait`\n                                     ty::TyKind::Ref(_, ty, _) if ty.is_trait() => true,\n                                     // `Box<dyn Trait>`\n-                                    _ if ty.is_box() && ty.boxed_ty().is_trait() =>\n-                                        true,\n+                                    _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n                                     // `dyn Trait`\n                                     _ if ty.is_trait() => true,\n                                     // Anything else.\n                                     _ => false,\n                                 };\n-                            },\n+                            }\n                             _ => return false,\n                         },\n-                        _ => {},\n+                        _ => {}\n                     }\n                 }\n \n@@ -571,7 +608,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     destination: Some((Place::Local(dest), block)),\n                     args,\n                     ..\n-                } = &terminator.kind {\n+                } = &terminator.kind\n+                {\n                     debug!(\n                         \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n                         target, dest, args"}]}