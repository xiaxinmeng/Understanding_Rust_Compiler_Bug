{"sha": "bd6683c729e3dc919e054839eed07702d938b727", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNjY4M2M3MjllM2RjOTE5ZTA1NDgzOWVlZDA3NzAyZDkzOGI3Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-07T00:02:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-07T00:02:00Z"}, "message": "auto merge of #14702 : nikomatsakis/rust/issue-5527-namespace-substs-b, r=pnkfelix\n\nSeparate out initial refactorings for PR #14604", "tree": {"sha": "e26681d3f5451ef1abdb57f598ab4fff662d23b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e26681d3f5451ef1abdb57f598ab4fff662d23b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd6683c729e3dc919e054839eed07702d938b727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd6683c729e3dc919e054839eed07702d938b727", "html_url": "https://github.com/rust-lang/rust/commit/bd6683c729e3dc919e054839eed07702d938b727", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd6683c729e3dc919e054839eed07702d938b727/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a414858ac04580be522b4d27abe834112011408", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a414858ac04580be522b4d27abe834112011408", "html_url": "https://github.com/rust-lang/rust/commit/8a414858ac04580be522b4d27abe834112011408"}, {"sha": "4a51e9c5493ff80d3783a51d130a87a08b8de74d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a51e9c5493ff80d3783a51d130a87a08b8de74d", "html_url": "https://github.com/rust-lang/rust/commit/4a51e9c5493ff80d3783a51d130a87a08b8de74d"}], "stats": {"total": 1953, "additions": 1019, "deletions": 934}, "files": [{"sha": "1b17cfb1bae01dd8b038ea644fb8a82812330e1c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -46,6 +46,7 @@ extern crate time;\n extern crate log;\n \n pub mod middle {\n+    pub mod def;\n     pub mod trans;\n     pub mod ty;\n     pub mod ty_fold;"}, {"sha": "6469462734e553190560e6e43937c9b3185f8434", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -22,6 +22,7 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::lang_items;\n+use middle::def;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n@@ -333,11 +334,11 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        ImmStatic => DlDef(ast::DefStatic(did, false)),\n-        MutStatic => DlDef(ast::DefStatic(did, true)),\n-        Struct    => DlDef(ast::DefStruct(did)),\n-        UnsafeFn  => DlDef(ast::DefFn(did, ast::UnsafeFn)),\n-        Fn        => DlDef(ast::DefFn(did, ast::NormalFn)),\n+        ImmStatic => DlDef(def::DefStatic(did, false)),\n+        MutStatic => DlDef(def::DefStatic(did, true)),\n+        Struct    => DlDef(def::DefStruct(did)),\n+        UnsafeFn  => DlDef(def::DefFn(did, ast::UnsafeFn)),\n+        Fn        => DlDef(def::DefFn(did, ast::NormalFn)),\n         StaticMethod | UnsafeStaticMethod => {\n             let fn_style = if fam == UnsafeStaticMethod { ast::UnsafeFn } else\n                 { ast::NormalFn };\n@@ -348,27 +349,27 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             // a trait_method_sort.\n             let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_method_sort).is_some() {\n-                ast::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n                                                                     item))\n             } else {\n-                ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            DlDef(ast::DefStaticMethod(did, provenance, fn_style))\n+            DlDef(def::DefStaticMethod(did, provenance, fn_style))\n         }\n-        Type | ForeignType => DlDef(ast::DefTy(did)),\n-        Mod => DlDef(ast::DefMod(did)),\n-        ForeignMod => DlDef(ast::DefForeignMod(did)),\n+        Type | ForeignType => DlDef(def::DefTy(did)),\n+        Mod => DlDef(def::DefMod(did)),\n+        ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n-            DlDef(ast::DefVariant(enum_did, did, true))\n+            DlDef(def::DefVariant(enum_did, did, true))\n         }\n         TupleVariant => {\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n-            DlDef(ast::DefVariant(enum_did, did, false))\n+            DlDef(def::DefVariant(enum_did, did, false))\n         }\n-        Trait => DlDef(ast::DefTrait(did)),\n-        Enum => DlDef(ast::DefTy(did)),\n+        Trait => DlDef(def::DefTrait(did)),\n+        Enum => DlDef(def::DefTy(did)),\n         Impl => DlImpl(did),\n         PublicField | InheritedField => DlField,\n     }\n@@ -459,7 +460,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n // Something that a name can resolve to.\n #[deriving(Clone)]\n pub enum DefLike {\n-    DlDef(ast::Def),\n+    DlDef(def::Def),\n     DlImpl(ast::DefId),\n     DlField\n }"}, {"sha": "2cc06f7a32dde70ab2a39971709739dcfab26778", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -1631,7 +1631,7 @@ impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n                 let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n-                let def_id = ast_util::def_id_of_def(trait_def);\n+                let def_id = trait_def.def_id();\n \n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate."}, {"sha": "a39be31c4b5720370ece6e3d83a65408be3b7430", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -16,6 +16,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::subst;\n use middle::ty;\n \n use std::rc::Rc;\n@@ -25,7 +26,6 @@ use std::uint;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n \n // Compact string representation for ty::t values. API ty_str &\n@@ -133,7 +133,7 @@ pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tc\n }\n \n pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                         conv: conv_did) -> ty::substs {\n+                         conv: conv_did) -> subst::Substs {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n }\n@@ -162,7 +162,7 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     }\n }\n \n-fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n+fn parse_substs(st: &mut PState, conv: conv_did) -> subst::Substs {\n     let regions = parse_region_substs(st, |x,y| conv(x,y));\n \n     let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n@@ -172,24 +172,24 @@ fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n     st.pos = st.pos + 1u;\n \n-    return ty::substs {\n+    return subst::Substs {\n         regions: regions,\n         self_ty: self_ty,\n         tps: params\n     };\n }\n \n-fn parse_region_substs(st: &mut PState, conv: conv_did) -> ty::RegionSubsts {\n+fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n     match next(st) {\n-        'e' => ty::ErasedRegions,\n+        'e' => subst::ErasedRegions,\n         'n' => {\n             let mut regions = vec!();\n             while peek(st) != '.' {\n                 let r = parse_region(st, |x,y| conv(x,y));\n                 regions.push(r);\n             }\n             assert_eq!(next(st), '.');\n-            ty::NonerasedRegions(OwnedSlice::from_vec(regions))\n+            subst::NonerasedRegions(regions)\n         }\n         _ => fail!(\"parse_bound_region: bad input\")\n     }"}, {"sha": "f48dbecc53025e362f0b5e2858ea979fa9284c1f", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -17,6 +17,7 @@ use std::cell::RefCell;\n use std::collections::HashMap;\n use std::io::MemWriter;\n \n+use middle::subst;\n use middle::ty::param_ty;\n use middle::ty;\n \n@@ -96,20 +97,20 @@ fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     }\n }\n \n-pub fn enc_substs(w: &mut MemWriter, cx: &ctxt, substs: &ty::substs) {\n+pub fn enc_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::Substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_opt(w, substs.self_ty, |w, t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     mywrite!(w, \"]\");\n }\n \n-fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &ty::RegionSubsts) {\n+fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::RegionSubsts) {\n     match *substs {\n-        ty::ErasedRegions => {\n+        subst::ErasedRegions => {\n             mywrite!(w, \"e\");\n         }\n-        ty::NonerasedRegions(ref regions) => {\n+        subst::NonerasedRegions(ref regions) => {\n             mywrite!(w, \"n\");\n             for &r in regions.iter() {\n                 enc_region(w, cx, r);"}, {"sha": "f0caf0e7fe83248c403e6fa2eea54335b203ad82", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -16,13 +16,15 @@ use c = metadata::common;\n use cstore = metadata::cstore;\n use driver::session::Session;\n use metadata::decoder;\n+use middle::def;\n use e = metadata::encoder;\n use middle::freevars::freevar_entry;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n+use middle::subst;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck};\n use util::ppaux::ty_to_str;\n@@ -394,58 +396,58 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n+fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> def::Def {\n     let mut dsr = reader::Decoder::new(doc);\n-    let def: ast::Def = Decodable::decode(&mut dsr).unwrap();\n+    let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n     def.tr(xcx)\n }\n \n-impl tr for ast::Def {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ast::Def {\n+impl tr for def::Def {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> def::Def {\n         match *self {\n-          ast::DefFn(did, p) => ast::DefFn(did.tr(xcx), p),\n-          ast::DefStaticMethod(did, wrapped_did2, p) => {\n-            ast::DefStaticMethod(did.tr(xcx),\n+          def::DefFn(did, p) => def::DefFn(did.tr(xcx), p),\n+          def::DefStaticMethod(did, wrapped_did2, p) => {\n+            def::DefStaticMethod(did.tr(xcx),\n                                    match wrapped_did2 {\n-                                    ast::FromTrait(did2) => {\n-                                        ast::FromTrait(did2.tr(xcx))\n+                                    def::FromTrait(did2) => {\n+                                        def::FromTrait(did2.tr(xcx))\n                                     }\n-                                    ast::FromImpl(did2) => {\n-                                        ast::FromImpl(did2.tr(xcx))\n+                                    def::FromImpl(did2) => {\n+                                        def::FromImpl(did2.tr(xcx))\n                                     }\n                                    },\n                                    p)\n           }\n-          ast::DefMethod(did0, did1) => {\n-            ast::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+          def::DefMethod(did0, did1) => {\n+            def::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n           }\n-          ast::DefSelfTy(nid) => { ast::DefSelfTy(xcx.tr_id(nid)) }\n-          ast::DefMod(did) => { ast::DefMod(did.tr(xcx)) }\n-          ast::DefForeignMod(did) => { ast::DefForeignMod(did.tr(xcx)) }\n-          ast::DefStatic(did, m) => { ast::DefStatic(did.tr(xcx), m) }\n-          ast::DefArg(nid, b) => { ast::DefArg(xcx.tr_id(nid), b) }\n-          ast::DefLocal(nid, b) => { ast::DefLocal(xcx.tr_id(nid), b) }\n-          ast::DefVariant(e_did, v_did, is_s) => {\n-            ast::DefVariant(e_did.tr(xcx), v_did.tr(xcx), is_s)\n+          def::DefSelfTy(nid) => { def::DefSelfTy(xcx.tr_id(nid)) }\n+          def::DefMod(did) => { def::DefMod(did.tr(xcx)) }\n+          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(xcx)) }\n+          def::DefStatic(did, m) => { def::DefStatic(did.tr(xcx), m) }\n+          def::DefArg(nid, b) => { def::DefArg(xcx.tr_id(nid), b) }\n+          def::DefLocal(nid, b) => { def::DefLocal(xcx.tr_id(nid), b) }\n+          def::DefVariant(e_did, v_did, is_s) => {\n+            def::DefVariant(e_did.tr(xcx), v_did.tr(xcx), is_s)\n           },\n-          ast::DefTrait(did) => ast::DefTrait(did.tr(xcx)),\n-          ast::DefTy(did) => ast::DefTy(did.tr(xcx)),\n-          ast::DefPrimTy(p) => ast::DefPrimTy(p),\n-          ast::DefTyParam(did, v) => ast::DefTyParam(did.tr(xcx), v),\n-          ast::DefBinding(nid, bm) => ast::DefBinding(xcx.tr_id(nid), bm),\n-          ast::DefUse(did) => ast::DefUse(did.tr(xcx)),\n-          ast::DefUpvar(nid1, def, nid2, nid3) => {\n-            ast::DefUpvar(xcx.tr_id(nid1),\n+          def::DefTrait(did) => def::DefTrait(did.tr(xcx)),\n+          def::DefTy(did) => def::DefTy(did.tr(xcx)),\n+          def::DefPrimTy(p) => def::DefPrimTy(p),\n+          def::DefTyParam(did, v) => def::DefTyParam(did.tr(xcx), v),\n+          def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),\n+          def::DefUse(did) => def::DefUse(did.tr(xcx)),\n+          def::DefUpvar(nid1, def, nid2, nid3) => {\n+            def::DefUpvar(xcx.tr_id(nid1),\n                            @(*def).tr(xcx),\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::DefStruct(did) => ast::DefStruct(did.tr(xcx)),\n-          ast::DefRegion(nid) => ast::DefRegion(xcx.tr_id(nid)),\n-          ast::DefTyParamBinder(nid) => {\n-            ast::DefTyParamBinder(xcx.tr_id(nid))\n+          def::DefStruct(did) => def::DefStruct(did.tr(xcx)),\n+          def::DefRegion(nid) => def::DefRegion(xcx.tr_id(nid)),\n+          def::DefTyParamBinder(nid) => {\n+            def::DefTyParamBinder(xcx.tr_id(nid))\n           }\n-          ast::DefLabel(nid) => ast::DefLabel(xcx.tr_id(nid))\n+          def::DefLabel(nid) => def::DefLabel(xcx.tr_id(nid))\n         }\n     }\n }\n@@ -796,7 +798,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(&mut self,\n                  ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty);\n-    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs);\n+    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n }\n \n@@ -842,7 +844,7 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs) {\n+    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n@@ -1076,7 +1078,7 @@ trait ebml_decoder_decoder_helpers {\n                            -> ty::TypeParameterDef;\n     fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n-    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> ty::substs;\n+    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn convert_def_id(&mut self,\n                       xcx: &ExtendedDecodeContext,\n@@ -1093,7 +1095,7 @@ trait ebml_decoder_decoder_helpers {\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n     fn read_substs_noxcx(&mut self, tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n-                         -> ty::substs;\n+                         -> subst::Substs;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n@@ -1121,7 +1123,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_substs_noxcx(&mut self,\n                          tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n-                         -> ty::substs\n+                         -> subst::Substs\n     {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_substs_data(\n@@ -1210,7 +1212,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> ty::substs {\n+    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n                                         xcx.dcx.cdata.cnum,"}, {"sha": "5706d249c46dabd98f12e670462b468dff96c1f1", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -14,6 +14,7 @@\n \n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n+use middle::def;\n use euv = middle::expr_use_visitor;\n use mc = middle::mem_categorization;\n use middle::ty;\n@@ -399,7 +400,7 @@ impl<'a> BorrowckCtxt<'a> {\n                    id: ast::NodeId,\n                    span: Span,\n                    ty: ty::t,\n-                   def: ast::Def)\n+                   def: def::Def)\n                    -> mc::cmt {\n         match self.mc().cat_def(id, span, ty, def) {\n             Ok(c) => c,\n@@ -412,11 +413,11 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn cat_captured_var(&self,\n                             closure_id: ast::NodeId,\n                             closure_span: Span,\n-                            upvar_def: ast::Def)\n+                            upvar_def: def::Def)\n                             -> mc::cmt {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = ast_util::def_id_of_def(upvar_def).node;\n+        let var_id = upvar_def.def_id().node;\n         let var_ty = ty::node_id_to_type(self.tcx, var_id);\n         self.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "4a36e84fbe56e0663ca28d9a7bb0de1aed3736ce", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use middle::cfg::*;\n+use middle::def;\n use middle::graph;\n use middle::typeck;\n use middle::ty;\n@@ -531,7 +532,7 @@ impl<'a> CFGBuilder<'a> {\n \n             Some(_) => {\n                 match self.tcx.def_map.borrow().find(&expr.id) {\n-                    Some(&ast::DefLabel(loop_id)) => {\n+                    Some(&def::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n                                 return *l;"}, {"sha": "2bb7d0bc5c8d471a3b8e9b58026d42ea251cb5f4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -10,6 +10,7 @@\n \n \n use driver::session::Session;\n+use middle::def::*;\n use middle::resolve;\n use middle::ty;\n use middle::typeck;"}, {"sha": "39a35e3adfab62ca899cb2a7adbb986657164c01", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -12,6 +12,7 @@\n \n use middle::const_eval::{compare_const_vals, lookup_const_by_id};\n use middle::const_eval::{eval_const_expr, const_val, const_bool, const_float};\n+use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;"}, {"sha": "ca94cf2485038a93f5bd16269692108748334d8b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -14,6 +14,7 @@\n use metadata::csearch;\n use middle::astencode;\n \n+use middle::def;\n use middle::ty;\n use middle::typeck::astconv;\n use util::nodemap::{DefIdMap};\n@@ -83,10 +84,10 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n-        Some(ast::DefStatic(def_id, false)) => {\n+        Some(def::DefStatic(def_id, false)) => {\n             lookup_const_by_id(tcx, def_id)\n         }\n-        Some(ast::DefVariant(enum_def, variant_def, _)) => {\n+        Some(def::DefVariant(enum_def, variant_def, _)) => {\n             lookup_variant_by_id(tcx, enum_def, variant_def)\n         }\n         _ => None"}, {"sha": "3eec3c7e8811aa5a34e7f60f1d2914ddc68c038d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -17,15 +17,16 @@\n  */\n \n \n+use middle::def;\n+use middle::ty;\n+use middle::typeck;\n use std::io;\n use std::string::String;\n use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n use syntax::print::{pp, pprust};\n-use middle::ty;\n-use middle::typeck;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n@@ -757,7 +758,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n             Some(_) => {\n                 match self.tcx().def_map.borrow().find(&expr.id) {\n-                    Some(&ast::DefLabel(loop_id)) => {\n+                    Some(&def::DefLabel(loop_id)) => {\n                         match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {"}, {"sha": "fb19fbd70c69e117c0159c6454bbc6bcc956b179", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -12,6 +12,7 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n+use middle::def;\n use middle::lint::{Allow, contains_lint, DeadCode};\n use middle::privacy;\n use middle::ty;\n@@ -21,7 +22,7 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, def_id_of_def, is_local};\n+use syntax::ast_util::{local_def, is_local};\n use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token;\n@@ -77,9 +78,9 @@ impl<'a> MarkSymbolVisitor<'a> {\n             None => return\n         };\n         let def_id = match def {\n-            ast::DefVariant(enum_id, _, _) => Some(enum_id),\n-            ast::DefPrimTy(_) => None,\n-            _ => Some(def_id_of_def(def)),\n+            def::DefVariant(enum_id, _, _) => Some(enum_id),\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id())\n         };\n         match def_id {\n             Some(def_id) => self.check_def_id(def_id),"}, {"sha": "ca89439eabad57dd87a39c5aa4ba77622555bd42", "filename": "src/librustc/middle/def.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+pub enum Def {\n+    DefFn(ast::DefId, ast::FnStyle),\n+    DefStaticMethod(/* method */ ast::DefId, MethodProvenance, ast::FnStyle),\n+    DefSelfTy(/* trait id */ ast::NodeId),\n+    DefMod(ast::DefId),\n+    DefForeignMod(ast::DefId),\n+    DefStatic(ast::DefId, bool /* is_mutbl */),\n+    DefArg(ast::NodeId, ast::BindingMode),\n+    DefLocal(ast::NodeId, ast::BindingMode),\n+    DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n+    DefTy(ast::DefId),\n+    DefTrait(ast::DefId),\n+    DefPrimTy(ast::PrimTy),\n+    DefTyParam(ast::DefId, uint),\n+    DefBinding(ast::NodeId, ast::BindingMode),\n+    DefUse(ast::DefId),\n+    DefUpvar(ast::NodeId,  // id of closed over var\n+             @Def,     // closed over def\n+             ast::NodeId,  // expr node that creates the closure\n+             ast::NodeId), // id for the block/body of the closure expr\n+\n+    /// Note that if it's a tuple struct's definition, the node id of the ast::DefId\n+    /// may either refer to the item definition's id or the StructDef.ctor_id.\n+    ///\n+    /// The cases that I have encountered so far are (this is not exhaustive):\n+    /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n+    ///   it to a def whose id is the item definition's id.\n+    /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n+    ///   it to a def whose id is the StructDef.ctor_id.\n+    DefStruct(ast::DefId),\n+    DefTyParamBinder(ast::NodeId), /* struct, impl or trait with ty params */\n+    DefRegion(ast::NodeId),\n+    DefLabel(ast::NodeId),\n+    DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+pub enum MethodProvenance {\n+    FromTrait(ast::DefId),\n+    FromImpl(ast::DefId),\n+}\n+\n+impl Def {\n+    pub fn def_id(&self) -> ast::DefId {\n+        match *self {\n+            DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n+            DefForeignMod(id) | DefStatic(id, _) |\n+            DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n+            DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n+                id\n+            }\n+            DefArg(id, _) |\n+            DefLocal(id, _) |\n+            DefSelfTy(id) |\n+            DefUpvar(id, _, _, _) |\n+            DefBinding(id, _) |\n+            DefRegion(id) |\n+            DefTyParamBinder(id) |\n+            DefLabel(id) => {\n+                local_def(id)\n+            }\n+\n+            DefPrimTy(_) => fail!()\n+        }\n+    }\n+\n+    pub fn variant_def_ids(&self) -> Option<(ast::DefId, ast::DefId)> {\n+        match *self {\n+            DefVariant(enum_id, var_id, _) => {\n+                Some((enum_id, var_id))\n+            }\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "c75d793cba637c355d2bfa5c243f90da1974536a", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -11,6 +11,7 @@\n //! Enforces the Rust effect system. Currently there is just one effect,\n /// `unsafe`.\n \n+use middle::def;\n use middle::ty;\n use middle::typeck::MethodCall;\n use util::ppaux;\n@@ -183,7 +184,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n             }\n             ast::ExprPath(..) => {\n                 match ty::resolve_expr(self.tcx, expr) {\n-                    ast::DefStatic(_, true) => {\n+                    def::DefStatic(_, true) => {\n                         self.require_unsafe(expr.span, \"use of mutable static\")\n                     }\n                     _ => {}"}, {"sha": "c44ea0ae78b10a9765fbc466a8a1b70672f041ce", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -15,12 +15,12 @@\n  */\n \n use mc = middle::mem_categorization;\n+use middle::def;\n use middle::freevars;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::{Span};\n use util::ppaux::Repr;\n \n@@ -814,7 +814,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                             closure_expr: &ast::Expr,\n                             freevars: &[freevars::freevar_entry]) {\n         for freevar in freevars.iter() {\n-            let id_var = ast_util::def_id_of_def(freevar.def).node;\n+            let id_var = freevar.def.def_id().node;\n             let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                closure_expr.span,\n                                                                freevar.def));\n@@ -850,11 +850,11 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n     fn cat_captured_var(&mut self,\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n-                        upvar_def: ast::Def)\n+                        upvar_def: def::Def)\n                         -> mc::McResult<mc::cmt> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = ast_util::def_id_of_def(upvar_def).node;\n+        let var_id = upvar_def.def_id().node;\n         let var_ty = ty::node_id_to_type(self.tcx(), var_id);\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "614972f3d5776dbd3ed6349b0ff690f66e9be3a9", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -13,12 +13,13 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def;\n use middle::resolve;\n use middle::ty;\n use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::codemap::Span;\n-use syntax::{ast, ast_util};\n+use syntax::{ast};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -35,7 +36,7 @@ pub enum CaptureMode {\n // (The def_upvar will already have been stripped).\n #[deriving(Encodable, Decodable)]\n pub struct freevar_entry {\n-    pub def: ast::Def, //< The variable being accessed free.\n+    pub def: def::Def, //< The variable being accessed free.\n     pub span: Span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_map = NodeMap<Vec<freevar_entry>>;\n@@ -64,13 +65,13 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n                         let mut def = df;\n                         while i < depth {\n                             match def {\n-                                ast::DefUpvar(_, inner, _, _) => { def = *inner; }\n+                                def::DefUpvar(_, inner, _, _) => { def = *inner; }\n                                 _ => break\n                             }\n                             i += 1;\n                         }\n                         if i == depth { // Made it to end of loop\n-                            let dnum = ast_util::def_id_of_def(def).node;\n+                            let dnum = def.def_id().node;\n                             if !self.seen.contains(&dnum) {\n                                 self.refs.push(freevar_entry {\n                                     def: def,"}, {"sha": "39f2e8425833c1e065c6a84cd479914638c29b2a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -11,6 +11,7 @@\n \n use middle::freevars::freevar_entry;\n use middle::freevars;\n+use middle::subst;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n@@ -19,9 +20,8 @@ use util::ppaux::UserString;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::print::pprust::{expr_to_str,path_to_str};\n-use syntax::{visit,ast_util};\n+use syntax::{visit};\n use syntax::visit::Visitor;\n \n // Kind analysis pass.\n@@ -87,8 +87,8 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n                                     struct_did: DefId) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n     if !struct_tpt.generics.has_type_params() {\n-        let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n-            regions: ty::NonerasedRegions(OwnedSlice::empty()),\n+        let struct_ty = ty::mk_struct(cx.tcx, struct_did, subst::Substs {\n+            regions: subst::NonerasedRegions(Vec::new()),\n             self_ty: None,\n             tps: Vec::new()\n         });\n@@ -116,7 +116,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n     let ast_trait_def = *cx.tcx.def_map.borrow()\n                               .find(&trait_ref.ref_id)\n                               .expect(\"trait ref not in def map!\");\n-    let trait_def_id = ast_util::def_id_of_def(ast_trait_def);\n+    let trait_def_id = ast_trait_def.def_id();\n     let trait_def = cx.tcx.trait_defs.borrow()\n                           .find_copy(&trait_def_id)\n                           .expect(\"trait def not in trait-defs map!\");\n@@ -141,7 +141,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n             TyPath(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n                 let struct_def = cx.tcx.def_map.borrow().get_copy(&path_node_id);\n-                let struct_did = ast_util::def_id_of_def(struct_def);\n+                let struct_did = struct_def.def_id();\n                 check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n             }\n             _ => {\n@@ -174,15 +174,15 @@ fn with_appropriate_checker(cx: &Context,\n     fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n-        let id = ast_util::def_id_of_def(fv.def).node;\n+        let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n \n         check_freevar_bounds(cx, fv.span, var_t, bounds, None);\n     }\n \n     fn check_for_block(cx: &Context, fv: &freevar_entry,\n                        bounds: ty::BuiltinBounds, region: ty::Region) {\n-        let id = ast_util::def_id_of_def(fv.def).node;\n+        let id = fv.def.def_id().node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n         // FIXME(#3569): Figure out whether the implicit borrow is actually\n         // mutable. Currently we assume all upvars are referenced mutably.\n@@ -257,7 +257,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n             let def_map = cx.tcx.def_map.borrow();\n             let type_param_defs = match e.node {\n               ExprPath(_) => {\n-                let did = ast_util::def_id_of_def(def_map.get_copy(&e.id));\n+                let did = def_map.get_copy(&e.id).def_id();\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs.clone()\n               }\n               _ => {\n@@ -348,7 +348,7 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n                 None => { }\n                 Some(ref item_substs) => {\n                     let def_map = cx.tcx.def_map.borrow();\n-                    let did = ast_util::def_id_of_def(def_map.get_copy(&id));\n+                    let did = def_map.get_copy(&id).def_id();\n                     let generics = ty::lookup_item_type(cx.tcx, did).generics;\n                     let type_param_defs = generics.type_param_defs();\n                     for (&ty, type_param_def) in"}, {"sha": "cae8436d6df7079a240dc9bfbaa9689b1f1ca591", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -38,6 +38,8 @@\n use driver::session;\n use metadata::csearch;\n use middle::dead::DEAD_CODE_LINT_STR;\n+use middle::def;\n+use middle::def::*;\n use middle::pat_util;\n use middle::privacy;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n@@ -935,17 +937,17 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n         match ty.node {\n             ast::TyPath(_, _, id) => {\n                 match cx.tcx.def_map.borrow().get_copy(&id) {\n-                    ast::DefPrimTy(ast::TyInt(ast::TyI)) => {\n+                    def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                         cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n                                 libc::c_int or libc::c_long should be used\");\n                     }\n-                    ast::DefPrimTy(ast::TyUint(ast::TyU)) => {\n+                    def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n                         cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n                     }\n-                    ast::DefTy(def_id) => {\n+                    def::DefTy(def_id) => {\n                         if !adt::is_ffi_safe(cx.tcx, def_id) {\n                             cx.span_lint(CTypes, ty.span,\n                                          \"found enum type without foreign-function-safe \\\n@@ -1394,7 +1396,7 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     // Lint for constants that look like binding identifiers (#7526)\n     match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-        (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n+        (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n             let ident = path.segments.last().unwrap().identifier;\n             let s = token::get_ident(ident);\n@@ -1411,8 +1413,8 @@ fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n     match &p.node {\n         &ast::PatIdent(_, ref path, _) => {\n             match cx.tcx.def_map.borrow().find(&p.id) {\n-                Some(&ast::DefLocal(_, _)) | Some(&ast::DefBinding(_, _)) |\n-                        Some(&ast::DefArg(_, _)) => {\n+                Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n+                        Some(&def::DefArg(_, _)) => {\n                     // last identifier alone is right choice for this lint.\n                     let ident = path.segments.last().unwrap().identifier;\n                     let s = token::get_ident(ident);\n@@ -1726,7 +1728,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     let id = match e.node {\n         ast::ExprPath(..) | ast::ExprStruct(..) => {\n             match cx.tcx.def_map.borrow().find(&e.id) {\n-                Some(&def) => ast_util::def_id_of_def(def),\n+                Some(&def) => def.def_id(),\n                 None => return\n             }\n         }"}, {"sha": "8b1de130053ee15f944f3640a9a87769df2784b8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -102,7 +102,7 @@\n  *   to return explicitly.\n  */\n \n-\n+use middle::def::*;\n use middle::freevars;\n use middle::lint::{UnusedVariable, DeadAssignment};\n use middle::pat_util;\n@@ -486,7 +486,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n                 match moved_variable_node_id_from_def(fv.def) {\n                     Some(rv) => {\n                         let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                        let fv_id = ast_util::def_id_of_def(fv.def).node;\n+                        let fv_id = fv.def.def_id().node;\n                         let fv_ty = ty::node_id_to_type(ir.tcx, fv_id);\n                         let is_move = match fv_mode {\n                             // var must be dead afterwards"}, {"sha": "06e0a12577270b359dc87e012d29db6ddeca3474", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -62,6 +62,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::NodeMap;\n@@ -489,20 +490,20 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n-                   def: ast::Def)\n+                   def: def::Def)\n                    -> McResult<cmt> {\n         debug!(\"cat_def: id={} expr={} def={:?}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n-          ast::DefStruct(..) | ast::DefVariant(..) => {\n+          def::DefStruct(..) | def::DefVariant(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n-          ast::DefFn(..) | ast::DefStaticMethod(..) | ast::DefMod(_) |\n-          ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n-          ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n-          ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n-          ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n+          def::DefFn(..) | def::DefStaticMethod(..) | def::DefMod(_) |\n+          def::DefForeignMod(_) | def::DefStatic(_, false) |\n+          def::DefUse(_) | def::DefTrait(_) | def::DefTy(_) | def::DefPrimTy(_) |\n+          def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n+          def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -512,7 +513,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          ast::DefStatic(_, true) => {\n+          def::DefStatic(_, true) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -522,7 +523,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }))\n           }\n \n-          ast::DefArg(vid, binding_mode) => {\n+          def::DefArg(vid, binding_mode) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n@@ -540,7 +541,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             }))\n           }\n \n-          ast::DefUpvar(var_id, _, fn_node_id, _) => {\n+          def::DefUpvar(var_id, _, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n@@ -582,8 +583,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n               }\n           }\n \n-          ast::DefLocal(vid, binding_mode) |\n-          ast::DefBinding(vid, binding_mode) => {\n+          def::DefLocal(vid, binding_mode) |\n+          def::DefBinding(vid, binding_mode) => {\n             // by-value/by-ref bindings are local variables\n             let m = match binding_mode {\n                 ast::BindByValue(ast::MutMutable) => McDeclared,\n@@ -987,7 +988,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n             match self.tcx().def_map.borrow().find(&pat.id) {\n-                Some(&ast::DefVariant(enum_did, _, _)) => {\n+                Some(&def::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n \n                     let downcast_cmt = {\n@@ -1009,8 +1010,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                         if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n-                Some(&ast::DefFn(..)) |\n-                Some(&ast::DefStruct(..)) => {\n+                Some(&def::DefFn(..)) |\n+                Some(&def::DefStruct(..)) => {\n                     for (i, &subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                         let cmt_field =\n@@ -1020,7 +1021,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                         if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n-                Some(&ast::DefStatic(..)) => {\n+                Some(&def::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n                         if_ok!(self.cat_pattern(cmt.clone(), subpat, |x,y,z| op(x,y,z)));\n                     }"}, {"sha": "44ed0192d1d27601d809613ca6d7967db6ec615c", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use middle::def::*;\n use middle::resolve;\n \n use std::collections::HashMap;"}, {"sha": "fcd6d4246592ba54bba18f4cadcaa4047252a363", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -15,6 +15,7 @@\n use std::mem::replace;\n \n use metadata::csearch;\n+use middle::def;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n@@ -24,7 +25,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{is_local, def_id_of_def, local_def};\n+use syntax::ast_util::{is_local, local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -243,9 +244,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_, _, id) => {\n                         match self.tcx.def_map.borrow().get_copy(&id) {\n-                            ast::DefPrimTy(..) => true,\n+                            def::DefPrimTy(..) => true,\n                             def => {\n-                                let did = def_id_of_def(def);\n+                                let did = def.def_id();\n                                 !is_local(did) ||\n                                  self.exported_items.contains(&did.node)\n                             }\n@@ -301,9 +302,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 match ty.node {\n                     ast::TyPath(_, _, id) => {\n                         match self.tcx.def_map.borrow().get_copy(&id) {\n-                            ast::DefPrimTy(..) => {},\n+                            def::DefPrimTy(..) => {},\n                             def => {\n-                                let did = def_id_of_def(def);\n+                                let did = def.def_id();\n                                 if is_local(did) {\n                                     self.exported_items.insert(did.node);\n                                 }\n@@ -576,7 +577,7 @@ impl<'a> PrivacyVisitor<'a> {\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n                         let def = self.tcx.def_map.borrow().get_copy(&id);\n-                        let did = def_id_of_def(def);\n+                        let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n                             ast_map::NodeItem(item) => item,\n@@ -673,7 +674,7 @@ impl<'a> PrivacyVisitor<'a> {\n                                                 .last()\n                                                 .unwrap()\n                                                 .identifier);\n-                let origdid = def_id_of_def(orig_def);\n+                let origdid = orig_def.def_id();\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n@@ -750,16 +751,16 @@ impl<'a> PrivacyVisitor<'a> {\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n         match self.tcx.def_map.borrow().get_copy(&path_id) {\n-            ast::DefStaticMethod(..) => ck(\"static method\"),\n-            ast::DefFn(..) => ck(\"function\"),\n-            ast::DefStatic(..) => ck(\"static\"),\n-            ast::DefVariant(..) => ck(\"variant\"),\n-            ast::DefTy(..) => ck(\"type\"),\n-            ast::DefTrait(..) => ck(\"trait\"),\n-            ast::DefStruct(..) => ck(\"struct\"),\n-            ast::DefMethod(_, Some(..)) => ck(\"trait method\"),\n-            ast::DefMethod(..) => ck(\"method\"),\n-            ast::DefMod(..) => ck(\"module\"),\n+            def::DefStaticMethod(..) => ck(\"static method\"),\n+            def::DefFn(..) => ck(\"function\"),\n+            def::DefStatic(..) => ck(\"static\"),\n+            def::DefVariant(..) => ck(\"variant\"),\n+            def::DefTy(..) => ck(\"type\"),\n+            def::DefTrait(..) => ck(\"trait\"),\n+            def::DefStruct(..) => ck(\"struct\"),\n+            def::DefMethod(_, Some(..)) => ck(\"trait method\"),\n+            def::DefMethod(..) => ck(\"method\"),\n+            def::DefMod(..) => ck(\"module\"),\n             _ => {}\n         }\n     }\n@@ -829,7 +830,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get_copy(&expr.id) {\n-                            ast::DefVariant(_, variant_id, _) => {\n+                            def::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n                                                      NamedField(field.ident.node));\n@@ -862,7 +863,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                 };\n                 match self.tcx.def_map.borrow().find(&expr.id) {\n-                    Some(&ast::DefStruct(did)) => {\n+                    Some(&def::DefStruct(did)) => {\n                         guard(if is_local(did) {\n                             local_def(self.tcx.map.get_parent(did.node))\n                         } else {\n@@ -877,7 +878,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                     // Tuple struct constructors across crates are identified as\n                     // DefFn types, so we explicitly handle that case here.\n-                    Some(&ast::DefFn(did, _)) if !is_local(did) => {\n+                    Some(&def::DefFn(did, _)) if !is_local(did) => {\n                         match csearch::get_tuple_struct_definition_if_ctor(\n                                     &self.tcx.sess.cstore, did) {\n                             Some(did) => guard(did),\n@@ -940,7 +941,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().find(&pattern.id) {\n-                            Some(&ast::DefVariant(_, variant_id, _)) => {\n+                            Some(&def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n                                                      NamedField(field.ident));\n@@ -1205,8 +1206,8 @@ impl<'a> VisiblePrivateTypesVisitor<'a> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n             // `int` etc. (None doesn't seem to occur.)\n-            None | Some(ast::DefPrimTy(..)) => return false,\n-            Some(def) => def_id_of_def(def)\n+            None | Some(def::DefPrimTy(..)) => return false,\n+            Some(def) => def.def_id()\n         };\n         // A path can only be private if:\n         // it's in this crate..."}, {"sha": "ef2f78de8f975d0f59efa16db74b871e4cf3eaa4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -16,6 +16,7 @@\n // reachable as well.\n \n use driver::config;\n+use middle::def;\n use middle::ty;\n use middle::typeck;\n use middle::privacy;\n@@ -25,7 +26,7 @@ use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, is_local};\n+use syntax::ast_util::{is_local};\n use syntax::attr;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -109,7 +110,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n                     }\n                 };\n \n-                let def_id = def_id_of_def(def);\n+                let def_id = def.def_id();\n                 if is_local(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(def_id.node)\n@@ -119,7 +120,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n                             // to do some work to figure out whether the static\n                             // is indeed reachable (address_insignificant\n                             // statics are *never* reachable).\n-                            ast::DefStatic(..) => {\n+                            def::DefStatic(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n "}, {"sha": "9bfa0e10aedeff3ba653d0e483356b144c51c8eb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -13,14 +13,15 @@\n use driver::session::Session;\n use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use middle::def::*;\n use middle::lang_items::LanguageItems;\n use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n use syntax::ast;\n-use syntax::ast_util::{def_id_of_def, local_def};\n+use syntax::ast_util::{local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n use syntax::parse::token::special_idents;\n@@ -265,8 +266,8 @@ enum RibKind {\n               // parent;   method itself\n     MethodRibKind(NodeId, MethodSort),\n \n-    // We passed through a function *item* scope. Disallow upvars.\n-    OpaqueFunctionRibKind,\n+    // We passed through an item scope. Disallow upvars.\n+    ItemRibKind,\n \n     // We're in a constant item. Can't refer to dynamic stuff.\n     ConstantItemRibKind\n@@ -1599,7 +1600,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n         if is_exported {\n-            self.external_exports.insert(def_id_of_def(def));\n+            self.external_exports.insert(def.def_id());\n         }\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n@@ -2438,7 +2439,7 @@ impl<'a> Resolver<'a> {\n             Some(ref target) => {\n                 let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n-                let did = def_id_of_def(def);\n+                let did = def.def_id();\n                 if value_used_public {Some(lp)} else {Some(DependsOn(did))}\n             },\n             // AllPublic here and below is a dummy value, it should never be used because\n@@ -2449,7 +2450,7 @@ impl<'a> Resolver<'a> {\n             Some(ref target) => {\n                 let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n-                let did = def_id_of_def(def);\n+                let did = def.def_id();\n                 if type_used_public {Some(lp)} else {Some(DependsOn(did))}\n             },\n             None => None,\n@@ -3307,10 +3308,10 @@ impl<'a> Resolver<'a> {\n             Some(d) => {\n                 let name = token::get_name(name);\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n-                       name, def_id_of_def(d));\n+                       name, d.def_id());\n                 exports2.push(Export2 {\n                     name: name.get().to_string(),\n-                    def_id: def_id_of_def(d)\n+                    def_id: d.def_id()\n                 });\n             }\n             d_opt => {\n@@ -3417,7 +3418,8 @@ impl<'a> Resolver<'a> {\n                 def = d;\n                 is_ty_param = false;\n             }\n-            DlDef(d @ DefTyParam(..)) => {\n+            DlDef(d @ DefTyParam(..)) |\n+            DlDef(d @ DefSelfTy(..)) => {\n                 def = d;\n                 is_ty_param = true;\n             }\n@@ -3434,10 +3436,10 @@ impl<'a> Resolver<'a> {\n                 }\n                 FunctionRibKind(function_id, body_id) => {\n                     if !is_ty_param {\n-                        def = DefUpvar(def_id_of_def(def).node,\n-                                        @def,\n-                                        function_id,\n-                                        body_id);\n+                        def = DefUpvar(def.def_id().node,\n+                                       @def,\n+                                       function_id,\n+                                       body_id);\n                     }\n                 }\n                 MethodRibKind(item_id, _) => {\n@@ -3450,6 +3452,13 @@ impl<'a> Resolver<'a> {\n                     } => {\n                       // ok\n                     }\n+\n+                    DefSelfTy(did) if {\n+                        did == item_id\n+                    } => {\n+                      // ok\n+                    }\n+\n                     _ => {\n                     if !is_ty_param {\n                         // This was an attempt to access an upvar inside a\n@@ -3474,7 +3483,7 @@ impl<'a> Resolver<'a> {\n                     }\n                   }\n                 }\n-                OpaqueFunctionRibKind => {\n+                ItemRibKind => {\n                     if !is_ty_param {\n                         // This was an attempt to access an upvar inside a\n                         // named function item. This is not allowed, so we\n@@ -3574,7 +3583,7 @@ impl<'a> Resolver<'a> {\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                item.id,\n                                                                0,\n-                                                               NormalRibKind),\n+                                                               ItemRibKind),\n                                              |this| {\n                     visit::walk_item(this, item, ());\n                 });\n@@ -3584,7 +3593,7 @@ impl<'a> Resolver<'a> {\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                item.id,\n                                                                0,\n-                                                               NormalRibKind),\n+                                                               ItemRibKind),\n                                              |this| {\n                     visit::walk_item(this, item, ());\n                 });\n@@ -3603,7 +3612,8 @@ impl<'a> Resolver<'a> {\n \n             ItemTrait(ref generics, _, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n-                let self_type_rib = Rib::new(NormalRibKind);\n+                let self_type_rib = Rib::new(ItemRibKind);\n+\n                 // plain insert (no renaming)\n                 let name = self.type_self_ident.name;\n                 self_type_rib.bindings.borrow_mut()\n@@ -3685,7 +3695,7 @@ impl<'a> Resolver<'a> {\n                                 this.with_type_parameter_rib(\n                                     HasTypeParameters(\n                                         generics, foreign_item.id, 0,\n-                                        NormalRibKind),\n+                                        ItemRibKind),\n                                     |this| visit::walk_foreign_item(this,\n                                                                 *foreign_item,\n                                                                 ()));\n@@ -3701,13 +3711,13 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemFn(fn_decl, _, _, ref generics, block) => {\n-                self.resolve_function(OpaqueFunctionRibKind,\n+                self.resolve_function(ItemRibKind,\n                                       Some(fn_decl),\n                                       HasTypeParameters\n                                         (generics,\n                                          item.id,\n                                          0,\n-                                         OpaqueFunctionRibKind),\n+                                         ItemRibKind),\n                                       block);\n             }\n \n@@ -3889,7 +3899,7 @@ impl<'a> Resolver<'a> {\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                        id,\n                                                        0,\n-                                                       OpaqueFunctionRibKind),\n+                                                       ItemRibKind),\n                                      |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n@@ -3967,7 +3977,7 @@ impl<'a> Resolver<'a> {\n \n                 match self.def_map.borrow().find(&trait_ref.ref_id) {\n                     Some(def) => {\n-                        let did = def_id_of_def(*def);\n+                        let did = def.def_id();\n                         Some((did, trait_ref.clone()))\n                     }\n                     None => None\n@@ -4638,7 +4648,7 @@ impl<'a> Resolver<'a> {\n                         let p = child_name_bindings.defined_in_public_namespace(\n                                         namespace);\n                         let lp = if p {LastMod(AllPublic)} else {\n-                            LastMod(DependsOn(def_id_of_def(def)))\n+                            LastMod(DependsOn(def.def_id()))\n                         };\n                         return ChildNameDefinition(def, lp);\n                     }\n@@ -5118,7 +5128,7 @@ impl<'a> Resolver<'a> {\n                                 self.value_ribs.borrow().iter().rev().advance(|rib| {\n                                     let res = match *rib {\n                                         Rib { bindings: _, kind: MethodRibKind(_, _) } => true,\n-                                        Rib { bindings: _, kind: OpaqueFunctionRibKind } => false,\n+                                        Rib { bindings: _, kind: ItemRibKind } => false,\n                                         _ => return true, // Keep advancing\n                                     };\n "}, {"sha": "c4121d830dbdc50b043da75548bcb4c848d3f892", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 76, "deletions": 6, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -15,8 +15,78 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n+use std::vec::Vec;\n use syntax::codemap::Span;\n \n+///////////////////////////////////////////////////////////////////////////\n+\n+/**\n+ * Represents the values to use when substituting lifetime parameters.\n+ * If the value is `ErasedRegions`, then this subst is occurring during\n+ * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n+pub enum RegionSubsts {\n+    ErasedRegions,\n+    NonerasedRegions(Vec<ty::Region>)\n+}\n+\n+/**\n+ * The type `Substs` represents the kinds of things that can be substituted to\n+ * convert a polytype into a monotype.  Note however that substituting bound\n+ * regions other than `self` is done through a different mechanism:\n+ *\n+ * - `tps` represents the type parameters in scope.  They are indexed\n+ *   according to the order in which they were declared.\n+ *\n+ * - `self_r` indicates the region parameter `self` that is present on nominal\n+ *   types (enums, structs) declared as having a region parameter.  `self_r`\n+ *   should always be none for types that are not region-parameterized and\n+ *   Some(_) for types that are.  The only bound region parameter that should\n+ *   appear within a region-parameterized type is `self`.\n+ *\n+ * - `self_ty` is the type to which `self` should be remapped, if any.  The\n+ *   `self` type is rather funny in that it can only appear on traits and is\n+ *   always substituted away to the implementing type for a trait. */\n+#[deriving(Clone, PartialEq, Eq, Hash)]\n+pub struct Substs {\n+    pub self_ty: Option<ty::t>,\n+    pub tps: Vec<ty::t>,\n+    pub regions: RegionSubsts,\n+}\n+\n+impl Substs {\n+    pub fn empty() -> Substs {\n+        Substs {\n+            self_ty: None,\n+            tps: Vec::new(),\n+            regions: NonerasedRegions(Vec::new())\n+        }\n+    }\n+\n+    pub fn trans_empty() -> Substs {\n+        Substs {\n+            self_ty: None,\n+            tps: Vec::new(),\n+            regions: ErasedRegions\n+        }\n+    }\n+\n+    pub fn is_noop(&self) -> bool {\n+        let regions_is_noop = match self.regions {\n+            ErasedRegions => false, // may be used to canonicalize\n+            NonerasedRegions(ref regions) => regions.is_empty()\n+        };\n+\n+        self.tps.len() == 0u &&\n+            regions_is_noop &&\n+            self.self_ty.is_none()\n+    }\n+\n+    pub fn self_ty(&self) -> ty::t {\n+        self.self_ty.unwrap()\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n@@ -25,20 +95,20 @@ use syntax::codemap::Span;\n // there is more information available (for better errors).\n \n pub trait Subst {\n-    fn subst(&self, tcx: &ty::ctxt, substs: &ty::substs) -> Self {\n+    fn subst(&self, tcx: &ty::ctxt, substs: &Substs) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n     fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n+                     substs: &Substs,\n                      span: Option<Span>)\n                      -> Self;\n }\n \n impl<T:TypeFoldable> Subst for T {\n     fn subst_spanned(&self,\n                      tcx: &ty::ctxt,\n-                     substs: &ty::substs,\n+                     substs: &Substs,\n                      span: Option<Span>)\n                      -> T\n     {\n@@ -56,7 +126,7 @@ impl<T:TypeFoldable> Subst for T {\n \n struct SubstFolder<'a> {\n     tcx: &'a ty::ctxt,\n-    substs: &'a ty::substs,\n+    substs: &'a Substs,\n \n     // The location for which the substitution is performed, if available.\n     span: Option<Span>,\n@@ -81,8 +151,8 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n         match r {\n             ty::ReEarlyBound(_, i, _) => {\n                 match self.substs.regions {\n-                    ty::ErasedRegions => ty::ReStatic,\n-                    ty::NonerasedRegions(ref regions) => *regions.get(i),\n+                    ErasedRegions => ty::ReStatic,\n+                    NonerasedRegions(ref regions) => *regions.get(i),\n                 }\n             }\n             _ => r"}, {"sha": "2a3ec63e995ef3b089211fe9313339ca81acbc07", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -198,6 +198,7 @@ use back::abi;\n use driver::config::FullDebugInfo;\n use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n use middle::const_eval;\n+use middle::def;\n use middle::lang_items::{UniqStrEqFnLangItem, StrEqFnLangItem};\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n@@ -336,7 +337,7 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let ccx = bcx.ccx();\n     let def = ccx.tcx.def_map.borrow().get_copy(&pat_id);\n     match def {\n-        ast::DefVariant(enum_id, var_id, _) => {\n+        def::DefVariant(enum_id, var_id, _) => {\n             let variants = ty::enum_variants(ccx.tcx(), enum_id);\n             for v in (*variants).iter() {\n                 if var_id == v.id {\n@@ -346,8 +347,8 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n             }\n             unreachable!();\n         }\n-        ast::DefFn(..) |\n-        ast::DefStruct(_) => {\n+        def::DefFn(..) |\n+        def::DefStruct(_) => {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n@@ -603,7 +604,7 @@ fn enter_opt<'a, 'b>(\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n-                let const_def_id = ast_util::def_id_of_def(const_def);\n+                let const_def_id = const_def.def_id();\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(Vec::new())\n                 } else {\n@@ -644,7 +645,7 @@ fn enter_opt<'a, 'b>(\n                     // Look up the struct variant ID.\n                     let struct_id;\n                     match tcx.def_map.borrow().get_copy(&p.id) {\n-                        ast::DefVariant(_, found_struct_id, _) => {\n+                        def::DefVariant(_, found_struct_id, _) => {\n                             struct_id = found_struct_id;\n                         }\n                         _ => {\n@@ -918,15 +919,15 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 // variable binding.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(ast::DefVariant(..)) => {\n+                    Some(def::DefVariant(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(ast::DefStruct(..)) => {\n+                    Some(def::DefStruct(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n-                    Some(ast::DefStatic(const_did, false)) => {\n+                    Some(def::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -938,12 +939,12 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 // struct-like enum variant, or a struct.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(ast::DefFn(..)) |\n-                    Some(ast::DefVariant(..)) => {\n+                    Some(def::DefFn(..)) |\n+                    Some(def::DefVariant(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(ast::DefStatic(const_did, false)) => {\n+                    Some(def::DefStatic(const_did, false)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -1122,8 +1123,8 @@ fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatEnum(_, _) => {\n                 match bcx.tcx().def_map.borrow().find(&pat.id) {\n-                    Some(&ast::DefFn(..)) |\n-                    Some(&ast::DefStruct(..)) => true,\n+                    Some(&def::DefFn(..)) |\n+                    Some(&def::DefStruct(..)) => true,\n                     _ => false\n                 }\n             }\n@@ -2205,7 +2206,7 @@ fn bind_irrefutable_pat<'a>(\n         ast::PatEnum(_, ref sub_pats) => {\n             let opt_def = bcx.tcx().def_map.borrow().find_copy(&pat.id);\n             match opt_def {\n-                Some(ast::DefVariant(enum_id, var_id, _)) => {\n+                Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n                                                          enum_id,\n@@ -2222,8 +2223,8 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(ast::DefFn(..)) |\n-                Some(ast::DefStruct(..)) => {\n+                Some(def::DefFn(..)) |\n+                Some(def::DefStruct(..)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n@@ -2241,7 +2242,7 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(ast::DefStatic(_, false)) => {\n+                Some(def::DefStatic(_, false)) => {\n                 }\n                 _ => {\n                     // Nothing to do here."}, {"sha": "5f51f80299f4be21e070459de497ffc6269b5da0", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -51,6 +51,8 @@ use std::num::{Bitwise};\n use std::rc::Rc;\n \n use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -304,10 +306,10 @@ impl Case {\n     }\n }\n \n-fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n+fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<Case> {\n     ty::enum_variants(tcx, def_id).iter().map(|vi| {\n         let arg_tys = vi.args.iter().map(|&raw_ty| {\n-            ty::subst(tcx, substs, raw_ty)\n+            raw_ty.subst(tcx, substs)\n         }).collect();\n         Case { discr: vi.disr_val, tys: arg_tys }\n     }).collect()"}, {"sha": "96d059c2f84ce91a19be225812693858feab6171", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -40,6 +40,8 @@ use middle::lint;\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::build::*;\n@@ -442,7 +444,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n                     did: ast::DefId,\n                     t: ty::t,\n                     parent_id: ast::DefId,\n-                    substs: &ty::substs)\n+                    substs: &subst::Substs)\n                  -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = if did.krate != ast::LOCAL_CRATE {\n@@ -463,8 +465,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n     } else {\n         let tcx = ccx.tcx();\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = ty::subst(tcx, substs,\n-                                 ty::lookup_item_type(tcx, parent_id).ty);\n+        let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n                                      [glue::get_drop_glue_type(ccx, t)], ty::mk_nil());\n@@ -633,7 +634,7 @@ pub fn iter_structural_ty<'r,\n                     repr: &adt::Repr,\n                     av: ValueRef,\n                     variant: &ty::VariantInfo,\n-                    substs: &ty::substs,\n+                    substs: &subst::Substs,\n                     f: val_and_ty_fn<'r,'b>)\n                     -> &'b Block<'b> {\n         let _icx = push_ctxt(\"iter_variant\");\n@@ -643,7 +644,7 @@ pub fn iter_structural_ty<'r,\n         for (i, &arg) in variant.args.iter().enumerate() {\n             cx = f(cx,\n                    adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n-                   ty::subst(tcx, substs, arg));\n+                   arg.subst(tcx, substs));\n         }\n         return cx;\n     }\n@@ -1097,19 +1098,19 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n                        id: ast::NodeId,\n                        has_env: bool,\n                        output_type: ty::t,\n-                       param_substs: Option<&'a param_substs>,\n+                       param_substs: &'a param_substs,\n                        sp: Option<Span>,\n                        block_arena: &'a TypedArena<Block<'a>>)\n                        -> FunctionContext<'a> {\n-    for p in param_substs.iter() { p.validate(); }\n+    param_substs.validate();\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n            if id == -1 {\n                \"\".to_string()\n            } else {\n                ccx.tcx.map.path_to_str(id).to_string()\n            },\n-           id, param_substs.map(|s| s.repr(ccx.tcx())));\n+           id, param_substs.repr(ccx.tcx()));\n \n     let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n@@ -1302,7 +1303,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n-                     param_substs: Option<&param_substs>,\n+                     param_substs: &param_substs,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n@@ -1313,7 +1314,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     set_uwtable(llfndecl);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.map(|s| s.repr(ccx.tcx())));\n+           param_substs.repr(ccx.tcx()));\n \n     let has_env = match ty::get(ty::node_id_to_type(ccx.tcx(), id)).sty {\n         ty::ty_closure(_) => true,\n@@ -1326,7 +1327,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                           id,\n                           has_env,\n                           output_type,\n-                          param_substs.map(|s| &*s),\n+                          param_substs,\n                           Some(body.span),\n                           &arena);\n     init_function(&fcx, false, output_type);\n@@ -1402,11 +1403,11 @@ pub fn trans_fn(ccx: &CrateContext,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n-                param_substs: Option<&param_substs>,\n+                param_substs: &param_substs,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id).to_string());\n-    debug!(\"trans_fn(param_substs={})\", param_substs.map(|s| s.repr(ccx.tcx())));\n+    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n     trans_closure(ccx, decl, body, llfndecl,\n@@ -1418,7 +1419,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n                           variant: &ast::Variant,\n                           _args: &[ast::VariantArg],\n                           disr: ty::Disr,\n-                          param_substs: Option<&param_substs>,\n+                          param_substs: &param_substs,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n@@ -1433,7 +1434,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n pub fn trans_tuple_struct(ccx: &CrateContext,\n                           _fields: &[ast::StructField],\n                           ctor_id: ast::NodeId,\n-                          param_substs: Option<&param_substs>,\n+                          param_substs: &param_substs,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n@@ -1448,7 +1449,7 @@ pub fn trans_tuple_struct(ccx: &CrateContext,\n fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                                            ctor_id: ast::NodeId,\n                                            disr: ty::Disr,\n-                                           param_substs: Option<&param_substs>,\n+                                           param_substs: &param_substs,\n                                            llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n     let ctor_ty = ctor_ty.substp(ccx.tcx(), param_substs);\n@@ -1463,7 +1464,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n-                          param_substs.map(|s| &*s), None, &arena);\n+                          param_substs, None, &arena);\n     init_function(&fcx, false, result_ty);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n@@ -1499,7 +1500,7 @@ fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n                 trans_enum_variant(ccx, id, variant, args.as_slice(),\n-                                   disr_val, None, llfn);\n+                                   disr_val, &param_substs::empty(), llfn);\n             }\n             ast::TupleVariantKind(_) => {\n                 // Nothing to do.\n@@ -1586,7 +1587,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                      decl,\n                      body,\n                      llfn,\n-                     None,\n+                     &param_substs::empty(),\n                      item.id,\n                      item.attrs.as_slice());\n         } else {\n@@ -1659,7 +1660,7 @@ pub fn trans_struct_def(ccx: &CrateContext, struct_def: @ast::StructDef) {\n         Some(ctor_id) if struct_def.fields.len() > 0 => {\n             let llfndecl = get_item_val(ccx, ctor_id);\n             trans_tuple_struct(ccx, struct_def.fields.as_slice(),\n-                               ctor_id, None, llfndecl);\n+                               ctor_id, &param_substs::empty(), llfndecl);\n         }\n         Some(_) | None => {}\n     }"}, {"sha": "8ee777278fe6a3841f239ae3ac6b3b14d354d3f3", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -21,6 +21,9 @@ use driver::session;\n use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n use metadata::csearch;\n+use middle::def;\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -39,7 +42,6 @@ use middle::trans::monomorphize;\n use middle::trans::type_of;\n use middle::trans::foreign;\n use middle::ty;\n-use middle::subst::Subst;\n use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n@@ -113,42 +115,42 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         return Callee {bcx: bcx, data: Fn(llfn)};\n     }\n \n-    fn trans_def<'a>(bcx: &'a Block<'a>, def: ast::Def, ref_expr: &ast::Expr)\n+    fn trans_def<'a>(bcx: &'a Block<'a>, def: def::Def, ref_expr: &ast::Expr)\n                  -> Callee<'a> {\n         match def {\n-            ast::DefFn(did, _) |\n-            ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n+            def::DefFn(did, _) |\n+            def::DefStaticMethod(did, def::FromImpl(_), _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ExprId(ref_expr.id)))\n             }\n-            ast::DefStaticMethod(impl_did,\n-                                   ast::FromTrait(trait_did),\n-                                   _) => {\n+            def::DefStaticMethod(impl_did,\n+                                 def::FromTrait(trait_did),\n+                                 _) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx, impl_did,\n                                                                 trait_did,\n                                                                 ref_expr.id))\n             }\n-            ast::DefVariant(tid, vid, _) => {\n+            def::DefVariant(tid, vid, _) => {\n                 // nullary variants are not callable\n                 assert!(ty::enum_variant_with_id(bcx.tcx(),\n                                                       tid,\n                                                       vid).args.len() > 0u);\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ExprId(ref_expr.id)))\n             }\n-            ast::DefStruct(def_id) => {\n+            def::DefStruct(def_id) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, def_id, ExprId(ref_expr.id)))\n             }\n-            ast::DefStatic(..) |\n-            ast::DefArg(..) |\n-            ast::DefLocal(..) |\n-            ast::DefBinding(..) |\n-            ast::DefUpvar(..) => {\n+            def::DefStatic(..) |\n+            def::DefArg(..) |\n+            def::DefLocal(..) |\n+            def::DefBinding(..) |\n+            def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            ast::DefMod(..) | ast::DefForeignMod(..) | ast::DefTrait(..) |\n-            ast::DefTy(..) | ast::DefPrimTy(..) |\n-            ast::DefUse(..) | ast::DefTyParamBinder(..) |\n-            ast::DefRegion(..) | ast::DefLabel(..) | ast::DefTyParam(..) |\n-            ast::DefSelfTy(..) | ast::DefMethod(..) => {\n+            def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n+            def::DefTy(..) | def::DefPrimTy(..) |\n+            def::DefUse(..) | def::DefTyParamBinder(..) |\n+            def::DefRegion(..) | def::DefLabel(..) | def::DefTyParam(..) |\n+            def::DefSelfTy(..) | def::DefMethod(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"cannot translate def {:?} \\\n@@ -184,8 +186,8 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n                                            def_id: ast::DefId,\n                                            ref_id: ast::NodeId,\n-                                           substs: ty::substs,\n-                                           vtables: Option<typeck::vtable_res>)\n+                                           substs: subst::Substs,\n+                                           vtables: typeck::vtable_res)\n                                            -> Callee<'a> {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ExprId(ref_id),\n@@ -195,9 +197,10 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n fn resolve_default_method_vtables(bcx: &Block,\n                                   impl_id: ast::DefId,\n                                   method: &ty::Method,\n-                                  substs: &ty::substs,\n-                                  impl_vtables: Option<typeck::vtable_res>)\n-                          -> (typeck::vtable_res, typeck::vtable_param_res) {\n+                                  substs: &subst::Substs,\n+                                  impl_vtables: typeck::vtable_res)\n+                          -> (typeck::vtable_res, typeck::vtable_param_res)\n+{\n \n     // Get the vtables that the impl implements the trait at\n     let impl_res = ty::lookup_impl_vtables(bcx.tcx(), impl_id);\n@@ -211,27 +214,15 @@ fn resolve_default_method_vtables(bcx: &Block,\n     };\n \n     let mut param_vtables = resolve_vtables_under_param_substs(\n-        bcx.tcx(), Some(&param_substs), impl_res.trait_vtables.as_slice());\n+        bcx.tcx(), &param_substs, impl_res.trait_vtables.as_slice());\n \n     // Now we pull any vtables for parameters on the actual method.\n     let num_method_vtables = method.generics.type_param_defs().len();\n-    match impl_vtables {\n-        Some(ref vtables) => {\n-            let num_impl_type_parameters =\n-                vtables.len() - num_method_vtables;\n-            param_vtables.push_all(vtables.tailn(num_impl_type_parameters))\n-        },\n-        None => {\n-            param_vtables.extend(range(0, num_method_vtables).map(\n-                |_| -> typeck::vtable_param_res {\n-                    Vec::new()\n-                }\n-            ))\n-        }\n-    }\n+    let num_impl_type_parameters = impl_vtables.len() - num_method_vtables;\n+    param_vtables.push_all(impl_vtables.tailn(num_impl_type_parameters));\n \n     let self_vtables = resolve_param_vtables_under_param_substs(\n-        bcx.tcx(), Some(&param_substs), impl_res.self_vtables.as_slice());\n+        bcx.tcx(), &param_substs, impl_res.self_vtables.as_slice());\n \n     (param_vtables, self_vtables)\n }\n@@ -241,8 +232,8 @@ pub fn trans_fn_ref_with_vtables(\n         bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n         node: ExprOrMethodCall,  // node id of use of fn; may be zero if N/A\n-        substs: ty::substs, // values for fn's ty params\n-        vtables: Option<typeck::vtable_res>) // vtables for the call\n+        substs: subst::Substs, // values for fn's ty params\n+        vtables: typeck::vtable_res) // vtables for the call\n      -> ValueRef {\n     /*!\n      * Translates a reference to a fn/method item, monomorphizing and\n@@ -334,7 +325,7 @@ pub fn trans_fn_ref_with_vtables(\n                    self_vtables.repr(tcx), param_vtables.repr(tcx));\n \n             (true, source_id,\n-             new_substs, Some(self_vtables), Some(param_vtables))\n+             new_substs, Some(self_vtables), param_vtables)\n         }\n     };\n \n@@ -504,8 +495,8 @@ pub fn trans_lang_call<'a>(\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n                                                                     0,\n-                                                                    ty::substs::empty(),\n-                                                                    None)\n+                                                                    subst::Substs::empty(),\n+                                                                    Vec::new())\n                              },\n                              ArgVals(args),\n                              dest)"}, {"sha": "f956b58031cde143c7812b1936d44ea997f07184", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -13,6 +13,7 @@ use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use driver::config::FullDebugInfo;\n use lib::llvm::ValueRef;\n+use middle::def;\n use middle::freevars;\n use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::trans::base::*;\n@@ -30,7 +31,6 @@ use util::ppaux::ty_to_str;\n \n use arena::TypedArena;\n use syntax::ast;\n-use syntax::ast_util;\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -282,7 +282,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n             ty::RegionTraitStore(..) => { upvarptr = Load(bcx, upvarptr); }\n             ty::UniqTraitStore => {}\n         }\n-        let def_id = ast_util::def_id_of_def(freevar.def);\n+        let def_id = freevar.def.def_id();\n \n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n \n@@ -368,13 +368,13 @@ pub fn trans_expr_fn<'a>(\n \n pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                closure_ty: ty::t,\n-                               def: ast::Def,\n+                               def: def::Def,\n                                fn_ptr: ValueRef,\n                                is_local: bool) -> ValueRef {\n \n     let def_id = match def {\n-        ast::DefFn(did, _) | ast::DefStaticMethod(did, _, _) |\n-        ast::DefVariant(_, did, _) | ast::DefStruct(did) => did,\n+        def::DefFn(did, _) | def::DefStaticMethod(did, _, _) |\n+        def::DefVariant(_, did, _) | def::DefStruct(did) => did,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a statically resolved fn, got \\\n@@ -421,7 +421,9 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     let _icx = push_ctxt(\"closure::get_wrapper_for_bare_fn\");\n \n     let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output, None, None, &arena);\n+    let empty_param_substs = param_substs::empty();\n+    let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output,\n+                          &empty_param_substs, None, &arena);\n     init_function(&fcx, true, f.sig.output);\n     let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n \n@@ -453,7 +455,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n \n pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n                                      closure_ty: ty::t,\n-                                     def: ast::Def,\n+                                     def: def::Def,\n                                      fn_ptr: ValueRef)\n                                      -> DatumBlock<'a, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");"}, {"sha": "1bcf47531dd561bb757da7e95b834f7e75e3ce24", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -17,14 +17,16 @@ use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef};\n use lib::llvm::{True, False, Bool};\n use lib::llvm::llvm;\n use lib;\n+use middle::def;\n use middle::lang_items::LangItem;\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::ty;\n-use middle::subst::Subst;\n use middle::typeck;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n@@ -177,12 +179,20 @@ pub type ExternMap = HashMap<String, ValueRef>;\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n-    pub substs: ty::substs,\n-    pub vtables: Option<typeck::vtable_res>,\n+    pub substs: subst::Substs,\n+    pub vtables: typeck::vtable_res,\n     pub self_vtables: Option<typeck::vtable_param_res>\n }\n \n impl param_substs {\n+    pub fn empty() -> param_substs {\n+        param_substs {\n+            substs: subst::Substs::trans_empty(),\n+            vtables: Vec::new(),\n+            self_vtables: None\n+        }\n+    }\n+\n     pub fn validate(&self) {\n         for t in self.substs.tps.iter() {\n             assert!(!ty::type_needs_infer(*t));\n@@ -204,21 +214,13 @@ impl Repr for param_substs {\n }\n \n pub trait SubstP {\n-    fn substp(&self, tcx: &ty::ctxt, param_substs: Option<&param_substs>)\n+    fn substp(&self, tcx: &ty::ctxt, param_substs: &param_substs)\n               -> Self;\n }\n \n impl<T:Subst+Clone> SubstP for T {\n-    fn substp(&self, tcx: &ty::ctxt, param_substs: Option<&param_substs>)\n-              -> T {\n-        match param_substs {\n-            Some(substs) => {\n-                self.subst(tcx, &substs.substs)\n-            }\n-            None => {\n-                (*self).clone()\n-            }\n-        }\n+    fn substp(&self, tcx: &ty::ctxt, substs: &param_substs) -> T {\n+        self.subst(tcx, &substs.substs)\n     }\n }\n \n@@ -279,7 +281,7 @@ pub struct FunctionContext<'a> {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    pub param_substs: Option<&'a param_substs>,\n+    pub param_substs: &'a param_substs,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -453,7 +455,7 @@ impl<'a> Block<'a> {\n         e.repr(self.tcx())\n     }\n \n-    pub fn def(&self, nid: ast::NodeId) -> ast::Def {\n+    pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -695,16 +697,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n-    match bcx.fcx.param_substs {\n-        Some(ref substs) => {\n-            ty::subst(bcx.tcx(), &substs.substs, t)\n-        }\n-        _ => {\n-            assert!(!ty::type_has_params(t));\n-            assert!(!ty::type_has_self(t));\n-            t\n-        }\n-    }\n+    t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n }\n \n pub fn node_id_type(bcx: &Block, id: ast::NodeId) -> ty::t {\n@@ -733,7 +726,7 @@ pub enum ExprOrMethodCall {\n \n pub fn node_id_substs(bcx: &Block,\n                       node: ExprOrMethodCall)\n-                      -> ty::substs {\n+                      -> subst::Substs {\n     let tcx = bcx.tcx();\n \n     let substs = match node {\n@@ -757,10 +750,10 @@ pub fn node_id_substs(bcx: &Block,\n }\n \n pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n-                 -> Option<typeck::vtable_res> {\n+                 -> typeck::vtable_res {\n     bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n         resolve_vtables_in_fn_ctxt(bcx.fcx, vts.as_slice())\n-    })\n+    }).unwrap_or_else(|| Vec::new())\n }\n \n // Apply the typaram substitutions in the FunctionContext to some\n@@ -774,7 +767,7 @@ pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n }\n \n pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n-                                          param_substs: Option<&param_substs>,\n+                                          param_substs: &param_substs,\n                                           vts: &[typeck::vtable_param_res])\n                                           -> typeck::vtable_res {\n     vts.iter().map(|ds| {\n@@ -786,7 +779,7 @@ pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n \n pub fn resolve_param_vtables_under_param_substs(\n     tcx: &ty::ctxt,\n-    param_substs: Option<&param_substs>,\n+    param_substs: &param_substs,\n     ds: &[typeck::vtable_origin])\n     -> typeck::vtable_param_res {\n     ds.iter().map(|d| {\n@@ -799,7 +792,7 @@ pub fn resolve_param_vtables_under_param_substs(\n \n \n pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n-                                         param_substs: Option<&param_substs>,\n+                                         param_substs: &param_substs,\n                                          vt: &typeck::vtable_origin)\n                                          -> typeck::vtable_origin {\n     match *vt {\n@@ -810,16 +803,7 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                 resolve_vtables_under_param_substs(tcx, param_substs, sub.as_slice()))\n         }\n         typeck::vtable_param(n_param, n_bound) => {\n-            match param_substs {\n-                Some(substs) => {\n-                    find_vtable(tcx, substs, n_param, n_bound)\n-                }\n-                _ => {\n-                    tcx.sess.bug(format!(\n-                        \"resolve_vtable_under_param_substs: asked to lookup \\\n-                         but no vtables in the fn_ctxt!\").as_slice())\n-                }\n-            }\n+            find_vtable(tcx, param_substs, n_param, n_bound)\n         }\n     }\n }\n@@ -835,9 +819,7 @@ pub fn find_vtable(tcx: &ty::ctxt,\n     let param_bounds = match n_param {\n         typeck::param_self => ps.self_vtables.as_ref().expect(\"self vtables missing\"),\n         typeck::param_numbered(n) => {\n-            let tables = ps.vtables.as_ref()\n-                .expect(\"vtables missing where they are needed\");\n-            tables.get(n)\n+            ps.vtables.get(n)\n         }\n     };\n     param_bounds.get(n_bound).clone()"}, {"sha": "ac6e9ca6c645ef68e041f782386b6ca8dc2b13bc", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -17,6 +17,7 @@ use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, In\n \n use metadata::csearch;\n use middle::const_eval;\n+use middle::def;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::push_ctxt;\n@@ -617,7 +618,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {\n-                Some(ast::DefFn(def_id, _fn_style)) => {\n+                Some(def::DefFn(def_id, _fn_style)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx(), def_id).ty;\n                         (base::trans_external_path(cx, def_id, ty), true)\n@@ -626,18 +627,18 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                         (base::get_item_val(cx, def_id.node), true)\n                     }\n                 }\n-                Some(ast::DefStatic(def_id, false)) => {\n+                Some(def::DefStatic(def_id, false)) => {\n                     get_const_val(cx, def_id)\n                 }\n-                Some(ast::DefVariant(enum_did, variant_did, _)) => {\n+                Some(def::DefVariant(enum_did, variant_did, _)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n                     (adt::trans_const(cx, &*repr, vinfo.disr_val, []), true)\n                 }\n-                Some(ast::DefStruct(_)) => {\n+                Some(def::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n                     let llty = type_of::type_of(cx, ety);\n                     (C_null(llty), true)\n@@ -650,14 +651,14 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n           ast::ExprCall(callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n               match opt_def {\n-                  Some(ast::DefStruct(_)) => {\n+                  Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, &*repr, 0, arg_vals.as_slice()),\n                        inlineable)\n                   }\n-                  Some(ast::DefVariant(enum_did, variant_did, _)) => {\n+                  Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),"}, {"sha": "ea152c348087c4052d05682e862909f16f775464", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -10,6 +10,7 @@\n \n use lib::llvm::*;\n use driver::config::FullDebugInfo;\n+use middle::def;\n use middle::lang_items::{FailFnLangItem, FailBoundsCheckFnLangItem};\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -288,7 +289,7 @@ pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n             match bcx.tcx().def_map.borrow().find(&expr_id) {\n-                Some(&ast::DefLabel(loop_id)) => loop_id,\n+                Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n                                                r).as_slice())"}, {"sha": "b709fa52cf730261906458ebc108e6cdec91ac27", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -131,6 +131,7 @@ use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n use metadata::csearch;\n+use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, Lvalue};\n@@ -620,7 +621,7 @@ pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n /// indicates why no debuginfo should be created for the function.\n pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n-                                     param_substs: Option<&param_substs>,\n+                                     param_substs: &param_substs,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext { repr: DebugInfoDisabled };\n@@ -787,7 +788,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n                               fn_decl: &ast::FnDecl,\n-                              param_substs: Option<&param_substs>,\n+                              param_substs: &param_substs,\n                               error_span: Span) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), []);\n@@ -822,14 +823,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     fn get_template_parameters(cx: &CrateContext,\n                                generics: &ast::Generics,\n-                               param_substs: Option<&param_substs>,\n+                               param_substs: &param_substs,\n                                file_metadata: DIFile,\n                                name_to_append_suffix_to: &mut String)\n                                -> DIArray {\n-        let self_type = match param_substs {\n-            Some(param_substs) => param_substs.substs.self_ty,\n-            _ => None\n-        };\n+        let self_type = param_substs.substs.self_ty;\n \n         // Only true for static default methods:\n         let has_self_type = self_type.is_some();\n@@ -883,13 +881,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n \n         // Handle other generic parameters\n-        let actual_types = match param_substs {\n-            Some(param_substs) => &param_substs.substs.tps,\n-            None => {\n-                return create_DIArray(DIB(cx), template_params.as_slice());\n-            }\n-        };\n-\n+        let actual_types = &param_substs.substs.tps;\n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n@@ -1356,7 +1348,7 @@ impl StructMemberDescriptionFactory {\n fn prepare_struct_metadata(cx: &CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n-                           substs: &ty::substs,\n+                           substs: &subst::Substs,\n                            span: Span)\n                         -> RecursiveTypeDescription {\n     let struct_name = ppaux::ty_to_str(cx.tcx(), struct_type);\n@@ -2251,7 +2243,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n fn trait_metadata(cx: &CrateContext,\n                   def_id: ast::DefId,\n                   trait_type: ty::t,\n-                  substs: &ty::substs,\n+                  substs: &subst::Substs,\n                   trait_store: ty::TraitStore,\n                   _: &ty::BuiltinBounds)\n                -> DIType {"}, {"sha": "d9ae9b08381708fc6cbdeb71983becba468b17e0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -37,6 +37,7 @@ use back::abi;\n use lib::llvm::{ValueRef, llvm};\n use lib;\n use metadata::csearch;\n+use middle::def;\n use middle::lang_items::MallocFnLangItem;\n use middle::trans::_match;\n use middle::trans::adt;\n@@ -499,18 +500,18 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n \n fn trans_def<'a>(bcx: &'a Block<'a>,\n                  ref_expr: &ast::Expr,\n-                 def: ast::Def)\n+                 def: def::Def)\n                  -> DatumBlock<'a, Expr>\n {\n     //! Translates a reference to a path.\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        ast::DefFn(..) | ast::DefStaticMethod(..) |\n-        ast::DefStruct(_) | ast::DefVariant(..) => {\n+        def::DefFn(..) | def::DefStaticMethod(..) |\n+        def::DefStruct(_) | def::DefVariant(..) => {\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n-        ast::DefStatic(did, _) => {\n+        def::DefStatic(did, _) => {\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             fn get_did(ccx: &CrateContext, did: ast::DefId)\n@@ -775,7 +776,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n fn trans_def_dps_unadjusted<'a>(\n                             bcx: &'a Block<'a>,\n                             ref_expr: &ast::Expr,\n-                            def: ast::Def,\n+                            def: def::Def,\n                             dest: Dest)\n                             -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n@@ -786,7 +787,7 @@ fn trans_def_dps_unadjusted<'a>(\n     };\n \n     match def {\n-        ast::DefVariant(tid, vid, _) => {\n+        def::DefVariant(tid, vid, _) => {\n             let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n@@ -802,7 +803,7 @@ fn trans_def_dps_unadjusted<'a>(\n                 return bcx;\n             }\n         }\n-        ast::DefStruct(_) => {\n+        def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n@@ -823,16 +824,16 @@ fn trans_def_dps_unadjusted<'a>(\n \n fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n                                ref_expr: &ast::Expr,\n-                               def: ast::Def) -> DatumBlock<'a, Expr> {\n+                               def: def::Def) -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let llfn = match def {\n-        ast::DefFn(did, _) |\n-        ast::DefStruct(did) | ast::DefVariant(_, did, _) |\n-        ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n+        def::DefFn(did, _) |\n+        def::DefStruct(did) | def::DefVariant(_, did, _) |\n+        def::DefStaticMethod(did, def::FromImpl(_), _) => {\n             callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n         }\n-        ast::DefStaticMethod(impl_did, ast::FromTrait(trait_did), _) => {\n+        def::DefStaticMethod(impl_did, def::FromTrait(trait_did), _) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n                                              trait_did, ref_expr.id)\n         }\n@@ -849,7 +850,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n }\n \n pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n-                           def: ast::Def)\n+                           def: def::Def)\n                            -> Datum<Lvalue> {\n     /*!\n      * Translates a reference to a local variable or argument.\n@@ -859,7 +860,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n-        ast::DefUpvar(nid, _, _, _) => {\n+        def::DefUpvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.borrow().find(&nid) {\n@@ -871,10 +872,10 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n                 }\n             }\n         }\n-        ast::DefArg(nid, _) => {\n+        def::DefArg(nid, _) => {\n             take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)\n         }\n-        ast::DefLocal(nid, _) | ast::DefBinding(nid, _) => {\n+        def::DefLocal(nid, _) | def::DefBinding(nid, _) => {\n             take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)\n         }\n         _ => {\n@@ -931,7 +932,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow().get_copy(&node_id);\n                     match def {\n-                        ast::DefVariant(enum_id, variant_id, _) => {\n+                        def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n                             op(variant_info.disr_val,"}, {"sha": "6f217d83a624a2497f29fd016d6940877c63d5a5", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -570,7 +570,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n         base::set_llvm_fn_attrs(attrs, llfn);\n-        base::trans_fn(ccx, decl, body, llfn, None, id, []);\n+        base::trans_fn(ccx, decl, body, llfn, &param_substs::empty(), id, []);\n         llfn\n     }\n "}, {"sha": "96aa7267d231ab8aa65014a056e6781a2eca6e91", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -18,6 +18,7 @@ use back::link::*;\n use lib::llvm::{llvm, ValueRef, True};\n use lib;\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n+use middle::subst;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -229,7 +230,7 @@ fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n                               v0: ValueRef,\n                               dtor_did: ast::DefId,\n                               class_did: ast::DefId,\n-                              substs: &ty::substs)\n+                              substs: &subst::Substs)\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, &*repr, v0);\n@@ -243,7 +244,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n                          v0: ValueRef,\n                          dtor_did: ast::DefId,\n                          class_did: ast::DefId,\n-                         substs: &ty::substs)\n+                         substs: &subst::Substs)\n                          -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n@@ -478,7 +479,9 @@ fn make_generic_glue(ccx: &CrateContext,\n     let _s = StatRecorder::new(ccx, glue_name);\n \n     let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, llfn, -1, false, ty::mk_nil(), None, None, &arena);\n+    let empty_param_substs = param_substs::empty();\n+    let fcx = new_fn_ctxt(ccx, llfn, -1, false, ty::mk_nil(),\n+                          &empty_param_substs, None, &arena);\n \n     init_function(&fcx, false, ty::mk_nil());\n "}, {"sha": "c14ff7a49eabcaa69040e57b212e74223b1fb48d", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -131,7 +131,8 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n           if num_type_params == 0 {\n               let llfn = get_item_val(ccx, mth.id);\n-              trans_fn(ccx, mth.decl, mth.body, llfn, None, mth.id, []);\n+              trans_fn(ccx, mth.decl, mth.body, llfn,\n+                       &param_substs::empty(), mth.id, []);\n           }\n           local_def(mth.id)\n         }"}, {"sha": "0719288bb028529e03c8e31a41df6fc45d7e6bfb", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -192,7 +192,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, decl, item.id, false, output_type,\n-                          Some(&*substs), Some(item.span), &arena);\n+                          substs, Some(item.span), &arena);\n     init_function(&fcx, true, output_type);\n \n     set_always_inline(fcx.llfn);"}, {"sha": "2beb3be3d275085e03cbc497d5acbd408fbf9583", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -14,6 +14,7 @@ use lib::llvm::llvm;\n use lib::llvm::ValueRef;\n use lib;\n use metadata::csearch;\n+use middle::subst;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee::*;\n@@ -67,7 +68,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             trans_fn(ccx, method.decl, method.body,\n-                     llfn, None, method.id, []);\n+                     llfn, &param_substs::empty(), method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n             visit::walk_method_helper(&mut v, *method, ());\n@@ -109,19 +110,13 @@ pub fn trans_method_callee<'a>(\n             param_num: p,\n             bound_num: b\n         }) => {\n-            match bcx.fcx.param_substs {\n-                Some(substs) => {\n-                    ty::populate_implementations_for_trait_if_necessary(\n-                        bcx.tcx(),\n-                        trait_id);\n-\n-                    let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n-                    trans_monomorphized_callee(bcx, method_call,\n-                                               trait_id, off, vtbl)\n-                }\n-                // how to get rid of this?\n-                None => fail!(\"trans_method_callee: missing param_substs\")\n-            }\n+            ty::populate_implementations_for_trait_if_necessary(\n+                bcx.tcx(),\n+                trait_id);\n+\n+            let vtbl = find_vtable(bcx.tcx(), bcx.fcx.param_substs, p, b);\n+            trans_monomorphized_callee(bcx, method_call,\n+                                       trait_id, off, vtbl)\n         }\n \n         typeck::MethodObject(ref mt) => {\n@@ -208,7 +203,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n \n             let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n                                                  callee_substs,\n-                                                 Some(callee_origins));\n+                                                 callee_origins);\n \n             let callee_ty = node_id_type(bcx, expr_id);\n             let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n@@ -264,7 +259,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n                                                mth_id,\n                                                MethodCall(method_call),\n                                                callee_substs,\n-                                               Some(callee_origins));\n+                                               callee_origins);\n \n           Callee { bcx: bcx, data: Fn(llfn) }\n       }\n@@ -277,9 +272,9 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n fn combine_impl_and_methods_tps(bcx: &Block,\n                                 mth_did: ast::DefId,\n                                 node: ExprOrMethodCall,\n-                                rcvr_substs: ty::substs,\n+                                rcvr_substs: subst::Substs,\n                                 rcvr_origins: typeck::vtable_res)\n-                                -> (ty::substs, typeck::vtable_res)\n+                                -> (subst::Substs, typeck::vtable_res)\n {\n     /*!\n      * Creates a concatenated set of substitutions which includes\n@@ -321,23 +316,13 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n         MethodCall(method_call) => method_call\n     };\n     let mut vtables = rcvr_origins;\n-    match node_vtables(bcx, vtable_key) {\n-        Some(vt) => {\n-            let start = vt.len() - n_m_tps;\n-            vtables.extend(vt.move_iter().skip(start));\n-        }\n-        None => {\n-            vtables.extend(range(0, n_m_tps).map(\n-                |_| -> typeck::vtable_param_res {\n-                    Vec::new()\n-                }\n-            ));\n-        }\n-    }\n+    let vt = node_vtables(bcx, vtable_key);\n+    let start = vt.len() - n_m_tps;\n+    vtables.extend(vt.move_iter().skip(start));\n \n-    let ty_substs = ty::substs {\n+    let ty_substs = subst::Substs {\n         tps: tps,\n-        regions: ty::ErasedRegions,\n+        regions: subst::ErasedRegions,\n         self_ty: rcvr_self_ty\n     };\n \n@@ -493,7 +478,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n \n fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n-                       substs: ty::substs,\n+                       substs: subst::Substs,\n                        vtables: typeck::vtable_res)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n@@ -524,7 +509,7 @@ fn emit_vtable_methods(bcx: &Block,\n             C_null(Type::nil(ccx).ptr_to())\n         } else {\n             trans_fn_ref_with_vtables(bcx, m_id, ExprId(0),\n-                                      substs.clone(), Some(vtables.clone()))\n+                                      substs.clone(), vtables.clone())\n         }\n     }).collect()\n }"}, {"sha": "9559c0909a6abf42f17439efdbbadc72befaf7c8", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -11,6 +11,8 @@\n use back::link::exported_name;\n use driver::session;\n use lib::llvm::ValueRef;\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n use middle::trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n@@ -29,8 +31,8 @@ use std::hash::{sip, Hash};\n \n pub fn monomorphic_fn(ccx: &CrateContext,\n                       fn_id: ast::DefId,\n-                      real_substs: &ty::substs,\n-                      vtables: Option<typeck::vtable_res>,\n+                      real_substs: &subst::Substs,\n+                      vtables: typeck::vtable_res,\n                       self_vtables: Option<typeck::vtable_param_res>,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool) {\n@@ -53,23 +55,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n     let substs_iter = real_substs.self_ty.iter().chain(real_substs.tps.iter());\n-    let param_ids: Vec<MonoParamId> = match vtables {\n-        Some(ref vts) => {\n-            debug!(\"make_mono_id vtables={} psubsts={}\",\n-                   vts.repr(ccx.tcx()), real_substs.tps.repr(ccx.tcx()));\n-            let vts_iter = self_vtables.iter().chain(vts.iter());\n-            vts_iter.zip(substs_iter).map(|(vtable, subst)| MonoParamId {\n-                subst: *subst,\n-                // Do we really need the vtables to be hashed? Isn't the type enough?\n-                vtables: vtable.iter().map(|vt| make_vtable_id(ccx, vt)).collect()\n-            }).collect()\n-        }\n-        None => substs_iter.map(|subst| MonoParamId {\n-            subst: *subst,\n-            vtables: Vec::new()\n-        }).collect()\n-    };\n-\n+    let param_ids: Vec<ty::t> = substs_iter.map(|t| *t).collect();\n     let hash_id = MonoId {\n         def: fn_id,\n         params: param_ids\n@@ -139,7 +125,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst(ccx.tcx(), real_substs, llitem_ty),\n+        None => llitem_ty.subst(ccx.tcx(), real_substs),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n             // that the \"internal\" and \"external\" type of them differ.\n@@ -161,14 +147,14 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             tps.push(real_substs.self_ty.unwrap());\n             tps.push_all(real_substs.tps.tailn(idx));\n \n-            let substs = ty::substs { regions: ty::ErasedRegions,\n-                                      self_ty: None,\n-                                      tps: tps };\n+            let substs = subst::Substs { regions: subst::ErasedRegions,\n+                                         self_ty: None,\n+                                         tps: tps };\n \n             debug!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx()));\n \n-            ty::subst(ccx.tcx(), &substs, llitem_ty)\n+            llitem_ty.subst(ccx.tcx(), &substs)\n         }\n     };\n \n@@ -220,7 +206,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n               } => {\n                   let d = mk_lldecl();\n                   set_llvm_fn_attrs(i.attrs.as_slice(), d);\n-                  trans_fn(ccx, decl, body, d, Some(&psubsts), fn_id.node, []);\n+                  trans_fn(ccx, decl, body, d, &psubsts, fn_id.node, []);\n                   d\n               }\n               _ => {\n@@ -252,7 +238,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                                        v,\n                                        args.as_slice(),\n                                        this_tv.disr_val,\n-                                       Some(&psubsts),\n+                                       &psubsts,\n                                        d);\n                 }\n                 ast::StructVariantKind(_) =>\n@@ -263,15 +249,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, mth.decl, mth.body, d, Some(&psubsts), mth.id, []);\n+            trans_fn(ccx, mth.decl, mth.body, d, &psubsts, mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, mth.decl, mth.body, d, Some(&psubsts), mth.id, []);\n+                    trans_fn(ccx, mth.decl, mth.body, d, &psubsts, mth.id, []);\n                     d\n                 }\n                 _ => {\n@@ -287,7 +273,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                                      struct_def.fields.as_slice(),\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n-                                     Some(&psubsts),\n+                                     &psubsts,\n                                      d);\n             d\n         }\n@@ -315,33 +301,22 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoParamId {\n     pub subst: ty::t,\n-    // Do we really need the vtables to be hashed? Isn't the type enough?\n-    pub vtables: Vec<MonoId>\n }\n \n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoId {\n     pub def: ast::DefId,\n-    pub params: Vec<MonoParamId>\n+    pub params: Vec<ty::t>\n }\n \n-pub fn make_vtable_id(ccx: &CrateContext,\n+pub fn make_vtable_id(_ccx: &CrateContext,\n                       origin: &typeck::vtable_origin)\n                       -> MonoId {\n     match origin {\n-        &typeck::vtable_static(impl_id, ref substs, ref sub_vtables) => {\n+        &typeck::vtable_static(impl_id, ref substs, _) => {\n             MonoId {\n                 def: impl_id,\n-                // FIXME(NDM) -- this is pretty bogus. It ignores self-type,\n-                // and vtables are not necessary, AND they are not guaranteed\n-                // to be same length as the number of TPS ANYHOW!\n-                params: sub_vtables.iter().zip(substs.tps.iter()).map(|(vtable, subst)| {\n-                    MonoParamId {\n-                        subst: *subst,\n-                        // Do we really need the vtables to be hashed? Isn't the type enough?\n-                        vtables: vtable.iter().map(|vt| make_vtable_id(ccx, vt)).collect()\n-                    }\n-                }).collect()\n+                params: substs.tps.iter().map(|subst| *subst).collect()\n             }\n         }\n "}, {"sha": "3b469a1d110633b2bcbf6f8e53fa2679eb5ed8f9", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -297,8 +297,10 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                                                     fn_ty,\n                                                     sym.as_slice());\n                 let arena = TypedArena::new();\n+                let empty_param_substs = param_substs::empty();\n                 let fcx = new_fn_ctxt(ccx, llfdecl, -1, false,\n-                                      ty::mk_u64(), None, None, &arena);\n+                                      ty::mk_u64(), &empty_param_substs,\n+                                      None, &arena);\n                 init_function(&fcx, false, ty::mk_u64());\n \n                 let arg = unsafe {"}, {"sha": "bf5bedd98e88404881f3d970432cb9bdc337c45b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::foreign;\n@@ -21,7 +22,6 @@ use middle::trans::type_::Type;\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::owned_slice::OwnedSlice;\n \n pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n@@ -310,8 +310,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n     let tstr = ppaux::parameterized(cx.tcx(),\n                                     ty::item_path_str(cx.tcx(),\n                                                       did).as_slice(),\n-                                    &ty::NonerasedRegions(\n-                                        OwnedSlice::empty()),\n+                                    &subst::ErasedRegions,\n                                     tps,\n                                     did,\n                                     false);"}, {"sha": "6275abdc8ab209a893742e8a0dd017833e535b75", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 113, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -16,14 +16,16 @@ use metadata::csearch;\n use mc = middle::mem_categorization;\n use middle::lint;\n use middle::const_eval;\n+use middle::def;\n use middle::dependency_format;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::freevars;\n use middle::resolve;\n use middle::resolve_lifetime;\n+use middle::subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty;\n-use middle::subst::Subst;\n use middle::typeck;\n use middle::typeck::MethodCall;\n use middle::ty_fold;\n@@ -207,7 +209,7 @@ pub enum AutoAdjustment {\n     AutoObject(ty::TraitStore,\n                ty::BuiltinBounds,\n                ast::DefId, /* Trait ID */\n-               ty::substs /* Trait substitutions */)\n+               subst::Substs /* Trait substitutions */)\n }\n \n #[deriving(Clone, Decodable, Encodable)]\n@@ -639,40 +641,6 @@ pub enum BoundRegion {\n     BrFresh(uint),\n }\n \n-/**\n- * Represents the values to use when substituting lifetime parameters.\n- * If the value is `ErasedRegions`, then this subst is occurring during\n- * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n-pub enum RegionSubsts {\n-    ErasedRegions,\n-    NonerasedRegions(OwnedSlice<ty::Region>)\n-}\n-\n-/**\n- * The type substs represents the kinds of things that can be substituted to\n- * convert a polytype into a monotype.  Note however that substituting bound\n- * regions other than `self` is done through a different mechanism:\n- *\n- * - `tps` represents the type parameters in scope.  They are indexed\n- *   according to the order in which they were declared.\n- *\n- * - `self_r` indicates the region parameter `self` that is present on nominal\n- *   types (enums, structs) declared as having a region parameter.  `self_r`\n- *   should always be none for types that are not region-parameterized and\n- *   Some(_) for types that are.  The only bound region parameter that should\n- *   appear within a region-parameterized type is `self`.\n- *\n- * - `self_ty` is the type to which `self` should be remapped, if any.  The\n- *   `self` type is rather funny in that it can only appear on traits and is\n- *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct substs {\n-    pub self_ty: Option<ty::t>,\n-    pub tps: Vec<t>,\n-    pub regions: RegionSubsts,\n-}\n-\n mod primitives {\n     use super::t_box_;\n \n@@ -731,7 +699,7 @@ pub enum sty {\n     ty_int(ast::IntTy),\n     ty_uint(ast::UintTy),\n     ty_float(ast::FloatTy),\n-    ty_enum(DefId, substs),\n+    ty_enum(DefId, Substs),\n     ty_box(t),\n     ty_uniq(t),\n     ty_str,\n@@ -741,7 +709,7 @@ pub enum sty {\n     ty_bare_fn(BareFnTy),\n     ty_closure(Box<ClosureTy>),\n     ty_trait(Box<TyTrait>),\n-    ty_struct(DefId, substs),\n+    ty_struct(DefId, Substs),\n     ty_tup(Vec<t>),\n \n     ty_param(param_ty), // type parameter\n@@ -757,15 +725,15 @@ pub enum sty {\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct TyTrait {\n     pub def_id: DefId,\n-    pub substs: substs,\n+    pub substs: Substs,\n     pub store: TraitStore,\n     pub bounds: BuiltinBounds\n }\n \n #[deriving(PartialEq, Eq, Hash)]\n pub struct TraitRef {\n     pub def_id: DefId,\n-    pub substs: substs\n+    pub substs: Substs\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -1032,7 +1000,7 @@ pub struct ParameterEnvironment {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an affect on regions.\n-    pub free_substs: ty::substs,\n+    pub free_substs: Substs,\n \n     /// Bound on the Self parameter\n     pub self_param_bound: Option<Rc<TraitRef>>,\n@@ -1068,11 +1036,11 @@ pub struct TraitDef {\n /// item into the monotype of an item reference.\n #[deriving(Clone)]\n pub struct ItemSubsts {\n-    pub substs: ty::substs,\n+    pub substs: Substs,\n }\n \n pub struct ty_param_substs_and_ty {\n-    pub substs: ty::substs,\n+    pub substs: Substs,\n     pub ty: ty::t\n }\n \n@@ -1176,12 +1144,12 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n             }\n         }\n     }\n-    fn sflags(substs: &substs) -> uint {\n+    fn sflags(substs: &Substs) -> uint {\n         let mut f = 0u;\n         for tt in substs.tps.iter() { f |= get(*tt).flags; }\n         match substs.regions {\n-            ErasedRegions => {}\n-            NonerasedRegions(ref regions) => {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref regions) => {\n                 for r in regions.iter() {\n                     f |= rflags(*r)\n                 }\n@@ -1369,7 +1337,7 @@ pub fn mk_str_slice(cx: &ctxt, r: Region, m: ast::Mutability) -> t {\n             })\n }\n \n-pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: substs) -> t {\n+pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: Substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n@@ -1444,7 +1412,7 @@ pub fn mk_ctor_fn(cx: &ctxt,\n \n pub fn mk_trait(cx: &ctxt,\n                 did: ast::DefId,\n-                substs: substs,\n+                substs: Substs,\n                 store: TraitStore,\n                 bounds: BuiltinBounds)\n              -> t {\n@@ -1458,7 +1426,7 @@ pub fn mk_trait(cx: &ctxt,\n     mk_t(cx, ty_trait(inner))\n }\n \n-pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: substs) -> t {\n+pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n@@ -1524,38 +1492,14 @@ pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n \n impl ItemSubsts {\n     pub fn empty() -> ItemSubsts {\n-        ItemSubsts {\n-            substs: substs::empty(),\n-        }\n+        ItemSubsts { substs: Substs::empty() }\n     }\n \n     pub fn is_noop(&self) -> bool {\n-        ty::substs_is_noop(&self.substs)\n+        self.substs.is_noop()\n     }\n }\n \n-pub fn substs_is_noop(substs: &substs) -> bool {\n-    let regions_is_noop = match substs.regions {\n-        ErasedRegions => false, // may be used to canonicalize\n-        NonerasedRegions(ref regions) => regions.is_empty()\n-    };\n-\n-    substs.tps.len() == 0u &&\n-        regions_is_noop &&\n-        substs.self_ty.is_none()\n-}\n-\n-pub fn substs_to_str(cx: &ctxt, substs: &substs) -> String {\n-    substs.repr(cx)\n-}\n-\n-pub fn subst(cx: &ctxt,\n-             substs: &substs,\n-             typ: t)\n-          -> t {\n-    typ.subst(cx, substs)\n-}\n-\n // Type utilities\n \n pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n@@ -1744,7 +1688,7 @@ fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n           ty_enum(did, ref substs) => {\n             for v in (*enum_variants(cx, did)).iter() {\n                 for aty in v.args.iter() {\n-                    let t = subst(cx, substs, *aty);\n+                    let t = aty.subst(cx, substs);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n                                                    encountered_box);\n@@ -2376,7 +2320,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n                 let vs = enum_variants(cx, did);\n                 let r = !vs.is_empty() && vs.iter().all(|variant| {\n                     variant.args.iter().any(|aty| {\n-                        let sty = subst(cx, substs, *aty);\n+                        let sty = aty.subst(cx, substs);\n                         type_requires(cx, seen, r_ty, sty)\n                     })\n                 });\n@@ -3002,7 +2946,7 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n     }\n }\n \n-pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n+pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().find(&expr.id) {\n         Some(&def) => def,\n         None => {\n@@ -3050,7 +2994,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n     match expr.node {\n         ast::ExprPath(..) => {\n             match resolve_expr(tcx, expr) {\n-                ast::DefVariant(tid, vid, _) => {\n+                def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n                     if variant_info.args.len() > 0u {\n                         // N-ary variant.\n@@ -3061,24 +3005,24 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                     }\n                 }\n \n-                ast::DefStruct(_) => {\n+                def::DefStruct(_) => {\n                     match get(expr_ty(tcx, expr)).sty {\n                         ty_bare_fn(..) => RvalueDatumExpr,\n                         _ => RvalueDpsExpr\n                     }\n                 }\n \n                 // Fn pointers are just scalar values.\n-                ast::DefFn(..) | ast::DefStaticMethod(..) => RvalueDatumExpr,\n+                def::DefFn(..) | def::DefStaticMethod(..) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues.\n-                ast::DefStatic(..) |\n-                ast::DefBinding(..) |\n-                ast::DefUpvar(..) |\n-                ast::DefArg(..) |\n-                ast::DefLocal(..) => LvalueExpr,\n+                def::DefStatic(..) |\n+                def::DefBinding(..) |\n+                def::DefUpvar(..) |\n+                def::DefArg(..) |\n+                def::DefLocal(..) => LvalueExpr,\n \n                 def => {\n                     tcx.sess.span_bug(\n@@ -3169,7 +3113,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 Some(&def) => def,\n                 None => fail!(\"no def for place\"),\n             };\n-            let def_id = ast_util::def_id_of_def(definition);\n+            let def_id = definition.def_id();\n             match tcx.lang_items.items.get(ExchangeHeapLangItem as uint) {\n                 &Some(item_def_id) if def_id == item_def_id => {\n                     RvalueDatumExpr\n@@ -3591,7 +3535,7 @@ pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def = *tcx.def_map.borrow()\n                      .find(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n-    ast_util::def_id_of_def(def)\n+    def.def_id()\n }\n \n pub fn try_add_builtin_trait(tcx: &ctxt,\n@@ -3688,13 +3632,13 @@ impl VariantInfo {\n \n pub fn substd_enum_variants(cx: &ctxt,\n                             id: ast::DefId,\n-                            substs: &substs)\n+                            substs: &Substs)\n                          -> Vec<Rc<VariantInfo>> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n-            .map(|aty| subst(cx, substs, *aty)).collect();\n+            .map(|aty| aty.subst(cx, substs)).collect();\n \n-        let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n+        let substd_ctor_ty = variant_info.ctor_ty.subst(cx, substs);\n \n         Rc::new(VariantInfo {\n             args: substd_args,\n@@ -3944,7 +3888,7 @@ pub fn lookup_repr_hint(tcx: &ctxt, did: DefId) -> attr::ReprAttr {\n pub fn lookup_field_type(tcx: &ctxt,\n                          struct_id: DefId,\n                          id: DefId,\n-                         substs: &substs)\n+                         substs: &Substs)\n                       -> ty::t {\n     let t = if id.krate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n@@ -3959,7 +3903,7 @@ pub fn lookup_field_type(tcx: &ctxt,\n            }\n         }\n     };\n-    subst(tcx, substs, t)\n+    t.subst(tcx, substs)\n }\n \n // Lookup all ancestor structs of a struct indicated by did. That is the reflexive,\n@@ -4027,7 +3971,7 @@ pub fn lookup_struct_field(cx: &ctxt,\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n-pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &substs)\n+pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n                      -> Vec<field> {\n     lookup_struct_fields(cx, did).iter().map(|f| {\n        field {\n@@ -4140,11 +4084,11 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n         }\n \n         fn fold_substs(&mut self,\n-                       substs: &substs)\n-                       -> substs {\n-            substs { regions: ErasedRegions,\n-                     self_ty: substs.self_ty.fold_with(self),\n-                     tps: substs.tps.fold_with(self) }\n+                       substs: &subst::Substs)\n+                       -> subst::Substs {\n+            subst::Substs { regions: subst::ErasedRegions,\n+                            self_ty: substs.self_ty.fold_with(self),\n+                            tps: substs.tps.fold_with(self) }\n         }\n \n         fn fold_sig(&mut self,\n@@ -4292,8 +4236,8 @@ pub fn visitor_object_ty(tcx: &ctxt,\n         Ok(id) => id,\n         Err(s) => { return Err(s); }\n     };\n-    let substs = substs {\n-        regions: ty::NonerasedRegions(OwnedSlice::empty()),\n+    let substs = Substs {\n+        regions: subst::NonerasedRegions(Vec::new()),\n         self_ty: None,\n         tps: Vec::new()\n     };\n@@ -4676,10 +4620,10 @@ pub fn construct_parameter_environment(\n         push_region_params(t, free_id, method_region_params)\n     };\n \n-    let free_substs = substs {\n+    let free_substs = Substs {\n         self_ty: self_ty,\n         tps: type_params,\n-        regions: ty::NonerasedRegions(OwnedSlice::from_vec(region_params))\n+        regions: subst::NonerasedRegions(region_params)\n     };\n \n     //\n@@ -4712,16 +4656,6 @@ pub fn construct_parameter_environment(\n     }\n }\n \n-impl substs {\n-    pub fn empty() -> substs {\n-        substs {\n-            self_ty: None,\n-            tps: Vec::new(),\n-            regions: NonerasedRegions(OwnedSlice::empty())\n-        }\n-    }\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: ast::Mutability) -> BorrowKind {\n         match m {"}, {"sha": "e8f043b5f86959ec0f764823ad5b3ebe59d4c6af", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -10,6 +10,7 @@\n \n // Generalized type folding mechanism.\n \n+use middle::subst;\n use middle::ty;\n use middle::typeck;\n use std::rc::Rc;\n@@ -50,8 +51,8 @@ pub trait TypeFolder {\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &ty::substs)\n-                   -> ty::substs {\n+                   substs: &subst::Substs)\n+                   -> subst::Substs {\n         super_fold_substs(self, substs)\n     }\n \n@@ -180,8 +181,8 @@ impl TypeFoldable for ty::Region {\n     }\n }\n \n-impl TypeFoldable for ty::substs {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::substs {\n+impl TypeFoldable for subst::Substs {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> subst::Substs {\n         folder.fold_substs(self)\n     }\n }\n@@ -278,20 +279,20 @@ pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n }\n \n pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n-                                       substs: &ty::substs)\n-                                       -> ty::substs {\n+                                       substs: &subst::Substs)\n+                                       -> subst::Substs {\n     let regions = match substs.regions {\n-        ty::ErasedRegions => {\n-            ty::ErasedRegions\n+        subst::ErasedRegions => {\n+            subst::ErasedRegions\n         }\n-        ty::NonerasedRegions(ref regions) => {\n-            ty::NonerasedRegions(regions.fold_with(this))\n+        subst::NonerasedRegions(ref regions) => {\n+            subst::NonerasedRegions(regions.fold_with(this))\n         }\n     };\n \n-    ty::substs { regions: regions,\n-                 self_ty: substs.self_ty.fold_with(this),\n-                 tps: substs.tps.fold_with(this) }\n+    subst::Substs { regions: regions,\n+                    self_ty: substs.self_ty.fold_with(this),\n+                    tps: substs.tps.fold_with(this) }\n }\n \n pub fn super_fold_sig<T:TypeFolder>(this: &mut T,"}, {"sha": "f8821a86e717770d56cfa39cc6c851c2c672da92", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -49,10 +49,10 @@\n  * an rptr (`&r.T`) use the region `r` that appears in the rptr.\n  */\n \n-\n use middle::const_eval;\n-use middle::subst::Subst;\n-use middle::ty::{substs};\n+use middle::def;\n+use middle::subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::rscope;\n@@ -152,7 +152,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     rscope: &RS,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n-    path: &ast::Path) -> ty::substs\n+    path: &ast::Path) -> subst::Substs\n {\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n@@ -232,8 +232,8 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                             .map(|&a_t| ast_ty_to_ty(this, rscope, a_t))\n                             .collect();\n \n-    let mut substs = substs {\n-        regions: ty::NonerasedRegions(OwnedSlice::from_vec(regions)),\n+    let mut substs = subst::Substs {\n+        regions: subst::NonerasedRegions(regions),\n         self_ty: self_ty,\n         tps: tps\n     };\n@@ -261,7 +261,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n     } = this.get_item_ty(did);\n \n     let substs = ast_path_substs(this, rscope, &generics, None, path);\n-    let ty = ty::subst(tcx, &substs, decl_ty);\n+    let ty = decl_ty.subst(tcx, &substs);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n@@ -329,7 +329,7 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                 Some(&d) => d\n             };\n             match a_def {\n-                ast::DefPrimTy(nty) => {\n+                def::DefPrimTy(nty) => {\n                     match nty {\n                         ast::TyBool => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -402,7 +402,7 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n             // FIXME(#12938): This is a hack until we have full support for\n             // DST.\n             match a_def {\n-                ast::DefTy(did) | ast::DefStruct(did)\n+                def::DefTy(did) | def::DefStruct(did)\n                         if Some(did) == this.tcx().lang_items.owned_box() => {\n                     if path.segments\n                            .iter()\n@@ -496,7 +496,7 @@ fn mk_pointer<AC:AstConv,\n             // restriction is enforced in the below case for ty_path, which\n             // will run after this as long as the path isn't a trait.\n             match tcx.def_map.borrow().find(&id) {\n-                Some(&ast::DefPrimTy(ast::TyStr)) => {\n+                Some(&def::DefPrimTy(ast::TyStr)) => {\n                     check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                     match ptr_ty {\n                         Uniq => {\n@@ -512,7 +512,7 @@ fn mk_pointer<AC:AstConv,\n                         }\n                     }\n                 }\n-                Some(&ast::DefTrait(trait_def_id)) => {\n+                Some(&def::DefTrait(trait_def_id)) => {\n                     let result = ast_path_to_trait_ref(\n                         this, rscope, trait_def_id, None, path);\n                     let trait_store = match ptr_ty {\n@@ -661,14 +661,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 // Kind bounds on path types are only supported for traits.\n                 match a_def {\n                     // But don't emit the error if the user meant to do a trait anyway.\n-                    ast::DefTrait(..) => { },\n+                    def::DefTrait(..) => { },\n                     _ if bounds.is_some() =>\n                         tcx.sess.span_err(ast_ty.span,\n                                           \"kind bounds can only be used on trait types\"),\n                     _ => { },\n                 }\n                 match a_def {\n-                    ast::DefTrait(_) => {\n+                    def::DefTrait(_) => {\n                         let path_str = path_to_str(path);\n                         tcx.sess.span_err(\n                             ast_ty.span,\n@@ -678,27 +678,27 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                     name=path_str).as_slice());\n                         ty::mk_err()\n                     }\n-                    ast::DefTy(did) | ast::DefStruct(did) => {\n+                    def::DefTy(did) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n                     }\n-                    ast::DefTyParam(id, n) => {\n+                    def::DefTyParam(id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         ty::mk_param(tcx, n, id)\n                     }\n-                    ast::DefSelfTy(id) => {\n+                    def::DefSelfTy(id) => {\n                         // n.b.: resolve guarantees that the this type only appears in a\n                         // trait, which we rely upon in various places when creating\n                         // substs\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         let did = ast_util::local_def(id);\n                         ty::mk_self(tcx, did)\n                     }\n-                    ast::DefMod(id) => {\n+                    def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n                                     tcx.map.node_to_str(id.node)).as_slice());\n                     }\n-                    ast::DefPrimTy(_) => {\n+                    def::DefPrimTy(_) => {\n                         fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     _ => {\n@@ -912,7 +912,7 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n                 match *ast_bound {\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n-                            ast::DefTrait(trait_did) => {\n+                            def::DefTrait(trait_did) => {\n                                 if ty::try_add_builtin_trait(tcx, trait_did,\n                                                              &mut builtin_bounds) {\n                                     continue; // success"}, {"sha": "df774b215042b6cccd73a6740b4797873643ccf4", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -10,7 +10,10 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::def;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::ty;\n use middle::typeck::check::demand;\n use middle::typeck::check::{check_expr, check_expr_has_type, FnCtxt};\n@@ -126,7 +129,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         ty::ty_enum(_, ref expected_substs) => {\n             // Lookup the enum and variant def ids:\n             let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            match ast_util::variant_def_ids(v_def) {\n+            match v_def.variant_def_ids() {\n                 Some((enm, var)) => {\n                     // Assign the pattern the type of the *enum*, not the variant.\n                     let enum_tpt = ty::lookup_item_type(tcx, enm);\n@@ -151,7 +154,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                             if var_tpt.generics.type_param_defs().len() ==\n                                 expected_substs.tps.len()\n                             {\n-                                ty::subst(tcx, expected_substs, *t)\n+                                t.subst(tcx, expected_substs)\n                             }\n                             else {\n                                 *t // In this case, an error was already signaled\n@@ -186,7 +189,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         ty::ty_struct(struct_def_id, ref expected_substs) => {\n             // Lookup the struct ctor def id\n             let s_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            let s_def_id = ast_util::def_id_of_def(s_def);\n+            let s_def_id = s_def.def_id();\n \n             // Assign the pattern the type of the struct.\n             let ctor_tpt = ty::lookup_item_type(tcx, s_def_id);\n@@ -301,7 +304,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                fields: &[ast::FieldPat],\n                                class_fields: Vec<ty::field_ty>,\n                                class_id: ast::DefId,\n-                               substitutions: &ty::substs,\n+                               substitutions: &subst::Substs,\n                                etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -362,19 +365,19 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n                         expected: ty::t, path: &ast::Path,\n                         fields: &[ast::FieldPat], etc: bool,\n                         struct_id: ast::DefId,\n-                        substitutions: &ty::substs) {\n+                        substitutions: &subst::Substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let class_fields = ty::lookup_struct_fields(tcx, struct_id);\n \n     // Check to ensure that the struct is the one specified.\n     match tcx.def_map.borrow().find(&pat_id) {\n-        Some(&ast::DefStruct(supplied_def_id))\n+        Some(&def::DefStruct(supplied_def_id))\n                 if supplied_def_id == struct_id => {\n             // OK.\n         }\n-        Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n+        Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n             let name = pprust::path_to_str(path);\n             tcx.sess\n                .span_err(span,\n@@ -400,21 +403,21 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           fields: &[ast::FieldPat],\n                                           etc: bool,\n                                           enum_id: ast::DefId,\n-                                          substitutions: &ty::substs) {\n+                                          substitutions: &subst::Substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Find the variant that was specified.\n     match tcx.def_map.borrow().find(&pat_id) {\n-        Some(&ast::DefVariant(found_enum_id, variant_id, _))\n+        Some(&def::DefVariant(found_enum_id, variant_id, _))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n             let class_fields = ty::lookup_struct_fields(tcx, variant_id);\n \n             check_struct_pat_fields(pcx, span, fields, class_fields,\n                                     variant_id, substitutions, etc);\n         }\n-        Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n+        Some(&def::DefStruct(..)) | Some(&def::DefVariant(..)) => {\n             let name = pprust::path_to_str(path);\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but \\\n@@ -475,8 +478,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       }\n       ast::PatEnum(..) |\n       ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(tcx.def_map.borrow()\n-                                                   .get_copy(&pat.id));\n+        let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n@@ -556,7 +558,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                             \"a structure pattern\".to_string(),\n                             None);\n                 match tcx.def_map.borrow().find(&pat.id) {\n-                    Some(&ast::DefStruct(supplied_def_id)) => {\n+                    Some(&def::DefStruct(supplied_def_id)) => {\n                          check_struct_pat(pcx,\n                                           pat.id,\n                                           pat.span,\n@@ -565,10 +567,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                           fields.as_slice(),\n                                           etc,\n                                           supplied_def_id,\n-                                          &ty::substs {\n+                                          &subst::Substs {\n                                               self_ty: None,\n                                               tps: Vec::new(),\n-                                              regions: ty::ErasedRegions,\n+                                              regions: subst::ErasedRegions,\n                                           });\n                     }\n                     _ => () // Error, but we're already in an error case"}, {"sha": "0d4fea56e7790ae8253d516d0b2e7935732c581e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -80,6 +80,7 @@ obtained the type `Foo`, we would never match this method.\n */\n \n \n+use middle::subst;\n use middle::subst::Subst;\n use middle::ty::*;\n use middle::ty;\n@@ -104,7 +105,6 @@ use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::owned_slice::OwnedSlice;\n \n #[deriving(PartialEq)]\n pub enum CheckTraitsFlag {\n@@ -233,7 +233,7 @@ fn construct_transformed_self_ty_for_object(\n     tcx: &ty::ctxt,\n     span: Span,\n     trait_def_id: ast::DefId,\n-    rcvr_substs: &ty::substs,\n+    rcvr_substs: &subst::Substs,\n     method_ty: &ty::Method)\n     -> ty::t {\n     /*!\n@@ -257,7 +257,7 @@ fn construct_transformed_self_ty_for_object(\n         * match below.\n         */\n \n-    let substs = ty::substs {regions: rcvr_substs.regions.clone(),\n+    let substs = subst::Substs {regions: rcvr_substs.regions.clone(),\n                                 self_ty: None,\n                                 tps: rcvr_substs.tps.clone()};\n     match method_ty.explicit_self {\n@@ -319,7 +319,7 @@ struct LookupContext<'a> {\n #[deriving(Clone)]\n struct Candidate {\n     rcvr_match_condition: RcvrMatchCondition,\n-    rcvr_substs: ty::substs,\n+    rcvr_substs: subst::Substs,\n     method_ty: Rc<ty::Method>,\n     origin: MethodOrigin,\n }\n@@ -500,7 +500,7 @@ impl<'a> LookupContext<'a> {\n \n     fn push_inherent_candidates_from_object(&mut self,\n                                             did: DefId,\n-                                            substs: &ty::substs) {\n+                                            substs: &subst::Substs) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n                substs.repr(self.tcx()));\n@@ -516,7 +516,7 @@ impl<'a> LookupContext<'a> {\n         //\n         // `confirm_candidate()` also relies upon this substitution\n         // for Self. (fix)\n-        let rcvr_substs = substs {\n+        let rcvr_substs = subst::Substs {\n             self_ty: Some(ty::mk_err()),\n             ..(*substs).clone()\n         };\n@@ -1047,7 +1047,7 @@ impl<'a> LookupContext<'a> {\n             return Some(MethodCallee {\n                 origin: relevant_candidates.get(0).origin,\n                 ty: ty::mk_err(),\n-                substs: substs::empty()\n+                substs: subst::Substs::empty()\n             });\n         }\n \n@@ -1140,8 +1140,10 @@ impl<'a> LookupContext<'a> {\n         // Determine values for the early-bound lifetime parameters.\n         // FIXME -- permit users to manually specify lifetimes\n         let mut all_regions: Vec<Region> = match candidate.rcvr_substs.regions {\n-            NonerasedRegions(ref v) => v.iter().map(|r| r.clone()).collect(),\n-            ErasedRegions => tcx.sess.span_bug(self.span, \"ErasedRegions\")\n+            subst::NonerasedRegions(ref v) => {\n+                v.iter().map(|r| r.clone()).collect()\n+            }\n+            subst::ErasedRegions => tcx.sess.span_bug(self.span, \"ErasedRegions\")\n         };\n         let m_regions =\n             self.fcx.infcx().region_vars_for_defs(\n@@ -1153,9 +1155,9 @@ impl<'a> LookupContext<'a> {\n \n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n-        let all_substs = substs {\n+        let all_substs = subst::Substs {\n             tps: candidate.rcvr_substs.tps.clone().append(m_substs.as_slice()),\n-            regions: NonerasedRegions(OwnedSlice::from_vec(all_regions)),\n+            regions: subst::NonerasedRegions(all_regions),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n \n@@ -1164,7 +1166,7 @@ impl<'a> LookupContext<'a> {\n         // Compute the method type with type parameters substituted\n         debug!(\"fty={} all_substs={}\",\n                bare_fn_ty.repr(tcx),\n-               ty::substs_to_str(tcx, &all_substs));\n+               all_substs.repr(tcx));\n \n         let fn_sig = &bare_fn_ty.sig;\n         let inputs = match candidate.origin {"}, {"sha": "a09c92d4db01fa29765cd0a52a35fce0af711060", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 77, "deletions": 71, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -78,15 +78,17 @@ type parameter).\n \n \n use middle::const_eval;\n+use middle::def;\n use middle::lang_items::{ExchangeHeapLangItem, GcLangItem};\n use middle::lang_items::{ManagedHeapLangItem};\n use middle::lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n-use middle::subst::Subst;\n+use middle::subst;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n-use middle::ty::{substs, param_ty, Disr, ExprTyProvider};\n+use middle::ty::{param_ty, Disr, ExprTyProvider};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -283,9 +285,11 @@ fn blank_fn_ctxt<'a>(ccx: &'a CrateCtxt<'a>,\n fn blank_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n-                                               self_param_bound: None,\n-                                               type_param_bounds: Vec::new() };\n+    let param_env = ty::ParameterEnvironment {\n+        free_substs: subst::Substs::empty(),\n+        self_param_bound: None,\n+        type_param_bounds: Vec::new()\n+    };\n     Inherited::new(ccx.tcx, param_env)\n }\n \n@@ -855,7 +859,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_m_span: Span,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n-                       trait_substs: &ty::substs) {\n+                       trait_substs: &subst::Substs) {\n     debug!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n@@ -983,15 +987,15 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         impl_m.generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n         collect();\n-    let dummy_impl_regions: OwnedSlice<ty::Region> =\n+    let dummy_impl_regions: Vec<ty::Region> =\n         impl_generics.region_param_defs().iter().\n         map(|l| ty::ReFree(ty::FreeRegion {\n                 scope_id: impl_m_body_id,\n                 bound_region: ty::BrNamed(l.def_id, l.name)})).\n         collect();\n-    let dummy_substs = ty::substs {\n+    let dummy_substs = subst::Substs {\n         tps: dummy_impl_tps.append(dummy_method_tps.as_slice()),\n-        regions: ty::NonerasedRegions(dummy_impl_regions),\n+        regions: subst::NonerasedRegions(dummy_impl_regions),\n         self_ty: None };\n \n     // Create a bare fn type for trait/impl\n@@ -1012,10 +1016,10 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     };\n     debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n-        let substs { regions: trait_regions,\n-                     tps: trait_tps,\n-                     self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n-        let substs = substs {\n+        let subst::Substs { regions: trait_regions,\n+                            tps: trait_tps,\n+                            self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n+        let substs = subst::Substs {\n             regions: trait_regions,\n             tps: trait_tps.append(dummy_method_tps.as_slice()),\n             self_ty: self_ty,\n@@ -1107,7 +1111,7 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts) {\n-        if !ty::substs_is_noop(&substs.substs) {\n+        if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n                    substs.repr(self.tcx()),\n@@ -1121,7 +1125,7 @@ impl<'a> FnCtxt<'a> {\n                            node_id: ast::NodeId,\n                            ty: ty::t,\n                            substs: ty::ItemSubsts) {\n-        let ty = ty::subst(self.tcx(), &substs.substs, ty);\n+        let ty = ty.subst(self.tcx(), &substs.substs);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n     }\n@@ -1185,7 +1189,7 @@ impl<'a> FnCtxt<'a> {\n         }\n     }\n \n-    pub fn method_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n+    pub fn method_ty_substs(&self, id: ast::NodeId) -> subst::Substs {\n         match self.inh.method_map.borrow().find(&MethodCall::expr(id)) {\n             Some(method) => method.substs.clone(),\n             None => {\n@@ -1488,12 +1492,12 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     let rps = vcx.infcx.region_vars_for_defs(span, rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n-    let substs = substs {\n-        regions: ty::NonerasedRegions(rps),\n+    let substs = subst::Substs {\n+        regions: subst::NonerasedRegions(rps),\n         self_ty: None,\n         tps: tps,\n     };\n-    let substd_ty = ty::subst(tcx, &substs, raw_ty);\n+    let substd_ty = raw_ty.subst(tcx, &substs);\n \n     ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n }\n@@ -1504,7 +1508,7 @@ pub fn lookup_field_ty(tcx: &ty::ctxt,\n                        class_id: ast::DefId,\n                        items: &[ty::field_ty],\n                        fieldname: ast::Name,\n-                       substs: &ty::substs) -> Option<ty::t> {\n+                       substs: &subst::Substs) -> Option<ty::t> {\n \n     let o_field = items.iter().find(|f| f.name == fieldname);\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n@@ -1520,13 +1524,13 @@ pub enum DerefArgs {\n // Given the provenance of a static method, returns the generics of the static\n // method's container.\n fn generics_of_static_method_container(type_context: &ty::ctxt,\n-                                       provenance: ast::MethodProvenance)\n+                                       provenance: def::MethodProvenance)\n                                        -> ty::Generics {\n     match provenance {\n-        ast::FromTrait(trait_def_id) => {\n+        def::FromTrait(trait_def_id) => {\n             ty::lookup_trait_def(type_context, trait_def_id).generics.clone()\n         }\n-        ast::FromImpl(impl_def_id) => {\n+        def::FromImpl(impl_def_id) => {\n             ty::lookup_item_type(type_context, impl_def_id).generics.clone()\n         }\n     }\n@@ -1536,7 +1540,7 @@ fn generics_of_static_method_container(type_context: &ty::ctxt,\n // locations.\n fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                                           path: &ast::Path,\n-                                          def: ast::Def) {\n+                                          def: def::Def) {\n     // We only care about checking the case in which the path has two or\n     // more segments.\n     if path.segments.len() < 2 {\n@@ -1577,13 +1581,13 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n         // ensure that the segment of the path which names the trait or\n         // implementation (the penultimate segment) is annotated with the\n         // right number of type parameters.\n-        ast::DefStaticMethod(_, provenance, _) => {\n+        def::DefStaticMethod(_, provenance, _) => {\n             let generics =\n                 generics_of_static_method_container(function_context.ccx.tcx,\n                                                     provenance);\n             let name = match provenance {\n-                ast::FromTrait(_) => \"trait\",\n-                ast::FromImpl(_) => \"impl\",\n+                def::FromTrait(_) => \"trait\",\n+                def::FromImpl(_) => \"impl\",\n             };\n \n             let trait_segment = &path.segments.get(path.segments.len() - 2);\n@@ -2437,7 +2441,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                       span: Span,\n                                       class_id: ast::DefId,\n                                       node_id: ast::NodeId,\n-                                      substitutions: ty::substs,\n+                                      substitutions: subst::Substs,\n                                       field_types: &[ty::field_ty],\n                                       ast_fields: &[ast::Field],\n                                       check_completeness: bool)  {\n@@ -2543,13 +2547,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Generate the struct type.\n         let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+        let substitutions = subst::Substs {\n+            regions: subst::NonerasedRegions(regions),\n             self_ty: None,\n             tps: type_parameters\n         };\n \n-        let mut struct_type = ty::subst(tcx, &substitutions, raw_type);\n+        let mut struct_type = raw_type.subst(tcx, &substitutions);\n \n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n@@ -2599,13 +2603,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Generate the enum type.\n         let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+        let substitutions = subst::Substs {\n+            regions: subst::NonerasedRegions(regions),\n             self_ty: None,\n             tps: type_parameters\n         };\n \n-        let enum_type = ty::subst(tcx, &substitutions, raw_type);\n+        let enum_type = raw_type.subst(tcx, &substitutions);\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n@@ -2703,7 +2707,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                   // FIXME(pcwalton): For now we hardcode the two permissible\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n-                  let def_id = ast_util::def_id_of_def(definition);\n+                  let def_id = definition.def_id();\n                   match tcx.lang_items\n                            .items\n                            .get(ExchangeHeapLangItem as uint) {\n@@ -2734,10 +2738,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                       }\n                                   };\n                               let regions =\n-                                  ty::NonerasedRegions(OwnedSlice::empty());\n+                                  subst::NonerasedRegions(Vec::new());\n                               let sty = ty::mk_struct(tcx,\n                                                       gc_struct_id,\n-                                                      substs {\n+                                                      subst::Substs {\n                                                         self_ty: None,\n                                                         tps: vec!(\n                                                             fcx.expr_ty(\n@@ -3253,11 +3257,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n         match def {\n-            Some(ast::DefStruct(type_def_id)) => {\n+            Some(def::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          fields.as_slice(), base_expr);\n             }\n-            Some(ast::DefVariant(enum_id, variant_id, _)) => {\n+            Some(def::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, fields.as_slice());\n             }\n@@ -3806,54 +3810,54 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n                                       sp: Span,\n-                                      defn: ast::Def)\n+                                      defn: def::Def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n-      ast::DefArg(nid, _) | ast::DefLocal(nid, _) |\n-      ast::DefBinding(nid, _) => {\n+      def::DefArg(nid, _) | def::DefLocal(nid, _) |\n+      def::DefBinding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n-      ast::DefFn(id, _) | ast::DefStaticMethod(id, _, _) |\n-      ast::DefStatic(id, _) | ast::DefVariant(_, id, _) |\n-      ast::DefStruct(id) => {\n+      def::DefFn(id, _) | def::DefStaticMethod(id, _, _) |\n+      def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n+      def::DefStruct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n-      ast::DefUpvar(_, inner, _, _) => {\n+      def::DefUpvar(_, inner, _, _) => {\n         return ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n-      ast::DefTrait(_) |\n-      ast::DefTy(_) |\n-      ast::DefPrimTy(_) |\n-      ast::DefTyParam(..)=> {\n+      def::DefTrait(_) |\n+      def::DefTy(_) |\n+      def::DefPrimTy(_) |\n+      def::DefTyParam(..)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type\");\n       }\n-      ast::DefMod(..) | ast::DefForeignMod(..) => {\n+      def::DefMod(..) | def::DefForeignMod(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found module\");\n       }\n-      ast::DefUse(..) => {\n+      def::DefUse(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found use\");\n       }\n-      ast::DefRegion(..) => {\n+      def::DefRegion(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found region\");\n       }\n-      ast::DefTyParamBinder(..) => {\n+      def::DefTyParamBinder(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type parameter\");\n       }\n-      ast::DefLabel(..) => {\n+      def::DefLabel(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found label\");\n       }\n-      ast::DefSelfTy(..) => {\n+      def::DefSelfTy(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n-      ast::DefMethod(..) => {\n+      def::DefMethod(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found method\");\n       }\n     }\n@@ -3864,7 +3868,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n pub fn instantiate_path(fcx: &FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n-                        def: ast::Def,\n+                        def: def::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n@@ -3888,8 +3892,10 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     let num_expected_regions = tpt.generics.region_param_defs().len();\n     let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        OwnedSlice::from_vec(pth.segments.last().unwrap().lifetimes.iter().map(\n-            |l| ast_region_to_region(fcx.tcx(), l)).collect())\n+        pth.segments.last().unwrap().lifetimes\n+            .iter()\n+            .map(|l| ast_region_to_region(fcx.tcx(), l))\n+            .collect()\n     } else {\n         if num_supplied_regions != 0 {\n             fcx.ccx.tcx.sess.span_err(\n@@ -3904,7 +3910,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n         fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.as_slice())\n     };\n-    let regions = ty::NonerasedRegions(regions);\n+    let regions = subst::NonerasedRegions(regions);\n \n     // Special case: If there is a self parameter, omit it from the list of\n     // type parameters.\n@@ -3913,7 +3919,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     // of type parameters actually manifest in the AST. This will differ from\n     // the internal type parameter count when there are self types involved.\n     let (user_ty_param_count, user_ty_param_req, self_parameter_index) = match def {\n-        ast::DefStaticMethod(_, provenance @ ast::FromTrait(_), _) => {\n+        def::DefStaticMethod(_, provenance @ def::FromTrait(_), _) => {\n             let generics = generics_of_static_method_container(fcx.ccx.tcx,\n                                                                provenance);\n             (ty_param_count - 1, ty_param_req - 1, Some(generics.type_param_defs().len()))\n@@ -3980,7 +3986,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             tps.push(ty)\n         }\n \n-        let mut substs = substs {\n+        let mut substs = subst::Substs {\n             regions: regions,\n             self_ty: None,\n             tps: tps\n@@ -4020,13 +4026,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n         assert_eq!(substs.tps.len(), ty_param_count)\n \n-        let substs {tps, regions, ..} = substs;\n+        let subst::Substs {tps, regions, ..} = substs;\n         (tps, regions)\n     };\n \n-    let substs = substs { regions: regions,\n-                          self_ty: None,\n-                          tps: tps };\n+    let substs = subst::Substs { regions: regions,\n+                                 self_ty: None,\n+                                 tps: tps };\n \n     fcx.write_ty_substs(node_id, tpt.ty, ty::ItemSubsts {\n         substs: substs,\n@@ -4148,7 +4154,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool\n         match e.node {\n             ast::ExprBreak(Some(_)) => {\n                 match cx.def_map.borrow().find(&e.id) {\n-                    Some(&ast::DefLabel(loop_id)) if id == loop_id => true,\n+                    Some(&def::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 }\n             }\n@@ -4261,10 +4267,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"type_id\" => {\n                 let langid = ccx.tcx.lang_items.require(TypeIdLangItem);\n                 match langid {\n-                    Ok(did) => (1u, Vec::new(), ty::mk_struct(ccx.tcx, did, substs {\n+                    Ok(did) => (1u, Vec::new(), ty::mk_struct(ccx.tcx, did, subst::Substs {\n                                                  self_ty: None,\n                                                  tps: Vec::new(),\n-                                                 regions: ty::NonerasedRegions(OwnedSlice::empty())\n+                                                 regions: subst::NonerasedRegions(Vec::new())\n                                                  }) ),\n                     Err(msg) => {\n                         tcx.sess.span_fatal(it.span, msg.as_slice());"}, {"sha": "e1db465424af88946486e9362e1f09bed4082c93", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -118,7 +118,8 @@ and report an error, and it just seems like more mess in the end.)\n \n */\n \n-\n+use middle::def;\n+use middle::def::{DefArg, DefBinding, DefLocal, DefUpvar};\n use middle::freevars;\n use mc = middle::mem_categorization;\n use middle::ty::{ReScope};\n@@ -134,9 +135,7 @@ use middle::pat_util;\n use util::nodemap::NodeMap;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n-use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -163,7 +162,7 @@ pub struct Rcx<'a> {\n     repeating_scope: ast::NodeId,\n }\n \n-fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n+fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long\n      * is `def` valid?\n@@ -665,7 +664,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n-            let def_id = ast_util::def_id_of_def(def);\n+            let def_id = def.def_id();\n             assert!(def_id.krate == ast::LOCAL_CRATE);\n             let upvar_id = ty::UpvarId { var_id: def_id.node,\n                                          closure_expr_id: expr.id };\n@@ -725,7 +724,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // determining the final borrow_kind) and propagate that as\n             // a constraint on the outer closure.\n             match freevar.def {\n-                ast::DefUpvar(var_id, _, outer_closure_id, _) => {\n+                def::DefUpvar(var_id, _, outer_closure_id, _) => {\n                     // thing being captured is itself an upvar:\n                     let outer_upvar_id = ty::UpvarId {\n                         var_id: var_id,"}, {"sha": "0665ae651f0ad319bca3ad614348ad92c215da8d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 44, "deletions": 58, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -23,6 +23,7 @@ use middle::typeck::{vtable_origin, vtable_res, vtable_param_res};\n use middle::typeck::{vtable_static, vtable_param, impl_res};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::MethodCall;\n+use middle::subst;\n use middle::subst::Subst;\n use util::common::indenter;\n use util::ppaux;\n@@ -73,15 +74,10 @@ impl<'a> VtableContext<'a> {\n     pub fn tcx(&self) -> &'a ty::ctxt { self.infcx.tcx }\n }\n \n-fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n-    type_param_defs.iter().any(\n-        |type_param_def| !type_param_def.bounds.trait_bounds.is_empty())\n-}\n-\n fn lookup_vtables(vcx: &VtableContext,\n                   span: Span,\n                   type_param_defs: &[ty::TypeParameterDef],\n-                  substs: &ty::substs,\n+                  substs: &subst::Substs,\n                   is_early: bool) -> vtable_res {\n     debug!(\"lookup_vtables(span={:?}, \\\n             type_param_defs={}, \\\n@@ -118,7 +114,7 @@ fn lookup_vtables(vcx: &VtableContext,\n fn lookup_vtables_for_param(vcx: &VtableContext,\n                             span: Span,\n                             // None for substs means the identity\n-                            substs: Option<&ty::substs>,\n+                            substs: Option<&subst::Substs>,\n                             type_param_bounds: &ty::ParamBounds,\n                             ty: ty::t,\n                             is_early: bool) -> vtable_param_res {\n@@ -464,9 +460,9 @@ fn search_for_vtable(vcx: &VtableContext,\n fn fixup_substs(vcx: &VtableContext,\n                 span: Span,\n                 id: ast::DefId,\n-                substs: ty::substs,\n+                substs: subst::Substs,\n                 is_early: bool)\n-                -> Option<ty::substs> {\n+                -> Option<subst::Substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n@@ -503,7 +499,7 @@ fn fixup_ty(vcx: &VtableContext,\n \n fn connect_trait_tps(vcx: &VtableContext,\n                      span: Span,\n-                     impl_substs: &ty::substs,\n+                     impl_substs: &subst::Substs,\n                      trait_ref: Rc<ty::TraitRef>,\n                      impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n@@ -566,7 +562,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                       let vcx = fcx.vtable_context();\n                       let target_trait_ref = Rc::new(ty::TraitRef {\n                           def_id: target_def_id,\n-                          substs: ty::substs {\n+                          substs: subst::Substs {\n                               tps: target_substs.tps.clone(),\n                               regions: target_substs.regions.clone(),\n                               self_ty: Some(typ)\n@@ -631,20 +627,18 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.borrow().get_copy(&ex.id);\n-            let did = ast_util::def_id_of_def(def);\n+            let did = def.def_id();\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n-            if has_trait_bounds(item_ty.generics.type_param_defs()) {\n-                debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n-                       item_ty.generics.type_param_defs().repr(fcx.tcx()));\n-                let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, ex.span,\n-                                           item_ty.generics.type_param_defs(),\n-                                           &item_substs.substs, is_early);\n-                if !is_early {\n-                    insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n-                }\n+            debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n+                   item_ty.generics.type_param_defs().repr(fcx.tcx()));\n+            let vcx = fcx.vtable_context();\n+            let vtbls = lookup_vtables(&vcx, ex.span,\n+                                       item_ty.generics.type_param_defs(),\n+                                       &item_substs.substs, is_early);\n+            if !is_early {\n+                insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n             }\n         });\n       }\n@@ -657,19 +651,17 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprMethodCall(_, _, _) => {\n         match fcx.inh.method_map.borrow().find(&MethodCall::expr(ex.id)) {\n           Some(method) => {\n-            debug!(\"vtable resolution on parameter bounds for method call {}\",\n-                   ex.repr(fcx.tcx()));\n-            let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n-            if has_trait_bounds(type_param_defs.as_slice()) {\n-                let substs = fcx.method_ty_substs(ex.id);\n-                let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, ex.span,\n-                                           type_param_defs.as_slice(),\n-                                           &substs, is_early);\n-                if !is_early {\n-                    insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n-                }\n-            }\n+              debug!(\"vtable resolution on parameter bounds for method call {}\",\n+                     ex.repr(fcx.tcx()));\n+              let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n+              let substs = fcx.method_ty_substs(ex.id);\n+              let vcx = fcx.vtable_context();\n+              let vtbls = lookup_vtables(&vcx, ex.span,\n+                                         type_param_defs.as_slice(),\n+                                         &substs, is_early);\n+              if !is_early {\n+                  insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n+              }\n           }\n           None => {}\n         }\n@@ -695,15 +687,13 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                        ex.repr(fcx.tcx()));\n                                 let type_param_defs =\n                                     ty::method_call_type_param_defs(cx.tcx, method.origin);\n-                                if has_trait_bounds(type_param_defs.deref().as_slice()) {\n-                                    let vcx = fcx.vtable_context();\n-                                    let vtbls = lookup_vtables(&vcx, ex.span,\n-                                                               type_param_defs.deref()\n-                                                               .as_slice(),\n-                                                               &method.substs, is_early);\n-                                    if !is_early {\n-                                        insert_vtables(fcx, method_call, vtbls);\n-                                    }\n+                                let vcx = fcx.vtable_context();\n+                                let vtbls = lookup_vtables(&vcx, ex.span,\n+                                                           type_param_defs.deref()\n+                                                           .as_slice(),\n+                                                           &method.substs, is_early);\n+                                if !is_early {\n+                                    insert_vtables(fcx, method_call, vtbls);\n                                 }\n                             }\n                             None => {}\n@@ -799,23 +789,19 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n /// Resolve vtables for a method call after typeck has finished.\n /// Used by trans to monomorphize artificial method callees (e.g. drop).\n pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n-                            substs: &ty::substs) -> Option<vtable_res> {\n+                            substs: &subst::Substs) -> vtable_res {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n     let type_param_defs = &*generics.type_param_defs;\n-    if has_trait_bounds(type_param_defs.as_slice()) {\n-        let vcx = VtableContext {\n-            infcx: &infer::new_infer_ctxt(tcx),\n-            param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n-        };\n+    let vcx = VtableContext {\n+        infcx: &infer::new_infer_ctxt(tcx),\n+        param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n+    };\n \n-        Some(lookup_vtables(&vcx,\n-                            tcx.map.span(id),\n-                            type_param_defs.as_slice(),\n-                            substs,\n-                            false))\n-    } else {\n-        None\n-    }\n+    lookup_vtables(&vcx,\n+                   tcx.map.span(id),\n+                   type_param_defs.as_slice(),\n+                   substs,\n+                   false)\n }\n \n impl<'a, 'b> visit::Visitor<()> for &'a FnCtxt<'b> {"}, {"sha": "63dc122f7cbf64c3082ae050e15e631466a7df71", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -12,8 +12,9 @@\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n \n-\n+use middle::def;\n use middle::pat_util;\n+use middle::subst;\n use middle::ty;\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::typeck::astconv::AstConv;\n@@ -231,10 +232,10 @@ impl<'cx> WritebackCx<'cx> {\n                         // bare functions to coerce to a closure to avoid\n                         // constructing (slower) indirect call wrappers.\n                         match self.tcx().def_map.borrow().find(&id) {\n-                            Some(&ast::DefFn(..)) |\n-                            Some(&ast::DefStaticMethod(..)) |\n-                            Some(&ast::DefVariant(..)) |\n-                            Some(&ast::DefStruct(_)) => {\n+                            Some(&def::DefFn(..)) |\n+                            Some(&def::DefStaticMethod(..)) |\n+                            Some(&def::DefVariant(..)) |\n+                            Some(&def::DefStruct(_)) => {\n                             }\n                             _ => {\n                                 self.tcx().sess.span_err(\n@@ -291,7 +292,7 @@ impl<'cx> WritebackCx<'cx> {\n                 // probably for invocations on objects, and this\n                 // causes encoding failures). -nmatsakis\n                 new_method.substs.self_ty = None;\n-                new_method.substs.regions = ty::ErasedRegions;\n+                new_method.substs.regions = subst::ErasedRegions;\n \n                 self.tcx().method_map.borrow_mut().insert(\n                     method_call,"}, {"sha": "99a6aad715ccbf548c9f1895e3a6b58f77a5651b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -17,9 +17,11 @@\n \n use metadata::csearch::{each_impl, get_impl_trait, each_implementation_for_trait};\n use metadata::csearch;\n+use middle::subst;\n+use middle::subst::{Substs};\n use middle::ty::get;\n-use middle::ty::{ImplContainer, lookup_item_type, subst};\n-use middle::ty::{substs, t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n+use middle::ty::{ImplContainer, lookup_item_type};\n+use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n@@ -33,15 +35,15 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n use util::ppaux::Repr;\n-use syntax::ast::{Crate, DefId, DefStruct, DefTy};\n+use middle::def::{DefStruct, DefTy};\n+use syntax::ast::{Crate, DefId};\n use syntax::ast::{Item, ItemEnum, ItemImpl, ItemMod, ItemStruct};\n use syntax::ast::{LOCAL_CRATE, TraitRef, TyPath};\n use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, local_def};\n+use syntax::ast_util::{local_def};\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::visit;\n \n@@ -505,14 +507,12 @@ impl<'a> CoherenceChecker<'a> {\n         let bounds_count = polytype.generics.type_param_defs().len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n-        let substitutions = substs {\n-            regions: ty::NonerasedRegions(region_parameters),\n+        let substitutions = subst::Substs {\n+            regions: subst::NonerasedRegions(region_parameters),\n             self_ty: None,\n             tps: type_parameters\n         };\n-        let monotype = subst(self.crate_context.tcx,\n-                             &substitutions,\n-                             polytype.ty);\n+        let monotype = polytype.ty.subst(self.crate_context.tcx, &substitutions);\n \n         UniversalQuantificationResult {\n             monotype: monotype,\n@@ -544,7 +544,7 @@ impl<'a> CoherenceChecker<'a> {\n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n         let def_map = &self.crate_context.tcx.def_map;\n         let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n-        let trait_id = def_id_of_def(trait_def);\n+        let trait_id = trait_def.def_id();\n         return trait_id;\n     }\n \n@@ -730,7 +730,7 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n                                       impl_id: ast::DefId,\n                                       trait_ref: &ty::TraitRef,\n                                       method: &ty::Method)\n-                                      -> ty::substs {\n+                                      -> subst::Substs {\n     /*!\n      * Substitutes the values for the receiver's type parameters\n      * that are found in method, leaving the method's type parameters\n@@ -753,17 +753,17 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n     let mut combined_tps = trait_ref.substs.tps.clone();\n     combined_tps.push_all_move(meth_tps);\n     let combined_regions = match &trait_ref.substs.regions {\n-        &ty::ErasedRegions =>\n+        &subst::ErasedRegions =>\n             fail!(\"make_substs_for_receiver_types: unexpected ErasedRegions\"),\n \n-        &ty::NonerasedRegions(ref rs) => {\n-            let mut rs = rs.clone().into_vec();\n+        &subst::NonerasedRegions(ref rs) => {\n+            let mut rs = rs.clone();\n             rs.push_all_move(meth_regions);\n-            ty::NonerasedRegions(OwnedSlice::from_vec(rs))\n+            subst::NonerasedRegions(rs)\n         }\n     };\n \n-    ty::substs {\n+    subst::Substs {\n         regions: combined_regions,\n         self_ty: trait_ref.substs.self_ty,\n         tps: combined_tps"}, {"sha": "c6bc6ce72974052cc40b7143650ad0e8efa98547", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -32,12 +32,14 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n+use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n-use middle::ty::{ImplContainer, MethodContainer, TraitContainer, substs};\n+use middle::subst;\n+use middle::subst::{Subst, Substs};\n+use middle::ty::{ImplContainer, MethodContainer, TraitContainer};\n use middle::ty::{ty_param_bounds_and_ty};\n use middle::ty;\n-use middle::subst::Subst;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n@@ -320,16 +322,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         //     A,B,C => A',B',C'\n         //     Self => D'\n         //     D,E,F => E',F',G'\n-        let substs = substs {\n-            regions: ty::NonerasedRegions(rps_from_trait),\n+        let substs = subst::Substs {\n+            regions: subst::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n             tps: non_shifted_trait_tps.append(shifted_method_tps.as_slice())\n         };\n \n         // create the type of `foo`, applying the substitution above\n-        let ty = ty::subst(tcx,\n-                           &substs,\n-                           ty::mk_bare_fn(tcx, m.fty.clone()));\n+        let ty = ty::mk_bare_fn(tcx, m.fty.clone()).subst(tcx, &substs);\n \n         // create the type parameter definitions for `foo`, applying\n         // the substitution to any traits that appear in their bounds.\n@@ -741,7 +741,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n             ast::TyPath(_, _, path_id) => {\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.find(&path_id) {\n-                    Some(&ast::DefStruct(def_id)) => {\n+                    Some(&def::DefStruct(def_id)) => {\n                         // FIXME(#12511) Check for cycles in the inheritance hierarchy.\n                         // Check super-struct is virtual.\n                         match tcx.map.find(def_id.node) {\n@@ -832,7 +832,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     let rscope = ExplicitRscope;\n \n     match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n-        ast::DefTrait(trait_did) => {\n+        def::DefTrait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n@@ -1211,17 +1211,18 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n \n pub fn mk_item_substs(ccx: &CrateCtxt,\n                       ty_generics: &ty::Generics,\n-                      self_ty: Option<ty::t>) -> ty::substs\n+                      self_ty: Option<ty::t>)\n+                      -> subst::Substs\n {\n     let params: Vec<ty::t> =\n         ty_generics.type_param_defs().iter().enumerate().map(\n             |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n \n-    let regions: OwnedSlice<ty::Region> =\n+    let regions: Vec<ty::Region> =\n         ty_generics.region_param_defs().iter().enumerate().map(\n             |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.name)).collect();\n \n-    substs {regions: ty::NonerasedRegions(regions),\n-            self_ty: self_ty,\n-            tps: params}\n+    subst::Substs {regions: subst::NonerasedRegions(regions),\n+                   self_ty: self_ty,\n+                   tps: params}\n }"}, {"sha": "4a2cd7cbec2a83600842fd000c1d7122478a27ca", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -64,7 +64,7 @@ we may want to adjust precisely when coercions occur.\n \n */\n \n-\n+use middle::subst;\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowObj, AutoDerefRef};\n use middle::ty::{mt};\n use middle::ty;\n@@ -443,7 +443,7 @@ impl<'f> Coerce<'f> {\n                          sty_a: &ty::sty,\n                          b: ty::t,\n                          trait_def_id: ast::DefId,\n-                         trait_substs: &ty::substs,\n+                         trait_substs: &subst::Substs,\n                          trait_store: ty::TraitStore,\n                          bounds: ty::BuiltinBounds) -> CoerceResult {\n "}, {"sha": "2e8698e59aa9ac7d12e06af532924857758ae64e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -47,8 +47,10 @@\n // now.\n \n \n+use middle::subst;\n+use middle::subst::Substs;\n use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n-use middle::ty::{IntType, UintType, substs};\n+use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n use middle::typeck::infer::{then, ToUres};\n@@ -66,7 +68,6 @@ use std::result;\n \n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::abi;\n \n pub trait Combine {\n@@ -127,22 +128,23 @@ pub trait Combine {\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n-              as_: &ty::substs,\n-              bs: &ty::substs) -> cres<ty::substs> {\n-\n+              as_: &subst::Substs,\n+              bs: &subst::Substs)\n+              -> cres<subst::Substs>\n+    {\n         fn relate_region_params<C:Combine>(this: &C,\n                                            item_def_id: ast::DefId,\n-                                           a: &ty::RegionSubsts,\n-                                           b: &ty::RegionSubsts)\n-                                           -> cres<ty::RegionSubsts> {\n+                                           a: &subst::RegionSubsts,\n+                                           b: &subst::RegionSubsts)\n+                                           -> cres<subst::RegionSubsts> {\n             let tcx = this.infcx().tcx;\n             match (a, b) {\n-                (&ty::ErasedRegions, _) | (_, &ty::ErasedRegions) => {\n-                    Ok(ty::ErasedRegions)\n+                (&subst::ErasedRegions, _) | (_, &subst::ErasedRegions) => {\n+                    Ok(subst::ErasedRegions)\n                 }\n \n-                (&ty::NonerasedRegions(ref a_rs),\n-                 &ty::NonerasedRegions(ref b_rs)) => {\n+                (&subst::NonerasedRegions(ref a_rs),\n+                 &subst::NonerasedRegions(ref b_rs)) => {\n                     let variances = ty::item_variances(tcx, item_def_id);\n                     let region_params = &variances.region_params;\n                     let num_region_params = region_params.len();\n@@ -175,7 +177,7 @@ pub trait Combine {\n                         };\n                         rs.push(if_ok!(r));\n                     }\n-                    Ok(ty::NonerasedRegions(OwnedSlice::from_vec(rs)))\n+                    Ok(subst::NonerasedRegions(rs))\n                 }\n             }\n         }\n@@ -186,9 +188,9 @@ pub trait Combine {\n                                                   item_def_id,\n                                                   &as_.regions,\n                                                   &bs.regions));\n-        Ok(substs { regions: regions,\n-                    self_ty: self_ty,\n-                    tps: tps.clone() })\n+        Ok(subst::Substs { regions: regions,\n+                           self_ty: self_ty,\n+                           tps: tps.clone() })\n     }\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,"}, {"sha": "6464b191b76911b431cdabbb970ef4af4d9ae57f", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -60,6 +60,7 @@ time of error detection.\n */\n \n use std::collections::HashSet;\n+use middle::def;\n use middle::ty;\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n@@ -1045,7 +1046,7 @@ impl<'a> Rebuilder<'a> {\n                         Some(&d) => d\n                     };\n                     match a_def {\n-                        ast::DefTy(did) | ast::DefStruct(did) => {\n+                        def::DefTy(did) | def::DefStruct(did) => {\n                             let ty::ty_param_bounds_and_ty {\n                                 generics: generics,\n                                 ty: _"}, {"sha": "646dad879eef3d8eb58a2333a4be4e6c5b6706c1", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -41,7 +41,6 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n use util::common::indent;\n use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr};\n \n@@ -625,7 +624,7 @@ impl<'a> InferCtxt<'a> {\n     pub fn region_vars_for_defs(&self,\n                                 span: Span,\n                                 defs: &[ty::RegionParameterDef])\n-                                -> OwnedSlice<ty::Region> {\n+                                -> Vec<ty::Region> {\n         defs.iter()\n             .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n             .collect()"}, {"sha": "9bf6728c95ba325bd324337cabe2417d61d7113e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -63,7 +63,9 @@ independently:\n \n use driver::config;\n \n+use middle::def;\n use middle::resolve;\n+use middle::subst;\n use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n@@ -144,7 +146,7 @@ pub struct MethodObject {\n pub struct MethodCallee {\n     pub origin: MethodOrigin,\n     pub ty: ty::t,\n-    pub substs: ty::substs\n+    pub substs: subst::Substs\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -184,7 +186,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::DefId, ty::substs, vtable_res),\n+    vtable_static(ast::DefId, subst::Substs, vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -265,7 +267,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n }\n-pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().find(&id) {\n         Some(&x) => x,\n         _ => {\n@@ -275,7 +277,7 @@ pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n }\n \n pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n-                   -> ast::Def {\n+                   -> def::Def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n "}, {"sha": "04244ff31a8c31923db9bc647e9efd1414dbd46d", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -195,6 +195,7 @@ represents the \"variance transform\" as defined in the paper:\n use std::collections::HashMap;\n use arena;\n use arena::Arena;\n+use middle::subst;\n use middle::ty;\n use std::fmt;\n use std::rc::Rc;\n@@ -798,7 +799,7 @@ impl<'a> ConstraintContext<'a> {\n     fn add_constraints_from_substs(&mut self,\n                                    def_id: ast::DefId,\n                                    generics: &ty::Generics,\n-                                   substs: &ty::substs,\n+                                   substs: &subst::Substs,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n@@ -810,8 +811,8 @@ impl<'a> ConstraintContext<'a> {\n         }\n \n         match substs.regions {\n-            ty::ErasedRegions => {}\n-            ty::NonerasedRegions(ref rps) => {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref rps) => {\n                 for (i, p) in generics.region_param_defs().iter().enumerate() {\n                     let variance_decl =\n                         self.declared_variance(p.def_id, def_id, RegionParam, i);"}, {"sha": "a9ac1e76f11877ff5c567e3242d011f4b8ceaf34", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n \n+use middle::subst;\n+use middle::subst::Subst;\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{BrFresh, ctxt};\n@@ -419,15 +421,15 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n \n pub fn parameterized(cx: &ctxt,\n                      base: &str,\n-                     regions: &ty::RegionSubsts,\n+                     regions: &subst::RegionSubsts,\n                      tps: &[ty::t],\n                      did: ast::DefId,\n                      is_trait: bool)\n                      -> String {\n     let mut strs = Vec::new();\n     match *regions {\n-        ty::ErasedRegions => { }\n-        ty::NonerasedRegions(ref regions) => {\n+        subst::ErasedRegions => { }\n+        subst::NonerasedRegions(ref regions) => {\n             for &r in regions.iter() {\n                 strs.push(region_to_str(cx, \"\", false, r))\n             }\n@@ -443,15 +445,15 @@ pub fn parameterized(cx: &ctxt,\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n     let num_defaults = if has_defaults {\n         // We should have a borrowed version of substs instead of cloning.\n-        let mut substs = ty::substs {\n+        let mut substs = subst::Substs {\n             tps: Vec::from_slice(tps),\n             regions: regions.clone(),\n             self_ty: None\n         };\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n             substs.tps.pop();\n             match def.default {\n-                Some(default) => ty::subst(cx, &substs, default) == actual,\n+                Some(default) => default.subst(cx, &substs) == actual,\n                 None => false\n             }\n         }).len()\n@@ -565,7 +567,7 @@ impl Repr for ty::t {\n     }\n }\n \n-impl Repr for ty::substs {\n+impl Repr for subst::Substs {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"substs(regions={}, self_ty={}, tps={})\",\n                 self.regions.repr(tcx),\n@@ -580,11 +582,11 @@ impl Repr for ty::ItemSubsts {\n     }\n }\n \n-impl Repr for ty::RegionSubsts {\n+impl Repr for subst::RegionSubsts {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n-            ty::ErasedRegions => \"erased\".to_string(),\n-            ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n+            subst::ErasedRegions => \"erased\".to_string(),\n+            subst::NonerasedRegions(ref regions) => regions.repr(tcx)\n         }\n     }\n }"}, {"sha": "9db9a0e7612a6908a5f9bba2a5a11d59366c968d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -16,6 +16,7 @@ use syntax::attr::AttrMetaMethods;\n \n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n+use rustc::middle::def;\n use rustc::middle::ty;\n \n use core;\n@@ -46,22 +47,22 @@ pub fn try_inline(id: ast::NodeId) -> Option<Vec<clean::Item>> {\n         Some(def) => *def,\n         None => return None,\n     };\n-    let did = ast_util::def_id_of_def(def);\n+    let did = def.def_id();\n     if ast_util::is_local(did) { return None }\n     try_inline_def(&**cx, tcx, def)\n }\n \n fn try_inline_def(cx: &core::DocContext,\n                   tcx: &ty::ctxt,\n-                  def: ast::Def) -> Option<Vec<clean::Item>> {\n+                  def: def::Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n-    let did = ast_util::def_id_of_def(def);\n+    let did = def.def_id();\n     let inner = match def {\n-        ast::DefTrait(did) => {\n+        def::DefTrait(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n             clean::TraitItem(build_external_trait(tcx, did))\n         }\n-        ast::DefFn(did, style) => {\n+        def::DefFn(did, style) => {\n             // If this function is a tuple struct constructor, we just skip it\n             if csearch::get_tuple_struct_definition_if_ctor(&tcx.sess.cstore,\n                                                             did).is_some() {\n@@ -70,20 +71,20 @@ fn try_inline_def(cx: &core::DocContext,\n             record_extern_fqn(cx, did, clean::TypeFunction);\n             clean::FunctionItem(build_external_function(tcx, did, style))\n         }\n-        ast::DefStruct(did) => {\n+        def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n             clean::StructItem(build_struct(tcx, did))\n         }\n-        ast::DefTy(did) => {\n+        def::DefTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did).move_iter());\n             build_type(tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n-        ast::DefVariant(..) => return Some(Vec::new()),\n-        ast::DefMod(did) => {\n+        def::DefVariant(..) => return Some(Vec::new()),\n+        def::DefMod(did) => {\n             record_extern_fqn(cx, did, clean::TypeModule);\n             clean::ModuleItem(build_module(cx, tcx, did))\n         }\n@@ -248,7 +249,7 @@ fn build_impls(cx: &core::DocContext,\n                           impls: &mut Vec<Option<clean::Item>>) {\n             match def {\n                 decoder::DlImpl(did) => impls.push(build_impl(cx, tcx, did)),\n-                decoder::DlDef(ast::DefMod(did)) => {\n+                decoder::DlDef(def::DefMod(did)) => {\n                     csearch::each_child_of_item(&tcx.sess.cstore,\n                                                 did,\n                                                 |def, _, _| {"}, {"sha": "3cb5c663c4ea5a4d64db78b9c57b2b639baf7fb1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -25,6 +25,8 @@ use rustc::driver::driver;\n use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n+use rustc::middle::def;\n+use rustc::middle::subst;\n use rustc::middle::ty;\n \n use std::rc::Rc;\n@@ -190,7 +192,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n                                                       self.cnum,\n                                                       |def, _, _| {\n                     let did = match def {\n-                        decoder::DlDef(ast::DefMod(did)) => did,\n+                        decoder::DlDef(def::DefMod(did)) => did,\n                         _ => return\n                     };\n                     let attrs = inline::load_attrs(tcx, did);\n@@ -486,14 +488,14 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n-fn external_path(name: &str, substs: &ty::substs) -> Path {\n+fn external_path(name: &str, substs: &subst::Substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n             lifetimes: match substs.regions {\n-                ty::ErasedRegions => Vec::new(),\n-                ty::NonerasedRegions(ref v) => {\n+                subst::ErasedRegions => Vec::new(),\n+                subst::NonerasedRegions(ref v) => {\n                     v.iter().filter_map(|v| v.clean()).collect()\n                 }\n             },\n@@ -509,7 +511,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return RegionBound,\n         };\n-        let empty = ty::substs::empty();\n+        let empty = subst::Substs::empty();\n         let (did, path) = match *self {\n             ty::BoundStatic => return RegionBound,\n             ty::BoundSend =>\n@@ -574,12 +576,12 @@ impl Clean<Vec<TyParamBound>> for ty::ParamBounds {\n     }\n }\n \n-impl Clean<Option<Vec<TyParamBound>>> for ty::substs {\n+impl Clean<Option<Vec<TyParamBound>>> for subst::Substs {\n     fn clean(&self) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n         match self.regions {\n-            ty::NonerasedRegions(..) => v.push(RegionBound),\n-            ty::ErasedRegions => {}\n+            subst::NonerasedRegions(..) => v.push(RegionBound),\n+            subst::ErasedRegions => {}\n         }\n         v.extend(self.tps.iter().map(|t| TraitBound(t.clean())));\n \n@@ -1948,8 +1950,8 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n     };\n \n     match def {\n-        ast::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n-        ast::DefPrimTy(p) => match p {\n+        def::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n+        def::DefPrimTy(p) => match p {\n             ast::TyStr => return Primitive(Str),\n             ast::TyBool => return Primitive(Bool),\n             ast::TyChar => return Primitive(Char),\n@@ -1967,24 +1969,24 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n             ast::TyFloat(ast::TyF128) => return Primitive(F128),\n         },\n-        ast::DefTyParam(i, _) => return Generic(i),\n-        ast::DefTyParamBinder(i) => return TyParamBinder(i),\n+        def::DefTyParam(i, _) => return Generic(i),\n+        def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n     let did = register_def(&**cx, def);\n     ResolvedPath { path: path, typarams: tpbs, did: did }\n }\n \n-fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n+fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n     let (did, kind) = match def {\n-        ast::DefFn(i, _) => (i, TypeFunction),\n-        ast::DefTy(i) => (i, TypeEnum),\n-        ast::DefTrait(i) => (i, TypeTrait),\n-        ast::DefStruct(i) => (i, TypeStruct),\n-        ast::DefMod(i) => (i, TypeModule),\n-        ast::DefStatic(i, _) => (i, TypeStatic),\n-        ast::DefVariant(i, _, _) => (i, TypeEnum),\n-        _ => return ast_util::def_id_of_def(def),\n+        def::DefFn(i, _) => (i, TypeFunction),\n+        def::DefTy(i) => (i, TypeEnum),\n+        def::DefTrait(i) => (i, TypeTrait),\n+        def::DefStruct(i) => (i, TypeStruct),\n+        def::DefMod(i) => (i, TypeModule),\n+        def::DefStatic(i, _) => (i, TypeStatic),\n+        def::DefVariant(i, _, _) => (i, TypeEnum),\n+        _ => return def.def_id()\n     };\n     if ast_util::is_local(did) { return did }\n     let tcx = match cx.maybe_typed {"}, {"sha": "da9169d70fd3c9f5a37395e388f20a63055459d6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -195,7 +195,7 @@ impl<'a> RustdocVisitor<'a> {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return false\n         };\n-        let def = ast_util::def_id_of_def(*tcx.def_map.borrow().get(&id));\n+        let def = tcx.def_map.borrow().get(&id).def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "2bc24fd1eb36994fa3801ed3cbfc6b6ebea0b044", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -206,49 +206,6 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n-pub enum MethodProvenance {\n-    FromTrait(DefId),\n-    FromImpl(DefId),\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n-pub enum Def {\n-    DefFn(DefId, FnStyle),\n-    DefStaticMethod(/* method */ DefId, MethodProvenance, FnStyle),\n-    DefSelfTy(/* trait id */ NodeId),\n-    DefMod(DefId),\n-    DefForeignMod(DefId),\n-    DefStatic(DefId, bool /* is_mutbl */),\n-    DefArg(NodeId, BindingMode),\n-    DefLocal(NodeId, BindingMode),\n-    DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n-    DefTy(DefId),\n-    DefTrait(DefId),\n-    DefPrimTy(PrimTy),\n-    DefTyParam(DefId, uint),\n-    DefBinding(NodeId, BindingMode),\n-    DefUse(DefId),\n-    DefUpvar(NodeId,  // id of closed over var\n-              @Def,     // closed over def\n-              NodeId,  // expr node that creates the closure\n-              NodeId), // id for the block/body of the closure expr\n-\n-    /// Note that if it's a tuple struct's definition, the node id of the DefId\n-    /// may either refer to the item definition's id or the StructDef.ctor_id.\n-    ///\n-    /// The cases that I have encountered so far are (this is not exhaustive):\n-    /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the item definition's id.\n-    /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the StructDef.ctor_id.\n-    DefStruct(DefId),\n-    DefTyParamBinder(NodeId), /* struct, impl or trait with ty params */\n-    DefRegion(NodeId),\n-    DefLabel(NodeId),\n-    DefMethod(DefId /* method */, Option<DefId> /* trait */),\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,"}, {"sha": "a1ad3cc14c5180fa13cc7ca4ebcf099372a74f42", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -52,33 +52,6 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n     }\n }\n \n-pub fn variant_def_ids(d: Def) -> Option<(DefId, DefId)> {\n-    match d {\n-      DefVariant(enum_id, var_id, _) => {\n-          Some((enum_id, var_id))\n-      }\n-      _ => None\n-    }\n-}\n-\n-pub fn def_id_of_def(d: Def) -> DefId {\n-    match d {\n-        DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n-        DefForeignMod(id) | DefStatic(id, _) |\n-        DefVariant(_, id, _) | DefTy(id) | DefTyParam(id, _) |\n-        DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n-            id\n-        }\n-        DefArg(id, _) | DefLocal(id, _) | DefSelfTy(id)\n-        | DefUpvar(id, _, _, _) | DefBinding(id, _) | DefRegion(id)\n-        | DefTyParamBinder(id) | DefLabel(id) => {\n-            local_def(id)\n-        }\n-\n-        DefPrimTy(_) => fail!()\n-    }\n-}\n-\n pub fn binop_to_str(op: BinOp) -> &'static str {\n     match op {\n         BiAdd => \"+\","}, {"sha": "ce3c8c52b0e477726a0d3151ef35e76ebbf17483", "filename": "src/test/compile-fail/issue-12796.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: missing `Self` type param in the substitution of `fn(Self)`\n-\n trait Trait {\n     fn outer(self) {\n         fn inner(_: Self) {\n+            //~^ ERROR can't use type parameters from outer function\n+            //~^^ ERROR use of undeclared type name `Self`\n         }\n     }\n }"}, {"sha": "39e1e117cd0ab5be9a8128b57df7e8f5356a7034", "filename": "src/test/compile-fail/issue-5997-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -10,8 +10,8 @@\n \n fn f<Z>() -> bool {\n     enum E { V(Z) }\n-    //~^ ERROR can't use type parameters from outer function in the\n-\n+    //~^ ERROR can't use type parameters from outer function\n+    //~^^ ERROR use of undeclared type name `Z`\n     true\n }\n "}, {"sha": "341fe173a03f4d7d0b43eed77f3ab4a6cff79ce5", "filename": "src/test/compile-fail/resolve-type-param-in-item-in-trait.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #14603: Check for references to type parameters from the\n+// outer scope (in this case, the trait) used on items in an inner\n+// scope (in this case, the enum).\n+\n+trait TraitA<A> {\n+    fn outer(self) {\n+        enum Foo<B> {\n+            Variance(A)\n+                //~^ ERROR can't use type parameters from outer function\n+                //~^^ ERROR use of undeclared type name `A`\n+        }\n+    }\n+}\n+\n+trait TraitB<A> {\n+    fn outer(self) {\n+        struct Foo<B>(A);\n+                //~^ ERROR can't use type parameters from outer function\n+                //~^^ ERROR use of undeclared type name `A`\n+    }\n+}\n+\n+trait TraitC<A> {\n+    fn outer(self) {\n+        struct Foo<B> { a: A }\n+                //~^ ERROR can't use type parameters from outer function\n+                //~^^ ERROR use of undeclared type name `A`\n+    }\n+}\n+\n+trait TraitD<A> {\n+    fn outer(self) {\n+        fn foo<B>(a: A) { }\n+                //~^ ERROR can't use type parameters from outer function\n+                //~^^ ERROR use of undeclared type name `A`\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "1576c646286a4b6445a8ad5aab69b95233086aa3", "filename": "src/test/run-pass/trait-contravariant-self.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6683c729e3dc919e054839eed07702d938b727/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs?ref=bd6683c729e3dc919e054839eed07702d938b727", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is an interesting test case. We have a trait (Bar) that is\n+// implemented for a `Box<Foo>` object (note: no bounds). And then we\n+// have a `Box<Foo:Send>` object. The impl for `Box<Foo>` is applicable\n+// to `Box<Foo:Send>` because:\n+//\n+// 1. The trait Bar is contravariant w/r/t Self because `Self` appears\n+//    only in argument position.\n+// 2. The impl provides `Bar for Box<Foo>`\n+// 3. The fn `wants_bar()` requires `Bar for Box<Foo:Send>`.\n+// 4. `Bar for Box<Foo> <: Bar for Box<Foo:Send>` because\n+//    `Box<Foo:Send> <: Box<Foo>`.\n+\n+trait Foo { }\n+struct SFoo;\n+impl Foo for SFoo { }\n+\n+trait Bar { fn dummy(&self); }\n+impl Bar for Box<Foo> { fn dummy(&self) { } }\n+\n+fn wants_bar<B:Bar>(b: &B) { }\n+\n+fn main() {\n+    let x: Box<Foo:Send> = (box SFoo);\n+    wants_bar(&x);\n+}\n+\n+"}]}