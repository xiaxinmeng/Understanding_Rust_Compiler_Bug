{"sha": "f34cc658eb477958e2b73e05586e7af66faefad9", "node_id": "C_kwDOAAsO6NoAKGYzNGNjNjU4ZWI0Nzc5NThlMmI3M2UwNTU4NmU3YWY2NmZhZWZhZDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-17T11:34:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-17T11:34:35Z"}, "message": "Auto merge of #106612 - JakobDegen:cleanup-wf, r=tmiasko\n\nDocument wf constraints on control flow in cleanup blocks\n\nWas recently made aware of [this code](https://github.com/rust-lang/rust/blob/a377893da2cd7124e5a18c7116cbb70e16dd5541/compiler/rustc_codegen_ssa/src/mir/analyze.rs#L247-L368), which has this potential ICE: https://github.com/rust-lang/rust/blob/a377893da2cd7124e5a18c7116cbb70e16dd5541/compiler/rustc_codegen_ssa/src/mir/analyze.rs#L308-L314\n\nRoughly speaking, the code there is attempting to partition the cleanup blocks into funclets that satisfy a \"unique successor\" property, and the ICE is set off if that's not possible. This PR documents the well-formedness constraints that MIR must satisfy to avoid setting off that ICE.\n\nThe constraints documented are slightly stronger than the cases in which the ICE would have been set off in that code. This is necessary though, since whether or not that ICE gets set off can depend on iteration order in some graphs.\n\nThis sort of constraint is kind of ugly, but I don't know a better alternative at the moment. It's worth knowing that two important optimizations are still correct:\n - Removing edges in the cfg: Fewer edges => fewer paths => stronger dominance relations => more contractions, and more contractions can't turn a forest into not-a-forest.\n - Contracting an edge u -> v when u only has one successor and v only has one predecessor: u already dominated v, so this contraction was going to happen anyway.\n\nThere is definitely a MIR opt somewhere that can run afoul of this, but I don't know where it is. `@saethlin` was able to set it off though, so maybe he'll be able to shed some light on it.\n\nr? `@RalfJung` I suppose, and cc `@tmiasko` who might have insight/opinions on this", "tree": {"sha": "cd8b7a9ee567940cc3e899c211066c11882f7359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd8b7a9ee567940cc3e899c211066c11882f7359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f34cc658eb477958e2b73e05586e7af66faefad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f34cc658eb477958e2b73e05586e7af66faefad9", "html_url": "https://github.com/rust-lang/rust/commit/f34cc658eb477958e2b73e05586e7af66faefad9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f34cc658eb477958e2b73e05586e7af66faefad9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "159ba8a92c9e2fa4121f106176309521f4af87e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/159ba8a92c9e2fa4121f106176309521f4af87e9", "html_url": "https://github.com/rust-lang/rust/commit/159ba8a92c9e2fa4121f106176309521f4af87e9"}, {"sha": "4bc963eba67e61507d2069edf10cfec1d7f8ec0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc963eba67e61507d2069edf10cfec1d7f8ec0a", "html_url": "https://github.com/rust-lang/rust/commit/4bc963eba67e61507d2069edf10cfec1d7f8ec0a"}], "stats": {"total": 119, "additions": 110, "deletions": 9}, "files": [{"sha": "dd168a9ac3cd3e94078cc20e24fb4c18c4b1b35c", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 96, "deletions": 8, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f34cc658eb477958e2b73e05586e7af66faefad9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34cc658eb477958e2b73e05586e7af66faefad9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=f34cc658eb477958e2b73e05586e7af66faefad9", "patch": "@@ -1,7 +1,8 @@\n //! Validates the MIR to ensure that invariants are upheld.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_infer::traits::Reveal;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n@@ -18,7 +19,7 @@ use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n use rustc_target::abi::{Size, VariantIdx};\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum EdgeKind {\n     Unwind,\n     Normal,\n@@ -57,18 +58,20 @@ impl<'tcx> MirPass<'tcx> for Validator {\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n \n-        TypeChecker {\n+        let mut checker = TypeChecker {\n             when: &self.when,\n             body,\n             tcx,\n             param_env,\n             mir_phase,\n+            unwind_edge_count: 0,\n             reachable_blocks: traversal::reachable_as_bitset(body),\n             storage_liveness,\n             place_cache: Vec::new(),\n             value_cache: Vec::new(),\n-        }\n-        .visit_body(body);\n+        };\n+        checker.visit_body(body);\n+        checker.check_cleanup_control_flow();\n     }\n }\n \n@@ -78,6 +81,7 @@ struct TypeChecker<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     mir_phase: MirPhase,\n+    unwind_edge_count: usize,\n     reachable_blocks: BitSet<BasicBlock>,\n     storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive<'static>>,\n     place_cache: Vec<PlaceRef<'tcx>>,\n@@ -102,7 +106,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n     }\n \n-    fn check_edge(&self, location: Location, bb: BasicBlock, edge_kind: EdgeKind) {\n+    fn check_edge(&mut self, location: Location, bb: BasicBlock, edge_kind: EdgeKind) {\n         if bb == START_BLOCK {\n             self.fail(location, \"start block must not have predecessors\")\n         }\n@@ -111,10 +115,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             match (src.is_cleanup, bb.is_cleanup, edge_kind) {\n                 // Non-cleanup blocks can jump to non-cleanup blocks along non-unwind edges\n                 (false, false, EdgeKind::Normal)\n-                // Non-cleanup blocks can jump to cleanup blocks along unwind edges\n-                | (false, true, EdgeKind::Unwind)\n                 // Cleanup blocks can jump to cleanup blocks along non-unwind edges\n                 | (true, true, EdgeKind::Normal) => {}\n+                // Non-cleanup blocks can jump to cleanup blocks along unwind edges\n+                (false, true, EdgeKind::Unwind) => {\n+                    self.unwind_edge_count += 1;\n+                }\n                 // All other jumps are invalid\n                 _ => {\n                     self.fail(\n@@ -134,6 +140,88 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    fn check_cleanup_control_flow(&self) {\n+        if self.unwind_edge_count <= 1 {\n+            return;\n+        }\n+        let doms = self.body.basic_blocks.dominators();\n+        let mut post_contract_node = FxHashMap::default();\n+        // Reusing the allocation across invocations of the closure\n+        let mut dom_path = vec![];\n+        let mut get_post_contract_node = |mut bb| {\n+            let root = loop {\n+                if let Some(root) = post_contract_node.get(&bb) {\n+                    break *root;\n+                }\n+                let parent = doms.immediate_dominator(bb);\n+                dom_path.push(bb);\n+                if !self.body.basic_blocks[parent].is_cleanup {\n+                    break bb;\n+                }\n+                bb = parent;\n+            };\n+            for bb in dom_path.drain(..) {\n+                post_contract_node.insert(bb, root);\n+            }\n+            root\n+        };\n+\n+        let mut parent = IndexVec::from_elem(None, &self.body.basic_blocks);\n+        for (bb, bb_data) in self.body.basic_blocks.iter_enumerated() {\n+            if !bb_data.is_cleanup || !self.reachable_blocks.contains(bb) {\n+                continue;\n+            }\n+            let bb = get_post_contract_node(bb);\n+            for s in bb_data.terminator().successors() {\n+                let s = get_post_contract_node(s);\n+                if s == bb {\n+                    continue;\n+                }\n+                let parent = &mut parent[bb];\n+                match parent {\n+                    None => {\n+                        *parent = Some(s);\n+                    }\n+                    Some(e) if *e == s => (),\n+                    Some(e) => self.fail(\n+                        Location { block: bb, statement_index: 0 },\n+                        format!(\n+                            \"Cleanup control flow violation: The blocks dominated by {:?} have edges to both {:?} and {:?}\",\n+                            bb,\n+                            s,\n+                            *e\n+                        )\n+                    ),\n+                }\n+            }\n+        }\n+\n+        // Check for cycles\n+        let mut stack = FxHashSet::default();\n+        for i in 0..parent.len() {\n+            let mut bb = BasicBlock::from_usize(i);\n+            stack.clear();\n+            stack.insert(bb);\n+            loop {\n+                let Some(parent)= parent[bb].take() else {\n+                    break\n+                };\n+                let no_cycle = stack.insert(parent);\n+                if !no_cycle {\n+                    self.fail(\n+                        Location { block: bb, statement_index: 0 },\n+                        format!(\n+                            \"Cleanup control flow violation: Cycle involving edge {:?} -> {:?}\",\n+                            bb, parent,\n+                        ),\n+                    );\n+                    break;\n+                }\n+                bb = parent;\n+            }\n+        }\n+    }\n+\n     /// Check if src can be assigned into dest.\n     /// This is not precise, it will accept some incorrect assignments.\n     fn mir_assign_valid_types(&self, src: Ty<'tcx>, dest: Ty<'tcx>) -> bool {"}, {"sha": "07b1ace2189459c27c0f5d7b37307d46aeec543a", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f34cc658eb477958e2b73e05586e7af66faefad9/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34cc658eb477958e2b73e05586e7af66faefad9/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=f34cc658eb477958e2b73e05586e7af66faefad9", "patch": "@@ -135,7 +135,10 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // This loop computes the semi[w] for w.\n         semi[w] = w;\n         for v in graph.predecessors(pre_order_to_real[w]) {\n-            let v = real_to_pre_order[v].unwrap();\n+            // Reachable vertices may have unreachable predecessors, so ignore any of them\n+            let Some(v) = real_to_pre_order[v] else {\n+                continue\n+            };\n \n             // eval returns a vertex x from which semi[x] is minimum among\n             // vertices semi[v] +> x *> v."}, {"sha": "52c2b10cbbea97e286650d84ce8bf4a79be35a23", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f34cc658eb477958e2b73e05586e7af66faefad9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34cc658eb477958e2b73e05586e7af66faefad9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=f34cc658eb477958e2b73e05586e7af66faefad9", "patch": "@@ -512,6 +512,16 @@ pub struct CopyNonOverlapping<'tcx> {\n ///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n ///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n ///     runtime.\n+///  4. The control flow between cleanup blocks must look like an upside down tree. Roughly\n+///     speaking, this means that control flow that looks like a V is allowed, while control flow\n+///     that looks like a W is not. This is necessary to ensure that landing pad information can be\n+///     correctly codegened on MSVC. More precisely:\n+///\n+///     Begin with the standard control flow graph `G`. Modify `G` as follows: for any two cleanup\n+///     vertices `u` and `v` such that `u` dominates `v`, contract `u` and `v` into a single vertex,\n+///     deleting self edges and duplicate edges in the process. Now remove all vertices from `G`\n+///     that are not cleanup vertices or are not reachable. The resulting graph must be an inverted\n+///     tree, that is each vertex may have at most one successor and there may be no cycles.\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum TerminatorKind<'tcx> {\n     /// Block has one successor; we continue execution there."}]}