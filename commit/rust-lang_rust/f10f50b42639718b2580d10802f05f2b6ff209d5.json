{"sha": "f10f50b42639718b2580d10802f05f2b6ff209d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMGY1MGI0MjYzOTcxOGIyNTgwZDEwODAyZjA1ZjJiNmZmMjA5ZDU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-05T03:51:11Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-22T06:14:35Z"}, "message": "Refactor how global paths are represented (for both ast and hir).", "tree": {"sha": "19b61435b37e14f97a74e18b6db32c507e7b1a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b61435b37e14f97a74e18b6db32c507e7b1a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f10f50b42639718b2580d10802f05f2b6ff209d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f10f50b42639718b2580d10802f05f2b6ff209d5", "html_url": "https://github.com/rust-lang/rust/commit/f10f50b42639718b2580d10802f05f2b6ff209d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f10f50b42639718b2580d10802f05f2b6ff209d5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "url": "https://api.github.com/repos/rust-lang/rust/commits/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "html_url": "https://github.com/rust-lang/rust/commit/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d"}], "stats": {"total": 499, "additions": 242, "deletions": 257}, "files": [{"sha": "1cf5e35a0957fa4341a1f148bf101cef36d9e584", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -81,7 +81,7 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n+    // Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n@@ -337,7 +337,6 @@ impl<'a> LoweringContext<'a> {\n \n         let proj_start = p.segments.len() - resolution.depth;\n         let path = P(hir::Path {\n-            global: p.global,\n             def: resolution.base_def,\n             segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n                 let param_mode = match (qself_position, param_mode) {\n@@ -404,12 +403,17 @@ impl<'a> LoweringContext<'a> {\n                         id: NodeId,\n                         p: &Path,\n                         name: Option<Name>,\n-                        param_mode: ParamMode)\n+                        param_mode: ParamMode,\n+                        defaults_to_global: bool)\n                         -> hir::Path {\n+        let mut segments = p.segments.iter();\n+        if defaults_to_global && p.is_global() {\n+            segments.next();\n+        }\n+\n         hir::Path {\n-            global: p.global,\n             def: self.expect_full_def(id),\n-            segments: p.segments.iter().map(|segment| {\n+            segments: segments.map(|segment| {\n                 self.lower_path_segment(segment, param_mode)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n@@ -424,9 +428,10 @@ impl<'a> LoweringContext<'a> {\n     fn lower_path(&mut self,\n                   id: NodeId,\n                   p: &Path,\n-                  param_mode: ParamMode)\n+                  param_mode: ParamMode,\n+                  defaults_to_global: bool)\n                   -> hir::Path {\n-        self.lower_path_extra(id, p, None, param_mode)\n+        self.lower_path_extra(id, p, None, param_mode, defaults_to_global)\n     }\n \n     fn lower_path_segment(&mut self,\n@@ -602,8 +607,8 @@ impl<'a> LoweringContext<'a> {\n                         // Check if the where clause type is a plain type parameter.\n                         match bound_pred.bounded_ty.node {\n                             TyKind::Path(None, ref path)\n-                                    if !path.global && path.segments.len() == 1 &&\n-                                        bound_pred.bound_lifetimes.is_empty() => {\n+                                    if path.segments.len() == 1 &&\n+                                       bound_pred.bound_lifetimes.is_empty() => {\n                                 if let Some(Def::TyParam(def_id)) =\n                                         self.resolver.get_resolution(bound_pred.bounded_ty.id)\n                                                      .map(|d| d.base_def) {\n@@ -677,7 +682,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(id, path, ParamMode::Explicit),\n+                    path: self.lower_path(id, path, ParamMode::Explicit, false),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -707,7 +712,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit),\n+            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit, false),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -800,7 +805,7 @@ impl<'a> LoweringContext<'a> {\n                             };\n \n                             let mut path = self.lower_path_extra(import.id, path, suffix,\n-                                                                 ParamMode::Explicit);\n+                                                                 ParamMode::Explicit, true);\n                             path.span = span;\n                             self.items.insert(import.id, hir::Item {\n                                 id: import.id,\n@@ -814,7 +819,7 @@ impl<'a> LoweringContext<'a> {\n                         path\n                     }\n                 };\n-                let path = P(self.lower_path(id, path, ParamMode::Explicit));\n+                let path = P(self.lower_path(id, path, ParamMode::Explicit, true));\n                 let kind = match view_path.node {\n                     ViewPathSimple(ident, _) => {\n                         *name = ident.name;\n@@ -1135,7 +1140,6 @@ impl<'a> LoweringContext<'a> {\n                             Some(def) => {\n                                 hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n                                     span: pth1.span,\n-                                    global: false,\n                                     def: def,\n                                     segments: hir_vec![\n                                         hir::PathSegment::from_name(pth1.node.name)\n@@ -1878,7 +1882,7 @@ impl<'a> LoweringContext<'a> {\n             Visibility::Crate(_) => hir::Visibility::Crate,\n             Visibility::Restricted { ref path, id } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: id\n                 }\n             }\n@@ -1971,7 +1975,6 @@ impl<'a> LoweringContext<'a> {\n \n         let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(hir::Path {\n             span: span,\n-            global: false,\n             def: def,\n             segments: hir_vec![hir::PathSegment::from_name(id)],\n         })));\n@@ -2139,17 +2142,12 @@ impl<'a> LoweringContext<'a> {\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n     fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n-        let idents = self.crate_root.iter().chain(components);\n-\n-        let segments: Vec<_> = idents.map(|name| {\n-            hir::PathSegment::from_name(Symbol::intern(name))\n-        }).collect();\n-\n         let mut path = hir::Path {\n             span: span,\n-            global: true,\n             def: Def::Err,\n-            segments: segments.into(),\n+            segments: iter::once(keywords::CrateRoot.name()).chain({\n+                self.crate_root.into_iter().chain(components.iter().cloned()).map(Symbol::intern)\n+            }).map(hir::PathSegment::from_name).collect(),\n         };\n \n         self.resolver.resolve_hir_path(&mut path, is_value);"}, {"sha": "a0039f612b985be5861c3f1a25f9c59d5986ffe0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -105,15 +105,18 @@ pub struct LifetimeDef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Path {\n     pub span: Span,\n-    /// A `::foo` path, is relative to the crate root rather than current\n-    /// module (like paths in an import).\n-    pub global: bool,\n     /// The definition that the path resolved to.\n     pub def: Def,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: HirVec<PathSegment>,\n }\n \n+impl Path {\n+    pub fn is_global(&self) -> bool {\n+        !self.segments.is_empty() && self.segments[0].name == keywords::CrateRoot.name()\n+    }\n+}\n+\n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"path({})\", print::path_to_string(self))"}, {"sha": "de4047df81c5d6b60f428eb3bddfe519f207a13b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -1643,17 +1643,14 @@ impl<'a> State<'a> {\n                   -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n-        let mut first = !path.global;\n-        for segment in &path.segments {\n-            if first {\n-                first = false\n-            } else {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            if i > 0 {\n                 word(&mut self.s, \"::\")?\n             }\n-\n-            self.print_name(segment.name)?;\n-\n-            self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+            if segment.name != keywords::CrateRoot.name() {\n+                self.print_name(segment.name)?;\n+                self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+            }\n         }\n \n         Ok(())\n@@ -1673,15 +1670,14 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.word_space(\"as\")?;\n \n-                let mut first = !path.global;\n-                for segment in &path.segments[..path.segments.len() - 1] {\n-                    if first {\n-                        first = false\n-                    } else {\n+                for (i, segment) in path.segments[..path.segments.len() - 1].iter().enumerate() {\n+                    if i > 0 {\n                         word(&mut self.s, \"::\")?\n                     }\n-                    self.print_name(segment.name)?;\n-                    self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                    if segment.name != keywords::CrateRoot.name() {\n+                        self.print_name(segment.name)?;\n+                        self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                    }\n                 }\n \n                 word(&mut self.s, \">\")?;"}, {"sha": "9d48fbca53edd9ddf11c8af56286e87fd8bc9ed1", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -1620,7 +1620,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         new_segs.push(new_seg);\n         hir::Path {\n             span: path.span,\n-            global: path.global,\n             def: path.def,\n             segments: new_segs.into()\n         }"}, {"sha": "ebe103490110436e6712fbf3b86b52805cf655c8", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -324,7 +324,6 @@ impl Witness {\n                     let v = ctor.variant_for_adt(adt);\n                     let qpath = hir::QPath::Resolved(None, P(hir::Path {\n                         span: DUMMY_SP,\n-                        global: false,\n                         def: Def::Err,\n                         segments: vec![hir::PathSegment::from_name(v.name)].into(),\n                     }));"}, {"sha": "bd865d10efcafb329f93380b44ada97b1076ca6d", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -189,7 +189,6 @@ enum SawAbiComponent<'a> {\n     SawStructField,\n     SawVariant,\n     SawQPath,\n-    SawPath(bool),\n     SawPathSegment,\n     SawPathParameters,\n     SawBlock,\n@@ -678,7 +677,6 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n-        SawPath(path.global).hash(self.st);\n         hash_span!(self, path.span);\n         visit::walk_path(self, path)\n     }"}, {"sha": "1d384741d9660b974ed3e53643229dbdc3581a18", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -382,7 +382,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n+            if path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = path.def {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\","}, {"sha": "52bdd014933b8d6438949a179e1afe5cbe041d7a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -154,8 +154,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_path(&mut self, path: &'a Path, id: NodeId) {\n-        if path.global && path.segments.len() > 0 {\n-            let ident = path.segments[0].identifier;\n+        if path.segments.len() >= 2 && path.is_global() {\n+            let ident = path.segments[1].identifier;\n             if token::Ident(ident).is_path_segment_keyword() {\n                 self.session.add_lint(lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n                                       id,"}, {"sha": "09f438953ecd2badfc7cae2f4e8c2ebab5fd92e3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -40,6 +40,7 @@ use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n+use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n \n@@ -112,7 +113,7 @@ impl<'a> Resolver<'a> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let module_path: Vec<_> = match view_path.node {\n+                let mut module_path: Vec<_> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n                                  .split_last()\n@@ -132,6 +133,12 @@ impl<'a> Resolver<'a> {\n                     }\n                 };\n \n+                // This can be removed once warning cycle #36888 is complete.\n+                if module_path.len() >= 2 && module_path[0].name == keywords::CrateRoot.name() &&\n+                   token::Ident(module_path[1]).is_path_segment_keyword() {\n+                    module_path.remove(0);\n+                }\n+\n                 // Build up the import directives.\n                 let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n \n@@ -193,18 +200,16 @@ impl<'a> Resolver<'a> {\n                                     let rename = node.rename.unwrap_or(node.name);\n                                     (module_path.clone(), node.name, rename)\n                                 } else {\n-                                    let ident = match module_path.last() {\n-                                        Some(&ident) => ident,\n-                                        None => {\n-                                            resolve_error(\n-                                                self,\n-                                                source_item.span,\n-                                                ResolutionError::\n-                                                SelfImportOnlyInImportListWithNonEmptyPrefix\n-                                            );\n-                                            continue;\n-                                        }\n-                                    };\n+                                    let ident = *module_path.last().unwrap();\n+                                    if ident.name == keywords::CrateRoot.name() {\n+                                        resolve_error(\n+                                            self,\n+                                            source_item.span,\n+                                            ResolutionError::\n+                                            SelfImportOnlyInImportListWithNonEmptyPrefix\n+                                        );\n+                                        continue;\n+                                    }\n                                     let module_path = module_path.split_last().unwrap().1;\n                                     let rename = node.rename.unwrap_or(ident);\n                                     (module_path.to_vec(), ident, rename)"}, {"sha": "7f91576f6d68f60a1c4eb1b742fcf5e1e101236c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -578,9 +578,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     fn visit_poly_trait_ref(&mut self,\n                             tref: &'tcx ast::PolyTraitRef,\n                             m: &'tcx ast::TraitBoundModifier) {\n-        let ast::Path { ref segments, span, global } = tref.trait_ref.path;\n+        let ast::Path { ref segments, span } = tref.trait_ref.path;\n         let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-        let def = self.resolve_trait_reference(&path, global, None, span);\n+        let def = self.resolve_trait_reference(&path, None, span);\n         self.record_def(tref.trait_ref.ref_id, def);\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n@@ -753,13 +753,6 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum PathScope {\n-    Global,\n-    Lexical,\n-    Import,\n-}\n-\n #[derive(Clone)]\n enum PathResult<'a> {\n     Module(Module<'a>),\n@@ -783,7 +776,7 @@ pub struct ModuleData<'a> {\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n-    macro_resolutions: RefCell<Vec<(Box<[Ident]>, PathScope, Span)>>,\n+    macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<Mark>>,\n@@ -1174,13 +1167,12 @@ impl<'a> ty::NodeIdTree for Resolver<'a> {\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n-        let hir::Path { ref segments, span, global, ref mut def } = *path;\n+        let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n-        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n-        match self.resolve_path(&path, scope, Some(namespace), Some(span)) {\n+        match self.resolve_path(&path, Some(namespace), Some(span)) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.depth == 0 => *def = path_res.base_def,\n-            PathResult::NonModule(..) => match self.resolve_path(&path, scope, None, Some(span)) {\n+            PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n@@ -1601,17 +1593,16 @@ impl<'a> Resolver<'a> {\n                             prefix.segments.iter().map(|seg| seg.identifier).collect();\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n-                            let (scope, span) = (PathScope::Import, prefix.span);\n+                            let span = prefix.span;\n                             // FIXME(#38012) This should be a module path, not anything in TypeNS.\n-                            let result =\n-                                self.resolve_path(&path, scope, Some(TypeNS), Some(span));\n+                            let result = self.resolve_path(&path, Some(TypeNS), Some(span));\n                             let (def, msg) = match result {\n                                 PathResult::Module(module) => (module.def().unwrap(), None),\n                                 PathResult::NonModule(res) if res.depth == 0 =>\n                                     (res.base_def, None),\n                                 PathResult::NonModule(_) => {\n                                     // Resolve a module path for better errors\n-                                    match self.resolve_path(&path, scope, None, Some(span)) {\n+                                    match self.resolve_path(&path, None, Some(span)) {\n                                         PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n                                         _ => unreachable!(),\n                                     }\n@@ -1698,19 +1689,17 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_trait_reference(&mut self,\n                                path: &[Ident],\n-                               global: bool,\n                                generics: Option<&Generics>,\n                                span: Span)\n                                -> PathResolution {\n-        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n-        let def = match self.resolve_path(path, scope, None, Some(span)) {\n+        let def = match self.resolve_path(path, None, Some(span)) {\n             PathResult::Module(module) => Some(module.def().unwrap()),\n             PathResult::NonModule(..) => return err_path_resolution(),\n             PathResult::Failed(msg, false) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return err_path_resolution();\n             }\n-            _ => match self.resolve_path(path, scope, Some(TypeNS), None) {\n+            _ => match self.resolve_path(path, Some(TypeNS), None) {\n                 PathResult::NonModule(path_resolution) => Some(path_resolution.base_def),\n                 _ => None,\n             },\n@@ -1766,9 +1755,9 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let ast::Path { ref segments, span, global } = trait_ref.path;\n+            let ast::Path { ref segments, span } = trait_ref.path;\n             let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-            let path_res = self.resolve_trait_reference(&path, global, generics, span);\n+            let path_res = self.resolve_trait_reference(&path, generics, span);\n             assert!(path_res.depth == 0);\n             self.record_def(trait_ref.ref_id, path_res);\n             if path_res.base_def != Def::Err {\n@@ -2260,9 +2249,8 @@ impl<'a> Resolver<'a> {\n                                    path: &Path,\n                                    ns: Namespace)\n                                    -> Option<PathResolution> {\n-        let ast::Path { ref segments, global, span } = *path;\n+        let ast::Path { ref segments, span } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n \n         if let Some(qself) = maybe_qself {\n             if qself.position == 0 {\n@@ -2273,10 +2261,10 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n             // Make sure the trait is valid.\n-            self.resolve_trait_reference(&path[..qself.position], global, None, span);\n+            self.resolve_trait_reference(&path[..qself.position], None, span);\n         }\n \n-        let result = match self.resolve_path(&path, scope, Some(ns), Some(span)) {\n+        let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n             PathResult::NonModule(path_res) => match path_res.base_def {\n                 Def::Trait(..) if maybe_qself.is_some() => return None,\n                 _ => path_res,\n@@ -2297,7 +2285,7 @@ impl<'a> Resolver<'a> {\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n             PathResult::Module(..) | PathResult::Failed(..)\n-                    if scope == PathScope::Lexical && (ns == TypeNS || path.len() > 1) &&\n+                    if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n                 PathResolution {\n                     base_def: Def::PrimTy(self.primitive_type_table.primitive_types[&path[0].name]),\n@@ -2317,7 +2305,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let unqualified_result = {\n-            match self.resolve_path(&[*path.last().unwrap()], PathScope::Lexical, Some(ns), None) {\n+            match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n                 PathResult::NonModule(path_res) => path_res.base_def,\n                 PathResult::Module(module) => module.def().unwrap(),\n                 _ => return Some(result),\n@@ -2333,27 +2321,19 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_path(&mut self,\n                     path: &[Ident],\n-                    scope: PathScope,\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n                     record_used: Option<Span>)\n                     -> PathResult<'a> {\n-        let (mut module, allow_self) = match scope {\n-            PathScope::Lexical => (None, true),\n-            PathScope::Import => (Some(self.graph_root), true),\n-            PathScope::Global => (Some(self.graph_root), false),\n-        };\n-        let mut allow_super = allow_self;\n+        let mut module = None;\n+        let mut allow_super = true;\n \n         for (i, &ident) in path.iter().enumerate() {\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n \n-            if i == 0 && allow_self && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n+            if i == 0 && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n                 module = Some(self.module_map[&self.current_module.normal_ancestor_id.unwrap()]);\n                 continue\n-            } else if i == 0 && allow_self && ns == TypeNS && ident.name == \"$crate\" {\n-                module = Some(self.resolve_crate_var(ident.ctxt));\n-                continue\n             } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n                 let current_module = if i == 0 { self.current_module } else { module.unwrap() };\n                 let self_module = self.module_map[&current_module.normal_ancestor_id.unwrap()];\n@@ -2367,6 +2347,14 @@ impl<'a> Resolver<'a> {\n             }\n             allow_super = false;\n \n+            if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n+                module = Some(self.graph_root);\n+                continue\n+            } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n+                module = Some(self.resolve_crate_var(ident.ctxt));\n+                continue\n+            }\n+\n             let binding = if let Some(module) = module {\n                 self.resolve_ident_in_module(module, ident, ns, false, record_used)\n             } else if opt_ns == Some(MacroNS) {\n@@ -2430,7 +2418,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        PathResult::Module(module.unwrap())\n+        PathResult::Module(module.unwrap_or(self.graph_root))\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -2665,10 +2653,8 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     // Be helpful if the name refers to a struct\n                     let path_name = path_names_to_string(path, 0);\n-                    let ast::Path { ref segments, global, .. } = *path;\n-                    let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-                    let scope = if global { PathScope::Global } else { PathScope::Lexical };\n-                    let type_res = match self.resolve_path(&path, scope, Some(TypeNS), None) {\n+                    let path: Vec<_> = path.segments.iter().map(|seg| seg.identifier).collect();\n+                    let type_res = match self.resolve_path(&path, Some(TypeNS), None) {\n                         PathResult::NonModule(type_res) => Some(type_res),\n                         _ => None,\n                     };\n@@ -2738,7 +2724,7 @@ impl<'a> Resolver<'a> {\n                             } else {\n                                 // we display a help message if this is a module\n                                 if let PathResult::Module(module) =\n-                                        self.resolve_path(&path, scope, None, None) {\n+                                        self.resolve_path(&path, None, None) {\n                                     def = module.def().unwrap();\n                                     context = UnresolvedNameContext::PathIsMod(parent);\n                                 }\n@@ -2964,7 +2950,6 @@ impl<'a> Resolver<'a> {\n                         segms.push(ident.into());\n                         let path = Path {\n                             span: span,\n-                            global: false,\n                             segments: segms,\n                         };\n                         // the entity is accessible in the following cases:\n@@ -3022,7 +3007,7 @@ impl<'a> Resolver<'a> {\n \n         let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let mut path_resolution = err_path_resolution();\n-        let vis = match self.resolve_path(&path, PathScope::Import, None, Some(span)) {\n+        let vis = match self.resolve_path(&path, None, Some(span)) {\n             PathResult::Module(module) => {\n                 path_resolution = PathResolution::new(module.def().unwrap());\n                 ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n@@ -3190,15 +3175,14 @@ impl<'a> Resolver<'a> {\n }\n \n fn names_to_string(names: &[Ident]) -> String {\n-    let mut first = true;\n     let mut result = String::new();\n-    for ident in names {\n-        if first {\n-            first = false\n-        } else {\n-            result.push_str(\"::\")\n+    for (i, ident) in names.iter().enumerate() {\n+        if i > 0 {\n+            result.push_str(\"::\");\n+        }\n+        if ident.name != keywords::CrateRoot.name() {\n+            result.push_str(&ident.name.as_str());\n         }\n-        result.push_str(&ident.name.as_str());\n     }\n     result\n }"}, {"sha": "ff3c583629371fed73a6cbbd3c716f21a0d852ba", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use {AmbiguityError, Resolver, ResolutionError, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathScope, PathResult};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult};\n use Namespace::{self, MacroNS};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use resolve_imports::ImportResolver;\n@@ -30,6 +30,7 @@ use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::fold::Folder;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -105,15 +106,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == \"$crate\" {\n-                    path.global = true;\n+                    path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n-                    if module.is_local() {\n-                        path.segments.remove(0);\n-                    } else {\n-                        path.segments[0].identifier = match module.kind {\n-                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name),\n+                    if !module.is_local() {\n+                        path.segments.insert(1, match module.kind {\n+                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name).into(),\n                             _ => unreachable!(),\n-                        };\n+                        })\n                     }\n                 }\n                 path\n@@ -182,7 +181,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        let ast::Path { ref segments, global, span } = *path;\n+        let ast::Path { ref segments, span } = *path;\n         if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n                 if segments.last().unwrap().parameters.is_some() { \"macro\" } else { \"module\" };\n@@ -191,20 +190,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n             return Err(Determinacy::Determined);\n         }\n \n-        let path_scope = if global { PathScope::Global } else { PathScope::Lexical };\n         let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let invocation = self.invocations[&scope];\n         self.current_module = invocation.module.get();\n \n-        if path.len() > 1 || global {\n+        if path.len() > 1 {\n             if !self.use_extern_macros {\n                 let msg = \"non-ident macro paths are experimental\";\n                 let feature = \"use_extern_macros\";\n                 emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);\n                 return Err(Determinacy::Determined);\n             }\n \n-            let ext = match self.resolve_path(&path, path_scope, Some(MacroNS), None) {\n+            let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n                 PathResult::NonModule(path_res) => match path_res.base_def {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(self.get_macro(def)),\n@@ -214,7 +212,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 _ => Err(Determinacy::Determined),\n             };\n             self.current_module.macro_resolutions.borrow_mut()\n-                .push((path.into_boxed_slice(), path_scope, span));\n+                .push((path.into_boxed_slice(), span));\n             return ext;\n         }\n \n@@ -351,8 +349,8 @@ impl<'a> Resolver<'a> {\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n-        for &(ref path, scope, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, scope, Some(MacroNS), Some(span)) {\n+        for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n+            match self.resolve_path(path, Some(MacroNS), Some(span)) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "f62974b30d18ea37c29bd1cf1b0fea973d2aac42", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -12,7 +12,7 @@ use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError};\n+use {NameBinding, NameBindingKind, PathResult, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n@@ -24,6 +24,7 @@ use rustc::hir::def::*;\n use syntax::ast::{Ident, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n+use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n@@ -490,7 +491,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::PrivateExternal);\n-            let result = self.resolve_path(&directive.module_path, PathScope::Import, None, None);\n+            let result = self.resolve_path(&directive.module_path, None, None);\n             directive.vis.set(vis);\n \n             match result {\n@@ -553,15 +554,17 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_path(&module_path, PathScope::Import, None, Some(span));\n+        let module_result = self.resolve_path(&module_path, None, Some(span));\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(msg, _) => {\n-                let mut path = vec![keywords::SelfValue.ident()];\n-                path.extend(module_path);\n-                let result = self.resolve_path(&path, PathScope::Import, None, None);\n-                return if let PathResult::Module(..) = result {\n-                    Some(format!(\"Did you mean `self::{}`?\", &names_to_string(module_path)))\n+                let (mut self_path, mut self_result) = (module_path.clone(), None);\n+                if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n+                    self_path[0].name = keywords::SelfValue.name();\n+                    self_result = Some(self.resolve_path(&self_path, None, None));\n+                }\n+                return if let Some(PathResult::Module(..)) = self_result {\n+                    Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n                 } else {\n                     Some(msg)\n                 };\n@@ -787,6 +790,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n }\n \n fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String {\n+    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n+    let names = if global { &names[1..] } else { names };\n     if names.is_empty() {\n         import_directive_subclass_to_string(subclass)\n     } else {"}, {"sha": "65372d4dca9a19dcf31cf091154931e97f975d42", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -143,19 +143,20 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     // a str representation of the entire prefix.\n     fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n         let spans = self.span.spans_for_path_segments(path);\n+        let segments = &path.segments[if path.is_global() { 1 } else { 0 }..];\n \n         // Paths to enums seem to not match their spans - the span includes all the\n         // variants too. But they seem to always be at the end, so I hope we can cope with\n         // always using the first ones. So, only error out if we don't have enough spans.\n         // What could go wrong...?\n-        if spans.len() < path.segments.len() {\n+        if spans.len() < segments.len() {\n             if generated_code(path.span) {\n                 return vec![];\n             }\n             error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n                    path_to_string(path),\n                    spans.len(),\n-                   path.segments.len());\n+                   segments.len());\n             for s in &spans {\n                 let loc = self.sess.codemap().lookup_char_pos(s.lo);\n                 error!(\"    '{}' in {}, line {}\",\n@@ -170,14 +171,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let mut result: Vec<(Span, String)> = vec![];\n \n         let mut segs = vec![];\n-        for (i, (seg, span)) in path.segments.iter().zip(&spans).enumerate() {\n+        for (i, (seg, span)) in segments.iter().zip(&spans).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {\n                 span: *span, // span for the last segment\n-                global: path.global,\n                 segments: segs,\n             };\n-            let qualname = if i == 0 && path.global {\n+            let qualname = if i == 0 && path.is_global() {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n                 path_to_string(&sub_path)\n@@ -189,20 +189,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         result\n     }\n \n-    // The global arg allows us to override the global-ness of the path (which\n-    // actually means 'does the path start with `::`', rather than 'is the path\n-    // semantically global). We use the override for `use` imports (etc.) where\n-    // the syntax is non-global, but the semantics are global.\n-    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n+    fn write_sub_paths(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n+        for (span, qualname) in sub_paths {\n             self.dumper.mod_ref(ModRefData {\n-                span: *span,\n+                span: span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n@@ -212,22 +203,16 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n             return;\n         }\n \n-        let sub_paths = &sub_paths[..len-1];\n-        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n-            let qualname = if i == 0 && global && !path.global {\n-                format!(\"::{}\", qualname)\n-            } else {\n-                qualname.clone()\n-            };\n+        for (span, qualname) in sub_paths.into_iter().take(len - 1) {\n             self.dumper.mod_ref(ModRefData {\n-                span: *span,\n+                span: span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n                 ref_id: None\n@@ -935,7 +920,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::Union(..) |\n             Def::Variant(..) |\n             Def::TyAlias(..) |\n-            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path, false),\n+            Def::AssociatedTy(..) => self.write_sub_paths_truncated(path),\n             _ => {}\n         }\n     }\n@@ -946,7 +931,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                           fields: &'l [ast::Field],\n                           variant: &'l ty::VariantDef,\n                           base: &'l Option<P<ast::Expr>>) {\n-        self.write_sub_paths_truncated(path, false);\n+        self.write_sub_paths_truncated(path);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n@@ -1201,7 +1186,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                                 visibility: From::from(&item.vis),\n                             }.lower(self.tcx));\n                         }\n-                        self.write_sub_paths_truncated(path, true);\n+                        self.write_sub_paths_truncated(path);\n                     }\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n@@ -1225,7 +1210,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                                 visibility: From::from(&item.vis),\n                             }.lower(self.tcx));\n                         }\n-                        self.write_sub_paths(path, true);\n+                        self.write_sub_paths(path);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list {\n@@ -1237,7 +1222,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                             }\n                         }\n \n-                        self.write_sub_paths(path, true);\n+                        self.write_sub_paths(path);\n                     }\n                 }\n             }\n@@ -1340,7 +1325,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                     }.lower(self.tcx));\n                 }\n \n-                self.write_sub_paths_truncated(path, false);\n+                self.write_sub_paths_truncated(path);\n \n                 visit::walk_path(self, path);\n             }"}, {"sha": "fdbd2f3647c0c482c787d2c82322567a48b593be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -1737,7 +1737,6 @@ impl Clean<Type> for hir::Ty {\n                 segments.pop();\n                 let trait_path = hir::Path {\n                     span: p.span,\n-                    global: p.global,\n                     def: Def::Trait(cx.tcx.associated_item(p.def.def_id()).container.id()),\n                     segments: segments.into(),\n                 };\n@@ -1756,7 +1755,6 @@ impl Clean<Type> for hir::Ty {\n                 }\n                 let trait_path = hir::Path {\n                     span: self.span,\n-                    global: false,\n                     def: def,\n                     segments: vec![].into(),\n                 };\n@@ -2213,9 +2211,9 @@ impl Path {\n impl Clean<Path> for hir::Path {\n     fn clean(&self, cx: &DocContext) -> Path {\n         Path {\n-            global: self.global,\n+            global: self.is_global(),\n             def: self.def,\n-            segments: self.segments.clean(cx),\n+            segments: if self.is_global() { &self.segments[1..] } else { &self.segments }.clean(cx),\n         }\n     }\n }\n@@ -2270,24 +2268,19 @@ impl Clean<PathSegment> for hir::PathSegment {\n }\n \n fn qpath_to_string(p: &hir::QPath) -> String {\n-    let (segments, global) = match *p {\n-        hir::QPath::Resolved(_, ref path) => {\n-            (&path.segments, path.global)\n-        }\n-        hir::QPath::TypeRelative(_, ref segment) => {\n-            return segment.name.to_string()\n-        }\n+    let segments = match *p {\n+        hir::QPath::Resolved(_, ref path) => &path.segments,\n+        hir::QPath::TypeRelative(_, ref segment) => return segment.name.to_string(),\n     };\n \n     let mut s = String::new();\n-    let mut first = true;\n-    for i in segments.iter().map(|x| x.name.as_str()) {\n-        if !first || global {\n+    for (i, seg) in segments.iter().enumerate() {\n+        if i > 0 {\n             s.push_str(\"::\");\n-        } else {\n-            first = false;\n         }\n-        s.push_str(&i);\n+        if seg.name != keywords::CrateRoot.name() {\n+            s.push_str(&*seg.name.as_str());\n+        }\n     }\n     s\n }"}, {"sha": "648a82ffb76844262a64ce610ecb8dcf4d2dd6db", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -111,10 +111,8 @@ pub struct LifetimeDef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Path {\n     pub span: Span,\n-    /// A `::foo` path, is relative to the crate root rather than current\n-    /// module (like paths in an import).\n-    pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n+    /// Global paths begin with `keywords::CrateRoot`.\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -136,10 +134,22 @@ impl Path {\n     pub fn from_ident(s: Span, identifier: Ident) -> Path {\n         Path {\n             span: s,\n-            global: false,\n             segments: vec![identifier.into()],\n         }\n     }\n+\n+    pub fn default_to_global(mut self) -> Path {\n+        let name = self.segments[0].identifier.name;\n+        if !self.is_global() && name != \"$crate\" &&\n+           name != keywords::SelfValue.name() && name != keywords::Super.name() {\n+            self.segments.insert(0, PathSegment::crate_root());\n+        }\n+        self\n+    }\n+\n+    pub fn is_global(&self) -> bool {\n+        !self.segments.is_empty() && self.segments[0].identifier.name == keywords::CrateRoot.name()\n+    }\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n@@ -166,6 +176,15 @@ impl From<Ident> for PathSegment {\n     }\n }\n \n+impl PathSegment {\n+    pub fn crate_root() -> Self {\n+        PathSegment {\n+            identifier: keywords::CrateRoot.ident(),\n+            parameters: None,\n+        }\n+    }\n+}\n+\n /// Parameters of a path segment.\n ///\n /// E.g. `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`"}, {"sha": "7584fa3916de01d77c9398c2b5e459c83d3d95fb", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -322,7 +322,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = idents.into_iter().map(Into::into).collect();\n+        let mut segments: Vec<ast::PathSegment> = Vec::new();\n+        if global {\n+            segments.push(ast::PathSegment::crate_root());\n+        }\n+\n+        segments.extend(idents.into_iter().map(Into::into));\n         let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n             None\n         } else {\n@@ -335,7 +340,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n         ast::Path {\n             span: sp,\n-            global: global,\n             segments: segments,\n         }\n     }"}, {"sha": "66555d7d95dce03c0ca9b0bda7dfbf18ba857473", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -25,7 +25,7 @@ use std::mem;\n pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     fn mac_placeholder() -> ast::Mac {\n         dummy_spanned(ast::Mac_ {\n-            path: ast::Path { span: DUMMY_SP, global: false, segments: Vec::new() },\n+            path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n             tts: Vec::new(),\n         })\n     }"}, {"sha": "bf10d45add4a0b09e4d43f23a3492cc1310def7a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -433,9 +433,8 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n     i\n }\n \n-pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n+pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        global: global,\n         segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),"}, {"sha": "24178e1f675b5197d218017aa558a5013b537932", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -633,7 +633,6 @@ mod tests {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n-                        global: false,\n                         segments: vec![Ident::from_str(\"a\").into()],\n                     }),\n                     span: sp(0, 1),\n@@ -647,8 +646,9 @@ mod tests {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 6),\n-                        global: true,\n-                        segments: vec![Ident::from_str(\"a\").into(), Ident::from_str(\"b\").into()],\n+                        segments: vec![ast::PathSegment::crate_root(),\n+                                       Ident::from_str(\"a\").into(),\n+                                       Ident::from_str(\"b\").into()]\n                     }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n@@ -757,7 +757,6 @@ mod tests {\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n-                            global: false,\n                             segments: vec![Ident::from_str(\"d\").into()],\n                         }),\n                         span:sp(7,8),\n@@ -775,7 +774,6 @@ mod tests {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n-                               global:false,\n                                segments: vec![Ident::from_str(\"b\").into()],\n                             }),\n                            span: sp(0,1),\n@@ -817,7 +815,6 @@ mod tests {\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n-                                        global:false,\n                                         segments: vec![Ident::from_str(\"i32\").into()],\n                                         }),\n                                         span:sp(10,13)\n@@ -860,7 +857,6 @@ mod tests {\n                                                 node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n-                                                        global:false,\n                                                         segments: vec![Ident::from_str(\"b\").into()],\n                                                       }),\n                                                 span: sp(17,18),"}, {"sha": "cd4f255b5e3f815668aaedc483177d811ccca2bd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -1614,7 +1614,6 @@ impl<'a> Parser<'a> {\n         } else {\n             ast::Path {\n                 span: span,\n-                global: false,\n                 segments: vec![]\n             }\n         };\n@@ -1658,7 +1657,7 @@ impl<'a> Parser<'a> {\n         // Parse any number of segments and bound sets. A segment is an\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n-        let segments = match mode {\n+        let mut segments = match mode {\n             PathStyle::Type => {\n                 self.parse_path_segments_without_colons()?\n             }\n@@ -1670,13 +1669,16 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n+        if is_global {\n+            segments.insert(0, ast::PathSegment::crate_root());\n+        }\n+\n         // Assemble the span.\n         let span = mk_sp(lo, self.prev_span.hi);\n \n         // Assemble the result.\n         Ok(ast::Path {\n             span: span,\n-            global: is_global,\n             segments: segments,\n         })\n     }\n@@ -5180,7 +5182,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Crate) {\n             pub_crate(self)\n         } else {\n-            let path = self.parse_path(PathStyle::Mod)?;\n+            let path = self.parse_path(PathStyle::Mod)?.default_to_global();\n             self.expect(&token::CloseDelim(token::Paren))?;\n             Ok(Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID })\n         }\n@@ -6068,9 +6070,9 @@ impl<'a> Parser<'a> {\n         if self.check(&token::OpenDelim(token::Brace)) || self.check(&token::BinOp(token::Star)) ||\n            self.is_import_coupler() {\n             // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n+            self.eat(&token::ModSep);\n             let prefix = ast::Path {\n-                global: self.eat(&token::ModSep),\n-                segments: Vec::new(),\n+                segments: vec![ast::PathSegment::crate_root()],\n                 span: mk_sp(lo, self.span.hi),\n             };\n             let view_path_kind = if self.eat(&token::BinOp(token::Star)) {\n@@ -6080,7 +6082,7 @@ impl<'a> Parser<'a> {\n             };\n             Ok(P(spanned(lo, self.span.hi, view_path_kind)))\n         } else {\n-            let prefix = self.parse_path(PathStyle::Mod)?;\n+            let prefix = self.parse_path(PathStyle::Mod)?.default_to_global();\n             if self.is_import_coupler() {\n                 // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();"}, {"sha": "e9c1cbcba61db9953bab3135bd9349222f4b53e8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -371,7 +371,7 @@ pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n+    to_string(|s| s.print_path(p, false, 0, false))\n }\n \n pub fn ident_to_string(id: ast::Ident) -> String {\n@@ -435,7 +435,8 @@ pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     match *vis {\n         ast::Visibility::Public => format!(\"pub {}\", s),\n         ast::Visibility::Crate(_) => format!(\"pub(crate) {}\", s),\n-        ast::Visibility::Restricted { ref path, .. } => format!(\"pub({}) {}\", path, s),\n+        ast::Visibility::Restricted { ref path, .. } =>\n+            format!(\"pub({}) {}\", to_string(|s| s.print_path(path, false, 0, true)), s),\n         ast::Visibility::Inherited => s.to_string()\n     }\n }\n@@ -1021,7 +1022,7 @@ impl<'a> State<'a> {\n                                  &generics));\n             }\n             ast::TyKind::Path(None, ref path) => {\n-                try!(self.print_path(path, false, 0));\n+                try!(self.print_path(path, false, 0, false));\n             }\n             ast::TyKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, false))\n@@ -1332,7 +1333,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n                 try!(self.print_visibility(&item.vis));\n-                try!(self.print_path(&node.path, false, 0));\n+                try!(self.print_path(&node.path, false, 0, false));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(INDENT_UNIT));\n@@ -1347,7 +1348,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> io::Result<()> {\n-        self.print_path(&t.path, false, 0)\n+        self.print_path(&t.path, false, 0, false)\n     }\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> io::Result<()> {\n@@ -1405,8 +1406,10 @@ impl<'a> State<'a> {\n         match *vis {\n             ast::Visibility::Public => self.word_nbsp(\"pub\"),\n             ast::Visibility::Crate(_) => self.word_nbsp(\"pub(crate)\"),\n-            ast::Visibility::Restricted { ref path, .. } =>\n-                self.word_nbsp(&format!(\"pub({})\", path)),\n+            ast::Visibility::Restricted { ref path, .. } => {\n+                let path = to_string(|s| s.print_path(path, false, 0, true));\n+                self.word_nbsp(&format!(\"pub({})\", path))\n+            }\n             ast::Visibility::Inherited => Ok(())\n         }\n     }\n@@ -1571,7 +1574,7 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0)?;\n+                self.print_path(&node.path, false, 0, false)?;\n                 word(&mut self.s, \"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n@@ -1607,7 +1610,7 @@ impl<'a> State<'a> {\n             }\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n-                try!(self.print_path(&node.path, false, 0));\n+                try!(self.print_path(&node.path, false, 0, false));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(INDENT_UNIT));\n                 try!(self.popen());\n@@ -1793,7 +1796,7 @@ impl<'a> State<'a> {\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n                      -> io::Result<()> {\n-        try!(self.print_path(&m.node.path, false, 0));\n+        try!(self.print_path(&m.node.path, false, 0, false));\n         try!(word(&mut self.s, \"!\"));\n         match delim {\n             token::Paren => try!(self.popen()),\n@@ -1885,7 +1888,7 @@ impl<'a> State<'a> {\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>,\n                          attrs: &[Attribute]) -> io::Result<()> {\n-        try!(self.print_path(path, true, 0));\n+        try!(self.print_path(path, true, 0, false));\n         try!(word(&mut self.s, \"{\"));\n         try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_cmnt(\n@@ -2186,7 +2189,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n-                try!(self.print_path(path, true, 0))\n+                try!(self.print_path(path, true, 0, false))\n             }\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, true))\n@@ -2334,23 +2337,25 @@ impl<'a> State<'a> {\n     fn print_path(&mut self,\n                   path: &ast::Path,\n                   colons_before_params: bool,\n-                  depth: usize)\n+                  depth: usize,\n+                  defaults_to_global: bool)\n                   -> io::Result<()>\n     {\n         try!(self.maybe_print_comment(path.span.lo));\n \n-        let mut first = !path.global;\n-        for segment in &path.segments[..path.segments.len()-depth] {\n-            if first {\n-                first = false\n-            } else {\n+        let mut segments = path.segments[..path.segments.len()-depth].iter();\n+        if defaults_to_global && path.is_global() {\n+            segments.next();\n+        }\n+        for (i, segment) in segments.enumerate() {\n+            if i > 0 {\n                 try!(word(&mut self.s, \"::\"))\n             }\n-\n-            try!(self.print_ident(segment.identifier));\n-\n-            if let Some(ref parameters) = segment.parameters {\n-                try!(self.print_path_parameters(parameters, colons_before_params))\n+            if segment.identifier.name != keywords::CrateRoot.name() {\n+                try!(self.print_ident(segment.identifier));\n+                if let Some(ref parameters) = segment.parameters {\n+                    try!(self.print_path_parameters(parameters, colons_before_params));\n+                }\n             }\n         }\n \n@@ -2369,7 +2374,7 @@ impl<'a> State<'a> {\n             try!(space(&mut self.s));\n             try!(self.word_space(\"as\"));\n             let depth = path.segments.len() - qself.position;\n-            try!(self.print_path(&path, false, depth));\n+            try!(self.print_path(&path, false, depth, false));\n         }\n         try!(word(&mut self.s, \">\"));\n         try!(word(&mut self.s, \"::\"));\n@@ -2472,7 +2477,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n-                try!(self.print_path(path, true, 0));\n+                try!(self.print_path(path, true, 0, false));\n                 try!(self.popen());\n                 if let Some(ddpos) = ddpos {\n                     try!(self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p)));\n@@ -2490,13 +2495,13 @@ impl<'a> State<'a> {\n                 try!(self.pclose());\n             }\n             PatKind::Path(None, ref path) => {\n-                try!(self.print_path(path, true, 0));\n+                try!(self.print_path(path, true, 0, false));\n             }\n             PatKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, false));\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n-                try!(self.print_path(path, true, 0));\n+                try!(self.print_path(path, true, 0, false));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n@@ -2843,7 +2848,7 @@ impl<'a> State<'a> {\n                     try!(self.print_lifetime_bounds(lifetime, bounds));\n                 }\n                 ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    try!(self.print_path(path, false, 0));\n+                    try!(self.print_path(path, false, 0, false));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n                     try!(self.print_type(&ty));\n@@ -2857,7 +2862,7 @@ impl<'a> State<'a> {\n     pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> io::Result<()> {\n         match vp.node {\n             ast::ViewPathSimple(ident, ref path) => {\n-                try!(self.print_path(path, false, 0));\n+                try!(self.print_path(path, false, 0, true));\n \n                 if path.segments.last().unwrap().identifier.name !=\n                         ident.name {\n@@ -2870,15 +2875,15 @@ impl<'a> State<'a> {\n             }\n \n             ast::ViewPathGlob(ref path) => {\n-                try!(self.print_path(path, false, 0));\n+                try!(self.print_path(path, false, 0, true));\n                 word(&mut self.s, \"::*\")\n             }\n \n             ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n                     try!(word(&mut self.s, \"{\"));\n                 } else {\n-                    try!(self.print_path(path, false, 0));\n+                    try!(self.print_path(path, false, 0, true));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n                 try!(self.commasep(Inconsistent, &idents[..], |s, w| {"}, {"sha": "68d807b24a788547bc8516c68dbffd496e4ce353", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -80,8 +80,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         }],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n-            global: false,\n-            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+            segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n                 ast::Ident::from_str(name).into()\n             }).collect(),\n             span: span,"}, {"sha": "c2123ea5a079803a3897053afefec54656df786e", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -221,6 +221,9 @@ declare_keywords! {\n     (53, Default,        \"default\")\n     (54, StaticLifetime, \"'static\")\n     (55, Union,          \"union\")\n+\n+    // A virtual keyword that resolves to the crate root when used in a lexical scope.\n+    (56, CrateRoot, \"{{root}}\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "b8e0b938814a76605dc24226e8c726c97cb30589", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -579,7 +579,6 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n-        global: false,\n         segments: ids.into_iter().map(Into::into).collect(),\n     }\n }"}, {"sha": "1fc1bdff593c2766fa16ab94bad998451f82e0ee", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -61,7 +61,6 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         fn path(&self) -> ast::Path {\n             ast::Path {\n                 span: self.span,\n-                global: false,\n                 segments: vec![self.ident.into()],\n             }\n         }"}, {"sha": "7f187d8d1c1195a472d8a749ace01da3a892fa63", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -363,15 +363,12 @@ fn find_type_parameters(ty: &ast::Ty,\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            match ty.node {\n-                ast::TyKind::Path(_, ref path) if !path.global => {\n-                    if let Some(segment) = path.segments.first() {\n-                        if self.ty_param_names.contains(&segment.identifier.name) {\n-                            self.types.push(P(ty.clone()));\n-                        }\n+            if let ast::TyKind::Path(_, ref path) = ty.node {\n+                if let Some(segment) = path.segments.first() {\n+                    if self.ty_param_names.contains(&segment.identifier.name) {\n+                        self.types.push(P(ty.clone()));\n                     }\n                 }\n-                _ => {}\n             }\n \n             visit::walk_ty(self, ty)"}, {"sha": "3c585680eab119222c5a4a65104c401ca28106c7", "filename": "src/test/compile-fail/resolve-primitive-fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Ftest%2Fcompile-fail%2Fresolve-primitive-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10f50b42639718b2580d10802f05f2b6ff209d5/src%2Ftest%2Fcompile-fail%2Fresolve-primitive-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-primitive-fallback.rs?ref=f10f50b42639718b2580d10802f05f2b6ff209d5", "patch": "@@ -16,5 +16,5 @@ fn main() {\n \n     // Make sure primitive type fallback doesn't work with global paths\n     let _: ::u8;\n-    //~^ ERROR type name `u8` is undefined or not in scope\n+    //~^ ERROR type name `::u8` is undefined or not in scope\n }"}]}