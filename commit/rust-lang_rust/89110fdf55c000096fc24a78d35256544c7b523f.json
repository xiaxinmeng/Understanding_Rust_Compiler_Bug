{"sha": "89110fdf55c000096fc24a78d35256544c7b523f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MTEwZmRmNTVjMDAwMDk2ZmMyNGE3OGQzNTI1NjU0NGM3YjUyM2Y=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-22T00:37:03Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-29T07:58:50Z"}, "message": "Use more deriving(IterBytes) in librustc.", "tree": {"sha": "3f02930e83cfeeb08af21d30102946552880d4de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f02930e83cfeeb08af21d30102946552880d4de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89110fdf55c000096fc24a78d35256544c7b523f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89110fdf55c000096fc24a78d35256544c7b523f", "html_url": "https://github.com/rust-lang/rust/commit/89110fdf55c000096fc24a78d35256544c7b523f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89110fdf55c000096fc24a78d35256544c7b523f/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b80bad638a40c0a969fabf897f0ef13fe567b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b80bad638a40c0a969fabf897f0ef13fe567b7", "html_url": "https://github.com/rust-lang/rust/commit/75b80bad638a40c0a969fabf897f0ef13fe567b7"}], "stats": {"total": 298, "additions": 23, "deletions": 275}, "files": [{"sha": "b255f2ca78c7fd19f32e4069c1dae7c2d0866d03", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/89110fdf55c000096fc24a78d35256544c7b523f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89110fdf55c000096fc24a78d35256544c7b523f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=89110fdf55c000096fc24a78d35256544c7b523f", "patch": "@@ -36,6 +36,8 @@ use core::cast;\n use core::hashmap::{HashMap};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::to_bytes;\n+use core::str;\n+use core::vec::raw::to_ptr;\n use core::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n@@ -860,7 +862,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub enum mono_param_id {\n     mono_precise(ty::t, Option<@~[mono_id]>),\n     mono_any,\n@@ -870,7 +872,7 @@ pub enum mono_param_id {\n               datum::DatumMode),\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub enum MonoDataClass {\n     MonoBits,    // Anything not treated differently from arbitrary integer data\n     MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n@@ -895,7 +897,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n }\n \n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct mono_id_ {\n     def: ast::def_id,\n     params: ~[mono_param_id],\n@@ -904,40 +906,6 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-impl to_bytes::IterBytes for mono_param_id {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            mono_precise(t, ref mids) => {\n-                0u8.iter_bytes(lsb0, f) &&\n-                ty::type_id(t).iter_bytes(lsb0, f) &&\n-                mids.iter_bytes(lsb0, f)\n-            }\n-\n-            mono_any => 1u8.iter_bytes(lsb0, f),\n-\n-            mono_repr(ref a, ref b, ref c, ref d) => {\n-                2u8.iter_bytes(lsb0, f) &&\n-                a.iter_bytes(lsb0, f) &&\n-                b.iter_bytes(lsb0, f) &&\n-                c.iter_bytes(lsb0, f) &&\n-                d.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n-impl to_bytes::IterBytes for MonoDataClass {\n-    fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for mono_id_ {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.def.iter_bytes(lsb0, f) && self.params.iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);"}, {"sha": "a990e4c70a94cbd5c0036264bc1017eecdbe7580", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 212, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/89110fdf55c000096fc24a78d35256544c7b523f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89110fdf55c000096fc24a78d35256544c7b523f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=89110fdf55c000096fc24a78d35256544c7b523f", "patch": "@@ -52,7 +52,7 @@ use syntax;\n \n // Data types\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct field {\n     ident: ast::ident,\n     mt: mt\n@@ -96,13 +96,13 @@ impl Method {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct mt {\n     ty: t,\n     mutbl: ast::mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -133,7 +133,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct creader_cache_key {\n     cnum: int,\n     pos: uint,\n@@ -142,14 +142,6 @@ pub struct creader_cache_key {\n \n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n-impl to_bytes::IterBytes for creader_cache_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.cnum.iter_bytes(lsb0, f) &&\n-        self.pos.iter_bytes(lsb0, f) &&\n-        self.len.iter_bytes(lsb0, f)\n-    }\n-}\n-\n struct intern_key {\n     sty: *sty,\n }\n@@ -168,6 +160,8 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n+// NB: Do not replace this with #[deriving(IterBytes)], as above. (Figured\n+// this out the hard way.)\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n         unsafe {\n@@ -372,14 +366,14 @@ pub fn type_has_regions(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct BareFnTy {\n     purity: ast::purity,\n     abis: AbiSet,\n     sig: FnSig\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n pub struct ClosureTy {\n     purity: ast::purity,\n     sigil: ast::Sigil,\n@@ -396,32 +390,13 @@ pub struct ClosureTy {\n  * - `lifetimes` is the list of region names bound in this fn.\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type. */\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct FnSig {\n     bound_lifetime_names: OptVec<ast::ident>,\n     inputs: ~[t],\n     output: t\n }\n \n-impl to_bytes::IterBytes for BareFnTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.purity.iter_bytes(lsb0, f) &&\n-        self.abis.iter_bytes(lsb0, f) &&\n-        self.sig.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for ClosureTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.purity.iter_bytes(lsb0, f) &&\n-        self.sigil.iter_bytes(lsb0, f) &&\n-        self.onceness.iter_bytes(lsb0, f) &&\n-        self.region.iter_bytes(lsb0, f) &&\n-        self.sig.iter_bytes(lsb0, f) &&\n-        self.bounds.iter_bytes(lsb0, f)\n-    }\n-}\n-\n #[deriving(Eq, IterBytes)]\n pub struct param_ty {\n     idx: uint,\n@@ -526,7 +501,7 @@ type opt_region = Option<Region>;\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct substs {\n     self_r: opt_region,\n     self_ty: Option<ty::t>,\n@@ -582,7 +557,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -714,62 +689,33 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct TyVid(uint);\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct IntVid(uint);\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct FloatVid(uint);\n \n-#[deriving(Eq, Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub struct RegionVid {\n     id: uint\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n }\n \n-impl to_bytes::IterBytes for InferTy {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            TyVar(ref tv) => {\n-                0u8.iter_bytes(lsb0, f) && tv.iter_bytes(lsb0, f)\n-            }\n-            IntVar(ref iv) => {\n-                1u8.iter_bytes(lsb0, f) && iv.iter_bytes(lsb0, f)\n-            }\n-            FloatVar(ref fv) => {\n-                2u8.iter_bytes(lsb0, f) && fv.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n-#[deriving(Encodable, Decodable)]\n+#[deriving(Encodable, Decodable, IterBytes)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)\n }\n \n-impl to_bytes::IterBytes for InferRegion {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ReVar(ref rv) => {\n-                0u8.iter_bytes(lsb0, f) && rv.iter_bytes(lsb0, f)\n-            }\n-            ReSkolemized(ref v, _) => {\n-                1u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n impl cmp::Eq for InferRegion {\n     fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n@@ -849,30 +795,6 @@ impl ToStr for IntVarValue {\n     }\n }\n \n-impl to_bytes::IterBytes for TyVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for IntVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for FloatVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for RegionVid {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_uint().iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub struct TypeParameterDef {\n     def_id: ast::def_id,\n     bounds: @ParamBounds\n@@ -2744,123 +2666,6 @@ impl cmp::TotalEq for bound_region {\n     }\n }\n \n-impl to_bytes::IterBytes for vstore {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            vstore_fixed(ref u) => {\n-                0u8.iter_bytes(lsb0, f) && u.iter_bytes(lsb0, f)\n-            }\n-            vstore_uniq => 1u8.iter_bytes(lsb0, f),\n-            vstore_box => 2u8.iter_bytes(lsb0, f),\n-\n-            vstore_slice(ref r) => {\n-                3u8.iter_bytes(lsb0, f) && r.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n-impl to_bytes::IterBytes for substs {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.self_r.iter_bytes(lsb0, f) &&\n-        self.self_ty.iter_bytes(lsb0, f) &&\n-        self.tps.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for mt {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.ty.iter_bytes(lsb0, f) && self.mutbl.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for field {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.ident.iter_bytes(lsb0, f) && self.mt.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for FnSig {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.inputs.iter_bytes(lsb0, f) && self.output.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for sty {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ty_nil => 0u8.iter_bytes(lsb0, f),\n-            ty_bool => 1u8.iter_bytes(lsb0, f),\n-\n-            ty_int(ref t) => 2u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n-\n-            ty_uint(ref t) => 3u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n-\n-            ty_float(ref t) => 4u8.iter_bytes(lsb0, f) && t.iter_bytes(lsb0, f),\n-\n-            ty_estr(ref v) => 5u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f),\n-\n-            ty_enum(ref did, ref substs) => {\n-                6u8.iter_bytes(lsb0, f) &&\n-                did.iter_bytes(lsb0, f) &&\n-                substs.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_box(ref mt) => 7u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_evec(ref mt, ref v) => {\n-                8u8.iter_bytes(lsb0, f) &&\n-                mt.iter_bytes(lsb0, f) &&\n-                v.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_unboxed_vec(ref mt) => 9u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_tup(ref ts) => 10u8.iter_bytes(lsb0, f) && ts.iter_bytes(lsb0, f),\n-\n-            ty_bare_fn(ref ft) => 12u8.iter_bytes(lsb0, f) && ft.iter_bytes(lsb0, f),\n-\n-            ty_self(ref did) => 13u8.iter_bytes(lsb0, f) && did.iter_bytes(lsb0, f),\n-\n-            ty_infer(ref v) => 14u8.iter_bytes(lsb0, f) && v.iter_bytes(lsb0, f),\n-\n-            ty_param(ref p) => 15u8.iter_bytes(lsb0, f) && p.iter_bytes(lsb0, f),\n-\n-            ty_type => 16u8.iter_bytes(lsb0, f),\n-            ty_bot => 17u8.iter_bytes(lsb0, f),\n-\n-            ty_ptr(ref mt) => 18u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_uniq(ref mt) => 19u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n-\n-            ty_trait(ref did, ref substs, ref v, ref mutbl, bounds) => {\n-                20u8.iter_bytes(lsb0, f) &&\n-                did.iter_bytes(lsb0, f) &&\n-                substs.iter_bytes(lsb0, f) &&\n-                v.iter_bytes(lsb0, f) &&\n-                mutbl.iter_bytes(lsb0, f) &&\n-                bounds.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_opaque_closure_ptr(ref ck) => 21u8.iter_bytes(lsb0, f) && ck.iter_bytes(lsb0, f),\n-\n-            ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n-\n-            ty_struct(ref did, ref substs) => {\n-                23u8.iter_bytes(lsb0, f) && did.iter_bytes(lsb0, f) && substs.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_rptr(ref r, ref mt) => {\n-                24u8.iter_bytes(lsb0, f) && r.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f)\n-            }\n-\n-            ty_err => 25u8.iter_bytes(lsb0, f),\n-\n-            ty_closure(ref ct) => 26u8.iter_bytes(lsb0, f) && ct.iter_bytes(lsb0, f),\n-        }\n-    }\n-}\n-\n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,"}, {"sha": "4380711b78e88105ca5b5aa77914f8f576f4c67b", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/89110fdf55c000096fc24a78d35256544c7b523f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89110fdf55c000096fc24a78d35256544c7b523f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=89110fdf55c000096fc24a78d35256544c7b523f", "patch": "@@ -548,43 +548,18 @@ use util::ppaux::note_and_explain_region;\n \n use core::cell::Cell;\n use core::hashmap::{HashMap, HashSet};\n-use core::to_bytes;\n use core::uint;\n use core::vec;\n use syntax::codemap::span;\n use syntax::ast;\n \n-#[deriving(Eq)]\n+#[deriving(Eq,IterBytes)]\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region)\n }\n \n-impl to_bytes::IterBytes for Constraint {\n-   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        match *self {\n-            ConstrainVarSubVar(ref v0, ref v1) => {\n-                0u8.iter_bytes(lsb0, f) &&\n-                v0.iter_bytes(lsb0, f) &&\n-                v1.iter_bytes(lsb0, f)\n-            }\n-\n-            ConstrainRegSubVar(ref ra, ref va) => {\n-                1u8.iter_bytes(lsb0, f) &&\n-                ra.iter_bytes(lsb0, f) &&\n-                va.iter_bytes(lsb0, f)\n-            }\n-\n-            ConstrainVarSubReg(ref va, ref ra) => {\n-                2u8.iter_bytes(lsb0, f) &&\n-                va.iter_bytes(lsb0, f) &&\n-                ra.iter_bytes(lsb0, f)\n-            }\n-        }\n-    }\n-}\n-\n #[deriving(Eq, IterBytes)]\n struct TwoRegions {\n     a: Region,"}]}