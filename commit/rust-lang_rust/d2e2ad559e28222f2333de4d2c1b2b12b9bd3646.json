{"sha": "d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZTJhZDU1OWUyODIyMmYyMzMzZGU0ZDJjMWIyYjEyYjliZDM2NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-13T00:28:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-13T00:28:11Z"}, "message": "Auto merge of #40570 - nikomatsakis:inference-subtype-through-obligation, r=arielb1\n\nHandle subtyping in inference through obligations\n\nWe currently store subtyping relations in the `TypeVariables` structure as a kind of special case. This branch uses normal obligations to propagate subtyping, thus converting our inference variables into normal fallback. It also does a few other things:\n\n- Removes the (unstable, outdated) support for custom type inference fallback.\n    - It's not clear how we want this to work, but we know that we don't want it to work the way it currently does.\n    - The existing support was also just getting in my way.\n- Fixes #30225, which was caused by the trait caching code pretending type variables were normal unification variables, when indeed they were not (but now are).\n\nThere is one fishy part of these changes: when computing the LUB/GLB of a \"bivariant\" type parameter, I currently return the `a` value. Bivariant type parameters are only allowed in a very particular situation, where the type parameter is only used as an associated type output, like this:\n\n```rust\npub struct Foo<A, B>\n    where A: Fn() -> B\n{\n    data: A\n}\n```\n\nIn principle, if one had `T=Foo<A, &'a u32>` and `U=Foo<A, &'b u32>` and (e.g.) `A: for<'a> Fn() -> &'a u32`, then I think that computing the LUB of `T` and `U` might do the wrong thing. Probably the right behavior is just to create a fresh type variable. However, that particular example would not compile (because the where-clause is illegal; `'a` does not appear in any input type). I was not able to make an example that *would* compile and demonstrate this shortcoming, and handling the LUB/GLB was mildly inconvenient, so I left it as is. I am considering whether to revisit this or what.\n\nI have started a crater run to test the impact of these changes.", "tree": {"sha": "afb310b7cdfa693c14f58984ec06d795a5cd45b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afb310b7cdfa693c14f58984ec06d795a5cd45b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "html_url": "https://github.com/rust-lang/rust/commit/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14481f72102ba2abb5f314d5537fee90352981c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/14481f72102ba2abb5f314d5537fee90352981c5", "html_url": "https://github.com/rust-lang/rust/commit/14481f72102ba2abb5f314d5537fee90352981c5"}, {"sha": "1cc7621dec567ded8965fd6c01d80104cfec4d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc7621dec567ded8965fd6c01d80104cfec4d68", "html_url": "https://github.com/rust-lang/rust/commit/1cc7621dec567ded8965fd6c01d80104cfec4d68"}], "stats": {"total": 1642, "additions": 732, "deletions": 910}, "files": [{"sha": "f55462fb5deb636925504c6105ac71869b434d89", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -164,6 +164,7 @@ impl_stable_hash_for!(enum ty::Visibility {\n impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n+impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n impl<'a, 'tcx, A, B> HashStable<StableHashingContext<'a, 'tcx>> for ty::OutlivesPredicate<A, B>\n     where A: HashStable<StableHashingContext<'a, 'tcx>>,\n@@ -194,6 +195,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx\n             ty::Predicate::Equate(ref pred) => {\n                 pred.hash_stable(hcx, hasher);\n             }\n+            ty::Predicate::Subtype(ref pred) => {\n+                pred.hash_stable(hcx, hasher);\n+            }\n             ty::Predicate::RegionOutlives(ref pred) => {\n                 pred.hash_stable(hcx, hasher);\n             }"}, {"sha": "4acb8b807d594efcc0f6b8be67ec1165a93c9a9f", "filename": "src/librustc/infer/bivariate.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Applies the \"bivariance relationship\" to two types and/or regions.\n-//! If (A,B) are bivariant then either A <: B or B <: A. It occurs\n-//! when type/lifetime parameters are unconstrained. Usually this is\n-//! an error, but we permit it in the specific case where a type\n-//! parameter is constrained in a where-clause via an associated type.\n-//!\n-//! There are several ways one could implement bivariance. You could\n-//! just do nothing at all, for example, or you could fully verify\n-//! that one of the two subtyping relationships hold. We choose to\n-//! thread a middle line: we relate types up to regions, but ignore\n-//! all region relationships.\n-//!\n-//! At one point, handling bivariance in this fashion was necessary\n-//! for inference, but I'm actually not sure if that is true anymore.\n-//! In particular, it might be enough to say (A,B) are bivariant for\n-//! all (A,B).\n-\n-use super::combine::CombineFields;\n-use super::type_variable::{BiTo};\n-\n-use ty::{self, Ty, TyCtxt};\n-use ty::TyVar;\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n-\n-pub struct Bivariate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n-    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n-    a_is_expected: bool,\n-}\n-\n-impl<'combine, 'infcx, 'gcx, 'tcx> Bivariate<'combine, 'infcx, 'gcx, 'tcx> {\n-    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n-        -> Bivariate<'combine, 'infcx, 'gcx, 'tcx>\n-    {\n-        Bivariate { fields: fields, a_is_expected: a_is_expected }\n-    }\n-}\n-\n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Bivariate<'combine, 'infcx, 'gcx, 'tcx>\n-{\n-    fn tag(&self) -> &'static str { \"Bivariate\" }\n-\n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n-\n-    fn a_is_expected(&self) -> bool { self.a_is_expected }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n-                                             variance: ty::Variance,\n-                                             a: &T,\n-                                             b: &T)\n-                                             -> RelateResult<'tcx, T>\n-    {\n-        match variance {\n-            // If we have Foo<A> and Foo is invariant w/r/t A,\n-            // and we want to assert that\n-            //\n-            //     Foo<A> <: Foo<B> ||\n-            //     Foo<B> <: Foo<A>\n-            //\n-            // then still A must equal B.\n-            ty::Invariant => self.relate(a, b),\n-\n-            ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.relate(a, b),\n-            ty::Contravariant => self.relate(a, b),\n-        }\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(),\n-               a, b);\n-        if a == b { return Ok(a); }\n-\n-        let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n-        match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n-                infcx.type_variables.borrow_mut().relate_vars(a_id, BiTo, b_id);\n-                Ok(a)\n-            }\n-\n-            (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, BiTo, a_id, self.a_is_expected)?;\n-                Ok(a)\n-            }\n-\n-            (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, BiTo, b_id, self.a_is_expected)?;\n-                Ok(a)\n-            }\n-\n-            _ => {\n-                self.fields.infcx.super_combine_tys(self, a, b)\n-            }\n-        }\n-    }\n-\n-    fn regions(&mut self, a: &'tcx ty::Region, _: &'tcx ty::Region)\n-               -> RelateResult<'tcx, &'tcx ty::Region> {\n-        Ok(a)\n-    }\n-\n-    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n-                  -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        let a1 = self.tcx().erase_late_bound_regions(a);\n-        let b1 = self.tcx().erase_late_bound_regions(b);\n-        let c = self.relate(&a1, &b1)?;\n-        Ok(ty::Binder(c))\n-    }\n-}"}, {"sha": "b73079b02bdd94ab0d050939f8de38716cbcadb7", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 83, "deletions": 100, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -32,14 +32,12 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n-use super::bivariate::Bivariate;\n use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n-use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n@@ -49,7 +47,6 @@ use ty::relate::{RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n use syntax::ast;\n-use syntax::util::small_vector::SmallVector;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n@@ -60,6 +57,11 @@ pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum RelationDir {\n+    SubtypeOf, SupertypeOf, EqTo\n+}\n+\n impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     pub fn super_combine_tys<R>(&self,\n                                 relation: &mut R,\n@@ -159,10 +161,6 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Equate::new(self, a_is_expected)\n     }\n \n-    pub fn bivariate<'a>(&'a mut self, a_is_expected: bool) -> Bivariate<'a, 'infcx, 'gcx, 'tcx> {\n-        Bivariate::new(self, a_is_expected)\n-    }\n-\n     pub fn sub<'a>(&'a mut self, a_is_expected: bool) -> Sub<'a, 'infcx, 'gcx, 'tcx> {\n         Sub::new(self, a_is_expected)\n     }\n@@ -175,108 +173,82 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Glb::new(self, a_is_expected)\n     }\n \n+    /// Here dir is either EqTo, SubtypeOf, or SupertypeOf. The\n+    /// idea is that we should ensure that the type `a_ty` is equal\n+    /// to, a subtype of, or a supertype of (respectively) the type\n+    /// to which `b_vid` is bound.\n+    ///\n+    /// Since `b_vid` has not yet been instantiated with a type, we\n+    /// will first instantiate `b_vid` with a *generalized* version\n+    /// of `a_ty`. Generalization introduces other inference\n+    /// variables wherever subtyping could occur.\n     pub fn instantiate(&mut self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid,\n                        a_is_expected: bool)\n                        -> RelateResult<'tcx, ()>\n     {\n-        // We use SmallVector here instead of Vec because this code is hot and\n-        // it's rare that the stack length exceeds 1.\n-        let mut stack = SmallVector::new();\n-        stack.push((a_ty, dir, b_vid));\n-        loop {\n-            // For each turn of the loop, we extract a tuple\n-            //\n-            //     (a_ty, dir, b_vid)\n-            //\n-            // to relate. Here dir is either SubtypeOf or\n-            // SupertypeOf. The idea is that we should ensure that\n-            // the type `a_ty` is a subtype or supertype (respectively) of the\n-            // type to which `b_vid` is bound.\n-            //\n-            // If `b_vid` has not yet been instantiated with a type\n-            // (which is always true on the first iteration, but not\n-            // necessarily true on later iterations), we will first\n-            // instantiate `b_vid` with a *generalized* version of\n-            // `a_ty`. Generalization introduces other inference\n-            // variables wherever subtyping could occur (at time of\n-            // this writing, this means replacing free regions with\n-            // region variables).\n-            let (a_ty, dir, b_vid) = match stack.pop() {\n-                None => break,\n-                Some(e) => e,\n-            };\n-            // Get the actual variable that b_vid has been inferred to\n-            let (b_vid, b_ty) = {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n-                let b_vid = variables.root_var(b_vid);\n-                (b_vid, variables.probe_root(b_vid))\n-            };\n-\n-            debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\",\n-                   a_ty,\n-                   dir,\n-                   b_vid);\n-\n-            // Check whether `vid` has been instantiated yet.  If not,\n-            // make a generalized form of `ty` and instantiate with\n-            // that.\n-            let b_ty = match b_ty {\n-                Some(t) => t, // ...already instantiated.\n-                None => {     // ...not yet instantiated:\n-                    // Generalize type if necessary.\n-                    let generalized_ty = match dir {\n-                        EqTo => self.generalize(a_ty, b_vid, false),\n-                        BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n-                    }?;\n-                    debug!(\"instantiate(a_ty={:?}, dir={:?}, \\\n-                                        b_vid={:?}, generalized_ty={:?})\",\n-                           a_ty, dir, b_vid,\n-                           generalized_ty);\n-                    self.infcx.type_variables\n-                        .borrow_mut()\n-                        .instantiate_and_push(\n-                            b_vid, generalized_ty, &mut stack);\n-                    generalized_ty\n-                }\n-            };\n-\n-            // The original triple was `(a_ty, dir, b_vid)` -- now we have\n-            // resolved `b_vid` to `b_ty`, so apply `(a_ty, dir, b_ty)`:\n-            //\n-            // FIXME(#16847): This code is non-ideal because all these subtype\n-            // relations wind up attributed to the same spans. We need\n-            // to associate causes/spans with each of the relations in\n-            // the stack to get this right.\n-            match dir {\n-                BiTo => self.bivariate(a_is_expected).relate(&a_ty, &b_ty),\n-                EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n-                SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n-                SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n-                    ty::Contravariant, &a_ty, &b_ty),\n-            }?;\n-        }\n+        use self::RelationDir::*;\n+\n+        // Get the actual variable that b_vid has been inferred to\n+        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_none());\n+\n+        debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n+\n+        // Generalize type of `a_ty` appropriately depending on the\n+        // direction.  As an example, assume:\n+        //\n+        // - `a_ty == &'x ?1`, where `'x` is some free region and `?1` is an\n+        //   inference variable,\n+        // - and `dir` == `SubtypeOf`.\n+        //\n+        // Then the generalized form `b_ty` would be `&'?2 ?3`, where\n+        // `'?2` and `?3` are fresh region/type inference\n+        // variables. (Down below, we will relate `a_ty <: b_ty`,\n+        // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n+        let b_ty = self.generalize(a_ty, b_vid, dir == EqTo)?;\n+        debug!(\"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n+               a_ty, dir, b_vid, b_ty);\n+        self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n+\n+        // Finally, relate `b_ty` to `a_ty`, as described in previous comment.\n+        //\n+        // FIXME(#16847): This code is non-ideal because all these subtype\n+        // relations wind up attributed to the same spans. We need\n+        // to associate causes/spans with each of the relations in\n+        // the stack to get this right.\n+        match dir {\n+            EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n+            SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+            SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+                ty::Contravariant, &a_ty, &b_ty),\n+        }?;\n \n         Ok(())\n     }\n \n-    /// Attempts to generalize `ty` for the type variable `for_vid`.  This checks for cycle -- that\n-    /// is, whether the type `ty` references `for_vid`. If `make_region_vars` is true, it will also\n-    /// replace all regions with fresh variables. Returns `TyError` in the case of a cycle, `Ok`\n+    /// Attempts to generalize `ty` for the type variable `for_vid`.\n+    /// This checks for cycle -- that is, whether the type `ty`\n+    /// references `for_vid`. If `is_eq_relation` is false, it will\n+    /// also replace all regions/unbound-type-variables with fresh\n+    /// variables. Returns `TyError` in the case of a cycle, `Ok`\n     /// otherwise.\n+    ///\n+    /// Preconditions:\n+    ///\n+    /// - `for_vid` is a \"root vid\"\n     fn generalize(&self,\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n-                  make_region_vars: bool)\n+                  is_eq_relation: bool)\n                   -> RelateResult<'tcx, Ty<'tcx>>\n     {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid: for_vid,\n-            make_region_vars: make_region_vars,\n+            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            is_eq_relation: is_eq_relation,\n             cycle_detected: false\n         };\n         let u = ty.fold_with(&mut generalize);\n@@ -291,8 +263,8 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n-    for_vid: ty::TyVid,\n-    make_region_vars: bool,\n+    for_vid_sub_root: ty::TyVid,\n+    is_eq_relation: bool,\n     cycle_detected: bool,\n }\n \n@@ -303,17 +275,17 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         // Check to see whether the type we are genealizing references\n-        // `vid`. At the same time, also update any type variables to\n-        // the values that they are bound to. This is needed to truly\n-        // check for cycles, but also just makes things readable.\n-        //\n-        // (In particular, you could have something like `$0 = Box<$1>`\n-        //  where `$1` has already been instantiated with `Box<$0>`)\n+        // any other type variable related to `vid` via\n+        // subtyping. This is basically our \"occurs check\", preventing\n+        // us from creating infinitely sized types.\n         match t.sty {\n             ty::TyInfer(ty::TyVar(vid)) => {\n                 let mut variables = self.infcx.type_variables.borrow_mut();\n                 let vid = variables.root_var(vid);\n-                if vid == self.for_vid {\n+                let sub_vid = variables.sub_root_var(vid);\n+                if sub_vid == self.for_vid_sub_root {\n+                    // If sub-roots are equal, then `for_vid` and\n+                    // `vid` are related via subtyping.\n                     self.cycle_detected = true;\n                     self.tcx().types.err\n                 } else {\n@@ -322,7 +294,18 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n                             drop(variables);\n                             self.fold_ty(u)\n                         }\n-                        None => t,\n+                        None => {\n+                            if !self.is_eq_relation {\n+                                let origin = variables.origin(vid);\n+                                let new_var_id = variables.new_var(false, origin, None);\n+                                let u = self.tcx().mk_var(new_var_id);\n+                                debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n+                                       vid, u);\n+                                u\n+                            } else {\n+                                t\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -359,7 +342,7 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReFree(..) => {\n-                if !self.make_region_vars {\n+                if self.is_eq_relation {\n                     return r;\n                 }\n             }"}, {"sha": "f620965ced84590e5c1b32d769374248dc66342f", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::CombineFields;\n+use super::combine::{CombineFields, RelationDir};\n use super::{Subtype};\n-use super::type_variable::{EqTo};\n \n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n@@ -58,17 +57,17 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n             (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n-                infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n+                infcx.type_variables.borrow_mut().equate(a_id, b_id);\n                 Ok(a)\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, EqTo, a_id, self.a_is_expected)?;\n+                self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, EqTo, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "72b23a3bc181cc0f1ed060dc7d12c4c9fcc49ef6", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::{self, TyCtxt};\n+use infer::type_variable::TypeVariableMap;\n+use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n \n use super::InferCtxt;\n@@ -54,57 +55,52 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the actual types (`?T`, `Option<?T`) -- and remember that\n     /// after the snapshot is popped, the variable `?T` is no longer\n     /// unified.\n-    ///\n-    /// Assumptions:\n-    /// - no new type variables are created during `f()` (asserted\n-    ///   below); this simplifies our logic since we don't have to\n-    ///   check for escaping type variables\n     pub fn fudge_regions_if_ok<T, E, F>(&self,\n                                         origin: &RegionVariableOrigin,\n                                         f: F) -> Result<T, E> where\n         F: FnOnce() -> Result<T, E>,\n         T: TypeFoldable<'tcx>,\n     {\n-        let (region_vars, value) = self.probe(|snapshot| {\n-            let vars_at_start = self.type_variables.borrow().num_vars();\n+        debug!(\"fudge_regions_if_ok(origin={:?})\", origin);\n \n+        let (type_variables, region_vars, value) = self.probe(|snapshot| {\n             match f() {\n                 Ok(value) => {\n                     let value = self.resolve_type_vars_if_possible(&value);\n \n                     // At this point, `value` could in principle refer\n-                    // to regions that have been created during the\n-                    // snapshot (we assert below that `f()` does not\n-                    // create any new type variables, so there\n-                    // shouldn't be any of those). Once we exit\n-                    // `probe()`, those are going to be popped, so we\n-                    // will have to eliminate any references to them.\n-\n-                    assert_eq!(self.type_variables.borrow().num_vars(), vars_at_start,\n-                               \"type variables were created during fudge_regions_if_ok\");\n+                    // to types/regions that have been created during\n+                    // the snapshot. Once we exit `probe()`, those are\n+                    // going to be popped, so we will have to\n+                    // eliminate any references to them.\n+\n+                    let type_variables =\n+                        self.type_variables.borrow_mut().types_created_since_snapshot(\n+                            &snapshot.type_snapshot);\n                     let region_vars =\n                         self.region_vars.vars_created_since_snapshot(\n                             &snapshot.region_vars_snapshot);\n \n-                    Ok((region_vars, value))\n+                    Ok((type_variables, region_vars, value))\n                 }\n                 Err(e) => Err(e),\n             }\n         })?;\n \n         // At this point, we need to replace any of the now-popped\n-        // region variables that appear in `value` with a fresh region\n-        // variable. We can't do this during the probe because they\n-        // would just get popped then too. =)\n+        // type/region variables that appear in `value` with a fresh\n+        // variable of the appropriate kind. We can't do this during\n+        // the probe because they would just get popped then too. =)\n \n         // Micro-optimization: if no variables have been created, then\n         // `value` can't refer to any of them. =) So we can just return it.\n-        if region_vars.is_empty() {\n+        if type_variables.is_empty() && region_vars.is_empty() {\n             return Ok(value);\n         }\n \n         let mut fudger = RegionFudger {\n             infcx: self,\n+            type_variables: &type_variables,\n             region_vars: &region_vars,\n             origin: origin\n         };\n@@ -115,6 +111,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n pub struct RegionFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    type_variables: &'a TypeVariableMap,\n     region_vars: &'a Vec<ty::RegionVid>,\n     origin: &'a RegionVariableOrigin,\n }\n@@ -124,6 +121,32 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::TyInfer(ty::InferTy::TyVar(vid)) => {\n+                match self.type_variables.get(&vid) {\n+                    None => {\n+                        // This variable was created before the\n+                        // \"fudging\".  Since we refresh all type\n+                        // variables to their binding anyhow, we know\n+                        // that it is unbound, so we can just return\n+                        // it.\n+                        debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_none());\n+                        ty\n+                    }\n+\n+                    Some(&origin) => {\n+                        // This variable was created during the\n+                        // fudging. Recreate it with a fresh variable\n+                        // here.\n+                        self.infcx.next_ty_var(origin)\n+                    }\n+                }\n+            }\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n     fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         match *r {\n             ty::ReVar(v) if self.region_vars.contains(&v) => {"}, {"sha": "a6dd18c113f1af57b886a0cbb6ed72f4e040c930", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -49,7 +49,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            // FIXME(#41044) -- not correct, need test\n+            ty::Bivariant => Ok(a.clone()),\n             ty::Contravariant => self.fields.lub(self.a_is_expected).relate(a, b),\n         }\n     }"}, {"sha": "d4d090f0153d015b5b779dabf724dd4bfbf18d57", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -44,6 +44,10 @@ pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx>\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n+    //\n+    // Subtle hack: ordering *may* be significant here. This method\n+    // relates `v` to `a` first, which may help us to avoid unecessary\n+    // type variable obligations. See caller for details.\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n@@ -74,7 +78,29 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n             Ok(v)\n         }\n \n-        (&ty::TyInfer(TyVar(..)), _) |\n+        // If one side is known to be a variable and one is not,\n+        // create a variable (`v`) to represent the LUB. Make sure to\n+        // relate `v` to the non-type-variable first (by passing it\n+        // first to `relate_bound`). Otherwise, we would produce a\n+        // subtype obligation that must then be processed.\n+        //\n+        // Example: if the LHS is a type variable, and RHS is\n+        // `Box<i32>`, then we current compare `v` to the RHS first,\n+        // which will instantiate `v` with `Box<i32>`.  Then when `v`\n+        // is compared to the LHS, we instantiate LHS with `Box<i32>`.\n+        // But if we did in reverse order, we would create a `v <:\n+        // LHS` (or vice versa) constraint and then instantiate\n+        // `v`. This would require further processing to achieve same\n+        // end-result; in partiular, this screws up some of the logic\n+        // in coercion, which expects LUB to figure out that the LHS\n+        // is (e.g.) `Box<i32>`. A more obvious solution might be to\n+        // iterate on the subtype obligations that are returned, but I\n+        // think this suffices. -nmatsakis\n+        (&ty::TyInfer(TyVar(..)), _) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+            this.relate_bound(v, b, a)?;\n+            Ok(v)\n+        }\n         (_, &ty::TyInfer(TyVar(..))) => {\n             let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;"}, {"sha": "d7e5c92b6e17b20e6882c8c23f9da025ab8e9e41", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -49,7 +49,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            // FIXME(#41044) -- not correct, need test\n+            ty::Bivariant => Ok(a.clone()),\n             ty::Contravariant => self.fields.glb(self.a_is_expected).relate(a, b),\n         }\n     }"}, {"sha": "e98792b120de284c332e144571439a39a69e11af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -48,7 +48,6 @@ use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n-mod bivariate;\n mod combine;\n mod equate;\n pub mod error_reporting;\n@@ -552,7 +551,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n }\n \n impl<T> ExpectedFound<T> {\n-    fn new(a_is_expected: bool, a: T, b: T) -> Self {\n+    pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n         if a_is_expected {\n             ExpectedFound {expected: a, found: b}\n         } else {\n@@ -1037,9 +1036,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             let origin = &ObligationCause::dummy();\n             let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, &a, &b).map(|InferOk { obligations, .. }| {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+            self.sub(true, trace, &a, &b).map(|InferOk { obligations: _, .. }| {\n+                // Ignore obligations, since we are unrolling\n+                // everything anyway.\n             })\n         })\n     }\n@@ -1130,6 +1129,43 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    pub fn subtype_predicate(&self,\n+                             cause: &ObligationCause<'tcx>,\n+                             predicate: &ty::PolySubtypePredicate<'tcx>)\n+        -> Option<InferResult<'tcx, ()>>\n+    {\n+        // Subtle: it's ok to skip the binder here and resolve because\n+        // `shallow_resolve` just ignores anything that is not a type\n+        // variable, and because type variable's can't (at present, at\n+        // least) capture any of the things bound by this binder.\n+        //\n+        // Really, there is no *particular* reason to do this\n+        // `shallow_resolve` here except as a\n+        // micro-optimization. Naturally I could not\n+        // resist. -nmatsakis\n+        let two_unbound_type_vars = {\n+            let a = self.shallow_resolve(predicate.skip_binder().a);\n+            let b = self.shallow_resolve(predicate.skip_binder().b);\n+            a.is_ty_var() && b.is_ty_var()\n+        };\n+\n+        if two_unbound_type_vars {\n+            // Two unbound type variables? Can't make progress.\n+            return None;\n+        }\n+\n+        Some(self.commit_if_ok(|snapshot| {\n+            let (ty::SubtypePredicate { a_is_expected, a, b}, skol_map) =\n+                self.skolemize_late_bound_regions(predicate, snapshot);\n+\n+            let cause_span = cause.span;\n+            let ok = self.sub_types(a_is_expected, cause, a, b)?;\n+            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n+            self.pop_skolemized(skol_map, snapshot);\n+            Ok(ok.unit())\n+        }))\n+    }\n+\n     pub fn region_outlives_predicate(&self,\n                                      cause: &traits::ObligationCause<'tcx>,\n                                      predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)"}, {"sha": "2a7dbbc026bc0bda28f84ce3236871ee60b4497a", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use super::SubregionOrigin;\n-use super::combine::CombineFields;\n-use super::type_variable::{SubtypeOf, SupertypeOf};\n+use super::combine::{CombineFields, RelationDir};\n \n+use traits::Obligation;\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n+use ty::fold::TypeFoldable;\n use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n@@ -65,7 +66,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Bivariant => Ok(a.clone()),\n             ty::Contravariant => self.with_expected_switched(|this| { this.relate(b, a) }),\n         }\n     }\n@@ -79,19 +80,38 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n-                infcx.type_variables\n-                    .borrow_mut()\n-                    .relate_vars(a_id, SubtypeOf, b_id);\n+            (&ty::TyInfer(TyVar(a_vid)), &ty::TyInfer(TyVar(b_vid))) => {\n+                // Shouldn't have any LBR here, so we can safely put\n+                // this under a binder below without fear of accidental\n+                // capture.\n+                assert!(!a.has_escaping_regions());\n+                assert!(!b.has_escaping_regions());\n+\n+                // can't make progress on `A <: B` if both A and B are\n+                // type variables, so record an obligation. We also\n+                // have to record in the `type_variables` tracker that\n+                // the two variables are equal modulo subtyping, which\n+                // is important to the occurs check later on.\n+                infcx.type_variables.borrow_mut().sub(a_vid, b_vid);\n+                self.fields.obligations.push(\n+                    Obligation::new(\n+                        self.fields.trace.cause.clone(),\n+                        ty::Predicate::Subtype(\n+                            ty::Binder(ty::SubtypePredicate {\n+                                a_is_expected: self.a_is_expected,\n+                                a,\n+                                b,\n+                            }))));\n+\n                 Ok(a)\n             }\n             (&ty::TyInfer(TyVar(a_id)), _) => {\n                 self.fields\n-                    .instantiate(b, SupertypeOf, a_id, !self.a_is_expected)?;\n+                    .instantiate(b, RelationDir::SupertypeOf, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, SubtypeOf, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, RelationDir::SubtypeOf, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "4ae2a8026409d3fcd4082562c4f8d850041da957", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 127, "deletions": 120, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n-use self::UndoEntry::*;\n use hir::def_id::{DefId};\n-use syntax::util::small_vector::SmallVector;\n use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n@@ -21,16 +18,39 @@ use std::cmp::min;\n use std::marker::PhantomData;\n use std::mem;\n use std::u32;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n     values: sv::SnapshotVec<Delegate<'tcx>>,\n+\n+    /// Two variables are unified in `eq_relations` when we have a\n+    /// constraint `?X == ?Y`.\n     eq_relations: ut::UnificationTable<ty::TyVid>,\n+\n+    /// Two variables are unified in `eq_relations` when we have a\n+    /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n+    /// table exists only to help with the occurs check. In particular,\n+    /// we want to report constraints like these as an occurs check\n+    /// violation:\n+    ///\n+    ///     ?1 <: ?3\n+    ///     Box<?3> <: ?1\n+    ///\n+    /// This works because `?1` and `?3` are unified in the\n+    /// `sub_relations` relation (not in `eq_relations`). Then when we\n+    /// process the `Box<?3> <: ?1` constraint, we do an occurs check\n+    /// on `Box<?3>` and find a potential cycle.\n+    ///\n+    /// This is reasonable because, in Rust, subtypes have the same\n+    /// \"skeleton\" and hence there is no possible type such that\n+    /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n+    sub_relations: ut::UnificationTable<ty::TyVid>,\n }\n \n /// Reasons to create a type inference variable\n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum TypeVariableOrigin {\n     MiscVariable(Span),\n     NormalizeProjectionType(Span),\n@@ -44,8 +64,11 @@ pub enum TypeVariableOrigin {\n     DivergingBlockExpr(Span),\n     DivergingFn(Span),\n     LatticeVariable(Span),\n+    Generalized(ty::TyVid),\n }\n \n+pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableOrigin>;\n+\n struct TypeVariableData<'tcx> {\n     value: TypeVariableValue<'tcx>,\n     origin: TypeVariableOrigin,\n@@ -55,7 +78,6 @@ struct TypeVariableData<'tcx> {\n enum TypeVariableValue<'tcx> {\n     Known(Ty<'tcx>),\n     Bounded {\n-        relations: Vec<Relation>,\n         default: Option<Default<'tcx>>\n     }\n }\n@@ -74,47 +96,25 @@ pub struct Default<'tcx> {\n pub struct Snapshot {\n     snapshot: sv::Snapshot,\n     eq_snapshot: ut::Snapshot<ty::TyVid>,\n+    sub_snapshot: ut::Snapshot<ty::TyVid>,\n }\n \n-enum UndoEntry<'tcx> {\n-    // The type of the var was specified.\n-    SpecifyVar(ty::TyVid, Vec<Relation>, Option<Default<'tcx>>),\n-    Relate(ty::TyVid, ty::TyVid),\n-    RelateRange(ty::TyVid, usize),\n+struct Instantiate<'tcx> {\n+    vid: ty::TyVid,\n+    default: Option<Default<'tcx>>,\n }\n \n struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n \n-type Relation = (RelationDir, ty::TyVid);\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n-pub enum RelationDir {\n-    SubtypeOf, SupertypeOf, EqTo, BiTo\n-}\n-\n-impl RelationDir {\n-    fn opposite(self) -> RelationDir {\n-        match self {\n-            SubtypeOf => SupertypeOf,\n-            SupertypeOf => SubtypeOf,\n-            EqTo => EqTo,\n-            BiTo => BiTo,\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable {\n             values: sv::SnapshotVec::new(),\n             eq_relations: ut::UnificationTable::new(),\n+            sub_relations: ut::UnificationTable::new(),\n         }\n     }\n \n-    fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n-        relations(self.values.get_mut(a.index as usize))\n-    }\n-\n     pub fn default(&self, vid: ty::TyVid) -> Option<Default<'tcx>> {\n         match &self.values.get(vid.index as usize).value {\n             &Known(_) => None,\n@@ -130,68 +130,46 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         &self.values.get(vid.index as usize).origin\n     }\n \n-    /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n+    /// Records that `a == b`, depending on `dir`.\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n-    pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n-        let a = self.root_var(a);\n-        let b = self.root_var(b);\n-        if a != b {\n-            if dir == EqTo {\n-                // a and b must be equal which we mark in the unification table\n-                let root = self.eq_relations.union(a, b);\n-                // In addition to being equal, all relations from the variable which is no longer\n-                // the root must be added to the root so they are not forgotten as the other\n-                // variable should no longer be referenced (other than to get the root)\n-                let other = if a == root { b } else { a };\n-                let count = {\n-                    let (relations, root_relations) = if other.index < root.index {\n-                        let (pre, post) = self.values.split_at_mut(root.index as usize);\n-                        (relations(&mut pre[other.index as usize]), relations(&mut post[0]))\n-                    } else {\n-                        let (pre, post) = self.values.split_at_mut(other.index as usize);\n-                        (relations(&mut post[0]), relations(&mut pre[root.index as usize]))\n-                    };\n-                    root_relations.extend_from_slice(relations);\n-                    relations.len()\n-                };\n-                self.values.record(RelateRange(root, count));\n-            } else {\n-                self.relations(a).push((dir, b));\n-                self.relations(b).push((dir.opposite(), a));\n-                self.values.record(Relate(a, b));\n-            }\n-        }\n+    pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n+        debug_assert!(self.probe(a).is_none());\n+        debug_assert!(self.probe(b).is_none());\n+        self.eq_relations.union(a, b);\n+        self.sub_relations.union(a, b);\n     }\n \n-    /// Instantiates `vid` with the type `ty` and then pushes an entry onto `stack` for each of the\n-    /// relations of `vid` to other variables. The relations will have the form `(ty, dir, vid1)`\n-    /// where `vid1` is some other variable id.\n+    /// Records that `a <: b`, depending on `dir`.\n     ///\n-    /// Precondition: `vid` must be a root in the unification table\n-    pub fn instantiate_and_push(\n-        &mut self,\n-        vid: ty::TyVid,\n-        ty: Ty<'tcx>,\n-        stack: &mut SmallVector<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n-    {\n-        debug_assert!(self.root_var(vid) == vid);\n-        let old_value = {\n-            let value_ptr = &mut self.values.get_mut(vid.index as usize).value;\n-            mem::replace(value_ptr, Known(ty))\n-        };\n+    /// Precondition: neither `a` nor `b` are known.\n+    pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n+        debug_assert!(self.probe(a).is_none());\n+        debug_assert!(self.probe(b).is_none());\n+        self.sub_relations.union(a, b);\n+    }\n+\n+    /// Instantiates `vid` with the type `ty`.\n+    ///\n+    /// Precondition: `vid` must not have been previously instantiated.\n+    pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n+        let vid = self.root_var(vid);\n+        debug_assert!(self.probe_root(vid).is_none());\n \n-        let (relations, default) = match old_value {\n-            Bounded { relations, default } => (relations, default),\n-            Known(_) => bug!(\"Asked to instantiate variable that is \\\n-                              already instantiated\")\n+        let old_value = {\n+            let vid_data = &mut self.values[vid.index as usize];\n+            mem::replace(&mut vid_data.value, TypeVariableValue::Known(ty))\n         };\n \n-        for &(dir, vid) in &relations {\n-            stack.push((ty, dir, vid));\n+        match old_value {\n+            TypeVariableValue::Bounded { default } => {\n+                self.values.record(Instantiate { vid: vid, default: default });\n+            }\n+            TypeVariableValue::Known(old_ty) => {\n+                bug!(\"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n+                     vid, ty, old_ty)\n+            }\n         }\n-\n-        self.values.record(SpecifyVar(vid, relations, default));\n     }\n \n     pub fn new_var(&mut self,\n@@ -200,8 +178,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                    default: Option<Default<'tcx>>,) -> ty::TyVid {\n         debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n         self.eq_relations.new_key(());\n+        self.sub_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n-            value: Bounded { relations: vec![], default: default },\n+            value: Bounded { default: default },\n             origin: origin,\n             diverging: diverging\n         });\n@@ -214,15 +193,41 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.values.len()\n     }\n \n+    /// Returns the \"root\" variable of `vid` in the `eq_relations`\n+    /// equivalence table. All type variables that have been equated\n+    /// will yield the same root variable (per the union-find\n+    /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n+    /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n         self.eq_relations.find(vid)\n     }\n \n+    /// Returns the \"root\" variable of `vid` in the `sub_relations`\n+    /// equivalence table. All type variables that have been are\n+    /// related via equality or subtyping will yield the same root\n+    /// variable (per the union-find algorithm), so `sub_root_var(a)\n+    /// == sub_root_var(b)` implies that:\n+    ///\n+    ///     exists X. (a <: X || X <: a) && (b <: X || X <: b)\n+    pub fn sub_root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n+        self.sub_relations.find(vid)\n+    }\n+\n+    /// True if `a` and `b` have same \"sub-root\" (i.e., exists some\n+    /// type X such that `forall i in {a, b}. (i <: X || X <: i)`.\n+    pub fn sub_unified(&mut self, a: ty::TyVid, b: ty::TyVid) -> bool {\n+        self.sub_root_var(a) == self.sub_root_var(b)\n+    }\n+\n     pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         let vid = self.root_var(vid);\n         self.probe_root(vid)\n     }\n \n+    pub fn origin(&self, vid: ty::TyVid) -> TypeVariableOrigin {\n+        self.values.get(vid.index as usize).origin.clone()\n+    }\n+\n     /// Retrieves the type of `vid` given that it is currently a root in the unification table\n     pub fn probe_root(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         debug_assert!(self.root_var(vid) == vid);\n@@ -248,6 +253,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         Snapshot {\n             snapshot: self.values.start_snapshot(),\n             eq_snapshot: self.eq_relations.snapshot(),\n+            sub_snapshot: self.sub_relations.snapshot(),\n         }\n     }\n \n@@ -263,13 +269,37 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             }\n         });\n \n-        self.values.rollback_to(s.snapshot);\n-        self.eq_relations.rollback_to(s.eq_snapshot);\n+        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n+        self.values.rollback_to(snapshot);\n+        self.eq_relations.rollback_to(eq_snapshot);\n+        self.sub_relations.rollback_to(sub_snapshot);\n     }\n \n     pub fn commit(&mut self, s: Snapshot) {\n-        self.values.commit(s.snapshot);\n-        self.eq_relations.commit(s.eq_snapshot);\n+        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n+        self.values.commit(snapshot);\n+        self.eq_relations.commit(eq_snapshot);\n+        self.sub_relations.commit(sub_snapshot);\n+    }\n+\n+    /// Returns a map `{V1 -> V2}`, where the keys `{V1}` are\n+    /// ty-variables created during the snapshot, and the values\n+    /// `{V2}` are the root variables that they were unified with,\n+    /// along with their origin.\n+    pub fn types_created_since_snapshot(&mut self, s: &Snapshot) -> TypeVariableMap {\n+        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+\n+        actions_since_snapshot\n+            .iter()\n+            .filter_map(|action| match action {\n+                &sv::UndoLog::NewElem(index) => Some(ty::TyVid { index: index as u32 }),\n+                _ => None,\n+            })\n+            .map(|vid| {\n+                let origin = self.values.get(vid.index as usize).origin.clone();\n+                (vid, origin)\n+            })\n+            .collect()\n     }\n \n     pub fn types_escaping_snapshot(&mut self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n@@ -298,7 +328,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(SpecifyVar(vid, ..)) => {\n+                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n@@ -334,35 +364,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n     type Value = TypeVariableData<'tcx>;\n-    type Undo = UndoEntry<'tcx>;\n-\n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry<'tcx>) {\n-        match action {\n-            SpecifyVar(vid, relations, default) => {\n-                values[vid.index as usize].value = Bounded {\n-                    relations: relations,\n-                    default: default\n-                };\n-            }\n+    type Undo = Instantiate<'tcx>;\n \n-            Relate(a, b) => {\n-                relations(&mut (*values)[a.index as usize]).pop();\n-                relations(&mut (*values)[b.index as usize]).pop();\n-            }\n-\n-            RelateRange(i, n) => {\n-                let relations = relations(&mut (*values)[i.index as usize]);\n-                for _ in 0..n {\n-                    relations.pop();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n-    match v.value {\n-        Known(_) => bug!(\"var_sub_var: variable is known\"),\n-        Bounded { ref mut relations, .. } => relations\n+    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: Instantiate<'tcx>) {\n+        let Instantiate { vid, default } = action;\n+        values[vid.index as usize].value = Bounded {\n+            default: default\n+        };\n     }\n }"}, {"sha": "e5a6930fefd228ad690bbe71b889a93b0c3708ec", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -32,6 +32,7 @@\n #![feature(i128_type)]\n #![feature(libc)]\n #![feature(loop_break_value)]\n+#![feature(never_type)]\n #![feature(nonzero)]\n #![cfg_attr(stage0, feature(pub_restricted))]\n #![feature(quote)]"}, {"sha": "2bfa8dec0bfc78a48bc75582108836fbde00c010", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -60,6 +60,7 @@ impl FreeRegionMap {\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Equate(..) |\n+                ty::Predicate::Subtype(..) |\n                 ty::Predicate::WellFormed(..) |\n                 ty::Predicate::ObjectSafe(..) |\n                 ty::Predicate::ClosureKind(..) |"}, {"sha": "f7a7d0e2071f210287dc4b4b6c575866146e1f21", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -39,6 +39,7 @@ use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n+use ty::SubtypePredicate;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n use syntax_pos::{DUMMY_SP, Span};\n@@ -68,6 +69,19 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     found_pattern: Option<&'a Pat>,\n }\n \n+impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn is_match(&self, ty: Ty<'tcx>) -> bool {\n+        ty == *self.target_ty || match (&ty.sty, &self.target_ty.sty) {\n+            (&ty::TyInfer(ty::TyVar(a_vid)), &ty::TyInfer(ty::TyVar(b_vid))) =>\n+                self.infcx.type_variables\n+                          .borrow_mut()\n+                          .sub_unified(a_vid, b_vid),\n+\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> Visitor<'a> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'a> {\n         NestedVisitorMap::None\n@@ -76,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'a> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     fn visit_local(&mut self, local: &'a Local) {\n         if let Some(&ty) = self.infcx.tables.borrow().node_types.get(&local.id) {\n             let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n-            let is_match = ty.walk().any(|t| t == *self.target_ty);\n+            let is_match = ty.walk().any(|t| self.is_match(t));\n \n             if is_match && self.found_pattern.is_none() {\n                 self.found_pattern = Some(&*local.pat);\n@@ -112,6 +126,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             FulfillmentErrorCode::CodeAmbiguity => {\n                 self.maybe_report_ambiguity(&error.obligation);\n             }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(&error.obligation.cause,\n+                                             expected_found.expected,\n+                                             expected_found.found,\n+                                             err.clone())\n+                    .emit();\n+            }\n         }\n     }\n \n@@ -555,6 +576,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         err\n                     }\n \n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n                     ty::Predicate::Equate(ref predicate) => {\n                         let predicate = self.resolve_type_vars_if_possible(predicate);\n                         let err = self.equality_predicate(&obligation.cause,\n@@ -761,6 +789,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            ty::Predicate::Subtype(ref data) => {\n+                if data.references_error() || self.tcx.sess.has_errors() {\n+                    // no need to overload user in such cases\n+                } else {\n+                    let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                    // both must be type variables, or the other would've been instantiated\n+                    assert!(a.is_ty_var() && b.is_ty_var());\n+                    self.need_type_info(obligation, a);\n+                }\n+            }\n+\n             _ => {\n                 if !self.tcx.sess.has_errors() {\n                     let mut err = struct_span_err!(self.tcx.sess,"}, {"sha": "64453f2983b92f03b6a86ae8444f2474630a052c", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -11,6 +11,7 @@\n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n+use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n@@ -496,6 +497,26 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 s => Ok(s)\n             }\n         }\n+\n+        ty::Predicate::Subtype(ref subtype) => {\n+            match selcx.infcx().subtype_predicate(&obligation.cause, subtype) {\n+                None => {\n+                    // none means that both are unresolved\n+                    pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n+                                                         subtype.skip_binder().b];\n+                    Ok(None)\n+                }\n+                Some(Ok(ok)) => {\n+                    Ok(Some(ok.obligations))\n+                }\n+                Some(Err(err)) => {\n+                    let expected_found = ExpectedFound::new(subtype.skip_binder().a_is_expected,\n+                                                            subtype.skip_binder().a,\n+                                                            subtype.skip_binder().b);\n+                    Err(FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "ea243d65881ea23b2f2e0e0a2a587427839c9e70", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -20,7 +20,8 @@ use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n-use infer::InferCtxt;\n+use ty::error::{ExpectedFound, TypeError};\n+use infer::{InferCtxt};\n \n use std::rc::Rc;\n use syntax::ast;\n@@ -214,6 +215,8 @@ pub struct FulfillmentError<'tcx> {\n pub enum FulfillmentErrorCode<'tcx> {\n     CodeSelectionError(SelectionError<'tcx>),\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n+    CodeSubtypeError(ExpectedFound<Ty<'tcx>>,\n+                     TypeError<'tcx>), // always comes from a SubtypePredicate\n     CodeAmbiguity,\n }\n "}, {"sha": "d190635bec3063ce3c0e8193fba6cde6942e0800", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -178,6 +178,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::TypeOutlives(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::Subtype(..) |\n                     ty::Predicate::Equate(..) => {\n                         false\n                     }\n@@ -209,6 +210,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |"}, {"sha": "67d50210ba39adb94a909c475424607ba445f5d4", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -568,6 +568,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n+            ty::Predicate::Subtype(ref p) => {\n+                // does this code ever run?\n+                match self.infcx.subtype_predicate(&obligation.cause, p) {\n+                    Some(Ok(InferOk { obligations, .. })) => {\n+                        self.inferred_obligations.extend(obligations);\n+                        EvaluatedToOk\n+                    },\n+                    Some(Err(_)) => EvaluatedToErr,\n+                    None => EvaluatedToAmbig,\n+                }\n+            }\n+\n             ty::Predicate::WellFormed(ty) => {\n                 match ty::wf::obligations(self.infcx, obligation.cause.body_id,\n                                           ty, obligation.cause.span) {"}, {"sha": "9d0b1035ade497076f6c76cb116da4dbc36317d3", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -130,6 +130,8 @@ impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n             super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeSubtypeError(ref a, ref b) =>\n+                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b),\n             super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }"}, {"sha": "d4245ec9b2475aa79fa033e16a1de9d874bd5ff8", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -42,7 +42,10 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             ty::Predicate::ObjectSafe(data),\n \n         ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-            ty::Predicate::ClosureKind(closure_def_id, kind)\n+            ty::Predicate::ClosureKind(closure_def_id, kind),\n+\n+        ty::Predicate::Subtype(ref data) =>\n+            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data)),\n     }\n }\n \n@@ -160,6 +163,10 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // `X == Y`, though conceivably we might. For example,\n                 // `&X == &Y` implies that `X == Y`.\n             }\n+            ty::Predicate::Subtype(..) => {\n+                // Currently, we do not \"elaborate\" predicates like `X\n+                // <: Y`, though conceivably we might.\n+            }\n             ty::Predicate::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }"}, {"sha": "8ff91583d0822f7ba57365e9d62b0023e1fe0b64", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -772,6 +772,9 @@ pub enum Predicate<'tcx> {\n     /// for some substitutions `...` and T being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureKind),\n+\n+    /// `T1 <: T2`\n+    Subtype(PolySubtypePredicate<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n@@ -850,6 +853,8 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n                 Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n             Predicate::Equate(ty::Binder(ref data)) =>\n                 Predicate::Equate(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Subtype(ty::Binder(ref data)) =>\n+                Predicate::Subtype(ty::Binder(data.subst(tcx, substs))),\n             Predicate::RegionOutlives(ty::Binder(ref data)) =>\n                 Predicate::RegionOutlives(ty::Binder(data.subst(tcx, substs))),\n             Predicate::TypeOutlives(ty::Binder(ref data)) =>\n@@ -929,6 +934,14 @@ pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Reg\n                                                                    &'tcx ty::Region>;\n pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>;\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct SubtypePredicate<'tcx> {\n+    pub a_is_expected: bool,\n+    pub a: Ty<'tcx>,\n+    pub b: Ty<'tcx>\n+}\n+pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n+\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n@@ -1042,6 +1055,9 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::Equate(ty::Binder(ref data)) => {\n                 vec![data.0, data.1]\n             }\n+            ty::Predicate::Subtype(ty::Binder(SubtypePredicate { a, b, a_is_expected: _ })) => {\n+                vec![a, b]\n+            }\n             ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n                 vec![data.0]\n             }\n@@ -1078,6 +1094,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n             Predicate::Projection(..) |\n             Predicate::Equate(..) |\n+            Predicate::Subtype(..) |\n             Predicate::RegionOutlives(..) |\n             Predicate::WellFormed(..) |\n             Predicate::ObjectSafe(..) |"}, {"sha": "a4466d7d840110f450a7b4e8e959164da13402c3", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -111,6 +111,18 @@ impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n+    type Lifted = ty::SubtypePredicate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::SubtypePredicate<'tcx>> {\n+        tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n+            a_is_expected: self.a_is_expected,\n+            a: a,\n+            b: b,\n+        })\n+    }\n+}\n+\n impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -167,6 +179,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::Equate(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::Equate)\n             }\n+            ty::Predicate::Subtype(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Subtype)\n+            }\n             ty::Predicate::RegionOutlives(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::RegionOutlives)\n             }\n@@ -693,6 +708,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::Trait(a.fold_with(folder)),\n             ty::Predicate::Equate(ref binder) =>\n                 ty::Predicate::Equate(binder.fold_with(folder)),\n+            ty::Predicate::Subtype(ref binder) =>\n+                ty::Predicate::Subtype(binder.fold_with(folder)),\n             ty::Predicate::RegionOutlives(ref binder) =>\n                 ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n             ty::Predicate::TypeOutlives(ref binder) =>\n@@ -712,6 +729,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n             ty::Predicate::Equate(ref binder) => binder.visit_with(visitor),\n+            ty::Predicate::Subtype(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::Projection(ref binder) => binder.visit_with(visitor),\n@@ -776,15 +794,28 @@ impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::EquatePredicate(self.0.fold_with(folder),\n-                            self.1.fold_with(folder))\n+        ty::EquatePredicate(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.0.visit_with(visitor) || self.1.visit_with(visitor)\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::SubtypePredicate<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::SubtypePredicate {\n+            a_is_expected: self.a_is_expected,\n+            a: self.a.fold_with(folder),\n+            b: self.b.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.a.visit_with(visitor) || self.b.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitPredicate {"}, {"sha": "5334ee2835db2325f6bcbf4066069efb6ad7c1a9", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -328,6 +328,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |"}, {"sha": "0b0e8a180cc36800c103ed87ead051ed584c8d0b", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -94,6 +94,10 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         }\n         ty::Predicate::ClosureKind(..) => {\n         }\n+        ty::Predicate::Subtype(ref data) => {\n+            wf.compute(data.skip_binder().a); // (*)\n+            wf.compute(data.skip_binder().b); // (*)\n+        }\n     }\n \n     wf.normalize()\n@@ -156,6 +160,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n                 match obligation.predicate {\n                     ty::Predicate::Trait(..) |\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::ClosureKind(..) |\n                     ty::Predicate::ObjectSafe(..) =>"}, {"sha": "2daf71d95addf67c547871de9fb3e99a56475aea", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -416,6 +416,7 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n             ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::Subtype(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n             ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n@@ -676,6 +677,12 @@ impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n     }\n }\n \n+impl<'tcx> fmt::Display for ty::Binder<ty::SubtypePredicate<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n@@ -897,6 +904,12 @@ impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for ty::SubtypePredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{} <: {}\", self.a, self.b)\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TraitPredicate({:?})\",\n@@ -949,6 +962,7 @@ impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n             ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n+            ty::Predicate::Subtype(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n             ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),"}, {"sha": "3515e5c5ede35a3f9c67fc4692aa33544527f787", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -43,7 +43,16 @@ pub trait ObligationProcessor {\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n \n-    fn process_backedge<'c, I>(&mut self, cycle: I,\n+    /// As we do the cycle check, we invoke this callback when we\n+    /// encounter an actual cycle. `cycle` is an iterator that starts\n+    /// at the start of the cycle in the stack and walks **toward the\n+    /// top**.\n+    ///\n+    /// In other words, if we had O1 which required O2 which required\n+    /// O3 which required O1, we would give an iterator yielding O1,\n+    /// O2, O3 (O1 is not yielded twice).\n+    fn process_backedge<'c, I>(&mut self,\n+                               cycle: I,\n                                _marker: PhantomData<&'c Self::Obligation>)\n         where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n@@ -239,8 +248,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n             }\n             Entry::Vacant(v) => {\n-                debug!(\"register_obligation_at({:?}, {:?}) - ok\",\n-                       obligation, parent);\n+                debug!(\"register_obligation_at({:?}, {:?}) - ok, new index is {}\",\n+                       obligation, parent, self.nodes.len());\n                 v.insert(NodeIndex::new(self.nodes.len()));\n                 self.cache_list.push(obligation.as_predicate().clone());\n                 self.nodes.push(Node::new(parent, obligation));\n@@ -376,6 +385,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let mut stack = self.scratch.take().unwrap();\n+        debug_assert!(stack.is_empty());\n+\n+        debug!(\"process_cycles()\");\n \n         for index in 0..self.nodes.len() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n@@ -389,6 +401,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n             }\n         }\n \n+        debug!(\"process_cycles: complete\");\n+\n+        debug_assert!(stack.is_empty());\n         self.scratch = Some(stack);\n     }\n \n@@ -402,21 +417,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n             NodeState::OnDfsStack => {\n                 let index =\n                     stack.iter().rposition(|n| *n == index).unwrap();\n-                // I need a Clone closure\n-                #[derive(Clone)]\n-                struct GetObligation<'a, O: 'a>(&'a [Node<O>]);\n-                impl<'a, 'b, O> FnOnce<(&'b usize,)> for GetObligation<'a, O> {\n-                    type Output = &'a O;\n-                    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> &'a O {\n-                        &self.0[*args.0].obligation\n-                    }\n-                }\n-                impl<'a, 'b, O> FnMut<(&'b usize,)> for GetObligation<'a, O> {\n-                    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> &'a O {\n-                        &self.0[*args.0].obligation\n-                    }\n-                }\n-\n                 processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n@@ -645,3 +645,20 @@ impl<O> Node<O> {\n         }\n     }\n }\n+\n+// I need a Clone closure\n+#[derive(Clone)]\n+struct GetObligation<'a, O: 'a>(&'a [Node<O>]);\n+\n+impl<'a, 'b, O> FnOnce<(&'b usize,)> for GetObligation<'a, O> {\n+    type Output = &'a O;\n+    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> &'a O {\n+        &self.0[*args.0].obligation\n+    }\n+}\n+\n+impl<'a, 'b, O> FnMut<(&'b usize,)> for GetObligation<'a, O> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> &'a O {\n+        &self.0[*args.0].obligation\n+    }\n+}"}, {"sha": "78176b155691cef23cbc783376890d8837101c99", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -169,6 +169,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),\n                     ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n                     ty::Predicate::Equate(..) => None,\n+                    ty::Predicate::Subtype(..) => None,\n                     ty::Predicate::RegionOutlives(..) => None,\n                     ty::Predicate::TypeOutlives(..) => None,\n                     ty::Predicate::WellFormed(..) => None,"}, {"sha": "2033eaf886166fc2debabb63dea4d4dc385fd247", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -195,8 +195,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Consider coercing the subtype to a DST\n         let unsize = self.coerce_unsized(a, b);\n         if unsize.is_ok() {\n+            debug!(\"coerce: unsize successful\");\n             return unsize;\n         }\n+        debug!(\"coerce: unsize failed\");\n \n         // Examine the supertype and consider auto-borrowing.\n         //\n@@ -745,7 +747,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n-        debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n+        debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         // Special-ish case: we can coerce any type `T` into the `!`\n         // type, but only if the source expression diverges."}, {"sha": "59dbbfe49f0a99848f3a712f02cd7fd808bf7eb5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -576,6 +576,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::WellFormed(..) |\n@@ -1148,19 +1149,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            match self.sub_types(false,\n-                                 &ObligationCause::dummy(),\n-                                 self_ty,\n-                                 probe.xform_self_ty) {\n-                Ok(InferOk { obligations, value: () }) => {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty())\n-                }\n+            let sub_obligations = match self.sub_types(false,\n+                                                       &ObligationCause::dummy(),\n+                                                       self_ty,\n+                                                       probe.xform_self_ty) {\n+                Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(_) => {\n                     debug!(\"--> cannot relate self-types\");\n                     return false;\n                 }\n-            }\n+            };\n \n             // If so, impls may carry other conditions (e.g., where\n             // clauses) that must be considered. Make sure that those\n@@ -1199,6 +1197,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // Evaluate those obligations to see if they might possibly hold.\n             let mut all_true = true;\n             for o in obligations.iter()\n+                .chain(sub_obligations.iter())\n                 .chain(norm_obligations.iter())\n                 .chain(ref_obligations.iter()) {\n                 if !selcx.evaluate_obligation(o) {"}, {"sha": "77213b5a7436fddd249b30911adb92ea63f6c7bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 211, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -88,9 +88,9 @@ use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n-use rustc::infer::type_variable::{self, TypeVariableOrigin};\n+use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n@@ -105,7 +105,7 @@ use session::{Session, CompileResult};\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -1978,218 +1978,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    // Implements type inference fallback algorithm\n     fn select_all_obligations_and_apply_defaults(&self) {\n-        if self.tcx.sess.features.borrow().default_type_parameter_fallback {\n-            self.new_select_all_obligations_and_apply_defaults();\n-        } else {\n-            self.old_select_all_obligations_and_apply_defaults();\n-        }\n-    }\n-\n-    // Implements old type inference fallback algorithm\n-    fn old_select_all_obligations_and_apply_defaults(&self) {\n         self.select_obligations_where_possible();\n         self.default_type_parameters();\n         self.select_obligations_where_possible();\n     }\n \n-    fn new_select_all_obligations_and_apply_defaults(&self) {\n-        use rustc::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n-\n-        // For the time being this errs on the side of being memory wasteful but provides better\n-        // error reporting.\n-        // let type_variables = self.type_variables.clone();\n-\n-        // There is a possibility that this algorithm will have to run an arbitrary number of times\n-        // to terminate so we bound it by the compiler's recursion limit.\n-        for _ in 0..self.tcx.sess.recursion_limit.get() {\n-            // First we try to solve all obligations, it is possible that the last iteration\n-            // has made it possible to make more progress.\n-            self.select_obligations_where_possible();\n-\n-            let mut conflicts = Vec::new();\n-\n-            // Collect all unsolved type, integral and floating point variables.\n-            let unsolved_variables = self.unsolved_variables();\n-\n-            // We must collect the defaults *before* we do any unification. Because we have\n-            // directly attached defaults to the type variables any unification that occurs\n-            // will erase defaults causing conflicting defaults to be completely ignored.\n-            let default_map: FxHashMap<Ty<'tcx>, _> =\n-                unsolved_variables\n-                    .iter()\n-                    .filter_map(|t| self.default(t).map(|d| (*t, d)))\n-                    .collect();\n-\n-            let mut unbound_tyvars = FxHashSet();\n-\n-            debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n-\n-            // We loop over the unsolved variables, resolving them and if they are\n-            // and unconstrainted numeric type we add them to the set of unbound\n-            // variables. We do this so we only apply literal fallback to type\n-            // variables without defaults.\n-            for ty in &unsolved_variables {\n-                let resolved = self.resolve_type_vars_if_possible(ty);\n-                if self.type_var_diverges(resolved) {\n-                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                       self.tcx.mk_diverging_default());\n-                } else {\n-                    match self.type_is_unconstrained_numeric(resolved) {\n-                        UnconstrainedInt | UnconstrainedFloat => {\n-                            unbound_tyvars.insert(resolved);\n-                        },\n-                        Neither => {}\n-                    }\n-                }\n-            }\n-\n-            // We now remove any numeric types that also have defaults, and instead insert\n-            // the type variable with a defined fallback.\n-            for ty in &unsolved_variables {\n-                if let Some(_default) = default_map.get(ty) {\n-                    let resolved = self.resolve_type_vars_if_possible(ty);\n-\n-                    debug!(\"select_all_obligations_and_apply_defaults: \\\n-                            ty: {:?} with default: {:?}\",\n-                             ty, _default);\n-\n-                    match resolved.sty {\n-                        ty::TyInfer(ty::TyVar(_)) => {\n-                            unbound_tyvars.insert(ty);\n-                        }\n-\n-                        ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) => {\n-                            unbound_tyvars.insert(ty);\n-                            if unbound_tyvars.contains(resolved) {\n-                                unbound_tyvars.remove(resolved);\n-                            }\n-                        }\n-\n-                        _ => {}\n-                    }\n-                }\n-            }\n-\n-            // If there are no more fallbacks to apply at this point we have applied all possible\n-            // defaults and type inference will proceed as normal.\n-            if unbound_tyvars.is_empty() {\n-                break;\n-            }\n-\n-            // Finally we go through each of the unbound type variables and unify them with\n-            // the proper fallback, reporting a conflicting default error if any of the\n-            // unifications fail. We know it must be a conflicting default because the\n-            // variable would only be in `unbound_tyvars` and have a concrete value if\n-            // it had been solved by previously applying a default.\n-\n-            // We wrap this in a transaction for error reporting, if we detect a conflict\n-            // we will rollback the inference context to its prior state so we can probe\n-            // for conflicts and correctly report them.\n-\n-            let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n-                conflicts.extend(\n-                    self.apply_defaults_and_return_conflicts(&unbound_tyvars, &default_map, None)\n-                );\n-\n-                // If there are conflicts we rollback, otherwise commit\n-                if conflicts.len() > 0 {\n-                    Err(())\n-                } else {\n-                    Ok(())\n-                }\n-            });\n-\n-            // Loop through each conflicting default, figuring out the default that caused\n-            // a unification failure and then report an error for each.\n-            for (conflict, default) in conflicts {\n-                let conflicting_default =\n-                    self.apply_defaults_and_return_conflicts(\n-                            &unbound_tyvars,\n-                            &default_map,\n-                            Some(conflict)\n-                        )\n-                        .last()\n-                        .map(|(_, tv)| tv)\n-                        .unwrap_or(type_variable::Default {\n-                            ty: self.next_ty_var(\n-                                TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n-                            origin_span: syntax_pos::DUMMY_SP,\n-                            // what do I put here?\n-                            def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n-                        });\n-\n-                // This is to ensure that we elimnate any non-determinism from the error\n-                // reporting by fixing an order, it doesn't matter what order we choose\n-                // just that it is consistent.\n-                let (first_default, second_default) =\n-                    if default.def_id < conflicting_default.def_id {\n-                        (default, conflicting_default)\n-                    } else {\n-                        (conflicting_default, default)\n-                    };\n-\n-\n-                self.report_conflicting_default_types(\n-                    first_default.origin_span,\n-                    self.body_id,\n-                    first_default,\n-                    second_default)\n-            }\n-        }\n-\n-        self.select_obligations_where_possible();\n-    }\n-\n-    // For use in error handling related to default type parameter fallback. We explicitly\n-    // apply the default that caused conflict first to a local version of the type variable\n-    // table then apply defaults until we find a conflict. That default must be the one\n-    // that caused conflict earlier.\n-    fn apply_defaults_and_return_conflicts<'b>(\n-        &'b self,\n-        unbound_vars: &'b FxHashSet<Ty<'tcx>>,\n-        default_map: &'b FxHashMap<Ty<'tcx>, type_variable::Default<'tcx>>,\n-        conflict: Option<Ty<'tcx>>,\n-    ) -> impl Iterator<Item=(Ty<'tcx>, type_variable::Default<'tcx>)> + 'b {\n-        use rustc::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n-\n-        conflict.into_iter().chain(unbound_vars.iter().cloned()).flat_map(move |ty| {\n-            if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, ty,\n-                                   self.tcx.mk_diverging_default());\n-            } else {\n-                match self.type_is_unconstrained_numeric(ty) {\n-                    UnconstrainedInt => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.f64)\n-                    },\n-                    Neither => {\n-                        if let Some(default) = default_map.get(ty) {\n-                            let default = default.clone();\n-                            let default_ty = self.normalize_associated_types_in(\n-                                default.origin_span, &default.ty);\n-                            match self.eq_types(false,\n-                                                &self.misc(default.origin_span),\n-                                                ty,\n-                                                default_ty) {\n-                                Ok(ok) => self.register_infer_ok_obligations(ok),\n-                                Err(_) => {\n-                                    return Some((ty, default));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            None\n-        })\n-    }\n-\n     fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n \n@@ -2757,11 +2552,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n                 let ures = self.sub_types(false, &origin, formal_ret, ret_ty);\n+\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n                 match ures {\n-                    Ok(ok) => self.register_infer_ok_obligations(ok),\n-                    Err(e) => return Err(e),\n+                    Ok(ok) => {\n+                        // Process any obligations locally as much as\n+                        // we can.  We don't care if some things turn\n+                        // out unconstrained or ambiguous, as we're\n+                        // just trying to get hints here.\n+                        let result = self.save_and_restore_obligations_in_snapshot_flag(|_| {\n+                            let mut fulfill = FulfillmentContext::new();\n+                            let ok = ok; // FIXME(#30046)\n+                            for obligation in ok.obligations {\n+                                fulfill.register_predicate_obligation(self, obligation);\n+                            }\n+                            fulfill.select_where_possible(self)\n+                        });\n+\n+                        match result {\n+                            Ok(()) => { }\n+                            Err(_) => return Err(()),\n+                        }\n+                    }\n+                    Err(_) => return Err(()),\n                 }\n \n                 // Record all the argument types, with the substitutions"}, {"sha": "2d72052f1e5ad6b4bf4e807671c74c64fcd9e36e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -1378,7 +1378,7 @@ E0102: r##\"\n You hit this error because the compiler lacks the information to\n determine the type of this variable. Erroneous code example:\n \n-```compile_fail,E0102\n+```compile_fail,E0282\n // could be an array of anything\n let x = []; // error: cannot determine a type for this local variable\n ```"}, {"sha": "fb8ba51853fe8748ca0ef482d70844e46efbae51", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -838,7 +838,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n-    EqPredicate { lhs: Type, rhs: Type }\n+    EqPredicate { lhs: Type, rhs: Type },\n }\n \n impl Clean<WherePredicate> for hir::WherePredicate {\n@@ -875,6 +875,7 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n         match *self {\n             Predicate::Trait(ref pred) => pred.clean(cx),\n             Predicate::Equate(ref pred) => pred.clean(cx),\n+            Predicate::Subtype(ref pred) => pred.clean(cx),\n             Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n             Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n             Predicate::Projection(ref pred) => pred.clean(cx),\n@@ -904,6 +905,13 @@ impl<'tcx> Clean<WherePredicate> for ty::EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n+    fn clean(&self, _cx: &DocContext) -> WherePredicate {\n+        panic!(\"subtype predicates are an internal rustc artifact \\\n+                and should not be seen by rustdoc\")\n+    }\n+}\n+\n impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'tcx ty::Region> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;"}, {"sha": "6a17ddebd1dc17f89c7755ea980ef65f8f280f4d", "filename": "src/test/compile-fail/E0102.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2FE0102.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2FE0102.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0102.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -10,6 +10,7 @@\n \n fn main() {\n     let x = [];\n-    //~^ ERROR E0102\n-    //~| NOTE cannot resolve type of variable\n+    //~^ ERROR type annotations needed\n+    //~| NOTE consider giving `x` a type\n+    //~| NOTE cannot infer type for `_`\n }"}, {"sha": "cff0064497aff34ac814b8be55d4a1b9c4e64b9d", "filename": "src/test/compile-fail/binop-move-semantics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -62,7 +62,6 @@ fn mut_plus_immut() {\n     &mut f\n     +\n     &f;  //~ ERROR: cannot borrow `f` as immutable because it is also borrowed as mutable\n-    //~^ cannot borrow `f` as immutable because it is also borrowed as mutable\n }\n \n fn immut_plus_mut() {\n@@ -71,7 +70,6 @@ fn immut_plus_mut() {\n     &f\n     +\n     &mut f;  //~ ERROR: cannot borrow `f` as mutable because it is also borrowed as immutable\n-    //~^ cannot borrow `f` as mutable because it is also borrowed as immutable\n }\n \n fn main() {}"}, {"sha": "f09e7ffd7e4b791c4b51472ca9db8013b79e0659", "filename": "src/test/compile-fail/borrowck/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-loop.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -109,7 +109,6 @@ fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n         borrow(&*v); //~ ERROR cannot borrow\n         if cond2 {\n             x = &mut v; //~ ERROR cannot borrow\n-            //~^ ERROR cannot borrow\n         }\n     }\n }"}, {"sha": "38e0e27a7b98e792e828f44bb7ad64ec83f426a0", "filename": "src/test/compile-fail/borrowck/borrowck-mut-borrow-linear-errors.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -19,7 +19,6 @@ fn main() {\n         match 1 {\n             1 => { addr = &mut x; }\n             //~^ ERROR cannot borrow `x` as mutable more than once at a time\n-            //~| ERROR cannot borrow `x` as mutable more than once at a time\n             2 => { addr = &mut x; }\n             //~^ ERROR cannot borrow `x` as mutable more than once at a time\n             _ => { addr = &mut x; }"}, {"sha": "8cde239ca6edf0c8c3126d6de4e4a7b540dad199", "filename": "src/test/compile-fail/default_ty_param_conflict.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-use std::fmt::Debug;\n-\n-// Example from the RFC\n-fn foo<F:Default=usize>() -> F { F::default() }\n-//~^ NOTE: a default was defined here...\n-\n-fn bar<B:Debug=isize>(b: B) { println!(\"{:?}\", b); }\n-//~^ NOTE: a second default was defined here...\n-\n-fn main() {\n-    // Here, F is instantiated with $0=uint\n-    let x = foo();\n-    //~^ ERROR: mismatched types\n-    //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n-    //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n-    //~| NOTE: ...that was applied to an unconstrained type variable here\n-\n-    // Here, B is instantiated with $1=uint, and constraint $0 <: $1 is added.\n-    bar(x);\n-    //~^ NOTE: ...that also applies to the same type variable here\n-}"}, {"sha": "e5b035e50aa931c625e36761098f26cd85a5f161", "filename": "src/test/compile-fail/default_ty_param_conflict_cross_crate.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-//aux-build:default_ty_param_cross_crate_crate.rs\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-extern crate default_param_test;\n-\n-use default_param_test::{Foo, bleh};\n-\n-fn meh<X, B=bool>(x: Foo<X, B>) {}\n-//~^ NOTE: a default was defined here...\n-\n-fn main() {\n-    let foo = bleh();\n-    //~^ NOTE: ...that also applies to the same type variable here\n-\n-    meh(foo);\n-    //~^ ERROR: mismatched types\n-    //~| NOTE: conflicting type parameter defaults `bool` and `char`\n-    //~| NOTE: conflicting type parameter defaults `bool` and `char`\n-    //~| a second default is defined on `default_param_test::bleh`\n-    //~| NOTE:  ...that was applied to an unconstrained type variable here\n-}"}, {"sha": "09bd3a2fc57d97a4f02744a84621c97622f16baa", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     // n == m\n     let &x = &1isize as &T;      //~ ERROR type `&T` cannot be dereferenced\n     let &&x = &(&1isize as &T);  //~ ERROR type `&T` cannot be dereferenced\n-    let box x = box 1isize as Box<T>; //~ ERROR `T: std::marker::Sized` is not satisfied\n+    let box x = box 1isize as Box<T>; //~ ERROR type `std::boxed::Box<T>` cannot be dereferenced\n \n     // n > m\n     let &&x = &1isize as &T;"}, {"sha": "6aeb9442c40ed9ebb637ac2cbf66e66490d610ac", "filename": "src/test/compile-fail/issue-12187-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -16,4 +16,5 @@ fn main() {\n     let &v = new();\n     //~^ ERROR type annotations needed [E0282]\n     //~| NOTE cannot infer type for `_`\n+    //~| NOTE consider giving a type to pattern\n }"}, {"sha": "d52ed06c4085d7d57b4522fac267c709d4f94f22", "filename": "src/test/compile-fail/issue-12187-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -16,4 +16,5 @@ fn main() {\n     let &v = new();\n     //~^ ERROR type annotations needed [E0282]\n     //~| NOTE cannot infer type for `_`\n+    //~| NOTE consider giving a type to pattern\n }"}, {"sha": "323ce3b0adf33d89f9166ffd2c2b60182a2120cb", "filename": "src/test/compile-fail/issue-25579.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -17,7 +17,6 @@ fn causes_ice(mut l: &mut Sexpression) {\n     loop { match l {\n         &mut Sexpression::Num(ref mut n) => {},\n         &mut Sexpression::Cons(ref mut expr) => { //~ ERROR cannot borrow `l.0`\n-            //~| ERROR cannot borrow `l.0`\n             l = &mut **expr; //~ ERROR cannot assign to `l`\n         }\n     }}"}, {"sha": "7acbbfb8826df40e1b8c9415aae2c9ce8430b351", "filename": "src/test/compile-fail/issue-30225.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-30225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-30225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30225.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #30225, which was an ICE that would trigger as\n+// a result of a poor interaction between trait result caching and\n+// type inference. Specifically, at that time, unification could cause\n+// unrelated type variables to become instantiated, if subtyping\n+// relationships existed. These relationships are now propagated\n+// through obligations and hence everything works out fine.\n+\n+trait Foo<U,V> : Sized {\n+    fn foo(self, u: Option<U>, v: Option<V>) {}\n+}\n+\n+struct A;\n+struct B;\n+\n+impl Foo<A, B> for () {}      // impl A\n+impl Foo<u32, u32> for u32 {} // impl B, creating ambiguity\n+\n+fn toxic() {\n+    // cache the resolution <() as Foo<$0,$1>> = impl A\n+    let u = None;\n+    let v = None;\n+    Foo::foo((), u, v);\n+}\n+\n+fn bomb() {\n+    let mut u = None; // type is Option<$0>\n+    let mut v = None; // type is Option<$1>\n+    let mut x = None; // type is Option<$2>\n+\n+    Foo::foo(x.unwrap(),u,v); // register <$2 as Foo<$0, $1>>\n+    u = v; // mark $0 and $1 in a subtype relationship\n+    //~^ ERROR mismatched types\n+    x = Some(()); // set $2 = (), allowing impl selection\n+                  // to proceed for <() as Foo<$0, $1>> = impl A.\n+                  // kaboom, this *used* to trigge an ICE\n+}\n+\n+fn main() {}"}, {"sha": "b4feadbacf7404cc61d1b9cc91f54224eaa19ffd", "filename": "src/test/compile-fail/issue-38412.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     let Box(a) = loop { };\n     //~^ ERROR expected tuple struct/variant, found struct `Box`\n-    //~| ERROR expected tuple struct/variant, found struct `Box`\n \n     // (The below is a trick to allow compiler to infer a type for\n     // variable `a` without attempting to ascribe a type to the"}, {"sha": "a5f001b785cc9481b9ceef9a31e6b0bf767b7600", "filename": "src/test/compile-fail/issue-7813.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    let v = &[];\n-    let it = v.iter(); //~ ERROR type annotations needed [E0282]\n-                       //~| NOTE cannot infer type for `T`\n-                       //~| NOTE consider giving `it` a type\n+    let v = &[]; //~ ERROR type annotations needed\n+    //~| NOTE consider giving `v` a type\n+    //~| NOTE cannot infer type for `_`\n+    let it = v.iter();\n }"}, {"sha": "5bb2ab75c53fd42a8fadd9b43920b94e87e0d216", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -21,7 +21,6 @@ use std::fmt::{};\n // Should get errors for both 'Some' and 'None'\n use std::option::Option::{Some, None};\n //~^ ERROR unused imports: `None`, `Some`\n-//~| ERROR unused imports: `None`, `Some`\n \n use test::A;       //~ ERROR unused import: `test::A`\n // Be sure that if we just bring some methods into scope that they're also"}, {"sha": "8fc2c2e6bce70009bc949f187d6458ef82f5b1ec", "filename": "src/test/run-pass/default_ty_param_default_dependent_associated_type.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_default_dependent_associated_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_default_dependent_associated_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_default_dependent_associated_type.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-use std::marker::PhantomData;\n-\n-trait Id {\n-    type This;\n-}\n-\n-impl<A> Id for A {\n-    type This = A;\n-}\n-\n-struct Foo<X: Default = usize, Y = <X as Id>::This> {\n-    data: PhantomData<(X, Y)>\n-}\n-\n-impl<X: Default, Y> Foo<X, Y> {\n-    fn new() -> Foo<X, Y> {\n-        Foo { data: PhantomData }\n-    }\n-}\n-\n-fn main() {\n-    let foo = Foo::new();\n-}"}, {"sha": "ac833d0f54744e2a659d0c9738da4695edfe3cc4", "filename": "src/test/run-pass/default_ty_param_dependent_defaults.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_dependent_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_dependent_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_dependent_defaults.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-\n-#![feature(default_type_parameter_fallback)]\n-use std::marker::PhantomData;\n-\n-struct Foo<T,U=T> { t: T, data: PhantomData<U> }\n-\n-fn main() {\n-    let foo = Foo { t: 'a', data: PhantomData };\n-}"}, {"sha": "e8d93092ec53d31704a5da06482dd58a9d00a719", "filename": "src/test/run-pass/default_ty_param_method_call_test.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-struct Foo;\n-\n-impl Foo {\n-    fn method<A:Default=String>(&self) -> A {\n-        A::default()\n-    }\n-}\n-\n-fn main() {\n-    let f = Foo.method();\n-    println!(\"{}\", f);\n-}"}, {"sha": "d9ac51fc23b0281a07a4934f97fda0dec7f7bcf8", "filename": "src/test/run-pass/default_ty_param_struct.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-struct Foo<A>(A);\n-\n-impl<A:Default=i32> Foo<A> {\n-    fn new() -> Foo<A> {\n-        Foo(A::default())\n-    }\n-}\n-\n-fn main() {\n-    let foo = Foo::new();\n-}"}, {"sha": "d3bdab9082e32a38a676bacb7b009e0270a646a8", "filename": "src/test/run-pass/default_ty_param_struct_and_type_alias.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-use std::marker::PhantomData;\n-\n-pub struct DeterministicHasher;\n-pub struct RandomHasher;\n-\n-\n-pub struct MyHashMap<K, V, H=DeterministicHasher> {\n-    data: PhantomData<(K, V, H)>\n-}\n-\n-impl<K, V, H> MyHashMap<K, V, H> {\n-    fn new() -> MyHashMap<K, V, H> {\n-        MyHashMap { data: PhantomData }\n-    }\n-}\n-\n-mod mystd {\n-    use super::{MyHashMap, RandomHasher};\n-    pub type HashMap<K, V, H=RandomHasher> = MyHashMap<K, V, H>;\n-}\n-\n-fn try_me<H>(hash_map: mystd::HashMap<i32, i32, H>) {}\n-\n-fn main() {\n-    let hash_map = mystd::HashMap::new();\n-    try_me(hash_map);\n-}"}, {"sha": "c67d3a49aff3d01a1288affa33fb307305dd036a", "filename": "src/test/run-pass/default_ty_param_trait_impl.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-// Another example from the RFC\n-trait Foo { }\n-trait Bar { }\n-\n-impl<T:Bar=usize> Foo for Vec<T> {}\n-impl Bar for usize {}\n-\n-fn takes_foo<F:Foo>(f: F) {}\n-\n-fn main() {\n-    let x = Vec::new(); // x: Vec<$0>\n-    takes_foo(x); // adds oblig Vec<$0> : Foo\n-}"}, {"sha": "067ad524922c0bfa17066c0939457504b321fe1d", "filename": "src/test/run-pass/default_ty_param_trait_impl_simple.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14481f72102ba2abb5f314d5537fee90352981c5/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs?ref=14481f72102ba2abb5f314d5537fee90352981c5", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(default_type_parameter_fallback)]\n-\n-// An example from the RFC\n-trait Foo { fn takes_foo(&self); }\n-trait Bar { }\n-\n-impl<T:Bar=usize> Foo for Vec<T> {\n-    fn takes_foo(&self) {}\n-}\n-\n-impl Bar for usize {}\n-\n-fn main() {\n-    let x = Vec::new(); // x: Vec<$0>\n-    x.takes_foo(); // adds oblig Vec<$0> : Foo\n-}"}, {"sha": "adc7101b16aa18a7cdc9fe6e3993421b0e11203a", "filename": "src/test/run-pass/issue-40951.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Frun-pass%2Fissue-40951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Frun-pass%2Fissue-40951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-40951.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(default_type_parameter_fallback)]\n+// Regression test for #40951.\n \n-use std::collections::HashMap;\n+const FOO: [&'static str; 1] = [\"foo\"];\n \n-type IntMap<K=usize> = HashMap<K, usize>;\n+fn find<T: PartialEq>(t: &[T], element: &T) { }\n \n fn main() {\n-    let x = IntMap::new();\n+    let x = format!(\"hi\");\n+    find(&FOO, &&*x);\n }", "previous_filename": "src/test/run-pass/default_ty_param_type_alias.rs"}, {"sha": "d7fb85ca4842e6824736ab98df5857b885c259c8", "filename": "src/test/run-pass/type-infer-generalize-ty-var.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a scenario where we generate a constraint like `?1 <: &?2`.\n+// In such a case, it is important that we instantiate `?1` with `&?3`\n+// where `?3 <: ?2`, and not with `&?2`. This is a regression test for\n+// #18653. The important thing is that we build.\n+\n+use std::cell::RefCell;\n+\n+enum Wrap<A> {\n+    WrapSome(A),\n+    WrapNone\n+}\n+\n+use Wrap::*;\n+\n+struct T;\n+struct U;\n+\n+trait Get<T: ?Sized> {\n+    fn get(&self) -> &T;\n+}\n+\n+impl Get<MyShow + 'static> for Wrap<T> {\n+    fn get(&self) -> &(MyShow + 'static) {\n+        static x: usize = 42;\n+        &x\n+    }\n+}\n+\n+impl Get<usize> for Wrap<U> {\n+    fn get(&self) -> &usize {\n+        static x: usize = 55;\n+        &x\n+    }\n+}\n+\n+trait MyShow { fn dummy(&self) { } }\n+impl<'a> MyShow for &'a (MyShow + 'a) { }\n+impl MyShow for usize { }\n+fn constrain<'a>(rc: RefCell<&'a (MyShow + 'a)>) { }\n+\n+fn main() {\n+    let mut collection: Wrap<_> = WrapNone;\n+\n+    {\n+        let __arg0 = Get::get(&collection);\n+        let __args_cell = RefCell::new(__arg0);\n+        constrain(__args_cell);\n+    }\n+    collection = WrapSome(T);\n+}"}, {"sha": "06cbd9a3df41686b464dee0f15dda74cb91ab8fc", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e2ad559e28222f2333de4d2c1b2b12b9bd3646/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=d2e2ad559e28222f2333de4d2c1b2b12b9bd3646", "patch": "@@ -97,6 +97,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     let primary_spans: Vec<_> = spans_in_this_file.iter()\n         .cloned()\n         .filter(|span| span.is_primary)\n+        .take(1) // sometimes we have more than one showing up in the json; pick first\n         .collect();\n     let primary_spans = if primary_spans.is_empty() {\n         // subdiagnostics often don't have a span of their own;"}]}