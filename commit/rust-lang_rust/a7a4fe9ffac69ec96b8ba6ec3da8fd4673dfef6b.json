{"sha": "a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "node_id": "C_kwDOAAsO6NoAKGE3YTRmZTlmZmFjNjllYzk2YjhiYTZlYzNkYThmZDQ2NzNkZmVmNmI", "commit": {"author": {"name": "Nixon Enraght-Moony", "email": "nixon.emoony@gmail.com", "date": "2022-08-24T16:32:39Z"}, "committer": {"name": "Nixon Enraght-Moony", "email": "nixon.emoony@gmail.com", "date": "2022-09-14T15:14:15Z"}, "message": "jsondoclint: Tree Walk Validator", "tree": {"sha": "389252744d9380eae821c341b1f38169d6d5f855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389252744d9380eae821c341b1f38169d6d5f855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "html_url": "https://github.com/rust-lang/rust/commit/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/comments", "author": {"login": "aDotInTheVoid", "id": 28781354, "node_id": "MDQ6VXNlcjI4NzgxMzU0", "avatar_url": "https://avatars.githubusercontent.com/u/28781354?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aDotInTheVoid", "html_url": "https://github.com/aDotInTheVoid", "followers_url": "https://api.github.com/users/aDotInTheVoid/followers", "following_url": "https://api.github.com/users/aDotInTheVoid/following{/other_user}", "gists_url": "https://api.github.com/users/aDotInTheVoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/aDotInTheVoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aDotInTheVoid/subscriptions", "organizations_url": "https://api.github.com/users/aDotInTheVoid/orgs", "repos_url": "https://api.github.com/users/aDotInTheVoid/repos", "events_url": "https://api.github.com/users/aDotInTheVoid/events{/privacy}", "received_events_url": "https://api.github.com/users/aDotInTheVoid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aDotInTheVoid", "id": 28781354, "node_id": "MDQ6VXNlcjI4NzgxMzU0", "avatar_url": "https://avatars.githubusercontent.com/u/28781354?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aDotInTheVoid", "html_url": "https://github.com/aDotInTheVoid", "followers_url": "https://api.github.com/users/aDotInTheVoid/followers", "following_url": "https://api.github.com/users/aDotInTheVoid/following{/other_user}", "gists_url": "https://api.github.com/users/aDotInTheVoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/aDotInTheVoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aDotInTheVoid/subscriptions", "organizations_url": "https://api.github.com/users/aDotInTheVoid/orgs", "repos_url": "https://api.github.com/users/aDotInTheVoid/repos", "events_url": "https://api.github.com/users/aDotInTheVoid/events{/privacy}", "received_events_url": "https://api.github.com/users/aDotInTheVoid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2506aa0394fa1f03d09a40cdabc5ade1215b0969", "url": "https://api.github.com/repos/rust-lang/rust/commits/2506aa0394fa1f03d09a40cdabc5ade1215b0969", "html_url": "https://github.com/rust-lang/rust/commit/2506aa0394fa1f03d09a40cdabc5ade1215b0969"}], "stats": {"total": 476, "additions": 469, "deletions": 7}, "files": [{"sha": "69f96bcbe63b43353df462f657f9f01c52b543af", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "patch": "@@ -103,9 +103,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.60\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n+checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"array_tool\"\n@@ -1362,9 +1362,9 @@ dependencies = [\n \n [[package]]\n name = \"fs-err\"\n-version = \"2.5.0\"\n+version = \"2.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bcd1163ae48bda72a20ae26d66a04d3094135cadab911cff418ae5e33f253431\"\n+checksum = \"64db3e262960f0662f43a6366788d5f10f7f244b8f7d7d987f560baf5ded5c50\"\n \n [[package]]\n name = \"fs_extra\"\n@@ -1894,6 +1894,12 @@ dependencies = [\n [[package]]\n name = \"jsondoclint\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"fs-err\",\n+ \"rustdoc-json-types\",\n+ \"serde_json\",\n+]\n \n [[package]]\n name = \"jsonpath_lib\"\n@@ -4449,9 +4455,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.83\"\n+version = \"1.0.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n+checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\","}, {"sha": "84a6c7f96c4644631e66c51070b9c4720af472f8", "filename": "src/tools/jsondoclint/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2FCargo.toml?ref=a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "patch": "@@ -6,3 +6,7 @@ edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n+anyhow = \"1.0.62\"\n+fs-err = \"2.8.1\"\n+rustdoc-json-types = { version = \"0.1.0\", path = \"../../rustdoc-json-types\" }\n+serde_json = \"1.0.85\""}, {"sha": "7c6c0b54379281c49ba81da3085b62166a7b77b0", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "patch": "@@ -0,0 +1,29 @@\n+use rustdoc_json_types::ItemEnum;\n+\n+pub(crate) fn can_appear_in_mod(kind: &ItemEnum) -> bool {\n+    match kind {\n+        ItemEnum::Module(_) => true,\n+        ItemEnum::ExternCrate { .. } => true,\n+        ItemEnum::Import(_) => true,\n+        ItemEnum::Union(_) => true,\n+        ItemEnum::Struct(_) => true,\n+        ItemEnum::StructField(_) => false, // Only in structs or variants\n+        ItemEnum::Enum(_) => true,\n+        ItemEnum::Variant(_) => false, // Only in enums\n+        ItemEnum::Function(_) => true,\n+        ItemEnum::Trait(_) => true,\n+        ItemEnum::TraitAlias(_) => true,\n+        ItemEnum::Method(_) => false, // Only in traits\n+        ItemEnum::Impl(_) => true,\n+        ItemEnum::Typedef(_) => true,\n+        ItemEnum::OpaqueTy(_) => todo!(\"IDK\"), // On\n+        ItemEnum::Constant(_) => true,\n+        ItemEnum::Static(_) => true,\n+        ItemEnum::ForeignType => todo!(\"IDK\"),\n+        ItemEnum::Macro(_) => true,\n+        ItemEnum::ProcMacro(_) => true,\n+        ItemEnum::PrimitiveType(_) => todo!(\"IDK\"),\n+        ItemEnum::AssocConst { .. } => false, // Trait Only\n+        ItemEnum::AssocType { .. } => false,  // Trait only\n+    }\n+}"}, {"sha": "b98601f7d89f9c47b7a37a4dd16227871ca4a760", "filename": "src/tools/jsondoclint/src/main.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs?ref=a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "patch": "@@ -1 +1,33 @@\n-fn main() {}\n+use std::env;\n+\n+use anyhow::{anyhow, bail, Result};\n+use fs_err as fs;\n+use rustdoc_json_types::{Crate, Id, FORMAT_VERSION};\n+\n+pub(crate) mod item_kind;\n+mod validator;\n+\n+#[derive(Debug)]\n+struct Error {\n+    message: String,\n+    id: Id,\n+}\n+\n+fn main() -> Result<()> {\n+    let path = env::args().nth(1).ok_or_else(|| anyhow!(\"no path given\"))?;\n+    let contents = fs::read_to_string(path)?;\n+    let krate: Crate = serde_json::from_str(&contents)?;\n+    assert_eq!(krate.format_version, FORMAT_VERSION);\n+\n+    let mut validator = validator::Validator::new(&krate);\n+    validator.check_crate();\n+\n+    if !validator.errs.is_empty() {\n+        for err in validator.errs {\n+            eprintln!(\"`{}`: `{}`\", err.id.0, err.message);\n+        }\n+        bail!(\"Errors validating json\");\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "2bb63bc3a44e5d0da1c64cc4d30ce521bfdb0709", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=a7a4fe9ffac69ec96b8ba6ec3da8fd4673dfef6b", "patch": "@@ -0,0 +1,391 @@\n+use std::collections::HashSet;\n+use std::hash::Hash;\n+\n+use rustdoc_json_types::{\n+    Constant, Crate, DynTrait, Enum, FnDecl, Function, FunctionPointer, GenericArg, GenericArgs,\n+    GenericBound, GenericParamDef, Generics, Id, Impl, Import, ItemEnum, Method, Module, OpaqueTy,\n+    Path, ProcMacro, Static, Struct, StructKind, Term, Trait, TraitAlias, Type, TypeBinding,\n+    TypeBindingKind, Typedef, Union, Variant, WherePredicate,\n+};\n+\n+use crate::{item_kind::can_appear_in_mod, Error};\n+\n+#[derive(Debug)]\n+pub struct Validator<'a> {\n+    pub(crate) errs: Vec<Error>,\n+    krate: &'a Crate,\n+    seen_ids: HashSet<&'a Id>,\n+    todo: HashSet<&'a Id>,\n+}\n+\n+fn set_remove<T: Hash + Eq + Clone>(set: &mut HashSet<T>) -> Option<T> {\n+    if let Some(id) = set.iter().next() {\n+        let id = id.clone();\n+        set.take(&id)\n+    } else {\n+        None\n+    }\n+}\n+\n+impl<'a> Validator<'a> {\n+    pub fn new(krate: &'a Crate) -> Self {\n+        Self { krate, errs: Vec::new(), seen_ids: HashSet::new(), todo: HashSet::new() }\n+    }\n+\n+    pub fn check_crate(&mut self) {\n+        let root = &self.krate.root;\n+        self.add_mod_id(root);\n+        while let Some(id) = set_remove(&mut self.todo) {\n+            self.seen_ids.insert(id);\n+            self.check_item(id);\n+        }\n+    }\n+\n+    fn check_item(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        match &item.inner {\n+            ItemEnum::Import(x) => self.check_import(x),\n+            ItemEnum::Union(x) => self.check_union(x),\n+            ItemEnum::Struct(x) => self.check_struct(x),\n+            ItemEnum::StructField(x) => self.check_struct_field(x),\n+            ItemEnum::Enum(x) => self.check_enum(x),\n+            ItemEnum::Variant(x) => self.check_variant(x),\n+            ItemEnum::Function(x) => self.check_function(x),\n+            ItemEnum::Trait(x) => self.check_trait(x),\n+            ItemEnum::TraitAlias(x) => self.check_trait_alias(x),\n+            ItemEnum::Method(x) => self.check_method(x),\n+            ItemEnum::Impl(x) => self.check_impl(x),\n+            ItemEnum::Typedef(x) => self.check_typedef(x),\n+            ItemEnum::OpaqueTy(x) => self.check_opaque_ty(x),\n+            ItemEnum::Constant(x) => self.check_constant(x),\n+            ItemEnum::Static(x) => self.check_static(x),\n+            ItemEnum::ForeignType => todo!(),\n+            ItemEnum::Macro(x) => self.check_macro(x),\n+            ItemEnum::ProcMacro(x) => self.check_proc_macro(x),\n+            ItemEnum::PrimitiveType(x) => self.check_primitive_type(x),\n+            ItemEnum::Module(x) => self.check_module(x),\n+\n+            ItemEnum::ExternCrate { .. } => todo!(),\n+            ItemEnum::AssocConst { .. } => todo!(),\n+            ItemEnum::AssocType { .. } => todo!(),\n+        }\n+    }\n+\n+    // Core checkers\n+    fn check_module(&mut self, module: &'a Module) {\n+        module.items.iter().for_each(|i| self.add_mod_item_id(i));\n+    }\n+\n+    fn check_import(&mut self, x: &'a Import) {\n+        if x.glob {\n+            self.add_mod_id(x.id.as_ref().unwrap());\n+        } else if let Some(id) = &x.id {\n+            self.add_mod_item_id(id);\n+        }\n+    }\n+\n+    fn check_union(&mut self, x: &'a Union) {\n+        self.check_generics(&x.generics);\n+        x.fields.iter().for_each(|i| self.add_field_id(i));\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_struct(&mut self, x: &'a Struct) {\n+        self.check_generics(&x.generics);\n+        match &x.kind {\n+            StructKind::Unit => {}\n+            StructKind::Tuple(fields) => fields.iter().flatten().for_each(|f| self.add_field_id(f)),\n+            StructKind::Plain { fields, fields_stripped: _ } => {\n+                fields.iter().for_each(|f| self.add_field_id(f))\n+            }\n+        }\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_struct_field(&mut self, x: &'a Type) {\n+        self.check_type(x);\n+    }\n+\n+    fn check_enum(&mut self, x: &'a Enum) {\n+        self.check_generics(&x.generics);\n+        x.variants.iter().for_each(|i| self.add_variant_id(i));\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_variant(&mut self, x: &'a Variant) {\n+        match x {\n+            Variant::Plain(_discriminant) => {} // TODO: Check discriminant value parses\n+            Variant::Tuple(tys) => tys.iter().flatten().for_each(|t| self.add_field_id(t)),\n+            Variant::Struct { fields, fields_stripped: _ } => {\n+                fields.iter().for_each(|f| self.add_field_id(f))\n+            }\n+        }\n+    }\n+\n+    fn check_function(&mut self, x: &'a Function) {\n+        self.check_generics(&x.generics);\n+        self.check_fn_decl(&x.decl);\n+    }\n+\n+    fn check_trait(&mut self, x: &'a Trait) {\n+        self.check_generics(&x.generics);\n+        x.items.iter().for_each(|i| self.add_trait_item_id(i));\n+        x.bounds.iter().for_each(|i| self.check_generic_bound(i));\n+        x.implementations.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_trait_alias(&mut self, x: &'a TraitAlias) {\n+        self.check_generics(&x.generics);\n+        x.params.iter().for_each(|i| self.check_generic_bound(i));\n+    }\n+\n+    fn check_method(&mut self, x: &'a Method) {\n+        self.check_fn_decl(&x.decl);\n+        self.check_generics(&x.generics);\n+    }\n+\n+    fn check_impl(&mut self, x: &'a Impl) {\n+        self.check_generics(&x.generics);\n+        if let Some(path) = &x.trait_ {\n+            self.check_path(path); // TODO: Check is trait.\n+        }\n+        self.check_type(&x.for_);\n+        x.items.iter().for_each(|i| self.add_trait_item_id(i));\n+        if let Some(blanket_impl) = &x.blanket_impl {\n+            self.check_type(blanket_impl)\n+        }\n+    }\n+\n+    fn check_typedef(&mut self, x: &'a Typedef) {\n+        self.check_generics(&x.generics);\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_opaque_ty(&mut self, x: &'a OpaqueTy) {\n+        x.bounds.iter().for_each(|b| self.check_generic_bound(b));\n+        self.check_generics(&x.generics);\n+    }\n+\n+    fn check_constant(&mut self, x: &'a Constant) {\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_static(&mut self, x: &'a Static) {\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_macro(&mut self, _: &'a str) {\n+        // TODO\n+    }\n+\n+    fn check_proc_macro(&mut self, _: &'a ProcMacro) {\n+        // TODO\n+    }\n+\n+    fn check_primitive_type(&mut self, _: &'a str) {\n+        // TODO\n+    }\n+\n+    fn check_generics(&mut self, x: &'a Generics) {\n+        x.params.iter().for_each(|p| self.check_generic_param_def(p));\n+        x.where_predicates.iter().for_each(|w| self.check_where_predicate(w));\n+    }\n+\n+    fn check_type(&mut self, x: &'a Type) {\n+        match x {\n+            Type::ResolvedPath(path) => self.check_path(path),\n+            Type::DynTrait(dyn_trait) => self.check_dyn_trait(dyn_trait),\n+            Type::Generic(_) => {}\n+            Type::Primitive(_) => {}\n+            Type::FunctionPointer(fp) => self.check_function_pointer(&**fp),\n+            Type::Tuple(tys) => tys.iter().for_each(|ty| self.check_type(ty)),\n+            Type::Slice(inner) => self.check_type(&**inner),\n+            Type::Array { type_, len: _ } => self.check_type(&**type_),\n+            Type::ImplTrait(bounds) => bounds.iter().for_each(|b| self.check_generic_bound(b)),\n+            Type::Infer => {}\n+            Type::RawPointer { mutable: _, type_ } => self.check_type(&**type_),\n+            Type::BorrowedRef { lifetime: _, mutable: _, type_ } => self.check_type(&**type_),\n+            Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n+                self.check_generic_args(&**args);\n+                self.check_type(&**self_type);\n+                self.check_path(trait_);\n+            }\n+        }\n+    }\n+\n+    fn check_fn_decl(&mut self, x: &'a FnDecl) {\n+        x.inputs.iter().for_each(|(_name, ty)| self.check_type(ty));\n+        if let Some(output) = &x.output {\n+            self.check_type(output);\n+        }\n+    }\n+\n+    fn check_generic_bound(&mut self, x: &'a GenericBound) {\n+        match x {\n+            GenericBound::TraitBound { trait_, generic_params, modifier: _ } => {\n+                self.check_path(trait_);\n+                generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+            }\n+            GenericBound::Outlives(_) => todo!(),\n+        }\n+    }\n+\n+    fn check_path(&mut self, x: &'a Path) {\n+        self.add_id(&x.id); // TODO: What kinds are allowed here.\n+        if let Some(args) = &x.args {\n+            self.check_generic_args(&**args);\n+        }\n+    }\n+\n+    fn check_generic_args(&mut self, x: &'a GenericArgs) {\n+        match x {\n+            GenericArgs::AngleBracketed { args, bindings } => {\n+                args.iter().for_each(|arg| self.check_generic_arg(arg));\n+                bindings.iter().for_each(|bind| self.check_type_binding(bind));\n+            }\n+            GenericArgs::Parenthesized { inputs, output } => {\n+                inputs.iter().for_each(|ty| self.check_type(ty));\n+                if let Some(o) = output {\n+                    self.check_type(o);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_generic_param_def(&mut self, gpd: &'a GenericParamDef) {\n+        match &gpd.kind {\n+            rustdoc_json_types::GenericParamDefKind::Lifetime { outlives: _ } => {}\n+            rustdoc_json_types::GenericParamDefKind::Type { bounds, default, synthetic: _ } => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                if let Some(ty) = default {\n+                    self.check_type(ty);\n+                }\n+            }\n+            rustdoc_json_types::GenericParamDefKind::Const { type_, default: _ } => {\n+                self.check_type(type_)\n+            }\n+        }\n+    }\n+\n+    fn check_generic_arg(&mut self, arg: &'a GenericArg) {\n+        match arg {\n+            GenericArg::Lifetime(_) => {}\n+            GenericArg::Type(ty) => self.check_type(ty),\n+            GenericArg::Const(c) => self.check_constant(c),\n+            GenericArg::Infer => {}\n+        }\n+    }\n+\n+    fn check_type_binding(&mut self, bind: &'a TypeBinding) {\n+        self.check_generic_args(&bind.args);\n+        match &bind.binding {\n+            TypeBindingKind::Equality(term) => self.check_term(term),\n+            TypeBindingKind::Constraint(bounds) => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b))\n+            }\n+        }\n+    }\n+\n+    fn check_term(&mut self, term: &'a Term) {\n+        match term {\n+            Term::Type(ty) => self.check_type(ty),\n+            Term::Constant(con) => self.check_constant(con),\n+        }\n+    }\n+\n+    fn check_where_predicate(&mut self, w: &'a WherePredicate) {\n+        match w {\n+            WherePredicate::BoundPredicate { type_, bounds, generic_params } => {\n+                self.check_type(type_);\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+            }\n+            WherePredicate::RegionPredicate { lifetime: _, bounds } => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+            }\n+            WherePredicate::EqPredicate { lhs, rhs } => {\n+                self.check_type(lhs);\n+                self.check_term(rhs);\n+            }\n+        }\n+    }\n+\n+    fn check_dyn_trait(&mut self, dyn_trait: &'a DynTrait) {\n+        for pt in &dyn_trait.traits {\n+            self.check_path(&pt.trait_);\n+            pt.generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+        }\n+    }\n+\n+    fn check_function_pointer(&mut self, fp: &'a FunctionPointer) {\n+        self.check_fn_decl(&fp.decl);\n+        fp.generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+    }\n+\n+    // Aux functions\n+    fn add_id(&mut self, id: &'a Id) {\n+        if !self.seen_ids.contains(id) {\n+            self.todo.insert(id);\n+        }\n+    }\n+\n+    fn add_field_id(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        if let ItemEnum::StructField(_) = item.inner {\n+            self.add_id(id);\n+        } else {\n+            self.fail(id, \"Expecting field\");\n+        }\n+    }\n+\n+    fn add_mod_id(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        if let ItemEnum::Module(_) = item.inner {\n+            self.add_id(id);\n+        } else {\n+            self.fail(id, \"Expecting module\");\n+        }\n+    }\n+\n+    fn add_impl_id(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        if let ItemEnum::StructField(_) = item.inner {\n+            self.add_id(id);\n+        } else {\n+            self.fail(id, \"Expecting impl\");\n+        }\n+    }\n+\n+    fn add_variant_id(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        if let ItemEnum::StructField(_) = item.inner {\n+            self.add_id(id);\n+        } else {\n+            self.fail(id, \"Expecting variant\");\n+        }\n+    }\n+\n+    /// Add an Id that appeared in a trait\n+    fn add_trait_item_id(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        if !can_appear_in_mod(&item.inner) {\n+            self.fail(id, \"Expecting item that can appear in trait\");\n+        } else {\n+            self.add_id(id);\n+        }\n+    }\n+\n+    /// Add an Id that appeared in a mod\n+    fn add_mod_item_id(&mut self, id: &'a Id) {\n+        let item = &self.krate.index[id];\n+        if can_appear_in_mod(&item.inner) {\n+            self.add_id(id);\n+        } else {\n+            self.fail(id, \"Expecting item that can appear in trait\");\n+        }\n+    }\n+\n+    fn fail(&mut self, id: &Id, msg: &str) {\n+        self.errs.push(Error { id: id.clone(), message: msg.to_string() });\n+    }\n+}"}]}