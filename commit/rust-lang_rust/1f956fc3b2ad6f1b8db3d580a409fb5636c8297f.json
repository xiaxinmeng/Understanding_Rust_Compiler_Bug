{"sha": "1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOTU2ZmMzYjJhZDZmMWI4ZGIzZDU4MGE0MDlmYjU2MzZjODI5N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-19T20:24:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-19T20:24:30Z"}, "message": "auto merge of #4999 : erickt/rust/incoming, r=brson\n\nThis patch series is doing a couple things with the ultimate goal of removing `#[allow(vecs_implicitly_copyable)]`, although I'm not quite there yet. The main change is passing around `@~str`s in most places, and using `ref`s in others. As far as I could tell, there are no performance changes with these patches, and all the tests pass on my mac.", "tree": {"sha": "432dbd8dd2a3a2e0434cd4a9fc5c66e8718776ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/432dbd8dd2a3a2e0434cd4a9fc5c66e8718776ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "html_url": "https://github.com/rust-lang/rust/commit/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a782efc4f16fed52f1f82af5869bfb5285bbc3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a782efc4f16fed52f1f82af5869bfb5285bbc3f4", "html_url": "https://github.com/rust-lang/rust/commit/a782efc4f16fed52f1f82af5869bfb5285bbc3f4"}, {"sha": "68746cd4fb93e95a393c539abc65b93ed5eecdb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/68746cd4fb93e95a393c539abc65b93ed5eecdb5", "html_url": "https://github.com/rust-lang/rust/commit/68746cd4fb93e95a393c539abc65b93ed5eecdb5"}], "stats": {"total": 1751, "additions": 898, "deletions": 853}, "files": [{"sha": "0ed6a1c20b40e817b6d15b1c997538baf5dd6da1", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -466,14 +466,14 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if attr::get_meta_item_name(*meta) == ~\"name\" {\n+            if *attr::get_meta_item_name(*meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(*meta) {\n                   // Changing attr would avoid the need for the copy\n                   // here\n                   Some(v) => { name = Some(v.to_managed()); }\n                   None => cmh_items.push(*meta)\n                 }\n-            } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n+            } else if *attr::get_meta_item_name(*meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(*meta) {\n                   Some(v) => { vers = Some(v.to_managed()); }\n                   None => cmh_items.push(*meta)\n@@ -487,27 +487,27 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n                               -cmh_items: ~[@ast::meta_item],\n                               dep_hashes: ~[~str]) -> @str {\n-        fn len_and_str(s: ~str) -> ~str {\n-            return fmt!(\"%u_%s\", str::len(s), s);\n+        fn len_and_str(s: &str) -> ~str {\n+            fmt!(\"%u_%s\", s.len(), s)\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> ~str {\n-            return len_and_str(pprust::lit_to_str(@l));\n+            len_and_str(pprust::lit_to_str(@l))\n         }\n \n         let cmh_items = attr::sort_meta_items(cmh_items);\n \n         fn hash(symbol_hasher: &hash::State, m: &@ast::meta_item) {\n             match m.node {\n-              ast::meta_name_value(ref key, value) => {\n-                symbol_hasher.write_str(len_and_str((*key)));\n+              ast::meta_name_value(key, value) => {\n+                symbol_hasher.write_str(len_and_str(*key));\n                 symbol_hasher.write_str(len_and_str_lit(value));\n               }\n-              ast::meta_word(ref name) => {\n-                symbol_hasher.write_str(len_and_str((*name)));\n+              ast::meta_word(name) => {\n+                symbol_hasher.write_str(len_and_str(*name));\n               }\n-              ast::meta_list(ref name, ref mis) => {\n-                symbol_hasher.write_str(len_and_str((*name)));\n+              ast::meta_list(name, ref mis) => {\n+                symbol_hasher.write_str(len_and_str(*name));\n                 for mis.each |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n@@ -615,7 +615,7 @@ pub fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n-pub fn sanitize(s: ~str) -> ~str {\n+pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n     for str::chars_each(s) |c| {\n         match c {\n@@ -629,10 +629,10 @@ pub fn sanitize(s: ~str) -> ~str {\n           'a' .. 'z'\n           | 'A' .. 'Z'\n           | '0' .. '9'\n-          | '_' => str::push_char(&mut result, c),\n+          | '_' => result.push_char(c),\n           _ => {\n             if c > 'z' && char::is_XID_continue(c) {\n-                str::push_char(&mut result, c);\n+                result.push_char(c);\n             }\n           }\n         }\n@@ -655,7 +655,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     for ss.each |s| {\n         match *s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(sess.str_of(s));\n+          let sani = sanitize(*sess.str_of(s));\n           n += fmt!(\"%u%s\", str::len(sani), sani);\n         } }\n     }"}, {"sha": "61838c50ce4f10f26bae6129761bdb6b9ea44080", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -62,7 +62,7 @@ pub fn anon_src() -> ~str { ~\"<anon>\" }\n \n pub fn source_name(input: input) -> ~str {\n     match input {\n-      file_input(ref ifile) => (*ifile).to_str(),\n+      file_input(ref ifile) => ifile.to_str(),\n       str_input(_) => anon_src()\n     }\n }\n@@ -97,24 +97,24 @@ pub fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n     };\n \n     return ~[ // Target bindings.\n-         attr::mk_word_item(str::from_slice(os::FAMILY)),\n-         mk(~\"target_os\", tos),\n-         mk(~\"target_family\", str::from_slice(os::FAMILY)),\n-         mk(~\"target_arch\", arch),\n-         mk(~\"target_endian\", end),\n-         mk(~\"target_word_size\", wordsz),\n-         mk(~\"target_libc\", libc),\n+         attr::mk_word_item(@str::from_slice(os::FAMILY)),\n+         mk(@~\"target_os\", @tos),\n+         mk(@~\"target_family\", @str::from_slice(os::FAMILY)),\n+         mk(@~\"target_arch\", @arch),\n+         mk(@~\"target_endian\", @end),\n+         mk(@~\"target_word_size\", @wordsz),\n+         mk(@~\"target_libc\", @libc),\n          // Build bindings.\n-         mk(~\"build_compiler\", argv0),\n-         mk(~\"build_input\", source_name(input))];\n+         mk(@~\"build_compiler\", @argv0),\n+         mk(@~\"build_input\", @source_name(input))];\n }\n \n pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n                          -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n-        return cfg;\n+        cfg\n     } else {\n-        return vec::append_one(cfg, attr::mk_word_item(name));\n+        vec::append_one(cfg, attr::mk_word_item(@name))\n     }\n }\n \n@@ -142,7 +142,7 @@ pub fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // meta_word variant.\n     let mut words = ~[];\n     for cfgspecs.each |s| {\n-        words.push(attr::mk_word_item(/*bad*/copy *s));\n+        words.push(attr::mk_word_item(@/*bad*/copy *s));\n     }\n     return words;\n }\n@@ -541,11 +541,11 @@ pub fn build_session_options(+binary: ~str,\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n-            let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n+            let lint_name = @str::replace(*lint_name, ~\"-\", ~\"_\");\n             match lint_dict.find(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n-                                           level_name, lint_name));\n+                                           level_name, *lint_name));\n               }\n               Some(lint) => {\n                 lint_opts.push((lint.lint, *level));"}, {"sha": "5f9033063235b98d5da4f29526b4463956c3e1ad", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -253,8 +253,8 @@ pub impl Session {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n \n-    fn str_of(id: ast::ident) -> ~str {\n-        /*bad*/copy *self.parse_sess.interner.get(id)\n+    fn str_of(id: ast::ident) -> @~str {\n+        self.parse_sess.interner.get(id)\n     }\n     fn ident_of(+st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)\n@@ -310,7 +310,7 @@ pub fn building_library(req_crate_type: crate_type,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 ~\"crate_type\") {\n-              option::Some(~\"lib\") => true,\n+              Some(@~\"lib\") => true,\n               _ => false\n             }\n         }\n@@ -346,7 +346,7 @@ pub mod test {\n             style: ast::attr_outer,\n             value: codemap::respan(codemap::dummy_sp(),\n                 ast::meta_name_value(\n-                    ~\"crate_type\",\n+                    @~\"crate_type\",\n                     codemap::respan(codemap::dummy_sp(),\n                                      ast::lit_str(@t)))),\n             is_sugared_doc: false"}, {"sha": "281d1ea7305926ce96ad5f885cf1914f6ae57622", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -51,7 +51,7 @@ fn inject_libcore_ref(sess: Session,\n                     spanned(ast::attribute_ {\n                         style: ast::attr_inner,\n                         value: spanned(ast::meta_name_value(\n-                            ~\"vers\",\n+                            @~\"vers\",\n                             spanned(ast::lit_str(@CORE_VERSION.to_str()))\n                         )),\n                         is_sugared_doc: false"}, {"sha": "ddd09a8b83735c38cb49621aa7404029fb8ad0d8", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -57,7 +57,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n     let should_test = attr::contains(crate.node.config,\n-                                     attr::mk_word_item(~\"test\"));\n+                                     attr::mk_word_item(@~\"test\"));\n \n     if should_test {\n         generate_test_harness(sess, crate)\n@@ -111,7 +111,7 @@ fn fold_mod(cx: @mut TestCtxt,\n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n             @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               attr::get_attr_name(*attr) != ~\"main\"\n+                               *attr::get_attr_name(attr) != ~\"main\"\n                            }),.. copy *item}\n         } else { item }\n     }\n@@ -262,7 +262,7 @@ mod __test {\n fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n     let vers = ast::lit_str(@~\"0.6\");\n     let vers = nospan(vers);\n-    let mi = ast::meta_name_value(~\"vers\", vers);\n+    let mi = ast::meta_name_value(@~\"vers\", vers);\n     let mi = nospan(mi);\n     let id_std = cx.sess.ident_of(~\"std\");\n     let vi = if is_std(cx) {\n@@ -310,7 +310,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(@~\"!resolve_unexported\"));\n \n     let item = ast::item {\n         ident: cx.sess.ident_of(~\"__test\"),\n@@ -366,7 +366,7 @@ fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n-          Some(~\"std\") => true,\n+          Some(@~\"std\") => true,\n           _ => false\n         }\n     };"}, {"sha": "8567e90103262b562a9e1395cfefb2f726355a1c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -64,7 +64,7 @@ pub fn read_crates(diag: span_handler,\n type cache_entry = {\n     cnum: int,\n     span: span,\n-    hash: ~str,\n+    hash: @~str,\n     metas: @~[@ast::meta_item]\n };\n \n@@ -100,12 +100,12 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!(\"using multiple versions of crate `%s`\", name));\n+                fmt!(\"using multiple versions of crate `%s`\", *name));\n             for matches.each |match_| {\n                 diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n-                        ~\"link\", /*bad*/copy *match_.metas))\n+                        @~\"link\", /*bad*/copy *match_.metas))\n                 ];\n                 loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n@@ -133,7 +133,7 @@ fn visit_crate(e: @mut Env, c: ast::crate) {\n     for link_args.each |a| {\n         match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n           Some(ref linkarg) => {\n-            cstore::add_used_link_args(cstore, (/*bad*/copy *linkarg));\n+            cstore::add_used_link_args(cstore, **linkarg);\n           }\n           None => {/* fallthrough */ }\n         }\n@@ -145,7 +145,7 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n       ast::view_item_extern_mod(ident, meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n                ident, meta_items);\n-        let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n+        let cnum = resolve_crate(e, ident, meta_items, @~\"\", i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n@@ -168,61 +168,62 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n         let link_args = attr::find_attrs_by_name(i.attrs, \"link_args\");\n \n         match fm.sort {\n-          ast::named => {\n-            let foreign_name =\n-               match attr::first_attr_value_str_by_name(i.attrs,\n-                                                        ~\"link_name\") {\n-                 Some(ref nn) => {\n-                   if (*nn) == ~\"\" {\n-                      e.diag.span_fatal(\n-                          i.span,\n-                          ~\"empty #[link_name] not allowed; use #[nolink].\");\n-                   }\n-                   (/*bad*/copy *nn)\n-                 }\n-                None => /*bad*/copy *e.intr.get(i.ident)\n-            };\n-            if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n-                already_added =\n-                    !cstore::add_used_library(cstore, copy foreign_name);\n-            }\n-            if !link_args.is_empty() && already_added {\n-                e.diag.span_fatal(i.span, ~\"library '\" + foreign_name +\n-                           ~\"' already added: can't specify link_args.\");\n+            ast::named => {\n+                let foreign_name =\n+                    match attr::first_attr_value_str_by_name(i.attrs,\n+                                                            ~\"link_name\") {\n+                        Some(nn) => {\n+                            if *nn == ~\"\" {\n+                                e.diag.span_fatal(\n+                                    i.span,\n+                                    ~\"empty #[link_name] not allowed; use \" +\n+                                    ~\"#[nolink].\");\n+                            }\n+                            nn\n+                        }\n+                        None => e.intr.get(i.ident)\n+                    };\n+                if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n+                    already_added =\n+                        !cstore::add_used_library(cstore, foreign_name);\n+                }\n+                if !link_args.is_empty() && already_added {\n+                    e.diag.span_fatal(i.span, ~\"library '\" + *foreign_name +\n+                               ~\"' already added: can't specify link_args.\");\n+                }\n             }\n-          }\n-          ast::anonymous => { /* do nothing */ }\n+            ast::anonymous => { /* do nothing */ }\n         }\n \n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n-              Some(ref linkarg) => {\n-                cstore::add_used_link_args(cstore, *linkarg);\n-              }\n-              None => {/* fallthrough */ }\n+                Some(linkarg) => {\n+                    cstore::add_used_link_args(cstore, *linkarg);\n+                }\n+                None => { /* fallthrough */ }\n             }\n         }\n       }\n       _ => { }\n     }\n }\n \n-fn metas_with(+ident: ~str, +key: ~str, +metas: ~[@ast::meta_item])\n+fn metas_with(ident: @~str, key: @~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, key);\n+    let name_items = attr::find_meta_items_by_name(metas, *key);\n     if name_items.is_empty() {\n         vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {\n         metas\n     }\n }\n \n-fn metas_with_ident(+ident: ~str, +metas: ~[@ast::meta_item])\n+fn metas_with_ident(ident: @~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    metas_with(ident, ~\"name\", metas)\n+    metas_with(ident, @~\"name\", metas)\n }\n \n-fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: ~str)\n+fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: @~str)\n                -> Option<int> {\n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n@@ -236,10 +237,10 @@ fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: ~str)\n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n                  +metas: ~[@ast::meta_item],\n-                 +hash: ~str,\n+                 hash: @~str,\n                  span: span)\n               -> ast::crate_num {\n-    let metas = metas_with_ident(/*bad*/copy *e.intr.get(ident), metas);\n+    let metas = metas_with_ident(@/*bad*/copy *e.intr.get(ident), metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -275,8 +276,8 @@ fn resolve_crate(e: @mut Env,\n         let cname =\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          ~\"name\") {\n-              option::Some(ref v) => (/*bad*/copy *v),\n-              option::None => /*bad*/copy *e.intr.get(ident)\n+                Some(v) => v,\n+                None => e.intr.get(ident),\n             };\n         let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n@@ -301,10 +302,10 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(/*bad*/copy dep.vers, ~\"vers\", ~[]);\n+        let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n-               *e.intr.get(dep.name), dep.vers, dep.hash);\n-        match existing_match(e, metas_with_ident(copy *e.intr.get(cname),\n+               *e.intr.get(dep.name), *dep.vers, *dep.hash);\n+        match existing_match(e, metas_with_ident(e.intr.get(cname),\n                                                  copy cmetas),\n                              dep.hash) {\n           Some(local_cnum) => {\n@@ -318,8 +319,8 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, cmetas,\n-                                           /*bad*/copy dep.hash, fake_span);\n+            let local_cnum = resolve_crate(e, cname, cmetas, dep.hash,\n+                                           fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }"}, {"sha": "6231a6394df035429bbc64a2ee5f8adadd196cc7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -80,7 +80,7 @@ pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n     vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n-        /*bad*/copy cdata.name))], path)\n+        /*bad*/copy *cdata.name))], path)\n }\n \n pub enum found_ast {"}, {"sha": "23d126cae34a54975a2957a203486bc4ba0cd862", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -33,7 +33,7 @@ use syntax::parse::token::ident_interner;\n // own crate numbers.\n pub type cnum_map = oldmap::HashMap<ast::crate_num, ast::crate_num>;\n \n-pub type crate_metadata = @{name: ~str,\n+pub type crate_metadata = @{name: @~str,\n                             data: @~[u8],\n                             cnum_map: cnum_map,\n                             cnum: ast::crate_num};\n@@ -68,14 +68,14 @@ pub fn get_crate_data(cstore: @mut CStore, cnum: ast::crate_num)\n     return cstore.metas.get(&cnum);\n }\n \n-pub fn get_crate_hash(cstore: @mut CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_hash(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n-    return decoder::get_crate_hash(cdata.data);\n+    decoder::get_crate_hash(cdata.data)\n }\n \n-pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n-    return decoder::get_crate_vers(cdata.data);\n+    decoder::get_crate_vers(cdata.data)\n }\n \n pub fn set_crate_data(cstore: @mut CStore,\n@@ -107,24 +107,24 @@ pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n     return /*bad*/copy cstore.used_crate_files;\n }\n \n-pub fn add_used_library(cstore: @mut CStore, +lib: ~str) -> bool {\n-    assert lib != ~\"\";\n+pub fn add_used_library(cstore: @mut CStore, lib: @~str) -> bool {\n+    assert *lib != ~\"\";\n \n-    if vec::contains(cstore.used_libraries, &lib) { return false; }\n-    cstore.used_libraries.push(lib);\n-    return true;\n+    if cstore.used_libraries.contains(&*lib) { return false; }\n+    cstore.used_libraries.push(/*bad*/ copy *lib);\n+    true\n }\n \n pub fn get_used_libraries(cstore: @mut CStore) -> ~[~str] {\n-    return /*bad*/copy cstore.used_libraries;\n+    /*bad*/copy cstore.used_libraries\n }\n \n pub fn add_used_link_args(cstore: @mut CStore, args: &str) {\n-    cstore.used_link_args.push_all(str::split_char(args, ' '));\n+    cstore.used_link_args.push_all(args.split_char(' '));\n }\n \n pub fn get_used_link_args(cstore: @mut CStore) -> ~[~str] {\n-    return /*bad*/copy cstore.used_link_args;\n+    /*bad*/copy cstore.used_link_args\n }\n \n pub fn add_extern_mod_stmt_cnum(cstore: @mut CStore,\n@@ -151,25 +151,18 @@ pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n     for extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        debug!(\"Add hash[%s]: %s\", cdata.name, hash);\n+        debug!(\"Add hash[%s]: %s\", *cdata.name, *hash);\n         result.push({name: /*bad*/copy cdata.name, hash: hash});\n     }\n \n-    pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {\n-        a.name <= b.name\n-    }\n+    let sorted = std::sort::merge_sort(result, |a, b| a.name <= b.name);\n \n-    let sorted = std::sort::merge_sort(result, lteq);\n     debug!(\"sorted:\");\n     for sorted.each |x| {\n-        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n-    }\n-\n-    fn mapper(ch: &crate_hash) -> ~str {\n-        return /*bad*/copy ch.hash;\n+        debug!(\"  hash[%s]: %s\", *x.name, *x.hash);\n     }\n \n-    return vec::map(sorted, mapper);\n+    sorted.map(|ch| /*bad*/copy *ch.hash)\n }\n \n // Local Variables:"}, {"sha": "980942f609b42cf8daf9478995ce2f4f218e2132", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -962,7 +962,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(reader::doc_data(nd));\n-        items.push(attr::mk_word_item(n));\n+        items.push(attr::mk_word_item(@n));\n     };\n     for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -971,13 +971,13 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n         let v = str::from_bytes(reader::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items.push(attr::mk_name_value_item_str(n, v));\n+        items.push(attr::mk_name_value_item_str(@n, @v));\n     };\n     for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(reader::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(n, subitems));\n+        items.push(attr::mk_list_item(@n, subitems));\n     };\n     return items;\n }\n@@ -1015,7 +1015,7 @@ fn list_meta_items(intr: @ident_interner,\n     }\n }\n \n-fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n+fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n@@ -1031,7 +1031,7 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n }\n \n pub type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                      vers: ~str, hash: ~str};\n+                      vers: @~str, hash: @~str};\n \n pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n@@ -1044,8 +1044,8 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n-                  vers: docstr(depdoc, tag_crate_dep_vers),\n-                  hash: docstr(depdoc, tag_crate_dep_hash)});\n+                  vers: @docstr(depdoc, tag_crate_dep_vers),\n+                  hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n     return deps;\n@@ -1057,25 +1057,26 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n     for get_crate_deps(intr, data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *intr.get(dep.name), dep.hash, dep.vers));\n+                 dep.cnum, *intr.get(dep.name), *dep.hash, *dep.vers));\n     }\n \n     out.write_str(~\"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> ~str {\n+pub fn get_crate_hash(data: @~[u8]) -> @~str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    return str::from_bytes(reader::doc_data(hashdoc));\n+    @str::from_bytes(reader::doc_data(hashdoc))\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> ~str {\n+pub fn get_crate_vers(data: @~[u8]) -> @~str {\n     let attrs = decoder::get_crate_attributes(data);\n-    return match attr::last_meta_item_value_str_by_name(\n-        attr::find_linkage_metas(attrs), ~\"vers\") {\n-      Some(ref ver) => (/*bad*/copy *ver),\n-      None => ~\"0.0\"\n-    };\n+    let linkage_attrs = attr::find_linkage_metas(attrs);\n+\n+    match attr::last_meta_item_value_str_by_name(linkage_attrs, ~\"vers\") {\n+        Some(ver) => ver,\n+        None => @~\"0.0\"\n+    }\n }\n \n fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n@@ -1096,7 +1097,7 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    list_crate_attributes(intr, md, hash, out);\n+    list_crate_attributes(intr, md, *hash, out);\n     list_crate_deps(intr, bytes, out);\n }\n "}, {"sha": "25d60ba7f3dad1b3d9f2901f466cb4aff0c7bd90", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -104,13 +104,13 @@ pub fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n }\n \n fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Encoder, name: ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n+    ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n-                         ecx.tcx.sess.str_of(name));\n+                         *ecx.tcx.sess.str_of(name));\n }\n \n pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n@@ -305,7 +305,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n           ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n \n-        ebml_w.wr_tagged_str(tag, ecx.tcx.sess.str_of(name));\n+        ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n     }\n \n     do ebml_w.wr_tag(tag_path) {\n@@ -333,7 +333,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?)\",\n-                        ecx.tcx.sess.str_of(ident),\n+                        *ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n                                                 .sess.parse_sess.interner));\n@@ -353,15 +353,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for (*exports).each |exp| {\n+            for exports.each |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n+                       *exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n                 ebml_w.wr_str(def_to_str(exp.def_id));\n                 ebml_w.end_tag();\n                 ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name);\n+                ebml_w.wr_str(*exp.name);\n                 ebml_w.end_tag();\n                 ebml_w.end_tag();\n             }\n@@ -447,7 +447,7 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         global_index.push({val: id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n-               tcx.sess.str_of(nm), id);\n+               *tcx.sess.str_of(nm), id);\n         encode_visibility(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n@@ -470,7 +470,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n-               ecx.tcx.sess.str_of(ident),\n+               *ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n@@ -515,7 +515,7 @@ fn encode_info_for_method(ecx: @encode_ctxt,\n                           m: @method,\n                           +all_tps: ~[ty_param]) {\n     debug!(\"encode_info_for_method: %d %s %u\", m.id,\n-           ecx.tcx.sess.str_of(m.ident), all_tps.len());\n+           *ecx.tcx.sess.str_of(m.ident), all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     match m.self_ty.node {\n@@ -678,7 +678,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                                ebml_w,\n                                dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n-                                   ecx.tcx.sess.str_of(item.ident) +\n+                                   *ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n                                path,\n                                if tps.len() > 0u {\n@@ -1017,19 +1017,19 @@ fn write_int(writer: io::Writer, &&n: int) {\n \n fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n     match mi.node {\n-      meta_word(ref name) => {\n+      meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes((*name)));\n+        ebml_w.writer.write(str::to_bytes(*name));\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n-      meta_name_value(ref name, value) => {\n+      meta_name_value(name, value) => {\n         match value.node {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::to_bytes((*name)));\n+            ebml_w.writer.write(str::to_bytes(*name));\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n             ebml_w.writer.write(str::to_bytes(*value));\n@@ -1039,10 +1039,10 @@ fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      meta_list(ref name, ref items) => {\n+      meta_list(name, ref items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::to_bytes((*name)));\n+        ebml_w.writer.write(str::to_bytes(*name));\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n             encode_meta_item(ebml_w, **inner_item);\n@@ -1075,11 +1075,11 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n         assert !ecx.link_meta.vers.is_empty();\n \n         let name_item =\n-            attr::mk_name_value_item_str(~\"name\",\n-                                         ecx.link_meta.name.to_owned());\n+            attr::mk_name_value_item_str(@~\"name\",\n+                                         @ecx.link_meta.name.to_owned());\n         let vers_item =\n-            attr::mk_name_value_item_str(~\"vers\",\n-                                         ecx.link_meta.vers.to_owned());\n+            attr::mk_name_value_item_str(@~\"vers\",\n+                                         @ecx.link_meta.vers.to_owned());\n \n         let other_items =\n             {\n@@ -1088,7 +1088,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n             };\n \n         let meta_items = vec::append(~[name_item, vers_item], other_items);\n-        let link_item = attr::mk_list_item(~\"link\", meta_items);\n+        let link_item = attr::mk_list_item(@~\"link\", meta_items);\n \n         return attr::mk_attr(link_item);\n     }\n@@ -1097,7 +1097,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n     let mut found_link_attr = false;\n     for crate.node.attrs.each |attr| {\n         attrs.push(\n-            if attr::get_attr_name(*attr) != ~\"link\" {\n+            if *attr::get_attr_name(attr) != ~\"link\" {\n                 /*bad*/copy *attr\n             } else {\n                 match /*bad*/copy attr.node.value.node {\n@@ -1124,20 +1124,17 @@ fn encode_crate_deps(ecx: @encode_ctxt,\n         type numdep = decoder::crate_dep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps: ~[numdep] = ~[];\n+        let mut deps = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n             let dep = {cnum: key,\n-                       name: ecx.tcx.sess.ident_of(/*bad*/copy val.name),\n+                       name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);\n         };\n \n         // Sort by cnum\n-        pure fn lteq(kv1: &numdep, kv2: &numdep) -> bool {\n-            kv1.cnum <= kv2.cnum\n-        }\n-        std::sort::quick_sort(deps, lteq);\n+        std::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n@@ -1147,7 +1144,7 @@ fn encode_crate_deps(ecx: @encode_ctxt,\n         }\n \n         // mut -> immutable hack for vec::map\n-        return vec::slice(deps, 0u, vec::len(deps)).to_vec();\n+        deps.slice(0, deps.len())\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with\n@@ -1189,13 +1186,13 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::to_bytes(ecx.tcx.sess.str_of(dep.name)));\n+    ebml_w.writer.write(str::to_bytes(*ecx.tcx.sess.str_of(dep.name)));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::to_bytes(dep.vers));\n+    ebml_w.writer.write(str::to_bytes(*dep.vers));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::to_bytes(dep.hash));\n+    ebml_w.writer.write(str::to_bytes(*dep.hash));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }"}, {"sha": "32aa474d360c8b27b15abb716f63186d0ef4e544", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -49,7 +49,7 @@ pub type ctxt = {\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n-    hash: ~str,\n+    hash: @~str,\n     os: os,\n     static: bool,\n     intr: @ident_interner\n@@ -91,7 +91,7 @@ fn find_library_crate_aux(cx: ctxt,\n                           filesearch: filesearch::FileSearch) ->\n    Option<{ident: ~str, data: @~[u8]}> {\n     let crate_name = crate_name_from_metas(/*bad*/copy cx.metas);\n-    let prefix: ~str = nn.prefix + crate_name + ~\"-\";\n+    let prefix: ~str = nn.prefix + *crate_name + ~\"-\";\n     let suffix: ~str = /*bad*/copy nn.suffix;\n \n     let mut matches = ~[];\n@@ -130,7 +130,7 @@ fn find_library_crate_aux(cx: ctxt,\n         Some(/*bad*/copy matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n+            cx.span, fmt!(\"multiple matching crates for `%s`\", *crate_name));\n         cx.diag.handler().note(~\"candidates:\");\n         for matches.each |match_| {\n             cx.diag.handler().note(fmt!(\"path: %s\", match_.ident));\n@@ -142,18 +142,18 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-pub fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n+pub fn crate_name_from_metas(+metas: &[@ast::meta_item]) -> @~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n-      Some(i) => {\n-        match attr::get_meta_item_value_str(i) {\n-          Some(ref n) => (/*bad*/copy *n),\n-          // FIXME (#2406): Probably want a warning here since the user\n-          // is using the wrong type of meta item.\n-          _ => fail!()\n+        Some(i) => {\n+            match attr::get_meta_item_value_str(i) {\n+                Some(n) => n,\n+                // FIXME (#2406): Probably want a warning here since the user\n+                // is using the wrong type of meta item.\n+                _ => fail!()\n+            }\n         }\n-      }\n-      None => fail!(~\"expected to find the crate name\")\n+        None => fail!(~\"expected to find the crate name\")\n     }\n }\n \n@@ -167,7 +167,7 @@ pub fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n \n fn crate_matches(crate_data: @~[u8],\n                  metas: &[@ast::meta_item],\n-                 hash: ~str) -> bool {\n+                 hash: @~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if !hash.is_empty() {"}, {"sha": "320a76332ead53bb1b355ecdba7c99cfc698bc2c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -175,7 +175,7 @@ fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n       }\n       ty::br_named(s) => {\n         w.write_char('[');\n-        w.write_str(cx.tcx.sess.str_of(s));\n+        w.write_str(*cx.tcx.sess.str_of(s));\n         w.write_char(']')\n       }\n       ty::br_cap_avoid(id, br) => {\n@@ -282,7 +282,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n       ty::ty_rec(fields) => {\n         w.write_str(&\"R[\");\n         for fields.each |field| {\n-            w.write_str(cx.tcx.sess.str_of(field.ident));\n+            w.write_str(*cx.tcx.sess.str_of(field.ident));\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n         }"}, {"sha": "427d4492897fce03304b6b2173370f81ce0ff343", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -96,7 +96,7 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n                            maps: Maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           ecx.tcx.sess.str_of(ii.ident()),\n+           *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n@@ -108,7 +108,7 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           ecx.tcx.sess.str_of(ii.ident()),\n+           *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n }\n \n@@ -132,10 +132,10 @@ pub fn decode_inlined_item(cdata: cstore::crate_metadata,\n                                           to_id_range: to_id_range});\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n+        debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n         debug!(\"< Decoded inlined fn: %s::%s\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n-               tcx.sess.str_of(ii.ident()));\n+               *tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, ii);\n         decode_side_tables(xcx, ast_doc);"}, {"sha": "85ed4e74efb71c63675d7e2367df8210f6ba4b1c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -134,39 +134,47 @@ pub fn raw_pat(p: @pat) -> @pat {\n pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert(!pats.is_empty());\n     let ext = match is_useful(cx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n-      not_useful => return, // This is good, wildcard pattern isn't reachable\n-      useful_ => None,\n-      useful(ty, ref ctor) => {\n-        match ty::get(ty).sty {\n-          ty::ty_bool => {\n-            match (*ctor) {\n-              val(const_bool(true)) => Some(~\"true\"),\n-              val(const_bool(false)) => Some(~\"false\"),\n-              _ => None\n-            }\n-          }\n-          ty::ty_enum(id, _) => {\n-              let vid = match (*ctor) { variant(id) => id,\n-              _ => fail!(~\"check_exhaustive: non-variant ctor\") };\n-            match vec::find(*ty::enum_variants(cx.tcx, id),\n-                                |v| v.id == vid) {\n-                Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n-              None => fail!(~\"check_exhaustive: bad variant in ctor\")\n-            }\n-          }\n-          ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-            match (*ctor) {\n-              vec(n) => Some(fmt!(\"vectors of length %u\", n)),\n-              _ => None\n+        not_useful => {\n+            // This is good, wildcard pattern isn't reachable\n+            return;\n+        }\n+        useful_ => None,\n+        useful(ty, ref ctor) => {\n+            match ty::get(ty).sty {\n+                ty::ty_bool => {\n+                    match (*ctor) {\n+                        val(const_bool(true)) => Some(@~\"true\"),\n+                        val(const_bool(false)) => Some(@~\"false\"),\n+                        _ => None\n+                    }\n+                }\n+                ty::ty_enum(id, _) => {\n+                    let vid = match *ctor {\n+                        variant(id) => id,\n+                        _ => fail!(~\"check_exhaustive: non-variant ctor\"),\n+                    };\n+                    let variants = ty::enum_variants(cx.tcx, id);\n+\n+                    match variants.find(|v| v.id == vid) {\n+                        Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n+                        None => {\n+                            fail!(~\"check_exhaustive: bad variant in ctor\")\n+                        }\n+                    }\n+                }\n+                ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+                    match *ctor {\n+                        vec(n) => Some(@fmt!(\"vectors of length %u\", n)),\n+                    _ => None\n+                    }\n+                }\n+                _ => None\n             }\n-          }\n-          _ => None\n         }\n-      }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-      Some(ref s) => ~\": \" + (*s) + ~\" not covered\",\n-      None => ~\"\"\n+        Some(ref s) => ~\": \" + **s + ~\" not covered\",\n+        None => ~\"\"\n     };\n     cx.tcx.sess.span_err(sp, msg);\n }"}, {"sha": "983ee2ca141df6b497586920c938eaf06c03967b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -256,45 +256,46 @@ fn LanguageItemCollector(crate: @crate,\n                       -> LanguageItemCollector/&r {\n     let item_refs = HashMap();\n \n-    item_refs.insert(~\"const\", ConstTraitLangItem as uint);\n-    item_refs.insert(~\"copy\", CopyTraitLangItem as uint);\n-    item_refs.insert(~\"owned\", OwnedTraitLangItem as uint);\n-    item_refs.insert(~\"durable\", DurableTraitLangItem as uint);\n-\n-    item_refs.insert(~\"drop\", DropTraitLangItem as uint);\n-\n-    item_refs.insert(~\"add\", AddTraitLangItem as uint);\n-    item_refs.insert(~\"sub\", SubTraitLangItem as uint);\n-    item_refs.insert(~\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(~\"div\", DivTraitLangItem as uint);\n-    item_refs.insert(~\"modulo\", ModuloTraitLangItem as uint);\n-    item_refs.insert(~\"neg\", NegTraitLangItem as uint);\n-    item_refs.insert(~\"not\", NotTraitLangItem as uint);\n-    item_refs.insert(~\"bitxor\", BitXorTraitLangItem as uint);\n-    item_refs.insert(~\"bitand\", BitAndTraitLangItem as uint);\n-    item_refs.insert(~\"bitor\", BitOrTraitLangItem as uint);\n-    item_refs.insert(~\"shl\", ShlTraitLangItem as uint);\n-    item_refs.insert(~\"shr\", ShrTraitLangItem as uint);\n-    item_refs.insert(~\"index\", IndexTraitLangItem as uint);\n-\n-    item_refs.insert(~\"eq\", EqTraitLangItem as uint);\n-    item_refs.insert(~\"ord\", OrdTraitLangItem as uint);\n-\n-    item_refs.insert(~\"str_eq\", StrEqFnLangItem as uint);\n-    item_refs.insert(~\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n-    item_refs.insert(~\"annihilate\", AnnihilateFnLangItem as uint);\n-    item_refs.insert(~\"log_type\", LogTypeFnLangItem as uint);\n-    item_refs.insert(~\"fail_\", FailFnLangItem as uint);\n-    item_refs.insert(~\"fail_bounds_check\", FailBoundsCheckFnLangItem as uint);\n-    item_refs.insert(~\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n-    item_refs.insert(~\"exchange_free\", ExchangeFreeFnLangItem as uint);\n-    item_refs.insert(~\"malloc\", MallocFnLangItem as uint);\n-    item_refs.insert(~\"free\", FreeFnLangItem as uint);\n-    item_refs.insert(~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n-    item_refs.insert(~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n-    item_refs.insert(~\"check_not_borrowed\",\n+    item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n+    item_refs.insert(@~\"copy\", CopyTraitLangItem as uint);\n+    item_refs.insert(@~\"owned\", OwnedTraitLangItem as uint);\n+    item_refs.insert(@~\"durable\", DurableTraitLangItem as uint);\n+\n+    item_refs.insert(@~\"drop\", DropTraitLangItem as uint);\n+\n+    item_refs.insert(@~\"add\", AddTraitLangItem as uint);\n+    item_refs.insert(@~\"sub\", SubTraitLangItem as uint);\n+    item_refs.insert(@~\"mul\", MulTraitLangItem as uint);\n+    item_refs.insert(@~\"div\", DivTraitLangItem as uint);\n+    item_refs.insert(@~\"modulo\", ModuloTraitLangItem as uint);\n+    item_refs.insert(@~\"neg\", NegTraitLangItem as uint);\n+    item_refs.insert(@~\"not\", NotTraitLangItem as uint);\n+    item_refs.insert(@~\"bitxor\", BitXorTraitLangItem as uint);\n+    item_refs.insert(@~\"bitand\", BitAndTraitLangItem as uint);\n+    item_refs.insert(@~\"bitor\", BitOrTraitLangItem as uint);\n+    item_refs.insert(@~\"shl\", ShlTraitLangItem as uint);\n+    item_refs.insert(@~\"shr\", ShrTraitLangItem as uint);\n+    item_refs.insert(@~\"index\", IndexTraitLangItem as uint);\n+\n+    item_refs.insert(@~\"eq\", EqTraitLangItem as uint);\n+    item_refs.insert(@~\"ord\", OrdTraitLangItem as uint);\n+\n+    item_refs.insert(@~\"str_eq\", StrEqFnLangItem as uint);\n+    item_refs.insert(@~\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n+    item_refs.insert(@~\"annihilate\", AnnihilateFnLangItem as uint);\n+    item_refs.insert(@~\"log_type\", LogTypeFnLangItem as uint);\n+    item_refs.insert(@~\"fail_\", FailFnLangItem as uint);\n+    item_refs.insert(@~\"fail_bounds_check\",\n+                     FailBoundsCheckFnLangItem as uint);\n+    item_refs.insert(@~\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+    item_refs.insert(@~\"exchange_free\", ExchangeFreeFnLangItem as uint);\n+    item_refs.insert(@~\"malloc\", MallocFnLangItem as uint);\n+    item_refs.insert(@~\"free\", FreeFnLangItem as uint);\n+    item_refs.insert(@~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+    item_refs.insert(@~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n+    item_refs.insert(@~\"check_not_borrowed\",\n                      CheckNotBorrowedFnLangItem as uint);\n-    item_refs.insert(~\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+    item_refs.insert(@~\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,\n@@ -310,19 +311,17 @@ struct LanguageItemCollector {\n     crate: @crate,\n     session: Session,\n \n-    item_refs: HashMap<~str,uint>,\n+    item_refs: HashMap<@~str, uint>,\n }\n \n impl LanguageItemCollector {\n     fn match_and_collect_meta_item(item_def_id: def_id,\n                                    meta_item: meta_item) {\n         match meta_item.node {\n-            meta_name_value(ref key, literal) => {\n+            meta_name_value(key, literal) => {\n                 match literal.node {\n                     lit_str(value) => {\n-                        self.match_and_collect_item(item_def_id,\n-                                                    (/*bad*/copy *key),\n-                                                    /*bad*/copy *value);\n+                        self.match_and_collect_item(item_def_id, key, value);\n                     }\n                     _ => {} // Skip.\n                 }\n@@ -347,8 +346,8 @@ impl LanguageItemCollector {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    fn match_and_collect_item(item_def_id: def_id, key: ~str, value: ~str) {\n-        if key != ~\"lang\" {\n+    fn match_and_collect_item(item_def_id: def_id, key: @~str, value: @~str) {\n+        if *key != ~\"lang\" {\n             return;    // Didn't match.\n         }\n \n@@ -394,7 +393,7 @@ impl LanguageItemCollector {\n         for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n-                    self.session.err(fmt!(\"no item found for `%s`\", key));\n+                    self.session.err(fmt!(\"no item found for `%s`\", *key));\n                 }\n                 Some(_) => {\n                     // OK."}, {"sha": "70eb937678e2c6e7028d6feef7e9b79bd2424b34", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -117,117 +117,117 @@ type lint_spec = @{lint: lint,\n                    desc: &static/str,\n                    default: level};\n \n-pub type lint_dict = HashMap<~str,lint_spec>;\n+pub type lint_dict = HashMap<@~str, lint_spec>;\n \n /*\n   Pass names should not contain a '-', as the compiler normalizes\n   '-' to '_' in command-line flags\n  */\n pub fn get_lint_dict() -> lint_dict {\n     let v = ~[\n-        (~\"ctypes\",\n+        (@~\"ctypes\",\n          @{lint: ctypes,\n            desc: \"proper use of core::libc types in foreign modules\",\n            default: warn}),\n \n-        (~\"unused_imports\",\n+        (@~\"unused_imports\",\n          @{lint: unused_imports,\n            desc: \"imports that are never used\",\n            default: allow}),\n \n-        (~\"while_true\",\n+        (@~\"while_true\",\n          @{lint: while_true,\n            desc: \"suggest using loop { } instead of while(true) { }\",\n            default: warn}),\n \n-        (~\"path_statement\",\n+        (@~\"path_statement\",\n          @{lint: path_statement,\n            desc: \"path statements with no effect\",\n            default: warn}),\n \n-        (~\"unrecognized_lint\",\n+        (@~\"unrecognized_lint\",\n          @{lint: unrecognized_lint,\n            desc: \"unrecognized lint attribute\",\n            default: warn}),\n \n-        (~\"non_implicitly_copyable_typarams\",\n+        (@~\"non_implicitly_copyable_typarams\",\n          @{lint: non_implicitly_copyable_typarams,\n            desc: \"passing non implicitly copyable types as copy type params\",\n            default: warn}),\n \n-        (~\"vecs_implicitly_copyable\",\n+        (@~\"vecs_implicitly_copyable\",\n          @{lint: vecs_implicitly_copyable,\n            desc: \"make vecs and strs not implicitly copyable \\\n                   (only checked at top level)\",\n            default: warn}),\n \n-        (~\"implicit_copies\",\n+        (@~\"implicit_copies\",\n          @{lint: implicit_copies,\n            desc: \"implicit copies of non implicitly copyable data\",\n            default: warn}),\n \n-        (~\"deprecated_mode\",\n+        (@~\"deprecated_mode\",\n          @{lint: deprecated_mode,\n            desc: \"warn about deprecated uses of modes\",\n            default: warn}),\n \n-        (~\"deprecated_pattern\",\n+        (@~\"deprecated_pattern\",\n          @{lint: deprecated_pattern,\n            desc: \"warn about deprecated uses of pattern bindings\",\n            default: allow}),\n \n-        (~\"non_camel_case_types\",\n+        (@~\"non_camel_case_types\",\n          @{lint: non_camel_case_types,\n            desc: \"types, variants and traits should have camel case names\",\n            default: allow}),\n \n-        (~\"managed_heap_memory\",\n+        (@~\"managed_heap_memory\",\n          @{lint: managed_heap_memory,\n            desc: \"use of managed (@ type) heap memory\",\n            default: allow}),\n \n-        (~\"owned_heap_memory\",\n+        (@~\"owned_heap_memory\",\n          @{lint: owned_heap_memory,\n            desc: \"use of owned (~ type) heap memory\",\n            default: allow}),\n \n-        (~\"heap_memory\",\n+        (@~\"heap_memory\",\n          @{lint: heap_memory,\n            desc: \"use of any (~ type or @ type) heap memory\",\n            default: allow}),\n \n-        (~\"structural_records\",\n+        (@~\"structural_records\",\n          @{lint: structural_records,\n            desc: \"use of any structural records\",\n            default: deny}),\n \n-        (~\"legacy modes\",\n+        (@~\"legacy modes\",\n          @{lint: legacy_modes,\n            desc: \"allow legacy modes\",\n            default: forbid}),\n \n-        (~\"type_limits\",\n+        (@~\"type_limits\",\n          @{lint: type_limits,\n            desc: \"comparisons made useless by limits of the types involved\",\n            default: warn}),\n \n-        (~\"default_methods\",\n+        (@~\"default_methods\",\n          @{lint: default_methods,\n            desc: \"allow default methods\",\n            default: deny}),\n \n-        (~\"deprecated_self\",\n+        (@~\"deprecated_self\",\n          @{lint: deprecated_self,\n            desc: \"warn about deprecated uses of `self`\",\n            default: warn}),\n \n         /* FIXME(#3266)--make liveness warnings lintable\n-        (~\"unused_variable\",\n+        (@~\"unused_variable\",\n          @{lint: unused_variable,\n            desc: \"detect variables which are not used in any way\",\n            default: warn}),\n \n-        (~\"dead_assignment\",\n+        (@~\"dead_assignment\",\n          @{lint: dead_assignment,\n            desc: \"detect assignments that will never be read\",\n            default: warn}),\n@@ -344,15 +344,20 @@ impl ctxt {\n             }\n         }\n \n-        for triples.each |pair| {\n-            let (meta, level, lintname) = /*bad*/copy *pair;\n+        for triples.each |triple| {\n+            // FIXME(#3874): it would be nicer to write this...\n+            // let (meta, level, lintname) = /*bad*/copy *pair;\n+            let (meta, level, lintname) = match *triple {\n+                (ref meta, level, lintname) => (meta, level, lintname)\n+            };\n+\n             match self.dict.find(&lintname) {\n               None => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n                     meta.span,\n                     fmt!(\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), lintname));\n+                         level_to_str(level), *lintname));\n               }\n               Some(lint) => {\n \n@@ -363,7 +368,7 @@ impl ctxt {\n                         meta.span,\n                         fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n                              level_to_str(level),\n-                             lintname, lintname));\n+                             *lintname, *lintname));\n                 }\n \n                 // we do multiple unneeded copies of the\n@@ -829,26 +834,23 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert !ident.is_empty();\n-        let ident = ident_without_trailing_underscores(ident);\n+        let ident = ident_without_trailing_underscores(*ident);\n         let ident = ident_without_leading_underscores(ident);\n         char::is_uppercase(str::char_at(ident, 0)) &&\n             !ident.contains_char('_')\n     }\n \n-    fn ident_without_trailing_underscores(+ident: ~str) -> ~str {\n+    fn ident_without_trailing_underscores(ident: &r/str) -> &r/str {\n         match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => (ident).slice(0, idx + 1),\n-            None => { ident } // all underscores\n+            Some(idx) => str::view(ident, 0, idx + 1),\n+            None => ident, // all underscores\n         }\n     }\n \n-    fn ident_without_leading_underscores(+ident: ~str) -> ~str {\n+    fn ident_without_leading_underscores(ident: &r/str) -> &r/str {\n         match str::find(ident, |c| c != '_') {\n-          Some(idx) => ident.slice(idx, ident.len()),\n-          None => {\n-            // all underscores\n-            ident\n-          }\n+            Some(idx) => str::view(ident, idx, ident.len()),\n+            None => ident // all underscores\n         }\n     }\n \n@@ -864,18 +866,18 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n \n     match it.node {\n-      ast::item_ty(*) | ast::item_struct(*) |\n-      ast::item_trait(*) => {\n-        check_case(cx, it.ident, it.id, it.id, it.span)\n-      }\n-      ast::item_enum(ref enum_definition, _) => {\n-        check_case(cx, it.ident, it.id, it.id, it.span);\n-        for enum_definition.variants.each |variant| {\n-            check_case(cx, variant.node.name,\n-                       variant.node.id, it.id, variant.span);\n+        ast::item_ty(*) | ast::item_struct(*) |\n+        ast::item_trait(*) => {\n+            check_case(cx, it.ident, it.id, it.id, it.span)\n         }\n-      }\n-      _ => ()\n+        ast::item_enum(ref enum_definition, _) => {\n+            check_case(cx, it.ident, it.id, it.id, it.span);\n+            for enum_definition.variants.each |variant| {\n+                check_case(cx, variant.node.name,\n+                           variant.node.id, it.id, variant.span);\n+            }\n+        }\n+        _ => ()\n     }\n }\n "}, {"sha": "a7cfde0e70fec39b6ba266a2d99fdb34d5d74af8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -383,11 +383,11 @@ impl IrMaps {\n         }\n     }\n \n-    fn variable_name(&mut self, var: Variable) -> ~str {\n+    fn variable_name(&mut self, var: Variable) -> @~str {\n         match copy self.var_kinds[*var] {\n             Local(LocalInfo {ident: nm, _}) |\n             Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n-            ImplicitRet => ~\"<implicit-ret>\"\n+            ImplicitRet => @~\"<implicit-ret>\"\n         }\n     }\n \n@@ -1777,7 +1777,7 @@ impl @Liveness {\n                 self.tcx.sess.span_err(\n                     move_expr.span,\n                     fmt!(\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", self.tcx.sess.str_of(name)));\n+                          copy or move mode\", *self.tcx.sess.str_of(name)));\n                 return;\n               }\n               Local(*) | ImplicitRet => {\n@@ -1798,7 +1798,7 @@ impl @Liveness {\n                     move_expr.span,\n                     fmt!(\"`%s` moved into closure environment here \\\n                           because its type is moved by default\",\n-                         name));\n+                         *name));\n             }\n             expr_path(*) => {\n                 self.report_illegal_read(\n@@ -1838,7 +1838,7 @@ impl @Liveness {\n             move_expr.span,\n             fmt!(\"%s`%s` moved here because %s has type %s, \\\n                   which is moved by default (use `copy` to override)\",\n-                 expr_descr, name, pronoun,\n+                 expr_descr, *name, pronoun,\n                  ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n@@ -1858,12 +1858,12 @@ impl @Liveness {\n           FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"capture of %s: `%s`\", msg, name));\n+                fmt!(\"capture of %s: `%s`\", msg, *name));\n           }\n           ExprNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"use of %s: `%s`\", msg, name));\n+                fmt!(\"use of %s: `%s`\", msg, *name));\n           }\n           ExitNode | VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n@@ -1873,9 +1873,9 @@ impl @Liveness {\n         }\n     }\n \n-    fn should_warn(var: Variable) -> Option<~str> {\n+    fn should_warn(var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n-        if name[0] == ('_' as u8) {None} else {Some(name)}\n+        if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n     fn warn_about_unused_args(decl: fn_decl, entry_ln: LiveNode) {\n@@ -1913,11 +1913,11 @@ impl @Liveness {\n                     // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n                         sp, fmt!(\"variable `%s` is assigned to, \\\n-                                  but never used\", *name));\n+                                  but never used\", **name));\n                 } else {\n                     // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n-                        sp, fmt!(\"unused variable: `%s`\", *name));\n+                        sp, fmt!(\"unused variable: `%s`\", **name));\n                 }\n             }\n             return true;\n@@ -1931,7 +1931,7 @@ impl @Liveness {\n                 // FIXME(#3266)--make liveness warnings lintable\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    fmt!(\"value assigned to `%s` is never read\", *name));\n+                    fmt!(\"value assigned to `%s` is never read\", **name));\n             }\n         }\n     }"}, {"sha": "1c48df115e544dd4af6f8b3218fafb239217846f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -629,7 +629,7 @@ pub impl mem_categorization_ctxt {\n                 self.tcx.sess.span_bug(\n                     node.span(),\n                     fmt!(\"Cannot find field `%s` in type `%s`\",\n-                         self.tcx.sess.str_of(f_name),\n+                         *self.tcx.sess.str_of(f_name),\n                          ty_to_str(self.tcx, base_cmt.ty)));\n             }\n         };\n@@ -995,7 +995,7 @@ pub impl mem_categorization_ctxt {\n                  self.ptr_sigil(ptr), derefs)\n           }\n           cat_comp(cmt, comp) => {\n-            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp))\n+            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), *self.comp_to_repr(comp))\n           }\n           cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n         }\n@@ -1018,13 +1018,13 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn comp_to_repr(&self, comp: comp_kind) -> ~str {\n+    fn comp_to_repr(&self, comp: comp_kind) -> @~str {\n         match comp {\n           comp_field(fld, _) => self.tcx.sess.str_of(fld),\n-          comp_index(*) => ~\"[]\",\n-          comp_tuple => ~\"()\",\n-          comp_anon_field => ~\"<anonymous field>\",\n-          comp_variant(_) => ~\"<enum>\"\n+          comp_index(*) => @~\"[]\",\n+          comp_tuple => @~\"()\",\n+          comp_anon_field => @~\"<anonymous field>\",\n+          comp_variant(_) => @~\"<enum>\"\n         }\n     }\n \n@@ -1043,7 +1043,7 @@ pub impl mem_categorization_ctxt {\n           }\n           lp_comp(lp, comp) => {\n             fmt!(\"%s.%s\", self.lp_to_str(lp),\n-                 self.comp_to_repr(comp))\n+                 *self.comp_to_repr(comp))\n           }\n         }\n     }"}, {"sha": "e436d73aa7a934a0fdb95421f96d64075ea9fd42", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -116,7 +116,7 @@ pub type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n pub type ExportMap2 = HashMap<node_id, ~[Export2]>;\n \n pub struct Export2 {\n-    name: ~str,         // The name of the target.\n+    name: @~str,        // The name of the target.\n     def_id: def_id,     // The definition of the target.\n     reexport: bool,     // Whether this is a reexport.\n }\n@@ -1006,12 +1006,12 @@ pub impl Resolver {\n                     self.session.span_err(sp,\n                         fmt!(\"duplicate definition of %s %s\",\n                              namespace_to_str(ns),\n-                             self.session.str_of(name)));\n+                             *self.session.str_of(name)));\n                     do child.span_for_namespace(ns).iter() |sp| {\n                         self.session.span_note(*sp,\n                              fmt!(\"first definition of %s %s here:\",\n                                   namespace_to_str(ns),\n-                                  self.session.str_of(name)));\n+                                  *self.session.str_of(name)));\n                     }\n                 }\n                 return (child, new_parent);\n@@ -1549,7 +1549,7 @@ pub impl Resolver {\n     fn handle_external_def(def: def,\n                            modules: HashMap<def_id, @Module>,\n                            child_name_bindings: @mut NameBindings,\n-                           final_ident: ~str,\n+                           final_ident: &str,\n                            ident: ident,\n                            new_parent: ReducedGraphParent) {\n         match def {\n@@ -1634,7 +1634,7 @@ pub impl Resolver {\n                     debug!(\"(building reduced graph for \\\n                             external crate) ... adding \\\n                             trait method '%s'\",\n-                           self.session.str_of(method_name));\n+                           *self.session.str_of(method_name));\n \n                     // Add it to the trait info if not static.\n                     if self_ty != sty_static {\n@@ -1741,7 +1741,8 @@ pub impl Resolver {\n                     self.handle_external_def(def,\n                                              modules,\n                                              child_name_bindings,\n-                                             self.session.str_of(final_ident),\n+                                             *self.session.str_of(\n+                                                 final_ident),\n                                              final_ident,\n                                              new_parent);\n                 }\n@@ -1759,7 +1760,8 @@ pub impl Resolver {\n                                     debug!(\"(building reduced graph for \\\n                                             external crate) processing \\\n                                             static methods for type name %s\",\n-                                            self.session.str_of(final_ident));\n+                                            *self.session.str_of(\n+                                                final_ident));\n \n                                     let (child_name_bindings, new_parent) =\n                                         self.add_child(final_ident,\n@@ -1805,7 +1807,7 @@ pub impl Resolver {\n                                         debug!(\"(building reduced graph for \\\n                                                  external crate) creating \\\n                                                  static method '%s'\",\n-                                               self.session.str_of(ident));\n+                                               *self.session.str_of(ident));\n \n                                         let (method_name_bindings, _) =\n                                             self.add_child(\n@@ -1855,7 +1857,7 @@ pub impl Resolver {\n                         directive: privacy %? %s::%s\",\n                        privacy,\n                        self.idents_to_str(module_path.get()),\n-                       self.session.str_of(target));\n+                       *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n                     Some(resolution) => {\n@@ -1971,8 +1973,8 @@ pub impl Resolver {\n                     // We presumably emitted an error. Continue.\n                     let idents = import_directive.module_path.get();\n                     let msg = fmt!(\"failed to resolve import: %s\",\n-                                   self.import_path_to_str(idents,\n-                                   *import_directive.subclass));\n+                                   *self.import_path_to_str(idents,\n+                                       *import_directive.subclass));\n                     self.session.span_err(import_directive.span, msg);\n                 }\n                 Indeterminate => {\n@@ -1989,26 +1991,28 @@ pub impl Resolver {\n     }\n \n     fn idents_to_str(idents: ~[ident]) -> ~str {\n-        let ident_strs = idents.map(|&ident| self.session.str_of(ident));\n-        return str::connect(ident_strs, \"::\");\n+        let ident_strs = do idents.map |ident| {\n+            /*bad*/ copy *self.session.str_of(*ident)\n+        };\n+        str::connect(ident_strs, \"::\")\n     }\n \n     fn import_directive_subclass_to_str(subclass: ImportDirectiveSubclass)\n-                                                                     -> ~str {\n+                                                                    -> @~str {\n         match subclass {\n             SingleImport(_target, source, _ns) => self.session.str_of(source),\n-            GlobImport => ~\"*\"\n+            GlobImport => @~\"*\"\n         }\n     }\n \n     fn import_path_to_str(idents: ~[ident], subclass: ImportDirectiveSubclass)\n-                                                                     -> ~str {\n+                                                                    -> @~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n-            fmt!(\"%s::%s\",\n+            @fmt!(\"%s::%s\",\n                  self.idents_to_str(idents),\n-                 self.import_directive_subclass_to_str(subclass))\n+                 *self.import_directive_subclass_to_str(subclass))\n         }\n     }\n \n@@ -2122,9 +2126,9 @@ pub impl Resolver {\n \n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n-               self.session.str_of(target),\n+               *self.session.str_of(target),\n                self.module_to_str(containing_module),\n-               self.session.str_of(source),\n+               *self.session.str_of(source),\n                self.module_to_str(module_));\n \n         // We need to resolve both namespaces for this to succeed.\n@@ -2314,9 +2318,9 @@ pub impl Resolver {\n \n         debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n                 from `%s`\",\n-               self.session.str_of(target),\n+               *self.session.str_of(target),\n                self.module_to_str(containing_module),\n-               self.session.str_of(source),\n+               *self.session.str_of(source),\n                self.module_to_str(module_));\n \n         // We need to resolve the module namespace for this to succeed.\n@@ -2527,7 +2531,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   self.session.str_of(ident),\n+                   *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    dest_import_resolution.privacy);\n@@ -2575,7 +2579,7 @@ pub impl Resolver {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n-                            self.session.str_of(name));\n+                            *self.session.str_of(name));\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n@@ -2589,7 +2593,7 @@ pub impl Resolver {\n                                     self.session.span_err(span,\n                                                           fmt!(\"not a \\\n                                                                 module: %s\",\n-                                                               self.session.\n+                                                               *self.session.\n                                                                    str_of(\n                                                                     name)));\n                                     return Failed;\n@@ -2603,7 +2607,7 @@ pub impl Resolver {\n                             // There are no type bindings at all.\n                             self.session.span_err(span,\n                                                   fmt!(\"not a module: %s\",\n-                                                       self.session.str_of(\n+                                                       *self.session.str_of(\n                                                             name)));\n                             return Failed;\n                         }\n@@ -2709,7 +2713,7 @@ pub impl Resolver {\n \n         debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n-               self.session.str_of(name),\n+               *self.session.str_of(name),\n                namespace,\n                self.module_to_str(module_));\n \n@@ -2949,7 +2953,7 @@ pub impl Resolver {\n                               allow_globs: bool)\n                            -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n-               self.session.str_of(name),\n+               *self.session.str_of(name),\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n@@ -3003,7 +3007,7 @@ pub impl Resolver {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve %s\",\n-               self.session.str_of(name));\n+               *self.session.str_of(name));\n         return Failed;\n     }\n \n@@ -3032,8 +3036,8 @@ pub impl Resolver {\n \n         debug!(\"(resolving one-level naming result) resolving import `%s` = \\\n                 `%s` in `%s`\",\n-                self.session.str_of(target_name),\n-                self.session.str_of(source_name),\n+                *self.session.str_of(target_name),\n+                *self.session.str_of(source_name),\n                 self.module_to_str(module_));\n \n         // Find the matching items in the lexical scope chain for every\n@@ -3154,7 +3158,7 @@ pub impl Resolver {\n                 debug!(\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n                        is_none(&module_result),\n-                       self.session.str_of(target_name),\n+                       *self.session.str_of(target_name),\n                        self.module_to_str(module_));\n \n                 import_resolution.value_target = value_result;\n@@ -3275,7 +3279,7 @@ pub impl Resolver {\n             (Some(d), Some(Public)) => {\n                 debug!(\"(computing exports) YES: %s '%s' => %?\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n-                       self.session.str_of(ident),\n+                       *self.session.str_of(ident),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n                     reexport: reexport,\n@@ -3295,7 +3299,7 @@ pub impl Resolver {\n     fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n         for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n-                   self.session.str_of(*ident));\n+                   *self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n                                              *ident,\n                                              *namebindings,\n@@ -3311,14 +3315,14 @@ pub impl Resolver {\n         for module_.import_resolutions.each |ident, importresolution| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n-                       self.session.str_of(*ident));\n+                       *self.session.str_of(*ident));\n                 loop;\n             }\n             for [ TypeNS, ValueNS ].each |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n-                               self.session.str_of(*ident));\n+                               *self.session.str_of(*ident));\n                         self.add_exports_of_namebindings(&mut *exports2,\n                                                          *ident,\n                                                          target.bindings,\n@@ -3361,15 +3365,15 @@ pub impl Resolver {\n                 match orig_module.children.find(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n-                               self.session.str_of(name),\n+                               *self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n-                                       self.session.str_of(name),\n+                                       *self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n                             }\n                             Some(module_) => {\n@@ -3543,7 +3547,7 @@ pub impl Resolver {\n \n     fn resolve_item(item: @item, visitor: ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n-               self.session.str_of(item.ident));\n+               *self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n@@ -4105,15 +4109,15 @@ pub impl Resolver {\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             self.session.str_of(key), i + 1));\n+                             *self.session.str_of(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.session.span_err(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 self.session.str_of(key), i + 1));\n+                                 *self.session.str_of(key), i + 1));\n                     }\n                   }\n                 }\n@@ -4125,7 +4129,7 @@ pub impl Resolver {\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             self.session.str_of(key), i + 1));\n+                             *self.session.str_of(key), i + 1));\n                 }\n             }\n         }\n@@ -4209,7 +4213,7 @@ pub impl Resolver {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n-                                       self.session.str_of(\n+                                       *self.session.str_of(\n                                             path.idents.last()),\n                                        def);\n                                 result_def = Some(def);\n@@ -4278,7 +4282,7 @@ pub impl Resolver {\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     struct or enum variant\",\n-                                    self.session.str_of(ident));\n+                                    *self.session.str_of(ident));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4292,13 +4296,13 @@ pub impl Resolver {\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                        self.session\n-                                                        .str_of(ident)));\n+                                                        *self.session\n+                                                            .str_of(ident)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     constant\",\n-                                    self.session.str_of(ident));\n+                                    *self.session.str_of(ident));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4313,7 +4317,7 @@ pub impl Resolver {\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n-                                   self.session.str_of(ident));\n+                                   *self.session.str_of(ident));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -4395,7 +4399,7 @@ pub impl Resolver {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"not an enum variant: %s\",\n-                                     self.session.str_of(\n+                                     *self.session.str_of(\n                                          path.idents.last())));\n                         }\n                         None => {\n@@ -4736,7 +4740,7 @@ pub impl Resolver {\n             Some(dl_def(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n-                       self.session.str_of(ident),\n+                       *self.session.str_of(ident),\n                        def);\n                 return Some(def);\n             }\n@@ -4764,7 +4768,7 @@ pub impl Resolver {\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n-                               self.session.str_of(ident));\n+                               *self.session.str_of(ident));\n                         return Some(def);\n                     }\n                 }\n@@ -4785,15 +4789,15 @@ pub impl Resolver {\n           let rib = self.type_ribs.get_elt(i);\n           match rib.kind {\n             MethodRibKind(node_id, _) =>\n-              for vec::each(self.crate.node.module.items) |item| {\n+              for self.crate.node.module.items.each |item| {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n                       for vec::each(class_def.fields) |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _, _) => {\n-                              if str::eq_slice(self.session.str_of(ident),\n+                              if str::eq_slice(*self.session.str_of(ident),\n                                                name) {\n                                 return true\n                               }\n@@ -4902,8 +4906,9 @@ pub impl Resolver {\n                     None =>\n                         self.session.span_err(expr.span,\n                                               fmt!(\"use of undeclared label \\\n-                                                   `%s`\", self.session.str_of(\n-                                                  label))),\n+                                                   `%s`\",\n+                                                   *self.session.str_of(\n+                                                       label))),\n                     Some(dl_def(def @ def_label(_))) =>\n                         self.record_def(expr.id, def),\n                     Some(_) =>\n@@ -4998,7 +5003,7 @@ pub impl Resolver {\n \n     fn search_for_traits_containing_method(name: ident) -> @DVec<def_id> {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n-               self.session.str_of(name));\n+               *self.session.str_of(name));\n \n         let found_traits = @DVec();\n         let mut search_module = self.current_module;\n@@ -5094,15 +5099,15 @@ pub impl Resolver {\n                 for method '%s'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n-               self.session.str_of(name));\n+               *self.session.str_of(name));\n \n         match self.trait_info.find(&trait_def_id) {\n             Some(trait_info) if trait_info.contains_key(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n                        trait_def_id.node,\n-                       self.session.str_of(name));\n+                       *self.session.str_of(name));\n                 (*found_traits).push(trait_def_id);\n                 true\n             }\n@@ -5289,7 +5294,7 @@ pub impl Resolver {\n \n         debug!(\"Children:\");\n         for module_.children.each_key |&name| {\n-            debug!(\"* %s\", self.session.str_of(name));\n+            debug!(\"* %s\", *self.session.str_of(name));\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5312,7 +5317,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", self.session.str_of(name),\n+            debug!(\"* %s:%s%s\", *self.session.str_of(name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "a6813997ae8335433120186962917f0d139c6d89", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -1629,7 +1629,7 @@ pub fn trans_match_inner(scope_cx: block,\n             // Special case for empty types\n             let fail_cx = @mut None;\n             let f: mk_fail = || mk_fail(scope_cx, discr_expr.span,\n-                            ~\"scrutinizing value that can't exist\", fail_cx);\n+                            @~\"scrutinizing value that can't exist\", fail_cx);\n             Some(f)\n         } else {\n             None\n@@ -1661,7 +1661,7 @@ pub fn trans_match_inner(scope_cx: block,\n     bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(arm_cxs));\n     return bcx;\n \n-    fn mk_fail(bcx: block, sp: span, +msg: ~str,\n+    fn mk_fail(bcx: block, sp: span, msg: @~str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, ~\"case_fallthrough\");"}, {"sha": "16fdebff5589d932b494f01d60ba1ea9bbb25c28", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -521,7 +521,7 @@ pub fn compare_scalar_types(cx: block,\n             rslt(\n                 controlflow::trans_fail(\n                     cx, None,\n-                    ~\"attempt to compare values of type type\"),\n+                    @~\"attempt to compare values of type type\"),\n                 C_nil())\n         }\n         _ => {\n@@ -639,7 +639,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           _ => cx.tcx().sess.bug(fmt!(\"iter_variant: not a function type: \\\n                                        %s (variant name = %s)\",\n                                       cx.ty_to_str(fn_ty),\n-                                      cx.sess().str_of(variant.name)))\n+                                      *cx.sess().str_of(variant.name)))\n         }\n         return cx;\n     }\n@@ -776,7 +776,7 @@ pub fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n       }\n     };\n     do with_cond(cx, is_zero) |bcx| {\n-        controlflow::trans_fail(bcx, Some(span), /*bad*/copy text)\n+        controlflow::trans_fail(bcx, Some(span), @/*bad*/copy text)\n     }\n }\n \n@@ -1037,20 +1037,20 @@ pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-pub fn trans_trace(bcx: block, sp_opt: Option<span>, +trace_str: ~str) {\n+pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n-    add_comment(bcx, trace_str);\n-    let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n+    add_comment(bcx, /*bad*/ copy trace_str);\n+    let V_trace_str = C_cstr(bcx.ccx(), @/*bad*/ copy trace_str);\n     let {V_filename, V_line} = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), /*bad*/copy loc.file.name),\n+        {V_filename: C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name),\n          V_line: loc.line as int}\n       }\n       None => {\n-        {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n+        {V_filename: C_cstr(bcx.ccx(), @~\"<runtime>\"),\n          V_line: 0}\n       }\n     };\n@@ -1170,7 +1170,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n         special_idents::invalid\n     };\n     unsafe {\n-        let llbb: BasicBlockRef = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n+        let llbb = str::as_c_str(*cx.ccx.sess.str_of(s), |buf| {\n             llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n         });\n         let bcx = mk_block(llbb,\n@@ -1401,7 +1401,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         do option::iter(&simple_name) |name| {\n-            str::as_c_str(cx.ccx().sess.str_of(*name), |buf| {\n+            str::as_c_str(*cx.ccx().sess.str_of(*name), |buf| {\n                 unsafe {\n                     llvm::LLVMSetValueName(val, buf)\n                 }\n@@ -2815,7 +2815,7 @@ pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     }\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |&key, &val| {\n-        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n+        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n     }\n@@ -2859,9 +2859,9 @@ pub fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n-        let nm = ~\"_rust_crate_map_\" + cdata.name +\n-            ~\"_\" + cstore::get_crate_vers(cstore, i) +\n-            ~\"_\" + cstore::get_crate_hash(cstore, i);\n+        let nm = ~\"_rust_crate_map_\" + *cdata.name +\n+            ~\"_\" + *cstore::get_crate_vers(cstore, i) +\n+            ~\"_\" + *cstore::get_crate_hash(cstore, i);\n         let cr = str::as_c_str(nm, |buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)"}, {"sha": "fe9eea19c3ff4fc4924e9a2ad0d17c16aa59c9e8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -186,7 +186,7 @@ pub struct crate_ctxt {\n      // Cache generated vtables\n      vtables: HashMap<mono_id, ValueRef>,\n      // Cache of constant strings,\n-     const_cstr_cache: HashMap<~str, ValueRef>,\n+     const_cstr_cache: HashMap<@~str, ValueRef>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -1141,15 +1141,15 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n+pub fn C_cstr(cx: @crate_ctxt, s: @~str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(&s) {\n-          Some(llval) => return llval,\n-          None => ()\n+            Some(llval) => return llval,\n+            None => ()\n         }\n \n-        let sc = do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n+        let sc = do str::as_c_str(*s) |buf| {\n+            llvm::LLVMConstString(buf, s.len() as c_uint, False)\n         };\n         let g =\n             str::as_c_str(fmt!(\"str%u\", (cx.names)(~\"str\").repr),\n@@ -1166,9 +1166,9 @@ pub fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n+pub fn C_estr_slice(cx: @crate_ctxt, s: @~str) -> ValueRef {\n     unsafe {\n-        let len = str::len(s);\n+        let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n         C_struct(~[cs, C_uint(cx, len + 1u /* +1 for null */)])\n     }\n@@ -1324,7 +1324,7 @@ pub fn path_str(sess: session::Session, p: path) -> ~str {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first { first = false; }\n                 else { r += ~\"::\"; }\n-                r += sess.str_of(s);\n+                r += *sess.str_of(s);\n             }\n         }\n     }"}, {"sha": "2c5a93a2532f85931e9945fddaa41b707ee3a6aa", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -55,7 +55,7 @@ pub fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n       }\n       ast::lit_bool(b) => C_bool(b),\n       ast::lit_nil => C_nil(),\n-      ast::lit_str(s) => C_estr_slice(cx, /*bad*/copy *s)\n+      ast::lit_str(s) => C_estr_slice(cx, s)\n     }\n }\n "}, {"sha": "0997df66b986e28f287af4f7993411ea8b9268b4", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -320,16 +320,16 @@ pub fn trans_check_expr(bcx: block,\n                         s: ~str)\n                      -> block {\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n-    let expr_str = s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n-        + ~\" failed\";\n+    let expr_str = @(s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n+        + ~\" failed\");\n     let Result {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n             expr::trans_to_datum(bcx, pred_expr).to_result()\n         }\n     };\n     let val = bool_to_i1(bcx, val);\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n-        trans_fail(bcx, Some(pred_expr.span), /*bad*/copy expr_str)\n+        trans_fail(bcx, Some(pred_expr.span), expr_str)\n     }\n }\n \n@@ -356,13 +356,13 @@ pub fn trans_fail_expr(bcx: block,\n                     ppaux::ty_to_str(tcx, arg_datum.ty));\n             }\n         }\n-        _ => return trans_fail(bcx, sp_opt, ~\"explicit failure\")\n+        _ => trans_fail(bcx, sp_opt, @~\"explicit failure\")\n     }\n }\n \n pub fn trans_fail(bcx: block,\n                   sp_opt: Option<span>,\n-                  +fail_str: ~str)\n+                  fail_str: @~str)\n                -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n@@ -379,11 +379,11 @@ fn trans_fail_value(bcx: block,\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), /*bad*/copy loc.file.name),\n+        {V_filename: C_cstr(bcx.ccx(), @/*bad*/ copy loc.file.name),\n          V_line: loc.line as int}\n       }\n       None => {\n-        {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n+        {V_filename: C_cstr(bcx.ccx(), @~\"<runtime>\"),\n          V_line: 0}\n       }\n     };\n@@ -403,7 +403,7 @@ pub fn trans_fail_bounds_check(bcx: block, sp: span,\n \n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(sp.lo);\n     let line = C_int(ccx, loc.line as int);\n-    let filename_cstr = C_cstr(bcx.ccx(), /*bad*/copy loc.file.name);\n+    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n     let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n \n     let args = ~[filename, line, index, len];"}, {"sha": "838d764cc4d8902d7ed23e58438d7a9da2cda813", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -60,12 +60,12 @@ const DW_ATE_signed_char: int = 0x06;\n const DW_ATE_unsigned: int = 0x07;\n const DW_ATE_unsigned_char: int = 0x08;\n \n-fn llstr(s: ~str) -> ValueRef {\n-    str::as_c_str(s, |sbuf| {\n+fn llstr(s: &str) -> ValueRef {\n+    do str::as_c_str(s) |sbuf| {\n         unsafe {\n-            llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n+            llvm::LLVMMDString(sbuf, s.len() as libc::c_uint)\n         }\n-    })\n+    }\n }\n fn lltag(lltag: int) -> ValueRef {\n     lli32(LLVMDebugVersion | lltag)\n@@ -79,10 +79,9 @@ fn lli64(val: int) -> ValueRef {\n fn lli1(bval: bool) -> ValueRef {\n     C_i1(bval)\n }\n-fn llmdnode(elems: ~[ValueRef]) -> ValueRef {\n+fn llmdnode(elems: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        llvm::LLVMMDNode(vec::raw::to_ptr(elems),\n-                         vec::len(elems) as libc::c_uint)\n+        llvm::LLVMMDNode(vec::raw::to_ptr(elems), elems.len() as libc::c_uint)\n     }\n }\n fn llunused() -> ValueRef {\n@@ -205,7 +204,7 @@ fn create_compile_unit(cx: @crate_ctxt) -> @metadata<compile_unit_md> {\n         let unit_metadata = ~[lltag(tg),\n                              llunused(),\n                              lli32(DW_LANG_RUST),\n-                             llstr(copy crate_name),\n+                             llstr(crate_name),\n                              llstr(work_dir),\n                              llstr(env!(\"CFG_VERSION\")),\n                              lli1(true), // deprecated: main compile unit\n@@ -369,7 +368,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n \n struct StructCtxt {\n     file: ValueRef,\n-    name: ~str,\n+    name: @~str,\n     line: int,\n     members: ~[ValueRef],\n     total_size: int,\n@@ -378,17 +377,17 @@ struct StructCtxt {\n \n fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n     return create_composite_type(StructureTypeTag,\n-                                 /*bad*/copy cx.name,\n+                                 *cx.name,\n                                  cx.file,\n                                  cx.line,\n                                  cx.total_size,\n                                  cx.align,\n                                  0,\n-                                 option::None,\n-                                 option::Some(/*bad*/copy cx.members));\n+                                 None,\n+                                 Some(/*bad*/copy cx.members));\n }\n \n-fn create_structure(file: @metadata<file_md>, +name: ~str, line: int)\n+fn create_structure(file: @metadata<file_md>, name: @~str, line: int)\n                  -> @mut StructCtxt {\n     let cx = @mut StructCtxt {\n         file: file.node,\n@@ -401,7 +400,7 @@ fn create_structure(file: @metadata<file_md>, +name: ~str, line: int)\n     return cx;\n }\n \n-fn create_derived_type(type_tag: int, file: ValueRef, +name: ~str, line: int,\n+fn create_derived_type(type_tag: int, file: ValueRef, name: &str, line: int,\n                        size: int, align: int, offset: int, ty: ValueRef)\n     -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n@@ -418,14 +417,14 @@ fn create_derived_type(type_tag: int, file: ValueRef, +name: ~str, line: int,\n }\n \n fn add_member(cx: @mut StructCtxt,\n-              +name: ~str,\n+              name: &str,\n               line: int,\n               size: int,\n               align: int,\n               ty: ValueRef) {\n     cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n-                                       size * 8, align * 8, cx.total_size,\n-                                       ty));\n+                                        size * 8, align * 8, cx.total_size,\n+                                        ty));\n     cx.total_size += size * 8;\n }\n \n@@ -443,7 +442,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n         let field_t = ty::get_field(cx.tcx, t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, cx.sess.str_of(field.node.ident),\n+        add_member(scx, *cx.sess.str_of(field.node.ident),\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n@@ -466,7 +465,8 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n     let uint_t = ty::mk_uint(cx.tcx);\n     let refcount_type = create_basic_type(cx, uint_t, span);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, outer), 0);\n+    let scx = create_structure(file_node,\n+                               @/*bad*/ copy ty_to_str(cx.tcx, outer), 0);\n     add_member(scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n     add_member(scx, ~\"boxed\", 0, 8, //XXX member_size_and_align(??)\n@@ -479,7 +479,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     return mdval;\n }\n \n-fn create_composite_type(type_tag: int, +name: ~str, file: ValueRef,\n+fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n                          line: int, size: int, align: int, offset: int,\n                          derived: Option<ValueRef>,\n                          +members: Option<~[ValueRef]>)\n@@ -515,7 +515,8 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t), 0);\n+    let scx = create_structure(file_node,\n+                               @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx), vec_ty_span);\n     add_member(scx, ~\"fill\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n@@ -525,8 +526,8 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let data_ptr = create_composite_type(ArrayTypeTag, ~\"\", file_node.node, 0,\n                                          arr_size, arr_align, 0,\n-                                         option::Some(elem_ty_md.node),\n-                                         option::Some(~[subrange]));\n+                                         Some(elem_ty_md.node),\n+                                         Some(~[subrange]));\n     add_member(scx, ~\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(scx);\n@@ -641,7 +642,7 @@ fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> ~str {\n     /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n-fn create_var(type_tag: int, context: ValueRef, +name: ~str, file: ValueRef,\n+fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n               line: int, ret_ty: ValueRef) -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n                   context,\n@@ -679,7 +680,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n             None => create_function(bcx.fcx).node,\n             Some(_) => create_block(bcx).node\n         };\n-        let mdnode = create_var(tg, context, cx.sess.str_of(name),\n+        let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n                                 filemd.node, loc.line as int, tymd.node);\n         let mdval = @{node: mdnode, data: {id: local.node.id}};\n         update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n@@ -728,7 +729,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n                 // XXX: This is wrong; it should work for multiple bindings.\n                 let mdnode = create_var(tg,\n                                         context.node,\n-                                        cx.sess.str_of(path.idents.last()),\n+                                        *cx.sess.str_of(path.idents.last()),\n                                         filemd.node,\n                                         loc.line as int,\n                                         tymd.node);\n@@ -839,9 +840,9 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let fn_metadata = ~[lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n-                       llstr(cx.sess.str_of(ident)),\n+                       llstr(*cx.sess.str_of(ident)),\n                         //XXX fully-qualified C++ name:\n-                       llstr(cx.sess.str_of(ident)),\n+                       llstr(*cx.sess.str_of(ident)),\n                        llstr(~\"\"), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),"}, {"sha": "49e47e35572e20ba61f53208ff203173bda5366a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -47,10 +47,10 @@ fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n     }\n }\n \n-pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n+pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> @~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n-        option::Some(ref ln) => (/*bad*/copy *ln)\n+        Some(ln) => ln,\n     }\n }\n \n@@ -228,18 +228,18 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n         }\n \n         let lname = link_name(ccx, foreign_item);\n-        let llbasefn = base_fn(ccx, copy lname, tys, cc);\n+        let llbasefn = base_fn(ccx, *lname, tys, cc);\n         // Name the shim function\n         let shim_name = lname + ~\"__c_stack_shim\";\n         return build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n                            build_args, build_ret);\n     }\n \n-    fn base_fn(ccx: @crate_ctxt, +lname: ~str, tys: @c_stack_tys,\n+    fn base_fn(ccx: @crate_ctxt, lname: &str, tys: @c_stack_tys,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         do tys.fn_ty.decl_fn |fnty| {\n-            decl_fn(ccx.llmod, /*bad*/copy lname, cc, fnty)\n+            decl_fn(ccx.llmod, lname, cc, fnty)\n         }\n     }\n \n@@ -250,7 +250,7 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n                        cc: lib::llvm::CallConv) {\n         let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n-        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n+        let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n         let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n@@ -334,13 +334,13 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n                        +path: ast_map::path,\n                        substs: @param_substs,\n                        ref_id: Option<ast::node_id>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+    debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n \n     // XXX: Bad copy.\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, None,\n                                Some(copy substs), Some(item.span));\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n-    match ccx.sess.str_of(item.ident) {\n+    match *ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),"}, {"sha": "cc31c9ace9867615c37eed1229d8ad4686a42fd3", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -150,7 +150,7 @@ pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n                 });\n \n                 debug!(\"static_size_of_enum: variant %s type %s\",\n-                       cx.tcx.sess.str_of(variant.name),\n+                       *cx.tcx.sess.str_of(variant.name),\n                        ty_str(cx.tn, T_struct(lltypes)));\n \n                 let this_size = llsize_of_real(cx, T_struct(lltypes));"}, {"sha": "b7732aa817f8444c55da70fdb0dd92aa746fb473", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -322,7 +322,7 @@ pub fn trans_static_method_callee(bcx: block,\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n-            name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n+            name=%s\", method_id, callee_id, *ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get(&callee_id));\n@@ -794,10 +794,10 @@ pub fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n         let tbl = C_struct(ptrs);\n-        let vt_gvar =\n-                str::as_c_str(ccx.sess.str_of((ccx.names)(~\"vtable\")), |buf| {\n+        let vtable = ccx.sess.str_of((ccx.names)(~\"vtable\"));\n+        let vt_gvar = do str::as_c_str(*vtable) |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n-        });\n+        };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n         lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n@@ -825,11 +825,11 @@ pub fn make_impl_vtable(ccx: @crate_ctxt,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n-                   tcx.sess.str_of(im.ident));\n+                   *tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n-                   tcx.sess.str_of(im.ident));\n+                   *tcx.sess.str_of(im.ident));\n             let mut m_id = method_with_name(ccx, impl_id, im.ident);\n             if has_tps {\n                 // If the method is in another crate, need to make an inlined"}, {"sha": "52b95c168b22529e8ef252713bbd89342405e336", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -147,7 +147,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let pt = vec::append(/*bad*/copy *pt,\n-                         ~[path_name((ccx.names)(ccx.sess.str_of(name)))]);\n+                         ~[path_name((ccx.names)(*ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n     let mk_lldecl = || {"}, {"sha": "1fa97325313b6c52770a2e558c1b6c3477055ee3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -45,7 +45,7 @@ pub impl Reflector {\n         C_int(self.bcx.ccx(), i)\n     }\n \n-    fn c_slice(&mut self, +s: ~str) -> ValueRef {\n+    fn c_slice(&mut self, s: @~str) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;"}, {"sha": "d0f0275c81ac2302f99715b35a748820fe427ce4", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -263,7 +263,7 @@ pub fn trans_lit_str(bcx: block,\n             unsafe {\n                 let bytes = str_lit.len() + 1; // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n-                let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *str_lit);\n+                let llcstr = C_cstr(bcx.ccx(), str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr,\n                                                         T_ptr(T_i8()));\n                 Store(bcx,\n@@ -299,7 +299,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n                 ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n                 }) => {\n-                    let llptrval = C_cstr(bcx.ccx(), copy *s);\n+                    let llptrval = C_cstr(bcx.ccx(), s);\n                     let llptrval = PointerCast(bcx, llptrval, T_ptr(T_i8()));\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n                     let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n@@ -362,7 +362,7 @@ pub fn write_content(bcx: block,\n                 SaveIn(lldest) => {\n                     let bytes = s.len() + 1; // copy null-terminator too\n                     let llbytes = C_uint(bcx.ccx(), bytes);\n-                    let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *s);\n+                    let llcstr = C_cstr(bcx.ccx(), s);\n                     base::call_memcpy(bcx, lldest, llcstr, llbytes);\n                     return bcx;\n                 }"}, {"sha": "a1a32c62866d4ce3463f21ff1942c23a2af9080e", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -112,7 +112,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                                                    _ },\n                                  abi, _) => {\n         if abi == foreign_abi_rust_intrinsic {\n-            let flags = match cx.ccx.sess.str_of(i.ident) {\n+            let flags = match *cx.ccx.sess.str_of(i.ident) {\n                 ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |\n                 ~\"init\"     | ~\"reinterpret_cast\" |\n                 ~\"move_val\" | ~\"move_val_init\" => use_repr,"}, {"sha": "d11b0a8f2eb0d6d4e65a7b94deddceb27458b9b2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -783,11 +783,11 @@ pub fn mk_ctxt(s: session::Session,\n     let mut legacy_records = false;\n     for crate.node.attrs.each |attribute| {\n         match attribute.node.value.node {\n-            ast::meta_word(ref w) if (*w) == ~\"legacy_modes\" => {\n+            ast::meta_word(w) if *w == ~\"legacy_modes\" => {\n                 legacy_modes = true;\n                 if legacy_records { break; }\n             }\n-            ast::meta_word(ref w) if (*w) == ~\"legacy_records\" => {\n+            ast::meta_word(w) if *w == ~\"legacy_records\" => {\n                 legacy_records = true;\n                 if legacy_modes { break; }\n             }\n@@ -3226,7 +3226,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n     for fields.each |f| { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n-        tcx.sess.str_of(id),\n+        *tcx.sess.str_of(id),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n@@ -3235,7 +3235,7 @@ pub fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n       Some(f) => f,\n       // Do we only call this when we know the field is legit?\n       None => fail!(fmt!(\"get_field: ty doesn't have a field %s\",\n-                         tcx.sess.str_of(id)))\n+                         *tcx.sess.str_of(id)))\n     }\n }\n \n@@ -3465,8 +3465,8 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_record_fields(values) => {\n             fmt!(\"expected a record with field `%s` but found one with field \\\n                   `%s`\",\n-                 cx.sess.str_of(values.expected),\n-                 cx.sess.str_of(values.found))\n+                 *cx.sess.str_of(values.expected),\n+                 *cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_mode_mismatch(values) => {\n@@ -3500,7 +3500,7 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  vstore_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n-            fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n+            fmt!(\"in field `%s`, %s\", *cx.sess.str_of(fname),\n                  type_err_to_str(cx, err))\n         }\n         terr_sorts(values) => {"}, {"sha": "ee64b649d83630cdc9bd213cee2765803dab3535", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -231,7 +231,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n                 tcx.sess.span_err(span,\n                                   fmt!(\"struct `%s` does not have a field\n                                         named `%s`\", name,\n-                                       tcx.sess.str_of(field.ident)));\n+                                       *tcx.sess.str_of(field.ident)));\n             }\n         }\n     }\n@@ -244,7 +244,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n             }\n             tcx.sess.span_err(span,\n                               fmt!(\"pattern does not mention field `%s`\",\n-                                   tcx.sess.str_of(field.ident)));\n+                                   *tcx.sess.str_of(field.ident)));\n         }\n     }\n }\n@@ -436,7 +436,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 tcx.sess.span_fatal(pat.span,\n                                     fmt!(\"mismatched types: did not \\\n                                           expect a record with a field `%s`\",\n-                                          tcx.sess.str_of(f.ident)));\n+                                          *tcx.sess.str_of(f.ident)));\n               }\n             }\n         }"}, {"sha": "37cf4f2ae231671c4ddfcaa4eb42652f048238c3", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -450,7 +450,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n-                       tcx.sess.str_of(path.idents[0]),\n+                       *tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n                            fcx.inh.locals.get(&p.id)));\n               }\n@@ -508,7 +508,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n           Some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n                                    name %s in record type declaration\",\n-                                        tcx.sess.str_of(id)));\n+                                        *tcx.sess.str_of(id)));\n             tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n                                           this field occurred here\");\n             break;\n@@ -565,7 +565,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n-               ccx.tcx.sess.str_of(it.ident), it.id, rp);\n+               *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n             check_method(ccx, *m, self_ty, local_def(it.id));\n@@ -1370,7 +1370,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       fmt!(\"type `%s` does not implement any method in scope \\\n                             named `%s`\",\n                            actual,\n-                           fcx.ccx.tcx.sess.str_of(method_name))\n+                           *fcx.ccx.tcx.sess.str_of(method_name))\n                   },\n                   expr_t,\n                   None);\n@@ -1752,7 +1752,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   |actual| {\n                       fmt!(\"attempted access of field `%s` on type `%s`, but \\\n                             no field or method with that name was found\",\n-                           tcx.sess.str_of(field), actual)\n+                           *tcx.sess.str_of(field), actual)\n                   },\n                   expr_t, None);\n                 // Add error type for the result\n@@ -1790,13 +1790,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"structure has no field named `%s`\",\n-                             tcx.sess.str_of(field.node.ident)));\n+                             *tcx.sess.str_of(field.node.ident)));\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"field `%s` specified more than once\",\n-                             tcx.sess.str_of(field.node.ident)));\n+                             *tcx.sess.str_of(field.node.ident)));\n                 }\n                 Some((field_id, false)) => {\n                     let expected_field_type =\n@@ -1824,7 +1824,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     let (_, seen) = class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n-                            ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n+                            ~\"`\" + *tcx.sess.str_of(name) + ~\"`\");\n                     }\n                 }\n \n@@ -2543,7 +2543,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 if !found {\n                     tcx.sess.span_err(f.span,\n                                         ~\"unknown field in record update: \" +\n-                                        tcx.sess.str_of(f.node.ident));\n+                                        *tcx.sess.str_of(f.node.ident));\n                     fcx.write_ty(id, ty::mk_err(tcx));\n                     return true;\n                 }\n@@ -3151,7 +3151,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\",\n-                           ccx.tcx.sess.str_of(tps[i].ident)));\n+                           *ccx.tcx.sess.str_of(tps[i].ident)));\n         }\n     }\n }\n@@ -3164,7 +3164,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         arg {mode: ast::expl(m), ty: ty}\n     }\n     let tcx = ccx.tcx;\n-    let (n_tps, inputs, output) = match ccx.tcx.sess.str_of(it.ident) {\n+    let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint(ccx.tcx)),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),"}, {"sha": "1dbdc4378b068c32d1015f87927ba66a059602b8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -204,7 +204,7 @@ pub impl CoherenceChecker {\n         visit_crate(*crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 debug!(\"(checking coherence) item '%s'\",\n-                       self.crate_context.tcx.sess.str_of(item.ident));\n+                       *self.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n                     item_impl(_, opt_trait, _, _) => {\n@@ -245,7 +245,7 @@ pub impl CoherenceChecker {\n         if associated_traits.len() == 0 {\n             debug!(\"(checking implementation) no associated traits for item \\\n                     '%s'\",\n-                   self.crate_context.tcx.sess.str_of(item.ident));\n+                   *self.crate_context.tcx.sess.str_of(item.ident));\n \n             match get_base_type_def_id(self.inference_context,\n                                        item.span,\n@@ -274,7 +274,7 @@ pub impl CoherenceChecker {\n                     ast_map::node_id_to_str(\n                         self.crate_context.tcx.items, trait_did.node,\n                         self.crate_context.tcx.sess.parse_sess.interner),\n-                    self.crate_context.tcx.sess.str_of(item.ident));\n+                    *self.crate_context.tcx.sess.str_of(item.ident));\n \n             self.instantiate_default_methods(item.id, trait_did);\n \n@@ -362,15 +362,15 @@ pub impl CoherenceChecker {\n                     // method to that entry.\n                     debug!(\"(checking implementation) adding method `%s` \\\n                             to entry for existing trait\",\n-                            self.crate_context.tcx.sess.str_of(\n+                            *self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n                     mis.push(provided_method_info);\n                 }\n                 None => {\n                     // If the trait doesn't have an entry yet, create one.\n                     debug!(\"(checking implementation) creating new entry \\\n                             for method `%s`\",\n-                            self.crate_context.tcx.sess.str_of(\n+                            *self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n                     let method_infos = @DVec();\n                     method_infos.push(provided_method_info);\n@@ -730,7 +730,7 @@ pub impl CoherenceChecker {\n \n             tcx.sess.span_err(trait_ref_span,\n                               fmt!(\"missing method `%s`\",\n-                                   tcx.sess.str_of(method.ident)));\n+                                   *tcx.sess.str_of(method.ident)));\n         }\n     }\n \n@@ -742,7 +742,7 @@ pub impl CoherenceChecker {\n             for all_provided_methods.each |provided_method| {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n-                    sess.str_of(provided_method.method_info.ident));\n+                    *sess.str_of(provided_method.method_info.ident));\n                 vec::push(&mut *all_methods, provided_method.method_info);\n             }\n         }\n@@ -863,7 +863,7 @@ pub impl CoherenceChecker {\n                         session.bug(fmt!(\n                             \"no base type for external impl \\\n                              with no trait: %s (type %s)!\",\n-                             session.str_of(implementation.ident),\n+                             *session.str_of(implementation.ident),\n                              ty_to_str(self.crate_context.tcx,self_type.ty)));\n                     }\n                     Some(_) => {"}, {"sha": "2edbb3ebf675ac8f24105a7d9ec0b9936e836168", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -357,20 +357,20 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             tcx.sess.span_fatal(cm.span,\n                  fmt!(\"method `%s` is declared as \\\n                        static in its impl, but not in \\\n-                       its trait\", tcx.sess.str_of(impl_m.ident)));\n+                       its trait\", *tcx.sess.str_of(impl_m.ident)));\n         }\n         else if trait_m.self_ty == ast::sty_static {\n             tcx.sess.span_fatal(cm.span,\n                  fmt!(\"method `%s` is declared as \\\n                        static in its trait, but not in \\\n-                       its impl\", tcx.sess.str_of(impl_m.ident)));\n+                       its impl\", *tcx.sess.str_of(impl_m.ident)));\n         }\n         else {\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s`'s self type does \\\n                       not match the trait method's \\\n-                      self type\", tcx.sess.str_of(impl_m.ident)));\n+                      self type\", *tcx.sess.str_of(impl_m.ident)));\n         }\n     }\n \n@@ -379,7 +379,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             cm.span,\n             fmt!(\"method `%s` has %u type %s, but its trait \\\n                   declaration has %u type %s\",\n-                 tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n+                 *tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n                  pluralize(impl_m.tps.len(), ~\"parameter\"),\n                  trait_m.tps.len(),\n                  pluralize(trait_m.tps.len(), ~\"parameter\")));\n@@ -391,7 +391,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             cm.span,\n             fmt!(\"method `%s` has %u parameters \\\n                   but the trait has %u\",\n-                 tcx.sess.str_of(trait_m.ident),\n+                 *tcx.sess.str_of(trait_m.ident),\n                  vec::len(impl_m.fty.sig.inputs),\n                  vec::len(trait_m.fty.sig.inputs)));\n         return;\n@@ -412,7 +412,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                fmt!(\"in method `%s`, \\\n                      type parameter %u has %u %s, but the same type \\\n                      parameter in its trait declaration has %u %s\",\n-                    tcx.sess.str_of(trait_m.ident),\n+                    *tcx.sess.str_of(trait_m.ident),\n                     i, impl_param_bounds.len(),\n                     pluralize(impl_param_bounds.len(), ~\"bound\"),\n                     trait_param_bounds.len(),\n@@ -466,7 +466,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s` has an incompatible type: %s\",\n-                     tcx.sess.str_of(trait_m.ident),\n+                     *tcx.sess.str_of(trait_m.ident),\n                      ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n@@ -526,7 +526,7 @@ pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n                 tcx.sess.span_err(\n                     impl_m.span,\n                     fmt!(\"method `%s` is not a member of trait `%s`\",\n-                         tcx.sess.str_of(impl_m.mty.ident),\n+                         *tcx.sess.str_of(impl_m.mty.ident),\n                          path_to_str(a_trait_ty.path, tcx.sess.intr())));\n             }\n         }\n@@ -596,7 +596,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n-           tcx.sess.str_of(it.ident), it.id, rp);\n+           *tcx.sess.str_of(it.ident), it.id, rp);\n     match /*bad*/copy it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n@@ -809,7 +809,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n                    region_param: None,\n                    ty: ty::mk_bare_fn(ccx.tcx, tofd)};\n         debug!(\"type of %s (id %d) is %s\",\n-               tcx.sess.str_of(it.ident),\n+               *tcx.sess.str_of(it.ident),\n                it.id,\n                ppaux::ty_to_str(tcx, tpt.ty));\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);"}, {"sha": "b1ac8bb2d5c4eb13f70624dc90f7f3e5d2926467", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -187,7 +187,7 @@ Available lint options:\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n     for lint_dict.each |&k, &v| {\n-        let k = str::replace(k, ~\"_\", ~\"-\");\n+        let k = str::replace(*k, ~\"_\", ~\"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n                          match v.default {"}, {"sha": "8b0c84cff8343b87ed0b96a91a6525207fef7024", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -145,7 +145,8 @@ pub fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n     if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, sep); }\n \n     match br {\n-      br_named(id)         => fmt!(\"%s%s%s\", prefix, cx.sess.str_of(id), sep),\n+      br_named(id)         => fmt!(\"%s%s%s\", prefix, *cx.sess.str_of(id),\n+                                   sep),\n       br_self              => fmt!(\"%sself%s\", prefix, sep),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n@@ -321,7 +322,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         match ident {\n           Some(i) => {\n               s.push_char(' ');\n-              s.push_str(cx.sess.str_of(i));\n+              s.push_str(*cx.sess.str_of(i));\n           }\n           _ => { }\n         }\n@@ -387,7 +388,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                        &m.fty.sig) + ~\";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n+        return *cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n     }\n \n     // if there is an id, print that instead of the structural type:"}, {"sha": "bb9ba93cbe06a220f3cb808b0fbd1281843a50bd", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -65,9 +65,10 @@ fn doc_metas(\n \n pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n+    let name = attr::last_meta_item_value_str_by_name(link_metas, ~\"name\");\n \n     CrateAttrs {\n-        name: attr::last_meta_item_value_str_by_name(link_metas, ~\"name\")\n+        name: name.map(|s| copy **s)\n     }\n }\n \n@@ -97,7 +98,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n-        attr::get_meta_item_value_str(*meta)\n+        attr::get_meta_item_value_str(*meta).map(|s| copy **s)\n     };\n     if doc_strs.is_empty() {\n         None"}, {"sha": "98ce4052eeb038e6c57bc08d89b45848355c2d51", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -89,7 +89,7 @@ impl PackageScript {\n                     ast::meta_name_value(v, spanned {\n                                                 node: ast::lit_str(s),\n                                                 span: _}) => {\n-                        match v {\n+                        match *v {\n                             ~\"id\" => id = Some(*s),\n                             ~\"vers\" => vers = Some(*s),\n                             _ => ()\n@@ -112,7 +112,7 @@ impl PackageScript {\n                     ast::meta_name_value(v, spanned {\n                                                 node: ast::lit_str(s),\n                                                 span: _}) => {\n-                        match v {\n+                        match *v {\n                             ~\"url\" => url = Some(*s),\n                             ~\"target\" => target = Some(*s),\n                             _ => ()\n@@ -133,7 +133,7 @@ impl PackageScript {\n                     ast::meta_name_value(v, spanned {\n                                                 node: ast::lit_str(s),\n                                                 span: _}) => {\n-                        match v {\n+                        match *v {\n                             ~\"file\" => file = Some(*s),\n                             _ => ()\n                         }\n@@ -148,7 +148,7 @@ impl PackageScript {\n         for crate.node.attrs.each |a| {\n             match a.node.value.node {\n                 ast::meta_list(v, mis) => {\n-                    match v {\n+                    match *v {\n                         ~\"pkg\" => {\n                             let (i, v) = load_pkg_attr(mis);\n "}, {"sha": "7f7b3e75b6fc11e762a156bfde96e2087581f619", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -81,7 +81,7 @@ fn fold_mod(_ctx: @ReadyCtx, m: ast::_mod,\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.filtered |attr| {\n-                attr::get_attr_name(*attr) != ~\"main\"\n+                *attr::get_attr_name(attr) != ~\"main\"\n             },\n             .. copy *item\n         }\n@@ -110,7 +110,7 @@ fn fold_item(ctx: @ReadyCtx, item: @ast::item,\n                 ast::meta_list(_, mis) => {\n                     for mis.each |mi| {\n                         match mi.node {\n-                            ast::meta_word(cmd) => cmds.push(cmd),\n+                            ast::meta_word(cmd) => cmds.push(copy *cmd),\n                             _ => {}\n                         };\n                     }\n@@ -609,7 +609,7 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n     let mut crate_cfg = options.cfg;\n \n     for cfgs.each |&cfg| {\n-        crate_cfg.push(attr::mk_word_item(cfg));\n+        crate_cfg.push(attr::mk_word_item(@cfg));\n     }\n \n     let options = @{\n@@ -639,7 +639,7 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n             match a.node {\n                 ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n                                          span: _}) => {\n-                    match v {\n+                    match *v {\n                         ~\"name\" => name = Some(*s),\n                         ~\"vers\" => vers = Some(*s),\n                         ~\"uuid\" => uuid = Some(*s),\n@@ -657,13 +657,13 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n         match a.node.value.node {\n             ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n                                      span: _}) => {\n-                match v {\n+                match *v {\n                     ~\"crate_type\" => crate_type = Some(*s),\n                     _ => {}\n                 }\n             }\n             ast::meta_list(v, mis) => {\n-                match v {\n+                match *v {\n                     ~\"link\" => {\n                         let (n, v, u) = load_link_attr(mis);\n "}, {"sha": "234cef5f6eb4da5ed1b95d119251cdc7ae076c54", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -173,9 +173,9 @@ pub type meta_item = spanned<meta_item_>;\n #[auto_decode]\n #[deriving_eq]\n pub enum meta_item_ {\n-    meta_word(~str),\n-    meta_list(~str, ~[@meta_item]),\n-    meta_name_value(~str, lit),\n+    meta_word(@~str),\n+    meta_list(@~str, ~[@meta_item]),\n+    meta_name_value(@~str, lit),\n }\n \n pub type blk = spanned<blk_>;"}, {"sha": "74f67808a5e972550afc9773f6beaa599a83ed4c", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -193,7 +193,7 @@ pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n-        visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n+        visit::fk_dtor(ref tps, ref attrs, self_id, parent_id) => {\n             let dt = @spanned {\n                 node: ast::struct_dtor_ {\n                     id: id,\n@@ -203,7 +203,7 @@ pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                 },\n                 span: sp,\n             };\n-            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n+            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy *tps, dt,\n                                         parent_id,\n                                         @/* FIXME (#2543) */ copy cx.path));\n       }\n@@ -286,7 +286,7 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: vt) {\n         map_struct_def(struct_def, node_item(i, item_path), i.ident, cx,\n                        v);\n       }\n-      item_trait(_, traits, ref methods) => {\n+      item_trait(_, ref traits, ref methods) => {\n         for traits.each |p| {\n             cx.map.insert(p.ref_id, node_item(i, item_path));\n         }"}, {"sha": "a82ad762e229f8ba4f2cf29321e677e83faa2476", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -327,8 +327,8 @@ pub impl inlined_item_utils for inlined_item {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n             ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-            ii_dtor(ref dtor, _, tps, parent_id) => {\n-              visit::visit_struct_dtor_helper((*dtor), tps, parent_id, e, v);\n+            ii_dtor(/*bad*/ copy dtor, _, /*bad*/ copy tps, parent_id) => {\n+                visit::visit_struct_dtor_helper(dtor, tps, parent_id, e, v);\n             }\n         }\n     }"}, {"sha": "14ffb1cab5da417e947fc82d5c3854e30c6cc00b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 76, "deletions": 81, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -29,24 +29,24 @@ use std;\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: ~str, value: ~str)\n+pub fn mk_name_value_item_str(name: @~str, value: @~str)\n                            -> @ast::meta_item {\n-    let value_lit = dummy_spanned(ast::lit_str(@value));\n-    return mk_name_value_item(name, value_lit);\n+    let value_lit = dummy_spanned(ast::lit_str(value));\n+    mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: ~str, +value: ast::lit)\n+pub fn mk_name_value_item(name: @~str, +value: ast::lit)\n         -> @ast::meta_item {\n-    return @dummy_spanned(ast::meta_name_value(name, value));\n+    @dummy_spanned(ast::meta_name_value(name, value))\n }\n \n-pub fn mk_list_item(name: ~str, +items: ~[@ast::meta_item]) ->\n+pub fn mk_list_item(name: @~str, +items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n-    return @dummy_spanned(ast::meta_list(name, items));\n+    @dummy_spanned(ast::meta_list(name, items))\n }\n \n-pub fn mk_word_item(name: ~str) -> @ast::meta_item {\n-    return @dummy_spanned(ast::meta_word(name));\n+pub fn mk_word_item(name: @~str) -> @ast::meta_item {\n+    @dummy_spanned(ast::meta_word(name))\n }\n \n pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n@@ -60,7 +60,7 @@ pub fn mk_sugared_doc_attr(text: ~str,\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = ast::attribute_ {\n         style: doc_comment_style(text),\n-        value: spanned(lo, hi, ast::meta_name_value(~\"doc\", lit)),\n+        value: spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -80,39 +80,41 @@ pub fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n-        let meta = mk_name_value_item_str(~\"doc\",\n-                                     strip_doc_comment_decoration(comment));\n-        return mk_attr(meta);\n+        let meta = mk_name_value_item_str(@~\"doc\",\n+                                     @strip_doc_comment_decoration(*comment));\n+        mk_attr(meta)\n     } else {\n         *attr\n     }\n }\n \n /* Accessors */\n \n-pub fn get_attr_name(attr: ast::attribute) -> ~str {\n+pub pure fn get_attr_name(attr: &ast::attribute) -> @~str {\n     get_meta_item_name(@attr.node.value)\n }\n \n-pub fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n+pub pure fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n     match meta.node {\n-      ast::meta_word(ref n) => (*n),\n-      ast::meta_name_value(ref n, _) => (*n),\n-      ast::meta_list(ref n, _) => (*n)\n+        ast::meta_word(n) => n,\n+        ast::meta_name_value(n, _) => n,\n+        ast::meta_list(n, _) => n,\n     }\n }\n \n /**\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n+pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@~str> {\n     match meta.node {\n-        ast::meta_name_value(_, v) => match v.node {\n-            ast::lit_str(s) => option::Some(*s),\n-            _ => option::None\n+        ast::meta_name_value(_, v) => {\n+            match v.node {\n+                ast::lit_str(s) => Some(s),\n+                _ => None,\n+            }\n         },\n-        _ => option::None\n+        _ => None\n     }\n }\n \n@@ -130,11 +132,11 @@ pub fn get_meta_item_list(meta: @ast::meta_item)\n  * a tuple containing the name and string value, otherwise `none`\n  */\n pub fn get_name_value_str_pair(item: @ast::meta_item)\n-                            -> Option<(~str, ~str)> {\n+                            -> Option<(@~str, @~str)> {\n     match attr::get_meta_item_value_str(item) {\n-      Some(ref value) => {\n+      Some(value) => {\n         let name = attr::get_meta_item_name(item);\n-        Some((name, (*value)))\n+        Some((name, value))\n       }\n       None => None\n     }\n@@ -146,22 +148,21 @@ pub fn get_name_value_str_pair(item: @ast::meta_item)\n /// Search a list of attributes and return only those with a specific name\n pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n-    let filter: &fn(a: &ast::attribute) -> Option<ast::attribute> = |a| {\n-        if name == get_attr_name(*a) {\n-            option::Some(*a)\n+    do vec::filter_mapped(attrs) |a| {\n+        if name == *get_attr_name(a) {\n+            Some(*a)\n         } else {\n-            option::None\n+            None\n         }\n-    };\n-    return vec::filter_mapped(attrs, filter);\n+    }\n }\n \n /// Search a list of meta items and return only those with a specific name\n pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n     let mut rs = ~[];\n     for metas.each |mi| {\n-        if name == get_meta_item_name(*mi) {\n+        if name == *get_meta_item_name(*mi) {\n             rs.push(*mi)\n         }\n     }\n@@ -214,36 +215,39 @@ pub fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n     !find_attrs_by_name(attrs, name).is_empty()\n }\n \n-pub fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n-                                 -> Option<~str> {\n+pub fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: &str)\n+                                 -> Option<@~str> {\n \n     let mattrs = find_attrs_by_name(attrs, name);\n-    if vec::len(mattrs) > 0u {\n-        return get_meta_item_value_str(attr_meta(mattrs[0]));\n+    if mattrs.len() > 0 {\n+        get_meta_item_value_str(attr_meta(mattrs[0]))\n+    } else {\n+        None\n     }\n-    return option::None;\n }\n \n-fn last_meta_item_by_name(items: ~[@ast::meta_item], name: ~str)\n+fn last_meta_item_by_name(items: ~[@ast::meta_item], name: &str)\n     -> Option<@ast::meta_item> {\n \n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n-pub fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n-                                     -> Option<~str> {\n+pub fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: &str)\n+                                     -> Option<@~str> {\n \n     match last_meta_item_by_name(items, name) {\n-      Some(item) => match attr::get_meta_item_value_str(item) {\n-        Some(ref value) => Some((*value)),\n+        Some(item) => {\n+            match attr::get_meta_item_value_str(item) {\n+                Some(value) => Some(value),\n+                None => None\n+            }\n+        },\n         None => None\n-      },\n-      None => None\n     }\n }\n \n-pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n+pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n     -> Option<~[@ast::meta_item]> {\n \n     match last_meta_item_by_name(items, name) {\n@@ -256,20 +260,11 @@ pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n /* Higher-level applications */\n \n pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n-        pure fn key(m: &ast::meta_item) -> ~str {\n-            match m.node {\n-              ast::meta_word(ref name) => (*name),\n-              ast::meta_name_value(ref name, _) => (*name),\n-              ast::meta_list(ref name, _) => (*name)\n-            }\n-        }\n-        key(*ma) <= key(*mb)\n-    }\n-\n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v: ~[@ast::meta_item] = items;\n-    std::sort::quick_sort(v, lteq);\n+    let mut v = items;\n+    do std::sort::quick_sort(v) |ma, mb| {\n+        get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n+    }\n \n     // There doesn't seem to be a more optimal way to do this\n     do v.map |&m| {\n@@ -283,14 +278,14 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     }\n }\n \n-pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n+pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n \n     return vec::filter_mapped(items, |item| {\n-        if get_meta_item_name(*item) != name {\n-            option::Some(*item)\n+        if name != *get_meta_item_name(*item) {\n+            Some(*item)\n         } else {\n-            option::None\n+            None\n         }\n     });\n }\n@@ -311,21 +306,21 @@ pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n pub fn foreign_abi(attrs: ~[ast::attribute])\n                 -> Either<~str, ast::foreign_abi> {\n     return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n-      option::None => {\n-        either::Right(ast::foreign_abi_cdecl)\n-      }\n-      option::Some(~\"rust-intrinsic\") => {\n-        either::Right(ast::foreign_abi_rust_intrinsic)\n-      }\n-      option::Some(~\"cdecl\") => {\n-        either::Right(ast::foreign_abi_cdecl)\n-      }\n-      option::Some(~\"stdcall\") => {\n-        either::Right(ast::foreign_abi_stdcall)\n-      }\n-      option::Some(ref t) => {\n-        either::Left(~\"unsupported abi: \" + (*t))\n-      }\n+        None => {\n+            Right(ast::foreign_abi_cdecl)\n+        }\n+        Some(@~\"rust-intrinsic\") => {\n+            Right(ast::foreign_abi_rust_intrinsic)\n+        }\n+        Some(@~\"cdecl\") => {\n+            Right(ast::foreign_abi_cdecl)\n+        }\n+        Some(@~\"stdcall\") => {\n+            Right(ast::foreign_abi_stdcall)\n+        }\n+        Some(t) => {\n+            Left(~\"unsupported abi: \" + *t)\n+        }\n     };\n }\n \n@@ -348,8 +343,8 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         match attr.node.value.node {\n-          ast::meta_word(~\"inline\") => ia_hint,\n-          ast::meta_list(~\"inline\", items) => {\n+          ast::meta_word(@~\"inline\") => ia_hint,\n+          ast::meta_list(@~\"inline\", items) => {\n             if !vec::is_empty(find_meta_items_by_name(items, ~\"always\")) {\n                 ia_always\n             } else if !vec::is_empty(\n@@ -374,7 +369,7 @@ pub fn require_unique_names(diagnostic: span_handler,\n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if !set.insert(name) {\n             diagnostic.span_fatal(meta.span,\n-                                  fmt!(\"duplicate meta item `%s`\", name));\n+                                  fmt!(\"duplicate meta item `%s`\", *name));\n         }\n     }\n }"}, {"sha": "9ceaebe6dd1de00b09aa9b2f6c693abc654a24b2", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -114,7 +114,7 @@ pub fn expand_auto_encode(\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     fn is_auto_encode(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) == ~\"auto_encode\"\n+        *attr::get_attr_name(a) == ~\"auto_encode\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -127,24 +127,24 @@ pub fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n+                ast::item_struct(ref struct_def, ref tps) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        fields,\n-                        tps\n+                        struct_def.fields,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n                 },\n-                ast::item_enum(ref enum_def, tps) => {\n+                ast::item_enum(ref enum_def, ref tps) => {\n                     let ser_impl = mk_enum_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        (*enum_def),\n-                        tps\n+                        *enum_def,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n@@ -169,7 +169,7 @@ pub fn expand_auto_decode(\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     fn is_auto_decode(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) == ~\"auto_decode\"\n+        *attr::get_attr_name(a) == ~\"auto_decode\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -182,24 +182,24 @@ pub fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n+                ast::item_struct(ref struct_def, ref tps) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        fields,\n-                        tps\n+                        struct_def.fields,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n                 },\n-                ast::item_enum(ref enum_def, tps) => {\n+                ast::item_enum(ref enum_def, ref tps) => {\n                     let deser_impl = mk_enum_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        (*enum_def),\n-                        tps\n+                        *enum_def,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n@@ -410,7 +410,7 @@ fn mk_impl(\n     ident: ast::ident,\n     ty_param: ast::ty_param,\n     path: @ast::path,\n-    tps: ~[ast::ty_param],\n+    tps: &[ast::ty_param],\n     f: fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n     // All the type parameters need to bound to the trait.\n@@ -458,7 +458,7 @@ fn mk_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    tps: ~[ast::ty_param],\n+    tps: &[ast::ty_param],\n     body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialize::Encodable typaram.\n@@ -666,8 +666,8 @@ fn mk_struct_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n+    fields: &[@ast::struct_field],\n+    tps: &[ast::ty_param]\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| self.$(name).encode(__s)`\n@@ -808,7 +808,7 @@ struct field {\n     mutbl: ast::mutability,\n }\n \n-fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n+fn mk_struct_fields(fields: &[@ast::struct_field]) -> ~[field] {\n     do fields.map |field| {\n         let (ident, mutbl) = match field.node.kind {\n             ast::named_field(ident, mutbl, _) => (ident, mutbl),"}, {"sha": "fc55fd84a87308dc69eafeb2c5429f395d6c5bfa", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -75,9 +75,11 @@ pub enum SyntaxExtension {\n     ItemTT(SyntaxExpanderTTItem),\n }\n \n+type SyntaxExtensions = HashMap<@~str, SyntaxExtension>;\n+\n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-pub fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n+pub fn syntax_expander_table() -> SyntaxExtensions {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> SyntaxExtension {\n         NormalTT(SyntaxExpanderTT{expander: f, span: None})\n@@ -87,74 +89,74 @@ pub fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n         ItemTT(SyntaxExpanderTTItem{expander: f, span: None})\n     }\n     let syntax_expanders = HashMap();\n-    syntax_expanders.insert(~\"macro_rules\",\n+    syntax_expanders.insert(@~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(~\"fmt\",\n+    syntax_expanders.insert(@~\"fmt\",\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n-        ~\"auto_encode\",\n+        @~\"auto_encode\",\n         ItemDecorator(ext::auto_encode::expand_auto_encode));\n     syntax_expanders.insert(\n-        ~\"auto_decode\",\n+        @~\"auto_decode\",\n         ItemDecorator(ext::auto_encode::expand_auto_decode));\n-    syntax_expanders.insert(~\"env\",\n+    syntax_expanders.insert(@~\"env\",\n                             builtin_normal_tt(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(~\"concat_idents\",\n+    syntax_expanders.insert(@~\"concat_idents\",\n                             builtin_normal_tt(\n                                 ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(~\"log_syntax\",\n+    syntax_expanders.insert(@~\"log_syntax\",\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(~\"deriving_eq\",\n+    syntax_expanders.insert(@~\"deriving_eq\",\n                             ItemDecorator(\n                                 ext::deriving::expand_deriving_eq));\n-    syntax_expanders.insert(~\"deriving_iter_bytes\",\n+    syntax_expanders.insert(@~\"deriving_iter_bytes\",\n                             ItemDecorator(\n                                 ext::deriving::expand_deriving_iter_bytes));\n \n     // Quasi-quoting expanders\n-    syntax_expanders.insert(~\"quote_tokens\",\n+    syntax_expanders.insert(@~\"quote_tokens\",\n                        builtin_normal_tt(ext::quote::expand_quote_tokens));\n-    syntax_expanders.insert(~\"quote_expr\",\n+    syntax_expanders.insert(@~\"quote_expr\",\n                             builtin_normal_tt(ext::quote::expand_quote_expr));\n-    syntax_expanders.insert(~\"quote_ty\",\n+    syntax_expanders.insert(@~\"quote_ty\",\n                             builtin_normal_tt(ext::quote::expand_quote_ty));\n-    syntax_expanders.insert(~\"quote_item\",\n+    syntax_expanders.insert(@~\"quote_item\",\n                             builtin_normal_tt(ext::quote::expand_quote_item));\n-    syntax_expanders.insert(~\"quote_pat\",\n+    syntax_expanders.insert(@~\"quote_pat\",\n                             builtin_normal_tt(ext::quote::expand_quote_pat));\n-    syntax_expanders.insert(~\"quote_stmt\",\n+    syntax_expanders.insert(@~\"quote_stmt\",\n                             builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n-    syntax_expanders.insert(~\"line\",\n+    syntax_expanders.insert(@~\"line\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_line));\n-    syntax_expanders.insert(~\"col\",\n+    syntax_expanders.insert(@~\"col\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_col));\n-    syntax_expanders.insert(~\"file\",\n+    syntax_expanders.insert(@~\"file\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_file));\n-    syntax_expanders.insert(~\"stringify\",\n+    syntax_expanders.insert(@~\"stringify\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_stringify));\n-    syntax_expanders.insert(~\"include\",\n+    syntax_expanders.insert(@~\"include\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include));\n-    syntax_expanders.insert(~\"include_str\",\n+    syntax_expanders.insert(@~\"include_str\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include_str));\n-    syntax_expanders.insert(~\"include_bin\",\n+    syntax_expanders.insert(@~\"include_bin\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include_bin));\n-    syntax_expanders.insert(~\"module_path\",\n+    syntax_expanders.insert(@~\"module_path\",\n                             builtin_normal_tt(\n                                 ext::source_util::expand_mod));\n-    syntax_expanders.insert(~\"proto\",\n+    syntax_expanders.insert(@~\"proto\",\n                             builtin_item_tt(ext::pipes::expand_proto));\n     syntax_expanders.insert(\n-        ~\"trace_macros\",\n+        @~\"trace_macros\",\n         builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n     return syntax_expanders;\n }"}, {"sha": "f9a0de6535b755f3fe326a871942aa1572b6d0d2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n use ast::{tt_delim, tt_tok, item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use ast;\n+use attr;\n use codemap::{span, ExpandedFrom};\n use ext::base::*;\n use fold::*;\n@@ -22,7 +23,7 @@ use core::option;\n use core::vec;\n use std::oldmap::HashMap;\n \n-pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n+pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n                    e: expr_, s: span, fld: ast_fold,\n                    orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n@@ -40,7 +41,7 @@ pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n                 /* using idents and token::special_idents would make the\n                 the macro names be hygienic */\n                 let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(extname) {\n+                match exts.find(&extname) {\n                   None => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n@@ -87,7 +88,7 @@ pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n+pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n                         module_: ast::_mod, fld: ast_fold,\n                         orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n@@ -99,16 +100,13 @@ pub fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n     // the item into a new set of items.\n     let new_items = do vec::flat_map(module_.items) |item| {\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n-            let mname = match attr.node.value.node {\n-              ast::meta_word(ref n) => (*n),\n-              ast::meta_name_value(ref n, _) => (*n),\n-              ast::meta_list(ref n, _) => (*n)\n-            };\n+            let mname = attr::get_attr_name(attr);\n+\n             match exts.find(&mname) {\n               None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n               Some(ItemDecorator(dec_fn)) => {\n                   cx.bt_push(ExpandedFrom({call_site: attr.span,\n-                                           callie: {name: copy mname,\n+                                           callie: {name: /*bad*/ copy *mname,\n                                                     span: None}}));\n                   let r = dec_fn(cx, attr.span, attr.node.value, items);\n                   cx.bt_pop();\n@@ -123,7 +121,7 @@ pub fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n \n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(exts: HashMap<~str, SyntaxExtension>,\n+pub fn expand_item(exts: SyntaxExtensions,\n                    cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n                    orig: fn@(&&v: @ast::item, ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n@@ -149,7 +147,7 @@ pub fn expand_item(exts: HashMap<~str, SyntaxExtension>,\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n+pub fn expand_item_mac(exts: SyntaxExtensions,\n                        cx: ext_ctxt, &&it: @ast::item,\n                        fld: ast_fold) -> Option<@ast::item> {\n \n@@ -161,7 +159,7 @@ pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n     };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match exts.find(extname) {\n+    let expanded = match exts.find(&extname) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extname)),\n \n@@ -200,15 +198,15 @@ pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n         MRAny(_, item_maker, _) =>\n             option::chain(item_maker(), |i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n-            exts.insert((*mdef).name, (*mdef).ext);\n+            exts.insert(@/*bad*/ copy mdef.name, (*mdef).ext);\n             None\n         }\n     };\n     cx.bt_pop();\n     return maybe_it;\n }\n \n-pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n+pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n                    && s: stmt_, sp: span, fld: ast_fold,\n                    orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n                 -> (stmt_, span) {\n@@ -224,7 +222,7 @@ pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match exts.find(extname) {\n+    let (fully_expanded, sp) = match exts.find(&extname) {\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n "}, {"sha": "f4d0e57c5958d2d5faf60e7e305720144e76f3ff", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -228,9 +228,10 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n         let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: respan(dummy_sp(),\n-                          ast::meta_list(~\"allow\", ~[\n+                          ast::meta_list(@~\"allow\", ~[\n                               @respan(dummy_sp(),\n-                                      ast::meta_word(~\"non_camel_case_types\"))\n+                                      ast::meta_word(\n+                                         @~\"non_camel_case_types\"))\n                           ])),\n             is_sugared_doc: false\n         });"}, {"sha": "cc42a0992cbedd3be70c6d661ab610e6060f49d4", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -54,27 +54,27 @@ pub impl proto::visitor<(), (), ()> for ext_ctxt {\n     fn visit_message(&self, name: ~str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n-          Some(next_state { state: ref next, tys: next_tys }) => {\n+          Some(ref next_state) => {\n             let proto = this.proto;\n-            if !proto.has_state((*next)) {\n+            if !proto.has_state(next_state.state) {\n                 // This should be a span fatal, but then we need to\n                 // track span information.\n                 self.span_err(\n-                    proto.get_state((*next)).span,\n+                    proto.get_state(next_state.state).span,\n                     fmt!(\"message %s steps to undefined state, %s\",\n-                         name, (*next)));\n+                         name, next_state.state));\n             }\n             else {\n-                let next = proto.get_state((*next));\n+                let next = proto.get_state(next_state.state);\n \n-                if next.ty_params.len() != next_tys.len() {\n+                if next.ty_params.len() != next_state.tys.len() {\n                     self.span_err(\n                         next.span, // use a real span\n                         fmt!(\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              name, next.name,\n                              next.ty_params.len(),\n-                             next_tys.len()));\n+                             next_state.tys.len()));\n                 }\n             }\n           }"}, {"sha": "48bd8b03297424ee8e8ff787f26de8ad1d05d8b4", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -50,16 +50,13 @@ pub impl gen_send for message {\n     fn gen_send(&self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         match *self {\n-          message(ref _id, span, tys, this,\n-                  Some(next_state {state: ref next, tys: next_tys})) => {\n+          message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n             debug!(\"pipec: next state exists\");\n-            let next = this.proto.get_state((*next));\n-            assert next_tys.len() == next.ty_params.len();\n+            let next = this.proto.get_state(next_state.state);\n+            assert next_state.tys.len() == next.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n-            let args_ast = (arg_names, tys).map(\n-                |n, t| cx.arg(*n, *t)\n-            );\n+            let args_ast = (arg_names, *tys).map(|n, t| cx.arg(*n, *t));\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n@@ -119,7 +116,7 @@ pub impl gen_send for message {\n \n             let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n                                                       span)\n-                                                 .add_tys(next_tys));\n+                                                 .add_tys(next_state.tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -134,13 +131,13 @@ pub impl gen_send for message {\n                             cx.expr_block(body))\n           }\n \n-            message(ref _id, span, tys, this, None) => {\n+            message(ref _id, span, ref tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n-                let args_ast = (arg_names, tys).map(\n-                    |n, t| cx.arg(cx.ident_of(*n), *t)\n-                );\n+                let args_ast = do (arg_names, *tys).map |n, t| {\n+                    cx.arg(cx.ident_of(*n), *t)\n+                };\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(cx.ident_of(~\"pipe\"),\n@@ -219,8 +216,8 @@ pub impl to_type_decls for state {\n             let message(name, span, tys, this, next) = *m;\n \n             let tys = match next {\n-              Some(next_state { state: ref next, tys: next_tys }) => {\n-                let next = this.proto.get_state((*next));\n+              Some(ref next_state) => {\n+                let next = this.proto.get_state((next_state.state));\n                 let next_name = cx.str_of(next.data_name());\n \n                 let dir = match this.dir {\n@@ -232,7 +229,7 @@ pub impl to_type_decls for state {\n                                 cx.ty_path_ast_builder(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(next_tys)))\n+                                    .add_tys(next_state.tys)))\n               }\n               None => tys\n             };"}, {"sha": "dd0dfd8e44377323261e9666c957fc5822554192", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -59,12 +59,13 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                      arg_reader as reader, argument_gram);\n \n     // Extract the arguments:\n-    let lhses:~[@named_match] = match argument_map.get(&lhs_nm) {\n-      @matched_seq(s, _) => s,\n-      _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n+    let lhses = match argument_map.get(&lhs_nm) {\n+        @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n+        _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n-    let rhses:~[@named_match] = match argument_map.get(&rhs_nm) {\n-      @matched_seq(s, _) => s,\n+\n+    let rhses = match argument_map.get(&rhs_nm) {\n+      @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n "}, {"sha": "dacb6f60e37643226e0249ad29ec42c2f32d14ae", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -82,10 +82,10 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n         node:\n             match mi.node {\n                 meta_word(ref id) => meta_word((*id)),\n-                meta_list(ref id, mis) => {\n-                    let fold_meta_item = |x|fold_meta_item_(x, fld);\n-                    meta_list(/* FIXME: (#2543) */ copy (*id),\n-                        vec::map(mis, |e| fold_meta_item(*e)))\n+                meta_list(ref id, ref mis) => {\n+                    let fold_meta_item = |x| fold_meta_item_(x, fld);\n+                    meta_list(/* FIXME: (#2543) */ copy *id,\n+                              mis.map(|e| fold_meta_item(*e)))\n                 }\n                 meta_name_value(ref id, s) => {\n                     meta_name_value((*id), /* FIXME (#2543) */ copy s)\n@@ -213,52 +213,54 @@ fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n }\n \n pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n-    return match i {\n-          item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-          item_fn(decl, purity, typms, ref body) => {\n-              item_fn(fold_fn_decl(decl, fld),\n-                      purity,\n-                      fold_ty_params(typms, fld),\n-                      fld.fold_block((*body)))\n-          }\n-          item_mod(m) => item_mod(fld.fold_mod(m)),\n-          item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n-          item_ty(t, typms) => item_ty(fld.fold_ty(t),\n-                                       fold_ty_params(typms, fld)),\n-          item_enum(ref enum_definition, typms) => {\n+    match i {\n+        item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n+        item_fn(ref decl, purity, ref typms, ref body) => {\n+            item_fn(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n+                    purity,\n+                    fold_ty_params(/* FIXME (#2543) */ copy *typms, fld),\n+                    fld.fold_block(*body))\n+        }\n+        item_mod(m) => item_mod(fld.fold_mod(m)),\n+        item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n+        item_ty(t, typms) => item_ty(fld.fold_ty(t),\n+                                     fold_ty_params(typms, fld)),\n+        item_enum(ref enum_definition, ref typms) => {\n             item_enum(ast::enum_def(ast::enum_def_ {\n                 variants: enum_definition.variants.map(\n                     |x| fld.fold_variant(*x)),\n                 common: enum_definition.common.map(\n                     |x| fold_struct_def(*x, fld)),\n-            }), fold_ty_params(typms, fld))\n-          }\n-          item_struct(struct_def, typms) => {\n-            let struct_def = fold_struct_def(struct_def, fld);\n-              item_struct(struct_def, /* FIXME (#2543) */ copy typms)\n-          }\n-          item_impl(tps, ifce, ty, ref methods) => {\n-              item_impl(fold_ty_params(tps, fld),\n-                        ifce.map(|p| fold_trait_ref(*p, fld)),\n-                        fld.fold_ty(ty),\n-                        vec::map(*methods, |x| fld.fold_method(*x)))\n-          }\n-          item_trait(tps, traits, ref methods) => {\n-              let methods = do (*methods).map |method| {\n-                  match *method {\n-                      required(*) => copy *method,\n-                      provided(method) => provided(fld.fold_method(method))\n-                  }\n-              };\n-            item_trait(fold_ty_params(tps, fld),\n-                       vec::map(traits, |p| fold_trait_ref(*p, fld)),\n+            }), fold_ty_params(/* FIXME (#2543) */ copy *typms, fld))\n+        }\n+        item_struct(ref struct_def, ref typms) => {\n+            let struct_def = fold_struct_def(\n+                /* FIXME (#2543) */ copy *struct_def,\n+                fld);\n+            item_struct(struct_def, /* FIXME (#2543) */ copy *typms)\n+        }\n+        item_impl(ref tps, ifce, ty, ref methods) => {\n+            item_impl(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n+                      ifce.map(|p| fold_trait_ref(*p, fld)),\n+                      fld.fold_ty(ty),\n+                      methods.map(|x| fld.fold_method(*x)))\n+        }\n+        item_trait(ref tps, ref traits, ref methods) => {\n+            let methods = do methods.map |method| {\n+                match *method {\n+                    required(*) => copy *method,\n+                    provided(method) => provided(fld.fold_method(method))\n+                }\n+            };\n+            item_trait(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n+                       traits.map(|p| fold_trait_ref(*p, fld)),\n                        methods)\n-          }\n-      item_mac(ref m) => {\n-        // FIXME #2888: we might actually want to do something here.\n-        item_mac((*m))\n-      }\n-        };\n+        }\n+        item_mac(ref m) => {\n+            // FIXME #2888: we might actually want to do something here.\n+            item_mac((*m))\n+        }\n+    }\n }\n \n fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n@@ -466,14 +468,14 @@ pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_match(fld.fold_expr(expr),\n                      vec::map((*arms), |x| fld.fold_arm(*x)))\n           }\n-          expr_fn(proto, decl, ref body, _) => {\n+          expr_fn(proto, ref decl, ref body, _) => {\n             expr_fn(proto,\n-                    fold_fn_decl(decl, fld),\n+                    fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n                     fld.fold_block(*body),\n                     @())\n           }\n-          expr_fn_block(decl, ref body) => {\n-            expr_fn_block(fold_fn_decl(decl, fld),\n+          expr_fn_block(ref decl, ref body) => {\n+            expr_fn_block(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n                           fld.fold_block(*body))\n           }\n           expr_block(ref blk) => expr_block(fld.fold_block((*blk))),"}, {"sha": "34ac5c16841a11b0ffb381aa5b55b4e943c098cb", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -126,23 +126,23 @@ impl parser_attr for Parser {\n \n     fn parse_meta_item() -> @ast::meta_item {\n         let lo = self.span.lo;\n-        let name = *self.id_to_str(self.parse_ident());\n+        let name = self.id_to_str(self.parse_ident());\n         match self.token {\n-          token::EQ => {\n-            self.bump();\n-            let lit = self.parse_lit();\n-            let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_name_value(name, lit));\n-          }\n-          token::LPAREN => {\n-            let inner_items = self.parse_meta_seq();\n-            let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_list(name, inner_items));\n-          }\n-          _ => {\n-            let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_word(name));\n-          }\n+            token::EQ => {\n+                self.bump();\n+                let lit = self.parse_lit();\n+                let mut hi = self.span.hi;\n+                @spanned(lo, hi, ast::meta_name_value(name, lit))\n+            }\n+            token::LPAREN => {\n+                let inner_items = self.parse_meta_seq();\n+                let mut hi = self.span.hi;\n+                @spanned(lo, hi, ast::meta_list(name, inner_items))\n+            }\n+            _ => {\n+                let mut hi = self.span.hi;\n+                @spanned(lo, hi, ast::meta_word(name))\n+            }\n         }\n     }\n "}, {"sha": "e27784d1f6b4477c5331f44cc852db46767a445d", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -46,14 +46,14 @@ impl cmp::Eq for cmnt_style {\n \n pub type cmnt = {style: cmnt_style, lines: ~[~str], pos: BytePos};\n \n-pub fn is_doc_comment(s: ~str) -> bool {\n+pub fn is_doc_comment(s: &str) -> bool {\n     (s.starts_with(~\"///\") && !is_line_non_doc_comment(s)) ||\n     s.starts_with(~\"//!\") ||\n     (s.starts_with(~\"/**\") && !is_block_non_doc_comment(s)) ||\n     s.starts_with(~\"/*!\")\n }\n \n-pub fn doc_comment_style(comment: ~str) -> ast::attr_style {\n+pub fn doc_comment_style(comment: &str) -> ast::attr_style {\n     assert is_doc_comment(comment);\n     if comment.starts_with(~\"//!\") || comment.starts_with(~\"/*!\") {\n         ast::attr_inner\n@@ -62,7 +62,7 @@ pub fn doc_comment_style(comment: ~str) -> ast::attr_style {\n     }\n }\n \n-pub fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n+pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: ~[~str]) -> ~[~str] {"}, {"sha": "644d6ed5189a92e6d3af530b1b2d164e34f404f7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -3267,11 +3267,11 @@ pub impl Parser {\n         // on the mod, then we'll go and suck in another file and merge\n         // its contents\n         match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n-            Some(ref path) => {\n+            Some(path) => {\n                 let prefix = Path(\n                     self.sess.cm.span_to_filename(copy self.span));\n                 let prefix = prefix.dir_path();\n-                let path = Path((*path));\n+                let path = Path(copy *path);\n                 let (new_mod_item, new_attrs) = self.eval_src_mod_from_path(\n                     prefix, path, ~[], id_span);\n \n@@ -3300,7 +3300,7 @@ pub impl Parser {\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, ~\"path\") {\n \n-            Some(ref d) => (*d),\n+            Some(d) => copy *d,\n             None => copy *default_path\n         };\n         self.mod_path_stack.push(file_path)\n@@ -3320,10 +3320,10 @@ pub impl Parser {\n         let default_path = self.sess.interner.get(id) + ~\".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, ~\"path\") {\n-            Some(ref d) => {\n-                let path = Path(*d);\n+            Some(d) => {\n+                let path = Path(copy *d);\n                 if !path.is_absolute {\n-                    mod_path.push(*d)\n+                    mod_path.push(copy *d)\n                 } else {\n                     path\n                 }\n@@ -3357,7 +3357,7 @@ pub impl Parser {\n \n         fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n             match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-                Some(ref d) => (*d),\n+                Some(d) => copy *d,\n                 None => default\n             }\n         }"}, {"sha": "f145e433fa7c195f363d1b0122917d3bfad1303e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -429,7 +429,7 @@ pub fn mk_ident_interner() -> @ident_interner {\n                 ];\n \n                 let rv = @ident_interner {\n-                    interner: interner::mk_prefill(init_vec)\n+                    interner: interner::Interner::prefill(init_vec)\n                 };\n \n                 task::local_data::local_data_set(interner_key!(), @rv);\n@@ -443,7 +443,7 @@ pub fn mk_ident_interner() -> @ident_interner {\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @ident_interner {\n-    @ident_interner { interner: interner::mk::<@~str>() }\n+    @ident_interner { interner: interner::Interner::new() }\n }\n \n /**"}, {"sha": "eeba00be7046110d1c37d3798546b88ef77d222d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -498,9 +498,16 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(decl, purity, typarams, ref body) => {\n-        print_fn(s, decl, Some(purity), item.ident, typarams, None,\n-                 item.vis);\n+      ast::item_fn(ref decl, purity, ref typarams, ref body) => {\n+        print_fn(\n+            s,\n+            /* FIXME (#2543) */ copy *decl,\n+            Some(purity),\n+            item.ident,\n+            /* FIXME (#2543) */ copy *typarams,\n+            None,\n+            item.vis\n+        );\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, (*body), item.attrs);\n       }\n@@ -542,9 +549,15 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         word(s.s, ~\";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_enum(ref enum_definition, params) => {\n-        print_enum_def(s, (*enum_definition), params, item.ident,\n-                       item.span, item.vis);\n+      ast::item_enum(ref enum_definition, ref params) => {\n+        print_enum_def(\n+            s,\n+            *enum_definition,\n+            /* FIXME (#2543) */ copy *params,\n+            item.ident,\n+            item.span,\n+            item.vis\n+        );\n       }\n       ast::item_struct(struct_def, tps) => {\n           head(s, visibility_qualified(item.vis, ~\"struct\"));\n@@ -580,13 +593,13 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_trait(tps, traits, ref methods) => {\n+      ast::item_trait(ref tps, ref traits, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"trait\"));\n         print_ident(s, item.ident);\n-        print_type_params(s, tps);\n-        if vec::len(traits) != 0u {\n+        print_type_params(s, /* FIXME (#2543) */ copy *tps);\n+        if traits.len() != 0u {\n             word(s.s, ~\":\");\n-            for vec::each(traits) |trait_| {\n+            for traits.each |trait_| {\n                 nbsp(s);\n                 print_path(s, trait_.path, false);\n             }\n@@ -622,7 +635,7 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n         ident == enum_definition.variants[0].node.name;\n     if newtype {\n         match enum_definition.variants[0].node.kind {\n-            ast::tuple_variant_kind(args) if args.len() == 1 => {}\n+            ast::tuple_variant_kind(ref args) if args.len() == 1 => {}\n             _ => newtype = false\n         }\n     }\n@@ -887,7 +900,7 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n     if attr.node.is_sugared_doc {\n         let meta = attr::attr_meta(attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n-        word(s.s, comment);\n+        word(s.s, *comment);\n     } else {\n         word(s.s, ~\"#[\");\n         print_meta_item(s, @attr.node.value);\n@@ -1331,24 +1344,24 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, match_indent_unit);\n       }\n-      ast::expr_fn(sigil, decl, ref body, _) => {\n+      ast::expr_fn(sigil, ref decl, ref body, _) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n                              Some(sigil), ast::inherited);\n-        print_fn_args_and_ret(s, decl, None);\n+        print_fn_args_and_ret(s, /* FIXME (#2543) */ copy *decl, None);\n         space(s.s);\n         print_block(s, (*body));\n       }\n-      ast::expr_fn_block(decl, ref body) => {\n+      ast::expr_fn_block(ref decl, ref body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        print_fn_block_args(s, decl);\n+        print_fn_block_args(s, /* FIXME (#2543) */ copy *decl);\n         space(s.s);\n         // }\n         assert (*body).node.stmts.is_empty();\n@@ -1812,16 +1825,21 @@ pub fn print_type_params(s: @ps, &&params: ~[ast::ty_param]) {\n pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::meta_word(ref name) => word(s.s, (*name)),\n-      ast::meta_name_value(ref name, value) => {\n-        word_space(s, (*name));\n+      ast::meta_word(name) => word(s.s, *name),\n+      ast::meta_name_value(name, value) => {\n+        word_space(s, *name);\n         word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n-      ast::meta_list(ref name, items) => {\n-        word(s.s, (*name));\n+      ast::meta_list(name, ref items) => {\n+        word(s.s, *name);\n         popen(s);\n-        commasep(s, consistent, items, print_meta_item);\n+        commasep(\n+            s,\n+            consistent,\n+            /* FIXME (#2543) */ copy *items,\n+            print_meta_item\n+        );\n         pclose(s);\n       }\n     }"}, {"sha": "dcb3261169be4b094b69e82e51c6d9fce9bd13ce", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -14,72 +14,66 @@\n \n use core::prelude::*;\n \n-use core::dvec::DVec;\n-use std::oldmap::HashMap;\n-use std::oldmap;\n+use hashmap::linear::LinearMap;\n+use dvec::DVec;\n \n-pub type hash_interner<T> = {map: HashMap<T, uint>, vect: DVec<T>};\n-\n-pub fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n-    let m = oldmap::HashMap::<T, uint>();\n-    let hi: hash_interner<T> =\n-        {map: m, vect: DVec()};\n-    ((hi) as Interner::<T>)\n-}\n-\n-pub fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: &[T]) -> Interner<T> {\n-    let rv = mk();\n-    for init.each() |v| { rv.intern(*v); }\n-    return rv;\n+pub struct Interner<T> {\n+    priv mut map: LinearMap<T, uint>,\n+    priv vect: DVec<T>,\n }\n \n+// when traits can extend traits, we should extend index<uint,T> to get []\n+pub impl<T: Eq IterBytes Hash Const Copy> Interner<T> {\n+    static fn new() -> Interner<T> {\n+        Interner {\n+            map: LinearMap::new(),\n+            vect: DVec(),\n+        }\n+    }\n \n-/* when traits can extend traits, we should extend index<uint,T> to get [] */\n-pub trait Interner<T:Eq IterBytes Hash Const Copy> {\n-    fn intern(T) -> uint;\n-    fn gensym(T) -> uint;\n-    pure fn get(uint) -> T;\n-    fn len() -> uint;\n-}\n+    static fn prefill(init: &[T]) -> Interner<T> {\n+        let rv = Interner::new();\n+        for init.each() |v| { rv.intern(*v); }\n+        rv\n+    }\n \n-pub impl<T:Eq IterBytes Hash Const Copy> Interner<T> for hash_interner<T> {\n-    fn intern(val: T) -> uint {\n+    fn intern(&self, val: T) -> uint {\n         match self.map.find(&val) {\n-          Some(idx) => return idx,\n-          None => {\n-            let new_idx = self.vect.len();\n-            self.map.insert(val, new_idx);\n-            self.vect.push(val);\n-            return new_idx;\n-          }\n+            Some(&idx) => return idx,\n+            None => (),\n         }\n+\n+        let new_idx = self.vect.len();\n+        self.map.insert(val, new_idx);\n+        self.vect.push(val);\n+        new_idx\n     }\n-    fn gensym(val: T) -> uint {\n+\n+    fn gensym(&self, val: T) -> uint {\n         let new_idx = self.vect.len();\n         // leave out of .map to avoid colliding\n         self.vect.push(val);\n-        return new_idx;\n+        new_idx\n     }\n \n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pure fn get(idx: uint) -> T { self.vect.get_elt(idx) }\n+    pure fn get(&self, idx: uint) -> T { self.vect.get_elt(idx) }\n \n-    fn len() -> uint { return self.vect.len(); }\n+    fn len(&self) -> uint { self.vect.len() }\n }\n \n-\n #[test]\n #[should_fail]\n pub fn i1 () {\n-    let i : Interner<@~str> = mk();\n+    let i : Interner<@~str> = Interner::new();\n     i.get(13);\n }\n \n #[test]\n pub fn i2 () {\n-    let i : Interner<@~str> = mk();\n+    let i : Interner<@~str> = Interner::new();\n     // first one is zero:\n     assert i.intern (@~\"dog\") == 0;\n     // re-use gets the same entry:\n@@ -104,7 +98,7 @@ pub fn i2 () {\n \n #[test]\n pub fn i3 () {\n-    let i : Interner<@~str> = mk_prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n+    let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n     assert i.get(0) == @~\"Alan\";\n     assert i.get(1) == @~\"Bob\";\n     assert i.get(2) == @~\"Carol\";"}, {"sha": "3701607ffc13faa0f329d6ace987f6ceed27bb3a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f956fc3b2ad6f1b8db3d580a409fb5636c8297f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1f956fc3b2ad6f1b8db3d580a409fb5636c8297f", "patch": "@@ -137,11 +137,20 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty)(t, e, v);\n         (v.visit_expr)(ex, e, v);\n       }\n-      item_fn(decl, purity, tp, ref body) => {\n-        (v.visit_fn)(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n-                              /* FIXME (#2543) */ copy tp,\n-                              purity), decl, (*body),\n-                   i.span, i.id, e, v);\n+      item_fn(ref decl, purity, ref tp, ref body) => {\n+        (v.visit_fn)(\n+            fk_item_fn(\n+                /* FIXME (#2543) */ copy i.ident,\n+                /* FIXME (#2543) */ copy *tp,\n+                purity\n+            ),\n+            /* FIXME (#2543) */ copy *decl,\n+            (*body),\n+            i.span,\n+            i.id,\n+            e,\n+            v\n+        );\n       }\n       item_mod(m) => (v.visit_mod)(m, i.span, i.id, e, v),\n       item_foreign_mod(nm) => {\n@@ -152,9 +161,14 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty)(t, e, v);\n         (v.visit_ty_params)(tps, e, v);\n       }\n-      item_enum(ref enum_definition, tps) => {\n-        (v.visit_ty_params)(tps, e, v);\n-        visit_enum_def((*enum_definition), tps, e, v);\n+      item_enum(ref enum_definition, ref tps) => {\n+        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n+        visit_enum_def(\n+            *enum_definition,\n+            /* FIXME (#2543) */ copy *tps,\n+            e,\n+            v\n+        );\n       }\n       item_impl(tps, traits, ty, methods) => {\n         (v.visit_ty_params)(tps, e, v);\n@@ -170,8 +184,8 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty_params)(tps, e, v);\n         (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n       }\n-      item_trait(tps, traits, ref methods) => {\n-        (v.visit_ty_params)(tps, e, v);\n+      item_trait(ref tps, ref traits, ref methods) => {\n+        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n         for (*methods).each |m| {\n             (v.visit_trait_method)(*m, e, v);\n@@ -460,13 +474,27 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(x, e, v);\n         for (*arms).each |a| { (v.visit_arm)(*a, e, v); }\n       }\n-      expr_fn(proto, decl, ref body, _) => {\n-        (v.visit_fn)(fk_anon(proto), decl, (*body),\n-                     ex.span, ex.id, e, v);\n-      }\n-      expr_fn_block(decl, ref body) => {\n-        (v.visit_fn)(fk_fn_block, decl, (*body),\n-                     ex.span, ex.id, e, v);\n+      expr_fn(proto, ref decl, ref body, _) => {\n+        (v.visit_fn)(\n+            fk_anon(proto),\n+            /* FIXME (#2543) */ copy *decl,\n+            *body,\n+            ex.span,\n+            ex.id,\n+            e,\n+            v\n+        );\n+      }\n+      expr_fn_block(ref decl, ref body) => {\n+        (v.visit_fn)(\n+            fk_fn_block,\n+            /* FIXME (#2543) */ copy *decl,\n+            *body,\n+            ex.span,\n+            ex.id,\n+            e,\n+            v\n+        );\n       }\n       expr_block(ref b) => (v.visit_block)((*b), e, v),\n       expr_assign(a, b) => {"}]}