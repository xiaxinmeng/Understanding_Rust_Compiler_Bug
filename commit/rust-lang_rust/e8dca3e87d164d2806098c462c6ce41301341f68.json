{"sha": "e8dca3e87d164d2806098c462c6ce41301341f68", "node_id": "C_kwDOAAsO6NoAKGU4ZGNhM2U4N2QxNjRkMjgwNjA5OGM0NjJjNmNlNDEzMDEzNDFmNjg", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-06-07T02:03:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-07T02:03:09Z"}, "message": "Merge pull request #179 from rust-lang/sync_from_rust2\n\nSync from rust2", "tree": {"sha": "0b2a260ac92deb9008aa22b55bb0995ba03b304f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b2a260ac92deb9008aa22b55bb0995ba03b304f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8dca3e87d164d2806098c462c6ce41301341f68", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJinrHdCRBK7hj4Ov3rIwAA6nUIAH36KDabnnUa6pC3RcUZ1eYV\nvyoByf75RpOwN0LzMb2QoOOf54zO4P8Ped5021sxyJ8qDR6qzu1mpJvRI7Gf5GEf\nbws7ELN5fTMBvxlPzLZiHR4EzYfVn3mHiQJUiFKYSV8b9ePZkU1fg202IdWrQO12\nyz8nKQGE4X7MVz2ITlH4SgUOHTg+jI63qrpWmgiz0BCz30WxEyru2T6g9VmuRkaS\njDYviOB4GUxBacWMVVKXgCe2ALIRdsxnO+k5oxrI0YMHnu4Bgz1F+V3FSRI9Gqgj\nmt6l8LjMwr8t47f6/nRtDZfIMAYF3R4HyXvYVbzK55nIOWTcOZsU1li1a2Qd11M=\n=8NfJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 0b2a260ac92deb9008aa22b55bb0995ba03b304f\nparent 7e0a42b4927a213b8e6ceeec6d842eb0faaf0d26\nparent fb69f73d67337e740fad0cfd5a9221f7757ff5f2\nauthor antoyo <antoyo@users.noreply.github.com> 1654567389 -0400\ncommitter GitHub <noreply@github.com> 1654567389 -0400\n\nMerge pull request #179 from rust-lang/sync_from_rust2\n\nSync from rust2"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8dca3e87d164d2806098c462c6ce41301341f68", "html_url": "https://github.com/rust-lang/rust/commit/e8dca3e87d164d2806098c462c6ce41301341f68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8dca3e87d164d2806098c462c6ce41301341f68/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0a42b4927a213b8e6ceeec6d842eb0faaf0d26", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0a42b4927a213b8e6ceeec6d842eb0faaf0d26", "html_url": "https://github.com/rust-lang/rust/commit/7e0a42b4927a213b8e6ceeec6d842eb0faaf0d26"}, {"sha": "fb69f73d67337e740fad0cfd5a9221f7757ff5f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb69f73d67337e740fad0cfd5a9221f7757ff5f2", "html_url": "https://github.com/rust-lang/rust/commit/fb69f73d67337e740fad0cfd5a9221f7757ff5f2"}], "stats": {"total": 221, "additions": 154, "deletions": 67}, "files": [{"sha": "fe23a26769663f3a2f61b1ccdf8a3d65ab975d70", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -12,7 +12,7 @@ A secondary goal is to check if using the gcc backend will provide any run-time\n ## Building\n \n **This requires a patched libgccjit in order to work.\n-The patches in [this repostory](https://github.com/antoyo/libgccjit-patches) need to be applied.\n+The patches in [this repository](https://github.com/antoyo/libgccjit-patches) need to be applied.\n (Those patches should work when applied on master, but in case it doesn't work, they are known to work when applied on 079c23cfe079f203d5df83fea8e92a60c7d7e878.)\n You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already includes these patches.**\n "}, {"sha": "3af0ba09e0bace078927a61793a067ab20f0674c", "filename": "example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/example%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/example%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -37,7 +37,7 @@ impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n \n trait Trait {\n     // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n-    // without unsized_locals), but wrappers arond `Self` currently are not.\n+    // without unsized_locals), but wrappers around `Self` currently are not.\n     // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n     // fn wrapper(self: Wrapper<Self>) -> i32;\n     fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;"}, {"sha": "b20aeb979ad78d5b17e00157b514974b8de5bc3f", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-03-26\"\n+channel = \"nightly-2022-06-06\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "041079bc9c6f79a9cd305dd7190fb0f5bd8b8001", "filename": "rustup.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/rustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/rustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustup.sh?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -10,7 +10,7 @@ case $1 in\n         rustup toolchain install --profile minimal nightly-${TOOLCHAIN} # Sanity check to see if the nightly exists\n         echo nightly-${TOOLCHAIN} > rust-toolchain\n \n-        echo \"=> Uninstalling all old nighlies\"\n+        echo \"=> Uninstalling all old nightlies\"\n         for nightly in $(rustup toolchain list | grep nightly | grep -v $TOOLCHAIN | grep -v nightly-x86_64); do\n             rustup toolchain uninstall $nightly\n         done"}, {"sha": "52fd66af0659d624384ed5a924521d9d771658b9", "filename": "src/asm.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -258,9 +258,14 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 }\n \n                 InlineAsmOperandRef::SymFn { instance } => {\n+                    // TODO(@Amanieu): Additional mangling is needed on\n+                    // some targets to add a leading underscore (Mach-O)\n+                    // or byte count suffixes (x86 Windows).\n                     constants_len += self.tcx.symbol_name(instance).name.len();\n                 }\n                 InlineAsmOperandRef::SymStatic { def_id } => {\n+                    // TODO(@Amanieu): Additional mangling is needed on\n+                    // some targets to add a leading underscore (Mach-O).\n                     constants_len += self.tcx.symbol_name(Instance::mono(self.tcx, def_id)).name.len();\n                 }\n             }\n@@ -427,13 +432,16 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         }\n \n                         InlineAsmOperandRef::SymFn { instance } => {\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O)\n+                            // or byte count suffixes (x86 Windows).\n                             let name = self.tcx.symbol_name(instance).name;\n                             template_str.push_str(name);\n                         }\n \n                         InlineAsmOperandRef::SymStatic { def_id } => {\n-                            // TODO(@Commeownist): This may not be sufficient for all kinds of statics.\n-                            // Some statics may need the `@plt` suffix, like thread-local vars.\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O).\n                             let instance = Instance::mono(self.tcx, def_id);\n                             let name = self.tcx.symbol_name(instance).name;\n                             template_str.push_str(name);\n@@ -596,9 +604,10 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => unimplemented!(),\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n-                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,\n+                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg,\n             ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n@@ -661,6 +670,8 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => cx.type_i16(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::tmm_reg) => unimplemented!(),\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n@@ -671,8 +682,8 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n     }\n }\n \n-impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n-    fn codegen_global_asm(&self, template: &[InlineAsmTemplatePiece], operands: &[GlobalAsmOperandRef], options: InlineAsmOptions, _line_spans: &[Span]) {\n+impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn codegen_global_asm(&self, template: &[InlineAsmTemplatePiece], operands: &[GlobalAsmOperandRef<'tcx>], options: InlineAsmOptions, _line_spans: &[Span]) {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n         // Default to Intel syntax on x86\n@@ -705,6 +716,22 @@ impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n                             // here unlike normal inline assembly.\n                             template_str.push_str(string);\n                         }\n+\n+                        GlobalAsmOperandRef::SymFn { instance } => {\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O)\n+                            // or byte count suffixes (x86 Windows).\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n+                        GlobalAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(@Amanieu): Additional mangling is needed on\n+                            // some targets to add a leading underscore (Mach-O).\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n                     }\n                 }\n             }\n@@ -775,7 +802,8 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg) => {\n             unreachable!(\"clobber-only\")\n         }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),"}, {"sha": "efcf18d31eb09a69d345f94f5081b16b3612a20c", "filename": "src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fback%2Fwrite.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -11,7 +11,7 @@ use rustc_target::spec::SplitDebuginfo;\n use crate::{GccCodegenBackend, GccContext};\n \n pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_handler: &Handler, module: ModuleCodegen<GccContext>, config: &ModuleConfig) -> Result<CompiledModule, FatalError> {\n-    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &module.name[..]);\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &*module.name);\n     {\n         let context = &module.module_llvm.context;\n "}, {"sha": "fa490fe3f222ebdd8801020d150036e714ed2227", "filename": "src/builder.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -62,24 +62,6 @@ enum ExtremumOperation {\n     Min,\n }\n \n-trait EnumClone {\n-    fn clone(&self) -> Self;\n-}\n-\n-impl EnumClone for AtomicOrdering {\n-    fn clone(&self) -> Self {\n-        match *self {\n-            AtomicOrdering::NotAtomic => AtomicOrdering::NotAtomic,\n-            AtomicOrdering::Unordered => AtomicOrdering::Unordered,\n-            AtomicOrdering::Monotonic => AtomicOrdering::Monotonic,\n-            AtomicOrdering::Acquire => AtomicOrdering::Acquire,\n-            AtomicOrdering::Release => AtomicOrdering::Release,\n-            AtomicOrdering::AcquireRelease => AtomicOrdering::AcquireRelease,\n-            AtomicOrdering::SequentiallyConsistent => AtomicOrdering::SequentiallyConsistent,\n-        }\n-    }\n-}\n-\n pub struct Builder<'a: 'gcc, 'gcc, 'tcx> {\n     pub cx: &'a CodegenCx<'gcc, 'tcx>,\n     pub block: Block<'gcc>,\n@@ -104,9 +86,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             match order {\n                 // TODO(antoyo): does this make sense?\n                 AtomicOrdering::AcquireRelease | AtomicOrdering::Release => AtomicOrdering::Acquire,\n-                _ => order.clone(),\n+                _ => order,\n             };\n-        let previous_value = self.atomic_load(dst.get_type(), dst, load_ordering.clone(), Size::from_bytes(size));\n+        let previous_value = self.atomic_load(dst.get_type(), dst, load_ordering, Size::from_bytes(size));\n         let previous_var = func.new_local(None, previous_value.get_type(), \"previous_value\");\n         let return_value = func.new_local(None, previous_value.get_type(), \"return_value\");\n         self.llbb().add_assignment(None, previous_var, previous_value);\n@@ -510,8 +492,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn exactudiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): convert the arguments to unsigned?\n         // TODO(antoyo): poison if not exact.\n+        let a_type = a.get_type().to_unsigned(self);\n+        let a = self.gcc_int_cast(a, a_type);\n+        let b_type = b.get_type().to_unsigned(self);\n+        let b = self.gcc_int_cast(b, b_type);\n         a / b\n     }\n \n@@ -520,7 +505,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn exactsdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): posion if not exact.\n+        // TODO(antoyo): poison if not exact.\n         // FIXME(antoyo): rustc_codegen_ssa::mir::intrinsic uses different types for a and b but they\n         // should be the same.\n         let typ = a.get_type().to_signed(self);\n@@ -705,11 +690,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n \n         fn scalar_load_metadata<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, load: RValue<'gcc>, scalar: &abi::Scalar) {\n-            let vr = scalar.valid_range.clone();\n-            match scalar.value {\n+            let vr = scalar.valid_range(bx);\n+            match scalar.primitive() {\n                 abi::Int(..) => {\n                     if !scalar.is_always_valid(bx) {\n-                        bx.range_metadata(load, scalar.valid_range);\n+                        bx.range_metadata(load, vr);\n                     }\n                 }\n                 abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n@@ -735,7 +720,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 OperandValue::Immediate(self.to_immediate(load, place.layout))\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n-                let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n+                let b_offset = a.size(self).align_to(b.align(self).abi);\n                 let pair_type = place.layout.gcc_type(self, false);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n@@ -1275,7 +1260,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn do_not_inline(&mut self, _llret: RValue<'gcc>) {\n-        // FIMXE(bjorn3): implement\n+        // FIXME(bjorn3): implement\n     }\n \n     fn set_span(&mut self, _span: Span) {}\n@@ -1574,9 +1559,8 @@ impl ToGccOrdering for AtomicOrdering {\n \n         let ordering =\n             match self {\n-                AtomicOrdering::NotAtomic => __ATOMIC_RELAXED, // TODO(antoyo): check if that's the same.\n                 AtomicOrdering::Unordered => __ATOMIC_RELAXED,\n-                AtomicOrdering::Monotonic => __ATOMIC_RELAXED, // TODO(antoyo): check if that's the same.\n+                AtomicOrdering::Relaxed => __ATOMIC_RELAXED, // TODO(antoyo): check if that's the same.\n                 AtomicOrdering::Acquire => __ATOMIC_ACQUIRE,\n                 AtomicOrdering::Release => __ATOMIC_RELEASE,\n                 AtomicOrdering::AcquireRelease => __ATOMIC_ACQ_REL,"}, {"sha": "ce341406eaf4561a2d6aefa29283e8ecb28837dc", "filename": "src/common.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -91,6 +91,10 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.const_uint(self.type_i1(), val as u64)\n     }\n \n+    fn const_i16(&self, i: i16) -> RValue<'gcc> {\n+        self.const_int(self.type_i16(), i as i64)\n+    }\n+\n     fn const_i32(&self, i: i32) -> RValue<'gcc> {\n         self.const_int(self.type_i32(), i as i64)\n     }\n@@ -154,14 +158,14 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n-        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        let bitsize = if layout.is_bool() { 1 } else { layout.size(self).bits() };\n         match cv {\n             Scalar::Int(ScalarInt::ZST) => {\n-                assert_eq!(0, layout.value.size(self).bytes());\n+                assert_eq!(0, layout.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             }\n             Scalar::Int(int) => {\n-                let data = int.assert_bits(layout.value.size(self));\n+                let data = int.assert_bits(layout.size(self));\n \n                 // FIXME(antoyo): there's some issues with using the u128 code that follows, so hard-code\n                 // the paths for floating-point values.\n@@ -205,7 +209,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                if layout.value != Pointer {\n+                if layout.primitive() != Pointer {\n                     self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {\n@@ -275,6 +279,21 @@ impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n         else if self.is_u128(cx) {\n             cx.i128_type\n         }\n+        else if self.is_uchar(cx) {\n+            cx.char_type\n+        }\n+        else if self.is_ushort(cx) {\n+            cx.short_type\n+        }\n+        else if self.is_uint(cx) {\n+            cx.int_type\n+        }\n+        else if self.is_ulong(cx) {\n+            cx.long_type\n+        }\n+        else if self.is_ulonglong(cx) {\n+            cx.longlong_type\n+        }\n         else {\n             self.clone()\n         }\n@@ -296,6 +315,21 @@ impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n         else if self.is_i128(cx) {\n             cx.u128_type\n         }\n+        else if self.is_char(cx) {\n+            cx.uchar_type\n+        }\n+        else if self.is_short(cx) {\n+            cx.ushort_type\n+        }\n+        else if self.is_int(cx) {\n+            cx.uint_type\n+        }\n+        else if self.is_long(cx) {\n+            cx.ulong_type\n+        }\n+        else if self.is_longlong(cx) {\n+            cx.ulonglong_type\n+        }\n         else {\n             self.clone()\n         }\n@@ -308,6 +342,11 @@ pub trait TypeReflection<'gcc, 'tcx>  {\n     fn is_uint(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_ulong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_ulonglong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_char(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_short(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_int(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_long(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_longlong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n \n     fn is_i8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_u8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n@@ -328,11 +367,11 @@ pub trait TypeReflection<'gcc, 'tcx>  {\n \n impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n     fn is_uchar(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.u8_type\n+        self.unqualified() == cx.uchar_type\n     }\n \n     fn is_ushort(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.u16_type\n+        self.unqualified() == cx.ushort_type\n     }\n \n     fn is_uint(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n@@ -347,6 +386,26 @@ impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n         self.unqualified() == cx.ulonglong_type\n     }\n \n+    fn is_char(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.char_type\n+    }\n+\n+    fn is_short(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.short_type\n+    }\n+\n+    fn is_int(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.int_type\n+    }\n+\n+    fn is_long(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.long_type\n+    }\n+\n+    fn is_longlong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.longlong_type\n+    }\n+\n     fn is_i8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n         self.unqualified() == cx.i8_type\n     }"}, {"sha": "c0b8d21818f854cbbea2529ed6cf81ec3efe863f", "filename": "src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -329,7 +329,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            abi::Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n+            abi::Scalar::Initialized { value: Primitive::Pointer, valid_range: WrappingRange::full(dl.pointer_size) },\n             cx.type_i8p(),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "44f36cfa4cad4388e11f8ec333deea71c4291f19", "filename": "src/context.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -54,10 +54,15 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub u128_type: Type<'gcc>,\n     pub usize_type: Type<'gcc>,\n \n+    pub char_type: Type<'gcc>,\n+    pub uchar_type: Type<'gcc>,\n+    pub short_type: Type<'gcc>,\n+    pub ushort_type: Type<'gcc>,\n     pub int_type: Type<'gcc>,\n     pub uint_type: Type<'gcc>,\n     pub long_type: Type<'gcc>,\n     pub ulong_type: Type<'gcc>,\n+    pub longlong_type: Type<'gcc>,\n     pub ulonglong_type: Type<'gcc>,\n     pub sizet_type: Type<'gcc>,\n \n@@ -111,7 +116,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// NOTE: a hack is used because the rustc API is not suitable to libgccjit and as such,\n     /// `const_undef()` returns struct as pointer so that they can later be assigned a value.\n     /// As such, this set remembers which of these pointers were returned by this function so that\n-    /// they can be deferenced later.\n+    /// they can be dereferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n }\n@@ -146,10 +151,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let float_type = context.new_type::<f32>();\n         let double_type = context.new_type::<f64>();\n \n+        let char_type = context.new_c_type(CType::Char);\n+        let uchar_type = context.new_c_type(CType::UChar);\n+        let short_type = context.new_c_type(CType::Short);\n+        let ushort_type = context.new_c_type(CType::UShort);\n         let int_type = context.new_c_type(CType::Int);\n         let uint_type = context.new_c_type(CType::UInt);\n         let long_type = context.new_c_type(CType::Long);\n         let ulong_type = context.new_c_type(CType::ULong);\n+        let longlong_type = context.new_c_type(CType::LongLong);\n         let ulonglong_type = context.new_c_type(CType::ULongLong);\n         let sizet_type = context.new_c_type(CType::SizeT);\n \n@@ -202,10 +212,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             u32_type,\n             u64_type,\n             u128_type,\n+            char_type,\n+            uchar_type,\n+            short_type,\n+            ushort_type,\n             int_type,\n             uint_type,\n             long_type,\n             ulong_type,\n+            longlong_type,\n             ulonglong_type,\n             sizet_type,\n "}, {"sha": "c6681de68e2672b6d2f9f1f01cb15901d0dba305", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n-        // TODO(antoyo): switch to asumme when it exists.\n+        // TODO(antoyo): switch to assume when it exists.\n         // Or use something like this:\n         // #define __assume(cond) do { if (!(cond)) __builtin_unreachable(); } while (0)\n         self.expect(value, true);"}, {"sha": "870e9f776a4f08b4b9dbe2f2eec439a356a5ce1d", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -18,6 +18,7 @@ use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n+    #[allow(unused_macro_rules)]\n     macro_rules! emit_error {\n         ($msg: tt) => {\n             emit_error!($msg, )"}, {"sha": "5bfdeb8b93a484fc4077f1efad4372155e5c6137", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -139,14 +139,12 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn new_metadata<'tcx>(&self, _tcx: TyCtxt<'tcx>, _mod_name: &str) -> Self::Module {\n-        GccContext {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) -> Self::Module {\n+        let mut mods = GccContext {\n             context: Context::default(),\n-        }\n-    }\n-\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n-        unsafe { allocator::codegen(tcx, mods, module_name, kind, has_alloc_error_handler) }\n+        };\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, has_alloc_error_handler); }\n+        mods\n     }\n \n     fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n@@ -213,7 +211,7 @@ impl WriteBackendMethods for GccCodegenBackend {\n                     unimplemented!();\n                 }\n             };\n-        Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: vec![] })\n+        Ok(LtoModuleCodegen::Fat { module, _serialized_bitcode: vec![] })\n     }\n \n     fn run_thin_lto(_cgcx: &CodegenContext<Self>, _modules: Vec<(String, Self::ThinBuffer)>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n@@ -229,7 +227,12 @@ impl WriteBackendMethods for GccCodegenBackend {\n         Ok(())\n     }\n \n-    unsafe fn optimize_thin(_cgcx: &CodegenContext<Self>, _thin: &mut ThinModule<Self>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+    fn optimize_fat(_cgcx: &CodegenContext<Self>, _module: &mut ModuleCodegen<Self::Module>) -> Result<(), FatalError> {\n+        // TODO(antoyo)\n+        Ok(())\n+    }\n+\n+    unsafe fn optimize_thin(_cgcx: &CodegenContext<Self>, _thin: ThinModule<Self>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n         unimplemented!();\n     }\n \n@@ -245,11 +248,6 @@ impl WriteBackendMethods for GccCodegenBackend {\n         unimplemented!();\n     }\n \n-    fn run_lto_pass_manager(_cgcx: &CodegenContext<Self>, _module: &ModuleCodegen<Self::Module>, _config: &ModuleConfig, _thin: bool) -> Result<(), FatalError> {\n-        // TODO(antoyo)\n-        Ok(())\n-    }\n-\n     fn run_link(cgcx: &CodegenContext<Self>, diag_handler: &Handler, modules: Vec<ModuleCodegen<Self::Module>>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n         back::write::link(cgcx, diag_handler, modules)\n     }\n@@ -287,8 +285,10 @@ fn handle_native(name: &str) -> &str {\n }\n \n pub fn target_cpu(sess: &Session) -> &str {\n-    let name = sess.opts.cg.target_cpu.as_ref().unwrap_or(&sess.target.cpu);\n-    handle_native(name)\n+    match sess.opts.cg.target_cpu {\n+        Some(ref name) => handle_native(name),\n+        None => handle_native(sess.target.cpu.as_ref()),\n+    }\n }\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {"}, {"sha": "569ee2925b13c1785c9695ca80f708c912478774", "filename": "src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dca3e87d164d2806098c462c6ce41301341f68/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=e8dca3e87d164d2806098c462c6ce41301341f68", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n-        match scalar.value {\n+        match scalar.primitive() {\n             Int(i, true) => cx.type_from_integer(i),\n             Int(i, false) => cx.type_from_unsigned_integer(i),\n             F32 => cx.type_f32(),\n@@ -306,7 +306,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 Size::ZERO\n             }\n             else {\n-                a.value.size(cx).align_to(b.value.align(cx).abi)\n+                a.size(cx).align_to(b.align(cx).abi)\n             };\n         self.scalar_gcc_type_at(cx, scalar, offset)\n     }"}]}