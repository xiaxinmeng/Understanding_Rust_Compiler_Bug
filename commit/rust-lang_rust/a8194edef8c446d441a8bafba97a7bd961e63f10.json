{"sha": "a8194edef8c446d441a8bafba97a7bd961e63f10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MTk0ZWRlZjhjNDQ2ZDQ0MWE4YmFmYmE5N2E3YmQ5NjFlNjNmMTA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-09T05:00:49Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-09T05:00:49Z"}, "message": "rustpkg: Address review comments from Jack", "tree": {"sha": "1384e593de331b3b25081e8650b0deccbaa22908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1384e593de331b3b25081e8650b0deccbaa22908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8194edef8c446d441a8bafba97a7bd961e63f10", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8194edef8c446d441a8bafba97a7bd961e63f10", "html_url": "https://github.com/rust-lang/rust/commit/a8194edef8c446d441a8bafba97a7bd961e63f10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8194edef8c446d441a8bafba97a7bd961e63f10/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed4859ea78581a6d5dd8b5f1636c5ac121588179", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed4859ea78581a6d5dd8b5f1636c5ac121588179", "html_url": "https://github.com/rust-lang/rust/commit/ed4859ea78581a6d5dd8b5f1636c5ac121588179"}], "stats": {"total": 290, "additions": 126, "deletions": 164}, "files": [{"sha": "4de2572be7d5e2ac6c0bac04197552e7c40baacd", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 22, "deletions": 54, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -17,21 +17,22 @@ use workcache_support::*;\n \n use extra::arc::{Arc,RWArc};\n use extra::workcache;\n-use extra::workcache::*;\n-use std::os;\n+use extra::workcache::{Database, Logger, FreshnessMap};\n use extra::treemap::TreeMap;\n \n /// Convenience functions intended for calling from pkg.rs\n /// p is where to put the cache file for dependencies\n-pub fn default_ctxt(p: Path) -> BuildCtx {\n-    new_default_ctx(new_workcache_cx(&p), p)\n+pub fn default_context(p: Path) -> BuildContext {\n+    new_default_context(new_workcache_context(&p), p)\n }\n \n-pub fn new_default_ctx(c: Context, p: Path) -> BuildCtx {\n-    BuildCtx {\n-        cx: Ctx { use_rust_path_hack: false,\n-                  sysroot_opt: p },\n-        workcache_cx: c\n+pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n+    BuildContext {\n+        context: Context {\n+            use_rust_path_hack: false,\n+            sysroot: p\n+        },\n+        workcache_context: c\n     }\n }\n \n@@ -44,27 +45,27 @@ fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n }\n \n \n-pub fn new_workcache_cx(p: &Path) -> Context {\n+pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     let db_file = p.push(\"rustpkg_db.json\"); // ??? probably wrong\n     debug!(\"Workcache database file: %s\", db_file.to_str());\n     let db = RWArc::new(Database::new(db_file));\n     let lg = RWArc::new(Logger::new());\n     let cfg = Arc::new(TreeMap::new());\n-    let mut rslt: FreshnessMap = TreeMap::new();\n+    let mut freshness: FreshnessMap = TreeMap::new();\n     // Set up freshness functions for every type of dependency rustpkg\n     // knows about\n-    rslt.insert(~\"file\", file_is_fresh);\n-    rslt.insert(~\"binary\", binary_is_fresh);\n-    workcache::Context::new_with_freshness(db, lg, cfg, Arc::new(rslt))\n+    freshness.insert(~\"file\", file_is_fresh);\n+    freshness.insert(~\"binary\", binary_is_fresh);\n+    workcache::Context::new_with_freshness(db, lg, cfg, Arc::new(freshness))\n }\n \n pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n-    let cx = default_ctxt(sysroot);\n+    let cx = default_context(sysroot);\n     let subroot = root.clone();\n     let subversion = version.clone();\n     let sublib = lib.clone();\n-    do cx.workcache_cx.with_prep(name) |prep| {\n+    do cx.workcache_context.with_prep(name) |prep| {\n         let pkg_src = PkgSrc {\n             workspace: subroot.clone(),\n             start_dir: subroot.push(\"src\").push(name),\n@@ -78,17 +79,17 @@ pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n         let subcx = cx.clone();\n         let subsrc = pkg_src.clone();\n         do prep.exec |exec| {\n-            subsrc.clone().build(exec, &subcx.clone(), ~[]);\n+            subsrc.build(exec, &subcx.clone(), ~[]);\n         }\n     };\n }\n \n pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n                  main: Path) {\n-    let cx = default_ctxt(sysroot);\n+    let cx = default_context(sysroot);\n     let subroot = root.clone();\n     let submain = main.clone();\n-    do cx.workcache_cx.with_prep(name) |prep| {\n+    do cx.workcache_context.with_prep(name) |prep| {\n         let pkg_src = PkgSrc {\n             workspace: subroot.clone(),\n             start_dir: subroot.push(\"src\").push(name),\n@@ -107,41 +108,8 @@ pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n     }\n }\n \n-pub fn install_lib(sysroot: Path,\n-                   workspace: Path,\n-                   name: ~str,\n-                   lib_path: Path,\n-                   version: Version) {\n-    debug!(\"self_exe: %?\", os::self_exe_path());\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n-    debug!(\"workspace = %s\", workspace.to_str());\n-    // make a PkgSrc\n-    let pkg_id = PkgId{ version: version, ..PkgId::new(name)};\n-    let cx = default_ctxt(sysroot);\n-    let subpath = lib_path.clone();\n-    do cx.workcache_cx.with_prep(pkg_id.to_str()) |prep| {\n-        let pkg_src = PkgSrc {\n-            workspace: workspace.clone(),\n-            start_dir: subpath.push(\"src\").push(name),\n-            id: pkg_id.clone(),\n-            libs: ~[mk_crate(subpath.clone())],\n-            mains: ~[],\n-            tests: ~[],\n-            benchs: ~[]\n-        };\n-        pkg_src.declare_inputs(prep);\n-        let subcx = cx.clone();\n-        let subpkg_src = pkg_src.clone();\n-        do prep.exec |exec| {\n-            subpkg_src.clone().build(exec, &subcx.clone(), ~[]);\n-        }\n-    }\n-    cx.install_no_build(&workspace, &pkg_id);\n-}\n-\n-pub fn install_exe(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n-    let cx = default_ctxt(sysroot);\n-    debug!(\"install_exe calling with_prep\");\n+pub fn install_pkg(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n+    let cx = default_context(sysroot);\n     let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n     cx.install(PkgSrc::new(workspace, false, pkgid));\n }"}, {"sha": "2c6454cd2c664f6d812adc19d3dd9cf9ae4b17b9", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -14,62 +14,61 @@ use std::os;\n use extra::workcache;\n \n #[deriving(Clone)]\n-pub struct Ctx {\n+pub struct Context {\n     // If use_rust_path_hack is true, rustpkg searches for sources\n     // in *package* directories that are in the RUST_PATH (for example,\n     // FOO/src/bar-0.1 instead of FOO). The flag doesn't affect where\n     // rustpkg stores build artifacts.\n     use_rust_path_hack: bool,\n     // The root directory containing the Rust standard libraries\n-    sysroot_opt: Path\n+    sysroot: Path\n }\n \n #[deriving(Clone)]\n-pub struct BuildCtx {\n+pub struct BuildContext {\n     // Context for workcache\n-    workcache_cx: workcache::Context,\n+    workcache_context: workcache::Context,\n     // Everything else\n-    cx: Ctx\n+    context: Context\n }\n \n-impl BuildCtx {\n-    pub fn sysroot_opt(&self) -> Path {\n-        self.cx.sysroot_opt.clone()\n+impl BuildContext {\n+    pub fn sysroot(&self) -> Path {\n+        self.context.sysroot.clone()\n     }\n \n     pub fn sysroot_to_use(&self) -> Path {\n-        self.cx.sysroot_to_use()\n+        self.context.sysroot_to_use()\n     }\n }\n \n-impl Ctx {\n-    pub fn sysroot_opt(&self) -> Path {\n-        self.sysroot_opt.clone()\n+impl Context {\n+    pub fn sysroot(&self) -> Path {\n+        self.sysroot.clone()\n     }\n }\n \n-impl Ctx {\n+impl Context {\n     /// Debugging\n-    pub fn sysroot_opt_str(&self) -> ~str {\n-        self.sysroot_opt.to_str()\n+    pub fn sysroot_str(&self) -> ~str {\n+        self.sysroot.to_str()\n     }\n \n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n     pub fn sysroot_to_use(&self) -> Path {\n-        if !in_target(&self.sysroot_opt) {\n-            self.sysroot_opt.clone()\n+        if !in_target(&self.sysroot) {\n+            self.sysroot.clone()\n+        } else {\n+            self.sysroot.pop().pop().pop()\n         }\n-        else {\n-            self.sysroot_opt.pop().pop().pop()\n-        }\n-  }\n+    }\n }\n \n /// We assume that if ../../rustc exists, then we're running\n /// rustpkg from a Rust target directory. This is part of a\n /// kludgy hack used to adjust the sysroot.\n-pub fn in_target(sysroot_opt: &Path) -> bool {\n-    debug!(\"Checking whether %s is in target\", sysroot_opt.to_str());\n-    os::path_is_dir(&sysroot_opt.pop().pop().push(\"rustc\"))\n+pub fn in_target(sysroot: &Path) -> bool {\n+    debug!(\"Checking whether %s is in target\", sysroot.to_str());\n+    os::path_is_dir(&sysroot.pop().pop().push(\"rustc\"))\n }"}, {"sha": "946707288c43deed901a4d5f269baeeda6f4c04b", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -28,9 +28,11 @@ use extra::workcache;\n // This contains a list of files found in the source workspace.\n #[deriving(Clone)]\n pub struct PkgSrc {\n-    workspace: Path, // root of where the package source code lives\n-    start_dir: Path, // dir to start looking in for packages -- normally\n-                     // this is workspace/src/id but it may be just workspace\n+    /// Root of where the package source code lives\n+    workspace: Path,\n+    // Directory to start looking in for packages -- normally\n+    // this is workspace/src/id but it may be just workspace\n+    start_dir: Path,\n     id: PkgId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n@@ -61,8 +63,7 @@ impl PkgSrc {\n         let mut to_try = ~[];\n         if use_rust_path_hack {\n             to_try.push(workspace.clone());\n-        }\n-        else {\n+        } else {\n             let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(fmt!(\"%s-%s\",\n                                                          id.short_name, id.version.to_str()));\n             to_try.push(result);\n@@ -251,7 +252,7 @@ impl PkgSrc {\n     }\n \n     fn build_crates(&self,\n-                    ctx: &BuildCtx,\n+                    ctx: &BuildContext,\n                     exec: &mut workcache::Exec,\n                     destination_dir: &Path,\n                     crates: &[Crate],\n@@ -263,23 +264,17 @@ impl PkgSrc {\n             let path_str = path.to_str();\n             let cfgs = crate.cfgs + cfgs;\n \n-            let result = {\n+            let result =\n                 // compile_crate should return the path of the output artifact\n-                match compile_crate(ctx,\n-                                  exec,\n-                                  &self.id,\n-                                  &path,\n-                                  destination_dir,\n-                                  crate.flags,\n-                                  cfgs,\n-                                  false,\n-                                  what).map(|p| p.to_str()) {\n-                    Some(p) => p,\n-                    None   => build_err::cond.raise(fmt!(\"build failure on %s\",\n-                                                         path_str))\n-\n-                }\n-            };\n+                compile_crate(ctx,\n+                              exec,\n+                              &self.id,\n+                              &path,\n+                              destination_dir,\n+                              crate.flags,\n+                              cfgs,\n+                              false,\n+                              what).to_str();\n             debug!(\"Result of compiling %s was %s\", path_str, result);\n         }\n     }\n@@ -301,24 +296,25 @@ impl PkgSrc {\n \n     // It would be better if build returned a Path, but then Path would have to derive\n     // Encodable.\n-    pub fn build(&self, exec: &mut workcache::Exec, ctx: &BuildCtx, cfgs: ~[~str]) -> ~str {\n+    pub fn build(&self,\n+                 exec: &mut workcache::Exec,\n+                 build_context: &BuildContext,\n+                 cfgs: ~[~str]) -> ~str {\n         use conditions::not_a_workspace::cond;\n \n         // Determine the destination workspace (which depends on whether\n         // we're using the rust_path_hack)\n         let destination_workspace = if is_workspace(&self.workspace) {\n             debug!(\"%s is indeed a workspace\", self.workspace.to_str());\n             self.workspace.clone()\n-        }\n-            else {\n+        } else {\n             // It would be nice to have only one place in the code that checks\n             // for the use_rust_path_hack flag...\n-            if ctx.cx.use_rust_path_hack {\n+            if build_context.context.use_rust_path_hack {\n                 let rs = default_workspace();\n                 debug!(\"Using hack: %s\", rs.to_str());\n                 rs\n-            }\n-            else {\n+            } else {\n                 cond.raise(fmt!(\"Package root %s is not a workspace; pass in --rust_path_hack \\\n                                         if you want to treat it as a package source\",\n                                 self.workspace.to_str()))\n@@ -331,13 +327,13 @@ impl PkgSrc {\n         let benchs = self.benchs.clone();\n         debug!(\"Building libs in %s, destination = %s\",\n                destination_workspace.to_str(), destination_workspace.to_str());\n-        self.build_crates(ctx, exec, &destination_workspace, libs, cfgs, Lib);\n+        self.build_crates(build_context, exec, &destination_workspace, libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(ctx, exec, &destination_workspace, mains, cfgs, Main);\n+        self.build_crates(build_context, exec, &destination_workspace, mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(ctx, exec, &destination_workspace, tests, cfgs, Test);\n+        self.build_crates(build_context, exec, &destination_workspace, tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(ctx, exec, &destination_workspace, benchs, cfgs, Bench);\n+        self.build_crates(build_context, exec, &destination_workspace, benchs, cfgs, Bench);\n         destination_workspace.to_str()\n     }\n }"}, {"sha": "1b732354f11b8c985e5272375b2bb64271480718", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -84,8 +84,7 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n \n     if found.is_some() {\n         debug!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str());\n-    }\n-    else {\n+    } else {\n         debug!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str());\n     }\n     found"}, {"sha": "331dfcd692a19d2682ac3e78e8c8d18824ff18fd", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -40,7 +40,7 @@ use path_util::{built_executable_in_workspace, built_library_in_workspace, defau\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use source_control::is_git_dir;\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n-use context::{BuildCtx, Ctx};\n+use context::{BuildContext, Context};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use workcache_support::{discover_outputs, digest_only_date};\n@@ -174,6 +174,8 @@ pub trait CtxMethods {\n     fn build(&self, exec: &mut workcache::Exec, pkg_src: PkgSrc) -> Path;\n     fn clean(&self, workspace: &Path, id: &PkgId);\n     fn info(&self);\n+    /// Returns a pair. First component is a list of installed paths,\n+    /// second is a list of declared and discovered inputs\n     fn install(&self, src: PkgSrc) -> (~[Path], ~[(~str, ~str)]);\n     /// Returns a list of installed files\n     fn install_no_build(&self, workspace: &Path, id: &PkgId) -> ~[Path];\n@@ -183,11 +185,11 @@ pub trait CtxMethods {\n     fn unprefer(&self, _id: &str, _vers: Option<~str>);\n }\n \n-impl CtxMethods for BuildCtx {\n+impl CtxMethods for BuildContext {\n     fn build_from_src(&self, pkg_src: PkgSrc) {\n         let tag = pkg_src.id.to_str();\n         debug!(\"package source = %s\", pkg_src.to_str());\n-        do self.workcache_cx.with_prep(tag) |prep| {\n+        do self.workcache_context.with_prep(tag) |prep| {\n             let subsrc = pkg_src.clone();\n             let subself = self.clone();\n             declare_package_script_dependency(prep, &subsrc);\n@@ -203,7 +205,7 @@ impl CtxMethods for BuildCtx {\n             \"build\" => {\n                 if args.len() < 1 {\n                     match cwd_to_workspace() {\n-                        None if self.cx.use_rust_path_hack => {\n+                        None if self.context.use_rust_path_hack => {\n                             let cwd = os::getcwd();\n                             let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n                             self.build_from_src(PkgSrc::new(cwd, true, pkgid));\n@@ -218,7 +220,7 @@ impl CtxMethods for BuildCtx {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0].clone());\n-                    do each_pkg_parent_workspace(&self.cx, &pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n                         let pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n@@ -258,7 +260,7 @@ impl CtxMethods for BuildCtx {\n             \"install\" => {\n                if args.len() < 1 {\n                     match cwd_to_workspace() {\n-                        None if self.cx.use_rust_path_hack => {\n+                        None if self.context.use_rust_path_hack => {\n                             let cwd = os::getcwd();\n                             let inferred_pkgid =\n                                 PkgId::new(cwd.components[cwd.components.len() - 1]);\n@@ -275,7 +277,7 @@ impl CtxMethods for BuildCtx {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n-                    let workspaces = pkg_parent_workspaces(&self.cx, &pkgid);\n+                    let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n                     debug!(\"package ID = %s, found it in %? workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n@@ -287,7 +289,7 @@ impl CtxMethods for BuildCtx {\n                     else {\n                         for workspace in workspaces.iter() {\n                             let src = PkgSrc::new(workspace.clone(),\n-                                                  self.cx.use_rust_path_hack,\n+                                                  self.context.use_rust_path_hack,\n                                                   pkgid.clone());\n                             self.install(src);\n                         };\n@@ -324,7 +326,7 @@ impl CtxMethods for BuildCtx {\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    do each_pkg_parent_workspace(&self.cx, &pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(fmt!(\"Uninstalled package %s (was installed in %s)\",\n                                   pkgid.to_str(), workspace.to_str()));\n@@ -350,9 +352,7 @@ impl CtxMethods for BuildCtx {\n \n     /// Returns the destination workspace\n     /// In the case of a custom build, we don't know, so we just return the source workspace\n-    fn build(&self, exec: &mut workcache::Exec, pkg_src: PkgSrc) -> Path {\n-\n-        let pkg_src = &mut pkg_src.clone(); // :-o\n+    fn build(&self, exec: &mut workcache::Exec, mut pkg_src: PkgSrc) -> Path {\n         let workspace = pkg_src.workspace.clone();\n         let pkgid = pkg_src.id.clone();\n \n@@ -438,16 +438,15 @@ impl CtxMethods for BuildCtx {\n         fail!(\"info not yet implemented\");\n     }\n \n-    /// Returns a pair. First component is a list of installed paths,\n-    /// second is a list of declared and discovered inputs\n     fn install(&self, pkg_src: PkgSrc) -> (~[Path], ~[(~str, ~str)]) {\n \n         let id = &pkg_src.id;\n \n         let installed_files = RWArc::new(~[]);\n         let inputs = RWArc::new(~[]);\n         // FIXME #7402: Use RUST_PATH to determine target dir\n-        let f: &fn(&mut workcache::Prep) = |prep| {\n+        self.workcache_context.with_prep(id.to_str(), |p| pkg_src.declare_inputs(p));\n+        do self.workcache_context.with_prep(id.to_str()) |prep| {\n             let sub_inputs = inputs.clone();\n             let sub_files  = installed_files.clone();\n             let subsrc = pkg_src.clone();\n@@ -473,8 +472,6 @@ impl CtxMethods for BuildCtx {\n                 sub_inputs.write(|r| { *r = *r + exec.lookup_discovered_inputs() });\n             }\n         };\n-        self.workcache_cx.with_prep(id.to_str(), |p| pkg_src.declare_inputs(p));\n-        self.workcache_cx.with_prep(id.to_str(), f);\n         (installed_files.unwrap(), inputs.unwrap())\n     }\n \n@@ -609,12 +606,12 @@ pub fn main_args(args: &[~str]) {\n     let sroot = filesearch::get_or_default_sysroot();\n     debug!(\"Using sysroot: %s\", sroot.to_str());\n     debug!(\"Will store workcache in %s\", default_workspace().to_str());\n-    BuildCtx {\n-        cx: Ctx {\n-           use_rust_path_hack: use_rust_path_hack,\n-            sysroot_opt: sroot, // Currently, only tests override this\n+    BuildContext {\n+        context: Context {\n+            use_rust_path_hack: use_rust_path_hack,\n+            sysroot: sroot, // Currently, only tests override this\n          },\n-        workcache_cx: api::default_ctxt(default_workspace()).workcache_cx // ???\n+        workcache_context: api::default_context(default_workspace()).workcache_context\n     }.run(*cmd, remaining_args)\n }\n "}, {"sha": "f4016d26a150e4576e2b329a6668ca653f0e3c03", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -10,12 +10,13 @@\n \n // rustpkg unit tests\n \n-use context::{BuildCtx, Ctx};\n+use context::{BuildContext, Context};\n use std::{io, libc, os, run, str, task};\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::mkdtemp;\n-use extra::workcache::{Context, Database, Logger};\n+use extra::workcache;\n+use extra::workcache::{Database, Logger};\n use extra::treemap::TreeMap;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n@@ -36,15 +37,16 @@ fn datestamp(p: &Path) -> Option<libc::time_t> {\n     p.stat().map(|stat| stat.st_mtime)\n }\n \n-fn fake_ctxt(sysroot_opt: Path, workspace: &Path) -> BuildCtx {\n-    let bcx = Context::new(RWArc::new(Database::new(workspace.push(\"rustpkg_db.json\"))),\n-                           RWArc::new(Logger::new()),\n-                           Arc::new(TreeMap::new()));\n-    BuildCtx {\n-        workcache_cx: bcx,\n-        cx: Ctx {\n+fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n+    let context = workcache::Context::new(\n+        RWArc::new(Database::new(workspace.push(\"rustpkg_db.json\"))),\n+        RWArc::new(Logger::new()),\n+        Arc::new(TreeMap::new()));\n+    BuildContext {\n+        workcache_context: context,\n+        context: Context {\n             use_rust_path_hack: false,\n-            sysroot_opt: sysroot_opt\n+            sysroot: sysroot\n         }\n     }\n }"}, {"sha": "5e9fc6655a8ec4edcb1d3a31df59128821e3fbfc", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -19,7 +19,7 @@ use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, bin_crate};\n-use context::{in_target, BuildCtx};\n+use context::{in_target, BuildContext};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use path_util::{installed_library_in_workspace, U_RWX};\n@@ -153,16 +153,15 @@ pub fn ready_crate(sess: session::Session,\n     @fold.fold_crate(crate)\n }\n \n-pub fn compile_input(ctxt: &BuildCtx,\n+pub fn compile_input(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n-                     what: OutputType) -> Option<Path> {\n-\n+                     what: OutputType) -> Path {\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n@@ -175,7 +174,7 @@ pub fn compile_input(ctxt: &BuildCtx,\n \n     debug!(\"flags: %s\", flags.connect(\" \"));\n     debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot_opt().to_str());\n+    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot().to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -193,13 +192,13 @@ pub fn compile_input(ctxt: &BuildCtx,\n                           driver::optgroups()).unwrap();\n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n-    let sysroot_to_use = @if !in_target(&ctxt.sysroot_opt()) {\n-        ctxt.sysroot_opt()\n+    let sysroot_to_use = @if !in_target(&ctxt.sysroot()) {\n+        ctxt.sysroot()\n     }\n     else {\n-        ctxt.sysroot_opt().pop().pop().pop()\n+        ctxt.sysroot().pop().pop().pop()\n     };\n-    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot_opt().to_str());\n+    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot().to_str());\n     debug!(\"sysroot_to_use = %s\", sysroot_to_use.to_str());\n     let options = @session::options {\n         crate_type: crate_type,\n@@ -284,7 +283,7 @@ pub fn compile_crate_from_input(input: &Path,\n  // should be of the form <workspace>/build/<pkg id's path>\n                                 out_dir: &Path,\n                                 sess: session::Session,\n-                                crate: @ast::Crate) -> Option<Path> {\n+                                crate: @ast::Crate) -> Path {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n            out_dir.to_str(), sess.building_library);\n \n@@ -307,13 +306,13 @@ pub fn compile_crate_from_input(input: &Path,\n                                                         &analysis,\n                                                         outputs);\n     driver::phase_5_run_llvm_passes(sess, &translation, outputs);\n-    if driver::stop_after_phase_5(sess) { return Some(outputs.out_filename); }\n+    if driver::stop_after_phase_5(sess) { return outputs.out_filename; }\n     driver::phase_6_link_output(sess, &translation, outputs);\n \n     // Register dependency on the source file\n     exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n \n-    Some(outputs.out_filename)\n+    outputs.out_filename\n }\n \n #[cfg(windows)]\n@@ -326,12 +325,12 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n // Called by build_crates\n-pub fn compile_crate(ctxt: &BuildCtx,\n+pub fn compile_crate(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n                      pkg_id: &PkgId,\n                      crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n-                     what: OutputType) -> Option<Path> {\n+                     what: OutputType) -> Path {\n     debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n@@ -344,7 +343,7 @@ pub fn compile_crate(ctxt: &BuildCtx,\n /// Collect all `extern mod` directives in `c`, then\n /// try to install their targets, failing if any target\n /// can't be found.\n-pub fn find_and_install_dependencies(ctxt: &BuildCtx,\n+pub fn find_and_install_dependencies(ctxt: &BuildContext,\n                                  sess: session::Session,\n                                  exec: &mut workcache::Exec,\n                                  workspace: &Path,\n@@ -358,8 +357,10 @@ pub fn find_and_install_dependencies(ctxt: &BuildCtx,\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 let lib_name = match path_opt {\n-                    Some(p) => p, None => sess.str_of(lib_ident) };\n-                match installed_library_in_workspace(lib_name, &ctxt.sysroot_opt()) {\n+                    Some(p) => p,\n+                    None => sess.str_of(lib_ident)\n+                };\n+                match installed_library_in_workspace(lib_name, &ctxt.sysroot()) {\n                     Some(ref installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                         // Say that [path for c] has a discovered dependency on"}, {"sha": "d5dd87ee44228614a5f7636e6b948d0d19f9e17a", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8194edef8c446d441a8bafba97a7bd961e63f10/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=a8194edef8c446d441a8bafba97a7bd961e63f10", "patch": "@@ -12,14 +12,14 @@\n \n use std::{os,util};\n use std::path::Path;\n-use context::Ctx;\n+use context::Context;\n use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack};\n use util::option_to_vec;\n use package_id::PkgId;\n \n use path_util::rust_path;\n \n-pub fn each_pkg_parent_workspace(cx: &Ctx, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n     let workspaces = pkg_parent_workspaces(cx, pkgid);\n@@ -38,7 +38,7 @@ pub fn each_pkg_parent_workspace(cx: &Ctx, pkgid: &PkgId, action: &fn(&Path) ->\n     return true;\n }\n \n-pub fn pkg_parent_workspaces(cx: &Ctx, pkgid: &PkgId) -> ~[Path] {\n+pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n     let rs: ~[Path] = rust_path().move_iter()\n         .filter(|ws| workspace_contains_package_id(pkgid, ws))\n         .collect();"}]}