{"sha": "15fb06d73008d868f10707f32c5caebff41b3026", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZmIwNmQ3MzAwOGQ4NjhmMTA3MDdmMzJjNWNhZWJmZjQxYjMwMjY=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-05T20:08:33Z"}, "committer": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-05T23:25:03Z"}, "message": "remove int_uint feature from libcollections", "tree": {"sha": "3e3dfe6142b26fe4a212b4928abd63eb8bbbb3b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e3dfe6142b26fe4a212b4928abd63eb8bbbb3b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15fb06d73008d868f10707f32c5caebff41b3026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15fb06d73008d868f10707f32c5caebff41b3026", "html_url": "https://github.com/rust-lang/rust/commit/15fb06d73008d868f10707f32c5caebff41b3026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15fb06d73008d868f10707f32c5caebff41b3026/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1420cebebd48a187d8639243beaf207a0dd90853", "url": "https://api.github.com/repos/rust-lang/rust/commits/1420cebebd48a187d8639243beaf207a0dd90853", "html_url": "https://github.com/rust-lang/rust/commit/1420cebebd48a187d8639243beaf207a0dd90853"}], "stats": {"total": 391, "additions": 195, "deletions": 196}, "files": [{"sha": "8ba0eb9b7efe5180e5e9d3236796b0af26ab1a03", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=15fb06d73008d868f10707f32c5caebff41b3026", "patch": "@@ -266,8 +266,8 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::from_elem(10u, false);\n-    /// assert_eq!(bv.len(), 10u);\n+    /// let mut bv = Bitv::from_elem(10, false);\n+    /// assert_eq!(bv.len(), 10);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n@@ -353,7 +353,7 @@ impl Bitv {\n     /// ```\n     pub fn from_fn<F>(len: usize, mut f: F) -> Bitv where F: FnMut(usize) -> bool {\n         let mut bitv = Bitv::from_elem(len, false);\n-        for i in 0u..len {\n+        for i in 0..len {\n             bitv.set(i, f(i));\n         }\n         bitv\n@@ -1415,7 +1415,7 @@ impl BitvSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> bitv_set::Iter {\n-        SetIter {set: self, next_idx: 0u}\n+        SetIter {set: self, next_idx: 0}\n     }\n \n     /// Iterator over each u32 stored in `self` union `other`.\n@@ -1443,8 +1443,8 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: or,\n-            current_word: 0u32,\n-            next_idx: 0u\n+            current_word: 0,\n+            next_idx: 0\n         })\n     }\n \n@@ -1473,7 +1473,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: bitand,\n-            current_word: 0u32,\n+            current_word: 0,\n             next_idx: 0\n         }.take(min))\n     }\n@@ -1510,7 +1510,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: diff,\n-            current_word: 0u32,\n+            current_word: 0,\n             next_idx: 0\n         })\n     }\n@@ -1541,7 +1541,7 @@ impl BitvSet {\n             set: self,\n             other: other,\n             merge: bitxor,\n-            current_word: 0u32,\n+            current_word: 0,\n             next_idx: 0\n         })\n     }\n@@ -1902,7 +1902,7 @@ mod tests {\n         let zerolen = Bitv::new();\n         assert_eq!(format!(\"{:?}\", zerolen), \"\");\n \n-        let eightbits = Bitv::from_elem(8u, false);\n+        let eightbits = Bitv::from_elem(8, false);\n         assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n     }\n \n@@ -1916,10 +1916,10 @@ mod tests {\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::from_elem(1u, false);\n+        let mut act = Bitv::from_elem(1, false);\n         assert!(act.eq_vec(&[false]));\n         assert!(act.none() && !act.all());\n-        act = Bitv::from_elem(1u, true);\n+        act = Bitv::from_elem(1, true);\n         assert!(act.eq_vec(&[true]));\n         assert!(!act.none() && act.all());\n     }\n@@ -1938,42 +1938,42 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(10u, false);\n+        act = Bitv::from_elem(10, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(10u, true);\n+        act = Bitv::from_elem(10, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n+        act = Bitv::from_elem(10, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10u, false);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n-        act.set(8u, true);\n-        act.set(9u, true);\n+        act = Bitv::from_elem(10, false);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n+        act.set(8, true);\n+        act.set(9, true);\n         assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10u, false);\n-        act.set(0u, true);\n-        act.set(3u, true);\n-        act.set(6u, true);\n-        act.set(9u, true);\n+        act = Bitv::from_elem(10, false);\n+        act.set(0, true);\n+        act.set(3, true);\n+        act.set(6, true);\n+        act.set(9, true);\n         assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n         assert!(!act.none() && !act.all());\n     }\n@@ -1983,73 +1983,73 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(31u, false);\n+        act = Bitv::from_elem(31, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(31u, true);\n+        act = Bitv::from_elem(31, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(16u, true);\n-        act.set(17u, true);\n-        act.set(18u, true);\n-        act.set(19u, true);\n-        act.set(20u, true);\n-        act.set(21u, true);\n-        act.set(22u, true);\n-        act.set(23u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(16, true);\n+        act.set(17, true);\n+        act.set(18, true);\n+        act.set(19, true);\n+        act.set(20, true);\n+        act.set(21, true);\n+        act.set(22, true);\n+        act.set(23, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(24u, true);\n-        act.set(25u, true);\n-        act.set(26u, true);\n-        act.set(27u, true);\n-        act.set(28u, true);\n-        act.set(29u, true);\n-        act.set(30u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(24, true);\n+        act.set(25, true);\n+        act.set(26, true);\n+        act.set(27, true);\n+        act.set(28, true);\n+        act.set(29, true);\n+        act.set(30, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31u, false);\n-        act.set(3u, true);\n-        act.set(17u, true);\n-        act.set(30u, true);\n+        act = Bitv::from_elem(31, false);\n+        act.set(3, true);\n+        act.set(17, true);\n+        act.set(30, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n@@ -2062,75 +2062,75 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(32u, false);\n+        act = Bitv::from_elem(32, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(32u, true);\n+        act = Bitv::from_elem(32, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(16u, true);\n-        act.set(17u, true);\n-        act.set(18u, true);\n-        act.set(19u, true);\n-        act.set(20u, true);\n-        act.set(21u, true);\n-        act.set(22u, true);\n-        act.set(23u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(16, true);\n+        act.set(17, true);\n+        act.set(18, true);\n+        act.set(19, true);\n+        act.set(20, true);\n+        act.set(21, true);\n+        act.set(22, true);\n+        act.set(23, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(24u, true);\n-        act.set(25u, true);\n-        act.set(26u, true);\n-        act.set(27u, true);\n-        act.set(28u, true);\n-        act.set(29u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(24, true);\n+        act.set(25, true);\n+        act.set(26, true);\n+        act.set(27, true);\n+        act.set(28, true);\n+        act.set(29, true);\n+        act.set(30, true);\n+        act.set(31, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32u, false);\n-        act.set(3u, true);\n-        act.set(17u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n+        act = Bitv::from_elem(32, false);\n+        act.set(3, true);\n+        act.set(17, true);\n+        act.set(30, true);\n+        act.set(31, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n@@ -2143,76 +2143,76 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(33u, false);\n+        act = Bitv::from_elem(33, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(33u, true);\n+        act = Bitv::from_elem(33, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(0u, true);\n-        act.set(1u, true);\n-        act.set(2u, true);\n-        act.set(3u, true);\n-        act.set(4u, true);\n-        act.set(5u, true);\n-        act.set(6u, true);\n-        act.set(7u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(0, true);\n+        act.set(1, true);\n+        act.set(2, true);\n+        act.set(3, true);\n+        act.set(4, true);\n+        act.set(5, true);\n+        act.set(6, true);\n+        act.set(7, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(16u, true);\n-        act.set(17u, true);\n-        act.set(18u, true);\n-        act.set(19u, true);\n-        act.set(20u, true);\n-        act.set(21u, true);\n-        act.set(22u, true);\n-        act.set(23u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(16, true);\n+        act.set(17, true);\n+        act.set(18, true);\n+        act.set(19, true);\n+        act.set(20, true);\n+        act.set(21, true);\n+        act.set(22, true);\n+        act.set(23, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, true, true, true, true, true, true, true,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(24u, true);\n-        act.set(25u, true);\n-        act.set(26u, true);\n-        act.set(27u, true);\n-        act.set(28u, true);\n-        act.set(29u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(24, true);\n+        act.set(25, true);\n+        act.set(26, true);\n+        act.set(27, true);\n+        act.set(28, true);\n+        act.set(29, true);\n+        act.set(30, true);\n+        act.set(31, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, true, true, true, true, true, true, true, true, false]));\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33u, false);\n-        act.set(3u, true);\n-        act.set(17u, true);\n-        act.set(30u, true);\n-        act.set(31u, true);\n-        act.set(32u, true);\n+        act = Bitv::from_elem(33, false);\n+        act.set(3, true);\n+        act.set(17, true);\n+        act.set(30, true);\n+        act.set(31, true);\n+        act.set(32, true);\n         assert!(act.eq_vec(\n                 &[false, false, false, true, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, true, false, false, false, false, false, false,\n@@ -2222,15 +2222,15 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::from_elem(10u, false);\n-        let v1 = Bitv::from_elem(11u, false);\n+        let v0 = Bitv::from_elem(10, false);\n+        let v1 = Bitv::from_elem(11, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::from_elem(10u, false);\n-        let v1 = Bitv::from_elem(110u, false);\n+        let v0 = Bitv::from_elem(10, false);\n+        let v1 = Bitv::from_elem(110, false);\n         assert!(v0 != v1);\n     }\n \n@@ -2248,12 +2248,12 @@ mod tests {\n     #[test]\n     fn test_equal_sneaky_big() {\n         let mut a = Bitv::from_elem(100, false);\n-        for i in 0u..100 {\n+        for i in 0..100 {\n             a.set(i, true);\n         }\n \n         let mut b = Bitv::from_elem(100, true);\n-        for i in 0u..100 {\n+        for i in 0..100 {\n             b.set(i, true);\n         }\n \n@@ -2350,8 +2350,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_lt() {\n-        let mut a = Bitv::from_elem(5u, false);\n-        let mut b = Bitv::from_elem(5u, false);\n+        let mut a = Bitv::from_elem(5, false);\n+        let mut b = Bitv::from_elem(5, false);\n \n         assert!(!(a < b) && !(b < a));\n         b.set(2, true);\n@@ -2366,8 +2366,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = Bitv::from_elem(5u, false);\n-        let mut b = Bitv::from_elem(5u, false);\n+        let mut a = Bitv::from_elem(5, false);\n+        let mut b = Bitv::from_elem(5, false);\n \n         assert!(a <= b && a >= b);\n         a.set(1, true);\n@@ -2542,7 +2542,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = 0 as usize;\n         b.iter(|| {\n-            for _ in 0u..100 {\n+            for _ in 0..100 {\n                 bitv |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bitv);\n@@ -2554,7 +2554,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            for _ in 0u..100 {\n+            for _ in 0..100 {\n                 bitv.set((r.next_u32() as usize) % BENCH_BITS, true);\n             }\n             black_box(&bitv);\n@@ -2566,7 +2566,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            for _ in 0u..100 {\n+            for _ in 0..100 {\n                 bitv.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n             }\n             black_box(&bitv);\n@@ -2578,7 +2578,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n-            for _ in 0u..100 {\n+            for _ in 0..100 {\n                 bitv.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n             black_box(&bitv);\n@@ -2598,8 +2598,8 @@ mod bitv_bench {\n     fn bench_bitv_small_iter(b: &mut Bencher) {\n         let bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n-            let mut sum = 0u;\n-            for _ in 0u..10 {\n+            let mut sum = 0;\n+            for _ in 0..10 {\n                 for pres in &bitv {\n                     sum += pres as usize;\n                 }\n@@ -2612,7 +2612,7 @@ mod bitv_bench {\n     fn bench_bitv_big_iter(b: &mut Bencher) {\n         let bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            let mut sum = 0u;\n+            let mut sum = 0;\n             for pres in &bitv {\n                 sum += pres as usize;\n             }\n@@ -2663,7 +2663,7 @@ mod bitv_set_test {\n         let idxs: Vec<_> = bitv.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = (0u..10000).filter(|&n| n % 2 == 0).collect();\n+        let long: BitvSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n         let real: Vec<_> = range_step(0, 10000, 2).collect();\n \n         let idxs: Vec<_> = long.iter().collect();\n@@ -2677,8 +2677,8 @@ mod bitv_set_test {\n         for &b in &bools {\n             for &l in &lengths {\n                 let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n-                assert_eq!(bitset.contains(&1u), b);\n-                assert_eq!(bitset.contains(&(l-1u)), b);\n+                assert_eq!(bitset.contains(&1), b);\n+                assert_eq!(bitset.contains(&(l-1)), b);\n                 assert!(!bitset.contains(&l));\n             }\n         }"}, {"sha": "57c799785e82d2ae46ba0bb1adf7fcb27f922957", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=15fb06d73008d868f10707f32c5caebff41b3026", "patch": "@@ -26,7 +26,6 @@\n #![feature(box_syntax)]\n #![feature(core)]\n #![feature(hash)]\n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "83828940ab8bb20eb546080fda6d455cdfab2ed5", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=15fb06d73008d868f10707f32c5caebff41b3026", "patch": "@@ -32,8 +32,8 @@ use std::cmp;\n \n use alloc::heap;\n \n-static INITIAL_CAPACITY: usize = 7u; // 2^3 - 1\n-static MINIMUM_CAPACITY: usize = 1u; // 2 - 1\n+static INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n+static MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ddbc86506b89c466d05d52c2fe1e1edfb3041fb5", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=15fb06d73008d868f10707f32c5caebff41b3026", "patch": "@@ -1116,7 +1116,7 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n \n impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n     fn concat(&self) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self {\n             result.push_all(v.as_slice())\n@@ -1125,7 +1125,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n     }\n \n     fn connect(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n@@ -1301,7 +1301,7 @@ impl<T: Clone> Iterator for Permutations<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n-    let len = v.len() as int;\n+    let len = v.len() as isize;\n     let buf_v = v.as_mut_ptr();\n \n     // 1 <= i < len;\n@@ -1371,7 +1371,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     let mut working_space = Vec::with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as isize)};\n \n     // length `len`.\n     let buf_v = v.as_ptr();\n@@ -1387,17 +1387,17 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n         // start <= i < len;\n         for i in start..cmp::min(start + insertion, len) {\n             // j satisfies: start <= j <= i;\n-            let mut j = i as int;\n+            let mut j = i as isize;\n             unsafe {\n                 // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as int);\n+                let read_ptr = buf_v.offset(i as isize);\n \n                 // find where to insert, we need to do strict <,\n                 // rather than <=, to maintain stability.\n \n                 // start <= j - 1 < len, so .offset(j - 1) is in\n                 // bounds.\n-                while j > start as int &&\n+                while j > start as isize &&\n                         compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n                     j -= 1;\n                 }\n@@ -1431,24 +1431,24 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // the end of the first run & start of the\n                 // second. Offset of `len` is defined, since this is\n                 // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as isize);\n                 // end of the second. Similar reasoning to the above re safety.\n                 let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as int);\n+                let right_end = buf_dat.offset(right_end_idx as isize);\n \n                 // the pointers to the elements under consideration\n                 // from the two runs.\n \n                 // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as int);\n+                let mut left = buf_dat.offset(start as isize);\n                 let mut right = right_start;\n \n                 // where we're putting the results, it is a run of\n                 // length `2*width`, so we step it once for each step\n                 // of either `left` or `right`.  `buf_tmp` has length\n                 // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as int);\n-                let out_end = buf_tmp.offset(right_end_idx as int);\n+                let mut out = buf_tmp.offset(start as isize);\n+                let out_end = buf_tmp.offset(right_end_idx as isize);\n \n                 while out < out_end {\n                     // Either the left or the right run are exhausted,\n@@ -2373,7 +2373,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iterator() {\n-        let mut xs = [1u, 2, 3, 4, 5];\n+        let mut xs = [1, 2, 3, 4, 5];\n         for (i,x) in xs.iter_mut().rev().enumerate() {\n             *x += i;\n         }\n@@ -2382,13 +2382,13 @@ mod tests {\n \n     #[test]\n     fn test_move_iterator() {\n-        let xs = vec![1u,2,3,4,5];\n+        let xs = vec![1,2,3,4,5];\n         assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10*a + b), 12345);\n     }\n \n     #[test]\n     fn test_move_rev_iterator() {\n-        let xs = vec![1u,2,3,4,5];\n+        let xs = vec![1,2,3,4,5];\n         assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10*a + b), 54321);\n     }\n \n@@ -2592,7 +2592,7 @@ mod tests {\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1], \"[1]\");\n         test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n-        test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n+        test_show_vec!(vec![vec![], vec![1], vec![1, 1]],\n                        \"[[], [1], [1, 1]]\");\n \n         let empty_mut: &mut [i32] = &mut[];\n@@ -2601,7 +2601,7 @@ mod tests {\n         test_show_vec!(v, \"[1]\");\n         let v = &mut[1, 2, 3];\n         test_show_vec!(v, \"[1, 2, 3]\");\n-        let v: &mut[&mut[_]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n+        let v: &mut[&mut[_]] = &mut[&mut[], &mut[1], &mut[1, 1]];\n         test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n@@ -2677,7 +2677,7 @@ mod tests {\n     fn test_iter_zero_sized() {\n         let mut v = vec![Foo, Foo, Foo];\n         assert_eq!(v.len(), 3);\n-        let mut cnt = 0u;\n+        let mut cnt = 0;\n \n         for f in &v {\n             assert!(*f == Foo);\n@@ -3016,7 +3016,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n-            for _ in 0u..100 {\n+            for _ in 0..100 {\n                 let l = v.len();\n                 v.insert(rng.gen::<usize>() % (l + 1),\n                          (1, 1));\n@@ -3028,7 +3028,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n-            for _ in 0u..100 {\n+            for _ in 0..100 {\n                 let l = v.len();\n                 v.remove(rng.gen::<usize>() % l);\n             }"}, {"sha": "2574cfc28da73afd959a79988a0186a6e04b3096", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=15fb06d73008d868f10707f32c5caebff41b3026", "patch": "@@ -469,7 +469,7 @@ impl String {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n             let slice = RawSlice {\n-                data: self.vec.as_ptr().offset(cur_len as int),\n+                data: self.vec.as_ptr().offset(cur_len as isize),\n                 len: 4,\n             };\n             let used = ch.encode_utf8(mem::transmute(slice)).unwrap_or(0);\n@@ -569,8 +569,8 @@ impl String {\n \n         let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n-                             self.vec.as_ptr().offset(next as int),\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n+                             self.vec.as_ptr().offset(next as isize),\n                              len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n@@ -599,10 +599,10 @@ impl String {\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as int),\n-                             self.vec.as_ptr().offset(idx as int),\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n+                             self.vec.as_ptr().offset(idx as isize),\n                              len - idx);\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n                              bits.as_ptr(),\n                              amt);\n             self.vec.set_len(len + amt);"}, {"sha": "c6c8beec870172178c42568ef47a24aecffad1dc", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15fb06d73008d868f10707f32c5caebff41b3026/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=15fb06d73008d868f10707f32c5caebff41b3026", "patch": "@@ -234,7 +234,7 @@ impl<T> Vec<T> {\n     ///         mem::forget(v);\n     ///\n     ///         // Overwrite memory with 4, 5, 6\n-    ///         for i in 0..len as int {\n+    ///         for i in 0..len as isize {\n     ///             ptr::write(p.offset(i), 4 + i);\n     ///         }\n     ///\n@@ -457,7 +457,7 @@ impl<T> Vec<T> {\n             let end = if mem::size_of::<T>() == 0 {\n                 (ptr as usize + self.len()) as *const T\n             } else {\n-                ptr.offset(self.len() as int) as *const T\n+                ptr.offset(self.len() as isize) as *const T\n             };\n             mem::forget(self);\n             IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n@@ -473,7 +473,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1u, 2, 3, 4];\n+    /// let mut v = vec![1, 2, 3, 4];\n     /// unsafe {\n     ///     v.set_len(1);\n     /// }\n@@ -539,7 +539,7 @@ impl<T> Vec<T> {\n         unsafe { // infallible\n             // The spot to put the new value\n             {\n-                let p = self.as_mut_ptr().offset(index as int);\n+                let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n                 ptr::copy_memory(p.offset(1), &*p, len - index);\n@@ -573,7 +573,7 @@ impl<T> Vec<T> {\n             let ret;\n             {\n                 // the place we are taking from.\n-                let ptr = self.as_mut_ptr().offset(index as int);\n+                let ptr = self.as_mut_ptr().offset(index as isize);\n                 // copy it out, unsafely having a copy of the value on\n                 // the stack and in the vector at the same time.\n                 ret = ptr::read(ptr);\n@@ -655,7 +655,7 @@ impl<T> Vec<T> {\n         }\n \n         unsafe {\n-            let end = (*self.ptr).offset(self.len as int);\n+            let end = (*self.ptr).offset(self.len as isize);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -743,7 +743,7 @@ impl<T> Vec<T> {\n             let end = if mem::size_of::<T>() == 0 {\n                 (*self.ptr as usize + self.len()) as *const T\n             } else {\n-                (*self.ptr).offset(self.len() as int) as *const T\n+                (*self.ptr).offset(self.len() as isize) as *const T\n             };\n             self.set_len(0);\n             Drain {\n@@ -835,7 +835,7 @@ impl<T> Vec<T> {\n             // types are passed to the allocator by `Vec`.\n             assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n \n-            // This `as int` cast is safe, because the size of the elements of the\n+            // This `as isize` cast is safe, because the size of the elements of the\n             // vector is not 0, and:\n             //\n             // 1) If the size of the elements in the vector is 1, the `int` may\n@@ -852,7 +852,7 @@ impl<T> Vec<T> {\n             //\n             // 2) If the size of the elements in the vector is >1, the `usize` ->\n             //    `int` conversion can't overflow.\n-            let offset = vec.len() as int;\n+            let offset = vec.len() as isize;\n             let start = vec.as_mut_ptr();\n \n             let mut pv = PartialVecNonZeroSized {\n@@ -1179,8 +1179,8 @@ impl<T: PartialEq> Vec<T> {\n             let mut w = 1;\n \n             while r < ln {\n-                let p_r = p.offset(r as int);\n-                let p_wm1 = p.offset((w - 1) as int);\n+                let p_r = p.offset(r as isize);\n+                let p_wm1 = p.offset((w - 1) as isize);\n                 if *p_r != *p_wm1 {\n                     if r != w {\n                         let p_w = p_wm1.offset(1);\n@@ -1648,7 +1648,7 @@ impl<T> Iterator for IntoIter<T> {\n                     self.ptr = mem::transmute(self.ptr as usize + 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -1681,7 +1681,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n                     self.end = mem::transmute(self.end as usize - 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n \n@@ -1736,7 +1736,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n                     self.ptr = mem::transmute(self.ptr as usize + 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -1769,7 +1769,7 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n                     self.end = mem::transmute(self.end as usize - 1);\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(mem::transmute(1u)))\n+                    Some(ptr::read(EMPTY as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n "}]}