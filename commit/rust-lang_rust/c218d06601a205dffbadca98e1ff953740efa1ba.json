{"sha": "c218d06601a205dffbadca98e1ff953740efa1ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMThkMDY2MDFhMjA1ZGZmYmFkY2E5OGUxZmY5NTM3NDBlZmExYmE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-15T23:49:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-15T23:49:02Z"}, "message": "Merge branch 'contrib'", "tree": {"sha": "eba4e9716c905209b8e35b02482550cf82a7e509", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eba4e9716c905209b8e35b02482550cf82a7e509"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c218d06601a205dffbadca98e1ff953740efa1ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c218d06601a205dffbadca98e1ff953740efa1ba", "html_url": "https://github.com/rust-lang/rust/commit/c218d06601a205dffbadca98e1ff953740efa1ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c218d06601a205dffbadca98e1ff953740efa1ba/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b675a021a73a3dfa09079790a50302aeb6d1616", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b675a021a73a3dfa09079790a50302aeb6d1616", "html_url": "https://github.com/rust-lang/rust/commit/0b675a021a73a3dfa09079790a50302aeb6d1616"}, {"sha": "e714402a9290acbcca3df8eeb2c767ff72452e9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e714402a9290acbcca3df8eeb2c767ff72452e9e", "html_url": "https://github.com/rust-lang/rust/commit/e714402a9290acbcca3df8eeb2c767ff72452e9e"}], "stats": {"total": 195, "additions": 108, "deletions": 87}, "files": [{"sha": "ecc182e1f79c48dc15546dc5bf8a9b5840d7af25", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c218d06601a205dffbadca98e1ff953740efa1ba/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/c218d06601a205dffbadca98e1ff953740efa1ba/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=c218d06601a205dffbadca98e1ff953740efa1ba", "patch": "@@ -24,6 +24,7 @@\n *.toc\n *.tp\n *.vr\n+*.swp\n .hg/\n .hgignore\n lexer.ml"}, {"sha": "c9ab6ffd57f8f928b7c2aeefa670ce4ab4bd7b64", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c218d06601a205dffbadca98e1ff953740efa1ba/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c218d06601a205dffbadca98e1ff953740efa1ba/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=c218d06601a205dffbadca98e1ff953740efa1ba", "patch": "@@ -4,6 +4,7 @@ Graydon Hoare <graydon@mozilla.com>\n \n Other authors:\n \n+Adam Bozanich <adam.boz@gmail.com>\n Andreas Gal <gal@mozilla.com>\n Brendan Eich <brendan@mozilla.org>\n Chris Double <chris.double@double.co.nz>"}, {"sha": "d0042ebf2574edb66a84a198ffec84838daa0323", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 88, "deletions": 87, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c218d06601a205dffbadca98e1ff953740efa1ba/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c218d06601a205dffbadca98e1ff953740efa1ba/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=c218d06601a205dffbadca98e1ff953740efa1ba", "patch": "@@ -775,7 +775,6 @@ and parse_type_item\n   let item = Ast.MOD_ITEM_type (effect, ty) in\n     (ident, span ps apos bpos (decl params item))\n \n-\n and parse_mod_item (ps:pstate) : (Ast.ident * Ast.mod_item) =\n   let apos = lexpos ps in\n   let parse_lib_name ident =\n@@ -849,72 +848,35 @@ and parse_mod_item (ps:pstate) : (Ast.ident * Ast.mod_item) =\n                 note_required_mod ps {lo=apos; hi=bpos} conv rlib item;\n                 (ident, item)\n           end\n-\n-      | USE ->\n-          begin\n-            bump ps;\n-            let ident = ctxt \"use mod: ident\" Pexp.parse_ident ps in\n-            let meta =\n-              ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n-            in\n-            let bpos = lexpos ps in\n-            let id = (span ps apos bpos ()).id in\n-            let (path, items) =\n-              ps.pstate_get_mod meta id ps.pstate_node_id ps.pstate_opaque_id\n-            in\n-            let bpos = lexpos ps in\n-              expect ps SEMI;\n-              let rlib =\n-                REQUIRED_LIB_rust { required_libname = path;\n-                                    required_prefix = ps.pstate_depth }\n-              in\n-                iflog ps\n-                  begin\n-                    fun _ ->\n-                      log ps \"extracted mod from %s (binding to %s)\"\n-                        path ident;\n-                      log ps \"%a\" Ast.sprintf_mod_items items;\n-                  end;\n-                let item = decl [||] (Ast.MOD_ITEM_mod (empty_view, items)) in\n-                let item = span ps apos bpos item in\n-                  note_required_mod ps {lo=apos; hi=bpos} CONV_rust rlib item;\n-                  (ident, item)\n-          end\n-\n-\n-\n       | _ -> raise (unexpected ps)\n \n+and parse_mod_items_header_from_signature (ps:pstate) : Ast.mod_view =\n+  let exports = Hashtbl.create 0 in\n+    while (peek ps = EXPORT)\n+    do\n+      bump ps;\n+      parse_export ps exports;\n+      expect ps SEMI;\n+    done;\n+    if (Hashtbl.length exports) = 0\n+    then htab_put exports Ast.EXPORT_all_decls ();\n+    {empty_view with Ast.view_exports = exports}\n \n and parse_mod_items_from_signature\n     (ps:pstate)\n     : (Ast.mod_view * Ast.mod_items) =\n-  let exports = Hashtbl.create 0 in\n-  let mis = Hashtbl.create 0 in\n-  let in_view = ref true in\n-    expect ps LBRACE;\n+  expect ps LBRACE;\n+  let view  = parse_mod_items_header_from_signature ps in\n+  let items = Hashtbl.create 0 in\n     while not (peek ps = RBRACE)\n     do\n-      if !in_view\n-      then\n-        match peek ps with\n-            EXPORT ->\n-              bump ps;\n-              parse_export ps exports;\n-              expect ps SEMI;\n-          | _ ->\n-              in_view := false\n-      else\n-        let (ident, mti) = ctxt \"mod items from sig: mod item\"\n-          parse_mod_item_from_signature ps\n-        in\n-          Hashtbl.add mis ident mti;\n+      let (ident,item) = ctxt \"mod items from sig: mod item\"\n+              parse_mod_item_from_signature ps\n+      in\n+        htab_put items ident item;\n     done;\n-    if (Hashtbl.length exports) = 0\n-    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n     expect ps RBRACE;\n-    ({empty_view with Ast.view_exports = exports}, mis)\n-\n+    (view,items)\n \n and parse_mod_item_from_signature (ps:pstate)\n     : (Ast.ident * Ast.mod_item) =\n@@ -1032,7 +994,6 @@ and expand_tags_to_stmts\n               (Ast.DECL_mod_item (ident, tag_item))))\n       id_items\n \n-\n and expand_tags_to_items\n     (ps:pstate)\n     (item:Ast.mod_item)\n@@ -1043,7 +1004,6 @@ and expand_tags_to_items\n       (fun (ident, item) -> htab_put items ident item)\n       id_items\n \n-\n and note_required_mod\n     (ps:pstate)\n     (sp:span)\n@@ -1123,48 +1083,89 @@ and parse_export\n   in\n     Hashtbl.add exports e ()\n \n+and parse_use\n+    (ps:pstate)\n+    : (Ast.ident * Ast.mod_item) = \n+  bump ps;\n+  let ident = ctxt \"use mod: ident\" Pexp.parse_ident ps in\n+  let meta =\n+    ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n+  in\n+  let apos = lexpos ps in\n+  let bpos = lexpos ps in\n+  let id = (span ps apos bpos ()).id in\n+  let (path, items) =\n+    ps.pstate_get_mod meta id ps.pstate_node_id ps.pstate_opaque_id\n+  in\n+  let bpos = lexpos ps in\n+    expect ps SEMI;\n+    let rlib =\n+      REQUIRED_LIB_rust { required_libname = path;\n+                          required_prefix = ps.pstate_depth }\n+    in\n+      iflog ps\n+        begin\n+          fun _ ->\n+            log ps \"extracted mod from %s (binding to %s)\"\n+              path ident;\n+            log ps \"%a\" Ast.sprintf_mod_items items;\n+        end;\n+      let item = decl [||] (Ast.MOD_ITEM_mod (empty_view, items)) in\n+      let item = span ps apos bpos item in\n+        note_required_mod ps {lo=apos; hi=bpos} CONV_rust rlib item;\n+        (ident, item)\n+\n+and parse_item_decl ps items fn =\n+  let (ident, item) = fn ps in\n+    htab_put items ident item;\n+    expand_tags_to_items ps item items\n+\n+and parse_mod_header (ps:pstate)\n+                     : (Ast.mod_view * Ast.mod_items) =\n+  let imports = Hashtbl.create 0 in\n+  let exports = Hashtbl.create 0 in\n+  let items   = Hashtbl.create 4 in\n+  let rec loop () =\n+    match peek ps with\n+        IMPORT ->\n+          bump ps;\n+          parse_import ps imports;\n+          expect ps SEMI;\n+          loop ()\n+      | EXPORT ->\n+          bump ps;\n+          parse_export ps exports;\n+          expect ps SEMI;\n+          loop ()\n+      | USE ->\n+          parse_item_decl ps items parse_use;\n+          loop ()\n+      | _ -> ()\n+  in\n+    loop ();\n+    if (Hashtbl.length exports) = 0\n+    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n+    let view = { Ast.view_imports = imports;\n+                 Ast.view_exports = exports }\n+    in\n+      (view, items)\n \n and parse_mod_items\n     (ps:pstate)\n     (terminal:token)\n     : (Ast.mod_view * Ast.mod_items) =\n   ps.pstate_depth <- ps.pstate_depth + 1;\n-  let imports = Hashtbl.create 0 in\n-  let exports = Hashtbl.create 0 in\n-  let in_view = ref true in\n-  let items = Hashtbl.create 4 in\n+  let (view, items) = parse_mod_header ps in\n     while (not (peek ps = terminal))\n     do\n-      if !in_view\n-      then\n-        match peek ps with\n-            IMPORT ->\n-              bump ps;\n-              parse_import ps imports;\n-              expect ps SEMI;\n-          | EXPORT ->\n-              bump ps;\n-              parse_export ps exports;\n-              expect ps SEMI;\n-          | _ ->\n-              in_view := false\n-      else\n-        let (ident, item) = parse_mod_item ps in\n-          htab_put items ident item;\n-          expand_tags_to_items ps item items;\n+      parse_item_decl ps items parse_mod_item;\n     done;\n-    if (Hashtbl.length exports) = 0\n-    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n     expect ps terminal;\n     ps.pstate_depth <- ps.pstate_depth - 1;\n-    let view = { Ast.view_imports = imports;\n-                 Ast.view_exports = exports }\n-    in\n-      (view, items)\n+    (view, items)\n ;;\n \n \n-\n (*\n  * Local Variables:\n  * fill-column: 78;"}, {"sha": "0b3302691a458a2a59e49518f22965dc01607a75", "filename": "src/test/run-pass/use-import-export.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c218d06601a205dffbadca98e1ff953740efa1ba/src%2Ftest%2Frun-pass%2Fuse-import-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c218d06601a205dffbadca98e1ff953740efa1ba/src%2Ftest%2Frun-pass%2Fuse-import-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-import-export.rs?ref=c218d06601a205dffbadca98e1ff953740efa1ba", "patch": "@@ -0,0 +1,18 @@\n+\n+mod foo {\n+  export x;\n+  use std (ver=\"0.0.1\");\n+  fn x() -> int { ret 1; }\n+}\n+\n+mod bar {\n+  use std (ver=\"0.0.1\");\n+  export y;\n+  fn y() -> int { ret 1; }\n+}\n+\n+fn main() {\n+  foo.x();\n+  bar.y();\n+}\n+"}]}