{"sha": "8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmODRkNGM4YjYzMDVjOTYwY2Y1MWMzNWE1ZWEzODY5N2Q3ZmE1MzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-08T18:02:22Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:31:34Z"}, "message": "Remove a large part of the tydesc-passing code", "tree": {"sha": "0f0e84976e0ba84a8feb360961427fc83ccdf47b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f0e84976e0ba84a8feb360961427fc83ccdf47b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "html_url": "https://github.com/rust-lang/rust/commit/8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83c9f585342d6974c5f1847f18ab2b6322b1ea42", "url": "https://api.github.com/repos/rust-lang/rust/commits/83c9f585342d6974c5f1847f18ab2b6322b1ea42", "html_url": "https://github.com/rust-lang/rust/commit/83c9f585342d6974c5f1847f18ab2b6322b1ea42"}], "stats": {"total": 419, "additions": 112, "deletions": 307}, "files": [{"sha": "5c6eb30bbeb57dd0ecc87d9aa8267269357cde9c", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -429,7 +429,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'f');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n-        encode_symbol(ecx, ebml_w, ctor_id);\n+        if tps.len() == 0u {\n+            encode_symbol(ecx, ebml_w, ctor_id);\n+        }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n@@ -447,7 +449,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         }\n         alt ifce {\n           some(t) {\n-            encode_symbol(ecx, ebml_w, item.id);\n             let i_ty = alt check t.node {\n               ty_path(_, id) { ty::node_id_to_type(tcx, id) }\n             };"}, {"sha": "2babf26b3b78292c446b6721f1da8d0b0889cd97", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 54, "deletions": 187, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -270,7 +270,7 @@ fn dynastack_alloca(cx: block, t: TypeRef, n: ValueRef, ty: ty::t) ->\n                    C_uint(bcx.ccx(), llsize_of_real(bcx.ccx(), t)),\n                    n);\n \n-    let lltydesc = get_tydesc_simple(cx, ty, false).val;\n+    let lltydesc = get_tydesc_simple(cx, ty).val;\n \n     let llresult = Call(dy_cx, dynastack_alloc, [llsz, lltydesc]);\n     ret PointerCast(dy_cx, llresult, T_ptr(t));\n@@ -450,7 +450,7 @@ fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n     let llty = type_of(ccx, box_ptr);\n \n     // Get the tydesc for the body:\n-    let {bcx, val: lltydesc} = get_tydesc(bcx, t, true, static_ti);\n+    let {bcx, val: lltydesc} = get_tydesc(bcx, t, static_ti);\n     lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n     // Allocate space:\n@@ -470,37 +470,6 @@ fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n \n // Type descriptor and type glue stuff\n \n-// Given a type and a field index into its corresponding type descriptor,\n-// returns an LLVM ValueRef of that field from the tydesc, generating the\n-// tydesc if necessary.\n-fn field_of_tydesc(cx: block, t: ty::t, escapes: bool, field: int) ->\n-   result {\n-    let tydesc = get_tydesc_simple(cx, t, escapes);\n-    ret rslt(tydesc.bcx,\n-             GEPi(tydesc.bcx, tydesc.val, [0, field]));\n-}\n-\n-// Given a type containing ty params, build a vector containing a ValueRef for\n-// each of the ty params it uses (from the current frame) and a vector of the\n-// indices of the ty params present in the type. This is used solely for\n-// constructing derived tydescs.\n-fn linearize_ty_params(cx: block, t: ty::t) ->\n-   {params: [uint], descs: [ValueRef]} {\n-    let param_vals = [], param_defs = [];\n-    ty::walk_ty(cx.tcx(), t) {|t|\n-        alt ty::get(t).struct {\n-          ty::ty_param(pid, _) {\n-            if !vec::any(param_defs, {|d| d == pid}) {\n-                param_vals += [cx.fcx.lltyparams[pid].desc];\n-                param_defs += [pid];\n-            }\n-          }\n-          _ { }\n-        }\n-    }\n-    ret {params: param_defs, descs: param_vals};\n-}\n-\n fn trans_stack_local_derived_tydesc(cx: block, llsz: ValueRef,\n                                     llalign: ValueRef, llroottydesc: ValueRef,\n                                     llfirstparam: ValueRef, n_params: uint)\n@@ -527,93 +496,16 @@ fn trans_stack_local_derived_tydesc(cx: block, llsz: ValueRef,\n     ret llmyroottydesc;\n }\n \n-fn get_derived_tydesc(cx: block, t: ty::t, escapes: bool,\n-                      &static_ti: option<@tydesc_info>) -> result {\n-    alt cx.fcx.derived_tydescs.find(t) {\n-      some(info) {\n-        // If the tydesc escapes in this context, the cached derived\n-        // tydesc also has to be one that was marked as escaping.\n-        if !(escapes && !info.escapes) {\n-            ret rslt(cx, info.lltydesc);\n-        }\n-      }\n-      none {/* fall through */ }\n-    }\n-\n-    cx.ccx().stats.n_derived_tydescs += 1u;\n-    let bcx = raw_block(cx.fcx, cx.fcx.llderivedtydescs);\n-    let tys = linearize_ty_params(bcx, t);\n-    let root_ti = get_static_tydesc(bcx.ccx(), t, tys.params);\n-    static_ti = some(root_ti);\n-    lazily_emit_all_tydesc_glue(cx.ccx(), static_ti);\n-    let root = root_ti.tydesc;\n-    let sz = size_of(bcx, t);\n-    bcx = sz.bcx;\n-    let align = align_of(bcx, t);\n-    bcx = align.bcx;\n-\n-    // Store the captured type descriptors in an alloca if the caller isn't\n-    // promising to do so itself.\n-    let n_params = ty::count_ty_params(bcx.tcx(), t);\n-\n-    assert n_params == tys.params.len();\n-    assert n_params == tys.descs.len();\n-\n-    let llparamtydescs =\n-        alloca(bcx, T_array(T_ptr(bcx.ccx().tydesc_type), n_params + 1u));\n-    let i = 0;\n-\n-    // If the type descriptor escapes, we need to add in the root as\n-    // the first parameter, because upcall_get_type_desc() expects it.\n-    if escapes {\n-        Store(bcx, root, GEPi(bcx, llparamtydescs, [0, 0]));\n-        i += 1;\n-    }\n-\n-    for td: ValueRef in tys.descs {\n-        Store(bcx, td, GEPi(bcx, llparamtydescs, [0, i]));\n-        i += 1;\n-    }\n-\n-    let llfirstparam =\n-        PointerCast(bcx, llparamtydescs,\n-                    T_ptr(T_ptr(bcx.ccx().tydesc_type)));\n-\n-    let v;\n-    if escapes {\n-        let ccx = bcx.ccx();\n-        let td_val =\n-            Call(bcx, ccx.upcalls.get_type_desc,\n-                 [C_null(T_ptr(T_nil())), sz.val,\n-                  align.val, C_uint(ccx, 1u + n_params), llfirstparam,\n-                  C_uint(ccx, 0u)]);\n-        v = td_val;\n-    } else {\n-        v = trans_stack_local_derived_tydesc(bcx, sz.val, align.val, root,\n-                                             llfirstparam, n_params);\n-    }\n-    bcx.fcx.derived_tydescs.insert(t, {lltydesc: v, escapes: escapes});\n-    ret rslt(cx, v);\n-}\n-\n-fn get_tydesc_simple(bcx: block, t: ty::t, escapes: bool) -> result {\n+fn get_tydesc_simple(bcx: block, t: ty::t) -> result {\n     let ti = none;\n-    get_tydesc(bcx, t, escapes, ti)\n+    get_tydesc(bcx, t, ti)\n }\n \n-fn get_tydesc(cx: block, t: ty::t, escapes: bool,\n+fn get_tydesc(cx: block, t: ty::t,\n               &static_ti: option<@tydesc_info>) -> result {\n \n-    // Is the supplied type a type param? If so, return the passed-in tydesc.\n-    alt ty::type_param(t) {\n-      some(id) { ret rslt(cx, cx.fcx.lltyparams[id].desc); }\n-      none {/* fall through */ }\n-    }\n-\n-    // Does it contain a type param? If so, generate a derived tydesc.\n-    if ty::type_has_params(t) {\n-        ret get_derived_tydesc(cx, t, escapes, static_ti);\n-    }\n+    // FIXME[mono]\n+    assert !ty::type_has_params(t);\n     // Otherwise, generate a tydesc if necessary, and return it.\n     let info = get_static_tydesc(cx.ccx(), t, []);\n     static_ti = some(info);\n@@ -980,7 +872,7 @@ fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n         let dtor_addr = common::get_res_dtor(ccx, did, inner_t);\n         let args = [bcx.fcx.llretptr, null_env_ptr(bcx)];\n         for tp in tps {\n-            let td = get_tydesc_simple(bcx, tp, false);\n+            let td = get_tydesc_simple(bcx, tp);\n             args += [td.val];\n             bcx = td.bcx;\n         }\n@@ -1244,13 +1136,6 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n }\n \n-fn lazily_emit_all_generic_info_tydesc_glues(ccx: @crate_ctxt,\n-                                             gi: generic_info) {\n-    for ti: option<@tydesc_info> in gi.static_tis {\n-        lazily_emit_all_tydesc_glue(ccx, ti);\n-    }\n-}\n-\n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n                            static_ti: option<@tydesc_info>) {\n     alt static_ti {\n@@ -1349,7 +1234,7 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n    block {\n     let ti: option<@tydesc_info> = none::<@tydesc_info>;\n-    let {bcx: bcx, val: td} = get_tydesc(cx, t, false, ti);\n+    let {bcx: bcx, val: td} = get_tydesc(cx, t, ti);\n     call_tydesc_glue_full(bcx, v, td, field, ti);\n     ret bcx;\n }\n@@ -1370,7 +1255,7 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n     let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n-    r = get_tydesc_simple(bcx, t, false);\n+    r = get_tydesc_simple(bcx, t);\n     let lltydesc = r.val;\n     bcx = r.bcx;\n     let lltydescs =\n@@ -2047,18 +1932,6 @@ fn trans_loop(cx:block, body: ast::blk) -> block {\n     ret next_cx;\n }\n \n-type generic_info = {item_type: ty::t,\n-                     static_tis: [option<@tydesc_info>],\n-                     tydescs: [ValueRef],\n-                     param_bounds: @[ty::param_bounds],\n-                     origins: option<typeck::vtable_res>};\n-\n-enum generic_callee {\n-    generic_full(generic_info),\n-    generic_mono(ty::t),\n-    generic_none,\n-}\n-\n enum lval_kind {\n     temporary, //< Temporary value passed by value if of immediate type\n     owned,     //< Non-temporary value passed by pointer\n@@ -2075,7 +1948,7 @@ type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n                           kind: lval_kind,\n                           env: callee_env,\n-                          generic: generic_callee};\n+                          tds: option<[ValueRef]>};\n \n fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n@@ -2094,8 +1967,7 @@ fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n \n fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, kind: kind, env: is_closure,\n-         generic: generic_none};\n+    ret {bcx: bcx, val: val, kind: kind, env: is_closure, tds: none};\n }\n \n fn trans_external_path(cx: block, did: ast::def_id,\n@@ -2108,7 +1980,7 @@ fn trans_external_path(cx: block, did: ast::def_id,\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n                   vtables: option<typeck::vtable_res>)\n-    -> option<{llfn: ValueRef, fty: ty::t}> {\n+    -> option<ValueRef> {\n     let substs = vec::map(substs, {|t|\n         alt ty::get(t).struct {\n           ty::ty_box(mt) { ty::mk_opaque_box(ccx.tcx) }\n@@ -2126,7 +1998,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n \n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let mono_ty = ty::substitute_type_params(ccx.tcx, substs, tpt.ty);\n-    let llfty = type_of_fn_from_ty(ccx, mono_ty, []);\n+    let llfty = type_of_fn_from_ty(ccx, mono_ty, 0u);\n \n     let map_node = ccx.tcx.items.get(fn_id.node);\n     // Get the path so that we can create a symbol\n@@ -2146,7 +2018,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     let pt = *pt + [path_name(ccx.names(name))];\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n     let lldecl = decl_cdecl_fn(ccx.llmod, s, llfty);\n-    ccx.monomorphized.insert(hash_id, {llfn: lldecl, fty: mono_ty});\n+    ccx.monomorphized.insert(hash_id, lldecl);\n \n     let psubsts = some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n     alt check map_node {\n@@ -2182,10 +2054,9 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         }\n       }\n     }\n-    some({llfn: lldecl, fty: mono_ty})\n+    some(lldecl)\n }\n \n-// FIXME[mono] Only actually translate things that are not generic\n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n     alt ccx.external.find(fn_id) {\n@@ -2266,10 +2137,12 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n           }\n         };\n         alt mono {\n-          some({llfn, fty}) {\n-            ret {bcx: bcx, val: llfn,\n+          some(llfn) {\n+            let cast = PointerCast(bcx, llfn, T_ptr(type_of_fn_from_ty(\n+                ccx, node_id_type(bcx, id), 0u)));\n+            ret {bcx: bcx, val: cast,\n                  kind: owned, env: null_env,\n-                 generic: generic_mono(fty)};\n+                 tds: none};\n           }\n           none {}\n         }\n@@ -2295,23 +2168,22 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         }\n     }\n \n-    let gen = generic_none, bcx = bcx;\n+    let tds = none, bcx = bcx;\n+    // FIXME[mono] ensure this is a native function\n     if tys.len() > 0u {\n-        let tydescs = [], tis = [];\n+        val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n+            ccx, node_id_type(bcx, id), tys.len())));\n+        let tydescs = [];\n         for t in tys {\n             let ti = none;\n-            let td = get_tydesc(bcx, t, true, ti);\n-            tis += [ti];\n+            let td = get_tydesc(bcx, t, ti);\n+            lazily_emit_all_tydesc_glue(ccx, ti);\n             bcx = td.bcx;\n             tydescs += [td.val];\n         }\n-        gen = generic_full({item_type: tpt.ty,\n-                            static_tis: tis,\n-                            tydescs: tydescs,\n-                            param_bounds: tpt.bounds,\n-                            origins: ccx.maps.vtable_map.find(id)});\n+        tds = some(tydescs);\n     }\n-    ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n+    ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: tds};\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2564,7 +2436,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n }\n \n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n-    let must_bind = alt c.generic { generic_full(_) { true } _ { false } } ||\n+    let must_bind = option::is_some(c.tds) ||\n         alt c.env { self_env(_, _) { true } _ { false } };\n     if must_bind {\n         let n_args = ty::ty_fn_args(ty).len();\n@@ -2761,7 +2633,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: block, llenv: ValueRef,\n-              gen: generic_callee, es: [@ast::expr], fn_ty: ty::t,\n+              tds: option<[ValueRef]>, es: [@ast::expr], fn_ty: ty::t,\n               dest: dest)\n    -> {bcx: block,\n        args: [ValueRef],\n@@ -2770,54 +2642,40 @@ fn trans_args(cx: block, llenv: ValueRef,\n     let temp_cleanups = [];\n     let args = ty::ty_fn_args(fn_ty);\n     let llargs: [ValueRef] = [];\n-    let lltydescs: [ValueRef] = [];\n \n     let ccx = cx.ccx();\n     let bcx = cx;\n \n-    let retty = ty::ty_fn_ret(fn_ty), full_retty = retty;\n-    alt gen {\n-      generic_full(g) { fail; }\n-      generic_mono(t) {\n-        args = ty::ty_fn_args(t);\n-        retty = ty::ty_fn_ret(t);\n-      }\n-      _ { }\n-    }\n+    let retty = ty::ty_fn_ret(fn_ty);\n     // Arg 0: Output pointer.\n     let llretslot = alt dest {\n       ignore {\n         if ty::type_is_nil(retty) {\n             llvm::LLVMGetUndef(T_ptr(T_nil()))\n         } else {\n-            let {bcx: cx, val} = alloc_ty(bcx, full_retty);\n+            let {bcx: cx, val} = alloc_ty(bcx, retty);\n             bcx = cx;\n             val\n         }\n       }\n       save_in(dst) { dst }\n       by_val(_) {\n-          let {bcx: cx, val} = alloc_ty(bcx, full_retty);\n+          let {bcx: cx, val} = alloc_ty(bcx, retty);\n           bcx = cx;\n           val\n       }\n     };\n \n-    if retty != full_retty || ty::type_has_params(retty) {\n-        // It's possible that the callee has some generic-ness somewhere in\n-        // its return value -- say a method signature within an obj or a fn\n-        // type deep in a structure -- which the caller has a concrete view\n-        // of. If so, cast the caller's view of the restlot to the callee's\n-        // view, for the sake of making a type-compatible call.\n-        let llretty = T_ptr(type_of(ccx, retty));\n-        llargs += [PointerCast(cx, llretslot, llretty)];\n-    } else { llargs += [llretslot]; }\n+    llargs += [llretslot];\n \n     // Arg 1: Env (closure-bindings / self value)\n     llargs += [llenv];\n \n     // Args >2: ty_params ...\n-    llargs += lltydescs;\n+    alt tds {\n+      some(tds) { llargs += tds; }\n+      none {}\n+    }\n \n     // ... then explicit args.\n \n@@ -2883,7 +2741,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n \n         let ret_ty = node_id_type(bcx, id);\n         let args_res =\n-            trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n+            trans_args(bcx, llenv, f_res.tds, args, fn_expr_ty, dest);\n         bcx = args_res.bcx;\n         let llargs = args_res.args;\n         let llretslot = args_res.retslot;\n@@ -3418,7 +3276,7 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n         with_scope(bcx, \"log\") {|bcx|\n             let {bcx, val, _} = trans_temp_expr(bcx, e);\n             let e_ty = expr_ty(bcx, e);\n-            let {bcx, val: tydesc} = get_tydesc_simple(bcx, e_ty, false);\n+            let {bcx, val: tydesc} = get_tydesc_simple(bcx, e_ty);\n             // Call the polymorphic log function.\n             let {bcx, val} = spill_if_immediate(bcx, val, e_ty);\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n@@ -4376,6 +4234,15 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n                      llfndecl, no_self, none, item.id, none);\n+        } else {\n+            for stmt in body.node.stmts {\n+                alt stmt.node {\n+                  ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n+                    trans_item(ccx, *i);\n+                  }\n+                  _ {}\n+                }\n+            }\n         }\n       }\n       ast::item_impl(tps, _, _, ms) {\n@@ -4400,8 +4267,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let i = 0;\n             for variant: ast::variant in variants {\n-                let llfn = get_item_val(ccx, variant.node.id);\n                 if variant.node.args.len() > 0u {\n+                    let llfn = get_item_val(ccx, variant.node.id);\n                     trans_enum_variant(ccx, item.id, variant,\n                                        vi[i].disr_val, degen,\n                                        none, llfn);\n@@ -4535,7 +4402,7 @@ fn param_bounds(ccx: @crate_ctxt, tps: [ast::ty_param])\n fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                     bnds: [ty::param_bounds], node_id: ast::node_id,\n                     node_type: ty::t) -> ValueRef {\n-    let llfty = type_of_fn_from_ty(ccx, node_type, bnds);\n+    let llfty = type_of_fn_from_ty(ccx, node_type, bnds.len());\n     register_fn_fuller(ccx, sp, path, flav, node_id, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n@@ -4582,7 +4449,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n             {mode: ast::expl(ast::by_val),\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm})};\n         let nt = ty::mk_nil(ccx.tcx);\n-        let llfty = type_of_fn(ccx, [vecarg_ty], nt, []);\n+        let llfty = type_of_fn(ccx, [vecarg_ty], nt, 0u);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n "}, {"sha": "eae89f4304c80b5e65a5288c803ad479e19ce4ba", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 31, "deletions": 88, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -131,21 +131,15 @@ fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_tys(tcx: ty::ctxt,\n                   ck: ty::closure_kind,\n-                  ty_params: [fn_ty_param],\n+                  ty_params: option<[ValueRef]>,\n                   bound_values: [environment_value])\n     -> (ty::t, [ty::t]) {\n     let bound_tys = [];\n \n-    let tydesc_ty = mk_tydesc_ty(tcx, ck);\n-\n     // Compute the closed over tydescs\n-    let param_ptrs = [];\n-    for tp in ty_params {\n-        param_ptrs += [tydesc_ty];\n-        option::may(tp.vtables) {|vtables|\n-            for vtable in vtables { param_ptrs += [tydesc_ty]; }\n-        }\n-    }\n+    let n_param_ptrs = alt ty_params {\n+      some(tds) { tds.len() } none { 0u }\n+    };\n \n     // Compute the closed over data\n     for bv in bound_values {\n@@ -158,7 +152,8 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n \n-    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, param_ptrs),\n+    let typtrs = vec::from_elem(n_param_ptrs, mk_tydesc_ty(tcx, ck));\n+    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, typtrs),\n                                     bound_data_ty]);\n     #debug[\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)];\n     ret (cdata_ty, bound_tys);\n@@ -186,7 +181,7 @@ fn allocate_cbox(bcx: block,\n                          &ti: option<@tydesc_info>) -> block {\n         let ccx = bcx.ccx();\n         let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n-        let {bcx, val: td} = base::get_tydesc(bcx, cdata_ty, true, ti);\n+        let {bcx, val: td} = base::get_tydesc(bcx, cdata_ty, ti);\n         let td = Call(bcx, ccx.upcalls.create_shared_type_desc, [td]);\n         Store(bcx, td, bound_tydesc);\n         bcx\n@@ -243,7 +238,7 @@ fn cast_if_we_can(bcx: block, llbox: ValueRef, t: ty::t) -> ValueRef {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(\n-    bcx: block, lltyparams: [fn_ty_param],\n+    bcx: block, lltyparams: option<[ValueRef]>,\n     bound_values: [environment_value],\n     ck: ty::closure_kind)\n     -> closure_result {\n@@ -284,18 +279,11 @@ fn store_environment(\n     let {bcx:bcx, val:ty_params_slot} =\n         GEP_tup_like(bcx, cbox_ty, llbox,\n                      [0, abi::box_field_body, abi::closure_body_ty_params]);\n-    let off = 0;\n-    for tp in lltyparams {\n-        let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n-        Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, off]));\n-        off += 1;\n-        option::may(tp.vtables, {|vtables|\n-            for vtable in vtables {\n-                let cast = PointerCast(bcx, vtable, val_ty(cloned_td));\n-                Store(bcx, cast, GEPi(bcx, ty_params_slot, [0, off]));\n-                off += 1;\n-            }\n-        });\n+    option::may(lltyparams) {|tds|\n+        vec::iteri(tds) {|i, td|\n+            let cloned_td = maybe_clone_tydesc(bcx, ck, td);\n+            Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, i as int]));\n+        }\n     }\n \n     // Copy expr values into boxed bindings.\n@@ -389,14 +377,13 @@ fn build_closure(bcx0: block,\n           }\n         }\n     }\n-    ret store_environment(bcx, copy bcx.fcx.lltyparams, env_vals, ck);\n+    ret store_environment(bcx, none, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment(enclosing_cx: block,\n-                    fcx: fn_ctxt,\n+fn load_environment(fcx: fn_ctxt,\n                     cdata_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n@@ -405,27 +392,6 @@ fn load_environment(enclosing_cx: block,\n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n-    // Populate the type parameters from the environment. We need to\n-    // do this first because the tydescs are needed to index into\n-    // the bindings if they are dynamically sized.\n-    let {bcx, val: lltydescs} = GEP_tup_like(bcx, cdata_ty, llcdata,\n-                                            [0, abi::closure_body_ty_params]);\n-    let off = 0;\n-    for tp in copy enclosing_cx.fcx.lltyparams {\n-        let tydesc = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n-        off += 1;\n-        let vtables = option::map(tp.vtables, {|vtables|\n-            let rslt = [];\n-            for vtable in vtables {\n-                let vtable = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n-                rslt += [PointerCast(bcx, vtable, T_ptr(T_vtable()))];\n-                off += 1;\n-            }\n-            rslt\n-        });\n-        fcx.lltyparams += [{desc: tydesc, vtables: vtables}];\n-    }\n-\n     // Populate the upvars from the environment.\n     let i = 0u;\n     vec::iter(cap_vars) { |cap_var|\n@@ -460,7 +426,7 @@ fn trans_expr_fn(bcx: block,\n     if dest == ignore { ret bcx; }\n     let ccx = bcx.ccx(), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n-    let llfnty = type_of_fn_from_ty(ccx, fty, []);\n+    let llfnty = type_of_fn_from_ty(ccx, fty, 0u);\n     let sub_path = bcx.fcx.path + [path_name(\"anon\")];\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n@@ -472,7 +438,7 @@ fn trans_expr_fn(bcx: block,\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n                       bcx.fcx.param_substs, id, none, {|fcx|\n-            load_environment(bcx, fcx, cdata_ty, cap_vars, ck);\n+            load_environment(fcx, cdata_ty, cap_vars, ck);\n         });\n         llbox\n     };\n@@ -513,13 +479,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n         ret bcx;\n     }\n \n-    // Figure out which tydescs we need to pass, if any.\n-    let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n-      generic_full(ginfo) { fail; }\n-      _ { (outgoing_fty, [], @[]) }\n-    };\n-\n-    if bound.len() == 0u && lltydescs.len() == 0u &&\n+    if bound.len() == 0u && option::is_none(f_res.tds) &&\n        (f_res.env == null_env || f_res.env == is_closure) {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n@@ -545,14 +505,15 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n \n     // Actually construct the closure\n     let {llbox, cdata_ty, bcx} = store_environment(\n-        bcx, vec::map(lltydescs, {|d| {desc: d, vtables: none}}),\n+        bcx, f_res.tds,\n         env_vals + vec::map(bound, {|x| env_expr(x, expr_ty(bcx, x))}),\n         ty::ck_box);\n \n     // Make thunk\n     let llthunk = trans_bind_thunk(\n-        cx.fcx.ccx, cx.fcx.path, pair_ty, outgoing_fty_real, args,\n-        cdata_ty, *param_bounds, target_info);\n+        cx.fcx.ccx, cx.fcx.path, pair_ty, outgoing_fty, args,\n+        cdata_ty, target_info,\n+        alt f_res.tds { some(x) { x.len() } _ { 0u } });\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -704,16 +665,15 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                     outgoing_fty: ty::t,\n                     args: [option<@ast::expr>],\n                     cdata_ty: ty::t,\n-                    param_bounds: [ty::param_bounds],\n-                    target_info: target_info)\n+                    target_info: target_info,\n+                    n_tps: uint)\n     -> {val: ValueRef, ty: TypeRef} {\n     let tcx = ccx.tcx;\n     #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n-            cdata_ty=%s,param_bounds=%?]\",\n+            cdata_ty=%s]\",\n            ty_to_str(tcx, incoming_fty),\n            ty_to_str(tcx, outgoing_fty),\n-           ty_to_str(tcx, cdata_ty),\n-           param_bounds];\n+           ty_to_str(tcx, cdata_ty)];\n \n     // Here we're not necessarily constructing a thunk in the sense of\n     // \"function with no arguments\".  The result of compiling 'bind f(foo,\n@@ -813,28 +773,11 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let {bcx: l_bcx, val: param_record} =\n         GEP_tup_like(l_bcx, cdata_ty, llcdata,\n                      [0, abi::closure_body_ty_params]);\n-    let off = 0;\n-    for param in param_bounds {\n-        let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, off])),\n-            vtables = none;\n+    let i = 0u;\n+    while i < n_tps {\n+        let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, i as int]));\n         llargs += [dsc];\n-        off += 1;\n-        for bound in *param {\n-            alt bound {\n-              ty::bound_iface(_) {\n-                let vtable = Load(l_bcx, GEPi(l_bcx, param_record, [0, off]));\n-                vtable = PointerCast(l_bcx, vtable, T_ptr(T_vtable()));\n-                llargs += [vtable];\n-                off += 1;\n-                vtables = some(alt vtables {\n-                  none { [vtable] }\n-                  some(ds) { ds + [vtable] }\n-                });\n-              }\n-              _ {}\n-            }\n-        }\n-        fcx.lltyparams += [{desc: dsc, vtables: vtables}];\n+        fcx.lltyparams += [{desc: dsc, vtables: none}];\n     }\n \n     let a: uint = first_tp_arg; // retptr, env come first\n@@ -895,7 +838,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n     let lltargetty =\n-        type_of_fn_from_ty(ccx, outgoing_fty, param_bounds);\n+        type_of_fn_from_ty(ccx, outgoing_fty, 0u);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     Call(bcx, lltargetfn, llargs);\n     build_return(bcx);"}, {"sha": "6c7b1aa916fa6ea5b44ca8aa9fc1d76d11fea15d", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -93,7 +93,7 @@ type crate_ctxt = {\n      // Track mapping of external ids to local items imported for inlining\n      external: hashmap<ast::def_id, option<ast::node_id>>,\n      // Cache instances of monomorphized functions\n-     monomorphized: hashmap<mono_id, {llfn: ValueRef, fty: ty::t}>,\n+     monomorphized: hashmap<mono_id, ValueRef>,\n      // Cache generated vtables\n      vtables: hashmap<mono_id, ValueRef>,\n      module_data: hashmap<str, ValueRef>,\n@@ -180,6 +180,7 @@ type fn_ctxt = @{\n     llupvars: hashmap<ast::node_id, ValueRef>,\n \n     // A vector of incoming type descriptors and their associated vtables.\n+    // Currently only used by glue functions\n     mutable lltyparams: [fn_ty_param],\n \n     // Derived tydescs are tydescs created at runtime, for types that\n@@ -307,7 +308,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n     let nil_res = ty::mk_nil(ccx.tcx);\n     let fn_mode = ast::expl(ast::by_ref);\n     let f_t = type_of::type_of_fn(ccx, [{mode: fn_mode, ty: inner_t}],\n-                                  nil_res, *param_bounds);\n+                                  nil_res, (*param_bounds).len());\n     ret base::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.cstore,\n                                                     did), f_t);\n@@ -542,9 +543,9 @@ fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n-// to tydescs and other vtables that it closes over. But the types and number\n-// of those are rarely known to the code that needs to manipulate them, so\n-// they are described by this opaque type.\n+// to tydescs and other vtables that it closes over. But the types and number of\n+// those are rarely known to the code that needs to manipulate them, so they\n+// are described by this opaque type.\n fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n \n fn T_task(targ_cfg: @session::config) -> TypeRef {"}, {"sha": "85ba984bed915c4e438cbc0dc4ceceb652696711", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -76,7 +76,7 @@ fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n \n fn wrapper_fn_ty(ccx: @crate_ctxt, vtable_ty: TypeRef, fty: ty::t,\n                  tps: @[ty::param_bounds]) -> {ty: ty::t, llty: TypeRef} {\n-    let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *tps);\n+    let bare_fn_ty = type_of_fn_from_ty(ccx, fty, (*tps).len());\n     let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n     {ty: fty, llty: T_fn([vtable_ty] + inputs, output)}\n }\n@@ -86,13 +86,11 @@ fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n     -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx.ccx();\n     let fty = node_id_type(bcx, callee_id);\n-    let llfty = type_of::type_of_fn_from_ty(ccx, fty, []);\n+    let llfty = type_of::type_of_fn_from_ty(ccx, fty, 0u);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n-    {bcx: bcx, val: mptr, kind: owned,\n-     env: env,\n-     generic: generic_none}\n+    {bcx: bcx, val: mptr, kind: owned, env: env, tds: none}\n }\n \n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n@@ -243,10 +241,10 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n         let fty = ty::substitute_type_params(tcx, substs,\n                                              ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_vars(fty) {\n-            C_null(type_of_fn_from_ty(ccx, fty, []))\n+            C_null(type_of_fn_from_ty(ccx, fty, 0u))\n         } else {\n             let m_id = method_with_name(ccx, impl_id, im.ident);\n-            option::get(monomorphic_fn(ccx, m_id, substs, some(vtables))).llfn\n+            option::get(monomorphic_fn(ccx, m_id, substs, some(vtables)))\n         }\n     }))\n }"}, {"sha": "7aa059fb17ee8f99184eb550b23448d152a22896", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -269,7 +269,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n             ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n-        let llty = type_of_fn_from_ty(ccx, t, []);\n+        let llty = type_of_fn_from_ty(ccx, t, 0u);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id,\n                  none);\n@@ -383,8 +383,7 @@ fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n           ast::native_abi_rust_intrinsic {\n             // For intrinsics: link the function directly to the intrinsic\n             // function itself.\n-            let fn_type = type_of_fn_from_ty(\n-                ccx, node_type, param_bounds(ccx, tps));\n+            let fn_type = type_of_fn_from_ty(ccx, node_type, tps.len());\n             let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n             ccx.item_symbols.insert(i.id, ri_name);\n             get_extern_fn(ccx.externs, ccx.llmod, ri_name,"}, {"sha": "cf774e19acfa56b2bf21da2a9f7b64405be2fefe", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -701,7 +701,7 @@ fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n \n     alt ty::get(t).struct {\n       ty::ty_param(p, _) {\n-        let {bcx, val: tydesc} = base::get_tydesc_simple(cx, t, false);\n+        let {bcx, val: tydesc} = base::get_tydesc_simple(cx, t);\n         let szptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_size]);\n         let aptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_align]);\n         {bcx: bcx, sz: Load(bcx, szptr), align: Load(bcx, aptr)}"}, {"sha": "e7034adb47d83875506a38c426356faa6da3e2ae", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -202,7 +202,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let ccx = bcx.ccx();\n     let elt_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let ti = none;\n-    let {bcx: bcx, val: td} = get_tydesc(bcx, elt_ty, false, ti);\n+    let {bcx: bcx, val: td} = get_tydesc(bcx, elt_ty, ti);\n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr,\n                                T_ptr(T_ptr(ccx.opaque_vec_type)));"}, {"sha": "a7991563abb7460e17171142dcd8ac79650017f8", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f84d4c8b6305c960cf51c35a5ea38697d7fa530/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8f84d4c8b6305c960cf51c35a5ea38697d7fa530", "patch": "@@ -19,7 +19,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n }\n \n fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n-              output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n+              output: ty::t, n_ty_params: uint) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n@@ -29,24 +29,20 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n     atys += [T_opaque_box_ptr(cx)];\n \n     // Args >2: ty params, if not acquired via capture...\n-    for bounds in params {\n+    let i = 0u;\n+    while i < n_ty_params {\n         atys += [T_ptr(cx.tydesc_type)];\n-        for bound in *bounds {\n-            alt bound {\n-              ty::bound_iface(_) { atys += [T_ptr(T_vtable())]; }\n-              _ {}\n-            }\n-        }\n+        i += 1u;\n     }\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, inputs);\n     ret T_fn(atys, llvm::LLVMVoidType());\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n-                      param_bounds: [ty::param_bounds]) -> TypeRef {\n-    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n+fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t, n_ty_params: uint)\n+    -> TypeRef {\n+    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), n_ty_params)\n }\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n@@ -93,7 +89,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(tys)\n       }\n       ty::ty_fn(_) {\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, t, []))\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, t, 0u))\n       }\n       ty::ty_iface(_, _) { T_opaque_iface(cx) }\n       ty::ty_res(_, sub, tps) {\n@@ -155,7 +151,7 @@ fn type_of_ty_param_bounds_and_ty\n     let t = tpt.ty;\n     alt ty::get(t).struct {\n       ty::ty_fn(_) {\n-        ret type_of_fn_from_ty(ccx, t, *tpt.bounds);\n+        ret type_of_fn_from_ty(ccx, t, (*tpt.bounds).len());\n       }\n       _ {\n         // fall through"}]}