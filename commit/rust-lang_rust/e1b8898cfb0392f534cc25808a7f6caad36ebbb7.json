{"sha": "e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYjg4OThjZmIwMzkyZjUzNGNjMjU4MDhhN2Y2Y2FhZDM2ZWJiYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T08:17:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-09T08:17:48Z"}, "message": "Auto merge of #57882 - euclio:unused-doc-attributes, r=estebank\n\noverhaul unused doc comments lint\n\nThis PR contains a number of improvements to the `unused_doc_comments` lint.\n\n- Extends the span to cover the entire comment when using sugared doc comments.\n- Triggers the lint for all unused doc comments on a node, instead of just the first one.\n- Triggers the lint on macro expansions, and provides a help note explaining that doc comments must be expanded by the macro.\n- Adds a label pointing at the node that cannot be documented.\n\nFurthermore, this PR fixes any instances in rustc where a macro expansion was erroneously documented.", "tree": {"sha": "52b15becdc2531921468fdabbe243479e61a523e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52b15becdc2531921468fdabbe243479e61a523e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "html_url": "https://github.com/rust-lang/rust/commit/e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9f8304351ad4223e4f618e9a329b2b94776b25e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f8304351ad4223e4f618e9a329b2b94776b25e", "html_url": "https://github.com/rust-lang/rust/commit/c9f8304351ad4223e4f618e9a329b2b94776b25e"}, {"sha": "daf80f721b0c9f3a57f13dd9d8934e851ad17dd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf80f721b0c9f3a57f13dd9d8934e851ad17dd5", "html_url": "https://github.com/rust-lang/rust/commit/daf80f721b0c9f3a57f13dd9d8934e851ad17dd5"}], "stats": {"total": 505, "additions": 342, "deletions": 163}, "files": [{"sha": "98b5fcd3ee4f06fbcc4eeb22d393dcfda16d7584", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -4515,7 +4515,7 @@ macro_rules! rev {\n     )*}\n }\n \n-/// intra-sign conversions\n+// intra-sign conversions\n try_from_upper_bounded!(u16, u8);\n try_from_upper_bounded!(u32, u16, u8);\n try_from_upper_bounded!(u64, u32, u16, u8);"}, {"sha": "4fb8b7168b89d510e6b4dd24aa921ed7133e0848", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -122,15 +122,15 @@ impl fmt::Display for HirId {\n // hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n-    /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-    /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n-    /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n-    /// the node's position within the owning item in any way, but there is a\n-    /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n-    /// integers starting at zero, so a mapping that maps all or most nodes within\n-    /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n-    /// tree or hash map.\n     newtype_index! {\n+        /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n+        /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+        /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n+        /// the node's position within the owning item in any way, but there is a\n+        /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+        /// integers starting at zero, so a mapping that maps all or most nodes within\n+        /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+        /// tree or hash map.\n         pub struct ItemLocalId { .. }\n     }\n }"}, {"sha": "93030c98f355929e158859aed879398c3533e534", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -132,25 +132,24 @@ pub enum ScopeData {\n     Remainder(FirstStatementIndex)\n }\n \n-/// Represents a subscope of `block` for a binding that is introduced\n-/// by `block.stmts[first_statement_index]`. Such subscopes represent\n-/// a suffix of the block. Note that each subscope does not include\n-/// the initializer expression, if any, for the statement indexed by\n-/// `first_statement_index`.\n-///\n-/// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n-///\n-/// * The subscope with `first_statement_index == 0` is scope of both\n-///   `a` and `b`; it does not include EXPR_1, but does include\n-///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n-///   but instead another `Scope` that encompasses the whole block,\n-///   e.g., `Scope::Node`.\n-///\n-/// * The subscope with `first_statement_index == 1` is scope of `c`,\n-///   and thus does not include EXPR_2, but covers the `...`.\n-\n newtype_index! {\n+    /// Represents a subscope of `block` for a binding that is introduced\n+    /// by `block.stmts[first_statement_index]`. Such subscopes represent\n+    /// a suffix of the block. Note that each subscope does not include\n+    /// the initializer expression, if any, for the statement indexed by\n+    /// `first_statement_index`.\n+    ///\n+    /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n+    ///\n+    /// * The subscope with `first_statement_index == 0` is scope of both\n+    ///   `a` and `b`; it does not include EXPR_1, but does include\n+    ///   everything after that first `let`. (If you want a scope that\n+    ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n+    ///   but instead another `Scope` that encompasses the whole block,\n+    ///   e.g., `Scope::Node`.\n+    ///\n+    /// * The subscope with `first_statement_index == 1` is scope of `c`,\n+    ///   and thus does not include EXPR_2, but covers the `...`.\n     pub struct FirstStatementIndex { .. }\n }\n "}, {"sha": "274721b45cba02ca5179ca7ca4c2f8b1b232dab7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -1892,9 +1892,11 @@ pub mod tls {\n         rayon_core::tlv::get()\n     }\n \n-    /// A thread local variable which stores a pointer to the current ImplicitCtxt\n     #[cfg(not(parallel_compiler))]\n-    thread_local!(static TLV: Cell<usize> = Cell::new(0));\n+    thread_local! {\n+        /// A thread local variable which stores a pointer to the current ImplicitCtxt.\n+        static TLV: Cell<usize> = Cell::new(0);\n+    }\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n@@ -2011,10 +2013,11 @@ pub mod tls {\n         })\n     }\n \n-    /// Stores a pointer to the GlobalCtxt if one is available.\n-    /// This is used to access the GlobalCtxt in the deadlock handler\n-    /// given to Rayon.\n-    scoped_thread_local!(pub static GCX_PTR: Lock<usize>);\n+    scoped_thread_local! {\n+        /// Stores a pointer to the GlobalCtxt if one is available.\n+        /// This is used to access the GlobalCtxt in the deadlock handler given to Rayon.\n+        pub static GCX_PTR: Lock<usize>\n+    }\n \n     /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n     /// This is used in the deadlock handler."}, {"sha": "1629f1dc6302ae718c59e334630cb058ba918868", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -1512,42 +1512,42 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-/// \"Universes\" are used during type- and trait-checking in the\n-/// presence of `for<..>` binders to control what sets of names are\n-/// visible. Universes are arranged into a tree: the root universe\n-/// contains names that are always visible. Each child then adds a new\n-/// set of names that are visible, in addition to those of its parent.\n-/// We say that the child universe \"extends\" the parent universe with\n-/// new names.\n-///\n-/// To make this more concrete, consider this program:\n-///\n-/// ```\n-/// struct Foo { }\n-/// fn bar<T>(x: T) {\n-///   let y: for<'a> fn(&'a u8, Foo) = ...;\n-/// }\n-/// ```\n-///\n-/// The struct name `Foo` is in the root universe U0. But the type\n-/// parameter `T`, introduced on `bar`, is in an extended universe U1\n-/// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n-/// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n-/// region `'a` is in a universe U2 that extends U1, because we can\n-/// name it inside the fn type but not outside.\n-///\n-/// Universes are used to do type- and trait-checking around these\n-/// \"forall\" binders (also called **universal quantification**). The\n-/// idea is that when, in the body of `bar`, we refer to `T` as a\n-/// type, we aren't referring to any type in particular, but rather a\n-/// kind of \"fresh\" type that is distinct from all other types we have\n-/// actually declared. This is called a **placeholder** type, and we\n-/// use universes to talk about this. In other words, a type name in\n-/// universe 0 always corresponds to some \"ground\" type that the user\n-/// declared, but a type name in a non-zero universe is a placeholder\n-/// type -- an idealized representative of \"types in general\" that we\n-/// use for checking generic functions.\n newtype_index! {\n+    /// \"Universes\" are used during type- and trait-checking in the\n+    /// presence of `for<..>` binders to control what sets of names are\n+    /// visible. Universes are arranged into a tree: the root universe\n+    /// contains names that are always visible. Each child then adds a new\n+    /// set of names that are visible, in addition to those of its parent.\n+    /// We say that the child universe \"extends\" the parent universe with\n+    /// new names.\n+    ///\n+    /// To make this more concrete, consider this program:\n+    ///\n+    /// ```\n+    /// struct Foo { }\n+    /// fn bar<T>(x: T) {\n+    ///   let y: for<'a> fn(&'a u8, Foo) = ...;\n+    /// }\n+    /// ```\n+    ///\n+    /// The struct name `Foo` is in the root universe U0. But the type\n+    /// parameter `T`, introduced on `bar`, is in an extended universe U1\n+    /// -- i.e., within `bar`, we can name both `T` and `Foo`, but outside\n+    /// of `bar`, we cannot name `T`. Then, within the type of `y`, the\n+    /// region `'a` is in a universe U2 that extends U1, because we can\n+    /// name it inside the fn type but not outside.\n+    ///\n+    /// Universes are used to do type- and trait-checking around these\n+    /// \"forall\" binders (also called **universal quantification**). The\n+    /// idea is that when, in the body of `bar`, we refer to `T` as a\n+    /// type, we aren't referring to any type in particular, but rather a\n+    /// kind of \"fresh\" type that is distinct from all other types we have\n+    /// actually declared. This is called a **placeholder** type, and we\n+    /// use universes to talk about this. In other words, a type name in\n+    /// universe 0 always corresponds to some \"ground\" type that the user\n+    /// declared, but a type name in a non-zero universe is a placeholder\n+    /// type -- an idealized representative of \"types in general\" that we\n+    /// use for checking generic functions.\n     pub struct UniverseIndex {\n         DEBUG_FORMAT = \"U{}\",\n     }"}, {"sha": "95148834e01cc42bc59535e774af721569cde5dd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -1082,46 +1082,46 @@ impl<'a, 'gcx, 'tcx> ParamConst {\n     }\n }\n \n-/// A [De Bruijn index][dbi] is a standard means of representing\n-/// regions (and perhaps later types) in a higher-ranked setting. In\n-/// particular, imagine a type like this:\n-///\n-///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-///     ^          ^            |        |         |\n-///     |          |            |        |         |\n-///     |          +------------+ 0      |         |\n-///     |                                |         |\n-///     +--------------------------------+ 1       |\n-///     |                                          |\n-///     +------------------------------------------+ 0\n-///\n-/// In this type, there are two binders (the outer fn and the inner\n-/// fn). We need to be able to determine, for any given region, which\n-/// fn type it is bound by, the inner or the outer one. There are\n-/// various ways you can do this, but a De Bruijn index is one of the\n-/// more convenient and has some nice properties. The basic idea is to\n-/// count the number of binders, inside out. Some examples should help\n-/// clarify what I mean.\n-///\n-/// Let's start with the reference type `&'b isize` that is the first\n-/// argument to the inner function. This region `'b` is assigned a De\n-/// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n-/// fn). The region `'a` that appears in the second argument type (`&'a\n-/// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n-/// second-innermost binder\". (These indices are written on the arrays\n-/// in the diagram).\n-///\n-/// What is interesting is that De Bruijn index attached to a particular\n-/// variable will vary depending on where it appears. For example,\n-/// the final type `&'a char` also refers to the region `'a` declared on\n-/// the outermost fn. But this time, this reference is not nested within\n-/// any other binders (i.e., it is not an argument to the inner fn, but\n-/// rather the outer one). Therefore, in this case, it is assigned a\n-/// De Bruijn index of 0, because the innermost binder in that location\n-/// is the outer fn.\n-///\n-/// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n newtype_index! {\n+    /// A [De Bruijn index][dbi] is a standard means of representing\n+    /// regions (and perhaps later types) in a higher-ranked setting. In\n+    /// particular, imagine a type like this:\n+    ///\n+    ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n+    ///     ^          ^            |        |         |\n+    ///     |          |            |        |         |\n+    ///     |          +------------+ 0      |         |\n+    ///     |                                |         |\n+    ///     +--------------------------------+ 1       |\n+    ///     |                                          |\n+    ///     +------------------------------------------+ 0\n+    ///\n+    /// In this type, there are two binders (the outer fn and the inner\n+    /// fn). We need to be able to determine, for any given region, which\n+    /// fn type it is bound by, the inner or the outer one. There are\n+    /// various ways you can do this, but a De Bruijn index is one of the\n+    /// more convenient and has some nice properties. The basic idea is to\n+    /// count the number of binders, inside out. Some examples should help\n+    /// clarify what I mean.\n+    ///\n+    /// Let's start with the reference type `&'b isize` that is the first\n+    /// argument to the inner function. This region `'b` is assigned a De\n+    /// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n+    /// fn). The region `'a` that appears in the second argument type (`&'a\n+    /// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n+    /// second-innermost binder\". (These indices are written on the arrays\n+    /// in the diagram).\n+    ///\n+    /// What is interesting is that De Bruijn index attached to a particular\n+    /// variable will vary depending on where it appears. For example,\n+    /// the final type `&'a char` also refers to the region `'a` declared on\n+    /// the outermost fn. But this time, this reference is not nested within\n+    /// any other binders (i.e., it is not an argument to the inner fn, but\n+    /// rather the outer one). Therefore, in this case, it is assigned a\n+    /// De Bruijn index of 0, because the innermost binder in that location\n+    /// is the outer fn.\n+    ///\n+    /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n     pub struct DebruijnIndex {\n         DEBUG_FORMAT = \"DebruijnIndex({})\",\n         const INNERMOST = 0,"}, {"sha": "1153c3e79bfd554c1af4b9cdd1c73433224a6030", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -58,9 +58,10 @@ macro_rules! newtype_index {\n     // ---- public rules ----\n \n     // Use default constants\n-    ($v:vis struct $name:ident { .. }) => (\n+    ($(#[$attrs:meta])* $v:vis struct $name:ident { .. }) => (\n         newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n+            @attrs        [$(#[$attrs])*]\n             @type         [$name]\n             // shave off 256 indices at the end to allow space for packing these indices into enums\n             @max          [0xFFFF_FF00]\n@@ -69,9 +70,10 @@ macro_rules! newtype_index {\n     );\n \n     // Define any constants\n-    ($v:vis struct $name:ident { $($tokens:tt)+ }) => (\n+    ($(#[$attrs:meta])* $v:vis struct $name:ident { $($tokens:tt)+ }) => (\n         newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n+            @attrs        [$(#[$attrs])*]\n             @type         [$name]\n             // shave off 256 indices at the end to allow space for packing these indices into enums\n             @max          [0xFFFF_FF00]\n@@ -84,10 +86,12 @@ macro_rules! newtype_index {\n \n     // Base case, user-defined constants (if any) have already been defined\n     (@derives      [$($derives:ident,)*]\n+     @attrs        [$(#[$attrs:meta])*]\n      @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]) => (\n+        $(#[$attrs])*\n         #[derive(Copy, PartialEq, Eq, Hash, PartialOrd, Ord, $($derives),*)]\n         #[rustc_layout_scalar_valid_range_end($max)]\n         $v struct $type {\n@@ -317,14 +321,16 @@ macro_rules! newtype_index {\n \n     // By not including the @derives marker in this list nor in the default args, we can force it\n     // to come first if it exists. When encodable isn't custom, add serialization traits by default.\n-    (@type         [$type:ident]\n+    (@attrs        [$(#[$attrs:meta])*]\n+     @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]\n                    derive [$($derives:ident,)+]\n                    $($tokens:tt)*) => (\n         newtype_index!(\n             @derives      [$($derives,)+ RustcEncodable,]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -335,14 +341,16 @@ macro_rules! newtype_index {\n \n     // The case where no derives are added, but encodable is overridden. Don't\n     // derive serialization traits\n-    (@type         [$type:ident]\n+    (@attrs        [$(#[$attrs:meta])*]\n+     @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]\n                    ENCODABLE = custom\n                    $($tokens:tt)*) => (\n         newtype_index!(\n             @derives      []\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -351,13 +359,15 @@ macro_rules! newtype_index {\n     );\n \n     // The case where no derives are added, add serialization derives by default\n-    (@type         [$type:ident]\n+    (@attrs        [$(#[$attrs:meta])*]\n+     @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]\n                    $($tokens:tt)*) => (\n         newtype_index!(\n             @derives      [RustcEncodable,]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -384,13 +394,15 @@ macro_rules! newtype_index {\n \n     // Rewrite final without comma to one that includes comma\n     (@derives      [$($derives:ident,)*]\n+     @attrs        [$(#[$attrs:meta])*]\n      @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]\n                    $name:ident = $constant:expr) => (\n         newtype_index!(\n             @derives      [$($derives,)*]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -400,6 +412,7 @@ macro_rules! newtype_index {\n \n     // Rewrite final const without comma to one that includes comma\n     (@derives      [$($derives:ident,)*]\n+     @attrs        [$(#[$attrs:meta])*]\n      @type         [$type:ident]\n      @max          [$_max:expr]\n      @vis          [$v:vis]\n@@ -408,6 +421,7 @@ macro_rules! newtype_index {\n                    const $name:ident = $constant:expr) => (\n         newtype_index!(\n             @derives      [$($derives,)*]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -417,6 +431,7 @@ macro_rules! newtype_index {\n \n     // Replace existing default for max\n     (@derives      [$($derives:ident,)*]\n+     @attrs        [$(#[$attrs:meta])*]\n      @type         [$type:ident]\n      @max          [$_max:expr]\n      @vis          [$v:vis]\n@@ -425,6 +440,7 @@ macro_rules! newtype_index {\n                    $($tokens:tt)*) => (\n         newtype_index!(\n             @derives      [$($derives,)*]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -434,6 +450,7 @@ macro_rules! newtype_index {\n \n     // Replace existing default for debug_format\n     (@derives      [$($derives:ident,)*]\n+     @attrs        [$(#[$attrs:meta])*]\n      @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n@@ -442,6 +459,7 @@ macro_rules! newtype_index {\n                    $($tokens:tt)*) => (\n         newtype_index!(\n             @derives      [$($derives,)*]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n@@ -451,6 +469,7 @@ macro_rules! newtype_index {\n \n     // Assign a user-defined constant\n     (@derives      [$($derives:ident,)*]\n+     @attrs        [$(#[$attrs:meta])*]\n      @type         [$type:ident]\n      @max          [$max:expr]\n      @vis          [$v:vis]\n@@ -462,6 +481,7 @@ macro_rules! newtype_index {\n         pub const $name: $type = $type::from_u32_const($constant);\n         newtype_index!(\n             @derives      [$($derives,)*]\n+            @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]"}, {"sha": "7a7c49e46042807254be6805529bc44d0cf2656e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 65, "deletions": 11, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -36,7 +36,7 @@ use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::ast::Expr;\n-use syntax::attr;\n+use syntax::attr::{self, HasAttrs};\n use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n@@ -802,27 +802,81 @@ impl LintPass for UnusedDocComment {\n }\n \n impl UnusedDocComment {\n-    fn warn_if_doc<'a, 'tcx,\n-                   I: Iterator<Item=&'a ast::Attribute>,\n-                   C: LintContext<'tcx>>(&self, mut attrs: I, cx: &C) {\n-        if let Some(attr) = attrs.find(|a| a.is_value_str() && a.check_name(\"doc\")) {\n-            cx.struct_span_lint(UNUSED_DOC_COMMENTS, attr.span, \"doc comment not used by rustdoc\")\n-              .emit();\n+    fn warn_if_doc(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        node_span: Span,\n+        node_kind: &str,\n+        is_macro_expansion: bool,\n+        attrs: &[ast::Attribute]\n+    ) {\n+        let mut attrs = attrs.into_iter().peekable();\n+\n+        // Accumulate a single span for sugared doc comments.\n+        let mut sugared_span: Option<Span> = None;\n+\n+        while let Some(attr) = attrs.next() {\n+            if attr.is_sugared_doc {\n+                sugared_span = Some(\n+                    sugared_span.map_or_else(\n+                        || attr.span,\n+                        |span| span.with_hi(attr.span.hi()),\n+                    ),\n+                );\n+            }\n+\n+            if attrs.peek().map(|next_attr| next_attr.is_sugared_doc).unwrap_or_default() {\n+                continue;\n+            }\n+\n+            let span = sugared_span.take().unwrap_or_else(|| attr.span);\n+\n+            if attr.name() == \"doc\" {\n+                let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n+\n+                err.span_label(\n+                    node_span,\n+                    format!(\"rustdoc does not generate documentation for {}\", node_kind)\n+                );\n+\n+                if is_macro_expansion {\n+                    err.help(\"to document an item produced by a macro, \\\n+                              the macro must produce the documentation as part of its expansion\");\n+                }\n+\n+                err.emit();\n+            }\n         }\n     }\n }\n \n impl EarlyLintPass for UnusedDocComment {\n-    fn check_local(&mut self, cx: &EarlyContext<'_>, decl: &ast::Local) {\n-        self.warn_if_doc(decl.attrs.iter(), cx);\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        if let ast::ItemKind::Mac(..) = item.node {\n+            self.warn_if_doc(cx, item.span, \"macro expansions\", true, &item.attrs);\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n+        let (kind, is_macro_expansion) = match stmt.node {\n+            ast::StmtKind::Local(..) => (\"statements\", false),\n+            ast::StmtKind::Item(..) => (\"inner items\", false),\n+            ast::StmtKind::Mac(..) => (\"macro expansions\", true),\n+            // expressions will be reported by `check_expr`.\n+            ast::StmtKind::Semi(..) |\n+            ast::StmtKind::Expr(..) => return,\n+        };\n+\n+        self.warn_if_doc(cx, stmt.span, kind, is_macro_expansion, stmt.node.attrs());\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        self.warn_if_doc(arm.attrs.iter(), cx);\n+        let arm_span = arm.pats[0].span.with_hi(arm.body.span.hi());\n+        self.warn_if_doc(cx, arm_span, \"match arms\", false, &arm.attrs);\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-        self.warn_if_doc(expr.attrs.iter(), cx);\n+        self.warn_if_doc(cx, expr.span, \"expressions\", false, &expr.attrs);\n     }\n }\n "}, {"sha": "5e375dcaa068173a416f748edc241d2a5e6a397e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -66,6 +66,7 @@ macro_rules! pre_expansion_lint_passes {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n             KeywordIdents: KeywordIdents,\n+            UnusedDocComment: UnusedDocComment,\n         ]);\n     )\n }\n@@ -77,7 +78,6 @@ macro_rules! early_lint_passes {\n             UnusedImportBraces: UnusedImportBraces,\n             UnsafeCode: UnsafeCode,\n             AnonymousParameters: AnonymousParameters,\n-            UnusedDocComment: UnusedDocComment,\n             EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns,\n             NonCamelCaseTypes: NonCamelCaseTypes,\n             DeprecatedAttr: DeprecatedAttr::new(),"}, {"sha": "2101447965a15f705d92b5a89a40dfdca51204fe", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -116,14 +116,14 @@ impl RegionValueElements {\n     }\n }\n \n-/// A single integer representing a `Location` in the MIR control-flow\n-/// graph. Constructed efficiently from `RegionValueElements`.\n newtype_index! {\n+    /// A single integer representing a `Location` in the MIR control-flow\n+    /// graph. Constructed efficiently from `RegionValueElements`.\n     pub struct PointIndex { DEBUG_FORMAT = \"PointIndex({})\" }\n }\n \n-/// A single integer representing a `ty::Placeholder`.\n newtype_index! {\n+    /// A single integer representing a `ty::Placeholder`.\n     pub struct PlaceholderIndex { DEBUG_FORMAT = \"PlaceholderIndex({})\" }\n }\n "}, {"sha": "97f84675f94bf19d540efc7cbed7cbc84fc6bb4e", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -23,7 +23,7 @@ pub(crate) mod indexes {\n     use rustc_data_structures::indexed_vec::Idx;\n \n     macro_rules! new_index {\n-        ($Index:ident, $debug_name:expr) => {\n+        ($(#[$attrs:meta])* $Index:ident, $debug_name:expr) => {\n             #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n             pub struct $Index(NonZeroUsize);\n \n@@ -44,17 +44,29 @@ pub(crate) mod indexes {\n         }\n     }\n \n-    /// Index into MovePathData.move_paths\n-    new_index!(MovePathIndex, \"mp\");\n-\n-    /// Index into MoveData.moves.\n-    new_index!(MoveOutIndex, \"mo\");\n-\n-    /// Index into MoveData.inits.\n-    new_index!(InitIndex, \"in\");\n-\n-    /// Index into Borrows.locations\n-    new_index!(BorrowIndex, \"bw\");\n+    new_index!(\n+        /// Index into MovePathData.move_paths\n+        MovePathIndex,\n+        \"mp\"\n+    );\n+\n+    new_index!(\n+        /// Index into MoveData.moves.\n+        MoveOutIndex,\n+        \"mo\"\n+    );\n+\n+    new_index!(\n+        /// Index into MoveData.inits.\n+        InitIndex,\n+        \"in\"\n+    );\n+\n+    new_index!(\n+        /// Index into Borrows.locations\n+        BorrowIndex,\n+        \"bw\"\n+    );\n }\n \n pub use self::indexes::MovePathIndex;"}, {"sha": "d53a294fa6a9e8a16ceb8519e66a1664672f03d3", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -11,15 +11,15 @@ use crate::sys::stdio;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n \n-/// Stdout used by print! and println! macros\n thread_local! {\n+    /// Stdout used by print! and println! macros\n     static LOCAL_STDOUT: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n-/// Stderr used by eprint! and eprintln! macros, and panics\n thread_local! {\n+    /// Stderr used by eprint! and eprintln! macros, and panics\n     static LOCAL_STDERR: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }"}, {"sha": "7d2e5ab6f2b7f673a0fde4a2ae765c3c7066a433", "filename": "src/test/ui/useless_comment.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Ftest%2Fui%2Fuseless_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Ftest%2Fui%2Fuseless_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuseless_comment.rs?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -1,18 +1,43 @@\n+#![feature(stmt_expr_attributes)]\n+\n #![deny(unused_doc_comments)]\n \n+macro_rules! mac {\n+    () => {}\n+}\n+\n+/// foo //~ ERROR unused doc comment\n+mac!();\n+\n fn foo() {\n-    /// a //~ ERROR doc comment not used by rustdoc\n+    /// a //~ ERROR unused doc comment\n     let x = 12;\n \n-    /// b //~ doc comment not used by rustdoc\n+    /// multi-line //~ unused doc comment\n+    /// doc comment\n+    /// that is unused\n     match x {\n-        /// c //~ ERROR doc comment not used by rustdoc\n+        /// c //~ ERROR unused doc comment\n         1 => {},\n         _ => {}\n     }\n \n-    /// foo //~ ERROR doc comment not used by rustdoc\n+    /// foo //~ ERROR unused doc comment\n     unsafe {}\n+\n+    #[doc = \"foo\"] //~ ERROR unused doc comment\n+    #[doc = \"bar\"] //~ ERROR unused doc comment\n+    3;\n+\n+    /// bar //~ ERROR unused doc comment\n+    mac!();\n+\n+    let x = /** comment */ 47; //~ ERROR unused doc comment\n+\n+    /// dox //~ ERROR unused doc comment\n+    {\n+\n+    }\n }\n \n fn main() {"}, {"sha": "0742a844b7f4026ac15d87439672578556cabe64", "filename": "src/test/ui/useless_comment.stderr", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Ftest%2Fui%2Fuseless_comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b8898cfb0392f534cc25808a7f6caad36ebbb7/src%2Ftest%2Fui%2Fuseless_comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuseless_comment.stderr?ref=e1b8898cfb0392f534cc25808a7f6caad36ebbb7", "patch": "@@ -1,32 +1,98 @@\n-error: doc comment not used by rustdoc\n-  --> $DIR/useless_comment.rs:4:5\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:9:1\n    |\n-LL |     /// a //~ ERROR doc comment not used by rustdoc\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | /// foo //~ ERROR unused doc comment\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | mac!();\n+   | ------- rustdoc does not generate documentation for macro expansions\n    |\n note: lint level defined here\n-  --> $DIR/useless_comment.rs:1:9\n+  --> $DIR/useless_comment.rs:3:9\n    |\n LL | #![deny(unused_doc_comments)]\n    |         ^^^^^^^^^^^^^^^^^^^\n+   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion\n \n-error: doc comment not used by rustdoc\n-  --> $DIR/useless_comment.rs:7:5\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:13:5\n    |\n-LL |     /// b //~ doc comment not used by rustdoc\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     /// a //~ ERROR unused doc comment\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let x = 12;\n+   |     ----------- rustdoc does not generate documentation for statements\n \n-error: doc comment not used by rustdoc\n-  --> $DIR/useless_comment.rs:9:9\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:16:5\n    |\n-LL |         /// c //~ ERROR doc comment not used by rustdoc\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | /     /// multi-line //~ unused doc comment\n+LL | |     /// doc comment\n+LL | |     /// that is unused\n+   | |______________________^\n+LL | /     match x {\n+LL | |         /// c //~ ERROR unused doc comment\n+LL | |         1 => {},\n+LL | |         _ => {}\n+LL | |     }\n+   | |_____- rustdoc does not generate documentation for expressions\n \n-error: doc comment not used by rustdoc\n-  --> $DIR/useless_comment.rs:14:5\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:20:9\n    |\n-LL |     /// foo //~ ERROR doc comment not used by rustdoc\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         /// c //~ ERROR unused doc comment\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         1 => {},\n+   |         ------- rustdoc does not generate documentation for match arms\n \n-error: aborting due to 4 previous errors\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:25:5\n+   |\n+LL |     /// foo //~ ERROR unused doc comment\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {}\n+   |     --------- rustdoc does not generate documentation for expressions\n+\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:28:5\n+   |\n+LL |     #[doc = \"foo\"] //~ ERROR unused doc comment\n+   |     ^^^^^^^^^^^^^^\n+LL |     #[doc = \"bar\"] //~ ERROR unused doc comment\n+LL |     3;\n+   |     - rustdoc does not generate documentation for expressions\n+\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:29:5\n+   |\n+LL |     #[doc = \"bar\"] //~ ERROR unused doc comment\n+   |     ^^^^^^^^^^^^^^\n+LL |     3;\n+   |     - rustdoc does not generate documentation for expressions\n+\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:32:5\n+   |\n+LL |     /// bar //~ ERROR unused doc comment\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     mac!();\n+   |     ------- rustdoc does not generate documentation for macro expansions\n+   |\n+   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion\n+\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:35:13\n+   |\n+LL |     let x = /** comment */ 47; //~ ERROR unused doc comment\n+   |             ^^^^^^^^^^^^^^ -- rustdoc does not generate documentation for expressions\n+\n+error: unused doc comment\n+  --> $DIR/useless_comment.rs:37:5\n+   |\n+LL |       /// dox //~ ERROR unused doc comment\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | /     {\n+LL | |\n+LL | |     }\n+   | |_____- rustdoc does not generate documentation for expressions\n+\n+error: aborting due to 10 previous errors\n "}]}