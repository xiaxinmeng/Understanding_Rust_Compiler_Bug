{"sha": "b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MDQxYmZhYjNhODM3MDJhODAyNmZiN2ExOGQ4ZWE3ZDU0Y2M2NDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-29T22:35:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-29T22:35:23Z"}, "message": "Auto merge of #44174 - jimmycuadra:try-from-infallible, r=sfackler\n\nAdd blanket TryFrom impl when From is implemented.\n\nAdds `impl<T, U> TryFrom<T> for U where U: From<T>`.\n\nRemoves `impl<'a, T> TryFrom<&'a str> for T where T: FromStr` (originally added in #40281) due to overlapping impls caused by the new blanket impl. This removal is to be discussed further on the tracking issue for TryFrom.\n\nRefs #33417.\n\n/cc @sfackler, @scottmcm (thank you for the help!), and @aturon", "tree": {"sha": "7f22fe35983186a4d48ea90d70c6461d11ef1269", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f22fe35983186a4d48ea90d70c6461d11ef1269"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "html_url": "https://github.com/rust-lang/rust/commit/b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f87d20a7cce70b8cc59a1adf3037d14bc83f237", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f87d20a7cce70b8cc59a1adf3037d14bc83f237", "html_url": "https://github.com/rust-lang/rust/commit/6f87d20a7cce70b8cc59a1adf3037d14bc83f237"}, {"sha": "27d95d3645761252caf42c77fc53b76b4278520a", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d95d3645761252caf42c77fc53b76b4278520a", "html_url": "https://github.com/rust-lang/rust/commit/27d95d3645761252caf42c77fc53b76b4278520a"}], "stats": {"total": 119, "additions": 71, "deletions": 48}, "files": [{"sha": "e815d72d366466e79d3b3507c36585afeca5cb28", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -48,8 +48,25 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use str::FromStr;\n+use fmt;\n \n+/// A type used as the error type for implementations of fallible conversion\n+/// traits in cases where conversions cannot actually fail.\n+///\n+/// Because `Infallible` has no variants, a value of this type can never exist.\n+/// It is used only to satisfy trait signatures that expect an error type, and\n+/// signals to both the compiler and the user that the error case is impossible.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub enum Infallible {}\n+\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl fmt::Display for Infallible {\n+    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+        }\n+    }\n+}\n /// A cheap reference-to-reference conversion. Used to convert a value to a\n /// reference value within generic code.\n ///\n@@ -417,6 +434,17 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n     }\n }\n \n+// Infallible conversions are semantically equivalent to fallible conversions\n+// with an uninhabited error type.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl<T, U> TryFrom<U> for T where T: From<U> {\n+    type Error = Infallible;\n+\n+    fn try_from(value: U) -> Result<Self, Self::Error> {\n+        Ok(T::from(value))\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // CONCRETE IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n@@ -442,14 +470,3 @@ impl AsRef<str> for str {\n         self\n     }\n }\n-\n-// FromStr implies TryFrom<&str>\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl<'a, T> TryFrom<&'a str> for T where T: FromStr\n-{\n-    type Error = <T as FromStr>::Err;\n-\n-    fn try_from(s: &'a str) -> Result<T, Self::Error> {\n-        FromStr::from_str(s)\n-    }\n-}"}, {"sha": "e9aee4a4676de47fda7282106908e79d3d80b430", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -89,6 +89,7 @@ macro_rules! step_impl_unsigned {\n             }\n \n             #[inline]\n+            #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n                 match <$t>::try_from(n) {\n                     Ok(n_as_t) => self.checked_add(n_as_t),\n@@ -120,6 +121,7 @@ macro_rules! step_impl_signed {\n             }\n \n             #[inline]\n+            #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n                 match <$unsigned>::try_from(n) {\n                     Ok(n_as_unsigned) => {"}, {"sha": "85be8a08728e519fca43789b6eb7fb94986087aa", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -12,7 +12,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::TryFrom;\n+use convert::{Infallible, TryFrom};\n use fmt;\n use intrinsics;\n use str::FromStr;\n@@ -2507,16 +2507,24 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl From<Infallible> for TryFromIntError {\n+    fn from(infallible: Infallible) -> TryFromIntError {\n+        match infallible {\n+        }\n+    }\n+}\n+\n // no possible bounds violation\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n+            type Error = Infallible;\n \n             #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                Ok(u as $target)\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n             }\n         }\n     )*}\n@@ -2588,31 +2596,17 @@ macro_rules! rev {\n }\n \n /// intra-sign conversions\n-try_from_unbounded!(u8, u8, u16, u32, u64, u128);\n-try_from_unbounded!(u16, u16, u32, u64, u128);\n-try_from_unbounded!(u32, u32, u64, u128);\n-try_from_unbounded!(u64, u64, u128);\n-try_from_unbounded!(u128, u128);\n try_from_upper_bounded!(u16, u8);\n try_from_upper_bounded!(u32, u16, u8);\n try_from_upper_bounded!(u64, u32, u16, u8);\n try_from_upper_bounded!(u128, u64, u32, u16, u8);\n \n-try_from_unbounded!(i8, i8, i16, i32, i64, i128);\n-try_from_unbounded!(i16, i16, i32, i64, i128);\n-try_from_unbounded!(i32, i32, i64, i128);\n-try_from_unbounded!(i64, i64, i128);\n-try_from_unbounded!(i128, i128);\n try_from_both_bounded!(i16, i8);\n try_from_both_bounded!(i32, i16, i8);\n try_from_both_bounded!(i64, i32, i16, i8);\n try_from_both_bounded!(i128, i64, i32, i16, i8);\n \n // unsigned-to-signed\n-try_from_unbounded!(u8, i16, i32, i64, i128);\n-try_from_unbounded!(u16, i32, i64, i128);\n-try_from_unbounded!(u32, i64, i128);\n-try_from_unbounded!(u64, i128);\n try_from_upper_bounded!(u8, i8);\n try_from_upper_bounded!(u16, i8, i16);\n try_from_upper_bounded!(u32, i8, i16, i32);\n@@ -2631,15 +2625,13 @@ try_from_both_bounded!(i64, u32, u16, u8);\n try_from_both_bounded!(i128, u64, u32, u16, u8);\n \n // usize/isize\n-try_from_unbounded!(usize, usize);\n try_from_upper_bounded!(usize, isize);\n try_from_lower_bounded!(isize, usize);\n-try_from_unbounded!(isize, isize);\n \n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8);\n     try_from_unbounded!(usize, u16, u32, u64, u128);\n@@ -2651,21 +2643,21 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8);\n     try_from_unbounded!(isize, i16, i32, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16);\n+    rev!(try_from_unbounded, usize, u16);\n     rev!(try_from_upper_bounded, usize, u32, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16);\n     rev!(try_from_both_bounded, usize, i32, i64, i128);\n \n     rev!(try_from_unbounded, isize, u8);\n     rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16);\n+    rev!(try_from_unbounded, isize, i16);\n     rev!(try_from_both_bounded, isize, i32, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8, u16);\n     try_from_unbounded!(usize, u32, u64, u128);\n@@ -2677,21 +2669,21 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8, i16);\n     try_from_unbounded!(isize, i32, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16, u32);\n+    rev!(try_from_unbounded, usize, u16, u32);\n     rev!(try_from_upper_bounded, usize, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n     rev!(try_from_both_bounded, usize, i64, i128);\n \n     rev!(try_from_unbounded, isize, u8, u16);\n     rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16, i32);\n+    rev!(try_from_unbounded, isize, i16, i32);\n     rev!(try_from_both_bounded, isize, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8, u16, u32);\n     try_from_unbounded!(usize, u64, u128);\n@@ -2703,14 +2695,14 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8, i16, i32);\n     try_from_unbounded!(isize, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16, u32, u64);\n+    rev!(try_from_unbounded, usize, u16, u32, u64);\n     rev!(try_from_upper_bounded, usize, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n     rev!(try_from_both_bounded, usize, i128);\n \n     rev!(try_from_unbounded, isize, u8, u16, u32);\n     rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16, i32, i64);\n+    rev!(try_from_unbounded, isize, i16, i32, i64);\n     rev!(try_from_both_bounded, isize, i128);\n }\n "}, {"sha": "0af9fcf0a3d3bcaecff2efa11661721fb77a75c3", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -18,7 +18,6 @@ use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n-use convert::TryFrom;\n use fmt;\n use iter::{Map, Cloned, FusedIterator, TrustedLen};\n use iter_private::TrustedRandomAccess;\n@@ -2198,7 +2197,7 @@ pub trait StrExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_empty(&self) -> bool;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn parse<'a, T: TryFrom<&'a str>>(&'a self) -> Result<T, T::Error>;\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n // truncate `&str` to length at most equal to `max`\n@@ -2518,9 +2517,7 @@ impl StrExt for str {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n \n     #[inline]\n-    fn parse<'a, T>(&'a self) -> Result<T, T::Error> where T: TryFrom<&'a str> {\n-        T::try_from(self)\n-    }\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4e10ceac878b6a4c5669d49a2b7fd9838efb4ca8", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -32,7 +32,6 @@ fn test_convert() {\n #[test]\n fn test_from_str() {\n     assert_eq!(char::from_str(\"a\").unwrap(), 'a');\n-    assert_eq!(char::try_from(\"a\").unwrap(), 'a');\n     assert_eq!(char::from_str(\"\\0\").unwrap(), '\\0');\n     assert_eq!(char::from_str(\"\\u{D7FF}\").unwrap(), '\\u{d7FF}');\n     assert!(char::from_str(\"\").is_err());"}, {"sha": "7eb5ff988577766058c656e5d681f40319792448", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::convert::TryFrom;\n+use core::convert::{TryFrom, TryInto};\n use core::cmp::PartialEq;\n use core::fmt::Debug;\n use core::marker::Copy;\n+use core::num::TryFromIntError;\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::option::Option;\n use core::option::Option::{Some, None};\n@@ -134,6 +135,13 @@ fn test_empty() {\n     assert_eq!(\"\".parse::<u8>().ok(), None);\n }\n \n+#[test]\n+fn test_infallible_try_from_int_error() {\n+    let func = |x: i8| -> Result<i32, TryFromIntError> { Ok(x.try_into()?) };\n+\n+    assert!(func(0).is_ok());\n+}\n+\n macro_rules! test_impl_from {\n     ($fn_name: ident, $Small: ty, $Large: ty) => {\n         #[test]"}, {"sha": "166439692d4edd3d0f878b18bd5a5046eb23962d", "filename": "src/libstd/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7041bfab3a83702a8026fb7a18d8ea7d54cc648/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=b7041bfab3a83702a8026fb7a18d8ea7d54cc648", "patch": "@@ -56,6 +56,7 @@ use any::TypeId;\n use borrow::Cow;\n use cell;\n use char;\n+use convert;\n use fmt::{self, Debug, Display};\n use mem::transmute;\n use num;\n@@ -362,6 +363,13 @@ impl Error for char::ParseCharError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl Error for convert::Infallible {\n+    fn description(&self) -> &str {\n+        match *self {\n+        }\n+    }\n+}\n \n // copied from any.rs\n impl Error + 'static {"}]}