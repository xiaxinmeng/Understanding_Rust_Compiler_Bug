{"sha": "ea0d99829da705377b7b690062401f772f0babe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMGQ5OTgyOWRhNzA1Mzc3YjdiNjkwMDYyNDAxZjc3MmYwYmFiZTg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-05T15:50:55Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-07T14:02:17Z"}, "message": "Add resolution errors for const generics\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "c9e0dcb2d39dc8ff020d0912ecb59e91b46f7560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9e0dcb2d39dc8ff020d0912ecb59e91b46f7560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea0d99829da705377b7b690062401f772f0babe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0d99829da705377b7b690062401f772f0babe8", "html_url": "https://github.com/rust-lang/rust/commit/ea0d99829da705377b7b690062401f772f0babe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea0d99829da705377b7b690062401f772f0babe8/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4ef753e8f45a67f6756ad4c9103e0e327a1e078", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ef753e8f45a67f6756ad4c9103e0e327a1e078", "html_url": "https://github.com/rust-lang/rust/commit/b4ef753e8f45a67f6756ad4c9103e0e327a1e078"}], "stats": {"total": 178, "additions": 146, "deletions": 32}, "files": [{"sha": "934bb0f03c4f5fe2cfaf35ed448f57d11a464341", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 126, "deletions": 32, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d99829da705377b7b690062401f772f0babe8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d99829da705377b7b690062401f772f0babe8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ea0d99829da705377b7b690062401f772f0babe8", "patch": "@@ -51,6 +51,7 @@ use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generi\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::ParamKindOrd;\n use syntax::ptr::P;\n use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n@@ -142,10 +143,11 @@ impl Ord for BindingError {\n }\n \n enum ResolutionError<'a> {\n-    /// error E0401: can't use type parameters from outer function\n-    TypeParametersFromOuterFunction(Def),\n-    /// error E0403: the name is already used for a type parameter in this type parameter list\n-    NameAlreadyUsedInTypeParameterList(Name, &'a Span),\n+    /// error E0401: can't use type or const parameters from outer function\n+    ParametersFromOuterFunction(Def, ParamKindOrd),\n+    /// error E0403: the name is already used for a type/const parameter in this list of\n+    /// generic parameters\n+    NameAlreadyUsedInParameterList(Name, &'a Span),\n     /// error E0407: method is not a member of trait\n     MethodNotMemberOfTrait(Name, &'a str),\n     /// error E0437: type is not a member of trait\n@@ -177,7 +179,9 @@ enum ResolutionError<'a> {\n     /// error E0530: X bindings cannot shadow Ys\n     BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n     /// error E0128: type parameters with a default cannot use forward declared identifiers\n-    ForwardDeclaredTyParam,\n+    ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n+    /// error E0670: const parameter cannot depend on type parameter\n+    ConstParamDependentOnTypeParam,\n }\n \n /// Combines an error with provided span and emits it\n@@ -195,12 +199,14 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                    resolution_error: ResolutionError<'a>)\n                                    -> DiagnosticBuilder<'sess> {\n     match resolution_error {\n-        ResolutionError::TypeParametersFromOuterFunction(outer_def) => {\n+        ResolutionError::ParametersFromOuterFunction(outer_def, kind) => {\n             let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0401,\n-                                           \"can't use type parameters from outer function\");\n-            err.span_label(span, \"use of type variable from outer function\");\n+                span,\n+                E0401,\n+                \"can't use {} parameters from outer function\",\n+                kind,\n+            );\n+            err.span_label(span, format!(\"use of {} variable from outer function\", kind));\n \n             let cm = resolver.session.source_map();\n             match outer_def {\n@@ -224,20 +230,25 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                     }\n                     return err;\n                 },\n-                Def::TyParam(typaram_defid) => {\n-                    if let Some(typaram_span) = resolver.definitions.opt_span(typaram_defid) {\n-                        err.span_label(typaram_span, \"type variable from outer function\");\n+                Def::TyParam(def_id) => {\n+                    if let Some(span) = resolver.definitions.opt_span(def_id) {\n+                        err.span_label(span, \"type variable from outer function\");\n                     }\n-                },\n+                }\n+                Def::ConstParam(def_id) => {\n+                    if let Some(span) = resolver.definitions.opt_span(def_id) {\n+                        err.span_label(span, \"const variable from outer function\");\n+                    }\n+                }\n                 _ => {\n-                    bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy or \\\n-                         Def::TyParam\")\n+                    bug!(\"TypeParametersFromOuterFunction should only be used with Def::SelfTy, \\\n+                         Def::TyParam or Def::ConstParam\");\n                 }\n             }\n \n             // Try to retrieve the span of the function signature and generate a new message with\n-            // a local type parameter\n-            let sugg_msg = \"try using a local type parameter instead\";\n+            // a local type or const parameter.\n+            let sugg_msg = &format!(\"try using a local {} parameter instead\", kind);\n             if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n                 // Suggest the modification to the user\n                 err.span_suggestion(\n@@ -247,19 +258,20 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                     Applicability::MachineApplicable,\n                 );\n             } else if let Some(sp) = cm.generate_fn_name_span(span) {\n-                err.span_label(sp, \"try adding a local type parameter in this method instead\");\n+                err.span_label(sp,\n+                    format!(\"try adding a local {} parameter in this method instead\", kind));\n             } else {\n-                err.help(\"try using a local type parameter instead\");\n+                err.help(&format!(\"try using a local {} parameter instead\", kind));\n             }\n \n             err\n         }\n-        ResolutionError::NameAlreadyUsedInTypeParameterList(name, first_use_span) => {\n+        ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n              let mut err = struct_span_err!(resolver.session,\n                                             span,\n                                             E0403,\n-                                            \"the name `{}` is already used for a type parameter \\\n-                                            in this type parameter list\",\n+                                            \"the name `{}` is already used for a generic \\\n+                                            parameter in this list of generic parameters\",\n                                             name);\n              err.span_label(span, \"already used\");\n              err.span_label(first_use_span.clone(), format!(\"first use of `{}`\", name));\n@@ -416,6 +428,12 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                 span, \"defaulted type parameters cannot be forward declared\".to_string());\n             err\n         }\n+        ResolutionError::ConstParamDependentOnTypeParam => {\n+            let mut err = struct_span_err!(resolver.session, span, E0670,\n+                                           \"const parameters cannot depend on type parameters\");\n+            err.span_label(span, format!(\"const parameter depends on type parameter\"));\n+            err\n+        }\n     }\n }\n \n@@ -546,7 +564,7 @@ impl<'a> PathSource<'a> {\n                 Def::Struct(..) | Def::Union(..) | Def::Enum(..) |\n                 Def::Trait(..) | Def::TraitAlias(..) | Def::TyAlias(..) |\n                 Def::AssociatedTy(..) | Def::PrimTy(..) | Def::TyParam(..) |\n-                Def::SelfTy(..) | Def::Existential(..) |\n+                Def::SelfTy(..) | Def::Existential(..) | Def::ConstParam(..) |\n                 Def::ForeignTy(..) => true,\n                 _ => false,\n             },\n@@ -564,7 +582,7 @@ impl<'a> PathSource<'a> {\n                 Def::VariantCtor(_, CtorKind::Const) | Def::VariantCtor(_, CtorKind::Fn) |\n                 Def::Const(..) | Def::Static(..) | Def::Local(..) | Def::Upvar(..) |\n                 Def::Fn(..) | Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::SelfCtor(..) => true,\n+                Def::SelfCtor(..) | Def::ConstParam(..) => true,\n                 _ => false,\n             },\n             PathSource::Pat => match def {\n@@ -855,6 +873,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         self.label_ribs.pop();\n         self.ribs[ValueNS].pop();\n     }\n+\n     fn visit_generics(&mut self, generics: &'tcx Generics) {\n         // For type parameter defaults, we have to ban access\n         // to following type parameters, as the Substs can only\n@@ -865,6 +884,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         let mut found_default = false;\n         default_ban_rib.bindings.extend(generics.params.iter()\n             .filter_map(|param| match param.kind {\n+                GenericParamKind::Const { .. } |\n                 GenericParamKind::Lifetime { .. } => None,\n                 GenericParamKind::Type { ref default, .. } => {\n                     found_default |= default.is_some();\n@@ -876,6 +896,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 }\n             }));\n \n+        // We also ban access to type parameters for use as the types of const parameters.\n+        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n+        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n+            .filter(|param| if let GenericParamKind::Type { .. } = param.kind {\n+                true\n+            } else {\n+                false\n+            })\n+            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Def::Err)));\n+\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n@@ -893,6 +923,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     // Allow all following defaults to refer to this type parameter.\n                     default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n                 }\n+                GenericParamKind::Const { ref ty } => {\n+                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n+\n+                    for bound in &param.bounds {\n+                        self.visit_param_bound(bound);\n+                    }\n+\n+                    self.visit_ty(ty);\n+\n+                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+                }\n             }\n         }\n         for p in &generics.where_clause.predicates {\n@@ -944,6 +985,9 @@ enum RibKind<'a> {\n     /// from the default of a type parameter because they're not declared\n     /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n+\n+    /// We forbid the use of type parameters as the types of const parameters.\n+    TyParamAsConstParamTy,\n }\n \n /// One local scope.\n@@ -2535,7 +2579,7 @@ impl<'a> Resolver<'a> {\n \n                             if seen_bindings.contains_key(&ident) {\n                                 let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n                                     ident.name,\n                                     span,\n                                 );\n@@ -2548,6 +2592,24 @@ impl<'a> Resolver<'a> {\n                             function_type_rib.bindings.insert(ident, def);\n                             self.record_def(param.id, PathResolution::new(def));\n                         }\n+                        GenericParamKind::Const { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_type_parameter_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                                    ident.name,\n+                                    span,\n+                                );\n+                                resolve_error(self, param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+                            let def = Def::ConstParam(self.definitions.local_def_id(param.id));\n+                            function_type_rib.bindings.insert(ident, def);\n+                            self.record_def(param.id, PathResolution::new(def));\n+                        }\n                     }\n                 }\n                 self.ribs[TypeNS].push(function_type_rib);\n@@ -4106,6 +4168,15 @@ impl<'a> Resolver<'a> {\n             return Def::Err;\n         }\n \n+        // An invalid use of a type parameter as the type of a const parameter.\n+        if let TyParamAsConstParamTy = self.ribs[ns][rib_index].kind {\n+            if record_used {\n+                resolve_error(self, span, ResolutionError::ConstParamDependentOnTypeParam);\n+            }\n+            assert_eq!(def, Def::Err);\n+            return Def::Err;\n+        }\n+\n         match def {\n             Def::Upvar(..) => {\n                 span_bug!(span, \"unexpected {:?} in bindings\", def)\n@@ -4114,7 +4185,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n-                        ForwardTyParamBanRibKind => {\n+                        ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -4167,21 +4238,44 @@ impl<'a> Resolver<'a> {\n                     match rib.kind {\n                         NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n-                        ConstantItemRibKind => {\n+                        ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {\n-                            // This was an attempt to use a type parameter outside\n-                            // its scope.\n+                            // This was an attempt to use a type parameter outside its scope.\n                             if record_used {\n-                                resolve_error(self, span,\n-                                    ResolutionError::TypeParametersFromOuterFunction(def));\n+                                resolve_error(\n+                                    self,\n+                                    span,\n+                                    ResolutionError::ParametersFromOuterFunction(\n+                                        def,\n+                                        ParamKindOrd::Type,\n+                                    ),\n+                                );\n                             }\n                             return Def::Err;\n                         }\n                     }\n                 }\n             }\n+            Def::ConstParam(..) => {\n+                for rib in ribs {\n+                    if let ItemRibKind = rib.kind {\n+                        // This was an attempt to use a const parameter outside its scope.\n+                        if record_used {\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::ParametersFromOuterFunction(\n+                                    def,\n+                                    ParamKindOrd::Const,\n+                                ),\n+                            );\n+                        }\n+                        return Def::Err;\n+                    }\n+                }\n+            }\n             _ => {}\n         }\n         def"}, {"sha": "ab3883d2b9b9bfb065e09f6300f7427f6380484f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d99829da705377b7b690062401f772f0babe8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d99829da705377b7b690062401f772f0babe8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ea0d99829da705377b7b690062401f772f0babe8", "patch": "@@ -307,6 +307,26 @@ impl GenericBound {\n \n pub type GenericBounds = Vec<GenericBound>;\n \n+/// Specifies the enforced ordering for generic parameters. In the future,\n+/// if we wanted to relax this order, we could override `PartialEq` and\n+/// `PartialOrd`, to allow the kinds to be unordered.\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]\n+pub enum ParamKindOrd {\n+    Lifetime,\n+    Type,\n+    Const,\n+}\n+\n+impl fmt::Display for ParamKindOrd {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            ParamKindOrd::Lifetime => \"lifetime\".fmt(f),\n+            ParamKindOrd::Type => \"type\".fmt(f),\n+            ParamKindOrd::Const => \"const\".fmt(f),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`)."}]}