{"sha": "478a33dabc4e6f2f501f476c79b56178d9df4f37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OGEzM2RhYmM0ZTZmMmY1MDFmNDc2Yzc5YjU2MTc4ZDlkZjRmMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-19T12:00:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-19T12:00:10Z"}, "message": "Auto merge of #33002 - mitaa:rdoc-cross-impls, r=alexcrichton\n\nrustdoc: refine cross-crate impl inlining\n\nThis changes the current rule that impls within `doc(hidden)` modules aren't inlined, to only inlining impls where the implemented trait and type are reachable in documentation.\n\nfixes #14586\nfixes #31948\n\n.. and also applies the reachability checking to cross-crate links.\n\nfixes #28480\n\nr? @alexcrichton", "tree": {"sha": "a3c02c01a6d1b0eefbb5e28a932e6968b8fc9b14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3c02c01a6d1b0eefbb5e28a932e6968b8fc9b14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478a33dabc4e6f2f501f476c79b56178d9df4f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478a33dabc4e6f2f501f476c79b56178d9df4f37", "html_url": "https://github.com/rust-lang/rust/commit/478a33dabc4e6f2f501f476c79b56178d9df4f37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478a33dabc4e6f2f501f476c79b56178d9df4f37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8c0aeb88ba1e12d0c0a1d0ed7b4a90b44460a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c0aeb88ba1e12d0c0a1d0ed7b4a90b44460a29", "html_url": "https://github.com/rust-lang/rust/commit/e8c0aeb88ba1e12d0c0a1d0ed7b4a90b44460a29"}, {"sha": "77b409a674f62e3be13ec9339b5c8272c9b5c0a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/77b409a674f62e3be13ec9339b5c8272c9b5c0a9", "html_url": "https://github.com/rust-lang/rust/commit/77b409a674f62e3be13ec9339b5c8272c9b5c0a9"}], "stats": {"total": 601, "additions": 472, "deletions": 129}, "files": [{"sha": "c1a8f747de14d9823888a309505c960f8fab6ce0", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -113,6 +113,7 @@ pub enum InlinedItemRef<'a> {\n /// LOCAL_CRATE in their DefId.\n pub const LOCAL_CRATE: ast::CrateNum = 0;\n \n+#[derive(Copy, Clone)]\n pub struct ChildItem {\n     pub def: DefLike,\n     pub name: ast::Name,"}, {"sha": "478f662d0962a4646a9ae555f2bcca15abb7acb7", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -15,10 +15,11 @@\n use util::nodemap::{DefIdSet, FnvHashMap};\n \n use std::hash::Hash;\n+use std::fmt;\n use syntax::ast::NodeId;\n \n // Accessibility levels, sorted in ascending order\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum AccessLevel {\n     // Exported items + items participating in various kinds of public interfaces,\n     // but not directly nameable. For example, if function `fn f() -> T {...}` is\n@@ -56,6 +57,12 @@ impl<Id: Hash + Eq> Default for AccessLevels<Id> {\n     }\n }\n \n+impl<Id: Hash + Eq + fmt::Debug> fmt::Debug for AccessLevels<Id> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.map, f)\n+    }\n+}\n+\n /// A set containing all exported definitions from external crates.\n /// The set does not contain any entries from local crates.\n pub type ExternalExports = DefIdSet;"}, {"sha": "fd57a452e0aba395abc9e93a97f26a7abab06c78", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -26,9 +26,9 @@ use rustc::middle::stability;\n \n use rustc_const_eval::lookup_const_by_id;\n \n-use core::DocContext;\n+use core::{DocContext, DocAccessLevels};\n use doctree;\n-use clean::{self, Attributes, GetDefId};\n+use clean::{self, GetDefId};\n \n use super::{Clean, ToSource};\n \n@@ -116,7 +116,7 @@ fn try_inline_def(cx: &DocContext, tcx: &TyCtxt,\n         }\n         _ => return None,\n     };\n-    cx.inlined.borrow_mut().as_mut().unwrap().insert(did);\n+    cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(tcx.item_name(did).to_string()),\n@@ -146,7 +146,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n             elem.data.to_string()\n         });\n         let fqn = once(crate_name).chain(relative).collect();\n-        cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n+        cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n     }\n }\n \n@@ -260,11 +260,6 @@ pub fn build_impls(cx: &DocContext,\n             match def {\n                 cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n                 cstore::DlDef(Def::Mod(did)) => {\n-                    // Don't recurse if this is a #[doc(hidden)] module\n-                    if load_attrs(cx, tcx, did).list(\"doc\").has_word(\"hidden\") {\n-                        return;\n-                    }\n-\n                     for item in tcx.sess.cstore.item_children(did) {\n                         populate_impls(cx, tcx, item.def, impls)\n                     }\n@@ -295,16 +290,17 @@ pub fn build_impl(cx: &DocContext,\n                   tcx: &TyCtxt,\n                   did: DefId,\n                   ret: &mut Vec<clean::Item>) {\n-    if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n+    if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n \n     let attrs = load_attrs(cx, tcx, did);\n     let associated_trait = tcx.impl_trait_ref(did);\n-    if let Some(ref t) = associated_trait {\n-        // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n-        let trait_attrs = load_attrs(cx, tcx, t.def_id);\n-        if trait_attrs.list(\"doc\").has_word(\"hidden\") {\n+\n+    // Only inline impl if the implemented trait is\n+    // reachable in rustdoc generated documentation\n+    if let Some(traitref) = associated_trait {\n+        if !cx.access_levels.borrow().is_doc_reachable(traitref.def_id) {\n             return\n         }\n     }\n@@ -330,6 +326,17 @@ pub fn build_impl(cx: &DocContext,\n         });\n     }\n \n+    let ty = tcx.lookup_item_type(did);\n+    let for_ = ty.ty.clean(cx);\n+\n+    // Only inline impl if the implementing type is\n+    // reachable in rustdoc generated documentation\n+    if let Some(did) = for_.def_id() {\n+        if !cx.access_levels.borrow().is_doc_reachable(did) {\n+            return\n+        }\n+    }\n+\n     let predicates = tcx.lookup_predicates(did);\n     let trait_items = tcx.sess.cstore.impl_items(did)\n             .iter()\n@@ -412,7 +419,6 @@ pub fn build_impl(cx: &DocContext,\n         }\n     }).collect::<Vec<_>>();\n     let polarity = tcx.trait_impl_polarity(did);\n-    let ty = tcx.lookup_item_type(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n             clean::TraitBound(polyt, _) => polyt.trait_,\n@@ -436,7 +442,7 @@ pub fn build_impl(cx: &DocContext,\n             derived: clean::detect_derived(&attrs),\n             provided_trait_methods: provided,\n             trait_: trait_,\n-            for_: ty.ty.clean(cx),\n+            for_: for_,\n             generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n             items: trait_items,\n             polarity: polarity.map(|p| { p.clean(cx) }),"}, {"sha": "c9f40a1adae3209fb1d4a909a13f3d76f004a641", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -36,6 +36,7 @@ use syntax::ptr::P;\n \n use rustc_trans::back::link;\n use rustc::middle::cstore::{self, CrateStore};\n+use rustc::middle::privacy::AccessLevels;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n@@ -47,15 +48,17 @@ use rustc::hir;\n use std::collections::{HashMap, HashSet};\n use std::path::PathBuf;\n use std::rc::Rc;\n+use std::sync::Arc;\n use std::u32;\n use std::env::current_dir;\n+use std::mem;\n \n use core::DocContext;\n use doctree;\n use visit_ast;\n use html::item_type::ItemType;\n \n-mod inline;\n+pub mod inline;\n mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n@@ -113,13 +116,16 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Crate {\n     pub name: String,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n+    pub access_levels: Arc<AccessLevels<DefId>>,\n+    // These are later on moved into `CACHEKEY`, leaving the map empty.\n+    // Only here so that they can be filtered through the rustdoc passes.\n     pub external_traits: HashMap<DefId, Trait>,\n }\n \n@@ -128,14 +134,20 @@ struct CrateNum(ast::CrateNum);\n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n         use rustc::session::config::Input;\n+        use ::visit_lib::LibEmbargoVisitor;\n \n         if let Some(t) = cx.tcx_opt() {\n             cx.deref_trait_did.set(t.lang_items.deref_trait());\n+            cx.renderinfo.borrow_mut().deref_trait_did = cx.deref_trait_did.get();\n         }\n \n         let mut externs = Vec::new();\n         for cnum in cx.sess().cstore.crates() {\n             externs.push((cnum, CrateNum(cnum).clean(cx)));\n+            if cx.tcx_opt().is_some() {\n+                // Analyze doc-reachability for extern items\n+                LibEmbargoVisitor::new(cx).visit_lib(cnum);\n+            }\n         }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n@@ -205,14 +217,17 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n             Input::Str { ref name, .. } => PathBuf::from(name.clone()),\n         };\n \n+        let mut access_levels = cx.access_levels.borrow_mut();\n+        let mut external_traits = cx.external_traits.borrow_mut();\n+\n         Crate {\n             name: name.to_string(),\n             src: src,\n             module: Some(module),\n             externs: externs,\n             primitives: primitives,\n-            external_traits: cx.external_traits.borrow_mut().take()\n-                               .unwrap_or(HashMap::new()),\n+            access_levels: Arc::new(mem::replace(&mut access_levels, Default::default())),\n+            external_traits: mem::replace(&mut external_traits, Default::default()),\n         }\n     }\n }\n@@ -541,8 +556,7 @@ impl Clean<TyParam> for hir::TyParam {\n \n impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n-        cx.external_typarams.borrow_mut().as_mut().unwrap()\n-          .insert(self.def_id, self.name.clean(cx));\n+        cx.renderinfo.borrow_mut().external_typarams.insert(self.def_id, self.name.clean(cx));\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n@@ -2685,7 +2699,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     inline::record_extern_fqn(cx, did, kind);\n     if let TypeTrait = kind {\n         let t = inline::build_external_trait(cx, tcx, did);\n-        cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n+        cx.external_traits.borrow_mut().insert(did, t);\n     }\n     did\n }"}, {"sha": "b7c60b8a524c0881780a8bc20253a1c01a856527", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 33, "deletions": 46, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -29,12 +29,13 @@ use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n+use html::render::RenderInfo;\n \n pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n@@ -45,19 +46,24 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type ExternalPaths = RefCell<Option<HashMap<DefId,\n-                                                (Vec<String>, clean::TypeKind)>>>;\n+pub type Externs = HashMap<String, Vec<String>>;\n+pub type ExternalPaths = HashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n-    pub external_paths: ExternalPaths,\n-    pub external_traits: RefCell<Option<HashMap<DefId, clean::Trait>>>,\n-    pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n-    pub inlined: RefCell<Option<HashSet<DefId>>>,\n     pub all_crate_impls: RefCell<HashMap<ast::CrateNum, Vec<clean::Item>>>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from crateanalysis.\n+    /// Later on moved into `clean::Crate`\n+    pub access_levels: RefCell<AccessLevels<DefId>>,\n+    /// Later on moved into `html::render::CACHE_KEY`\n+    pub renderinfo: RefCell<RenderInfo>,\n+    /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n+    pub external_traits: RefCell<HashMap<DefId, clean::Trait>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -81,20 +87,23 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n     }\n }\n \n-pub struct CrateAnalysis {\n-    pub access_levels: AccessLevels<DefId>,\n-    pub external_paths: ExternalPaths,\n-    pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n-    pub inlined: RefCell<Option<HashSet<DefId>>>,\n-    pub deref_trait_did: Option<DefId>,\n+pub trait DocAccessLevels {\n+    fn is_doc_reachable(&self, DefId) -> bool;\n }\n \n-pub type Externs = HashMap<String, Vec<String>>;\n+impl DocAccessLevels for AccessLevels<DefId> {\n+    fn is_doc_reachable(&self, did: DefId) -> bool {\n+        self.is_public(did)\n+    }\n+}\n \n-pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n-                input: Input, triple: Option<String>)\n-                -> (clean::Crate, CrateAnalysis) {\n \n+pub fn run_core(search_paths: SearchPaths,\n+                cfgs: Vec<String>,\n+                externs: Externs,\n+                input: Input,\n+                triple: Option<String>) -> (clean::Crate, RenderInfo)\n+{\n     // Parse, resolve, and typecheck the given crate.\n \n     let cpath = match input {\n@@ -148,7 +157,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n \n-    let krate_and_analysis = abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n+    abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n                                                      &cstore,\n                                                      hir_map,\n                                                      &arenas,\n@@ -175,42 +184,20 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n-            external_traits: RefCell::new(Some(HashMap::new())),\n-            external_typarams: RefCell::new(Some(HashMap::new())),\n-            external_paths: RefCell::new(Some(HashMap::new())),\n-            inlined: RefCell::new(Some(HashSet::new())),\n             all_crate_impls: RefCell::new(HashMap::new()),\n             deref_trait_did: Cell::new(None),\n+            access_levels: RefCell::new(access_levels),\n+            external_traits: RefCell::new(HashMap::new()),\n+            renderinfo: RefCell::new(Default::default()),\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());\n \n-        let mut analysis = CrateAnalysis {\n-            access_levels: access_levels,\n-            external_paths: RefCell::new(None),\n-            external_typarams: RefCell::new(None),\n-            inlined: RefCell::new(None),\n-            deref_trait_did: None,\n-        };\n-\n         let krate = {\n-            let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n+            let mut v = RustdocVisitor::new(&ctxt);\n             v.visit(ctxt.map.krate());\n             v.clean(&ctxt)\n         };\n \n-        let external_paths = ctxt.external_paths.borrow_mut().take();\n-        *analysis.external_paths.borrow_mut() = external_paths;\n-\n-        let map = ctxt.external_typarams.borrow_mut().take();\n-        *analysis.external_typarams.borrow_mut() = map;\n-\n-        let map = ctxt.inlined.borrow_mut().take();\n-        *analysis.inlined.borrow_mut() = map;\n-\n-        analysis.deref_trait_did = ctxt.deref_trait_did.get();\n-\n-        Some((krate, analysis))\n-    }), &sess);\n-\n-    krate_and_analysis.unwrap()\n+        Some((krate, ctxt.renderinfo.into_inner()))\n+    }), &sess).unwrap()\n }"}, {"sha": "d4212bba590602f2f93498ce7c95926f42d3ce6c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -24,6 +24,7 @@ use syntax::abi::Abi;\n use rustc::hir;\n \n use clean;\n+use core::DocAccessLevels;\n use html::item_type::ItemType;\n use html::render;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n@@ -298,6 +299,9 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n     let mut url = if did.is_local() || cache.inlined.contains(&did) {\n         repeat(\"../\").take(loc.len()).collect::<String>()\n     } else {\n+        if !cache.access_levels.is_doc_reachable(did) {\n+            return None\n+        }\n         match cache.extern_locations[&did.krate] {\n             (_, render::Remote(ref s)) => s.to_string(),\n             (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),"}, {"sha": "c08d917589d3c6b3279b3181631a46278a888197", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -247,14 +247,18 @@ pub struct Cache {\n     /// Set of definitions which have been inlined from external crates.\n     pub inlined: HashSet<DefId>,\n \n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from crateanalysis.\n+    pub access_levels: Arc<AccessLevels<DefId>>,\n+\n     // Private fields only used when initially crawling a crate to build a cache\n \n     stack: Vec<String>,\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n     stripped_mod: bool,\n-    access_levels: AccessLevels<DefId>,\n     deref_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n@@ -265,6 +269,16 @@ pub struct Cache {\n     orphan_methods: Vec<(DefId, clean::Item)>,\n }\n \n+/// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n+/// Later on moved into `CACHE_KEY`.\n+#[derive(Default)]\n+pub struct RenderInfo {\n+    pub inlined: HashSet<DefId>,\n+    pub external_paths: ::core::ExternalPaths,\n+    pub external_typarams: HashMap<DefId, String>,\n+    pub deref_trait_did: Option<DefId>,\n+}\n+\n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a> {\n     scx: &'a mut SharedContext,\n@@ -416,7 +430,8 @@ pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: PathBuf,\n            passes: HashSet<String>,\n-           css_file_extension: Option<PathBuf>) -> Result<(), Error> {\n+           css_file_extension: Option<PathBuf>,\n+           renderinfo: RenderInfo) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n@@ -483,19 +498,20 @@ pub fn run(mut krate: clean::Crate,\n     };\n \n     // Crawl the crate to build various caches used for the output\n-    let analysis = ::ANALYSISKEY.with(|a| a.clone());\n-    let analysis = analysis.borrow();\n-    let access_levels = analysis.as_ref().map(|a| a.access_levels.clone());\n-    let access_levels = access_levels.unwrap_or(Default::default());\n-    let paths: HashMap<DefId, (Vec<String>, ItemType)> =\n-      analysis.as_ref().map(|a| {\n-        let paths = a.external_paths.borrow_mut().take().unwrap();\n-        paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t)))).collect()\n-      }).unwrap_or(HashMap::new());\n+    let RenderInfo {\n+        inlined,\n+        external_paths,\n+        external_typarams,\n+        deref_trait_did,\n+    } = renderinfo;\n+\n+    let paths = external_paths.into_iter()\n+                              .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n+                              .collect::<HashMap<_, _>>();\n+\n     let mut cache = Cache {\n         impls: HashMap::new(),\n-        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone()))\n-                             .collect(),\n+        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone())).collect(),\n         paths: paths,\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n@@ -505,16 +521,12 @@ pub fn run(mut krate: clean::Crate,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n         stripped_mod: false,\n-        access_levels: access_levels,\n+        access_levels: krate.access_levels.clone(),\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n-        deref_trait_did: analysis.as_ref().and_then(|a| a.deref_trait_did),\n-        typarams: analysis.as_ref().map(|a| {\n-            a.external_typarams.borrow_mut().take().unwrap()\n-        }).unwrap_or(HashMap::new()),\n-        inlined: analysis.as_ref().map(|a| {\n-            a.inlined.borrow_mut().take().unwrap()\n-        }).unwrap_or(HashSet::new()),\n+        deref_trait_did: deref_trait_did,\n+        typarams: external_typarams,\n+        inlined: inlined,\n     };\n \n     // Cache where all our extern crates are located"}, {"sha": "86aad10e02fc7354c273d5cdf38a0b0e55a57623", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -48,14 +48,11 @@ extern crate rustc_unicode;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::default::Default;\n use std::env;\n-use std::io::Read;\n use std::path::PathBuf;\n use std::process;\n-use std::rc::Rc;\n use std::sync::mpsc::channel;\n \n use externalfiles::ExternalHtml;\n@@ -83,6 +80,7 @@ pub mod markdown;\n pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n+pub mod visit_lib;\n pub mod test;\n mod flock;\n \n@@ -113,12 +111,9 @@ const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-thread_local!(pub static ANALYSISKEY: Rc<RefCell<Option<core::CrateAnalysis>>> = {\n-    Rc::new(RefCell::new(None))\n-});\n-\n struct Output {\n     krate: clean::Crate,\n+    renderinfo: html::render::RenderInfo,\n     passes: Vec<String>,\n }\n \n@@ -302,14 +297,15 @@ pub fn main_args(args: &[String]) -> isize {\n             return 1;\n         }\n     };\n-    let Output { krate, passes, } = out;\n+    let Output { krate, passes, renderinfo } = out;\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n             html::render::run(krate, &external_html,\n                               output.unwrap_or(PathBuf::from(\"doc\")),\n                               passes.into_iter().collect(),\n-                              css_file_extension)\n+                              css_file_extension,\n+                              renderinfo)\n                 .expect(\"failed to generate documentation\")\n         }\n         Some(s) => {\n@@ -380,12 +376,8 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         tx.send(core::run_core(paths, cfgs, externs, Input::File(cr),\n                                triple)).unwrap();\n     });\n-    let (mut krate, analysis) = rx.recv().unwrap();\n+    let (mut krate, renderinfo) = rx.recv().unwrap();\n     info!(\"finished with rustc\");\n-    let mut analysis = Some(analysis);\n-    ANALYSISKEY.with(|s| {\n-        *s.borrow_mut() = analysis.take();\n-    });\n \n     if let Some(name) = matches.opt_str(\"crate-name\") {\n         krate.name = name\n@@ -443,5 +435,5 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // Run everything!\n     info!(\"Executing passes/plugins\");\n     let krate = pm.run_plugins(krate);\n-    Output { krate: krate, passes: passes }\n+    Output { krate: krate, renderinfo: renderinfo, passes: passes }\n }"}, {"sha": "ac1b5452fa75d5a5c83f3c8ae1be6bfe0188cccf", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -87,10 +87,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet();\n-    let analysis = super::ANALYSISKEY.with(|a| a.clone());\n-    let analysis = analysis.borrow();\n-    let analysis = analysis.as_ref().unwrap();\n-    let access_levels = analysis.access_levels.clone();\n+    let access_levels = krate.access_levels.clone();\n \n     // strip all private items\n     {"}, {"sha": "5a7050fb42f3045a8115d0ecd616f27247e60da3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -108,15 +108,14 @@ pub fn run(input: &str,\n         map: &map,\n         maybe_typed: core::NotTyped(&sess),\n         input: input,\n-        external_paths: RefCell::new(Some(HashMap::new())),\n-        external_traits: RefCell::new(None),\n-        external_typarams: RefCell::new(None),\n-        inlined: RefCell::new(None),\n+        external_traits: RefCell::new(HashMap::new()),\n         all_crate_impls: RefCell::new(HashMap::new()),\n         deref_trait_did: Cell::new(None),\n+        access_levels: Default::default(),\n+        renderinfo: Default::default(),\n     };\n \n-    let mut v = RustdocVisitor::new(&ctx, None);\n+    let mut v = RustdocVisitor::new(&ctx);\n     v.visit(ctx.map.krate());\n     let mut krate = v.clean(&ctx);\n     if let Some(name) = crate_name {"}, {"sha": "2bce8f4c2a1275a1c1e03a8fe0a9707c7502bbb3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -21,12 +21,14 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n use rustc::hir::map as hir_map;\n+use rustc::hir::def::Def;\n use rustc::middle::stability;\n+use rustc::middle::privacy::AccessLevel;\n \n use rustc::hir;\n \n use core;\n-use clean::{Clean, Attributes};\n+use clean::{self, Clean, Attributes};\n use doctree::*;\n \n // looks to me like the first two of these are actually\n@@ -41,22 +43,19 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n-    pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'a, 'tcx>,\n-               analysis: Option<&'a core::CrateAnalysis>) -> RustdocVisitor<'a, 'tcx> {\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n         let mut stack = HashSet::new();\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: hir::HirVec::new(),\n             cx: cx,\n-            analysis: analysis,\n             view_item_stack: stack,\n             inlining_from_glob: false,\n         }\n@@ -243,19 +242,40 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = tcx.def_map.borrow()[&id].def_id();\n-        let def_node_id = match tcx.map.as_local_node_id(def) {\n-            Some(n) => n, None => return false\n-        };\n-        let analysis = match self.analysis {\n-            Some(analysis) => analysis, None => return false\n-        };\n+        let def = tcx.def_map.borrow()[&id];\n+        let def_did = def.def_id();\n \n         let use_attrs = tcx.map.attrs(id).clean(self.cx);\n+        let is_no_inline = use_attrs.list(\"doc\").has_word(\"no_inline\");\n+\n+        // For cross-crate impl inlining we need to know whether items are\n+        // reachable in documentation - a previously nonreachable item can be\n+        // made reachable by cross-crate inlining which we're checking here.\n+        // (this is done here because we need to know this upfront)\n+        if !def.def_id().is_local() && !is_no_inline {\n+            let attrs = clean::inline::load_attrs(self.cx, tcx, def_did);\n+            let self_is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n+            match def.base_def {\n+                Def::Trait(did) |\n+                Def::Struct(did) |\n+                Def::Enum(did) |\n+                Def::TyAlias(did) if !self_is_hidden => {\n+                    self.cx.access_levels.borrow_mut().map.insert(did, AccessLevel::Public);\n+                },\n+                Def::Mod(did) => if !self_is_hidden {\n+                    ::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n+                },\n+                _ => {},\n+            }\n+            return false\n+        }\n+\n+        let def_node_id = match tcx.map.as_local_node_id(def_did) {\n+            Some(n) => n, None => return false\n+        };\n \n-        let is_private = !analysis.access_levels.is_public(def);\n+        let is_private = !self.cx.access_levels.borrow().is_public(def_did);\n         let is_hidden = inherits_doc_hidden(self.cx, def_node_id);\n-        let is_no_inline = use_attrs.list(\"doc\").has_word(\"no_inline\");\n \n         // Only inline if requested or if the item would otherwise be stripped\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {"}, {"sha": "f56f4c306f90a540451568994f4ce1ee2e8aef8f", "filename": "src/librustdoc/visit_lib.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::middle::cstore::{CrateStore, ChildItem, DefLike};\n+use rustc::middle::privacy::{AccessLevels, AccessLevel};\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::ty::Visibility;\n+use syntax::ast;\n+\n+use std::cell::RefMut;\n+\n+use clean::{Attributes, Clean};\n+\n+// FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n+\n+/// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n+/// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n+pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    cx: &'a ::core::DocContext<'b, 'tcx>,\n+    cstore: &'a CrateStore<'tcx>,\n+    // Accessibility levels for reachable nodes\n+    access_levels: RefMut<'a, AccessLevels<DefId>>,\n+    // Previous accessibility level, None means unreachable\n+    prev_level: Option<AccessLevel>,\n+}\n+\n+impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n+    pub fn new(cx: &'a ::core::DocContext<'b, 'tcx>) -> LibEmbargoVisitor<'a, 'b, 'tcx> {\n+        LibEmbargoVisitor {\n+            cx: cx,\n+            cstore: &*cx.sess().cstore,\n+            access_levels: cx.access_levels.borrow_mut(),\n+            prev_level: Some(AccessLevel::Public),\n+        }\n+    }\n+\n+    pub fn visit_lib(&mut self, cnum: ast::CrateNum) {\n+        let did = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        self.visit_mod(did);\n+    }\n+\n+    // Updates node level and returns the updated level\n+    fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+        let attrs: Vec<_> = self.cx.tcx().get_attrs(did).iter()\n+                                                        .map(|a| a.clean(self.cx))\n+                                                        .collect();\n+        let is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n+\n+        let old_level = self.access_levels.map.get(&did).cloned();\n+        // Accessibility levels can only grow\n+        if level > old_level && !is_hidden {\n+            self.access_levels.map.insert(did, level.unwrap());\n+            level\n+        } else {\n+            old_level\n+        }\n+    }\n+\n+    pub fn visit_mod(&mut self, did: DefId) {\n+        for item in self.cstore.item_children(did) {\n+            if let DefLike::DlDef(def) = item.def {\n+                match def {\n+                    Def::Mod(did) |\n+                    Def::ForeignMod(did) |\n+                    Def::Trait(did) |\n+                    Def::Struct(did) |\n+                    Def::Enum(did) |\n+                    Def::TyAlias(did) |\n+                    Def::Fn(did) |\n+                    Def::Method(did) |\n+                    Def::Static(did, _) |\n+                    Def::Const(did) => self.visit_item(did, item),\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_item(&mut self, did: DefId, item: ChildItem) {\n+        let inherited_item_level = match item.def {\n+            DefLike::DlImpl(..) | DefLike::DlField => unreachable!(),\n+            DefLike::DlDef(def) => {\n+                match def {\n+                    Def::ForeignMod(..) => self.prev_level,\n+                    _ => if item.vis == Visibility::Public { self.prev_level } else { None }\n+                }\n+            }\n+        };\n+\n+        let item_level = self.update(did, inherited_item_level);\n+\n+        if let DefLike::DlDef(Def::Mod(did)) = item.def {\n+            let orig_level = self.prev_level;\n+\n+            self.prev_level = item_level;\n+            self.visit_mod(did);\n+            self.prev_level = orig_level;\n+        }\n+    }\n+}"}, {"sha": "e2bc153ce0d85379cad0cab059935464c9279adf", "filename": "src/test/auxiliary/rustdoc-hidden-sig.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Fauxiliary%2Frustdoc-hidden-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Fauxiliary%2Frustdoc-hidden-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frustdoc-hidden-sig.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Bar;\n+\n+impl Bar {\n+    pub fn bar(_: u8) -> hidden::Hidden {\n+        hidden::Hidden\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Hidden;\n+}"}, {"sha": "22a311d579745df533b07ed7853d105255f70163", "filename": "src/test/auxiliary/rustdoc-nonreachable-impls.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Fauxiliary%2Frustdoc-nonreachable-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Fauxiliary%2Frustdoc-nonreachable-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frustdoc-nonreachable-impls.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo;\n+\n+pub trait Woof {}\n+pub trait Bark {}\n+\n+mod private {\n+    // should be shown\n+    impl ::Woof for ::Foo {}\n+\n+    pub trait Bar {}\n+    pub struct Wibble;\n+\n+    // these should not be shown\n+    impl Bar for ::Foo {}\n+    impl Bar for Wibble {}\n+    impl ::Bark for Wibble {}\n+    impl ::Woof for Wibble {}\n+}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    // should be shown\n+    impl ::Bark for ::Foo {}\n+\n+    pub trait Qux {}\n+    pub struct Wobble;\n+\n+\n+    // these should only be shown if they're reexported correctly\n+    impl Qux for ::Foo {}\n+    impl Qux for Wobble {}\n+    impl ::Bark for Wobble {}\n+    impl ::Woof for Wobble {}\n+}"}, {"sha": "6b5c5b20147345f5d20c53ab6ac37f7f8c12fb07", "filename": "src/test/rustdoc/inline_cross/issue-28480.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-28480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-28480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-28480.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rustdoc-hidden-sig.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+// @has rustdoc_hidden_sig/struct.Bar.html\n+// @!has -  '//a/@title' 'Hidden'\n+// @has -  '//a' 'u8'\n+extern crate rustdoc_hidden_sig;\n+\n+// @has issue_28480/struct.Bar.html\n+// @!has -  '//a/@title' 'Hidden'\n+// @has -  '//a' 'u8'\n+pub use rustdoc_hidden_sig::Bar;"}, {"sha": "e953b66fce15dd351ea4dcf6fa4d984d463c2001", "filename": "src/test/rustdoc/inline_cross/issue-31948-1.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-1.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rustdoc-nonreachable-impls.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate rustdoc_nonreachable_impls;\n+\n+// @has issue_31948_1/struct.Wobble.html\n+// @has - '//*[@class=\"impl\"]//code' 'Bark for'\n+// @has - '//*[@class=\"impl\"]//code' 'Woof for'\n+// @!has - '//*[@class=\"impl\"]//code' 'Bar for'\n+// @!has - '//*[@class=\"impl\"]//code' 'Qux for'\n+pub use rustdoc_nonreachable_impls::hidden::Wobble;\n+\n+// @has issue_31948_1/trait.Bark.html\n+// FIXME(33025): has - '//code' 'for Foo'\n+// @has - '//code' 'for Wobble'\n+// @!has - '//code' 'for Wibble'\n+pub use rustdoc_nonreachable_impls::Bark;\n+\n+// @has issue_31948_1/trait.Woof.html\n+// FIXME(33025): has - '//code' 'for Foo'\n+// @has - '//code' 'for Wobble'\n+// @!has - '//code' 'for Wibble'\n+pub use rustdoc_nonreachable_impls::Woof;\n+\n+// @!has issue_31948_1/trait.Bar.html\n+// @!has issue_31948_1/trait.Qux.html"}, {"sha": "0423fa1de3b4c56fc55da4bf8b45c4ae4d5aa77c", "filename": "src/test/rustdoc/inline_cross/issue-31948-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-2.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rustdoc-nonreachable-impls.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate rustdoc_nonreachable_impls;\n+\n+// @has issue_31948_2/struct.Wobble.html\n+// @has - '//*[@class=\"impl\"]//code' 'Qux for'\n+// @has - '//*[@class=\"impl\"]//code' 'Bark for'\n+// @has - '//*[@class=\"impl\"]//code' 'Woof for'\n+// @!has - '//*[@class=\"impl\"]//code' 'Bar for'\n+pub use rustdoc_nonreachable_impls::hidden::Wobble;\n+\n+// @has issue_31948_2/trait.Qux.html\n+// FIXME(33025): has - '//code' 'for Foo'\n+// @has - '//code' 'for Wobble'\n+pub use rustdoc_nonreachable_impls::hidden::Qux;\n+\n+// @!has issue_31948_2/trait.Bar.html\n+// @!has issue_31948_2/trait.Woof.html\n+// @!has issue_31948_2/trait.Bark.html"}, {"sha": "073e8eb50fb257def2cce87c8cfc04698e7fd981", "filename": "src/test/rustdoc/inline_cross/issue-31948.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478a33dabc4e6f2f501f476c79b56178d9df4f37/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948.rs?ref=478a33dabc4e6f2f501f476c79b56178d9df4f37", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rustdoc-nonreachable-impls.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate rustdoc_nonreachable_impls;\n+\n+// @has issue_31948/struct.Foo.html\n+// @has - '//*[@class=\"impl\"]//code' 'Bark for'\n+// @has - '//*[@class=\"impl\"]//code' 'Woof for'\n+// @!has - '//*[@class=\"impl\"]//code' 'Bar for'\n+// @!has - '//*[@class=\"impl\"]//code' 'Qux for'\n+pub use rustdoc_nonreachable_impls::Foo;\n+\n+// @has issue_31948/trait.Bark.html\n+// @has - '//code' 'for Foo'\n+// @!has - '//code' 'for Wibble'\n+// @!has - '//code' 'for Wobble'\n+pub use rustdoc_nonreachable_impls::Bark;\n+\n+// @has issue_31948/trait.Woof.html\n+// @has - '//code' 'for Foo'\n+// @!has - '//code' 'for Wibble'\n+// @!has - '//code' 'for Wobble'\n+pub use rustdoc_nonreachable_impls::Woof;\n+\n+// @!has issue_31948/trait.Bar.html\n+// @!has issue_31948/trait.Qux.html\n+// @!has issue_31948/struct.Wibble.html\n+// @!has issue_31948/struct.Wobble.html"}]}