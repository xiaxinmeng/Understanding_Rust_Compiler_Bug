{"sha": "f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNDgzM2FiZmNlNzRjZjE3OGMwNTg5YTRiN2NmNWZiYTlkMmEyZGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-30T19:18:25Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-01T04:41:46Z"}, "message": "librustc: Make `a.b()` always a method call. r=nmatsakis", "tree": {"sha": "08943a296d704c10303fbd6b33b3d7e8fb704ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08943a296d704c10303fbd6b33b3d7e8fb704ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "html_url": "https://github.com/rust-lang/rust/commit/f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/54ae377ec26ed47bbb627bdcb58bb10658cf03c4", "html_url": "https://github.com/rust-lang/rust/commit/54ae377ec26ed47bbb627bdcb58bb10658cf03c4"}], "stats": {"total": 510, "additions": 413, "deletions": 97}, "files": [{"sha": "1bebf817f9bbd5ccf739288ec255b1e8760fcad5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -1047,7 +1047,7 @@ pub mod fsync {\n             option::None => (),\n             option::Some(level) => {\n               // fail hard if not succesful\n-              assert(self.arg.fsync_fn(self.arg.val, level) != -1);\n+              assert((self.arg.fsync_fn)(self.arg.val, level) != -1);\n             }\n           }\n         }"}, {"sha": "7cf5ad32b3c77ebe73919de8eedefff1601723f0", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -646,6 +646,9 @@ fn check_loans_in_expr(expr: @ast::expr,\n       ast::expr_call(f, args, _) => {\n         self.check_call(expr, Some(f), f.id, f.span, args);\n       }\n+      ast::expr_method_call(_, _, _, args, _) => {\n+        self.check_call(expr, None, expr.callee_id, expr.span, args);\n+      }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n       if self.bccx.method_map.contains_key(expr.id) => {"}, {"sha": "c0f9cb3d5e252b9bfbe81958febd11f2a7852b79", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -125,6 +125,38 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n+      ast::expr_method_call(rcvr, _, _, args, _) => {\n+        let arg_tys = ty::ty_fn_args(ty::node_id_to_type(self.tcx(),\n+                                                         ex.callee_id));\n+        let scope_r = ty::re_scope(ex.id);\n+        for vec::each2(args, arg_tys) |arg, arg_ty| {\n+            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+              ast::by_ref => {\n+                let arg_cmt = self.bccx.cat_expr(*arg);\n+                self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n+              }\n+               ast::by_val | ast::by_move | ast::by_copy => {}\n+            }\n+        }\n+\n+        match self.bccx.method_map.find(ex.id) {\n+            Some(method_map_entry) => {\n+                match method_map_entry.explicit_self {\n+                    ast::sty_by_ref => {\n+                        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n+                        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n+                    }\n+                    _ => {} // Nothing to do.\n+                }\n+            }\n+            None => {\n+                self.tcx().sess.span_bug(ex.span, ~\"no method map entry\");\n+            }\n+        }\n+\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n       ast::expr_match(ex_v, arms) => {\n         let cmt = self.bccx.cat_expr(ex_v);\n         for arms.each |arm| {"}, {"sha": "b4099325fb1bb16340eaac1fc7e9de6fe34b6c17", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -339,6 +339,18 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             }\n         }\n       }\n+      expr_method_call(_, _, _, args, _) => {\n+        for ty::ty_fn_args(ty::node_id_to_type(cx.tcx, e.callee_id)).eachi\n+                |i, arg_t| {\n+            match ty::arg_mode(cx.tcx, *arg_t) {\n+              by_copy => maybe_copy(cx, args[i],\n+                     Some((\"function arguments must be copyable\",\n+                           \"try changing the function to take a \\\n+                            reference instead\"))),\n+              by_ref | by_val | by_move => ()\n+            }\n+        }\n+      }\n       expr_field(lhs, _, _) => {\n         // If this is a method call with a by-val argument, we need\n         // to check the copy"}, {"sha": "985f62e86a6108dbdd03e0b4705e5942d15914a1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -550,8 +550,8 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n \n       // otherwise, live nodes are not required:\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n-      expr_vec(*) | expr_rec(*) | expr_call(*) | expr_tup(*) |\n-      expr_log(*) | expr_binary(*) |\n+      expr_vec(*) | expr_rec(*) | expr_call(*) | expr_method_call(*) |\n+      expr_tup(*) | expr_log(*) | expr_binary(*) |\n       expr_assert(*) | expr_addr_of(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) | expr_cast(*) |\n       expr_unary(*) | expr_fail(*) |\n@@ -1237,6 +1237,17 @@ impl Liveness {\n             self.propagate_through_expr(f, succ)\n           }\n \n+          expr_method_call(rcvr, _, _, args, _) => {\n+            // calling a method with bot return type means that the method\n+            // will fail, and hence the successors can be ignored\n+            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx,\n+                                                          expr.callee_id));\n+            let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n+                       else {succ};\n+            let succ = self.propagate_through_exprs(args, succ);\n+            self.propagate_through_expr(rcvr, succ)\n+          }\n+\n           expr_tup(exprs) => {\n             self.propagate_through_exprs(exprs, succ)\n           }\n@@ -1486,6 +1497,26 @@ fn check_arm(arm: arm, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_arm(arm, self, vt);\n }\n \n+fn check_call(args: &[@expr],\n+              targs: &[ty::arg],\n+              &&self: @Liveness) {\n+    for vec::each2(args, targs) |arg_expr, arg_ty| {\n+        match ty::resolved_mode(self.tcx, arg_ty.mode) {\n+            by_val | by_copy | by_ref => {}\n+            by_move => {\n+                if ty::expr_is_lval(self.tcx, self.ir.method_map, *arg_expr) {\n+                    // Probably a bad error message (what's an rvalue?)\n+                    // but I can't think of anything better\n+                    self.tcx.sess.span_err(arg_expr.span,\n+                      fmt!(\"move mode argument must be an rvalue: try (move \\\n+                            %s) instead\",\n+                           expr_to_str(*arg_expr, self.tcx.sess.intr())));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n       expr_path(_) => {\n@@ -1531,23 +1562,14 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n \n       expr_call(f, args, _) => {\n         let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n-        for vec::each2(args, targs) |arg_expr, arg_ty| {\n-            match ty::resolved_mode(self.tcx, arg_ty.mode) {\n-                by_val | by_copy | by_ref => {}\n-                by_move => {\n-                    if ty::expr_is_lval(self.tcx, self.ir.method_map,\n-                                        *arg_expr) {\n-                        // Probably a bad error message (what's an rvalue?)\n-                        // but I can't think of anything better\n-                        self.tcx.sess.span_err(arg_expr.span,\n-                          fmt!(\"Move mode argument must be an rvalue: try \\\n-                          (move %s) instead\", expr_to_str(*arg_expr,\n-                                                self.tcx.sess.intr())));\n-                    }\n-                }\n-            }\n-        }\n+        check_call(args, targs, self);\n+        visit::visit_expr(expr, self, vt);\n+      }\n \n+      expr_method_call(_, _, _, args, _) => {\n+        let targs = ty::ty_fn_args(ty::node_id_to_type(self.tcx,\n+                                                       expr.callee_id));\n+        check_call(args, targs, self);\n         visit::visit_expr(expr, self, vt);\n       }\n "}, {"sha": "e42d18a06c973cdabdd210b56db604ef393f5155", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -530,7 +530,8 @@ impl &mem_categorization_ctxt {\n           ast::expr_swap(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |\n           ast::expr_assert(*) | ast::expr_ret(*) |\n-          ast::expr_loop_body(*) | ast::expr_do_body(*) | ast::expr_unary(*) |\n+          ast::expr_loop_body(*) | ast::expr_do_body(*) |\n+          ast::expr_unary(*) | ast::expr_method_call(*) |\n           ast::expr_copy(*) | ast::expr_cast(*) | ast::expr_fail(*) |\n           ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n           ast::expr_if(*) | ast::expr_log(*) |"}, {"sha": "06011d928fd7214d9633e5d7948031b42b7497ad", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -258,7 +258,7 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n       // FIXME #3387\n       // ast::expr_index(*) | ast::expr_binary(*) |\n       // ast::expr_unary(*) |\n-      ast::expr_call(*) => {\n+      ast::expr_call(*) | ast::expr_method_call(*) => {\n         debug!(\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n                                                            cx.sess.intr()));\n         new_cx.parent = Some(expr.id);"}, {"sha": "56515b548cf62e33d7d70e1428226af5890f7344", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -16,12 +16,11 @@ use syntax::ast::{def_foreign_mod, def_id, def_label, def_local, def_mod};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n use syntax::ast::{def_typaram_binder, def_static_method};\n use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n-use syntax::ast::{expr_binary, expr_cast, expr_field, expr_fn};\n-use syntax::ast::{expr_fn_block, expr_index, expr_path};\n+use syntax::ast::{expr_binary, expr_break, expr_cast, expr_field, expr_fn};\n+use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n use syntax::ast::{enum_variant_kind, expr, expr_again, expr_assign_op};\n-use syntax::ast::{expr_binary, expr_break, expr_cast, expr_field, expr_fn};\n use syntax::ast::{expr_fn_block, expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n@@ -4971,6 +4970,10 @@ impl Resolver {\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, traits);\n             }\n+            expr_method_call(_, ident, _, _, _) => {\n+                let traits = self.search_for_traits_containing_method(ident);\n+                self.trait_map.insert(expr.id, traits);\n+            }\n             expr_binary(add, _, _) | expr_assign_op(add, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.add_trait);"}, {"sha": "b3b4238034a8c36c33f56ae4f306fa52ea972e8a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -292,6 +292,38 @@ fn trans_call(in_cx: block,\n         |cx| trans(cx, f), args, dest, DontAutorefArg)\n }\n \n+fn trans_method_call(in_cx: block,\n+                     call_ex: @ast::expr,\n+                     rcvr: @ast::expr,\n+                     args: CallArgs,\n+                     dest: expr::Dest)\n+                  -> block {\n+    let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n+    trans_call_inner(\n+        in_cx,\n+        call_ex.info(),\n+        node_id_type(in_cx, call_ex.callee_id),\n+        expr_ty(in_cx, call_ex),\n+        |cx| {\n+            match cx.ccx().maps.method_map.find(call_ex.id) {\n+                Some(origin) => {\n+                    meth::trans_method_callee(cx,\n+                                              call_ex.callee_id,\n+                                              rcvr,\n+                                              origin)\n+                }\n+                None => {\n+                    cx.tcx().sess.span_bug(call_ex.span,\n+                                           ~\"method call expr wasn't in \\\n+                                             method map\")\n+                }\n+            }\n+        },\n+        args,\n+        dest,\n+        DontAutorefArg)\n+}\n+\n fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: expr::Dest)\n     -> block\n {"}, {"sha": "2cd68bd0d23265ae49861919efaab005ce56780b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -592,6 +592,13 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return callee::trans_call(\n                 bcx, expr, f, callee::ArgExprs(args), expr.id, dest);\n         }\n+        ast::expr_method_call(rcvr, _, _, args, _) => {\n+            return callee::trans_method_call(bcx,\n+                                             expr,\n+                                             rcvr,\n+                                             callee::ArgExprs(args),\n+                                             dest);\n+        }\n         ast::expr_binary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx, expr, lhs, ~[rhs], dest,"}, {"sha": "a3df1c630f5a67f3101defe8cc89a5728a9eea87", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -170,6 +170,18 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n               _ => ()\n             }\n           }\n+          expr_method_call(*) => {\n+            match cx.method_map.find(e.id) {\n+              Some({origin: typeck::method_static(did), _}) => {\n+                traverse_def_id(cx, did);\n+              }\n+              Some(_) => {}\n+              None => {\n+                cx.tcx.sess.span_bug(e.span, ~\"expr_method_call not in \\\n+                                               method map\");\n+              }\n+            }\n+          }\n           _ => ()\n         }\n         visit::visit_expr(e, cx, v);"}, {"sha": "93c79e24ce82a281f7c2a0ab8ffe20c2f66768ee", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -173,6 +173,25 @@ fn node_type_needs(cx: ctx, use_: uint, id: node_id) {\n     type_needs(cx, use_, ty::node_id_to_type(cx.ccx.tcx, id));\n }\n \n+fn mark_for_method_call(cx: ctx, e_id: node_id) {\n+    do option::iter(&cx.ccx.maps.method_map.find(e_id)) |mth| {\n+        match mth.origin {\n+          typeck::method_static(did) => {\n+            do cx.ccx.tcx.node_type_substs.find(e_id).iter |ts| {\n+                let type_uses = type_uses_for(cx.ccx, did, ts.len());\n+                for vec::each2(type_uses, *ts) |uses, subst| {\n+                    type_needs(cx, *uses, *subst)\n+                }\n+            }\n+          }\n+          typeck::method_param({param_num: param, _}) => {\n+            cx.uses[param] |= use_tydesc;\n+          }\n+          typeck::method_trait(*) | typeck::method_self(*) => (),\n+        }\n+    }\n+}\n+\n fn mark_for_expr(cx: ctx, e: @expr) {\n     match e.node {\n       expr_vstore(_, _) |\n@@ -231,23 +250,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         // the chosen field.\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n-\n-        do option::iter(&cx.ccx.maps.method_map.find(e.id)) |mth| {\n-            match mth.origin {\n-              typeck::method_static(did) => {\n-                do cx.ccx.tcx.node_type_substs.find(e.id).iter |ts| {\n-                    let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-                    for vec::each2(type_uses, *ts) |uses, subst| {\n-                        type_needs(cx, *uses, *subst)\n-                    }\n-                }\n-              }\n-              typeck::method_param({param_num: param, _}) => {\n-                cx.uses[param] |= use_tydesc;\n-              }\n-              typeck::method_trait(*) | typeck::method_self(*) => (),\n-            }\n-        }\n+        mark_for_method_call(cx, e.id);\n       }\n       expr_log(_, _, val) => {\n         node_type_needs(cx, use_tydesc, val.id);\n@@ -264,6 +267,21 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n               }\n           }\n       }\n+      expr_method_call(rcvr, _, _, _, _) => {\n+        let base_ty = ty::node_id_to_type(cx.ccx.tcx, rcvr.id);\n+        type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n+\n+        for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n+                                               e.callee_id)).each |a| {\n+          match a.mode {\n+              expl(by_move) | expl(by_copy) | expl(by_val) => {\n+                  type_needs(cx, use_repr, a.ty);\n+              }\n+              _ => ()\n+          }\n+        }\n+        mark_for_method_call(cx, e.id);\n+      }\n       expr_paren(e) => mark_for_expr(cx, e),\n       expr_match(*) | expr_block(_) | expr_if(*) |\n       expr_while(*) | expr_fail(_) | expr_break(_) | expr_again(_) |"}, {"sha": "534f70ebed46fb31d9096aa5e68bc121535aae27", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -3053,6 +3053,7 @@ fn expr_kind(tcx: ctxt,\n         }\n \n         ast::expr_call(*) |\n+        ast::expr_method_call(*) |\n         ast::expr_rec(*) |\n         ast::expr_struct(*) |\n         ast::expr_tup(*) |"}, {"sha": "2081a9ef0172b95f4c4da54d2e2ed01189fe6d00", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 88, "deletions": 14, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -1101,24 +1101,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n-    // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n-                  f: @ast::expr, args: ~[@ast::expr]) -> bool {\n-\n-        // Index expressions need to be handled seperately, to inform\n-        // them that they appear in call position.\n-        let mut bot = match f.node {\n-          ast::expr_field(base, field, tys) => {\n-            check_field(fcx, f, true, base, field, tys)\n-          }\n-          _ => check_expr(fcx, f, None)\n-        };\n-        let fn_ty = fcx.expr_ty(f);\n+    // A generic function for doing all of the checking for call or\n+    // method expressions\n+    fn check_call_or_method(fcx: @fn_ctxt,\n+                            sp: span,\n+                            call_expr_id: ast::node_id,\n+                            fn_ty: ty::t,\n+                            expr: @ast::expr,\n+                            args: ~[@ast::expr],\n+                            bot: bool)\n+                         -> bool {\n+        let mut bot = bot;\n \n         // Call the generic checker.\n         let fty = {\n             let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, f, args, DontDerefArgs);\n+                                     fn_ty, expr, args, DontDerefArgs);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -1139,6 +1137,79 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n     }\n \n+    // A generic function for doing all of the checking for call expressions\n+    fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n+                  f: @ast::expr, args: ~[@ast::expr]) -> bool {\n+\n+        // Index expressions need to be handled separately, to inform them\n+        // that they appear in call position.\n+        let mut bot = match f.node {\n+            ast::expr_field(base, field, tys) => {\n+                check_field(fcx, f, true, base, field, tys)\n+            }\n+            _ => check_expr(fcx, f, None)\n+        };\n+\n+        check_call_or_method(fcx,\n+                             sp,\n+                             call_expr_id,\n+                             fcx.expr_ty(f),\n+                             f,\n+                             args,\n+                             bot)\n+    }\n+\n+    // Checks a method call.\n+    fn check_method_call(fcx: @fn_ctxt,\n+                         expr: @ast::expr,\n+                         rcvr: @ast::expr,\n+                         method_name: ast::ident,\n+                         args: ~[@ast::expr],\n+                         tps: ~[@ast::Ty])\n+                      -> bool {\n+        let bot = check_expr(fcx, rcvr, None);\n+        let expr_t = structurally_resolved_type(fcx,\n+                                                expr.span,\n+                                                fcx.expr_ty(rcvr));\n+\n+        let tps = tps.map(|ast_ty| fcx.to_ty(*ast_ty));\n+        match method::lookup(fcx,\n+                             expr,\n+                             rcvr,\n+                             expr.callee_id,\n+                             method_name,\n+                             expr_t,\n+                             tps,\n+                             DontDerefArgs) {\n+            Some(entry) => {\n+                fcx.ccx.method_map.insert(expr.id, entry);\n+            }\n+            None => {\n+                fcx.type_error_message(expr.span,\n+                  |actual| {\n+                      fmt!(\"type `%s` does not implement any method in scope \\\n+                            named `%s`\",\n+                           actual,\n+                           fcx.ccx.tcx.sess.str_of(method_name))\n+                  },\n+                  expr_t,\n+                  None);\n+\n+                // Add error type for the result\n+                fcx.write_ty(expr.id, ty::mk_err(fcx.ccx.tcx));\n+                fcx.write_ty(expr.callee_id, ty::mk_err(fcx.ccx.tcx));\n+            }\n+        }\n+\n+        check_call_or_method(fcx,\n+                             expr.span,\n+                             expr.id,\n+                             fcx.node_ty(expr.callee_id),\n+                             expr,\n+                             args,\n+                             bot)\n+    }\n+\n     // A generic function for checking for or for-each loops\n     fn check_for(fcx: @fn_ctxt, local: @ast::local,\n                  element_ty: ty::t, body: ast::blk,\n@@ -2092,6 +2163,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_call(f, args, _) => {\n         bot = check_call(fcx, expr.span, expr.id, f, args);\n       }\n+      ast::expr_method_call(rcvr, ident, tps, args, _) => {\n+        bot = check_method_call(fcx, expr, rcvr, ident, args, tps);\n+      }\n       ast::expr_cast(e, t) => {\n         bot = check_expr(fcx, e, None);\n         let t_1 = fcx.to_ty(t);"}, {"sha": "f45bef2eb5ffcbce9b7f9e61147d52f1d9f4dc8a", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -199,6 +199,17 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n             }\n         }\n \n+        ast::expr_method_call(rcvr, _, _, args, _) => {\n+            // Check for a.b() where b is a method.  Ensure that\n+            // any types in the callee are valid for the entire\n+            // method call.\n+\n+            constrain_auto_ref(rcx, rcvr);\n+            for args.each |arg| {\n+                constrain_auto_ref(rcx, *arg);\n+            }\n+        }\n+\n         ast::expr_cast(source, _) => {\n             // Determine if we are casting `source` to an trait\n             // instance.  If so, we have to be sure that the type of"}, {"sha": "7087b7c5b79a1d4c2a21bb87d59d1d6d0bfd50c4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -521,7 +521,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       // Must resolve bounds on methods with bounded params\n       ast::expr_field(*) | ast::expr_binary(*) |\n       ast::expr_unary(*) | ast::expr_assign_op(*) |\n-      ast::expr_index(*) => {\n+      ast::expr_index(*) | ast::expr_method_call(*) => {\n         match ty::method_call_bounds(cx.tcx, cx.method_map, ex.id) {\n           Some(bounds) => {\n             if has_trait_bounds(*bounds) {"}, {"sha": "ba2c9416f569f8525a87b77bf621307b3d2a0039", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -158,6 +158,11 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n         maybe_resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n       }\n \n+      ast::expr_method_call(*) => {\n+        // We must always have written in a callee ID type for these.\n+        resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+      }\n+\n       _ => ()\n     }\n     visit::visit_expr(e, wbcx, v);"}, {"sha": "c0af9fd2ae81d6f8687ad495068d07f29a91059c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -61,6 +61,9 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           Some(ast_map::node_expr(expr)) => {\n             match expr.node {\n               ast::expr_call(*) => explain_span(cx, ~\"call\", expr.span),\n+              ast::expr_method_call(*) => {\n+                explain_span(cx, ~\"method call\", expr.span)\n+              },\n               ast::expr_match(*) => explain_span(cx, ~\"match\", expr.span),\n               _ => explain_span(cx, ~\"expression\", expr.span)\n             }"}, {"sha": "9dab40ba991d163dd057da59b8982ab7681c3202", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -645,7 +645,7 @@ impl blk_check_mode : cmp::Eq {\n #[auto_serialize]\n #[auto_deserialize]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n-// Extra node ID is only used for index, assign_op, unary, binary\n+// Extra node ID is only used for index, assign_op, unary, binary, method call\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -659,6 +659,7 @@ enum expr_ {\n     expr_vec(~[@expr], mutability),\n     expr_rec(~[field], Option<@expr>),\n     expr_call(@expr, ~[@expr], bool), // True iff last argument is a block\n+    expr_method_call(@expr, ident, ~[@Ty], ~[@expr], bool), // Ditto\n     expr_tup(~[@expr]),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),"}, {"sha": "03a9729477aba37a894d8e7345d9ecf1d1f70709", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -409,6 +409,13 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                       fld.map_exprs(|x| fld.fold_expr(x), args),\n                       blk)\n           }\n+          expr_method_call(f, i, tps, args, blk) => {\n+            expr_method_call(fld.fold_expr(f),\n+                             fld.fold_ident(i),\n+                             vec::map(tps, |x| fld.fold_ty(*x)),\n+                             fld.map_exprs(|x| fld.fold_expr(x), args),\n+                             blk)\n+          }\n           expr_binary(binop, lhs, rhs) => {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n           }"}, {"sha": "e0210feb9de6cf887c5c51b7a98d130f1411aa72", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -6,9 +6,13 @@ use ast_util::operator_prec;\n \n fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     match e.node {\n-      ast::expr_if(*) | ast::expr_match(*) | ast::expr_block(_)\n-      | ast::expr_while(*) | ast::expr_loop(*)\n-      | ast::expr_call(_, _, true) => false,\n+      ast::expr_if(*)\n+      | ast::expr_match(*)\n+      | ast::expr_block(_)\n+      | ast::expr_while(*)\n+      | ast::expr_loop(*)\n+      | ast::expr_call(_, _, true)\n+      | ast::expr_method_call(_, _, _, _, true) => false,\n       _ => true\n     }\n }"}, {"sha": "7cf279d0d8126a8c60f51c8627aaf066552bee1b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -34,10 +34,10 @@ use ast::{_mod, add, arg, arm, attribute,\n              expr_call, expr_cast, expr_copy, expr_do_body, expr_fail,\n              expr_field, expr_fn, expr_fn_block, expr_if, expr_index,\n              expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac,\n-             expr_paren, expr_path, expr_rec, expr_repeat, expr_ret,\n-             expr_swap, expr_struct, expr_tup, expr_unary, expr_unary_move,\n-             expr_vec, expr_vstore, expr_vstore_mut_box, expr_while,\n-             extern_fn, field, fn_decl,\n+             expr_method_call, expr_paren, expr_path, expr_rec, expr_repeat,\n+             expr_ret, expr_swap, expr_struct, expr_tup, expr_unary,\n+             expr_unary_move, expr_vec, expr_vstore, expr_vstore_mut_box,\n+             expr_while, extern_fn, field, fn_decl,\n              foreign_item, foreign_item_const, foreign_item_fn, foreign_mod,\n              ident, impure_fn, infer, inherited,\n              item, item_, item_class, item_const, item_enum, item_fn,\n@@ -1212,8 +1212,26 @@ impl Parser {\n                         self.expect(token::LT);\n                         self.parse_seq_to_gt(Some(token::COMMA),\n                                              |p| p.parse_ty(false))\n-                    } else { ~[] };\n-                    e = self.mk_expr(lo, hi, expr_field(e, i, tys));\n+                    } else {\n+                        ~[]\n+                    };\n+\n+                    // expr.f() method call\n+                    match copy self.token {\n+                        token::LPAREN if self.permits_call() => {\n+                            let es = self.parse_unspanned_seq(\n+                                token::LPAREN, token::RPAREN,\n+                                seq_sep_trailing_disallowed(token::COMMA),\n+                                |p| p.parse_expr());\n+                            hi = self.span.hi;\n+\n+                            let nd = expr_method_call(e, i, tys, es, false);\n+                            e = self.mk_expr(lo, hi, move nd);\n+                        }\n+                        _ => {\n+                            e = self.mk_expr(lo, hi, expr_field(e, i, tys));\n+                        }\n+                    }\n                   }\n                   _ => self.unexpected()\n                 }\n@@ -1674,7 +1692,23 @@ impl Parser {\n             @{node: expr_call(f, args, true),\n               .. *e}\n           }\n-          expr_path(*) | expr_field(*) | expr_call(*) | expr_paren(*) => {\n+          expr_method_call(f, i, tps, args, false) => {\n+            let block = self.parse_lambda_block_expr();\n+            let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n+                                    ctor(block));\n+            let args = vec::append(args, ~[last_arg]);\n+            @{node: expr_method_call(f, i, tps, args, true),\n+              .. *e}\n+          }\n+          expr_field(f, i, tps) => {\n+            let block = self.parse_lambda_block_expr();\n+            let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n+                                    ctor(block));\n+            @{node: expr_method_call(f, i, tps, ~[last_arg], true),\n+              .. *e}\n+          }\n+          expr_path(*) | expr_call(*) | expr_method_call(*) |\n+          expr_paren(*) => {\n             let block = self.parse_lambda_block_expr();\n             let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                     ctor(block));"}, {"sha": "e13c6da403ff77dea7ab079d712d2e217be975b0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -1041,6 +1041,50 @@ fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n     }\n }\n \n+fn print_call_pre(s: ps,\n+                  has_block: bool,\n+                  base_args: &mut ~[@ast::expr])\n+               -> Option<@ast::expr> {\n+    if has_block {\n+        let blk_arg = base_args.pop();\n+        match blk_arg.node {\n+          ast::expr_loop_body(_) => { head(s, ~\"for\"); }\n+          ast::expr_do_body(_) => { head(s, ~\"do\"); }\n+          _ => {}\n+        }\n+        Some(blk_arg)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn print_call_post(s: ps,\n+                   has_block: bool,\n+                   blk: &Option<@ast::expr>,\n+                   base_args: &mut ~[@ast::expr]) {\n+    if !has_block || base_args.is_not_empty() {\n+        popen(s);\n+        commasep_exprs(s, inconsistent, *base_args);\n+        pclose(s);\n+    }\n+    if has_block {\n+        nbsp(s);\n+        match blk.get().node {\n+          // need to handle closures specifically\n+          ast::expr_do_body(e) | ast::expr_loop_body(e) => {\n+            end(s); // we close our head box; closure\n+                    // will create it's own.\n+            print_expr(s, e);\n+            end(s); // close outer box, as closures don't\n+          }\n+          _ => {\n+            // not sure if this can happen.\n+            print_expr(s, blk.get());\n+          }\n+        }\n+    }\n+}\n+\n fn print_expr(s: ps, &&expr: @ast::expr) {\n     fn print_field(s: ps, field: ast::field) {\n         ibox(s, indent_unit);\n@@ -1135,38 +1179,23 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         pclose(s);\n       }\n       ast::expr_call(func, args, has_block) => {\n-        let mut base_args = args;\n-        let blk = if has_block {\n-            let blk_arg = base_args.pop();\n-            match blk_arg.node {\n-              ast::expr_loop_body(_) => { head(s, ~\"for\"); }\n-              ast::expr_do_body(_) => { head(s, ~\"do\"); }\n-              _ => {}\n-            }\n-            Some(blk_arg)\n-        } else { None };\n+        let mut base_args = copy args;\n+        let blk = print_call_pre(s, has_block, &mut base_args);\n         print_expr(s, func);\n-        if !has_block || base_args.is_not_empty() {\n-            popen(s);\n-            commasep_exprs(s, inconsistent, base_args);\n-            pclose(s);\n-        }\n-        if has_block {\n-            nbsp(s);\n-            match blk.get().node {\n-              // need to handle closures specifically\n-              ast::expr_do_body(e) | ast::expr_loop_body(e) => {\n-                end(s); // we close our head box; closure\n-                        // will create it's own.\n-                print_expr(s, e);\n-                end(s); // close outer box, as closures don't\n-              }\n-              _ => {\n-                // not sure if this can happen.\n-                print_expr(s, blk.get());\n-              }\n-            }\n+        print_call_post(s, has_block, &blk, &mut base_args);\n+      }\n+      ast::expr_method_call(func, ident, tys, args, has_block) => {\n+        let mut base_args = copy args;\n+        let blk = print_call_pre(s, has_block, &mut base_args);\n+        print_expr(s, func);\n+        word(s.s, ~\".\");\n+        print_ident(s, ident);\n+        if vec::len(tys) > 0u {\n+            word(s.s, ~\"::<\");\n+            commasep(s, inconsistent, tys, print_type);\n+            word(s.s, ~\">\");\n         }\n+        print_call_post(s, has_block, &blk, &mut base_args);\n       }\n       ast::expr_binary(op, lhs, rhs) => {\n         print_expr(s, lhs);"}, {"sha": "bac651ef36c22688a4ff5de80196994c66ce9c06", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f34833abfce74cf178c0589a4b7cf5fba9d2a2db/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f34833abfce74cf178c0589a4b7cf5fba9d2a2db", "patch": "@@ -408,6 +408,11 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         visit_exprs(args, e, v);\n         (v.visit_expr)(callee, e, v);\n       }\n+      expr_method_call(callee, _, tys, args, _) => {\n+        visit_exprs(args, e, v);\n+        for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+        (v.visit_expr)(callee, e, v);\n+      }\n       expr_binary(_, a, b) => {\n         (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v);\n       }"}]}