{"sha": "2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMmYxYzIzOWU1OGM0N2ViOWI5NGJjNjMyOGFmNWYzMzc4Y2ZhNGQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-16T10:34:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-16T10:34:18Z"}, "message": "Rollup merge of #76694 - wesleywiser:partitioning_cx_trait, r=davidtwco\n\nIntroduce a PartitioningCx struct\n\nThis contains all the data used by the partitioning algorithm and allows that data to be used at each stage of the partitioning. This is useful for other approaches to partitioning which may want different pieces of the data available at each step.\n\ncc @rust-lang/wg-incr-comp", "tree": {"sha": "2c24ee1b185505d35dd70c024ce4aafd8b30bffe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c24ee1b185505d35dd70c024ce4aafd8b30bffe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfYeoqCRBK7hj4Ov3rIwAAdHIIAGoXZDTiJJ0uot/eNtKxeGs2\nq6WFMF3AV6hnKpmSysRqonlTG5H98Leud3YQ4fpv355VtKLsQJ+fJIPpSRlk0aU6\nI5G1BC9iuRwjETVNIRVdSoJFBfvGzxCTpeChLMNGSFBrwg/7Wfa0+AUfBMVU1qCY\n049Sla/9uZpoSE2z4Q2CbPELj02xZZjQJh9bQlkQT6TXRZJBA+ViFRAR1nRO0b7O\nJqpBEKAEyjunMv/cUmP/gByf18xkGmBjmeujM25gBrGIY8HFHQV8bxM1WrJ4pE+u\nrMJd2/r4qMj3pI/zZUd9TfoDLZd1utnHWzAmmfMgUzP0O+dUTrv0eKXo6CXuXrU=\n=IetW\n-----END PGP SIGNATURE-----\n", "payload": "tree 2c24ee1b185505d35dd70c024ce4aafd8b30bffe\nparent c8bfbad9edf796f1e7c1b685ae5fb5a1978997a7\nparent c9686cb31ad9dd9428825dbb3b362f5df72ab719\nauthor Dylan DPC <dylan.dpc@gmail.com> 1600252458 +0200\ncommitter GitHub <noreply@github.com> 1600252458 +0200\n\nRollup merge of #76694 - wesleywiser:partitioning_cx_trait, r=davidtwco\n\nIntroduce a PartitioningCx struct\n\nThis contains all the data used by the partitioning algorithm and allows that data to be used at each stage of the partitioning. This is useful for other approaches to partitioning which may want different pieces of the data available at each step.\n\ncc @rust-lang/wg-incr-comp\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "html_url": "https://github.com/rust-lang/rust/commit/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8bfbad9edf796f1e7c1b685ae5fb5a1978997a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8bfbad9edf796f1e7c1b685ae5fb5a1978997a7", "html_url": "https://github.com/rust-lang/rust/commit/c8bfbad9edf796f1e7c1b685ae5fb5a1978997a7"}, {"sha": "c9686cb31ad9dd9428825dbb3b362f5df72ab719", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9686cb31ad9dd9428825dbb3b362f5df72ab719", "html_url": "https://github.com/rust-lang/rust/commit/c9686cb31ad9dd9428825dbb3b362f5df72ab719"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "827d037f3198888888f36188d4470fbb122b2544", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::ty::print::characteristic_def_id_of_type;\n use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n use rustc_span::symbol::Symbol;\n \n+use super::PartitioningCx;\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::partitioning::merging;\n use crate::monomorphize::partitioning::{\n@@ -22,35 +23,36 @@ pub struct DefaultPartitioning;\n impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n     fn place_root_mono_items(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     ) -> PreInliningPartitioning<'tcx> {\n         let mut roots = FxHashSet::default();\n         let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n         let mut internalization_candidates = FxHashSet::default();\n \n         // Determine if monomorphizations instantiated in this crate will be made\n         // available to downstream crates. This depends on whether we are in\n         // share-generics mode and whether the current crate can even have\n         // downstream crates.\n-        let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n+        let export_generics =\n+            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n \n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n         let cgu_name_cache = &mut FxHashMap::default();\n \n         for mono_item in mono_items {\n-            match mono_item.instantiation_mode(tcx) {\n+            match mono_item.instantiation_mode(cx.tcx) {\n                 InstantiationMode::GloballyShared { .. } => {}\n                 InstantiationMode::LocalCopy => continue,\n             }\n \n-            let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n+            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n             let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(\n-                    tcx,\n+                    cx.tcx,\n                     cgu_name_builder,\n                     def_id,\n                     is_volatile,\n@@ -65,7 +67,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n             let mut can_be_internalized = true;\n             let (linkage, visibility) = mono_item_linkage_and_visibility(\n-                tcx,\n+                cx.tcx,\n                 &mono_item,\n                 &mut can_be_internalized,\n                 export_generics,\n@@ -97,17 +99,16 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n     fn merge_codegen_units(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-        target_cgu_count: usize,\n     ) {\n-        merging::merge_codegen_units(tcx, initial_partitioning, target_cgu_count);\n+        merging::merge_codegen_units(cx, initial_partitioning);\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: PreInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) -> PostInliningPartitioning<'tcx> {\n         let mut new_partitioning = Vec::new();\n         let mut mono_item_placements = FxHashMap::default();\n@@ -124,7 +125,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n             // Collect all items that need to be available in this codegen unit.\n             let mut reachable = FxHashSet::default();\n             for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, inlining_map, &mut reachable);\n+                follow_inlining(*root, cx.inlining_map, &mut reachable);\n             }\n \n             let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -198,9 +199,8 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n     fn internalize_symbols(\n         &mut self,\n-        _tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         partitioning: &mut PostInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) {\n         if partitioning.codegen_units.len() == 1 {\n             // Fast path for when there is only one codegen unit. In this case we\n@@ -218,7 +218,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n         // Build a map from every monomorphization to all the monomorphizations that\n         // reference it.\n         let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        inlining_map.iter_accesses(|accessor, accessees| {\n+        cx.inlining_map.iter_accesses(|accessor, accessees| {\n             for accessee in accessees {\n                 accessor_map.entry(*accessee).or_default().push(accessor);\n             }"}, {"sha": "5107e6972632c2d2a295c6e4e8a2608697bacd97", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/merging.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs?ref=2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "patch": "@@ -3,17 +3,16 @@ use std::cmp;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{Symbol, SymbolStr};\n \n+use super::PartitioningCx;\n use crate::monomorphize::partitioning::PreInliningPartitioning;\n \n pub fn merge_codegen_units<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+    cx: &PartitioningCx<'_, 'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    target_cgu_count: usize,\n ) {\n-    assert!(target_cgu_count >= 1);\n+    assert!(cx.target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n     // Note that at this point in time the `codegen_units` here may not be in a\n@@ -32,7 +31,7 @@ pub fn merge_codegen_units<'tcx>(\n         codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n \n     // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > target_cgu_count {\n+    while codegen_units.len() > cx.target_cgu_count {\n         // Sort small cgus to the back\n         codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n         let mut smallest = codegen_units.pop().unwrap();\n@@ -56,9 +55,9 @@ pub fn merge_codegen_units<'tcx>(\n         );\n     }\n \n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n \n-    if tcx.sess.opts.incremental.is_some() {\n+    if cx.tcx.sess.opts.incremental.is_some() {\n         // If we are doing incremental compilation, we want CGU names to\n         // reflect the path of the source level module they correspond to.\n         // For CGUs that contain the code of multiple modules because of the\n@@ -84,7 +83,7 @@ pub fn merge_codegen_units<'tcx>(\n \n         for cgu in codegen_units.iter_mut() {\n             if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+                if cx.tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n                     cgu.set_name(Symbol::intern(&new_cgu_name));\n                 } else {\n                     // If we don't require CGU names to be human-readable, we"}, {"sha": "b60beca688068c8494e5e4211e92bcfd01543463", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs?ref=2c2f1c239e58c47eb9b94bc6328af5f3378cfa4d", "patch": "@@ -108,31 +108,35 @@ use rustc_span::symbol::Symbol;\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n \n+pub struct PartitioningCx<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    target_cgu_count: usize,\n+    inlining_map: &'a InliningMap<'tcx>,\n+}\n+\n trait Partitioner<'tcx> {\n     fn place_root_mono_items(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     ) -> PreInliningPartitioning<'tcx>;\n \n     fn merge_codegen_units(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-        target_cgu_count: usize,\n     );\n \n     fn place_inlined_mono_items(\n         &mut self,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: PreInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) -> PostInliningPartitioning<'tcx>;\n \n     fn internalize_symbols(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         partitioning: &mut PostInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     );\n }\n \n@@ -157,12 +161,13 @@ pub fn partition<'tcx>(\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n     let mut partitioner = get_partitioner(tcx);\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(tcx, mono_items)\n+        partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -172,7 +177,7 @@ pub fn partition<'tcx>(\n     // Merge until we have at most `max_cgu_count` codegen units.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n+        partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n@@ -182,7 +187,7 @@ pub fn partition<'tcx>(\n     // local functions the definition of which is marked with `#[inline]`.\n     let mut post_inlining = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(initial_partitioning, inlining_map)\n+        partitioner.place_inlined_mono_items(cx, initial_partitioning)\n     };\n \n     post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -193,7 +198,7 @@ pub fn partition<'tcx>(\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(tcx, &mut post_inlining, inlining_map);\n+        partitioner.internalize_symbols(cx, &mut post_inlining);\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results."}]}