{"sha": "ed3689d57c988e1dd477930d957c4308c37d1a64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzY4OWQ1N2M5ODhlMWRkNDc3OTMwZDk1N2M0MzA4YzM3ZDFhNjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-05T19:39:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-08T13:36:42Z"}, "message": "remove ctor from ast", "tree": {"sha": "f973731be86f3b4df5adf233bb01cfbd458b6362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f973731be86f3b4df5adf233bb01cfbd458b6362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed3689d57c988e1dd477930d957c4308c37d1a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3689d57c988e1dd477930d957c4308c37d1a64", "html_url": "https://github.com/rust-lang/rust/commit/ed3689d57c988e1dd477930d957c4308c37d1a64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed3689d57c988e1dd477930d957c4308c37d1a64/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c3af1c1ab18632d2e8aa6c3a5fe369e670a471", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c3af1c1ab18632d2e8aa6c3a5fe369e670a471", "html_url": "https://github.com/rust-lang/rust/commit/f5c3af1c1ab18632d2e8aa6c3a5fe369e670a471"}], "stats": {"total": 771, "additions": 120, "deletions": 651}, "files": [{"sha": "ced64daa8d6110a50edd694c74d3886cf07cd242", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -135,7 +135,7 @@ enum def {\n               @def,     // closed over def\n               node_id,  // expr node that creates the closure\n               node_id), // id for the block/body of the closure expr\n-    def_class(def_id, bool /* has constructor */),\n+    def_class(def_id),\n     def_typaram_binder(node_id), /* class, impl or trait that has ty params */\n     def_region(node_id),\n     def_label(node_id)\n@@ -235,9 +235,9 @@ impl def : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            def_class(e0a, e1a) => {\n+            def_class(e0a) => {\n                 match (*other) {\n-                    def_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    def_class(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n@@ -1462,8 +1462,6 @@ type struct_def = {\n     fields: ~[@struct_field], /* fields */\n     methods: ~[@method],    /* methods */\n     /* (not including ctor or dtor) */\n-    /* ctor is optional, and will soon go away */\n-    ctor: Option<class_ctor>,\n     /* dtor is optional */\n     dtor: Option<class_dtor>\n };\n@@ -1563,7 +1561,6 @@ enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n-    ii_ctor(class_ctor, ident, ~[ty_param], def_id /* parent id */),\n     ii_dtor(class_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n "}, {"sha": "8555ceed2dbd62c0923c17e2e25e074d8c68f4ed", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -71,9 +71,6 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    // Constructor for a class\n-    // def_id is parent id\n-    node_ctor(ident, ~[ty_param], @class_ctor, def_id, @path),\n     // Destructor for a class\n     node_dtor(~[ty_param], @class_dtor, def_id, @path),\n     node_block(blk),\n@@ -132,7 +129,7 @@ fn map_decoded_item(diag: span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     match ii {\n-      ii_item(*) | ii_ctor(*) | ii_dtor(*) => { /* fallthrough */ }\n+      ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n                                              @path));\n@@ -155,18 +152,6 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n-      visit::fk_ctor(nm, attrs, tps, self_id, parent_id) => {\n-          let ct = @{node: {id: id,\n-                            attrs: attrs,\n-                            self_id: self_id,\n-                            dec: /* FIXME (#2543) */ copy decl,\n-                            body: /* FIXME (#2543) */ copy body},\n-                    span: sp};\n-          cx.map.insert(id, node_ctor(/* FIXME (#2543) */ copy nm,\n-                                      /* FIXME (#2543) */ copy tps,\n-                                      ct, parent_id,\n-                                      @/* FIXME (#2543) */ copy cx.path));\n-      }\n       visit::fk_dtor(tps, attrs, self_id, parent_id) => {\n           let dt = @{node: {id: id, attrs: attrs, self_id: self_id,\n                      body: /* FIXME (#2543) */ copy body}, span: sp};\n@@ -382,9 +367,6 @@ fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(node_local(_)) => { // add more info here\n         fmt!(\"local (id=%?)\", id)\n       }\n-      Some(node_ctor(*)) => { // add more info here\n-        fmt!(\"node_ctor (id=%?)\", id)\n-      }\n       Some(node_dtor(*)) => { // add more info here\n         fmt!(\"node_dtor (id=%?)\", id)\n       }"}, {"sha": "9e44c42a7027b5f483b4d20b05a832ba9cdecd5a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -57,7 +57,7 @@ pure fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_class(id, _) => {\n+      def_use(id) | def_class(id) => {\n         id\n       }\n       def_arg(id, _) | def_local(id, _) | def_self(id) |\n@@ -339,7 +339,6 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n-          ii_ctor(_, nm, _, _) => /* FIXME (#2543) */ copy nm,\n           ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n         }\n     }\n@@ -349,7 +348,6 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => i.id,\n           ii_foreign(i) => i.id,\n           ii_method(_, m) => m.id,\n-          ii_ctor(ctor, _, _, _) => ctor.node.id,\n           ii_dtor(dtor, _, _, _) => dtor.node.id\n         }\n     }\n@@ -359,9 +357,6 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => v.visit_item(i, e, v),\n           ii_foreign(i) => v.visit_foreign_item(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-          ii_ctor(ctor, nm, tps, parent_id) => {\n-              visit::visit_class_ctor_helper(ctor, nm, tps, parent_id, e, v);\n-          }\n           ii_dtor(dtor, _, tps, parent_id) => {\n               visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);\n           }\n@@ -495,12 +490,6 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(id);\n \n             match fk {\n-                visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n-                    vfn(id);\n-                    vfn(self_id);\n-                    vfn(parent_id.node);\n-                }\n                 visit::fk_dtor(tps, _, self_id, parent_id) => {\n                     for vec::each(tps) |tp| { vfn(tp.id); }\n                     vfn(id);"}, {"sha": "68d9cd80430d3458eb23b7a3f1281168cb5de1da", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -271,23 +271,6 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n \n fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                 -> @ast::struct_def {\n-    let resulting_optional_constructor;\n-    match struct_def.ctor {\n-        None => {\n-            resulting_optional_constructor = None;\n-        }\n-        Some(constructor) => {\n-            resulting_optional_constructor = Some({\n-                node: {\n-                    body: fld.fold_block(constructor.node.body),\n-                    dec: fold_fn_decl(constructor.node.dec, fld),\n-                    id: fld.new_id(constructor.node.id),\n-                    .. constructor.node\n-                },\n-                .. constructor\n-            });\n-        }\n-    }\n     let dtor = do option::map(&struct_def.dtor) |dtor| {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n@@ -298,7 +281,6 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n         traits: vec::map(struct_def.traits, |p| fold_trait_ref(*p, fld)),\n         fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n         methods: vec::map(struct_def.methods, |m| fld.fold_method(*m)),\n-        ctor: resulting_optional_constructor,\n         dtor: dtor\n     };\n }\n@@ -585,7 +567,6 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                                  |f| fld.fold_struct_field(*f)),\n                 methods: vec::map(struct_def.methods,\n                                   |m| fld.fold_method(*m)),\n-                ctor: None,\n                 dtor: dtor\n             })\n         }"}, {"sha": "f2e17c0a7e63cb44ffb03c13a32b5aeca6835315", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -115,8 +115,7 @@ enum class_member {\n   So that we can distinguish a class ctor or dtor\n   from other class members\n  */\n-enum class_contents { ctor_decl(fn_decl, ~[attribute], blk, codemap::span),\n-                      dtor_decl(blk, ~[attribute], codemap::span),\n+enum class_contents { dtor_decl(blk, ~[attribute], codemap::span),\n                       members(~[@class_member]) }\n \n type arg_or_capture_item = Either<arg, capture_item>;\n@@ -2683,30 +2682,13 @@ impl parser {\n \n         let mut fields: ~[@struct_field];\n         let mut methods: ~[@method] = ~[];\n-        let mut the_ctor: Option<(fn_decl, ~[attribute], blk, codemap::span)>\n-            = None;\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n-        let ctor_id = self.get_id();\n \n         if self.eat(token::LBRACE) {\n             // It's a record-like struct.\n             fields = ~[];\n             while self.token != token::RBRACE {\n                 match self.parse_class_item() {\n-                  ctor_decl(a_fn_decl, attrs, blk, s) => {\n-                      match the_ctor {\n-                        Some((_, _, _, s_first)) => {\n-                          self.span_note(s, #fmt(\"Duplicate constructor \\\n-                                     declaration for class %s\",\n-                                     *self.interner.get(class_name)));\n-                           self.span_fatal(copy s_first, ~\"First constructor \\\n-                                                          declared here\");\n-                        }\n-                        None    => {\n-                          the_ctor = Some((a_fn_decl, attrs, blk, s));\n-                        }\n-                      }\n-                  }\n                   dtor_decl(blk, attrs, s) => {\n                       match the_dtor {\n                         Some((_, _, s_first)) => {\n@@ -2764,36 +2746,14 @@ impl parser {\n                     self_id: self.get_id(),\n                     body: d_body},\n              span: d_s}};\n-        match the_ctor {\n-          Some((ct_d, ct_attrs, ct_b, ct_s)) => {\n-            (class_name,\n-             item_class(@{\n-                traits: traits,\n-                fields: move fields,\n-                methods: move methods,\n-                ctor: Some({\n-                 node: {id: ctor_id,\n-                        attrs: ct_attrs,\n-                        self_id: self.get_id(),\n-                        dec: ct_d,\n-                        body: ct_b},\n-                 span: ct_s}),\n-                dtor: actual_dtor\n-             }, ty_params),\n-             None)\n-          }\n-          None => {\n-            (class_name,\n-             item_class(@{\n-                    traits: traits,\n-                    fields: move fields,\n-                    methods: move methods,\n-                    ctor: None,\n-                    dtor: actual_dtor\n-             }, ty_params),\n-             None)\n-          }\n-        }\n+        (class_name,\n+         item_class(@{\n+             traits: traits,\n+             fields: move fields,\n+             methods: move methods,\n+             dtor: actual_dtor\n+         }, ty_params),\n+         None)\n     }\n \n     fn token_is_pound_or_doc_comment(++tok: token::token) -> bool {\n@@ -3097,12 +3057,6 @@ impl parser {\n         let mut methods: ~[@method] = ~[];\n         while self.token != token::RBRACE {\n             match self.parse_class_item() {\n-                ctor_decl(*) => {\n-                    self.span_fatal(copy self.span,\n-                                    ~\"deprecated explicit \\\n-                                      constructors are not allowed \\\n-                                      here\");\n-                }\n                 dtor_decl(blk, attrs, s) => {\n                     match the_dtor {\n                         Some((_, _, s_first)) => {\n@@ -3143,7 +3097,6 @@ impl parser {\n             traits: ~[],\n             fields: move fields,\n             methods: move methods,\n-            ctor: None,\n             dtor: actual_dtor\n         };\n     }"}, {"sha": "b98014f421bb33c94c7cc4cde012a00383e4ea56", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -653,18 +653,6 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n     }\n     bopen(s);\n     hardbreak_if_not_bol(s);\n-    do struct_def.ctor.iter |ctor| {\n-      maybe_print_comment(s, ctor.span.lo);\n-      print_outer_attributes(s, ctor.node.attrs);\n-      // Doesn't call head because there shouldn't be a space after new.\n-      cbox(s, indent_unit);\n-      ibox(s, 4);\n-      word(s.s, ~\"new(\");\n-      print_fn_args(s, ctor.node.dec, ~[], None);\n-      word(s.s, ~\")\");\n-      space(s.s);\n-      print_block(s, ctor.node.body);\n-    }\n     do struct_def.dtor.iter |dtor| {\n       hardbreak_if_not_bol(s);\n       maybe_print_comment(s, dtor.span.lo);"}, {"sha": "50fbd21f7b8dc0269d9abd966a3ecc94ef2ea347", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -17,29 +17,28 @@ enum fn_kind {\n     fk_method(ident, ~[ty_param], @method),\n     fk_anon(proto, capture_clause),  //< an anonymous function like fn@(...)\n     fk_fn_block(capture_clause),     //< a block {||...}\n-    fk_ctor(ident, ~[attribute], ~[ty_param], node_id /* self id */,\n-            def_id /* parent class id */), // class constructor\n     fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n }\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     match fk {\n-      fk_item_fn(name, _, _) | fk_method(name, _, _)\n-          | fk_ctor(name, _, _, _, _) =>  /* FIXME (#2543) */ copy name,\n+      fk_item_fn(name, _, _) | fk_method(name, _, _) => {\n+          /* FIXME (#2543) */ copy name\n+      }\n       fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n       fk_dtor(*)                  => parse::token::special_idents::dtor\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     match fk {\n-      fk_item_fn(_, tps, _) | fk_method(_, tps, _)\n-          | fk_ctor(_, _, tps, _, _) | fk_dtor(tps, _, _, _) => {\n-          /* FIXME (#2543) */ copy tps\n-      }\n-      fk_anon(*) | fk_fn_block(*) => ~[]\n+        fk_item_fn(_, tps, _) | fk_method(_, tps, _) |\n+        fk_dtor(tps, _, _, _) => {\n+            /* FIXME (#2543) */ copy tps\n+        }\n+        fk_anon(*) | fk_fn_block(*) => ~[]\n     }\n }\n \n@@ -291,17 +290,6 @@ fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n-// Similar logic to the comment on visit_method_helper - Tim\n-fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: ~[ty_param],\n-                              parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_ctor(/* FIXME (#2543) */ copy nm,\n-                       ctor.node.attrs,\n-                       /* FIXME (#2543) */ copy tps,\n-                       ctor.node.self_id, parent_id),\n-        ctor.node.dec, ctor.node.body, ctor.span, ctor.node.id, e, v)\n-\n-}\n-\n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: ~[ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n     v.visit_fn(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n@@ -330,7 +318,7 @@ fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n+fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n                        id: node_id, e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n         v.visit_struct_field(*f, e, v);\n@@ -341,9 +329,6 @@ fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n     for sd.traits.each |p| {\n         visit_path(p.path, e, v);\n     }\n-    do option::iter(&sd.ctor) |ctor| {\n-      visit_class_ctor_helper(*ctor, nm, tps, ast_util::local_def(id), e, v);\n-    };\n     do option::iter(&sd.dtor) |dtor| {\n       visit_class_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n     };"}, {"sha": "70a47522f37932ed83e6252fb0630f0a59254f2e", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -123,7 +123,6 @@ enum Family {\n     Variant,               // v\n     Impl,                  // i\n     Trait,                 // I\n-    Class,                 // C\n     Struct,                // S\n     PublicField,           // g\n     PrivateField,          // j\n@@ -156,7 +155,6 @@ fn item_family(item: ebml2::Doc) -> Family {\n       'v' => Variant,\n       'i' => Impl,\n       'I' => Trait,\n-      'C' => Class,\n       'S' => Struct,\n       'g' => PublicField,\n       'j' => PrivateField,\n@@ -300,8 +298,7 @@ fn item_to_def_like(item: ebml2::Doc, did: ast::def_id, cnum: ast::crate_num)\n     let fam = item_family(item);\n     match fam {\n       Const     => dl_def(ast::def_const(did)),\n-      Class     => dl_def(ast::def_class(did, true)),\n-      Struct    => dl_def(ast::def_class(did, false)),\n+      Struct    => dl_def(ast::def_class(did)),\n       UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n       Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n       PureFn    => dl_def(ast::def_fn(did, ast::pure_fn)),\n@@ -822,7 +819,6 @@ fn item_family_to_str(fam: Family) -> ~str {\n       Variant => ~\"variant\",\n       Impl => ~\"impl\",\n       Trait => ~\"trait\",\n-      Class => ~\"class\",\n       Struct => ~\"struct\",\n       PublicField => ~\"public field\",\n       PrivateField => ~\"private field\","}, {"sha": "ce3f50e71842c2ba1aa528e32dead79bb86779a2", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -635,12 +635,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-\n-        match struct_def.ctor {\n-            None => encode_family(ebml_w, 'S'),\n-            Some(_) => encode_family(ebml_w, 'C')\n-        }\n-\n+        encode_family(ebml_w, 'S');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n@@ -699,21 +694,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n-\n-        /* Encode the constructor */\n-        for struct_def.ctor.each |ctor| {\n-            debug!(\"encoding info for ctor %s %d\",\n-                   ecx.tcx.sess.str_of(item.ident), ctor.node.id);\n-            index.push({\n-                val: ctor.node.id,\n-                pos: ebml_w.writer.tell()\n-            });\n-            encode_info_for_ctor(ecx, ebml_w, ctor.node.id, item.ident,\n-                                 path, if tps.len() > 0u {\n-                                     Some(ii_ctor(*ctor, item.ident, tps,\n-                                                  local_def(item.id))) }\n-                                 else { None }, tps);\n-        }\n       }\n       item_impl(tps, opt_trait, _, methods) => {\n         add_to_index();"}, {"sha": "95c3d08f60e500f61b80a8ff627bb02663cd5bcc", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -262,13 +262,6 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_ctor(ctor, nm, tps, parent_id) => {\n-        let ctor_body = fld.fold_block(ctor.node.body);\n-        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n-        ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl,\n-                              .. ctor.node},\n-            .. ctor}, nm, tps, parent_id)\n-      }\n       ast::ii_dtor(dtor, nm, tps, parent_id) => {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         ast::ii_dtor({node: {body: dtor_body,\n@@ -302,18 +295,6 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_ctor(ctor, nm, tps, parent_id) => {\n-        let ctor_body = fld.fold_block(ctor.node.body);\n-        let ctor_attrs = fld.fold_attributes(ctor.node.attrs);\n-        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n-        let new_params = fold::fold_ty_params(tps, fld);\n-        let ctor_id = fld.new_id(ctor.node.id);\n-        let new_parent = xcx.tr_def_id(parent_id);\n-        ast::ii_ctor({node: {body: ctor_body, attrs: ctor_attrs,\n-                dec: ctor_decl, id: ctor_id,\n-                              .. ctor.node},\n-            .. ctor}, nm, new_params, new_parent)\n-      }\n       ast::ii_dtor(dtor, nm, tps, parent_id) => {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_attrs = fld.fold_attributes(dtor.node.attrs);\n@@ -369,8 +350,8 @@ impl ast::def: tr {\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::def_class(did, has_constructor) => {\n-            ast::def_class(did.tr(xcx), has_constructor)\n+          ast::def_class(did) => {\n+            ast::def_class(did.tr(xcx))\n           }\n           ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n           ast::def_typaram_binder(nid) => {"}, {"sha": "6a9195b45096b55417c791a2c689afe5b88c2c50", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -17,10 +17,6 @@ enum check_loan_ctxt = @{\n \n     reported: HashMap<ast::node_id, ()>,\n \n-    // Keep track of whether we're inside a ctor, so as to\n-    // allow mutating immutable fields in the same class if\n-    // we are in a ctor, we track the self id\n-    mut in_ctor: bool,\n     mut declared_purity: ast::purity,\n     mut fn_args: @~[ast::node_id]\n };\n@@ -62,7 +58,6 @@ fn check_loans(bccx: borrowck_ctxt,\n     let clcx = check_loan_ctxt(@{bccx: bccx,\n                                  req_maps: req_maps,\n                                  reported: HashMap(),\n-                                 mut in_ctor: false,\n                                  mut declared_purity: ast::impure_fn,\n                                  mut fn_args: @~[]});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n@@ -320,10 +315,7 @@ impl check_loan_ctxt {\n         debug!(\"check_assignment(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt));\n \n-        if self.in_ctor && self.is_self_field(cmt)\n-            && at.checked_by_liveness() {\n-            // assigning to self.foo in a ctor is always allowed.\n-        } else if self.is_local_variable(cmt) && at.checked_by_liveness() {\n+        if self.is_local_variable(cmt) && at.checked_by_liveness() {\n             // liveness guarantees that immutable local variables\n             // are only assigned once\n         } else {\n@@ -542,42 +534,28 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n-    do save_and_restore(&mut(self.in_ctor)) {\n-        do save_and_restore(&mut(self.declared_purity)) {\n-            do save_and_restore(&mut(self.fn_args)) {\n-                let is_stack_closure = self.is_stack_closure(id);\n-                let fty = ty::node_id_to_type(self.tcx(), id);\n-                self.declared_purity = ty::determine_inherited_purity(\n-                    copy self.declared_purity,\n-                    ty::ty_fn_purity(fty),\n-                    ty::ty_fn_proto(fty));\n-\n-                // In principle, we could consider fk_anon(*) or\n-                // fk_fn_block(*) to be in a ctor, I suppose, but the\n-                // purpose of the in_ctor flag is to allow modifications\n-                // of otherwise immutable fields and typestate wouldn't be\n-                // able to \"see\" into those functions anyway, so it\n-                // wouldn't be very helpful.\n-                match fk {\n-                  visit::fk_ctor(*) => {\n-                    self.in_ctor = true;\n-                    self.fn_args = @decl.inputs.map(|i| i.id );\n-                  }\n-                  visit::fk_anon(*) |\n-                  visit::fk_fn_block(*) if is_stack_closure => {\n-                    self.in_ctor = false;\n+    do save_and_restore(&mut(self.declared_purity)) {\n+        do save_and_restore(&mut(self.fn_args)) {\n+            let is_stack_closure = self.is_stack_closure(id);\n+            let fty = ty::node_id_to_type(self.tcx(), id);\n+            self.declared_purity = ty::determine_inherited_purity(\n+                copy self.declared_purity,\n+                ty::ty_fn_purity(fty),\n+                ty::ty_fn_proto(fty));\n+\n+            match fk {\n+                visit::fk_anon(*) |\n+                visit::fk_fn_block(*) if is_stack_closure => {\n                     // inherits the fn_args from enclosing ctxt\n-                  }\n-                  visit::fk_anon(*) | visit::fk_fn_block(*) |\n-                  visit::fk_method(*) | visit::fk_item_fn(*) |\n-                  visit::fk_dtor(*) => {\n-                    self.in_ctor = false;\n+                }\n+                visit::fk_anon(*) | visit::fk_fn_block(*) |\n+                visit::fk_method(*) | visit::fk_item_fn(*) |\n+                visit::fk_dtor(*) => {\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n-                  }\n                 }\n-\n-                visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n             }\n+\n+            visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n         }\n     }\n     debug!(\"purity on exit=%?\", copy self.declared_purity);"}, {"sha": "2a23ec86c51414dca2613d7f270728d7f78d3782", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -71,11 +71,11 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n     self.root_ub = body.node.id;\n \n     match fk {\n-      visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n-      visit::fk_item_fn(*) | visit::fk_method(*) |\n-      visit::fk_ctor(*) | visit::fk_dtor(*) => {\n-        self.item_ub = body.node.id;\n-      }\n+        visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n+        visit::fk_item_fn(*) | visit::fk_method(*) |\n+        visit::fk_dtor(*) => {\n+            self.item_ub = body.node.id;\n+        }\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, self, v);"}, {"sha": "7b473cedb4c51e56cdd9a876b766bc931f84d15b", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -181,9 +181,9 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n         // variables.  This list is used below to avoid checking and reporting\n         // on a given variable twice.\n         let cap_clause = match fk {\n-          visit::fk_anon(_, cc) | visit::fk_fn_block(cc) => cc,\n-          visit::fk_item_fn(*) | visit::fk_method(*) |\n-          visit::fk_ctor(*) | visit::fk_dtor(*) => @~[]\n+            visit::fk_anon(_, cc) | visit::fk_fn_block(cc) => cc,\n+            visit::fk_item_fn(*) | visit::fk_method(*) |\n+            visit::fk_dtor(*) => @~[]\n         };\n         let captured_vars = do (*cap_clause).map |cap_item| {\n             let cap_def = cx.tcx.def_map.get(cap_item.id);"}, {"sha": "86f786e7706ff560d3c345aad6fbfc13d0258816", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 29, "deletions": 173, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -35,12 +35,6 @@\n  * Any use of the variable where the variable is dead afterwards is a\n  * last use.\n  *\n- * # Extension to handle constructors\n- *\n- * Each field is assigned an index just as with local variables.  A use of\n- * `self` is considered a use of all fields.  A use of `self.f` is just a use\n- * of `f`.\n- *\n  * # Implementation details\n  *\n  * The actual implementation contains two (nested) walks over the AST.\n@@ -96,8 +90,6 @@\n  * - `no_ret_var`: a synthetic variable that is only 'read' from, the\n  *   fallthrough node.  This allows us to detect functions where we fail\n  *   to return explicitly.\n- *\n- * - `self_var`: a variable representing 'self'\n  */\n \n use dvec::DVec;\n@@ -230,7 +222,7 @@ impl LiveNode {\n \n fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n \n-enum RelevantDef { RelevantVar(node_id), RelevantSelf }\n+enum RelevantDef { RelevantVar(node_id) }\n \n type CaptureInfo = {ln: LiveNode, is_move: bool, rv: RelevantDef};\n \n@@ -250,15 +242,12 @@ struct LocalInfo {\n enum VarKind {\n     Arg(node_id, ident, rmode),\n     Local(LocalInfo),\n-    Field(ident),\n     Self,\n     ImplicitRet\n }\n \n fn relevant_def(def: def) -> Option<RelevantDef> {\n     match def {\n-      def_self(_) => Some(RelevantSelf),\n-\n       def_binding(nid, _) |\n       def_arg(nid, _) |\n       def_local(nid, _) => Some(RelevantVar(nid)),\n@@ -276,7 +265,6 @@ struct IrMaps {\n     mut num_vars: uint,\n     live_node_map: HashMap<node_id, LiveNode>,\n     variable_map: HashMap<node_id, Variable>,\n-    field_map: HashMap<ident, Variable>,\n     capture_map: HashMap<node_id, @~[CaptureInfo]>,\n     mut var_kinds: ~[VarKind],\n     mut lnks: ~[LiveNodeKind],\n@@ -293,7 +281,6 @@ fn IrMaps(tcx: ty::ctxt, method_map: typeck::method_map,\n         live_node_map: HashMap(),\n         variable_map: HashMap(),\n         capture_map: HashMap(),\n-        field_map: HashMap(),\n         var_kinds: ~[],\n         lnks: ~[]\n     }\n@@ -323,15 +310,12 @@ impl IrMaps {\n         self.num_vars += 1u;\n \n         match vk {\n-          Local(LocalInfo {id:node_id, _}) |\n-          Arg(node_id, _, _) => {\n-            self.variable_map.insert(node_id, v);\n-          }\n-          Field(name) => {\n-            self.field_map.insert(name, v);\n-          }\n-          Self | ImplicitRet => {\n-          }\n+            Local(LocalInfo {id:node_id, _}) |\n+            Arg(node_id, _, _) => {\n+                self.variable_map.insert(node_id, v);\n+            }\n+            Self | ImplicitRet => {\n+            }\n         }\n \n         debug!(\"%s is %?\", v.to_str(), vk);\n@@ -351,11 +335,10 @@ impl IrMaps {\n \n     fn variable_name(var: Variable) -> ~str {\n         match copy self.var_kinds[*var] {\n-          Local(LocalInfo {ident: nm, _}) |\n-          Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n-          Field(nm) => ~\"self.\" + self.tcx.sess.str_of(nm),\n-          Self => ~\"self\",\n-          ImplicitRet => ~\"<implicit-ret>\"\n+            Local(LocalInfo {ident: nm, _}) |\n+            Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n+            Self => ~\"self\",\n+            ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n@@ -399,7 +382,7 @@ impl IrMaps {\n             (*v).push(id);\n           }\n           Arg(_, _, by_ref) |\n-          Arg(_, _, by_val) | Self | Field(_) | ImplicitRet |\n+          Arg(_, _, by_val) | Self | ImplicitRet |\n           Local(LocalInfo {kind: FromMatch(bind_by_implicit_ref), _}) => {\n             debug!(\"--but it is not owned\");\n           }\n@@ -428,22 +411,14 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     // and so forth:\n     visit::visit_fn(fk, decl, body, sp, id, fn_maps, v);\n \n-    match fk {\n-      visit::fk_ctor(_, _, _, _, class_did) => {\n-        add_class_fields(fn_maps, class_did);\n-      }\n-      _ => {}\n-    }\n-\n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n     // - implicit_ret_var is a pseudo-variable that represents\n     //   an implicit return\n     let specials = {\n         exit_ln: (*fn_maps).add_live_node(ExitNode),\n         fallthrough_ln: (*fn_maps).add_live_node(ExitNode),\n-        no_ret_var: (*fn_maps).add_variable(ImplicitRet),\n-        self_var: (*fn_maps).add_variable(Self)\n+        no_ret_var: (*fn_maps).add_variable(ImplicitRet)\n     };\n \n     // compute liveness\n@@ -460,18 +435,9 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     });\n     check_vt.visit_block(body, lsets, check_vt);\n     lsets.check_ret(id, sp, fk, entry_ln);\n-    lsets.check_fields(sp, entry_ln);\n     lsets.warn_about_unused_args(sp, decl, entry_ln);\n }\n \n-fn add_class_fields(self: @IrMaps, did: def_id) {\n-    for ty::lookup_class_fields(self.tcx, did).each |field_ty| {\n-        assert field_ty.id.crate == local_crate;\n-        let var = self.add_variable(Field(field_ty.ident));\n-        self.field_map.insert(field_ty.ident, var);\n-    }\n-}\n-\n fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n@@ -595,8 +561,7 @@ fn invalid_users() -> users {\n type Specials = {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n-    no_ret_var: Variable,\n-    self_var: Variable\n+    no_ret_var: Variable\n };\n \n const ACC_READ: uint = 1u;\n@@ -649,7 +614,6 @@ impl Liveness {\n \n     fn variable_from_rdef(rv: RelevantDef, span: span) -> Variable {\n         match rv {\n-          RelevantSelf => self.s.self_var,\n           RelevantVar(nid) => self.variable(nid, span)\n         }\n     }\n@@ -934,14 +898,6 @@ impl Liveness {\n             }\n         }\n \n-        // as above, the \"self\" variable is a non-owned variable\n-        self.acc(self.s.exit_ln, self.s.self_var, ACC_READ);\n-\n-        // in a ctor, there is an implicit use of self.f for all fields f:\n-        for self.ir.field_map.each_value |var| {\n-            self.acc(self.s.exit_ln, var, ACC_READ|ACC_USE);\n-        }\n-\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -1023,24 +979,11 @@ impl Liveness {\n           // Interesting cases with control flow or which gen/kill\n \n           expr_path(_) => {\n-            self.access_path(expr, succ, ACC_READ | ACC_USE)\n+              self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          expr_field(e, nm, _) => {\n-            // If this is a reference to `self.f` inside of a ctor,\n-            // then we treat it as a read of that variable.\n-            // Otherwise, we ignore it and just propagate down to\n-            // process `e`.\n-            match self.as_self_field(e, nm) {\n-              Some((ln, var)) => {\n-                self.init_from_succ(ln, succ);\n-                self.acc(ln, var, ACC_READ | ACC_USE);\n-                ln\n-              }\n-              None => {\n-                self.propagate_through_expr(e, succ)\n-              }\n-            }\n+          expr_field(e, _, _) => {\n+              self.propagate_through_expr(e, succ)\n           }\n \n           expr_fn(*) | expr_fn_block(*) => {\n@@ -1269,8 +1212,8 @@ impl Liveness {\n         // In general, the full flow graph structure for an\n         // assignment/move/etc can be handled in one of two ways,\n         // depending on whether what is being assigned is a \"tracked\n-        // value\" or not. A tracked value is basically a local variable\n-        // or argument, or a self-field (`self.f`) in a ctor.\n+        // value\" or not. A tracked value is basically a local\n+        // variable or argument.\n         //\n         // The two kinds of graphs are:\n         //\n@@ -1293,12 +1236,11 @@ impl Liveness {\n         //\n         // # Tracked lvalues\n         //\n-        // A tracked lvalue is either a local variable/argument `x` or\n-        // else it is a self-field `self.f` in a constructor.  In\n+        // A tracked lvalue is a local variable/argument `x`.  In\n         // these cases, the link_node where the write occurs is linked\n-        // to node id of `x` or `self`, respectively.  The\n-        // `write_lvalue()` routine generates the contents of this\n-        // node.  There are no subcomponents to consider.\n+        // to node id of `x`.  The `write_lvalue()` routine generates\n+        // the contents of this node.  There are no subcomponents to\n+        // consider.\n         //\n         // # Non-tracked lvalues\n         //\n@@ -1315,12 +1257,9 @@ impl Liveness {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-          expr_path(_) => succ,\n-          expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n-            Some(_) => succ,\n-            None => self.propagate_through_expr(e, succ)\n-          },\n-          _ => self.propagate_through_expr(expr, succ)\n+            expr_path(_) => succ,\n+            expr_field(e, _, _) => self.propagate_through_expr(e, succ),\n+            _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n \n@@ -1330,14 +1269,6 @@ impl Liveness {\n                     acc: uint) -> LiveNode {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n-          expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n-            Some((ln, var)) => {\n-                self.init_from_succ(ln, succ);\n-                self.acc(ln, var, acc);\n-                ln\n-            }\n-            None => succ\n-          },\n \n           // We do not track other lvalues, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n@@ -1350,26 +1281,6 @@ impl Liveness {\n     fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n         let def = self.tcx.def_map.get(expr.id);\n         match relevant_def(def) {\n-          Some(RelevantSelf) => {\n-            // Accessing `self` is like accessing every field of\n-            // the current object. This allows something like\n-            // `self = ...;` (it will be considered a write to\n-            // every field, sensibly enough), though the borrowck\n-            // pass will reject it later on.\n-            //\n-            // Also, note that, within a ctor at least, an\n-            // expression like `self.f` is \"shortcircuiting\"\n-            // before it reaches this point by the code for\n-            // expr_field.\n-            let ln = self.live_node(expr.id, expr.span);\n-            if acc != 0u {\n-                self.init_from_succ(ln, succ);\n-                for self.ir.field_map.each_value |var| {\n-                    self.acc(ln, var, acc);\n-                }\n-            }\n-            ln\n-          }\n           Some(RelevantVar(nid)) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1383,29 +1294,6 @@ impl Liveness {\n         }\n     }\n \n-    fn as_self_field(expr: @expr,\n-                     fld: ident) -> Option<(LiveNode,Variable)> {\n-        // If we checking a constructor, then we treat self.f as a\n-        // variable.  we use the live_node id that will be assigned to\n-        // the reference to self but the variable id for `f`.\n-        match expr.node {\n-          expr_path(_) => {\n-            let def = self.tcx.def_map.get(expr.id);\n-            match def {\n-              def_self(_) => {\n-                // Note: the field_map is empty unless we are in a ctor\n-                return self.ir.field_map.find(fld).map(|var| {\n-                    let ln = self.live_node(expr.id, expr.span);\n-                    (ln, *var)\n-                });\n-              }\n-              _ => return None\n-            }\n-          }\n-          _ => return None\n-        }\n-    }\n-\n     fn propagate_through_loop(expr: @expr,\n                               cond: Option<@expr>,\n                               body: blk,\n@@ -1613,24 +1501,7 @@ enum ReadKind {\n }\n \n impl @Liveness {\n-    fn check_fields(sp: span, entry_ln: LiveNode) {\n-        for self.ir.field_map.each |nm, var| {\n-            match self.live_on_entry(entry_ln, var) {\n-              None => { /* ok */ }\n-              Some(ExitNode) => {\n-                self.tcx.sess.span_err(\n-                    sp, fmt!(\"field `self.%s` is never initialized\",\n-                             self.tcx.sess.str_of(nm)));\n-              }\n-              Some(lnk) => {\n-                self.report_illegal_read(\n-                    sp, lnk, var, PossiblyUninitializedField);\n-              }\n-            }\n-        }\n-    }\n-\n-    fn check_ret(id: node_id, sp: span, fk: visit::fn_kind,\n+    fn check_ret(id: node_id, sp: span, _fk: visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1644,15 +1515,8 @@ impl @Liveness {\n                 self.tcx.sess.span_err(\n                     sp, ~\"some control paths may return\");\n             } else {\n-                match fk {\n-                  visit::fk_ctor(*) => {\n-                    // ctors are written as though they are unit.\n-                  }\n-                  _ => {\n-                    self.tcx.sess.span_err(\n-                        sp, ~\"not all control paths return a value\");\n-                  }\n-                }\n+                self.tcx.sess.span_err(\n+                    sp, ~\"not all control paths return a value\");\n             }\n         }\n     }\n@@ -1737,7 +1601,6 @@ impl @Liveness {\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, ln, var);\n                   }\n-                  Some(RelevantSelf) => {}\n                   None => {}\n                 }\n               }\n@@ -1796,13 +1659,6 @@ impl @Liveness {\n                           copy or move mode\", self.tcx.sess.str_of(name)));\n                 return;\n               }\n-              Field(name) => {\n-                self.tcx.sess.span_err(\n-                    move_span,\n-                    fmt!(\"illegal move from field `%s`\",\n-                         self.tcx.sess.str_of(name)));\n-                return;\n-              }\n               Self => {\n                 self.tcx.sess.span_err(\n                     move_span,"}, {"sha": "eb0bf8796f0755f6e135ae35415738de04e43c68", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -305,16 +305,16 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n               visitor: visit::vt<ctxt>) {\n \n     let fn_cx = match fk {\n-      visit::fk_item_fn(*) | visit::fk_method(*) |\n-      visit::fk_ctor(*) | visit::fk_dtor(*) => {\n-        // Top-level functions are a root scope.\n-        ctxt {parent: Some(id),.. cx}\n-      }\n+        visit::fk_item_fn(*) | visit::fk_method(*) |\n+        visit::fk_dtor(*) => {\n+            // Top-level functions are a root scope.\n+            ctxt {parent: Some(id),.. cx}\n+        }\n \n-      visit::fk_anon(*) | visit::fk_fn_block(*) => {\n-        // Closures continue with the inherited scope.\n-        cx\n-      }\n+        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+            // Closures continue with the inherited scope.\n+            cx\n+        }\n     };\n \n     debug!(\"visiting fn with body %d. cx.parent: %? \\\n@@ -641,7 +641,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     match ty.node {\n       ast::ty_path(path, id) => {\n         match cx.def_map.get(id) {\n-          ast::def_ty(did) | ast::def_class(did, _) => {\n+          ast::def_ty(did) | ast::def_class(did) => {\n             if did.crate == ast::local_crate {\n                 if cx.opt_region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);"}, {"sha": "b455cc257ef14babe2ba5fc4df3078eb9a79d51a", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 64, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -757,7 +757,7 @@ struct Resolver {\n     unused_import_lint_level: level,\n \n     trait_info: HashMap<def_id,@HashMap<ident,()>>,\n-    structs: HashMap<def_id,bool>,\n+    structs: HashMap<def_id,()>,\n \n     // The number of imports that are currently unresolved.\n     mut unresolved_imports: uint,\n@@ -1069,36 +1069,15 @@ impl Resolver {\n             }\n \n             // These items live in both the type and value namespaces.\n-            item_class(struct_definition, _) => {\n-                let new_parent =\n-                    match struct_definition.ctor {\n-                    None => {\n-                        let (name_bindings, new_parent) =\n-                            self.add_child(ident, parent, ~[TypeNS], sp);\n+            item_class(*) => {\n+                let (name_bindings, new_parent) =\n+                    self.add_child(ident, parent, ~[TypeNS], sp);\n \n-                        (*name_bindings).define_type\n-                            (privacy, def_ty(local_def(item.id)), sp);\n-                        new_parent\n-                    }\n-                    Some(ctor) => {\n-                        let (name_bindings, new_parent) =\n-                            self.add_child(ident, parent, ~[ValueNS, TypeNS],\n-                                           sp);\n-\n-                        (*name_bindings).define_type\n-                            (privacy, def_ty(local_def(item.id)), sp);\n-\n-                        let purity = impure_fn;\n-                        let ctor_def = def_fn(local_def(ctor.node.id),\n-                                              purity);\n-                        (*name_bindings).define_value(privacy, ctor_def, sp);\n-                        new_parent\n-                    }\n-                };\n+                (*name_bindings).define_type\n+                    (privacy, def_ty(local_def(item.id)), sp);\n \n                 // Record the def ID of this struct.\n-                self.structs.insert(local_def(item.id),\n-                                    struct_definition.ctor.is_some());\n+                self.structs.insert(local_def(item.id), ());\n \n                 visit_item(item, new_parent, visitor);\n             }\n@@ -1183,7 +1162,7 @@ impl Resolver {\n                                      def_variant(item_id,\n                                                  local_def(variant.node.id)),\n                                      variant.span);\n-                self.structs.insert(local_def(variant.node.id), false);\n+                self.structs.insert(local_def(variant.node.id), ());\n             }\n             enum_variant_kind(enum_definition) => {\n                 (*child).define_type(privacy,\n@@ -1520,18 +1499,12 @@ impl Resolver {\n \n             child_name_bindings.define_type(Public, def, dummy_sp());\n           }\n-          def_class(def_id, has_constructor) => {\n+          def_class(def_id) => {\n             debug!(\"(building reduced graph for external \\\n-                    crate) building type %s (value? %d)\",\n-                   final_ident,\n-                   if has_constructor { 1 } else { 0 });\n+                    crate) building type %s\",\n+                   final_ident);\n             child_name_bindings.define_type(Public, def, dummy_sp());\n-\n-            if has_constructor {\n-                child_name_bindings.define_value(Public, def, dummy_sp());\n-            }\n-\n-            self.structs.insert(def_id, has_constructor);\n+            self.structs.insert(def_id, ());\n           }\n           def_self(*) | def_arg(*) | def_local(*) |\n           def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n@@ -3306,7 +3279,6 @@ impl Resolver {\n                                    struct_def.traits,\n                                    struct_def.fields,\n                                    struct_def.methods,\n-                                   struct_def.ctor,\n                                    struct_def.dtor,\n                                    visitor);\n             }\n@@ -3548,7 +3520,6 @@ impl Resolver {\n                      traits: ~[@trait_ref],\n                      fields: ~[@struct_field],\n                      methods: ~[@method],\n-                     optional_constructor: Option<class_ctor>,\n                      optional_destructor: Option<class_dtor>,\n                      visitor: ResolveVisitor) {\n \n@@ -3600,23 +3571,6 @@ impl Resolver {\n                 self.resolve_type(field.node.ty, visitor);\n             }\n \n-            // Resolve the constructor, if applicable.\n-            match optional_constructor {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(constructor) => {\n-                    self.resolve_function(NormalRibKind,\n-                                          Some(@constructor.node.dec),\n-                                          NoTypeParameters,\n-                                          constructor.node.body,\n-                                          HasSelfBinding(constructor.node.\n-                                                         self_id),\n-                                          NoCaptureClause,\n-                                          visitor);\n-                }\n-            }\n-\n             // Resolve the destructor, if applicable.\n             match optional_destructor {\n                 None => {\n@@ -4089,9 +4043,7 @@ impl Resolver {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains_key(class_id) => {\n-                            let has_constructor = self.structs.get(class_id);\n-                            let class_def = def_class(class_id,\n-                                                      has_constructor);\n+                            let class_def = def_class(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n                         Some(definition @ def_variant(_, variant_id))\n@@ -4559,10 +4511,9 @@ impl Resolver {\n                 //    let bar = Bar { ... } // no type parameters\n \n                 match self.resolve_path(path, TypeNS, false, visitor) {\n-                    Some(def_ty(class_id)) | Some(def_class(class_id, _))\n+                    Some(def_ty(class_id)) | Some(def_class(class_id))\n                             if self.structs.contains_key(class_id) => {\n-                        let has_constructor = self.structs.get(class_id);\n-                        let class_def = def_class(class_id, has_constructor);\n+                        let class_def = def_class(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))"}, {"sha": "c605fe398734b1dbbdb8d36ed711918eacf73a4f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 75, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -1596,18 +1596,14 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-\n-    if !ccx.class_ctors.contains_key(id) // hack --\n-       /* avoids the need for special cases to assign a type to\n-          the constructor body (since it has no explicit return) */\n-      &&\n-      (body.node.expr.is_none() ||\n-       ty::type_is_bot(block_ty) ||\n-       ty::type_is_nil(block_ty))  {\n+    if body.node.expr.is_none() || ty::type_is_bot(block_ty) ||\n+        ty::type_is_nil(block_ty)\n+    {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n         bcx = controlflow::trans_block(bcx, body, expr::SaveIn(fcx.llretptr));\n     }\n+\n     finish(bcx);\n     cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n \n@@ -1698,60 +1694,6 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n-                    body: ast::blk, llctor_decl: ValueRef,\n-                    psubsts: param_substs, ctor_id: ast::node_id,\n-                    parent_id: ast::def_id, sp: span) {\n-    // Add ctor to the ctor map\n-    ccx.class_ctors.insert(ctor_id, parent_id);\n-\n-    // Translate the ctor\n-\n-    // Set up the type for the result of the ctor\n-    // kludgy -- this wouldn't be necessary if the typechecker\n-    // special-cased constructors, then we could just look up\n-    // the ctor's return type.\n-    let rslt_ty =  ty::mk_class(ccx.tcx, parent_id,\n-                                dummy_substs(psubsts.tys));\n-\n-    // Make the fn context\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n-                               Some(psubsts), Some(sp));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n-    let mut bcx_top = top_scope_block(fcx, body.info());\n-    let lltop = bcx_top.llbb;\n-    let arg_tys = ty::ty_fn_args(node_id_type(bcx_top, ctor_id));\n-    bcx_top = copy_args_to_allocas(fcx, bcx_top, decl.inputs,\n-                                   raw_llargs, arg_tys);\n-\n-    // Create a temporary for `self` that we will return at the end\n-    let selfdatum = datum::scratch_datum(bcx_top, rslt_ty, true);\n-\n-    // Initialize dtor flag (if any) to 1\n-    if ty::ty_dtor(bcx_top.tcx(), parent_id).is_some() {\n-        let flag = GEPi(bcx_top, selfdatum.val, [0, 1]);\n-        Store(bcx_top, C_u8(1), flag);\n-    }\n-\n-    // initialize fields to zero\n-    let mut bcx = bcx_top;\n-\n-    // note we don't want to take *or* drop self.\n-    fcx.llself = Some(ValSelfData {v: selfdatum.val,\n-                                   t: rslt_ty,\n-                                   is_owned: false});\n-\n-    // Translate the body of the ctor\n-    bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n-\n-    // Generate the return expression\n-    bcx = selfdatum.move_to(bcx, datum::INIT, fcx.llretptr);\n-\n-    cleanup_and_leave(bcx, None, Some(fcx.llreturn));\n-    Unreachable(bcx);\n-    finish_fn(fcx, lltop);\n-}\n-\n fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n     body: ast::blk, dtor_id: ast::node_id,\n     psubsts: Option<param_substs>,\n@@ -1921,14 +1863,6 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                     tps: ~[ast::ty_param], path: @ast_map::path,\n                     ident: ast::ident, id: ast::node_id) {\n     if tps.len() == 0u {\n-      let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n-                     vtables: None,\n-                     bounds: @~[]};\n-      do option::iter(&struct_def.ctor) |ctor| {\n-        trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n-                         get_item_val(ccx, ctor.node.id), psubsts,\n-                         ctor.node.id, local_def(id), ctor.span);\n-      }\n       do option::iter(&struct_def.dtor) |dtor| {\n          trans_class_dtor(ccx, *path, dtor.node.body,\n            dtor.node.id, None, None, local_def(id));\n@@ -2184,10 +2118,6 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 }\n             }\n           }\n-          ast_map::node_ctor(nm, _, ctor, _, pt) => {\n-            let my_path = vec::append(*pt, ~[path_name(nm)]);\n-            register_fn(ccx, ctor.span, my_path, ctor.node.id)\n-          }\n           ast_map::node_dtor(_, dt, parent_id, pt) => {\n             /*\n                 Don't just call register_fn, since we don't want to add\n@@ -2712,7 +2642,6 @@ fn trans_crate(sess: session::session,\n           crate_map: crate_map,\n           mut uses_gc: false,\n           dbg_cx: dbg_cx,\n-          class_ctors: HashMap(),\n           mut do_not_commit_warning_issued: false};\n \n "}, {"sha": "b87d690a1c342619fe232054e376330e43db8e44", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -170,11 +170,6 @@ type crate_ctxt = {\n      // is not emitted by LLVM's GC pass when no functions use GC.\n      mut uses_gc: bool,\n      dbg_cx: Option<debuginfo::debug_ctxt>,\n-     // Mapping from class constructors to parent class --\n-     // used in base::trans_closure\n-     // parent_class must be a def_id because ctors can be\n-     // inlined, so the parent may be in a different crate\n-     class_ctors: HashMap<ast::node_id, ast::def_id>,\n      mut do_not_commit_warning_issued: bool};\n \n // Types used for llself."}, {"sha": "068ec49d6c7ec2f6ce753d1ecdb73d54213462f3", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -732,10 +732,6 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_method(method, _, _) => {\n           (method.ident, method.decl.output, method.id)\n       }\n-      ast_map::node_ctor(nm, _, ctor, _, _) => {\n-        // FIXME: output type may be wrong (#2194)\n-        (nm, ctor.node.dec.output, ctor.node.id)\n-      }\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn(_, decl, _, _) => {"}, {"sha": "ce9088d4b55c3469d2831a5bec042f0f8785d827", "filename": "src/rustc/middle/trans/inline.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -34,10 +34,6 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n-          csearch::found(ast::ii_ctor(ctor, _, _, _)) => {\n-            ccx.external.insert(fn_id, Some(ctor.node.id));\n-            local_def(ctor.node.id)\n-          }\n           csearch::found(ast::ii_foreign(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             local_def(item.id)"}, {"sha": "32a581454d3dc70bcfee6b15addf7adcb63186ba", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -5,7 +5,7 @@ use syntax::ast_map::{path, path_mod, path_name};\n use base::{trans_item, get_item_val, no_self, self_arg, trans_fn,\n               impl_self, decl_internal_cdecl_fn,\n               set_inline_hint_if_appr, set_inline_hint,\n-              trans_enum_variant, trans_class_ctor, trans_class_dtor,\n+              trans_enum_variant, trans_class_dtor,\n               get_insn_ctxt};\n use syntax::parse::token::special_idents;\n use type_of::type_of_fn_from_ty;\n@@ -71,7 +71,6 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         return {val: get_item_val(ccx, fn_id.node),\n                 must_cast: true};\n       }\n-      ast_map::node_ctor(nm, _, ct, _, pt) => (pt, nm, ct.span),\n       ast_map::node_dtor(_, dtor, _, pt) =>\n           (pt, special_idents::dtor, dtor.span),\n       ast_map::node_trait_method(*) => {\n@@ -162,16 +161,6 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         meth::trans_method(ccx, pt, mth, psubsts, None, d);\n         d\n       }\n-      ast_map::node_ctor(_, tps, ctor, parent_id, _) => {\n-        // ctors don't have attrs, at least not right now\n-        let d = mk_lldecl();\n-        let tp_tys = ty::ty_params_to_tys(ccx.tcx, tps);\n-        trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n-               option::get_default(&psubsts,\n-                        {tys:tp_tys, vtables: None, bounds: @~[]}),\n-                         fn_id.node, parent_id, ctor.span);\n-        d\n-      }\n       ast_map::node_dtor(_, dtor, _, pt) => {\n         let parent_id = match ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n                                               dtor.node.self_id)) {"}, {"sha": "bfb8de76a6c58005e81dd350795c203487d448e2", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -59,10 +59,6 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n         cx.rmap.insert(item.id, ());\n       }\n       ast_map::node_variant(v, _, _) => { cx.rmap.insert(v.node.id, ()); }\n-      // If it's a ctor, consider the parent reachable\n-      ast_map::node_ctor(_, _, _, parent_id, _) => {\n-        traverse_def_id(cx, parent_id);\n-      }\n       _ => ()\n     }\n }\n@@ -104,13 +100,6 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_class(struct_def, tps) => {\n-        do option::iter(&struct_def.ctor) |ctor| {\n-            cx.rmap.insert(ctor.node.id, ());\n-            if tps.len() > 0u || attr::find_inline_attr(ctor.node.attrs)\n-                     != attr::ia_none {\n-                traverse_inline_body(cx, ctor.node.body);\n-            }\n-        }\n         do option::iter(&struct_def.dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)"}, {"sha": "1f9ad20dd03e7ac08ea74fe0b2a0feaff8a01366", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -109,9 +109,6 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n-      ast_map::node_ctor(_, _, ctor, _, _) => {\n-        handle_body(cx, ctor.node.body);\n-      }\n       ast_map::node_dtor(_, dtor, _, _) => {\n         handle_body(cx, dtor.node.body);\n       }"}, {"sha": "ff916d55b6ffd2a83931baac140fd7aa160e80e8", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -3318,7 +3318,7 @@ fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     match def {\n-      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_, _)\n+      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_)\n         => true,\n       _ => false\n     }\n@@ -3492,9 +3492,6 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                             ast_map::path_name(variant.node.name))\n           }\n \n-          ast_map::node_ctor(nm, _, _, _, path) => {\n-            vec::append_one(*path, ast_map::path_name(nm))\n-          }\n           ast_map::node_dtor(_, _, _, path) => {\n             vec::append_one(*path, ast_map::path_name(\n                 syntax::parse::token::special_idents::literally_dtor))"}, {"sha": "389c1adb016bc1bf226ebee25e0f43fa53b61345", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -323,7 +323,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n           Some(d) => d\n         };\n         match a_def {\n-          ast::def_ty(did) | ast::def_class(did, _) => {\n+          ast::def_ty(did) | ast::def_class(did) => {\n             ast_path_to_ty(self, rscope, did, path, id).ty\n           }\n           ast::def_prim_ty(nty) => {"}, {"sha": "1d921497ccf4fa28040dc6573ed7ed352e12ae65", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -451,18 +451,6 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     let tcx = ccx.tcx;\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n-    do option::iter(&struct_def.ctor) |ctor| {\n-        let class_t = {self_ty: self_ty,\n-                       self_id: ctor.node.self_id,\n-                       def_id: local_def(id),\n-                       explicit_self: {node: ast::sty_by_ref,\n-                                       span: ast_util::dummy_sp()}};\n-        // typecheck the ctor\n-        check_bare_fn(ccx, ctor.node.dec,\n-                      ctor.node.body, ctor.node.id,\n-                      Some(class_t));\n-    }\n-\n     do option::iter(&struct_def.dtor) |dtor| {\n         let class_t = {self_ty: self_ty,\n                        self_id: dtor.node.self_id,\n@@ -1925,7 +1913,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Resolve the path.\n         let class_id;\n         match tcx.def_map.find(id) {\n-            Some(ast::def_class(type_def_id, _)) => {\n+            Some(ast::def_class(type_def_id)) => {\n                 class_id = type_def_id;\n             }\n             _ => {\n@@ -2412,7 +2400,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n \n       ast::def_fn(id, _) | ast::def_static_method(id, _) |\n       ast::def_const(id) | ast::def_variant(_, id) |\n-      ast::def_class(id, _) => {\n+      ast::def_class(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       ast::def_upvar(_, inner, _, _) => {"}, {"sha": "24bcc2281fb9a1c3193b71237e9cbd2abc32ffa2", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -325,7 +325,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n \n         // Check to ensure that the struct is the one specified.\n         match tcx.def_map.get(pat.id) {\n-            ast::def_class(supplied_def_id, _)\n+            ast::def_class(supplied_def_id)\n                     if supplied_def_id == class_id => {\n                 // OK.\n             }"}, {"sha": "472c8a30459dbd6eef7d680c4cbd08a980996803", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -497,30 +497,6 @@ fn convert_struct(ccx: @crate_ctxt,\n                   tpt: ty::ty_param_bounds_and_ty,\n                   id: ast::node_id) {\n     let tcx = ccx.tcx;\n-    do option::iter(&struct_def.ctor) |ctor| {\n-        // Write the ctor type\n-        let t_args = ctor.node.dec.inputs.map(\n-            |a| ty_of_arg(ccx, type_rscope(rp), *a, None) );\n-        let t_res = ty::mk_class(\n-            tcx, local_def(id),\n-            {self_r: rscope::bound_self_region(rp),\n-             self_ty: None,\n-             tps: ty::ty_params_to_tys(tcx, tps)});\n-        let proto = ty::proto_vstore(ty::vstore_slice(ty::re_static));\n-        let t_ctor = ty::mk_fn(tcx, FnTyBase {\n-            meta: FnMeta {purity: ast::impure_fn,\n-                          proto: proto,\n-                          bounds: @~[],\n-                          ret_style: ast::return_val},\n-            sig: FnSig {inputs: t_args,\n-                        output: t_res}\n-        });\n-        write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n-        tcx.tcache.insert(local_def(ctor.node.id),\n-                          {bounds: tpt.bounds,\n-                           region_param: rp,\n-                           ty: t_ctor});\n-    }\n \n     do option::iter(&struct_def.dtor) |dtor| {\n         // Write the dtor type"}, {"sha": "0f4a4804c751c81b8a1757537752a0e9f3bff849", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -10,7 +10,7 @@ trait parse {\n \n impl parser: parse {\n     fn parse() -> ~[int] {\n-        dvec::unwrap(move self.tokens) //~ ERROR illegal move from self\n+        dvec::unwrap(move self.tokens) //~ ERROR moving out of immutable field\n     }\n }\n "}, {"sha": "e4913f7056e85422ff585bee85860e79228481ec", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3689d57c988e1dd477930d957c4308c37d1a64/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=ed3689d57c988e1dd477930d957c4308c37d1a64", "patch": "@@ -19,7 +19,7 @@ mod argparse {\n         fn set_desc(self, s: &str) -> Flag {\n             Flag { //~ ERROR cannot infer an appropriate lifetime\n                 name: self.name,\n-                desc: s,\n+                desc: s, //~ ERROR cannot infer an appropriate lifetime\n                 max_count: self.max_count,\n                 value: self.value\n             }"}]}