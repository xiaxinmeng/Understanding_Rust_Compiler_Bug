{"sha": "a0be16b0b28143bca47a7598dbdf39e33692f690", "node_id": "C_kwDOAAsO6NoAKGEwYmUxNmIwYjI4MTQzYmNhNDdhNzU5OGRiZGYzOWUzMzY5MmY2OTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-28T09:12:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-28T09:12:19Z"}, "message": "Auto merge of #14040 - HKalbasi:mir, r=HKalbasi\n\nBeginning of MIR\n\nThis pull request introduces the initial implementation of MIR lowering and interpreting in Rust Analyzer.\n\nThe implementation of MIR has potential to bring several benefits:\n- Executing a unit test without compiling it: This is my main goal. It can be useful for quickly testing code changes and print-debugging unit tests without the need for a full compilation (ideally in almost zero time, similar to languages like python and js). There is a probability that it goes nowhere, it might become slower than rustc, or it might need some unreasonable amount of memory, or we may fail to support a common pattern/function that make it unusable for most of the codes.\n- Constant evaluation: MIR allows for easier and more correct constant evaluation, on par with rustc. If r-a wants to fully support the type system, it needs full const eval, which means arbitrary code execution, which needs MIR or something similar.\n- Supporting more diagnostics: MIR can be used to detect errors, most famously borrow checker and lifetime errors,  but also mutability errors and uninitialized variables, which can be difficult/impossible to detect in HIR.\n- Lowering closures: With MIR we can find out closure capture modes, which is useful in detecting if a closure implements the `FnMut` or `Fn` traits, and calculating its size and data layout.\n\nBut the current PR implements no diagnostics and doesn't support closures. About const eval, I removed the old const eval code and it now uses the mir interpreter. Everything that is supported in stable rustc is either implemented or is super easy to implement. About interpreting unit tests, I added an experimental config, disabled by default, that shows a `pass` or `fail` on hover of unit tests (ideally it should be a button similar to `Run test` button, but I didn't figured out how to add them). Currently, no real world test works, due to missing features including closures, heap allocation, `dyn Trait` and ... so at this point it is only useful for me selecting what to implement next.\n\nThe implementation of MIR is based on the design of rustc, the data structures are almost copy paste (so it should be easy to migrate it to a possible future stable-mir), but the lowering and interpreting code is from me.", "tree": {"sha": "cf04653c094209a1ff3fb579bf1885ff3b3f96ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf04653c094209a1ff3fb579bf1885ff3b3f96ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0be16b0b28143bca47a7598dbdf39e33692f690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0be16b0b28143bca47a7598dbdf39e33692f690", "html_url": "https://github.com/rust-lang/rust/commit/a0be16b0b28143bca47a7598dbdf39e33692f690", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0be16b0b28143bca47a7598dbdf39e33692f690/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c867cbf9b6aea8d73c433ed85c6619e7714f3f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c867cbf9b6aea8d73c433ed85c6619e7714f3f7f", "html_url": "https://github.com/rust-lang/rust/commit/c867cbf9b6aea8d73c433ed85c6619e7714f3f7f"}, {"sha": "cd67589f63bff4356ef933dd090f97de4acb9b52", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd67589f63bff4356ef933dd090f97de4acb9b52", "html_url": "https://github.com/rust-lang/rust/commit/cd67589f63bff4356ef933dd090f97de4acb9b52"}], "stats": {"total": 5144, "additions": 4447, "deletions": 697}, "files": [{"sha": "8d6f0be2648e20b8dd51fea9a08acd1aec9a4461", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -52,13 +52,21 @@ pub type LabelId = Idx<Label>;\n // We convert float values into bits and that's how we don't need to deal with f32 and f64.\n // For PartialEq, bits comparison should work, as ordering is not important\n // https://github.com/rust-lang/rust-analyzer/issues/12380#issuecomment-1137284360\n-#[derive(Default, Debug, Clone, Eq, PartialEq)]\n+#[derive(Default, Debug, Clone, Copy, Eq, PartialEq)]\n pub struct FloatTypeWrapper(u64);\n \n impl FloatTypeWrapper {\n     pub fn new(value: f64) -> Self {\n         Self(value.to_bits())\n     }\n+\n+    pub fn into_f64(self) -> f64 {\n+        f64::from_bits(self.0)\n+    }\n+\n+    pub fn into_f32(self) -> f32 {\n+        f64::from_bits(self.0) as f32\n+    }\n }\n \n impl fmt::Display for FloatTypeWrapper {"}, {"sha": "4096e0a38267ee4b809f74a5f5ad68aa9461c146", "filename": "crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -181,15 +181,15 @@ impl LangItems {\n         T: Into<AttrDefId> + Copy,\n     {\n         let _p = profile::span(\"collect_lang_item\");\n-        if let Some(lang_item) = lang_attr(db, item).and_then(|it| LangItem::from_str(&it)) {\n+        if let Some(lang_item) = lang_attr(db, item) {\n             self.items.entry(lang_item).or_insert_with(|| constructor(item));\n         }\n     }\n }\n \n-pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Option<SmolStr> {\n+pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Option<LangItem> {\n     let attrs = db.attrs(item.into());\n-    attrs.by_key(\"lang\").string_value().cloned()\n+    attrs.by_key(\"lang\").string_value().cloned().and_then(|it| LangItem::from_str(&it))\n }\n \n pub enum GenericRequirement {"}, {"sha": "0b72ca1eec18f64696f2a1e59abbabb1f0066120", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -143,7 +143,7 @@ macro_rules! assert {\n \n fn main() {\n      {\n-        if !true {\n+        if !(true ) {\n             $crate::panic!(\"{} {:?}\", arg1(a, b, c), arg2);\n         }\n     };"}, {"sha": "f3197d1800f22cf455ca1eb619d7637bd6ae3c25", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -8,7 +8,7 @@ use std::{\n \n use crate::{\n     body::LowerCtx,\n-    type_ref::{ConstScalarOrPath, LifetimeRef},\n+    type_ref::{ConstRefOrPath, LifetimeRef},\n };\n use hir_expand::name::Name;\n use intern::Interned;\n@@ -85,7 +85,7 @@ pub struct AssociatedTypeBinding {\n pub enum GenericArg {\n     Type(TypeRef),\n     Lifetime(LifetimeRef),\n-    Const(ConstScalarOrPath),\n+    Const(ConstRefOrPath),\n }\n \n impl Path {"}, {"sha": "b7542bd777d04018974006f76d2057a9a50c7ec4", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use crate::type_ref::ConstScalarOrPath;\n+use crate::type_ref::ConstRefOrPath;\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n@@ -212,7 +212,7 @@ pub(super) fn lower_generic_args(\n                 }\n             }\n             ast::GenericArg::ConstArg(arg) => {\n-                let arg = ConstScalarOrPath::from_expr_opt(arg.expr());\n+                let arg = ConstRefOrPath::from_expr_opt(arg.expr());\n                 args.push(GenericArg::Const(arg))\n             }\n         }"}, {"sha": "8e30f429a9f806d8a4ea5aeef7037bdc52ce3077", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -116,7 +116,7 @@ pub enum TypeRef {\n     Reference(Box<TypeRef>, Option<LifetimeRef>, Mutability),\n     // FIXME: for full const generics, the latter element (length) here is going to have to be an\n     // expression that is further lowered later in hir_ty.\n-    Array(Box<TypeRef>, ConstScalarOrPath),\n+    Array(Box<TypeRef>, ConstRefOrPath),\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n     Fn(Vec<(Option<Name>, TypeRef)>, bool /*varargs*/, bool /*is_unsafe*/),\n@@ -188,7 +188,7 @@ impl TypeRef {\n                 // `hir_def::body::lower` to lower this into an `Expr` and then evaluate it at the\n                 // `hir_ty` level, which would allow knowing the type of:\n                 // let v: [u8; 2 + 2] = [0u8; 4];\n-                let len = ConstScalarOrPath::from_expr_opt(inner.expr());\n+                let len = ConstRefOrPath::from_expr_opt(inner.expr());\n                 TypeRef::Array(Box::new(TypeRef::from_ast_opt(ctx, inner.ty())), len)\n             }\n             ast::Type::SliceType(inner) => {\n@@ -378,25 +378,25 @@ impl TypeBound {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ConstScalarOrPath {\n-    Scalar(ConstScalar),\n+pub enum ConstRefOrPath {\n+    Scalar(ConstRef),\n     Path(Name),\n }\n \n-impl std::fmt::Display for ConstScalarOrPath {\n+impl std::fmt::Display for ConstRefOrPath {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n-            ConstScalarOrPath::Scalar(s) => s.fmt(f),\n-            ConstScalarOrPath::Path(n) => n.fmt(f),\n+            ConstRefOrPath::Scalar(s) => s.fmt(f),\n+            ConstRefOrPath::Path(n) => n.fmt(f),\n         }\n     }\n }\n \n-impl ConstScalarOrPath {\n+impl ConstRefOrPath {\n     pub(crate) fn from_expr_opt(expr: Option<ast::Expr>) -> Self {\n         match expr {\n             Some(x) => Self::from_expr(x),\n-            None => Self::Scalar(ConstScalar::Unknown),\n+            None => Self::Scalar(ConstRef::Unknown),\n         }\n     }\n \n@@ -407,16 +407,16 @@ impl ConstScalarOrPath {\n             ast::Expr::PathExpr(p) => {\n                 match p.path().and_then(|x| x.segment()).and_then(|x| x.name_ref()) {\n                     Some(x) => Self::Path(x.as_name()),\n-                    None => Self::Scalar(ConstScalar::Unknown),\n+                    None => Self::Scalar(ConstRef::Unknown),\n                 }\n             }\n             ast::Expr::PrefixExpr(prefix_expr) => match prefix_expr.op_kind() {\n                 Some(ast::UnaryOp::Neg) => {\n                     let unsigned = Self::from_expr_opt(prefix_expr.expr());\n                     // Add sign\n                     match unsigned {\n-                        Self::Scalar(ConstScalar::UInt(num)) => {\n-                            Self::Scalar(ConstScalar::Int(-(num as i128)))\n+                        Self::Scalar(ConstRef::UInt(num)) => {\n+                            Self::Scalar(ConstRef::Int(-(num as i128)))\n                         }\n                         other => other,\n                     }\n@@ -425,22 +425,22 @@ impl ConstScalarOrPath {\n             },\n             ast::Expr::Literal(literal) => Self::Scalar(match literal.kind() {\n                 ast::LiteralKind::IntNumber(num) => {\n-                    num.value().map(ConstScalar::UInt).unwrap_or(ConstScalar::Unknown)\n+                    num.value().map(ConstRef::UInt).unwrap_or(ConstRef::Unknown)\n                 }\n                 ast::LiteralKind::Char(c) => {\n-                    c.value().map(ConstScalar::Char).unwrap_or(ConstScalar::Unknown)\n+                    c.value().map(ConstRef::Char).unwrap_or(ConstRef::Unknown)\n                 }\n-                ast::LiteralKind::Bool(f) => ConstScalar::Bool(f),\n-                _ => ConstScalar::Unknown,\n+                ast::LiteralKind::Bool(f) => ConstRef::Bool(f),\n+                _ => ConstRef::Unknown,\n             }),\n-            _ => Self::Scalar(ConstScalar::Unknown),\n+            _ => Self::Scalar(ConstRef::Unknown),\n         }\n     }\n }\n \n /// A concrete constant value\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum ConstScalar {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum ConstRef {\n     Int(i128),\n     UInt(u128),\n     Bool(bool),\n@@ -454,18 +454,18 @@ pub enum ConstScalar {\n     Unknown,\n }\n \n-impl ConstScalar {\n+impl ConstRef {\n     pub fn builtin_type(&self) -> BuiltinType {\n         match self {\n-            ConstScalar::UInt(_) | ConstScalar::Unknown => BuiltinType::Uint(BuiltinUint::U128),\n-            ConstScalar::Int(_) => BuiltinType::Int(BuiltinInt::I128),\n-            ConstScalar::Char(_) => BuiltinType::Char,\n-            ConstScalar::Bool(_) => BuiltinType::Bool,\n+            ConstRef::UInt(_) | ConstRef::Unknown => BuiltinType::Uint(BuiltinUint::U128),\n+            ConstRef::Int(_) => BuiltinType::Int(BuiltinInt::I128),\n+            ConstRef::Char(_) => BuiltinType::Char,\n+            ConstRef::Bool(_) => BuiltinType::Bool,\n         }\n     }\n }\n \n-impl From<Literal> for ConstScalar {\n+impl From<Literal> for ConstRef {\n     fn from(literal: Literal) -> Self {\n         match literal {\n             Literal::Char(c) => Self::Char(c),\n@@ -477,14 +477,14 @@ impl From<Literal> for ConstScalar {\n     }\n }\n \n-impl std::fmt::Display for ConstScalar {\n+impl std::fmt::Display for ConstRef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match self {\n-            ConstScalar::Int(num) => num.fmt(f),\n-            ConstScalar::UInt(num) => num.fmt(f),\n-            ConstScalar::Bool(flag) => flag.fmt(f),\n-            ConstScalar::Char(c) => write!(f, \"'{c}'\"),\n-            ConstScalar::Unknown => f.write_char('_'),\n+            ConstRef::Int(num) => num.fmt(f),\n+            ConstRef::UInt(num) => num.fmt(f),\n+            ConstRef::Bool(flag) => flag.fmt(f),\n+            ConstRef::Char(c) => write!(f, \"'{c}'\"),\n+            ConstRef::Unknown => f.write_char('_'),\n         }\n     }\n }"}, {"sha": "295083a37f2320da449668107e757811ed331003", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -206,7 +206,7 @@ fn assert_expand(\n             let cond = cond.clone();\n             let panic_args = itertools::Itertools::intersperse(panic_args.iter().cloned(), comma);\n             quote! {{\n-                if !#cond {\n+                if !(#cond) {\n                     #DOLLAR_CRATE::panic!(##panic_args);\n                 }\n             }}"}, {"sha": "03e9443599d8c577a1d1e011cb9bf84b2f3e5058", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -152,6 +152,15 @@ impl TyBuilder<()> {\n         TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner)\n     }\n \n+    // FIXME: rustc's ty is dependent on the adt type, maybe we need to do that as well\n+    pub fn discr_ty() -> Ty {\n+        TyKind::Scalar(chalk_ir::Scalar::Int(chalk_ir::IntTy::I128)).intern(Interner)\n+    }\n+\n+    pub fn bool() -> Ty {\n+        TyKind::Scalar(chalk_ir::Scalar::Bool).intern(Interner)\n+    }\n+\n     pub fn usize() -> Ty {\n         TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)).intern(Interner)\n     }"}, {"sha": "28ae4c349f83cfa34117128903898c5c873ce63c", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -540,8 +540,7 @@ pub(crate) fn trait_datum_query(\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n     let associated_ty_ids = trait_data.associated_types().map(to_assoc_type_id).collect();\n     let trait_datum_bound = rust_ir::TraitDatumBound { where_clauses };\n-    let well_known = lang_attr(db.upcast(), trait_)\n-        .and_then(|name| well_known_trait_from_lang_item(LangItem::from_str(&name)?));\n+    let well_known = lang_attr(db.upcast(), trait_).and_then(well_known_trait_from_lang_item);\n     let trait_datum = TraitDatum {\n         id: trait_id,\n         binders: make_binders(db, &generic_params, trait_datum_bound),"}, {"sha": "5830c48988fe50dd8bb48dd8722170d797a6634a", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 101, "deletions": 402, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -1,30 +1,25 @@\n //! Constant evaluation details\n \n-use std::{\n-    collections::HashMap,\n-    fmt::{Display, Write},\n-};\n-\n-use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n+use base_db::CrateId;\n+use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData};\n use hir_def::{\n-    builtin_type::BuiltinInt,\n-    expr::{ArithOp, BinaryOp, Expr, ExprId, Literal, Pat, PatId},\n+    expr::Expr,\n     path::ModPath,\n-    resolver::{resolver_for_expr, ResolveValueResult, Resolver, ValueNs},\n-    src::HasChildSource,\n-    type_ref::ConstScalar,\n-    ConstId, DefWithBodyId, EnumVariantId, Lookup,\n+    resolver::{Resolver, ValueNs},\n+    type_ref::ConstRef,\n+    ConstId, EnumVariantId,\n };\n-use la_arena::{Arena, Idx, RawIdx};\n+use la_arena::{Idx, RawIdx};\n use stdx::never;\n-use syntax::ast::HasName;\n \n use crate::{\n-    db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode, to_placeholder_idx,\n-    utils::Generics, Const, ConstData, ConstValue, GenericArg, InferenceResult, Interner, Ty,\n-    TyBuilder, TyKind,\n+    db::HirDatabase, infer::InferenceContext, layout::layout_of_ty, lower::ParamLoweringMode,\n+    to_placeholder_idx, utils::Generics, Const, ConstData, ConstScalar, ConstValue, GenericArg,\n+    Interner, MemoryMap, Ty, TyBuilder,\n };\n \n+use super::mir::{interpret_mir, lower_to_mir, pad16, MirEvalError, MirLowerError};\n+\n /// Extension trait for [`Const`]\n pub trait ConstExt {\n     /// Is a [`Const`] unknown?\n@@ -53,346 +48,24 @@ impl ConstExt for Const {\n     }\n }\n \n-pub struct ConstEvalCtx<'a> {\n-    pub db: &'a dyn HirDatabase,\n-    pub owner: DefWithBodyId,\n-    pub exprs: &'a Arena<Expr>,\n-    pub pats: &'a Arena<Pat>,\n-    pub local_data: HashMap<PatId, ComputedExpr>,\n-    infer: &'a InferenceResult,\n-}\n-\n-impl ConstEvalCtx<'_> {\n-    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n-        self.infer[expr].clone()\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ConstEvalError {\n-    NotSupported(&'static str),\n-    SemanticError(&'static str),\n-    Loop,\n-    IncompleteExpr,\n-    Panic(String),\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ComputedExpr {\n-    Literal(Literal),\n-    Enum(String, EnumVariantId, Literal),\n-    Tuple(Box<[ComputedExpr]>),\n+    MirLowerError(MirLowerError),\n+    MirEvalError(MirEvalError),\n }\n \n-impl Display for ComputedExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            ComputedExpr::Literal(l) => match l {\n-                Literal::Int(x, _) => {\n-                    if *x >= 10 {\n-                        write!(f, \"{x} ({x:#X})\")\n-                    } else {\n-                        x.fmt(f)\n-                    }\n-                }\n-                Literal::Uint(x, _) => {\n-                    if *x >= 10 {\n-                        write!(f, \"{x} ({x:#X})\")\n-                    } else {\n-                        x.fmt(f)\n-                    }\n-                }\n-                Literal::Float(x, _) => x.fmt(f),\n-                Literal::Bool(x) => x.fmt(f),\n-                Literal::Char(x) => std::fmt::Debug::fmt(x, f),\n-                Literal::String(x) => std::fmt::Debug::fmt(x, f),\n-                Literal::ByteString(x) => std::fmt::Debug::fmt(x, f),\n-            },\n-            ComputedExpr::Enum(name, _, _) => name.fmt(f),\n-            ComputedExpr::Tuple(t) => {\n-                f.write_char('(')?;\n-                for x in &**t {\n-                    x.fmt(f)?;\n-                    f.write_str(\", \")?;\n-                }\n-                f.write_char(')')\n-            }\n+impl From<MirLowerError> for ConstEvalError {\n+    fn from(value: MirLowerError) -> Self {\n+        match value {\n+            MirLowerError::ConstEvalError(e) => *e,\n+            _ => ConstEvalError::MirLowerError(value),\n         }\n     }\n }\n \n-fn scalar_max(scalar: &Scalar) -> i128 {\n-    match scalar {\n-        Scalar::Bool => 1,\n-        Scalar::Char => u32::MAX as i128,\n-        Scalar::Int(x) => match x {\n-            IntTy::Isize => isize::MAX as i128,\n-            IntTy::I8 => i8::MAX as i128,\n-            IntTy::I16 => i16::MAX as i128,\n-            IntTy::I32 => i32::MAX as i128,\n-            IntTy::I64 => i64::MAX as i128,\n-            IntTy::I128 => i128::MAX,\n-        },\n-        Scalar::Uint(x) => match x {\n-            chalk_ir::UintTy::Usize => usize::MAX as i128,\n-            chalk_ir::UintTy::U8 => u8::MAX as i128,\n-            chalk_ir::UintTy::U16 => u16::MAX as i128,\n-            chalk_ir::UintTy::U32 => u32::MAX as i128,\n-            chalk_ir::UintTy::U64 => u64::MAX as i128,\n-            chalk_ir::UintTy::U128 => i128::MAX, // ignore too big u128 for now\n-        },\n-        Scalar::Float(_) => 0,\n-    }\n-}\n-\n-fn is_valid(scalar: &Scalar, value: i128) -> bool {\n-    if value < 0 {\n-        !matches!(scalar, Scalar::Uint(_)) && -scalar_max(scalar) - 1 <= value\n-    } else {\n-        value <= scalar_max(scalar)\n-    }\n-}\n-\n-fn get_name(ctx: &mut ConstEvalCtx<'_>, variant: EnumVariantId) -> String {\n-    let loc = variant.parent.lookup(ctx.db.upcast());\n-    let children = variant.parent.child_source(ctx.db.upcast());\n-    let item_tree = loc.id.item_tree(ctx.db.upcast());\n-\n-    let variant_name = children.value[variant.local_id].name();\n-    let enum_name = item_tree[loc.id.value].name.to_string();\n-    enum_name + \"::\" + &variant_name.unwrap().to_string()\n-}\n-\n-pub fn eval_const(\n-    expr_id: ExprId,\n-    ctx: &mut ConstEvalCtx<'_>,\n-) -> Result<ComputedExpr, ConstEvalError> {\n-    let u128_to_i128 = |it: u128| -> Result<i128, ConstEvalError> {\n-        it.try_into().map_err(|_| ConstEvalError::NotSupported(\"u128 is too big\"))\n-    };\n-\n-    let expr = &ctx.exprs[expr_id];\n-    match expr {\n-        Expr::Missing => match ctx.owner {\n-            // evaluate the implicit variant index of an enum variant without expression\n-            // FIXME: This should return the type of the enum representation\n-            DefWithBodyId::VariantId(variant) => {\n-                let prev_idx: u32 = variant.local_id.into_raw().into();\n-                let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n-                let value = match prev_idx {\n-                    Some(local_id) => {\n-                        let prev_variant = EnumVariantId { local_id, parent: variant.parent };\n-                        1 + match ctx.db.const_eval_variant(prev_variant)? {\n-                            ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                            ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                            _ => {\n-                                return Err(ConstEvalError::NotSupported(\n-                                    \"Enum can't contain this kind of value\",\n-                                ))\n-                            }\n-                        }\n-                    }\n-                    _ => 0,\n-                };\n-                Ok(ComputedExpr::Literal(Literal::Int(value, Some(BuiltinInt::I128))))\n-            }\n-            _ => Err(ConstEvalError::IncompleteExpr),\n-        },\n-        Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n-        &Expr::UnaryOp { expr, op } => {\n-            let ty = &ctx.expr_ty(expr);\n-            let ev = eval_const(expr, ctx)?;\n-            match op {\n-                hir_def::expr::UnaryOp::Deref => Err(ConstEvalError::NotSupported(\"deref\")),\n-                hir_def::expr::UnaryOp::Not => {\n-                    let v = match ev {\n-                        ComputedExpr::Literal(Literal::Bool(b)) => {\n-                            return Ok(ComputedExpr::Literal(Literal::Bool(!b)))\n-                        }\n-                        ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                        _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-                    };\n-                    let r = match ty.kind(Interner) {\n-                        TyKind::Scalar(Scalar::Uint(x)) => match x {\n-                            chalk_ir::UintTy::U8 => !(v as u8) as i128,\n-                            chalk_ir::UintTy::U16 => !(v as u16) as i128,\n-                            chalk_ir::UintTy::U32 => !(v as u32) as i128,\n-                            chalk_ir::UintTy::U64 => !(v as u64) as i128,\n-                            chalk_ir::UintTy::U128 => {\n-                                return Err(ConstEvalError::NotSupported(\"negation of u128\"))\n-                            }\n-                            chalk_ir::UintTy::Usize => !(v as usize) as i128,\n-                        },\n-                        TyKind::Scalar(Scalar::Int(x)) => match x {\n-                            chalk_ir::IntTy::I8 => !(v as i8) as i128,\n-                            chalk_ir::IntTy::I16 => !(v as i16) as i128,\n-                            chalk_ir::IntTy::I32 => !(v as i32) as i128,\n-                            chalk_ir::IntTy::I64 => !(v as i64) as i128,\n-                            chalk_ir::IntTy::I128 => !v,\n-                            chalk_ir::IntTy::Isize => !(v as isize) as i128,\n-                        },\n-                        _ => return Err(ConstEvalError::NotSupported(\"unreachable?\")),\n-                    };\n-                    Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n-                }\n-                hir_def::expr::UnaryOp::Neg => {\n-                    let v = match ev {\n-                        ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                        _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-                    };\n-                    Ok(ComputedExpr::Literal(Literal::Int(\n-                        v.checked_neg().ok_or_else(|| {\n-                            ConstEvalError::Panic(\"overflow in negation\".to_string())\n-                        })?,\n-                        None,\n-                    )))\n-                }\n-            }\n-        }\n-        &Expr::BinaryOp { lhs, rhs, op } => {\n-            let ty = &ctx.expr_ty(lhs);\n-            let lhs = eval_const(lhs, ctx)?;\n-            let rhs = eval_const(rhs, ctx)?;\n-            let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n-            let v1 = match lhs {\n-                ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-            };\n-            let v2 = match rhs {\n-                ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-            };\n-            match op {\n-                BinaryOp::ArithOp(b) => {\n-                    let panic_arith = ConstEvalError::Panic(\n-                        \"attempt to run invalid arithmetic operation\".to_string(),\n-                    );\n-                    let r = match b {\n-                        ArithOp::Add => v1.checked_add(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Mul => v1.checked_mul(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Sub => v1.checked_sub(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Div => v1.checked_div(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Rem => v1.checked_rem(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Shl => v1\n-                            .checked_shl(v2.try_into().map_err(|_| panic_arith.clone())?)\n-                            .ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Shr => v1\n-                            .checked_shr(v2.try_into().map_err(|_| panic_arith.clone())?)\n-                            .ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::BitXor => v1 ^ v2,\n-                        ArithOp::BitOr => v1 | v2,\n-                        ArithOp::BitAnd => v1 & v2,\n-                    };\n-                    if let TyKind::Scalar(s) = ty.kind(Interner) {\n-                        if !is_valid(s, r) {\n-                            return Err(panic_arith);\n-                        }\n-                    }\n-                    Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n-                }\n-                BinaryOp::LogicOp(_) => Err(ConstEvalError::SemanticError(\"logic op on numbers\")),\n-                _ => Err(ConstEvalError::NotSupported(\"bin op on this operators\")),\n-            }\n-        }\n-        Expr::Block { statements, tail, .. } => {\n-            let mut prev_values = HashMap::<PatId, Option<ComputedExpr>>::default();\n-            for statement in &**statements {\n-                match *statement {\n-                    hir_def::expr::Statement::Let { pat: pat_id, initializer, .. } => {\n-                        let pat = &ctx.pats[pat_id];\n-                        match pat {\n-                            Pat::Bind { subpat, .. } if subpat.is_none() => (),\n-                            _ => {\n-                                return Err(ConstEvalError::NotSupported(\"complex patterns in let\"))\n-                            }\n-                        };\n-                        let value = match initializer {\n-                            Some(x) => eval_const(x, ctx)?,\n-                            None => continue,\n-                        };\n-                        if !prev_values.contains_key(&pat_id) {\n-                            let prev = ctx.local_data.insert(pat_id, value);\n-                            prev_values.insert(pat_id, prev);\n-                        } else {\n-                            ctx.local_data.insert(pat_id, value);\n-                        }\n-                    }\n-                    hir_def::expr::Statement::Expr { .. } => {\n-                        return Err(ConstEvalError::NotSupported(\"this kind of statement\"))\n-                    }\n-                }\n-            }\n-            let r = match tail {\n-                &Some(x) => eval_const(x, ctx),\n-                None => Ok(ComputedExpr::Tuple(Box::new([]))),\n-            };\n-            // clean up local data, so caller will receive the exact map that passed to us\n-            for (name, val) in prev_values {\n-                match val {\n-                    Some(x) => ctx.local_data.insert(name, x),\n-                    None => ctx.local_data.remove(&name),\n-                };\n-            }\n-            r\n-        }\n-        Expr::Path(p) => {\n-            let resolver = resolver_for_expr(ctx.db.upcast(), ctx.owner, expr_id);\n-            let pr = resolver\n-                .resolve_path_in_value_ns(ctx.db.upcast(), p.mod_path())\n-                .ok_or(ConstEvalError::SemanticError(\"unresolved path\"))?;\n-            let pr = match pr {\n-                ResolveValueResult::ValueNs(v) => v,\n-                ResolveValueResult::Partial(..) => {\n-                    return match ctx\n-                        .infer\n-                        .assoc_resolutions_for_expr(expr_id)\n-                        .ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n-                        .0\n-                    {\n-                        hir_def::AssocItemId::FunctionId(_) => {\n-                            Err(ConstEvalError::NotSupported(\"assoc function\"))\n-                        }\n-                        // FIXME use actual impl for trait assoc const\n-                        hir_def::AssocItemId::ConstId(c) => ctx.db.const_eval(c),\n-                        hir_def::AssocItemId::TypeAliasId(_) => {\n-                            Err(ConstEvalError::NotSupported(\"assoc type alias\"))\n-                        }\n-                    };\n-                }\n-            };\n-            match pr {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let r = ctx\n-                        .local_data\n-                        .get(&pat_id)\n-                        .ok_or(ConstEvalError::NotSupported(\"Unexpected missing local\"))?;\n-                    Ok(r.clone())\n-                }\n-                ValueNs::ConstId(id) => ctx.db.const_eval(id),\n-                ValueNs::GenericParam(_) => {\n-                    Err(ConstEvalError::NotSupported(\"const generic without substitution\"))\n-                }\n-                ValueNs::EnumVariantId(id) => match ctx.db.const_eval_variant(id)? {\n-                    ComputedExpr::Literal(lit) => {\n-                        Ok(ComputedExpr::Enum(get_name(ctx, id), id, lit))\n-                    }\n-                    _ => Err(ConstEvalError::NotSupported(\n-                        \"Enums can't evalute to anything but numbers\",\n-                    )),\n-                },\n-                _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n-            }\n-        }\n-        // FIXME: Handle the cast target\n-        &Expr::Cast { expr, .. } => match eval_const(expr, ctx)? {\n-            ComputedExpr::Enum(_, _, lit) => Ok(ComputedExpr::Literal(lit)),\n-            _ => Err(ConstEvalError::NotSupported(\"Can't cast these types\")),\n-        },\n-        _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n+impl From<MirEvalError> for ConstEvalError {\n+    fn from(value: MirEvalError) -> Self {\n+        ConstEvalError::MirEvalError(value)\n     }\n }\n \n@@ -449,97 +122,123 @@ pub fn intern_const_scalar(value: ConstScalar, ty: Ty) -> Const {\n         .intern(Interner)\n }\n \n+/// Interns a constant scalar with the given type\n+pub fn intern_const_ref(db: &dyn HirDatabase, value: &ConstRef, ty: Ty, krate: CrateId) -> Const {\n+    let bytes = match value {\n+        ConstRef::Int(i) => {\n+            // FIXME: We should handle failure of layout better.\n+            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n+        }\n+        ConstRef::UInt(i) => {\n+            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n+        }\n+        ConstRef::Bool(b) => ConstScalar::Bytes(vec![*b as u8], MemoryMap::default()),\n+        ConstRef::Char(c) => {\n+            ConstScalar::Bytes((*c as u32).to_le_bytes().to_vec(), MemoryMap::default())\n+        }\n+        ConstRef::Unknown => ConstScalar::Unknown,\n+    };\n+    intern_const_scalar(bytes, ty)\n+}\n+\n /// Interns a possibly-unknown target usize\n-pub fn usize_const(value: Option<u128>) -> Const {\n-    intern_const_scalar(value.map_or(ConstScalar::Unknown, ConstScalar::UInt), TyBuilder::usize())\n+pub fn usize_const(db: &dyn HirDatabase, value: Option<u128>, krate: CrateId) -> Const {\n+    intern_const_ref(\n+        db,\n+        &value.map_or(ConstRef::Unknown, ConstRef::UInt),\n+        TyBuilder::usize(),\n+        krate,\n+    )\n+}\n+\n+pub fn try_const_usize(c: &Const) -> Option<u128> {\n+    match &c.data(Interner).value {\n+        chalk_ir::ConstValue::BoundVar(_) => None,\n+        chalk_ir::ConstValue::InferenceVar(_) => None,\n+        chalk_ir::ConstValue::Placeholder(_) => None,\n+        chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n+            ConstScalar::Bytes(x, _) => Some(u128::from_le_bytes(pad16(&x, false))),\n+            _ => None,\n+        },\n+    }\n }\n \n pub(crate) fn const_eval_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n     _: &ConstId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n-    Err(ConstEvalError::Loop)\n+) -> Result<Const, ConstEvalError> {\n+    Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n \n-pub(crate) fn const_eval_variant_recover(\n+pub(crate) fn const_eval_discriminant_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n     _: &EnumVariantId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n-    Err(ConstEvalError::Loop)\n+) -> Result<i128, ConstEvalError> {\n+    Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n \n-pub(crate) fn const_eval_variant_query(\n+pub(crate) fn const_eval_query(\n     db: &dyn HirDatabase,\n     const_id: ConstId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n+) -> Result<Const, ConstEvalError> {\n     let def = const_id.into();\n-    let body = db.body(def);\n-    let infer = &db.infer(def);\n-    let result = eval_const(\n-        body.body_expr,\n-        &mut ConstEvalCtx {\n-            db,\n-            owner: const_id.into(),\n-            exprs: &body.exprs,\n-            pats: &body.pats,\n-            local_data: HashMap::default(),\n-            infer,\n-        },\n-    );\n-    result\n+    let body = db.mir_body(def)?;\n+    let c = interpret_mir(db, &body, false)?;\n+    Ok(c)\n }\n \n-pub(crate) fn const_eval_query_variant(\n+pub(crate) fn const_eval_discriminant_variant(\n     db: &dyn HirDatabase,\n     variant_id: EnumVariantId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n+) -> Result<i128, ConstEvalError> {\n     let def = variant_id.into();\n     let body = db.body(def);\n-    let infer = &db.infer(def);\n-    eval_const(\n-        body.body_expr,\n-        &mut ConstEvalCtx {\n-            db,\n-            owner: def,\n-            exprs: &body.exprs,\n-            pats: &body.pats,\n-            local_data: HashMap::default(),\n-            infer,\n-        },\n-    )\n+    if body.exprs[body.body_expr] == Expr::Missing {\n+        let prev_idx: u32 = variant_id.local_id.into_raw().into();\n+        let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n+        let value = match prev_idx {\n+            Some(local_id) => {\n+                let prev_variant = EnumVariantId { local_id, parent: variant_id.parent };\n+                1 + db.const_eval_discriminant(prev_variant)?\n+            }\n+            _ => 0,\n+        };\n+        return Ok(value);\n+    }\n+    let mir_body = db.mir_body(def)?;\n+    let c = interpret_mir(db, &mir_body, false)?;\n+    let c = try_const_usize(&c).unwrap() as i128;\n+    Ok(c)\n }\n \n+// FIXME: Ideally constants in const eval should have separate body (issue #7434), and this function should\n+// get an `InferenceResult` instead of an `InferenceContext`. And we should remove `ctx.clone().resolve_all()` here\n+// and make this function private. See the fixme comment on `InferenceContext::resolve_all`.\n pub(crate) fn eval_to_const(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,\n     ctx: &mut InferenceContext<'_>,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {\n+    let db = ctx.db;\n     if let Expr::Path(p) = &ctx.body.exprs[expr] {\n-        let db = ctx.db;\n         let resolver = &ctx.resolver;\n         if let Some(c) = path_to_const(db, resolver, p.mod_path(), mode, args, debruijn) {\n             return c;\n         }\n     }\n-    let body = ctx.body.clone();\n-    let mut ctx = ConstEvalCtx {\n-        db: ctx.db,\n-        owner: ctx.owner,\n-        exprs: &body.exprs,\n-        pats: &body.pats,\n-        local_data: HashMap::default(),\n-        infer: &ctx.result,\n-    };\n-    let computed_expr = eval_const(expr, &mut ctx);\n-    let const_scalar = match computed_expr {\n-        Ok(ComputedExpr::Literal(literal)) => literal.into(),\n-        _ => ConstScalar::Unknown,\n-    };\n-    intern_const_scalar(const_scalar, TyBuilder::usize())\n+    let infer = ctx.clone().resolve_all();\n+    if let Ok(mir_body) = lower_to_mir(ctx.db, ctx.owner, &ctx.body, &infer, expr) {\n+        if let Ok(result) = interpret_mir(db, &mir_body, true) {\n+            return result;\n+        }\n+    }\n+    unknown_const(infer[expr].clone())\n }\n \n #[cfg(test)]"}, {"sha": "19145b2d98e4f682804cfc57b02ed4433282e911", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 660, "deletions": 30, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -1,24 +1,44 @@\n use base_db::fixture::WithFixture;\n-use hir_def::{db::DefDatabase, expr::Literal};\n+use hir_def::db::DefDatabase;\n \n-use crate::{consteval::ComputedExpr, db::HirDatabase, test_db::TestDB};\n+use crate::{\n+    consteval::try_const_usize, db::HirDatabase, test_db::TestDB, Const, ConstScalar, Interner,\n+};\n \n-use super::ConstEvalError;\n+use super::{\n+    super::mir::{MirEvalError, MirLowerError},\n+    ConstEvalError,\n+};\n \n+fn simplify(e: ConstEvalError) -> ConstEvalError {\n+    match e {\n+        ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e)) => {\n+            simplify(ConstEvalError::MirEvalError(*e))\n+        }\n+        _ => e,\n+    }\n+}\n+\n+#[track_caller]\n fn check_fail(ra_fixture: &str, error: ConstEvalError) {\n-    assert_eq!(eval_goal(ra_fixture), Err(error));\n+    assert_eq!(eval_goal(ra_fixture).map_err(simplify), Err(error));\n }\n \n+#[track_caller]\n fn check_number(ra_fixture: &str, answer: i128) {\n     let r = eval_goal(ra_fixture).unwrap();\n-    match r {\n-        ComputedExpr::Literal(Literal::Int(r, _)) => assert_eq!(r, answer),\n-        ComputedExpr::Literal(Literal::Uint(r, _)) => assert_eq!(r, answer as u128),\n-        x => panic!(\"Expected number but found {x:?}\"),\n+    match &r.data(Interner).value {\n+        chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n+            ConstScalar::Bytes(b, _) => {\n+                assert_eq!(b, &answer.to_le_bytes()[0..b.len()]);\n+            }\n+            x => panic!(\"Expected number but found {:?}\", x),\n+        },\n+        _ => panic!(\"result of const eval wasn't a concrete const\"),\n     }\n }\n \n-fn eval_goal(ra_fixture: &str) -> Result<ComputedExpr, ConstEvalError> {\n+fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n     let (db, file_id) = TestDB::with_single_file(ra_fixture);\n     let module_id = db.module_for_file(file_id);\n     let def_map = module_id.def_map(&db);\n@@ -42,21 +62,18 @@ fn eval_goal(ra_fixture: &str) -> Result<ComputedExpr, ConstEvalError> {\n #[test]\n fn add() {\n     check_number(r#\"const GOAL: usize = 2 + 2;\"#, 4);\n+    check_number(r#\"const GOAL: i32 = -2 + --5;\"#, 3);\n+    check_number(r#\"const GOAL: i32 = 7 - 5;\"#, 2);\n+    check_number(r#\"const GOAL: i32 = 7 + (1 - 5);\"#, 3);\n }\n \n #[test]\n fn bit_op() {\n     check_number(r#\"const GOAL: u8 = !0 & !(!0 >> 1)\"#, 128);\n     check_number(r#\"const GOAL: i8 = !0 & !(!0 >> 1)\"#, 0);\n-    // FIXME: rustc evaluate this to -128\n-    check_fail(\n-        r#\"const GOAL: i8 = 1 << 7\"#,\n-        ConstEvalError::Panic(\"attempt to run invalid arithmetic operation\".to_string()),\n-    );\n-    check_fail(\n-        r#\"const GOAL: i8 = 1 << 8\"#,\n-        ConstEvalError::Panic(\"attempt to run invalid arithmetic operation\".to_string()),\n-    );\n+    check_number(r#\"const GOAL: i8 = 1 << 7\"#, (1i8 << 7) as i128);\n+    // FIXME: report panic here\n+    check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n }\n \n #[test]\n@@ -73,6 +90,562 @@ fn locals() {\n     );\n }\n \n+#[test]\n+fn references() {\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let x = 3;\n+        let y = &mut x;\n+        *y = 5;\n+        x\n+    };\n+    \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn reference_autoderef() {\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let x = 3;\n+        let y = &mut x;\n+        let y: &mut usize = &mut y;\n+        *y = 5;\n+        x\n+    };\n+    \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let x = 3;\n+        let y = &&&&&&&x;\n+        let z: &usize = &y;\n+        *z\n+    };\n+    \"#,\n+        3,\n+    );\n+}\n+\n+#[test]\n+fn function_call() {\n+    check_number(\n+        r#\"\n+    const fn f(x: usize) -> usize {\n+        2 * x + 5\n+    }\n+    const GOAL: usize = f(3);\n+    \"#,\n+        11,\n+    );\n+    check_number(\n+        r#\"\n+    const fn add(x: usize, y: usize) -> usize {\n+        x + y\n+    }\n+    const GOAL: usize = add(add(1, 2), add(3, add(4, 5)));\n+    \"#,\n+        15,\n+    );\n+}\n+\n+#[test]\n+fn intrinsics() {\n+    check_number(\n+        r#\"\n+    extern \"rust-intrinsic\" {\n+        pub fn size_of<T>() -> usize;\n+    }\n+\n+    const GOAL: usize = size_of::<i32>();\n+    \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn trait_basic() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = 3;\n+        Foo::f(&x)\n+    };\n+    \"#,\n+        36,\n+    );\n+}\n+\n+#[test]\n+fn trait_method() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = 3;\n+        x.f()\n+    };\n+    \"#,\n+        36,\n+    );\n+}\n+\n+#[test]\n+fn generic_fn() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for () {\n+        fn f(&self) -> u8 {\n+            0\n+        }\n+    }\n+\n+    struct Succ<S>(S);\n+\n+    impl<T: Foo> Foo for Succ<T> {\n+        fn f(&self) -> u8 {\n+            self.0.f() + 1\n+        }\n+    }\n+\n+    const GOAL: u8 = Succ(Succ(())).f();\n+    \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    fn foof<T: Foo>(x: T, y: T) -> u8 {\n+        x.f() + y.f()\n+    }\n+\n+    const GOAL: u8 = foof(2, 5);\n+    \"#,\n+        73,\n+    );\n+    check_number(\n+        r#\"\n+    fn bar<A, B>(a: A, b: B) -> B {\n+        b\n+    }\n+        const GOAL: u8 = bar(\"hello\", 12);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    fn bar<A, B>(a: A, b: B) -> B {\n+        b\n+    }\n+    fn foo<T>(x: [T; 2]) -> T {\n+        bar(x[0], x[1])\n+    }\n+\n+    const GOAL: u8 = foo([2, 5]);\n+    \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn impl_trait() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    fn foof(x: impl Foo, y: impl Foo) -> impl Foo {\n+        x.f() + y.f()\n+    }\n+\n+    const GOAL: u8 = foof(2, 5).f();\n+    \"#,\n+        106,\n+    );\n+    check_number(\n+        r#\"\n+        struct Foo<T>(T, T, (T, T));\n+        trait S {\n+            fn sum(&self) -> i64;\n+        }\n+        impl S for i64 {\n+            fn sum(&self) -> i64 {\n+                *self\n+            }\n+        }\n+        impl<T: S> S for Foo<T> {\n+            fn sum(&self) -> i64 {\n+                self.0.sum() + self.1.sum() + self.2 .0.sum() + self.2 .1.sum()\n+            }\n+        }\n+\n+        fn foo() -> Foo<impl S> {\n+            Foo(\n+                Foo(1i64, 2, (3, 4)),\n+                Foo(5, 6, (7, 8)),\n+                (\n+                    Foo(9, 10, (11, 12)),\n+                    Foo(13, 14, (15, 16)),\n+                ),\n+            )\n+        }\n+        const GOAL: i64 = foo().sum();\n+    \"#,\n+        136,\n+    );\n+}\n+\n+#[test]\n+fn ifs() {\n+    check_number(\n+        r#\"\n+    const fn f(b: bool) -> u8 {\n+        if b { 1 } else { 10 }\n+    }\n+\n+    const GOAL: u8 = f(true) + f(true) + f(false);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    const fn max(a: i32, b: i32) -> i32 {\n+        if a < b { b } else { a }\n+    }\n+\n+    const GOAL: u8 = max(max(1, max(10, 3)), 0-122);\n+        \"#,\n+        10,\n+    );\n+\n+    check_number(\n+        r#\"\n+    const fn max(a: &i32, b: &i32) -> &i32 {\n+        if a < b { b } else { a }\n+    }\n+\n+    const GOAL: i32 = *max(max(&1, max(&10, &3)), &5);\n+        \"#,\n+        10,\n+    );\n+}\n+\n+#[test]\n+fn loops() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        loop {\n+            x = x + 1;\n+            while true {\n+                break;\n+            }\n+            x = x + 1;\n+            if x == 2 {\n+                continue;\n+            }\n+            break;\n+        }\n+        x\n+    };\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn recursion() {\n+    check_number(\n+        r#\"\n+    const fn fact(k: i32) -> i32 {\n+        if k > 0 { fact(k - 1) * k } else { 1 }\n+    }\n+\n+    const GOAL: i32 = fact(5);\n+        \"#,\n+        120,\n+    );\n+}\n+\n+#[test]\n+fn structs() {\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let y = 1;\n+            let x = 3;\n+            let q = Point { y, x };\n+            p.x + p.y + p.x + q.y + q.y + q.x\n+        };\n+        \"#,\n+        17,\n+    );\n+}\n+\n+#[test]\n+fn unions() {\n+    check_number(\n+        r#\"\n+        union U {\n+            f1: i64,\n+            f2: (i32, i32),\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = U { f1: 0x0123ABCD0123DCBA };\n+            let p = unsafe { p.f2 };\n+            p.0 + p.1 + p.1\n+        };\n+        \"#,\n+        0x0123ABCD * 2 + 0x0123DCBA,\n+    );\n+}\n+\n+#[test]\n+fn tuples() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let a = (10, 20, 3, 15);\n+        a.1\n+    };\n+        \"#,\n+        20,\n+    );\n+    check_number(\n+        r#\"\n+    struct TupleLike(i32, u8, i64, u16);\n+    const GOAL: u8 = {\n+        let a = TupleLike(10, 20, 3, 15);\n+        a.1\n+    };\n+        \"#,\n+        20,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        match (&(2 + 2), &4) {\n+            (left_val, right_val) => {\n+                if !(*left_val == *right_val) {\n+                    2\n+                } else {\n+                    5\n+                }\n+            }\n+        }\n+    };\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn pattern_matching_ergonomics() {\n+    check_number(\n+        r#\"\n+    const fn f(x: &(u8, u8)) -> u8 {\n+        match x {\n+            (a, b) => *a + *b\n+        }\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn let_else() {\n+    check_number(\n+        r#\"\n+    const fn f(x: &(u8, u8)) -> u8 {\n+        let (a, b) = x;\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    enum SingleVariant {\n+        Var(u8, u8),\n+    }\n+    const fn f(x: &&&&&SingleVariant) -> u8 {\n+        let SingleVariant::Var(a, b) = x;\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&&&&&SingleVariant::Var(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>) -> i32 {\n+        let Some(x) = x else { return 10 };\n+        2 * x\n+    }\n+    const GOAL: u8 = f(Some(1000)) + f(None);\n+        \"#,\n+        2010,\n+    );\n+}\n+\n+#[test]\n+fn options() {\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let x = Some(2);\n+        match x {\n+            Some(y) => 2 * y,\n+            _ => 10,\n+        }\n+    };\n+        \"#,\n+        4,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    fn f(x: Option<Option<i32>>) -> i32 {\n+        if let Some(y) = x && let Some(z) = y {\n+            z\n+        } else if let Some(y) = x {\n+            1\n+        } else {\n+            0\n+        }\n+    }\n+    const GOAL: u8 = f(Some(Some(10))) + f(Some(None)) + f(None);\n+        \"#,\n+        11,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let x = None;\n+        match x {\n+            Some(y) => 2 * y,\n+            _ => 10,\n+        }\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: Option<&u8> = None;\n+        \"#,\n+        0,\n+    );\n+}\n+\n+#[test]\n+fn array_and_index() {\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: u8 = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[u8] = &a;\n+        x[1]\n+    };\n+        \"#,\n+        20,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = [1, 2, 3][2];\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = { let a = [1, 2, 3]; let x: &[i32] = &a; x.len() };\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = [1, 2, 3, 4, 5].len();\"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn byte_string() {\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: u8 = {\n+        let a = b\"hello\";\n+        let x: &[u8] = a;\n+        x[0]\n+    };\n+        \"#,\n+        104,\n+    );\n+}\n+\n #[test]\n fn consts() {\n     check_number(\n@@ -115,18 +688,12 @@ fn enums() {\n     );\n     let r = eval_goal(\n         r#\"\n-        enum E { A = 1, }\n+        enum E { A = 1, B }\n         const GOAL: E = E::A;\n         \"#,\n     )\n     .unwrap();\n-    match r {\n-        ComputedExpr::Enum(name, _, Literal::Uint(val, _)) => {\n-            assert_eq!(name, \"E::A\");\n-            assert_eq!(val, 1);\n-        }\n-        x => panic!(\"Expected enum but found {x:?}\"),\n-    }\n+    assert_eq!(try_const_usize(&r), Some(1));\n }\n \n #[test]\n@@ -138,7 +705,19 @@ fn const_loop() {\n     const F2: i32 = 2 * F1;\n     const GOAL: i32 = F3;\n     \"#,\n-        ConstEvalError::Loop,\n+        ConstEvalError::MirLowerError(MirLowerError::Loop),\n+    );\n+}\n+\n+#[test]\n+fn const_transfer_memory() {\n+    check_number(\n+        r#\"\n+    const A1: &i32 = &2;\n+    const A2: &i32 = &5;\n+    const GOAL: i32 = *A1 + *A2;\n+    \"#,\n+        7,\n     );\n }\n \n@@ -157,7 +736,20 @@ fn const_impl_assoc() {\n }\n \n #[test]\n-fn const_generic_subst() {\n+fn const_generic_subst_fn() {\n+    check_number(\n+        r#\"\n+    const fn f<const A: usize>(x: usize) -> usize {\n+        A * x + 5\n+    }\n+    const GOAL: usize = f::<2>(3);\n+    \"#,\n+        11,\n+    );\n+}\n+\n+#[test]\n+fn const_generic_subst_assoc_const_impl() {\n     // FIXME: this should evaluate to 5\n     check_fail(\n         r#\"\n@@ -167,7 +759,7 @@ fn const_generic_subst() {\n     }\n     const GOAL: usize = Adder::<2, 3>::VAL;\n     \"#,\n-        ConstEvalError::NotSupported(\"const generic without substitution\"),\n+        ConstEvalError::MirEvalError(MirEvalError::TypeError(\"missing generic arg\")),\n     );\n }\n \n@@ -185,6 +777,44 @@ fn const_trait_assoc() {\n     }\n     const GOAL: usize = U0::VAL;\n     \"#,\n-        ConstEvalError::IncompleteExpr,\n+        ConstEvalError::MirLowerError(MirLowerError::IncompleteExpr),\n+    );\n+}\n+\n+#[test]\n+fn exec_limits() {\n+    check_fail(\n+        r#\"\n+    const GOAL: usize = loop {};\n+    \"#,\n+        ConstEvalError::MirEvalError(MirEvalError::ExecutionLimitExceeded),\n+    );\n+    check_fail(\n+        r#\"\n+    const fn f(x: i32) -> i32 {\n+        f(x + 1)\n+    }\n+    const GOAL: i32 = f(0);\n+    \"#,\n+        ConstEvalError::MirEvalError(MirEvalError::StackOverflow),\n+    );\n+    // Reasonable code should still work\n+    check_number(\n+        r#\"\n+    const fn nth_odd(n: i32) -> i32 {\n+        2 * n - 1\n+    }\n+    const fn f(n: i32) -> i32 {\n+        let sum = 0;\n+        let i = 0;\n+        while i < n {\n+            i = i + 1;\n+            sum = sum + nth_odd(i);\n+        }\n+        sum\n+    }\n+    const GOAL: usize = f(10000);\n+    \"#,\n+        10000 * 10000,\n     );\n }"}, {"sha": "60e51b65f6b64d37b5e7aa44ec2ada747fdef051", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -16,10 +16,12 @@ use smallvec::SmallVec;\n \n use crate::{\n     chalk_db,\n-    consteval::{ComputedExpr, ConstEvalError},\n+    consteval::ConstEvalError,\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n-    Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n-    QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId, ValueTyDefId,\n+    mir::{MirBody, MirLowerError},\n+    Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n+    PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n+    ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -32,6 +34,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::infer::infer_query)]\n     fn infer_query(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n \n+    #[salsa::invoke(crate::mir::mir_body_query)]\n+    #[salsa::cycle(crate::mir::mir_body_recover)]\n+    fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n+\n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n     fn ty(&self, def: TyDefId) -> Binders<Ty>;\n@@ -46,13 +52,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n-    #[salsa::invoke(crate::consteval::const_eval_variant_query)]\n+    #[salsa::invoke(crate::consteval::const_eval_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n-    fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n+    fn const_eval(&self, def: ConstId) -> Result<Const, ConstEvalError>;\n \n-    #[salsa::invoke(crate::consteval::const_eval_query_variant)]\n-    #[salsa::cycle(crate::consteval::const_eval_variant_recover)]\n-    fn const_eval_variant(&self, def: EnumVariantId) -> Result<ComputedExpr, ConstEvalError>;\n+    #[salsa::invoke(crate::consteval::const_eval_discriminant_variant)]\n+    #[salsa::cycle(crate::consteval::const_eval_discriminant_recover)]\n+    fn const_eval_discriminant(&self, def: EnumVariantId) -> Result<i128, ConstEvalError>;\n \n     #[salsa::invoke(crate::lower::impl_trait_query)]\n     fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;"}, {"sha": "b6165f629e7ebc0acb3c938d7f53730ddf7878f7", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 122, "deletions": 12, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -7,16 +7,17 @@ use std::fmt::{self, Debug};\n use base_db::CrateId;\n use chalk_ir::BoundVar;\n use hir_def::{\n+    adt::VariantData,\n     body,\n     db::DefDatabase,\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_scope::ItemInNs,\n     lang_item::{LangItem, LangItemTarget},\n     path::{Path, PathKind},\n-    type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n+    type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n-    HasModule, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    HasModule, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n@@ -25,14 +26,17 @@ use smallvec::SmallVec;\n \n use crate::{\n     db::HirDatabase,\n-    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n+    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx,\n+    layout::layout_of_ty,\n+    lt_from_placeholder_idx,\n     mapping::from_chalk,\n+    mir::pad16,\n     primitive, to_assoc_type_id,\n     utils::{self, generics},\n-    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n-    GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n-    OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar, Substitution, TraitRef,\n-    TraitRefExt, Ty, TyExt, TyKind, WhereClause,\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstScalar, ConstValue,\n+    DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives,\n+    MemoryMap, Mutability, OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar,\n+    Substitution, TraitRef, TraitRefExt, Ty, TyExt, TyKind, WhereClause,\n };\n \n pub trait HirWrite: fmt::Write {\n@@ -362,20 +366,125 @@ impl HirDisplay for GenericArg {\n impl HirDisplay for Const {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         let data = self.interned();\n-        match data.value {\n+        match &data.value {\n             ConstValue::BoundVar(idx) => idx.hir_fmt(f),\n             ConstValue::InferenceVar(..) => write!(f, \"#c#\"),\n             ConstValue::Placeholder(idx) => {\n-                let id = from_placeholder_idx(f.db, idx);\n+                let id = from_placeholder_idx(f.db, *idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.type_or_consts[id.local_id];\n                 write!(f, \"{}\", param_data.name().unwrap())\n             }\n-            ConstValue::Concrete(c) => write!(f, \"{}\", c.interned),\n+            ConstValue::Concrete(c) => match &c.interned {\n+                ConstScalar::Bytes(b, m) => render_const_scalar(f, &b, m, &data.ty),\n+                ConstScalar::Unknown => f.write_char('_'),\n+            },\n         }\n     }\n }\n \n+fn render_const_scalar(\n+    f: &mut HirFormatter<'_>,\n+    b: &[u8],\n+    memory_map: &MemoryMap,\n+    ty: &Ty,\n+) -> Result<(), HirDisplayError> {\n+    match ty.kind(Interner) {\n+        chalk_ir::TyKind::Scalar(s) => match s {\n+            Scalar::Bool => write!(f, \"{}\", if b[0] == 0 { false } else { true }),\n+            Scalar::Char => {\n+                let x = u128::from_le_bytes(pad16(b, false)) as u32;\n+                let Ok(c) = char::try_from(x) else {\n+                    return f.write_str(\"<unicode-error>\");\n+                };\n+                write!(f, \"{c:?}\")\n+            }\n+            Scalar::Int(_) => {\n+                let x = i128::from_le_bytes(pad16(b, true));\n+                write!(f, \"{x}\")\n+            }\n+            Scalar::Uint(_) => {\n+                let x = u128::from_le_bytes(pad16(b, false));\n+                write!(f, \"{x}\")\n+            }\n+            Scalar::Float(fl) => match fl {\n+                chalk_ir::FloatTy::F32 => {\n+                    let x = f32::from_le_bytes(b.try_into().unwrap());\n+                    write!(f, \"{x:?}\")\n+                }\n+                chalk_ir::FloatTy::F64 => {\n+                    let x = f64::from_le_bytes(b.try_into().unwrap());\n+                    write!(f, \"{x:?}\")\n+                }\n+            },\n+        },\n+        chalk_ir::TyKind::Ref(_, _, t) => match t.kind(Interner) {\n+            chalk_ir::TyKind::Str => {\n+                let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());\n+                let bytes = memory_map.0.get(&addr).map(|x| &**x).unwrap_or(&[]);\n+                let s = std::str::from_utf8(bytes).unwrap_or(\"<utf8-error>\");\n+                write!(f, \"{s:?}\")\n+            }\n+            _ => f.write_str(\"<error>\"),\n+        },\n+        chalk_ir::TyKind::Adt(adt, subst) => match adt.0 {\n+            hir_def::AdtId::StructId(s) => {\n+                let data = f.db.struct_data(s);\n+                let Ok(layout) = f.db.layout_of_adt(adt.0, subst.clone()) else {\n+                    return f.write_str(\"<layout-error>\");\n+                };\n+                match data.variant_data.as_ref() {\n+                    VariantData::Record(fields) | VariantData::Tuple(fields) => {\n+                        let field_types = f.db.field_types(s.into());\n+                        let krate = adt.0.module(f.db.upcast()).krate();\n+                        let render_field = |f: &mut HirFormatter<'_>, id: LocalFieldId| {\n+                            let offset = layout\n+                                .fields\n+                                .offset(u32::from(id.into_raw()) as usize)\n+                                .bytes_usize();\n+                            let ty = field_types[id].clone().substitute(Interner, subst);\n+                            let Ok(layout) = layout_of_ty(f.db, &ty, krate) else {\n+                                return f.write_str(\"<layout-error>\");\n+                            };\n+                            let size = layout.size.bytes_usize();\n+                            render_const_scalar(f, &b[offset..offset + size], memory_map, &ty)\n+                        };\n+                        let mut it = fields.iter();\n+                        if matches!(data.variant_data.as_ref(), VariantData::Record(_)) {\n+                            write!(f, \"{} {{\", data.name)?;\n+                            if let Some((id, data)) = it.next() {\n+                                write!(f, \" {}: \", data.name)?;\n+                                render_field(f, id)?;\n+                            }\n+                            for (id, data) in it {\n+                                write!(f, \",  {}: \", data.name)?;\n+                                render_field(f, id)?;\n+                            }\n+                            write!(f, \" }}\")?;\n+                        } else {\n+                            let mut it = it.map(|x| x.0);\n+                            write!(f, \"{}(\", data.name)?;\n+                            if let Some(id) = it.next() {\n+                                render_field(f, id)?;\n+                            }\n+                            for id in it {\n+                                write!(f, \", \")?;\n+                                render_field(f, id)?;\n+                            }\n+                            write!(f, \")\")?;\n+                        }\n+                        return Ok(());\n+                    }\n+                    VariantData::Unit => write!(f, \"{}\", data.name),\n+                }\n+            }\n+            hir_def::AdtId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name),\n+            hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n+        },\n+        _ => f.write_str(\"<error>\"),\n+    }\n+}\n+\n impl HirDisplay for BoundVar {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"?{}.{}\", self.debruijn.depth(), self.index)\n@@ -614,8 +723,9 @@ impl HirDisplay for Ty {\n                                     {\n                                         return true;\n                                     }\n-                                    if let Some(ConstValue::Concrete(c)) =\n-                                        parameter.constant(Interner).map(|x| x.data(Interner).value)\n+                                    if let Some(ConstValue::Concrete(c)) = parameter\n+                                        .constant(Interner)\n+                                        .map(|x| &x.data(Interner).value)\n                                     {\n                                         if c.interned == ConstScalar::Unknown {\n                                             return true;"}, {"sha": "c77a5e073757ef877cf09ecde07f75a8be617b7f", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -512,7 +512,11 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn resolve_all(self) -> InferenceResult {\n+    // FIXME: This function should be private in module. It is currently only used in the consteval, since we need\n+    // `InferenceResult` in the middle of inference. See the fixme comment in `consteval::eval_to_const`. If you\n+    // used this function for another workaround, mention it here. If you really need this function and believe that\n+    // there is no problem in it being `pub(crate)`, remove this comment.\n+    pub(crate) fn resolve_all(self) -> InferenceResult {\n         let InferenceContext { mut table, mut result, .. } = self;\n \n         table.fallback_if_possible();\n@@ -681,11 +685,9 @@ impl<'a> InferenceContext<'a> {\n     /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n         let data = c.data(Interner);\n-        match data.value {\n+        match &data.value {\n             ConstValue::Concrete(cc) => match cc.interned {\n-                hir_def::type_ref::ConstScalar::Unknown => {\n-                    self.table.new_const_var(data.ty.clone())\n-                }\n+                crate::ConstScalar::Unknown => self.table.new_const_var(data.ty.clone()),\n                 _ => c,\n             },\n             _ => c,"}, {"sha": "e169cbef49792c52d95750254cb74abe89900081", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -822,7 +822,11 @@ impl<'a> InferenceContext<'a> {\n                             let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n                             coerce.coerce(self, Some(expr), &cur_elem_ty);\n                         }\n-                        consteval::usize_const(Some(elements.len() as u128))\n+                        consteval::usize_const(\n+                            self.db,\n+                            Some(elements.len() as u128),\n+                            self.resolver.krate(),\n+                        )\n                     }\n                     &Array::Repeat { initializer, repeat } => {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n@@ -843,7 +847,7 @@ impl<'a> InferenceContext<'a> {\n                                 DebruijnIndex::INNERMOST,\n                             )\n                         } else {\n-                            consteval::usize_const(None)\n+                            consteval::usize_const(self.db, None, self.resolver.krate())\n                         }\n                     }\n                 };\n@@ -859,7 +863,11 @@ impl<'a> InferenceContext<'a> {\n                 Literal::ByteString(bs) => {\n                     let byte_type = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n \n-                    let len = consteval::usize_const(Some(bs.len() as u128));\n+                    let len = consteval::usize_const(\n+                        self.db,\n+                        Some(bs.len() as u128),\n+                        self.resolver.krate(),\n+                    );\n \n                     let array_type = TyKind::Array(byte_type, len).intern(Interner);\n                     TyKind::Ref(Mutability::Not, static_lifetime(), array_type).intern(Interner)\n@@ -982,8 +990,11 @@ impl<'a> InferenceContext<'a> {\n                     // type and length). This should not be just an error type,\n                     // because we are to compute the unifiability of this type and\n                     // `rhs_ty` in the end of this function to issue type mismatches.\n-                    _ => TyKind::Array(self.err_ty(), crate::consteval::usize_const(None))\n-                        .intern(Interner),\n+                    _ => TyKind::Array(\n+                        self.err_ty(),\n+                        crate::consteval::usize_const(self.db, None, self.resolver.krate()),\n+                    )\n+                    .intern(Interner),\n                 }\n             }\n             Expr::RecordLit { path, fields, .. } => {"}, {"sha": "2c935733c0613eabe33fb46216b50f0f32be6fb5", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -6,17 +6,15 @@ use chalk_ir::Mutability;\n use hir_def::{\n     expr::{BindingAnnotation, Expr, Literal, Pat, PatId},\n     path::Path,\n-    type_ref::ConstScalar,\n };\n use hir_expand::name::Name;\n \n use crate::{\n-    consteval::intern_const_scalar,\n+    consteval::{try_const_usize, usize_const},\n     infer::{BindingMode, Expectation, InferenceContext, TypeMismatch},\n     lower::lower_to_chalk_mutability,\n     primitive::UintTy,\n-    static_lifetime, ConcreteConst, ConstValue, Interner, Scalar, Substitution, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    static_lifetime, Interner, Scalar, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::PatLike;\n@@ -264,18 +262,13 @@ impl<'a> InferenceContext<'a> {\n                 if let &Some(slice_pat_id) = slice {\n                     let rest_pat_ty = match expected.kind(Interner) {\n                         TyKind::Array(_, length) => {\n-                            let len = match length.data(Interner).value {\n-                                ConstValue::Concrete(ConcreteConst {\n-                                    interned: ConstScalar::UInt(len),\n-                                }) => len.checked_sub((prefix.len() + suffix.len()) as u128),\n-                                _ => None,\n-                            };\n+                            let len = try_const_usize(length);\n+                            let len = len.and_then(|len| {\n+                                len.checked_sub((prefix.len() + suffix.len()) as u128)\n+                            });\n                             TyKind::Array(\n                                 elem_ty.clone(),\n-                                intern_const_scalar(\n-                                    len.map_or(ConstScalar::Unknown, |len| ConstScalar::UInt(len)),\n-                                    TyBuilder::usize(),\n-                                ),\n+                                usize_const(self.db, len, self.resolver.krate()),\n                             )\n                         }\n                         _ => TyKind::Slice(elem_ty.clone()),"}, {"sha": "504f0743aa947edc3dcc7981fcf77dd88da8b7aa", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -704,14 +704,13 @@ impl<'a> fmt::Debug for InferenceTable<'a> {\n mod resolve {\n     use super::InferenceTable;\n     use crate::{\n-        ConcreteConst, Const, ConstData, ConstValue, DebruijnIndex, GenericArg, InferenceVar,\n-        Interner, Lifetime, Ty, TyVariableKind, VariableKind,\n+        ConcreteConst, Const, ConstData, ConstScalar, ConstValue, DebruijnIndex, GenericArg,\n+        InferenceVar, Interner, Lifetime, Ty, TyVariableKind, VariableKind,\n     };\n     use chalk_ir::{\n         cast::Cast,\n         fold::{TypeFoldable, TypeFolder},\n     };\n-    use hir_def::type_ref::ConstScalar;\n \n     #[derive(chalk_derive::FallibleTypeFolder)]\n     #[has_interner(Interner)]"}, {"sha": "36af78153d43ad439044e02be4383e1e980df7eb", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -6,12 +6,12 @@ use chalk_ir::{\n     DebruijnIndex,\n };\n use hir_def::{\n-    adt::VariantData, attr::Attrs, type_ref::ConstScalar, visibility::Visibility, AdtId,\n-    EnumVariantId, HasModule, Lookup, ModuleId, VariantId,\n+    adt::VariantData, attr::Attrs, visibility::Visibility, AdtId, EnumVariantId, HasModule, Lookup,\n+    ModuleId, VariantId,\n };\n \n use crate::{\n-    db::HirDatabase, Binders, ConcreteConst, Const, ConstValue, Interner, Substitution, Ty, TyKind,\n+    consteval::try_const_usize, db::HirDatabase, Binders, Interner, Substitution, Ty, TyKind,\n };\n \n /// Checks whether a type is visibly uninhabited from a particular module.\n@@ -69,7 +69,7 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n             TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n             TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n             TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n-            TyKind::Array(item_ty, len) => match try_usize_const(len) {\n+            TyKind::Array(item_ty, len) => match try_const_usize(len) {\n                 Some(0) | None => CONTINUE_OPAQUELY_INHABITED,\n                 Some(1..) => item_ty.super_visit_with(self, outer_binder),\n             },\n@@ -160,14 +160,3 @@ impl UninhabitedFrom<'_> {\n         }\n     }\n }\n-\n-fn try_usize_const(c: &Const) -> Option<u128> {\n-    let data = &c.data(Interner);\n-    if data.ty.kind(Interner) != &TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)) {\n-        return None;\n-    }\n-    match data.value {\n-        ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(value) }) => Some(value),\n-        _ => None,\n-    }\n-}"}, {"sha": "aea7e9762fdf4bfce6914539a301160ded3968f4", "filename": "crates/hir-ty/src/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -1,10 +1,10 @@\n //! Implementation of the Chalk `Interner` trait, which allows customizing the\n //! representation of the various objects Chalk deals with (types, goals etc.).\n \n-use crate::{chalk_db, tls, GenericArg};\n+use crate::{chalk_db, tls, ConstScalar, GenericArg};\n use base_db::salsa::InternId;\n use chalk_ir::{Goal, GoalData};\n-use hir_def::{type_ref::ConstScalar, TypeAliasId};\n+use hir_def::TypeAliasId;\n use intern::{impl_internable, Interned};\n use smallvec::SmallVec;\n use std::{fmt, sync::Arc};"}, {"sha": "a321c211bf4be19cc36d1ef9b34293eca1abf04c", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n };\n use stdx::never;\n \n-use crate::{db::HirDatabase, Interner, Substitution, Ty};\n+use crate::{consteval::try_const_usize, db::HirDatabase, Interner, Substitution, Ty};\n \n use self::adt::struct_variant_idx;\n pub use self::{\n@@ -122,17 +122,9 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             cx.univariant(dl, &fields, &ReprOptions::default(), kind).ok_or(LayoutError::Unknown)?\n         }\n         TyKind::Array(element, count) => {\n-            let count = match count.data(Interner).value {\n-                chalk_ir::ConstValue::Concrete(c) => match c.interned {\n-                    hir_def::type_ref::ConstScalar::Int(x) => x as u64,\n-                    hir_def::type_ref::ConstScalar::UInt(x) => x as u64,\n-                    hir_def::type_ref::ConstScalar::Unknown => {\n-                        user_error!(\"unknown const generic parameter\")\n-                    }\n-                    _ => user_error!(\"mismatched type of const generic parameter\"),\n-                },\n-                _ => return Err(LayoutError::HasPlaceholder),\n-            };\n+            let count = try_const_usize(&count).ok_or(LayoutError::UserError(\n+                \"mismatched type of const generic parameter\".to_string(),\n+            ))? as u64;\n             let element = layout_of_ty(db, element, krate)?;\n             let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow)?;\n "}, {"sha": "b22d0fe8ded1140046b5e555a36a17736438b8aa", "filename": "crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -76,17 +76,8 @@ pub fn layout_of_adt_query(\n             |min, max| Integer::repr_discr(&dl, &repr, min, max).unwrap_or((Integer::I8, false)),\n             variants.iter_enumerated().filter_map(|(id, _)| {\n                 let AdtId::EnumId(e) = def else { return None };\n-                let d = match db\n-                    .const_eval_variant(EnumVariantId { parent: e, local_id: id.0 })\n-                    .ok()?\n-                {\n-                    crate::consteval::ComputedExpr::Literal(l) => match l {\n-                        hir_def::expr::Literal::Int(i, _) => i,\n-                        hir_def::expr::Literal::Uint(i, _) => i as i128,\n-                        _ => return None,\n-                    },\n-                    _ => return None,\n-                };\n+                let d =\n+                    db.const_eval_discriminant(EnumVariantId { parent: e, local_id: id.0 }).ok()?;\n                 Some((id, d))\n             }),\n             // FIXME: The current code for niche-filling relies on variant indices"}, {"sha": "546044fc13aba136e456a32b448e9d2de00806f2", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -82,8 +82,8 @@ fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n #[track_caller]\n fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n     let l = eval_goal(ra_fixture, minicore).unwrap();\n-    assert_eq!(l.size.bytes(), size);\n-    assert_eq!(l.align.abi.bytes(), align);\n+    assert_eq!(l.size.bytes(), size, \"size mismatch\");\n+    assert_eq!(l.align.abi.bytes(), align, \"align mismatch\");\n }\n \n #[track_caller]\n@@ -300,4 +300,9 @@ fn enums_with_discriminants() {\n             C, // implicitly becomes 256, so we need two bytes\n         }\n     }\n+    size_and_align! {\n+        enum Goal {\n+            A = 1, // This one is (perhaps surprisingly) zero sized.\n+        }\n+    }\n }"}, {"sha": "9c63d67ab19a4b8109d224977605d4a0210e7410", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -13,6 +13,7 @@ mod builder;\n mod chalk_db;\n mod chalk_ext;\n pub mod consteval;\n+pub mod mir;\n mod infer;\n mod inhabitedness;\n mod interner;\n@@ -34,7 +35,7 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n \n-use std::sync::Arc;\n+use std::{collections::HashMap, hash::Hash, sync::Arc};\n \n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n@@ -46,6 +47,7 @@ use either::Either;\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use la_arena::{Arena, Idx};\n+use mir::MirEvalError;\n use rustc_hash::FxHashSet;\n use traits::FnTrait;\n use utils::Generics;\n@@ -145,6 +147,49 @@ pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n pub type Guidance = chalk_solve::Guidance<Interner>;\n pub type WhereClause = chalk_ir::WhereClause<Interner>;\n \n+/// A constant can have reference to other things. Memory map job is holding\n+/// the neccessary bits of memory of the const eval session to keep the constant\n+/// meaningful.\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+pub struct MemoryMap(pub HashMap<usize, Vec<u8>>);\n+\n+impl MemoryMap {\n+    fn insert(&mut self, addr: usize, x: Vec<u8>) {\n+        self.0.insert(addr, x);\n+    }\n+\n+    /// This functions convert each address by a function `f` which gets the byte intervals and assign an address\n+    /// to them. It is useful when you want to load a constant with a memory map in a new memory. You can pass an\n+    /// allocator function as `f` and it will return a mapping of old addresses to new addresses.\n+    fn transform_addresses(\n+        &self,\n+        mut f: impl FnMut(&[u8]) -> Result<usize, MirEvalError>,\n+    ) -> Result<HashMap<usize, usize>, MirEvalError> {\n+        self.0.iter().map(|x| Ok((*x.0, f(x.1)?))).collect()\n+    }\n+}\n+\n+/// A concrete constant value\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ConstScalar {\n+    Bytes(Vec<u8>, MemoryMap),\n+    /// Case of an unknown value that rustc might know but we don't\n+    // FIXME: this is a hack to get around chalk not being able to represent unevaluatable\n+    // constants\n+    // https://github.com/rust-lang/rust-analyzer/pull/8813#issuecomment-840679177\n+    // https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/Handling.20non.20evaluatable.20constants'.20equality/near/238386348\n+    Unknown,\n+}\n+\n+impl Hash for ConstScalar {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        core::mem::discriminant(self).hash(state);\n+        if let ConstScalar::Bytes(b, _) = self {\n+            b.hash(state)\n+        }\n+    }\n+}\n+\n /// Return an index of a parameter in the generic type parameter list by it's id.\n pub fn param_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)"}, {"sha": "296c6c5b21fab3d8983a2232caa24900682be4ad", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -27,9 +27,7 @@ use hir_def::{\n     lang_item::{lang_attr, LangItem},\n     path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{\n-        ConstScalarOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef,\n-    },\n+    type_ref::{ConstRefOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n     AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n     HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n@@ -44,7 +42,7 @@ use syntax::ast;\n \n use crate::{\n     all_super_traits,\n-    consteval::{intern_const_scalar, path_to_const, unknown_const, unknown_const_as_generic},\n+    consteval::{intern_const_ref, path_to_const, unknown_const, unknown_const_as_generic},\n     db::HirDatabase,\n     make_binders,\n     mapping::{from_chalk_trait_id, ToChalk},\n@@ -968,7 +966,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // - `Destruct` impls are built-in in 1.62 (current nightlies as of 08-04-2022), so until\n                         //   the builtin impls are supported by Chalk, we ignore them here.\n                         if let Some(lang) = lang_attr(self.db.upcast(), tr.hir_trait_id()) {\n-                            if lang == \"drop\" || lang == \"destruct\" {\n+                            if matches!(lang, LangItem::Drop | LangItem::Destruct) {\n                                 return false;\n                             }\n                         }\n@@ -1919,7 +1917,7 @@ pub(crate) fn generic_arg_to_chalk<'a, T>(\n     arg: &'a GenericArg,\n     this: &mut T,\n     for_type: impl FnOnce(&mut T, &TypeRef) -> Ty + 'a,\n-    for_const: impl FnOnce(&mut T, &ConstScalarOrPath, Ty) -> Const + 'a,\n+    for_const: impl FnOnce(&mut T, &ConstRefOrPath, Ty) -> Const + 'a,\n ) -> Option<crate::GenericArg> {\n     let kind = match kind_id {\n         Either::Left(_) => ParamKind::Type,\n@@ -1947,7 +1945,7 @@ pub(crate) fn generic_arg_to_chalk<'a, T>(\n                 let p = p.mod_path();\n                 if p.kind == PathKind::Plain {\n                     if let [n] = p.segments() {\n-                        let c = ConstScalarOrPath::Path(n.clone());\n+                        let c = ConstRefOrPath::Path(n.clone());\n                         return Some(\n                             GenericArgData::Const(for_const(this, &c, c_ty)).intern(Interner),\n                         );\n@@ -1964,14 +1962,14 @@ pub(crate) fn const_or_path_to_chalk(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     expected_ty: Ty,\n-    value: &ConstScalarOrPath,\n+    value: &ConstRefOrPath,\n     mode: ParamLoweringMode,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {\n     match value {\n-        ConstScalarOrPath::Scalar(s) => intern_const_scalar(*s, expected_ty),\n-        ConstScalarOrPath::Path(n) => {\n+        ConstRefOrPath::Scalar(s) => intern_const_ref(db, s, expected_ty, resolver.krate()),\n+        ConstRefOrPath::Path(n) => {\n             let path = ModPath::from_segments(PathKind::Plain, Some(n.clone()));\n             path_to_const(db, resolver, &path, mode, args, debruijn)\n                 .unwrap_or_else(|| unknown_const(expected_ty))"}, {"sha": "8dd34bc38823b743a591c4d0d7360e9b4f406981", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -660,23 +660,25 @@ pub fn lookup_impl_const(\n     env: Arc<TraitEnvironment>,\n     const_id: ConstId,\n     subs: Substitution,\n-) -> ConstId {\n+) -> (ConstId, Substitution) {\n     let trait_id = match const_id.lookup(db.upcast()).container {\n         ItemContainerId::TraitId(id) => id,\n-        _ => return const_id,\n+        _ => return (const_id, subs),\n     };\n     let substitution = Substitution::from_iter(Interner, subs.iter(Interner));\n     let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution };\n \n     let const_data = db.const_data(const_id);\n     let name = match const_data.name.as_ref() {\n         Some(name) => name,\n-        None => return const_id,\n+        None => return (const_id, subs),\n     };\n \n     lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n-        .and_then(|assoc| if let AssocItemId::ConstId(id) = assoc { Some(id) } else { None })\n-        .unwrap_or(const_id)\n+        .and_then(\n+            |assoc| if let (AssocItemId::ConstId(id), s) = assoc { Some((id, s)) } else { None },\n+        )\n+        .unwrap_or((const_id, subs))\n }\n \n /// Looks up the impl method that actually runs for the trait method `func`.\n@@ -687,10 +689,10 @@ pub fn lookup_impl_method(\n     env: Arc<TraitEnvironment>,\n     func: FunctionId,\n     fn_subst: Substitution,\n-) -> FunctionId {\n+) -> (FunctionId, Substitution) {\n     let trait_id = match func.lookup(db.upcast()).container {\n         ItemContainerId::TraitId(id) => id,\n-        _ => return func,\n+        _ => return (func, fn_subst),\n     };\n     let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n     let fn_params = fn_subst.len(Interner) - trait_params;\n@@ -701,25 +703,31 @@ pub fn lookup_impl_method(\n \n     let name = &db.function_data(func).name;\n     lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n-        .and_then(|assoc| if let AssocItemId::FunctionId(id) = assoc { Some(id) } else { None })\n-        .unwrap_or(func)\n+        .and_then(|assoc| {\n+            if let (AssocItemId::FunctionId(id), subst) = assoc {\n+                Some((id, subst))\n+            } else {\n+                None\n+            }\n+        })\n+        .unwrap_or((func, fn_subst))\n }\n \n fn lookup_impl_assoc_item_for_trait_ref(\n     trait_ref: TraitRef,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     name: &Name,\n-) -> Option<AssocItemId> {\n+) -> Option<(AssocItemId, Substitution)> {\n     let self_ty = trait_ref.self_type_parameter(Interner);\n     let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n     let impls = db.trait_impls_in_deps(env.krate);\n     let impls = impls.for_trait_and_self_ty(trait_ref.hir_trait_id(), self_ty_fp);\n \n     let table = InferenceTable::new(db, env);\n \n-    let impl_data = find_matching_impl(impls, table, trait_ref)?;\n-    impl_data.items.iter().find_map(|&it| match it {\n+    let (impl_data, impl_subst) = find_matching_impl(impls, table, trait_ref)?;\n+    let item = impl_data.items.iter().find_map(|&it| match it {\n         AssocItemId::FunctionId(f) => {\n             (db.function_data(f).name == *name).then_some(AssocItemId::FunctionId(f))\n         }\n@@ -730,14 +738,15 @@ fn lookup_impl_assoc_item_for_trait_ref(\n             .map(|n| n == name)\n             .and_then(|result| if result { Some(AssocItemId::ConstId(c)) } else { None }),\n         AssocItemId::TypeAliasId(_) => None,\n-    })\n+    })?;\n+    Some((item, impl_subst))\n }\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n     mut table: InferenceTable<'_>,\n     actual_trait_ref: TraitRef,\n-) -> Option<Arc<ImplData>> {\n+) -> Option<(Arc<ImplData>, Substitution)> {\n     let db = table.db;\n     loop {\n         let impl_ = impls.next()?;\n@@ -758,7 +767,7 @@ fn find_matching_impl(\n                 .into_iter()\n                 .map(|b| b.cast(Interner));\n             let goal = crate::Goal::all(Interner, wcs);\n-            table.try_obligation(goal).map(|_| impl_data)\n+            table.try_obligation(goal).map(|_| (impl_data, table.resolve_completely(impl_substs)))\n         });\n         if r.is_some() {\n             break r;"}, {"sha": "00fa6b795222c55e7252d719bf934741717c01aa", "filename": "crates/hir-ty/src/mir.rs", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -0,0 +1,811 @@\n+//! MIR definitions and implementation\n+\n+use std::iter;\n+\n+use crate::{\n+    infer::PointerCast, Const, ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty,\n+};\n+use chalk_ir::Mutability;\n+use hir_def::{\n+    expr::{Expr, Ordering},\n+    DefWithBodyId, FieldId, UnionId, VariantId,\n+};\n+use la_arena::{Arena, Idx, RawIdx};\n+\n+mod eval;\n+mod lower;\n+\n+pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n+pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n+use smallvec::{smallvec, SmallVec};\n+\n+use super::consteval::{intern_const_scalar, try_const_usize};\n+\n+pub type BasicBlockId = Idx<BasicBlock>;\n+pub type LocalId = Idx<Local>;\n+\n+fn return_slot() -> LocalId {\n+    LocalId::from_raw(RawIdx::from(0))\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct Local {\n+    pub mutability: Mutability,\n+    //pub local_info: Option<Box<LocalInfo>>,\n+    //pub internal: bool,\n+    //pub is_block_tail: Option<BlockTailInfo>,\n+    pub ty: Ty,\n+    //pub user_ty: Option<Box<UserTypeProjections>>,\n+    //pub source_info: SourceInfo,\n+}\n+\n+/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n+/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n+///\n+/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n+///\n+/// The most common way to create values is via loading a place. Loading a place is an operation\n+/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n+/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n+/// there may be other effects: if the type has a validity constraint loading the place might be UB\n+/// if the validity constraint is not met.\n+///\n+/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n+/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n+/// something we can even decide without knowing more about Rust's memory model?\n+///\n+/// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n+/// currently implements it, but it seems like this may be something to check against in the\n+/// validator.\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Operand {\n+    /// Creates a value by loading the given place.\n+    ///\n+    /// Before drop elaboration, the type of the place must be `Copy`. After drop elaboration there\n+    /// is no such requirement.\n+    Copy(Place),\n+\n+    /// Creates a value by performing loading the place, just like the `Copy` operand.\n+    ///\n+    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n+    /// place without first re-initializing it.\n+    ///\n+    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n+    Move(Place),\n+    /// Constants are already semantically values, and remain unchanged.\n+    Constant(Const),\n+}\n+\n+impl Operand {\n+    fn from_concrete_const(data: Vec<u8>, memory_map: MemoryMap, ty: Ty) -> Self {\n+        Operand::Constant(intern_const_scalar(ConstScalar::Bytes(data, memory_map), ty))\n+    }\n+\n+    fn from_bytes(data: Vec<u8>, ty: Ty) -> Self {\n+        Operand::from_concrete_const(data, MemoryMap::default(), ty)\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum ProjectionElem<V, T> {\n+    Deref,\n+    Field(FieldId),\n+    TupleField(usize),\n+    Index(V),\n+    ConstantIndex { offset: u64, min_length: u64, from_end: bool },\n+    Subslice { from: u64, to: u64, from_end: bool },\n+    //Downcast(Option<Symbol>, VariantIdx),\n+    OpaqueCast(T),\n+}\n+\n+type PlaceElem = ProjectionElem<LocalId, Ty>;\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Place {\n+    pub local: LocalId,\n+    pub projection: Vec<PlaceElem>,\n+}\n+\n+impl From<LocalId> for Place {\n+    fn from(local: LocalId) -> Self {\n+        Self { local, projection: vec![] }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum AggregateKind {\n+    /// The type is of the element\n+    Array(Ty),\n+    /// The type is of the tuple\n+    Tuple(Ty),\n+    Adt(VariantId, Substitution),\n+    Union(UnionId, FieldId),\n+    //Closure(LocalDefId, SubstsRef),\n+    //Generator(LocalDefId, SubstsRef, Movability),\n+}\n+\n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n+pub struct SwitchTargets {\n+    /// Possible values. The locations to branch to in each case\n+    /// are found in the corresponding indices from the `targets` vector.\n+    values: SmallVec<[u128; 1]>,\n+\n+    /// Possible branch sites. The last element of this vector is used\n+    /// for the otherwise branch, so targets.len() == values.len() + 1\n+    /// should hold.\n+    //\n+    // This invariant is quite non-obvious and also could be improved.\n+    // One way to make this invariant is to have something like this instead:\n+    //\n+    // branches: Vec<(ConstInt, BasicBlock)>,\n+    // otherwise: Option<BasicBlock> // exhaustive if None\n+    //\n+    // However we\u2019ve decided to keep this as-is until we figure a case\n+    // where some other approach seems to be strictly better than other.\n+    targets: SmallVec<[BasicBlockId; 2]>,\n+}\n+\n+impl SwitchTargets {\n+    /// Creates switch targets from an iterator of values and target blocks.\n+    ///\n+    /// The iterator may be empty, in which case the `SwitchInt` instruction is equivalent to\n+    /// `goto otherwise;`.\n+    pub fn new(\n+        targets: impl Iterator<Item = (u128, BasicBlockId)>,\n+        otherwise: BasicBlockId,\n+    ) -> Self {\n+        let (values, mut targets): (SmallVec<_>, SmallVec<_>) = targets.unzip();\n+        targets.push(otherwise);\n+        Self { values, targets }\n+    }\n+\n+    /// Builds a switch targets definition that jumps to `then` if the tested value equals `value`,\n+    /// and to `else_` if not.\n+    pub fn static_if(value: u128, then: BasicBlockId, else_: BasicBlockId) -> Self {\n+        Self { values: smallvec![value], targets: smallvec![then, else_] }\n+    }\n+\n+    /// Returns the fallback target that is jumped to when none of the values match the operand.\n+    pub fn otherwise(&self) -> BasicBlockId {\n+        *self.targets.last().unwrap()\n+    }\n+\n+    /// Returns an iterator over the switch targets.\n+    ///\n+    /// The iterator will yield tuples containing the value and corresponding target to jump to, not\n+    /// including the `otherwise` fallback target.\n+    ///\n+    /// Note that this may yield 0 elements. Only the `otherwise` branch is mandatory.\n+    pub fn iter(&self) -> impl Iterator<Item = (u128, BasicBlockId)> + '_ {\n+        iter::zip(&self.values, &self.targets).map(|(x, y)| (*x, *y))\n+    }\n+\n+    /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the\n+    /// specific value. This cannot fail, as it'll return the `otherwise`\n+    /// branch if there's not a specific match for the value.\n+    pub fn target_for_value(&self, value: u128) -> BasicBlockId {\n+        self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise())\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Terminator {\n+    /// Block has one successor; we continue execution there.\n+    Goto { target: BasicBlockId },\n+\n+    /// Switches based on the computed value.\n+    ///\n+    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n+    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n+    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n+    /// continues execution at the \"otherwise\" basic block.\n+    ///\n+    /// Target values may not appear more than once.\n+    SwitchInt {\n+        /// The discriminant value being tested.\n+        discr: Operand,\n+\n+        targets: SwitchTargets,\n+    },\n+\n+    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n+    ///\n+    /// Like a return, this marks the end of this invocation of the function.\n+    ///\n+    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n+    /// deaggregation runs.\n+    Resume,\n+\n+    /// Indicates that the landing pad is finished and that the process should abort.\n+    ///\n+    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n+    /// cleanup blocks.\n+    Abort,\n+\n+    /// Returns from the function.\n+    ///\n+    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n+    /// likely at least assigns the value currently in the return place (`_0`) to the place\n+    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n+    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n+    /// aliasing model.\n+    ///\n+    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n+    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n+    /// to the return place.\n+    Return,\n+\n+    /// Indicates a terminator that can never be reached.\n+    ///\n+    /// Executing this terminator is UB.\n+    Unreachable,\n+\n+    /// The behavior of this statement differs significantly before and after drop elaboration.\n+    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n+    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n+    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n+    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n+    /// call?)\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n+    /// `Drop` will be executed if...\n+    ///\n+    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n+    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n+    ///\n+    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n+    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n+    /// > consider indirect assignments.\n+    Drop { place: Place, target: BasicBlockId, unwind: Option<BasicBlockId> },\n+\n+    /// Drops the place and assigns a new value to it.\n+    ///\n+    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n+    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n+    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n+    /// explained by the elaboration:\n+    ///\n+    /// ```ignore (MIR)\n+    /// BB0 {\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```ignore (MIR)\n+    /// BB0 {\n+    ///   Drop(P, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // P is now uninitialized\n+    ///   P <- V\n+    /// }\n+    /// BB2 {\n+    ///   // P is now uninitialized -- its dtor panicked\n+    ///   P <- V\n+    /// }\n+    /// ```\n+    ///\n+    /// Disallowed after drop elaboration.\n+    DropAndReplace {\n+        place: Place,\n+        value: Operand,\n+        target: BasicBlockId,\n+        unwind: Option<BasicBlockId>,\n+    },\n+\n+    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n+    /// the referred to function. The operand types must match the argument types of the function.\n+    /// The return place type must match the return type. The type of the `func` operand must be\n+    /// callable, meaning either a function pointer, a function type, or a closure type.\n+    ///\n+    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n+    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n+    /// [#71117].\n+    ///\n+    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n+    Call {\n+        /// The function that\u2019s being called.\n+        func: Operand,\n+        /// Arguments the function is called with.\n+        /// These are owned by the callee, which is free to modify them.\n+        /// This allows the memory occupied by \"by-value\" arguments to be\n+        /// reused across function calls without duplicating the contents.\n+        args: Vec<Operand>,\n+        /// Where the returned value will be written\n+        destination: Place,\n+        /// Where to go after this call returns. If none, the call necessarily diverges.\n+        target: Option<BasicBlockId>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlockId>,\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n+        /// operator. True for overloaded function call.\n+        from_hir_call: bool,\n+        // This `Span` is the span of the function, without the dot and receiver\n+        // (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        //fn_span: Span,\n+    },\n+\n+    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n+    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n+    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n+    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n+    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n+    /// assertion does not fail, execution continues at the specified basic block.\n+    Assert {\n+        cond: Operand,\n+        expected: bool,\n+        //msg: AssertMessage,\n+        target: BasicBlockId,\n+        cleanup: Option<BasicBlockId>,\n+    },\n+\n+    /// Marks a suspend point.\n+    ///\n+    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n+    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n+    /// the return place of the function calling this one, and execution continues in the calling\n+    /// function. When next invoked with the same first argument, execution of this function\n+    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n+    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n+    ///\n+    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n+    ///\n+    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n+    Yield {\n+        /// The value to return.\n+        value: Operand,\n+        /// Where to resume to.\n+        resume: BasicBlockId,\n+        /// The place to store the resume argument in.\n+        resume_arg: Place,\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n+        drop: Option<BasicBlockId>,\n+    },\n+\n+    /// Indicates the end of dropping a generator.\n+    ///\n+    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n+    /// as `yield`.\n+    ///\n+    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n+    /// to me, because it's not even really in the current body.\n+    ///\n+    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n+    /// there be a \"block type\" like `cleanup` blocks for them?\n+    GeneratorDrop,\n+\n+    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n+    /// conservative.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FalseEdge {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlockId,\n+        /// A block control flow could conceptually jump to, but won't in\n+        /// practice.\n+        imaginary_target: BasicBlockId,\n+    },\n+\n+    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n+    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n+    /// with no function calls for example.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FalseUnwind {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlockId,\n+        /// The imaginary cleanup block link. This particular path will never be taken\n+        /// in practice, but in order to avoid fragility we want to always\n+        /// consider it in borrowck. We don't want to accept programs which\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `abort_unwinding_calls` passes.\n+        unwind: Option<BasicBlockId>,\n+    },\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    Shared,\n+\n+    /// The immediately borrowed place must be immutable, but projections from\n+    /// it don't need to be. For example, a shallow borrow of `a.b` doesn't\n+    /// conflict with a mutable borrow of `a.b.c`.\n+    ///\n+    /// This is used when lowering matches: when matching on a place we want to\n+    /// ensure that place have the same value from the start of the match until\n+    /// an arm is selected. This prevents this code from compiling:\n+    /// ```compile_fail,E0510\n+    /// let mut x = &Some(0);\n+    /// match *x {\n+    ///     None => (),\n+    ///     Some(_) if { x = &None; false } => (),\n+    ///     Some(_) => (),\n+    /// }\n+    /// ```\n+    /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n+    /// should not prevent `if let None = x { ... }`, for example, because the\n+    /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n+    /// We can also report errors with this kind of borrow differently.\n+    Shallow,\n+\n+    /// Data must be immutable but not aliasable. This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when the closure is\n+    /// borrowing or mutating a mutable referent, e.g.:\n+    /// ```\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = || *x += 5;\n+    /// ```\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    /// ```compile_fail,E0594\n+    /// struct Env<'a> { x: &'a &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// This is then illegal because you cannot mutate an `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    /// ```compile_fail,E0596\n+    /// struct Env<'a> { x: &'a mut &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    Unique,\n+\n+    /// Data is mutable and not aliasable.\n+    Mut {\n+        /// `true` if this borrow arose from method-call auto-ref\n+        /// (i.e., `adjustment::Adjust::Borrow`).\n+        allow_two_phase_borrow: bool,\n+    },\n+}\n+\n+impl BorrowKind {\n+    fn from_hir(m: hir_def::type_ref::Mutability) -> Self {\n+        match m {\n+            hir_def::type_ref::Mutability::Shared => BorrowKind::Shared,\n+            hir_def::type_ref::Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+        }\n+    }\n+\n+    fn from_chalk(m: Mutability) -> Self {\n+        match m {\n+            Mutability::Not => BorrowKind::Shared,\n+            Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum UnOp {\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum BinOp {\n+    /// The `+` operator (addition)\n+    Add,\n+    /// The `-` operator (subtraction)\n+    Sub,\n+    /// The `*` operator (multiplication)\n+    Mul,\n+    /// The `/` operator (division)\n+    ///\n+    /// Division by zero is UB, because the compiler should have inserted checks\n+    /// prior to this.\n+    Div,\n+    /// The `%` operator (modulus)\n+    ///\n+    /// Using zero as the modulus (second operand) is UB, because the compiler\n+    /// should have inserted checks prior to this.\n+    Rem,\n+    /// The `^` operator (bitwise xor)\n+    BitXor,\n+    /// The `&` operator (bitwise and)\n+    BitAnd,\n+    /// The `|` operator (bitwise or)\n+    BitOr,\n+    /// The `<<` operator (shift left)\n+    ///\n+    /// The offset is truncated to the size of the first operand before shifting.\n+    Shl,\n+    /// The `>>` operator (shift right)\n+    ///\n+    /// The offset is truncated to the size of the first operand before shifting.\n+    Shr,\n+    /// The `==` operator (equality)\n+    Eq,\n+    /// The `<` operator (less than)\n+    Lt,\n+    /// The `<=` operator (less than or equal to)\n+    Le,\n+    /// The `!=` operator (not equal to)\n+    Ne,\n+    /// The `>=` operator (greater than or equal to)\n+    Ge,\n+    /// The `>` operator (greater than)\n+    Gt,\n+    /// The `ptr.offset` operator\n+    Offset,\n+}\n+\n+impl From<hir_def::expr::ArithOp> for BinOp {\n+    fn from(value: hir_def::expr::ArithOp) -> Self {\n+        match value {\n+            hir_def::expr::ArithOp::Add => BinOp::Add,\n+            hir_def::expr::ArithOp::Mul => BinOp::Mul,\n+            hir_def::expr::ArithOp::Sub => BinOp::Sub,\n+            hir_def::expr::ArithOp::Div => BinOp::Div,\n+            hir_def::expr::ArithOp::Rem => BinOp::Rem,\n+            hir_def::expr::ArithOp::Shl => BinOp::Shl,\n+            hir_def::expr::ArithOp::Shr => BinOp::Shr,\n+            hir_def::expr::ArithOp::BitXor => BinOp::BitXor,\n+            hir_def::expr::ArithOp::BitOr => BinOp::BitOr,\n+            hir_def::expr::ArithOp::BitAnd => BinOp::BitAnd,\n+        }\n+    }\n+}\n+\n+impl From<hir_def::expr::CmpOp> for BinOp {\n+    fn from(value: hir_def::expr::CmpOp) -> Self {\n+        match value {\n+            hir_def::expr::CmpOp::Eq { negated: false } => BinOp::Eq,\n+            hir_def::expr::CmpOp::Eq { negated: true } => BinOp::Ne,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Greater, strict: false } => BinOp::Ge,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Greater, strict: true } => BinOp::Gt,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Less, strict: false } => BinOp::Le,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Less, strict: true } => BinOp::Lt,\n+        }\n+    }\n+}\n+\n+impl From<Operand> for Rvalue {\n+    fn from(x: Operand) -> Self {\n+        Self::Use(x)\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum CastKind {\n+    /// An exposing pointer to address cast. A cast between a pointer and an integer type, or\n+    /// between a function pointer and an integer type.\n+    /// See the docs on `expose_addr` for more details.\n+    PointerExposeAddress,\n+    /// An address-to-pointer cast that picks up an exposed provenance.\n+    /// See the docs on `from_exposed_addr` for more details.\n+    PointerFromExposedAddress,\n+    /// All sorts of pointer-to-pointer casts. Note that reference-to-raw-ptr casts are\n+    /// translated into `&raw mut/const *r`, i.e., they are not actually casts.\n+    Pointer(PointerCast),\n+    /// Cast into a dyn* object.\n+    DynStar,\n+    IntToInt,\n+    FloatToInt,\n+    FloatToFloat,\n+    IntToFloat,\n+    PtrToPtr,\n+    FnPtrToPtr,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Rvalue {\n+    /// Yields the operand unchanged\n+    Use(Operand),\n+\n+    /// Creates an array where each element is the value of the operand.\n+    ///\n+    /// This is the cause of a bug in the case where the repetition count is zero because the value\n+    /// is not dropped, see [#74836].\n+    ///\n+    /// Corresponds to source code like `[x; 32]`.\n+    ///\n+    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n+    //Repeat(Operand, ty::Const),\n+\n+    /// Creates a reference of the indicated kind to the place.\n+    ///\n+    /// There is not much to document here, because besides the obvious parts the semantics of this\n+    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n+    /// exactly what the behavior of this operation should be.\n+    ///\n+    /// `Shallow` borrows are disallowed after drop lowering.\n+    Ref(BorrowKind, Place),\n+\n+    /// Creates a pointer/reference to the given thread local.\n+    ///\n+    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n+    /// `*const T`, and if neither of those apply a `&T`.\n+    ///\n+    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n+    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n+    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n+    ///\n+    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n+    /// nature of this operation?\n+    //ThreadLocalRef(DefId),\n+\n+    /// Creates a pointer with the indicated mutability to the place.\n+    ///\n+    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n+    /// `&raw v` or `addr_of!(v)`.\n+    ///\n+    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n+    /// model.\n+    //AddressOf(Mutability, Place),\n+\n+    /// Yields the length of the place, as a `usize`.\n+    ///\n+    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n+    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n+    /// ill-formed for places of other types.\n+    Len(Place),\n+\n+    /// Performs essentially all of the casts that can be performed via `as`.\n+    ///\n+    /// This allows for casts from/to a variety of types.\n+    ///\n+    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n+    /// `ArrayToPointer` and `MutToConstPointer` are special.\n+    Cast(CastKind, Operand, Ty),\n+\n+    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n+    ///   parameter may be a `usize` as well.\n+    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n+    ///   raw pointers, or function pointers and return a `bool`. The types of the operands must be\n+    ///   matching, up to the usual caveat of the lifetimes in function pointers.\n+    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n+    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n+    ///   truncated as needed.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n+    ///   types and return a value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n+    ///   matching types and return a value of that type.\n+    //BinaryOp(BinOp, Box<(Operand, Operand)>),\n+\n+    /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n+    ///\n+    /// When overflow checking is disabled and we are generating run-time code, the error condition\n+    /// is false. Otherwise, and always during CTFE, the error condition is determined as described\n+    /// below.\n+    ///\n+    /// For addition, subtraction, and multiplication on integers the error condition is set when\n+    /// the infinite precision result would be unequal to the actual result.\n+    ///\n+    /// For shift operations on integers the error condition is set when the value of right-hand\n+    /// side is greater than or equal to the number of bits in the type of the left-hand side, or\n+    /// when the value of right-hand side is negative.\n+    ///\n+    /// Other combinations of types and operators are unsupported.\n+    CheckedBinaryOp(BinOp, Operand, Operand),\n+\n+    /// Computes a value as described by the operation.\n+    //NullaryOp(NullOp, Ty),\n+\n+    /// Exactly like `BinaryOp`, but less operands.\n+    ///\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n+    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n+    /// return a value with the same type as their operand.\n+    UnaryOp(UnOp, Operand),\n+\n+    /// Computes the discriminant of the place, returning it as an integer of type\n+    /// [`discriminant_ty`]. Returns zero for types without discriminant.\n+    ///\n+    /// The validity requirements for the underlying value are undecided for this rvalue, see\n+    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n+    /// variant index; use [`discriminant_for_variant`] to convert.\n+    ///\n+    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n+    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n+    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n+    Discriminant(Place),\n+\n+    /// Creates an aggregate value, like a tuple or struct.\n+    ///\n+    /// This is needed because dataflow analysis needs to distinguish\n+    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n+    /// has a destructor.\n+    ///\n+    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n+    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n+    Aggregate(AggregateKind, Vec<Operand>),\n+\n+    /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n+    ///\n+    /// This is different from a normal transmute because dataflow analysis will treat the box as\n+    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n+    /// affects alias analysis.\n+    ShallowInitBox(Operand, Ty),\n+\n+    /// A CopyForDeref is equivalent to a read from a place at the\n+    /// codegen level, but is treated specially by drop elaboration. When such a read happens, it\n+    /// is guaranteed (via nature of the mir_opt `Derefer` in rustc_mir_transform/src/deref_separator)\n+    /// that the only use of the returned value is a deref operation, immediately\n+    /// followed by one or more projections. Drop elaboration treats this rvalue as if the\n+    /// read never happened and just projects further. This allows simplifying various MIR\n+    /// optimizations and codegen backends that previously had to handle deref operations anywhere\n+    /// in a place.\n+    CopyForDeref(Place),\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Statement {\n+    Assign(Place, Rvalue),\n+    //FakeRead(Box<(FakeReadCause, Place)>),\n+    //SetDiscriminant {\n+    //    place: Box<Place>,\n+    //    variant_index: VariantIdx,\n+    //},\n+    Deinit(Place),\n+    StorageLive(LocalId),\n+    StorageDead(LocalId),\n+    //Retag(RetagKind, Box<Place>),\n+    //AscribeUserType(Place, UserTypeProjection, Variance),\n+    //Intrinsic(Box<NonDivergingIntrinsic>),\n+    Nop,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct BasicBlock {\n+    /// List of statements in this block.\n+    pub statements: Vec<Statement>,\n+\n+    /// Terminator for this block.\n+    ///\n+    /// N.B., this should generally ONLY be `None` during construction.\n+    /// Therefore, you should generally access it via the\n+    /// `terminator()` or `terminator_mut()` methods. The only\n+    /// exception is that certain passes, such as `simplify_cfg`, swap\n+    /// out the terminator temporarily with `None` while they continue\n+    /// to recurse over the set of basic blocks.\n+    pub terminator: Option<Terminator>,\n+\n+    /// If true, this block lies on an unwind path. This is used\n+    /// during codegen where distinct kinds of basic blocks may be\n+    /// generated (particularly for MSVC cleanup). Unwind blocks must\n+    /// only branch to other unwind blocks.\n+    pub is_cleanup: bool,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct MirBody {\n+    pub basic_blocks: Arena<BasicBlock>,\n+    pub locals: Arena<Local>,\n+    pub start_block: BasicBlockId,\n+    pub owner: DefWithBodyId,\n+    pub arg_count: usize,\n+}\n+\n+impl MirBody {}\n+\n+fn const_as_usize(c: &Const) -> usize {\n+    try_const_usize(c).unwrap() as usize\n+}"}, {"sha": "1ec32010a1914878d8d02f95c8a0c9c64bca5b1b", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "added", "additions": 1245, "deletions": 0, "changes": 1245, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -0,0 +1,1245 @@\n+//! This module provides a MIR interpreter, which is used in const eval.\n+\n+use std::{borrow::Cow, collections::HashMap, iter};\n+\n+use base_db::CrateId;\n+use chalk_ir::{\n+    fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable},\n+    DebruijnIndex, TyKind,\n+};\n+use hir_def::{\n+    builtin_type::BuiltinType,\n+    lang_item::{lang_attr, LangItem},\n+    layout::{Layout, LayoutError, RustcEnumVariantIdx, TagEncoding, Variants},\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, Lookup, VariantId,\n+};\n+use intern::Interned;\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    consteval::{intern_const_scalar, ConstEvalError},\n+    db::HirDatabase,\n+    from_placeholder_idx,\n+    infer::{normalize, PointerCast},\n+    layout::layout_of_ty,\n+    mapping::from_chalk,\n+    method_resolution::lookup_impl_method,\n+    CallableDefId, Const, ConstScalar, Interner, MemoryMap, Substitution, Ty, TyBuilder, TyExt,\n+};\n+\n+use super::{\n+    const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n+    Operand, Place, ProjectionElem, Rvalue, Statement, Terminator, UnOp,\n+};\n+\n+pub struct Evaluator<'a> {\n+    db: &'a dyn HirDatabase,\n+    stack: Vec<u8>,\n+    heap: Vec<u8>,\n+    crate_id: CrateId,\n+    // FIXME: This is a workaround, see the comment on `interpret_mir`\n+    assert_placeholder_ty_is_unused: bool,\n+    /// A general limit on execution, to prevent non terminating programs from breaking r-a main process\n+    execution_limit: usize,\n+    /// An additional limit on stack depth, to prevent stack overflow\n+    stack_depth_limit: usize,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum Address {\n+    Stack(usize),\n+    Heap(usize),\n+}\n+\n+use Address::*;\n+\n+struct Interval {\n+    addr: Address,\n+    size: usize,\n+}\n+\n+impl Interval {\n+    fn new(addr: Address, size: usize) -> Self {\n+        Self { addr, size }\n+    }\n+\n+    fn get<'a>(&self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n+        memory.read_memory(self.addr, self.size)\n+    }\n+}\n+\n+enum IntervalOrOwned {\n+    Owned(Vec<u8>),\n+    Borrowed(Interval),\n+}\n+impl IntervalOrOwned {\n+    pub(crate) fn to_vec(self, memory: &Evaluator<'_>) -> Result<Vec<u8>> {\n+        Ok(match self {\n+            IntervalOrOwned::Owned(o) => o,\n+            IntervalOrOwned::Borrowed(b) => b.get(memory)?.to_vec(),\n+        })\n+    }\n+}\n+\n+macro_rules! from_bytes {\n+    ($ty:tt, $value:expr) => {\n+        ($ty::from_le_bytes(match ($value).try_into() {\n+            Ok(x) => x,\n+            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+        }))\n+    };\n+}\n+\n+impl Address {\n+    fn from_bytes(x: &[u8]) -> Result<Self> {\n+        Ok(Address::from_usize(from_bytes!(usize, x)))\n+    }\n+\n+    fn from_usize(x: usize) -> Self {\n+        if x > usize::MAX / 2 {\n+            Stack(usize::MAX - x)\n+        } else {\n+            Heap(x)\n+        }\n+    }\n+\n+    fn to_bytes(&self) -> Vec<u8> {\n+        usize::to_le_bytes(self.to_usize()).to_vec()\n+    }\n+\n+    fn to_usize(&self) -> usize {\n+        let as_num = match self {\n+            Stack(x) => usize::MAX - *x,\n+            Heap(x) => *x,\n+        };\n+        as_num\n+    }\n+\n+    fn map(&self, f: impl FnOnce(usize) -> usize) -> Address {\n+        match self {\n+            Stack(x) => Stack(f(*x)),\n+            Heap(x) => Heap(f(*x)),\n+        }\n+    }\n+\n+    fn offset(&self, offset: usize) -> Address {\n+        self.map(|x| x + offset)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+pub enum MirEvalError {\n+    ConstEvalError(Box<ConstEvalError>),\n+    LayoutError(LayoutError, Ty),\n+    /// Means that code had type errors (or mismatched args) and we shouldn't generate mir in first place.\n+    TypeError(&'static str),\n+    /// Means that code had undefined behavior. We don't try to actively detect UB, but if it was detected\n+    /// then use this type of error.\n+    UndefinedBehavior(&'static str),\n+    Panic,\n+    MirLowerError(FunctionId, MirLowerError),\n+    TypeIsUnsized(Ty, &'static str),\n+    NotSupported(String),\n+    InvalidConst(Const),\n+    InFunction(FunctionId, Box<MirEvalError>),\n+    ExecutionLimitExceeded,\n+    StackOverflow,\n+    TargetDataLayoutNotAvailable,\n+}\n+\n+impl std::fmt::Debug for MirEvalError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::ConstEvalError(arg0) => f.debug_tuple(\"ConstEvalError\").field(arg0).finish(),\n+            Self::LayoutError(arg0, arg1) => {\n+                f.debug_tuple(\"LayoutError\").field(arg0).field(arg1).finish()\n+            }\n+            Self::TypeError(arg0) => f.debug_tuple(\"TypeError\").field(arg0).finish(),\n+            Self::UndefinedBehavior(arg0) => {\n+                f.debug_tuple(\"UndefinedBehavior\").field(arg0).finish()\n+            }\n+            Self::Panic => write!(f, \"Panic\"),\n+            Self::TargetDataLayoutNotAvailable => write!(f, \"TargetDataLayoutNotAvailable\"),\n+            Self::TypeIsUnsized(ty, it) => write!(f, \"{ty:?} is unsized. {it} should be sized.\"),\n+            Self::ExecutionLimitExceeded => write!(f, \"execution limit exceeded\"),\n+            Self::StackOverflow => write!(f, \"stack overflow\"),\n+            Self::MirLowerError(arg0, arg1) => {\n+                f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n+            }\n+            Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n+            Self::InvalidConst(arg0) => {\n+                let data = &arg0.data(Interner);\n+                f.debug_struct(\"InvalidConst\").field(\"ty\", &data.ty).field(\"value\", &arg0).finish()\n+            }\n+            Self::InFunction(func, e) => {\n+                let mut e = &**e;\n+                let mut stack = vec![*func];\n+                while let Self::InFunction(f, next_e) = e {\n+                    e = &next_e;\n+                    stack.push(*f);\n+                }\n+                f.debug_struct(\"WithStack\").field(\"error\", e).field(\"stack\", &stack).finish()\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirEvalError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl From<ConstEvalError> for MirEvalError {\n+    fn from(value: ConstEvalError) -> Self {\n+        match value {\n+            _ => MirEvalError::ConstEvalError(Box::new(value)),\n+        }\n+    }\n+}\n+\n+type Result<T> = std::result::Result<T, MirEvalError>;\n+\n+struct Locals<'a> {\n+    ptr: &'a ArenaMap<LocalId, Address>,\n+    body: &'a MirBody,\n+    subst: &'a Substitution,\n+}\n+\n+pub fn interpret_mir(\n+    db: &dyn HirDatabase,\n+    body: &MirBody,\n+    // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now\n+    // they share their body with their parent, so in MIR lowering we have locals of the parent body, which\n+    // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has\n+    // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can\n+    // (and probably should) do better here, for example by excluding bindings outside of the target expression.\n+    assert_placeholder_ty_is_unused: bool,\n+) -> Result<Const> {\n+    let ty = body.locals[return_slot()].ty.clone();\n+    let mut evaluator =\n+        Evaluator::new(db, body.owner.module(db.upcast()).krate(), assert_placeholder_ty_is_unused);\n+    let bytes = evaluator.interpret_mir_with_no_arg(&body)?;\n+    let memory_map = evaluator.create_memory_map(\n+        &bytes,\n+        &ty,\n+        &Locals { ptr: &ArenaMap::new(), body: &body, subst: &Substitution::empty(Interner) },\n+    )?;\n+    return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n+}\n+\n+impl Evaluator<'_> {\n+    pub fn new<'a>(\n+        db: &'a dyn HirDatabase,\n+        crate_id: CrateId,\n+        assert_placeholder_ty_is_unused: bool,\n+    ) -> Evaluator<'a> {\n+        Evaluator {\n+            stack: vec![0],\n+            heap: vec![0],\n+            db,\n+            crate_id,\n+            assert_placeholder_ty_is_unused,\n+            stack_depth_limit: 100,\n+            execution_limit: 100_000,\n+        }\n+    }\n+\n+    fn place_addr(&self, p: &Place, locals: &Locals<'_>) -> Result<Address> {\n+        Ok(self.place_addr_and_ty(p, locals)?.0)\n+    }\n+\n+    fn ptr_size(&self) -> usize {\n+        match self.db.target_data_layout(self.crate_id) {\n+            Some(x) => x.pointer_size.bytes_usize(),\n+            None => 8,\n+        }\n+    }\n+\n+    fn place_addr_and_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<(Address, Ty)> {\n+        let mut addr = locals.ptr[p.local];\n+        let mut ty: Ty =\n+            self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n+        for proj in &p.projection {\n+            match proj {\n+                ProjectionElem::Deref => {\n+                    match &ty.data(Interner).kind {\n+                        TyKind::Ref(_, _, inner) => {\n+                            ty = inner.clone();\n+                        }\n+                        _ => not_supported!(\"dereferencing smart pointers\"),\n+                    }\n+                    let x = from_bytes!(usize, self.read_memory(addr, self.ptr_size())?);\n+                    addr = Address::from_usize(x);\n+                }\n+                ProjectionElem::Index(op) => {\n+                    let offset =\n+                        from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n+                    match &ty.data(Interner).kind {\n+                        TyKind::Ref(_, _, inner) => match &inner.data(Interner).kind {\n+                            TyKind::Slice(inner) => {\n+                                ty = inner.clone();\n+                                let ty_size = self.size_of_sized(\n+                                    &ty,\n+                                    locals,\n+                                    \"slice inner type should be sized\",\n+                                )?;\n+                                let value = self.read_memory(addr, self.ptr_size() * 2)?;\n+                                addr = Address::from_bytes(&value[0..8])?.offset(ty_size * offset);\n+                            }\n+                            x => not_supported!(\"MIR index for ref type {x:?}\"),\n+                        },\n+                        TyKind::Array(inner, _) | TyKind::Slice(inner) => {\n+                            ty = inner.clone();\n+                            let ty_size = self.size_of_sized(\n+                                &ty,\n+                                locals,\n+                                \"array inner type should be sized\",\n+                            )?;\n+                            addr = addr.offset(ty_size * offset);\n+                        }\n+                        x => not_supported!(\"MIR index for type {x:?}\"),\n+                    }\n+                }\n+                &ProjectionElem::TupleField(f) => match &ty.data(Interner).kind {\n+                    TyKind::Tuple(_, subst) => {\n+                        let layout = self.layout(&ty)?;\n+                        ty = subst\n+                            .as_slice(Interner)\n+                            .get(f)\n+                            .ok_or(MirEvalError::TypeError(\"not enough tuple fields\"))?\n+                            .assert_ty_ref(Interner)\n+                            .clone();\n+                        let offset = layout.fields.offset(f).bytes_usize();\n+                        addr = addr.offset(offset);\n+                    }\n+                    _ => return Err(MirEvalError::TypeError(\"Only tuple has tuple fields\")),\n+                },\n+                ProjectionElem::Field(f) => match &ty.data(Interner).kind {\n+                    TyKind::Adt(adt, subst) => {\n+                        let layout = self.layout_adt(adt.0, subst.clone())?;\n+                        let variant_layout = match &layout.variants {\n+                            Variants::Single { .. } => &layout,\n+                            Variants::Multiple { variants, .. } => {\n+                                &variants[match f.parent {\n+                                    hir_def::VariantId::EnumVariantId(x) => {\n+                                        RustcEnumVariantIdx(x.local_id)\n+                                    }\n+                                    _ => {\n+                                        return Err(MirEvalError::TypeError(\n+                                            \"Multivariant layout only happens for enums\",\n+                                        ))\n+                                    }\n+                                }]\n+                            }\n+                        };\n+                        ty = self.db.field_types(f.parent)[f.local_id]\n+                            .clone()\n+                            .substitute(Interner, subst);\n+                        let offset = variant_layout\n+                            .fields\n+                            .offset(u32::from(f.local_id.into_raw()) as usize)\n+                            .bytes_usize();\n+                        addr = addr.offset(offset);\n+                    }\n+                    _ => return Err(MirEvalError::TypeError(\"Only adt has fields\")),\n+                },\n+                ProjectionElem::ConstantIndex { .. } => {\n+                    not_supported!(\"constant index\")\n+                }\n+                ProjectionElem::Subslice { .. } => not_supported!(\"subslice\"),\n+                ProjectionElem::OpaqueCast(_) => not_supported!(\"opaque cast\"),\n+            }\n+        }\n+        Ok((addr, ty))\n+    }\n+\n+    fn layout(&self, ty: &Ty) -> Result<Layout> {\n+        layout_of_ty(self.db, ty, self.crate_id)\n+            .map_err(|e| MirEvalError::LayoutError(e, ty.clone()))\n+    }\n+\n+    fn layout_adt(&self, adt: AdtId, subst: Substitution) -> Result<Layout> {\n+        self.db.layout_of_adt(adt, subst.clone()).map_err(|e| {\n+            MirEvalError::LayoutError(e, TyKind::Adt(chalk_ir::AdtId(adt), subst).intern(Interner))\n+        })\n+    }\n+\n+    fn place_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<Ty> {\n+        Ok(self.place_addr_and_ty(p, locals)?.1)\n+    }\n+\n+    fn operand_ty<'a>(&'a self, o: &'a Operand, locals: &'a Locals<'a>) -> Result<Ty> {\n+        Ok(match o {\n+            Operand::Copy(p) | Operand::Move(p) => self.place_ty(p, locals)?,\n+            Operand::Constant(c) => c.data(Interner).ty.clone(),\n+        })\n+    }\n+\n+    fn interpret_mir(\n+        &mut self,\n+        body: &MirBody,\n+        args: impl Iterator<Item = Vec<u8>>,\n+        subst: Substitution,\n+    ) -> Result<Vec<u8>> {\n+        if let Some(x) = self.stack_depth_limit.checked_sub(1) {\n+            self.stack_depth_limit = x;\n+        } else {\n+            return Err(MirEvalError::StackOverflow);\n+        }\n+        let mut current_block_idx = body.start_block;\n+        let mut locals = Locals { ptr: &ArenaMap::new(), body: &body, subst: &subst };\n+        let (locals_ptr, stack_size) = {\n+            let mut stack_ptr = self.stack.len();\n+            let addr = body\n+                .locals\n+                .iter()\n+                .map(|(id, x)| {\n+                    let size = self.size_of_sized(&x.ty, &locals, \"no unsized local\")?;\n+                    let my_ptr = stack_ptr;\n+                    stack_ptr += size;\n+                    Ok((id, Stack(my_ptr)))\n+                })\n+                .collect::<Result<ArenaMap<LocalId, _>>>()?;\n+            let stack_size = stack_ptr - self.stack.len();\n+            (addr, stack_size)\n+        };\n+        locals.ptr = &locals_ptr;\n+        self.stack.extend(iter::repeat(0).take(stack_size));\n+        let mut remain_args = body.arg_count;\n+        for ((_, addr), value) in locals_ptr.iter().skip(1).zip(args) {\n+            self.write_memory(*addr, &value)?;\n+            if remain_args == 0 {\n+                return Err(MirEvalError::TypeError(\"more arguments provided\"));\n+            }\n+            remain_args -= 1;\n+        }\n+        if remain_args > 0 {\n+            return Err(MirEvalError::TypeError(\"not enough arguments provided\"));\n+        }\n+        loop {\n+            let current_block = &body.basic_blocks[current_block_idx];\n+            if let Some(x) = self.execution_limit.checked_sub(1) {\n+                self.execution_limit = x;\n+            } else {\n+                return Err(MirEvalError::ExecutionLimitExceeded);\n+            }\n+            for statement in &current_block.statements {\n+                match statement {\n+                    Statement::Assign(l, r) => {\n+                        let addr = self.place_addr(l, &locals)?;\n+                        let result = self.eval_rvalue(r, &locals)?.to_vec(&self)?;\n+                        self.write_memory(addr, &result)?;\n+                    }\n+                    Statement::Deinit(_) => not_supported!(\"de-init statement\"),\n+                    Statement::StorageLive(_) => not_supported!(\"storage-live statement\"),\n+                    Statement::StorageDead(_) => not_supported!(\"storage-dead statement\"),\n+                    Statement::Nop => (),\n+                }\n+            }\n+            let Some(terminator) = current_block.terminator.as_ref() else {\n+                not_supported!(\"block without terminator\");\n+            };\n+            match terminator {\n+                Terminator::Goto { target } => {\n+                    current_block_idx = *target;\n+                }\n+                Terminator::Call {\n+                    func,\n+                    args,\n+                    destination,\n+                    target,\n+                    cleanup: _,\n+                    from_hir_call: _,\n+                } => {\n+                    let fn_ty = self.operand_ty(func, &locals)?;\n+                    match &fn_ty.data(Interner).kind {\n+                        TyKind::FnDef(def, generic_args) => {\n+                            let def: CallableDefId = from_chalk(self.db, *def);\n+                            let generic_args = self.subst_filler(generic_args, &locals);\n+                            match def {\n+                                CallableDefId::FunctionId(def) => {\n+                                    let arg_bytes = args\n+                                        .iter()\n+                                        .map(|x| {\n+                                            Ok(self\n+                                                .eval_operand(x, &locals)?\n+                                                .get(&self)?\n+                                                .to_owned())\n+                                        })\n+                                        .collect::<Result<Vec<_>>>()?\n+                                        .into_iter();\n+                                    let function_data = self.db.function_data(def);\n+                                    let is_intrinsic = match &function_data.abi {\n+                                        Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n+                                        None => match def.lookup(self.db.upcast()).container {\n+                                            hir_def::ItemContainerId::ExternBlockId(block) => {\n+                                                let id = block.lookup(self.db.upcast()).id;\n+                                                id.item_tree(self.db.upcast())[id.value]\n+                                                    .abi\n+                                                    .as_deref()\n+                                                    == Some(\"rust-intrinsic\")\n+                                            }\n+                                            _ => false,\n+                                        },\n+                                    };\n+                                    let result = if is_intrinsic {\n+                                        self.exec_intrinsic(\n+                                            function_data\n+                                                .name\n+                                                .as_text()\n+                                                .unwrap_or_default()\n+                                                .as_str(),\n+                                            arg_bytes,\n+                                            generic_args,\n+                                            &locals,\n+                                        )?\n+                                    } else if let Some(x) = self.detect_lang_function(def) {\n+                                        self.exec_lang_item(x, arg_bytes)?\n+                                    } else {\n+                                        let trait_env = {\n+                                            let Some(d) = body.owner.as_generic_def_id() else {\n+                                                not_supported!(\"trait resolving in non generic def id\");\n+                                            };\n+                                            self.db.trait_environment(d)\n+                                        };\n+                                        let (imp, generic_args) = lookup_impl_method(\n+                                            self.db,\n+                                            trait_env,\n+                                            def,\n+                                            generic_args.clone(),\n+                                        );\n+                                        let generic_args =\n+                                            self.subst_filler(&generic_args, &locals);\n+                                        let def = imp.into();\n+                                        let mir_body = self\n+                                            .db\n+                                            .mir_body(def)\n+                                            .map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+                                        self.interpret_mir(&mir_body, arg_bytes, generic_args)\n+                                            .map_err(|e| {\n+                                                MirEvalError::InFunction(imp, Box::new(e))\n+                                            })?\n+                                    };\n+                                    let dest_addr = self.place_addr(destination, &locals)?;\n+                                    self.write_memory(dest_addr, &result)?;\n+                                }\n+                                CallableDefId::StructId(id) => {\n+                                    let (size, variant_layout, tag) = self.layout_of_variant(\n+                                        id.into(),\n+                                        generic_args.clone(),\n+                                        &locals,\n+                                    )?;\n+                                    let result = self.make_by_layout(\n+                                        size,\n+                                        &variant_layout,\n+                                        tag,\n+                                        args,\n+                                        &locals,\n+                                    )?;\n+                                    let dest_addr = self.place_addr(destination, &locals)?;\n+                                    self.write_memory(dest_addr, &result)?;\n+                                }\n+                                CallableDefId::EnumVariantId(id) => {\n+                                    let (size, variant_layout, tag) = self.layout_of_variant(\n+                                        id.into(),\n+                                        generic_args.clone(),\n+                                        &locals,\n+                                    )?;\n+                                    let result = self.make_by_layout(\n+                                        size,\n+                                        &variant_layout,\n+                                        tag,\n+                                        args,\n+                                        &locals,\n+                                    )?;\n+                                    let dest_addr = self.place_addr(destination, &locals)?;\n+                                    self.write_memory(dest_addr, &result)?;\n+                                }\n+                            }\n+                            current_block_idx =\n+                                target.expect(\"broken mir, function without target\");\n+                        }\n+                        _ => not_supported!(\"unknown function type\"),\n+                    }\n+                }\n+                Terminator::SwitchInt { discr, targets } => {\n+                    let val = u128::from_le_bytes(pad16(\n+                        self.eval_operand(discr, &locals)?.get(&self)?,\n+                        false,\n+                    ));\n+                    current_block_idx = targets.target_for_value(val);\n+                }\n+                Terminator::Return => {\n+                    let ty = body.locals[return_slot()].ty.clone();\n+                    self.stack_depth_limit += 1;\n+                    return Ok(self\n+                        .read_memory(\n+                            locals.ptr[return_slot()],\n+                            self.size_of_sized(&ty, &locals, \"return type\")?,\n+                        )?\n+                        .to_owned());\n+                }\n+                Terminator::Unreachable => {\n+                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"))\n+                }\n+                _ => not_supported!(\"unknown terminator\"),\n+            }\n+        }\n+    }\n+\n+    fn eval_rvalue<'a>(\n+        &'a mut self,\n+        r: &'a Rvalue,\n+        locals: &'a Locals<'a>,\n+    ) -> Result<IntervalOrOwned> {\n+        use IntervalOrOwned::*;\n+        Ok(match r {\n+            Rvalue::Use(x) => Borrowed(self.eval_operand(x, locals)?),\n+            Rvalue::Ref(_, p) => {\n+                let addr = self.place_addr(p, locals)?;\n+                Owned(addr.to_bytes())\n+            }\n+            Rvalue::Len(_) => not_supported!(\"rvalue len\"),\n+            Rvalue::UnaryOp(op, val) => {\n+                let mut c = self.eval_operand(val, locals)?.get(&self)?;\n+                let mut ty = self.operand_ty(val, locals)?;\n+                while let TyKind::Ref(_, _, z) = ty.kind(Interner) {\n+                    ty = z.clone();\n+                    let size = self.size_of_sized(&ty, locals, \"operand of unary op\")?;\n+                    c = self.read_memory(Address::from_bytes(c)?, size)?;\n+                }\n+                let mut c = c.to_vec();\n+                if ty.as_builtin() == Some(BuiltinType::Bool) {\n+                    c[0] = 1 - c[0];\n+                } else {\n+                    match op {\n+                        UnOp::Not => c.iter_mut().for_each(|x| *x = !*x),\n+                        UnOp::Neg => {\n+                            c.iter_mut().for_each(|x| *x = !*x);\n+                            for k in c.iter_mut() {\n+                                let o;\n+                                (*k, o) = k.overflowing_add(1);\n+                                if !o {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                Owned(c)\n+            }\n+            Rvalue::CheckedBinaryOp(op, lhs, rhs) => {\n+                let lc = self.eval_operand(lhs, locals)?;\n+                let rc = self.eval_operand(rhs, locals)?;\n+                let mut lc = lc.get(&self)?;\n+                let mut rc = rc.get(&self)?;\n+                let mut ty = self.operand_ty(lhs, locals)?;\n+                while let TyKind::Ref(_, _, z) = ty.kind(Interner) {\n+                    ty = z.clone();\n+                    let size = self.size_of_sized(&ty, locals, \"operand of binary op\")?;\n+                    lc = self.read_memory(Address::from_bytes(lc)?, size)?;\n+                    rc = self.read_memory(Address::from_bytes(rc)?, size)?;\n+                }\n+                let is_signed = matches!(ty.as_builtin(), Some(BuiltinType::Int(_)));\n+                let l128 = i128::from_le_bytes(pad16(lc, is_signed));\n+                let r128 = i128::from_le_bytes(pad16(rc, is_signed));\n+                match op {\n+                    BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {\n+                        let r = match op {\n+                            BinOp::Ge => l128 >= r128,\n+                            BinOp::Gt => l128 > r128,\n+                            BinOp::Le => l128 <= r128,\n+                            BinOp::Lt => l128 < r128,\n+                            BinOp::Eq => l128 == r128,\n+                            BinOp::Ne => l128 != r128,\n+                            _ => unreachable!(),\n+                        };\n+                        let r = r as u8;\n+                        Owned(vec![r])\n+                    }\n+                    BinOp::BitAnd\n+                    | BinOp::BitOr\n+                    | BinOp::BitXor\n+                    | BinOp::Add\n+                    | BinOp::Mul\n+                    | BinOp::Div\n+                    | BinOp::Rem\n+                    | BinOp::Sub => {\n+                        let r = match op {\n+                            BinOp::Add => l128.overflowing_add(r128).0,\n+                            BinOp::Mul => l128.overflowing_mul(r128).0,\n+                            BinOp::Div => l128.checked_div(r128).ok_or(MirEvalError::Panic)?,\n+                            BinOp::Rem => l128.checked_rem(r128).ok_or(MirEvalError::Panic)?,\n+                            BinOp::Sub => l128.overflowing_sub(r128).0,\n+                            BinOp::BitAnd => l128 & r128,\n+                            BinOp::BitOr => l128 | r128,\n+                            BinOp::BitXor => l128 ^ r128,\n+                            _ => unreachable!(),\n+                        };\n+                        let r = r.to_le_bytes();\n+                        for &k in &r[lc.len()..] {\n+                            if k != 0 && (k != 255 || !is_signed) {\n+                                return Err(MirEvalError::Panic);\n+                            }\n+                        }\n+                        Owned(r[0..lc.len()].into())\n+                    }\n+                    BinOp::Shl | BinOp::Shr => {\n+                        let shift_amout = if r128 < 0 {\n+                            return Err(MirEvalError::Panic);\n+                        } else if r128 > 128 {\n+                            return Err(MirEvalError::Panic);\n+                        } else {\n+                            r128 as u8\n+                        };\n+                        let r = match op {\n+                            BinOp::Shl => l128 << shift_amout,\n+                            BinOp::Shr => l128 >> shift_amout,\n+                            _ => unreachable!(),\n+                        };\n+                        Owned(r.to_le_bytes()[0..lc.len()].into())\n+                    }\n+                    BinOp::Offset => not_supported!(\"offset binop\"),\n+                }\n+            }\n+            Rvalue::Discriminant(p) => {\n+                let ty = self.place_ty(p, locals)?;\n+                let bytes = self.eval_place(p, locals)?.get(&self)?;\n+                let layout = self.layout(&ty)?;\n+                match layout.variants {\n+                    Variants::Single { .. } => Owned(0u128.to_le_bytes().to_vec()),\n+                    Variants::Multiple { tag, tag_encoding, .. } => {\n+                        let Some(target_data_layout) = self.db.target_data_layout(self.crate_id) else {\n+                            not_supported!(\"missing target data layout\");\n+                        };\n+                        let size = tag.size(&*target_data_layout).bytes_usize();\n+                        let offset = layout.fields.offset(0).bytes_usize(); // The only field on enum variants is the tag field\n+                        match tag_encoding {\n+                            TagEncoding::Direct => {\n+                                let tag = &bytes[offset..offset + size];\n+                                Owned(pad16(tag, false).to_vec())\n+                            }\n+                            TagEncoding::Niche { untagged_variant, niche_start, .. } => {\n+                                let tag = &bytes[offset..offset + size];\n+                                let candidate_discriminant = i128::from_le_bytes(pad16(tag, false))\n+                                    .wrapping_sub(niche_start as i128);\n+                                let enum_id = match ty.kind(Interner) {\n+                                    TyKind::Adt(e, _) => match e.0 {\n+                                        AdtId::EnumId(e) => e,\n+                                        _ => not_supported!(\"Non enum with multi variant layout\"),\n+                                    },\n+                                    _ => not_supported!(\"Non adt with multi variant layout\"),\n+                                };\n+                                let enum_data = self.db.enum_data(enum_id);\n+                                let result = 'b: {\n+                                    for (local_id, _) in enum_data.variants.iter() {\n+                                        if candidate_discriminant\n+                                            == self.db.const_eval_discriminant(EnumVariantId {\n+                                                parent: enum_id,\n+                                                local_id,\n+                                            })?\n+                                        {\n+                                            break 'b candidate_discriminant;\n+                                        }\n+                                    }\n+                                    self.db.const_eval_discriminant(EnumVariantId {\n+                                        parent: enum_id,\n+                                        local_id: untagged_variant.0,\n+                                    })?\n+                                };\n+                                Owned(result.to_le_bytes().to_vec())\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Rvalue::ShallowInitBox(_, _) => not_supported!(\"shallow init box\"),\n+            Rvalue::CopyForDeref(_) => not_supported!(\"copy for deref\"),\n+            Rvalue::Aggregate(kind, values) => match kind {\n+                AggregateKind::Array(_) => {\n+                    let mut r = vec![];\n+                    for x in values {\n+                        let value = self.eval_operand(x, locals)?.get(&self)?;\n+                        r.extend(value);\n+                    }\n+                    Owned(r)\n+                }\n+                AggregateKind::Tuple(ty) => {\n+                    let layout = self.layout(&ty)?;\n+                    Owned(self.make_by_layout(\n+                        layout.size.bytes_usize(),\n+                        &layout,\n+                        None,\n+                        values,\n+                        locals,\n+                    )?)\n+                }\n+                AggregateKind::Union(x, f) => {\n+                    let layout = self.layout_adt((*x).into(), Substitution::empty(Interner))?;\n+                    let offset = layout\n+                        .fields\n+                        .offset(u32::from(f.local_id.into_raw()) as usize)\n+                        .bytes_usize();\n+                    let op = self.eval_operand(&values[0], locals)?.get(&self)?;\n+                    let mut result = vec![0; layout.size.bytes_usize()];\n+                    result[offset..offset + op.len()].copy_from_slice(op);\n+                    Owned(result)\n+                }\n+                AggregateKind::Adt(x, subst) => {\n+                    let (size, variant_layout, tag) =\n+                        self.layout_of_variant(*x, subst.clone(), locals)?;\n+                    Owned(self.make_by_layout(size, &variant_layout, tag, values, locals)?)\n+                }\n+            },\n+            Rvalue::Cast(kind, operand, target_ty) => match kind {\n+                CastKind::PointerExposeAddress => not_supported!(\"exposing pointer address\"),\n+                CastKind::PointerFromExposedAddress => {\n+                    not_supported!(\"creating pointer from exposed address\")\n+                }\n+                CastKind::Pointer(cast) => match cast {\n+                    PointerCast::Unsize => {\n+                        let current_ty = self.operand_ty(operand, locals)?;\n+                        match &target_ty.data(Interner).kind {\n+                            TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                                match &ty.data(Interner).kind {\n+                                    TyKind::Slice(_) => match &current_ty.data(Interner).kind {\n+                                        TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                                            match &ty.data(Interner).kind {\n+                                                TyKind::Array(_, size) => {\n+                                                    let addr = self\n+                                                        .eval_operand(operand, locals)?\n+                                                        .get(&self)?;\n+                                                    let len = const_as_usize(size);\n+                                                    let mut r = Vec::with_capacity(16);\n+                                                    r.extend(addr.iter().copied());\n+                                                    r.extend(len.to_le_bytes().into_iter());\n+                                                    Owned(r)\n+                                                }\n+                                                _ => {\n+                                                    not_supported!(\"slice unsizing from non arrays\")\n+                                                }\n+                                            }\n+                                        }\n+                                        _ => not_supported!(\"slice unsizing from non pointers\"),\n+                                    },\n+                                    TyKind::Dyn(_) => not_supported!(\"dyn pointer unsize cast\"),\n+                                    _ => not_supported!(\"unknown unsized cast\"),\n+                                }\n+                            }\n+                            _ => not_supported!(\"unsized cast on unknown pointer type\"),\n+                        }\n+                    }\n+                    x => not_supported!(\"pointer cast {x:?}\"),\n+                },\n+                CastKind::DynStar => not_supported!(\"dyn star cast\"),\n+                CastKind::IntToInt => {\n+                    // FIXME: handle signed cast\n+                    let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n+                    let dest_size =\n+                        self.size_of_sized(target_ty, locals, \"destination of int to int cast\")?;\n+                    Owned(current[0..dest_size].to_vec())\n+                }\n+                CastKind::FloatToInt => not_supported!(\"float to int cast\"),\n+                CastKind::FloatToFloat => not_supported!(\"float to float cast\"),\n+                CastKind::IntToFloat => not_supported!(\"float to int cast\"),\n+                CastKind::PtrToPtr => not_supported!(\"ptr to ptr cast\"),\n+                CastKind::FnPtrToPtr => not_supported!(\"fn ptr to ptr cast\"),\n+            },\n+        })\n+    }\n+\n+    fn layout_of_variant(\n+        &mut self,\n+        x: VariantId,\n+        subst: Substitution,\n+        locals: &Locals<'_>,\n+    ) -> Result<(usize, Layout, Option<(usize, usize, i128)>)> {\n+        let adt = x.adt_id();\n+        if let DefWithBodyId::VariantId(f) = locals.body.owner {\n+            if let VariantId::EnumVariantId(x) = x {\n+                if AdtId::from(f.parent) == adt {\n+                    // Computing the exact size of enums require resolving the enum discriminants. In order to prevent loops (and\n+                    // infinite sized type errors) we use a dummy layout\n+                    let i = self.db.const_eval_discriminant(x)?;\n+                    return Ok((16, self.layout(&TyBuilder::unit())?, Some((0, 16, i))));\n+                }\n+            }\n+        }\n+        let layout = self.layout_adt(adt, subst)?;\n+        Ok(match layout.variants {\n+            Variants::Single { .. } => (layout.size.bytes_usize(), layout, None),\n+            Variants::Multiple { variants, tag, tag_encoding, .. } => {\n+                let cx = self\n+                    .db\n+                    .target_data_layout(self.crate_id)\n+                    .ok_or(MirEvalError::TargetDataLayoutNotAvailable)?;\n+                let enum_variant_id = match x {\n+                    VariantId::EnumVariantId(x) => x,\n+                    _ => not_supported!(\"multi variant layout for non-enums\"),\n+                };\n+                let rustc_enum_variant_idx = RustcEnumVariantIdx(enum_variant_id.local_id);\n+                let mut discriminant = self.db.const_eval_discriminant(enum_variant_id)?;\n+                let variant_layout = variants[rustc_enum_variant_idx].clone();\n+                let have_tag = match tag_encoding {\n+                    TagEncoding::Direct => true,\n+                    TagEncoding::Niche { untagged_variant, niche_variants: _, niche_start } => {\n+                        discriminant = discriminant.wrapping_add(niche_start as i128);\n+                        untagged_variant != rustc_enum_variant_idx\n+                    }\n+                };\n+                (\n+                    layout.size.bytes_usize(),\n+                    variant_layout,\n+                    if have_tag {\n+                        Some((\n+                            layout.fields.offset(0).bytes_usize(),\n+                            tag.size(&*cx).bytes_usize(),\n+                            discriminant,\n+                        ))\n+                    } else {\n+                        None\n+                    },\n+                )\n+            }\n+        })\n+    }\n+\n+    fn make_by_layout(\n+        &mut self,\n+        size: usize, // Not neccessarily equal to variant_layout.size\n+        variant_layout: &Layout,\n+        tag: Option<(usize, usize, i128)>,\n+        values: &Vec<Operand>,\n+        locals: &Locals<'_>,\n+    ) -> Result<Vec<u8>> {\n+        let mut result = vec![0; size];\n+        if let Some((offset, size, value)) = tag {\n+            result[offset..offset + size].copy_from_slice(&value.to_le_bytes()[0..size]);\n+        }\n+        for (i, op) in values.iter().enumerate() {\n+            let offset = variant_layout.fields.offset(i).bytes_usize();\n+            let op = self.eval_operand(op, locals)?.get(&self)?;\n+            result[offset..offset + op.len()].copy_from_slice(op);\n+        }\n+        Ok(result)\n+    }\n+\n+    fn eval_operand(&mut self, x: &Operand, locals: &Locals<'_>) -> Result<Interval> {\n+        Ok(match x {\n+            Operand::Copy(p) | Operand::Move(p) => self.eval_place(p, locals)?,\n+            Operand::Constant(konst) => {\n+                let data = &konst.data(Interner);\n+                match &data.value {\n+                    chalk_ir::ConstValue::BoundVar(b) => {\n+                        let c = locals\n+                            .subst\n+                            .as_slice(Interner)\n+                            .get(b.index)\n+                            .ok_or(MirEvalError::TypeError(\"missing generic arg\"))?\n+                            .assert_const_ref(Interner);\n+                        self.eval_operand(&Operand::Constant(c.clone()), locals)?\n+                    }\n+                    chalk_ir::ConstValue::InferenceVar(_) => {\n+                        not_supported!(\"inference var constant\")\n+                    }\n+                    chalk_ir::ConstValue::Placeholder(_) => not_supported!(\"placeholder constant\"),\n+                    chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n+                        ConstScalar::Bytes(v, memory_map) => {\n+                            let mut v: Cow<'_, [u8]> = Cow::Borrowed(v);\n+                            let patch_map = memory_map.transform_addresses(|b| {\n+                                let addr = self.heap_allocate(b.len());\n+                                self.write_memory(addr, b)?;\n+                                Ok(addr.to_usize())\n+                            })?;\n+                            let size = self.size_of(&data.ty, locals)?.unwrap_or(v.len());\n+                            if size != v.len() {\n+                                // Handle self enum\n+                                if size == 16 && v.len() < 16 {\n+                                    v = Cow::Owned(pad16(&v, false).to_vec());\n+                                } else if size < 16 && v.len() == 16 {\n+                                    v = Cow::Owned(v[0..size].to_vec());\n+                                } else {\n+                                    return Err(MirEvalError::InvalidConst(konst.clone()));\n+                                }\n+                            }\n+                            let addr = self.heap_allocate(size);\n+                            self.write_memory(addr, &v)?;\n+                            self.patch_addresses(&patch_map, addr, &data.ty, locals)?;\n+                            Interval::new(addr, size)\n+                        }\n+                        ConstScalar::Unknown => not_supported!(\"evaluating unknown const\"),\n+                    },\n+                }\n+            }\n+        })\n+    }\n+\n+    fn eval_place(&mut self, p: &Place, locals: &Locals<'_>) -> Result<Interval> {\n+        let addr = self.place_addr(p, locals)?;\n+        Ok(Interval::new(\n+            addr,\n+            self.size_of_sized(&self.place_ty(p, locals)?, locals, \"type of this place\")?,\n+        ))\n+    }\n+\n+    fn read_memory(&self, addr: Address, size: usize) -> Result<&[u8]> {\n+        let (mem, pos) = match addr {\n+            Stack(x) => (&self.stack, x),\n+            Heap(x) => (&self.heap, x),\n+        };\n+        mem.get(pos..pos + size).ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory read\"))\n+    }\n+\n+    fn write_memory(&mut self, addr: Address, r: &[u8]) -> Result<()> {\n+        let (mem, pos) = match addr {\n+            Stack(x) => (&mut self.stack, x),\n+            Heap(x) => (&mut self.heap, x),\n+        };\n+        mem.get_mut(pos..pos + r.len())\n+            .ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory write\"))?\n+            .copy_from_slice(r);\n+        Ok(())\n+    }\n+\n+    fn size_of(&self, ty: &Ty, locals: &Locals<'_>) -> Result<Option<usize>> {\n+        if let DefWithBodyId::VariantId(f) = locals.body.owner {\n+            if let Some((adt, _)) = ty.as_adt() {\n+                if AdtId::from(f.parent) == adt {\n+                    // Computing the exact size of enums require resolving the enum discriminants. In order to prevent loops (and\n+                    // infinite sized type errors) we use a dummy size\n+                    return Ok(Some(16));\n+                }\n+            }\n+        }\n+        let ty = &self.ty_filler(ty, locals.subst, locals.body.owner)?;\n+        let layout = self.layout(ty);\n+        if self.assert_placeholder_ty_is_unused {\n+            if matches!(layout, Err(MirEvalError::LayoutError(LayoutError::HasPlaceholder, _))) {\n+                return Ok(Some(0));\n+            }\n+        }\n+        let layout = layout?;\n+        Ok(layout.is_sized().then(|| layout.size.bytes_usize()))\n+    }\n+\n+    /// A version of `self.size_of` which returns error if the type is unsized. `what` argument should\n+    /// be something that complete this: `error: type {ty} was unsized. {what} should be sized`\n+    fn size_of_sized(&self, ty: &Ty, locals: &Locals<'_>, what: &'static str) -> Result<usize> {\n+        match self.size_of(ty, locals)? {\n+            Some(x) => Ok(x),\n+            None => Err(MirEvalError::TypeIsUnsized(ty.clone(), what)),\n+        }\n+    }\n+\n+    /// Uses `ty_filler` to fill an entire subst\n+    fn subst_filler(&self, subst: &Substitution, locals: &Locals<'_>) -> Substitution {\n+        Substitution::from_iter(\n+            Interner,\n+            subst.iter(Interner).map(|x| match x.data(Interner) {\n+                chalk_ir::GenericArgData::Ty(ty) => {\n+                    let Ok(ty) = self.ty_filler(ty, locals.subst, locals.body.owner) else {\n+                        return x.clone();\n+                    };\n+                    chalk_ir::GenericArgData::Ty(ty).intern(Interner)\n+                }\n+                _ => x.clone(),\n+            }),\n+        )\n+    }\n+\n+    /// This function substitutes placeholders of the body with the provided subst, effectively plays\n+    /// the rule of monomorphization. In addition to placeholders, it substitutes opaque types (return\n+    /// position impl traits) with their underlying type.\n+    fn ty_filler(&self, ty: &Ty, subst: &Substitution, owner: DefWithBodyId) -> Result<Ty> {\n+        struct Filler<'a> {\n+            db: &'a dyn HirDatabase,\n+            subst: &'a Substitution,\n+            skip_params: usize,\n+        }\n+        impl FallibleTypeFolder<Interner> for Filler<'_> {\n+            type Error = MirEvalError;\n+\n+            fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n+                self\n+            }\n+\n+            fn interner(&self) -> Interner {\n+                Interner\n+            }\n+\n+            fn try_fold_ty(\n+                &mut self,\n+                ty: Ty,\n+                outer_binder: DebruijnIndex,\n+            ) -> std::result::Result<Ty, Self::Error> {\n+                match ty.kind(Interner) {\n+                    TyKind::OpaqueType(id, subst) => {\n+                        let impl_trait_id = self.db.lookup_intern_impl_trait_id((*id).into());\n+                        match impl_trait_id {\n+                            crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n+                                let infer = self.db.infer(func.into());\n+                                let filler = &mut Filler { db: self.db, subst, skip_params: 0 };\n+                                filler.try_fold_ty(infer.type_of_rpit[idx].clone(), outer_binder)\n+                            }\n+                            crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n+                                not_supported!(\"async block impl trait\");\n+                            }\n+                        }\n+                    }\n+                    _ => ty.try_super_fold_with(self.as_dyn(), outer_binder),\n+                }\n+            }\n+\n+            fn try_fold_free_placeholder_ty(\n+                &mut self,\n+                idx: chalk_ir::PlaceholderIndex,\n+                _outer_binder: DebruijnIndex,\n+            ) -> std::result::Result<Ty, Self::Error> {\n+                let x = from_placeholder_idx(self.db, idx);\n+                Ok(self\n+                    .subst\n+                    .as_slice(Interner)\n+                    .get((u32::from(x.local_id.into_raw()) as usize) + self.skip_params)\n+                    .and_then(|x| x.ty(Interner))\n+                    .ok_or(MirEvalError::TypeError(\"Generic arg not provided\"))?\n+                    .clone())\n+            }\n+        }\n+        let filler = &mut Filler { db: self.db, subst, skip_params: 0 };\n+        Ok(normalize(self.db, owner, ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST)?))\n+    }\n+\n+    fn heap_allocate(&mut self, s: usize) -> Address {\n+        let pos = self.heap.len();\n+        self.heap.extend(iter::repeat(0).take(s));\n+        Address::Heap(pos)\n+    }\n+\n+    pub fn interpret_mir_with_no_arg(&mut self, body: &MirBody) -> Result<Vec<u8>> {\n+        self.interpret_mir(&body, vec![].into_iter(), Substitution::empty(Interner))\n+    }\n+\n+    fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n+        lang_attr(self.db.upcast(), def)\n+    }\n+\n+    fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {\n+        // FIXME: support indirect references\n+        let mut mm = MemoryMap::default();\n+        match ty.kind(Interner) {\n+            TyKind::Ref(_, _, t) => {\n+                let size = self.size_of(t, locals)?;\n+                match size {\n+                    Some(size) => {\n+                        let addr_usize = from_bytes!(usize, bytes);\n+                        mm.insert(\n+                            addr_usize,\n+                            self.read_memory(Address::from_usize(addr_usize), size)?.to_vec(),\n+                        )\n+                    }\n+                    None => {\n+                        let element_size = match t.kind(Interner) {\n+                            TyKind::Str => 1,\n+                            TyKind::Slice(t) => {\n+                                self.size_of_sized(t, locals, \"slice inner type\")?\n+                            }\n+                            _ => return Ok(mm), // FIXME: support other kind of unsized types\n+                        };\n+                        let (addr, meta) = bytes.split_at(bytes.len() / 2);\n+                        let size = element_size * from_bytes!(usize, meta);\n+                        let addr = Address::from_bytes(addr)?;\n+                        mm.insert(addr.to_usize(), self.read_memory(addr, size)?.to_vec());\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+        Ok(mm)\n+    }\n+\n+    fn patch_addresses(\n+        &mut self,\n+        patch_map: &HashMap<usize, usize>,\n+        addr: Address,\n+        ty: &Ty,\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        // FIXME: support indirect references\n+        let my_size = self.size_of_sized(ty, locals, \"value to patch address\")?;\n+        match ty.kind(Interner) {\n+            TyKind::Ref(_, _, t) => {\n+                let size = self.size_of(t, locals)?;\n+                match size {\n+                    Some(_) => {\n+                        let current = from_bytes!(usize, self.read_memory(addr, my_size)?);\n+                        if let Some(x) = patch_map.get(&current) {\n+                            self.write_memory(addr, &x.to_le_bytes())?;\n+                        }\n+                    }\n+                    None => {\n+                        let current = from_bytes!(usize, self.read_memory(addr, my_size / 2)?);\n+                        if let Some(x) = patch_map.get(&current) {\n+                            self.write_memory(addr, &x.to_le_bytes())?;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_intrinsic(\n+        &self,\n+        as_str: &str,\n+        _arg_bytes: impl Iterator<Item = Vec<u8>>,\n+        generic_args: Substitution,\n+        locals: &Locals<'_>,\n+    ) -> Result<Vec<u8>> {\n+        match as_str {\n+            \"size_of\" => {\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n+                };\n+                let size = self.size_of(ty, locals)?;\n+                match size {\n+                    Some(x) => Ok(x.to_le_bytes().to_vec()),\n+                    None => return Err(MirEvalError::TypeError(\"size_of arg is unsized\")),\n+                }\n+            }\n+            _ => not_supported!(\"unknown intrinsic {as_str}\"),\n+        }\n+    }\n+\n+    pub(crate) fn exec_lang_item(\n+        &self,\n+        x: LangItem,\n+        mut args: std::vec::IntoIter<Vec<u8>>,\n+    ) -> Result<Vec<u8>> {\n+        use LangItem::*;\n+        match x {\n+            PanicFmt | BeginPanic => Err(MirEvalError::Panic),\n+            SliceLen => {\n+                let arg = args\n+                    .next()\n+                    .ok_or(MirEvalError::TypeError(\"argument of <[T]>::len() is not provided\"))?;\n+                let ptr_size = arg.len() / 2;\n+                Ok(arg[ptr_size..].into())\n+            }\n+            x => not_supported!(\"Executing lang item {x:?}\"),\n+        }\n+    }\n+}\n+\n+pub fn pad16(x: &[u8], is_signed: bool) -> [u8; 16] {\n+    let is_negative = is_signed && x.last().unwrap_or(&0) > &128;\n+    let fill_with = if is_negative { 255 } else { 0 };\n+    x.iter()\n+        .copied()\n+        .chain(iter::repeat(fill_with))\n+        .take(16)\n+        .collect::<Vec<u8>>()\n+        .try_into()\n+        .expect(\"iterator take is not working\")\n+}"}, {"sha": "1fa21e230c4c8e0b6b1df31cd111f4b3a00787d4", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "added", "additions": 1209, "deletions": 0, "changes": 1209, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -0,0 +1,1209 @@\n+//! This module generates a polymorphic MIR from a hir body\n+\n+use std::{iter, mem, sync::Arc};\n+\n+use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n+use hir_def::{\n+    body::Body,\n+    expr::{\n+        Array, BindingAnnotation, ExprId, LabelId, Literal, MatchArm, Pat, PatId, RecordLitField,\n+    },\n+    layout::LayoutError,\n+    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n+    DefWithBodyId, EnumVariantId, HasModule,\n+};\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    consteval::ConstEvalError, db::HirDatabase, layout::layout_of_ty, mapping::ToChalk,\n+    utils::generics, Adjust, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+};\n+\n+use super::*;\n+\n+#[derive(Debug, Clone, Copy)]\n+struct LoopBlocks {\n+    begin: BasicBlockId,\n+    end: BasicBlockId,\n+}\n+\n+struct MirLowerCtx<'a> {\n+    result: MirBody,\n+    owner: DefWithBodyId,\n+    binding_locals: ArenaMap<PatId, LocalId>,\n+    current_loop_blocks: Option<LoopBlocks>,\n+    discr_temp: Option<Place>,\n+    db: &'a dyn HirDatabase,\n+    body: &'a Body,\n+    infer: &'a InferenceResult,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum MirLowerError {\n+    ConstEvalError(Box<ConstEvalError>),\n+    LayoutError(LayoutError),\n+    IncompleteExpr,\n+    UnresolvedName,\n+    MissingFunctionDefinition,\n+    TypeError(&'static str),\n+    NotSupported(String),\n+    ContinueWithoutLoop,\n+    BreakWithoutLoop,\n+    Loop,\n+}\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl From<ConstEvalError> for MirLowerError {\n+    fn from(value: ConstEvalError) -> Self {\n+        match value {\n+            ConstEvalError::MirLowerError(e) => e,\n+            _ => MirLowerError::ConstEvalError(Box::new(value)),\n+        }\n+    }\n+}\n+\n+impl From<LayoutError> for MirLowerError {\n+    fn from(value: LayoutError) -> Self {\n+        MirLowerError::LayoutError(value)\n+    }\n+}\n+\n+type Result<T> = std::result::Result<T, MirLowerError>;\n+\n+impl MirLowerCtx<'_> {\n+    fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n+        if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n+            not_supported!(\"unsized temporaries\");\n+        }\n+        Ok(self.result.locals.alloc(Local { mutability: Mutability::Not, ty }))\n+    }\n+\n+    fn lower_expr_as_place(&self, expr_id: ExprId) -> Option<Place> {\n+        let adjustments = self.infer.expr_adjustments.get(&expr_id);\n+        let mut r = self.lower_expr_as_place_without_adjust(expr_id)?;\n+        for adjustment in adjustments.iter().flat_map(|x| x.iter()) {\n+            match adjustment.kind {\n+                Adjust::NeverToAny => return Some(r),\n+                Adjust::Deref(None) => {\n+                    r.projection.push(ProjectionElem::Deref);\n+                }\n+                Adjust::Deref(Some(_)) => return None,\n+                Adjust::Borrow(_) => return None,\n+                Adjust::Pointer(_) => return None,\n+            }\n+        }\n+        Some(r)\n+    }\n+\n+    fn lower_expr_as_place_without_adjust(&self, expr_id: ExprId) -> Option<Place> {\n+        match &self.body.exprs[expr_id] {\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                let pr = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path())?;\n+                let pr = match pr {\n+                    ResolveValueResult::ValueNs(v) => v,\n+                    ResolveValueResult::Partial(..) => return None,\n+                };\n+                match pr {\n+                    ValueNs::LocalBinding(pat_id) => Some(self.binding_locals[pat_id].into()),\n+                    _ => None,\n+                }\n+            }\n+            Expr::UnaryOp { expr, op } => match op {\n+                hir_def::expr::UnaryOp::Deref => {\n+                    let mut r = self.lower_expr_as_place(*expr)?;\n+                    r.projection.push(ProjectionElem::Deref);\n+                    Some(r)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn lower_expr_to_some_operand(\n+        &mut self,\n+        expr_id: ExprId,\n+        current: BasicBlockId,\n+    ) -> Result<(Operand, BasicBlockId)> {\n+        if !self.has_adjustments(expr_id) {\n+            match &self.body.exprs[expr_id] {\n+                Expr::Literal(l) => {\n+                    let ty = self.expr_ty(expr_id);\n+                    return Ok((self.lower_literal_to_operand(ty, l)?, current));\n+                }\n+                _ => (),\n+            }\n+        }\n+        let (p, current) = self.lower_expr_to_some_place(expr_id, current)?;\n+        Ok((Operand::Copy(p), current))\n+    }\n+\n+    fn lower_expr_to_some_place(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+    ) -> Result<(Place, BasicBlockId)> {\n+        if let Some(p) = self.lower_expr_as_place(expr_id) {\n+            return Ok((p, prev_block));\n+        }\n+        let mut ty = self.expr_ty(expr_id);\n+        if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n+            if let Some(x) = x.last() {\n+                ty = x.target.clone();\n+            }\n+        }\n+        let place = self.temp(ty)?;\n+        Ok((place.into(), self.lower_expr_to_place(expr_id, place.into(), prev_block)?))\n+    }\n+\n+    fn lower_expr_to_place(\n+        &mut self,\n+        expr_id: ExprId,\n+        place: Place,\n+        prev_block: BasicBlockId,\n+    ) -> Result<BasicBlockId> {\n+        if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n+            if x.len() > 0 {\n+                let tmp = self.temp(self.expr_ty(expr_id))?;\n+                let current =\n+                    self.lower_expr_to_place_without_adjust(expr_id, tmp.into(), prev_block)?;\n+                let mut r = Place::from(tmp);\n+                for adjustment in x {\n+                    match &adjustment.kind {\n+                        Adjust::NeverToAny => (),\n+                        Adjust::Deref(None) => {\n+                            r.projection.push(ProjectionElem::Deref);\n+                        }\n+                        Adjust::Deref(Some(_)) => not_supported!(\"overloaded dereference\"),\n+                        Adjust::Borrow(AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) => {\n+                            let tmp = self.temp(adjustment.target.clone())?;\n+                            self.push_assignment(\n+                                current,\n+                                tmp.into(),\n+                                Rvalue::Ref(BorrowKind::from_chalk(*m), r),\n+                            );\n+                            r = tmp.into();\n+                        }\n+                        Adjust::Pointer(cast) => {\n+                            let target = &adjustment.target;\n+                            let tmp = self.temp(target.clone())?;\n+                            self.push_assignment(\n+                                current,\n+                                tmp.into(),\n+                                Rvalue::Cast(\n+                                    CastKind::Pointer(cast.clone()),\n+                                    Operand::Copy(r).into(),\n+                                    target.clone(),\n+                                ),\n+                            );\n+                            r = tmp.into();\n+                        }\n+                    }\n+                }\n+                self.push_assignment(current, place, Operand::Copy(r).into());\n+                return Ok(current);\n+            }\n+        }\n+        self.lower_expr_to_place_without_adjust(expr_id, place, prev_block)\n+    }\n+\n+    fn lower_expr_to_place_without_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        place: Place,\n+        mut current: BasicBlockId,\n+    ) -> Result<BasicBlockId> {\n+        match &self.body.exprs[expr_id] {\n+            Expr::Missing => Err(MirLowerError::IncompleteExpr),\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                let pr = resolver\n+                    .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n+                    .ok_or(MirLowerError::UnresolvedName)?;\n+                let pr = match pr {\n+                    ResolveValueResult::ValueNs(v) => v,\n+                    ResolveValueResult::Partial(..) => {\n+                        return match self\n+                            .infer\n+                            .assoc_resolutions_for_expr(expr_id)\n+                            .ok_or(MirLowerError::UnresolvedName)?\n+                            .0\n+                            //.ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n+                        {\n+                            hir_def::AssocItemId::ConstId(c) => self.lower_const(c, current, place),\n+                            _ => return Err(MirLowerError::UnresolvedName),\n+                        };\n+                    }\n+                };\n+                match pr {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        self.push_assignment(\n+                            current,\n+                            place,\n+                            Operand::Copy(self.binding_locals[pat_id].into()).into(),\n+                        );\n+                        Ok(current)\n+                    }\n+                    ValueNs::ConstId(const_id) => self.lower_const(const_id, current, place),\n+                    ValueNs::EnumVariantId(variant_id) => {\n+                        let ty = self.infer.type_of_expr[expr_id].clone();\n+                        self.lower_enum_variant(variant_id, current, place, ty, vec![])\n+                    }\n+                    ValueNs::GenericParam(p) => {\n+                        let Some(def) = self.owner.as_generic_def_id() else {\n+                            not_supported!(\"owner without generic def id\");\n+                        };\n+                        let gen = generics(self.db.upcast(), def);\n+                        let ty = self.expr_ty(expr_id);\n+                        self.push_assignment(\n+                            current,\n+                            place,\n+                            Operand::Constant(\n+                                ConstData {\n+                                    ty,\n+                                    value: chalk_ir::ConstValue::BoundVar(BoundVar::new(\n+                                        DebruijnIndex::INNERMOST,\n+                                        gen.param_idx(p.into()).ok_or(MirLowerError::TypeError(\n+                                            \"fail to lower const generic param\",\n+                                        ))?,\n+                                    )),\n+                                }\n+                                .intern(Interner),\n+                            )\n+                            .into(),\n+                        );\n+                        Ok(current)\n+                    }\n+                    ValueNs::StructId(_) => {\n+                        // It's probably a unit struct or a zero sized function, so no action is needed.\n+                        Ok(current)\n+                    }\n+                    x => {\n+                        not_supported!(\"unknown name {x:?} in value name space\");\n+                    }\n+                }\n+            }\n+            Expr::If { condition, then_branch, else_branch } => {\n+                let (discr, current) = self.lower_expr_to_some_operand(*condition, current)?;\n+                let start_of_then = self.new_basic_block();\n+                let end = self.new_basic_block();\n+                let end_of_then =\n+                    self.lower_expr_to_place(*then_branch, place.clone(), start_of_then)?;\n+                self.set_goto(end_of_then, end);\n+                let mut start_of_else = end;\n+                if let Some(else_branch) = else_branch {\n+                    start_of_else = self.new_basic_block();\n+                    let end_of_else =\n+                        self.lower_expr_to_place(*else_branch, place, start_of_else)?;\n+                    self.set_goto(end_of_else, end);\n+                }\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr,\n+                        targets: SwitchTargets::static_if(1, start_of_then, start_of_else),\n+                    },\n+                );\n+                Ok(end)\n+            }\n+            Expr::Let { pat, expr } => {\n+                let (cond_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                let result = self.new_basic_block();\n+                let (then_target, else_target) = self.pattern_match(\n+                    current,\n+                    None,\n+                    cond_place,\n+                    self.expr_ty(*expr),\n+                    *pat,\n+                    BindingAnnotation::Unannotated,\n+                )?;\n+                self.write_bytes_to_place(then_target, place.clone(), vec![1], TyBuilder::bool())?;\n+                self.set_goto(then_target, result);\n+                if let Some(else_target) = else_target {\n+                    self.write_bytes_to_place(else_target, place, vec![0], TyBuilder::bool())?;\n+                    self.set_goto(else_target, result);\n+                }\n+                Ok(result)\n+            }\n+            Expr::Block { id: _, statements, tail, label } => {\n+                if label.is_some() {\n+                    not_supported!(\"block with label\");\n+                }\n+                for statement in statements.iter() {\n+                    match statement {\n+                        hir_def::expr::Statement::Let {\n+                            pat,\n+                            initializer,\n+                            else_branch,\n+                            type_ref: _,\n+                        } => match initializer {\n+                            Some(expr_id) => {\n+                                let else_block;\n+                                let init_place;\n+                                (init_place, current) =\n+                                    self.lower_expr_to_some_place(*expr_id, current)?;\n+                                (current, else_block) = self.pattern_match(\n+                                    current,\n+                                    None,\n+                                    init_place,\n+                                    self.expr_ty(*expr_id),\n+                                    *pat,\n+                                    BindingAnnotation::Unannotated,\n+                                )?;\n+                                match (else_block, else_branch) {\n+                                    (None, _) => (),\n+                                    (Some(else_block), None) => {\n+                                        self.set_terminator(else_block, Terminator::Unreachable);\n+                                    }\n+                                    (Some(else_block), Some(else_branch)) => {\n+                                        let (_, b) = self\n+                                            .lower_expr_to_some_place(*else_branch, else_block)?;\n+                                        self.set_terminator(b, Terminator::Unreachable);\n+                                    }\n+                                }\n+                            }\n+                            None => continue,\n+                        },\n+                        hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                            let ty = self.expr_ty(*expr);\n+                            let temp = self.temp(ty)?;\n+                            current = self.lower_expr_to_place(*expr, temp.into(), current)?;\n+                        }\n+                    }\n+                }\n+                match tail {\n+                    Some(tail) => self.lower_expr_to_place(*tail, place, current),\n+                    None => Ok(current),\n+                }\n+            }\n+            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin, _| {\n+                let (_, block) = this.lower_expr_to_some_place(*body, begin)?;\n+                this.set_goto(block, begin);\n+                Ok(())\n+            }),\n+            Expr::While { condition, body, label } => {\n+                self.lower_loop(current, *label, |this, begin, end| {\n+                    let (discr, to_switch) = this.lower_expr_to_some_operand(*condition, begin)?;\n+                    let after_cond = this.new_basic_block();\n+                    this.set_terminator(\n+                        to_switch,\n+                        Terminator::SwitchInt {\n+                            discr,\n+                            targets: SwitchTargets::static_if(1, after_cond, end),\n+                        },\n+                    );\n+                    let (_, block) = this.lower_expr_to_some_place(*body, after_cond)?;\n+                    this.set_goto(block, begin);\n+                    Ok(())\n+                })\n+            }\n+            Expr::For { .. } => not_supported!(\"for loop\"),\n+            Expr::Call { callee, args, .. } => {\n+                let callee_ty = self.expr_ty(*callee);\n+                match &callee_ty.data(Interner).kind {\n+                    chalk_ir::TyKind::FnDef(..) => {\n+                        let func = Operand::from_bytes(vec![], callee_ty.clone());\n+                        self.lower_call(func, args.iter().copied(), place, current)\n+                    }\n+                    TyKind::Scalar(_)\n+                    | TyKind::Tuple(_, _)\n+                    | TyKind::Array(_, _)\n+                    | TyKind::Adt(_, _)\n+                    | TyKind::Str\n+                    | TyKind::Foreign(_)\n+                    | TyKind::Slice(_) => {\n+                        return Err(MirLowerError::TypeError(\"function call on data type\"))\n+                    }\n+                    TyKind::Error => return Err(MirLowerError::MissingFunctionDefinition),\n+                    TyKind::AssociatedType(_, _)\n+                    | TyKind::Raw(_, _)\n+                    | TyKind::Ref(_, _, _)\n+                    | TyKind::OpaqueType(_, _)\n+                    | TyKind::Never\n+                    | TyKind::Closure(_, _)\n+                    | TyKind::Generator(_, _)\n+                    | TyKind::GeneratorWitness(_, _)\n+                    | TyKind::Placeholder(_)\n+                    | TyKind::Dyn(_)\n+                    | TyKind::Alias(_)\n+                    | TyKind::Function(_)\n+                    | TyKind::BoundVar(_)\n+                    | TyKind::InferenceVar(_, _) => not_supported!(\"dynamic function call\"),\n+                }\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                let (func_id, generic_args) =\n+                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedName)?;\n+                let ty = chalk_ir::TyKind::FnDef(\n+                    CallableDefId::FunctionId(func_id).to_chalk(self.db),\n+                    generic_args,\n+                )\n+                .intern(Interner);\n+                let func = Operand::from_bytes(vec![], ty);\n+                self.lower_call(\n+                    func,\n+                    iter::once(*receiver).chain(args.iter().copied()),\n+                    place,\n+                    current,\n+                )\n+            }\n+            Expr::Match { expr, arms } => {\n+                let (cond_place, mut current) = self.lower_expr_to_some_place(*expr, current)?;\n+                let cond_ty = self.expr_ty(*expr);\n+                let end = self.new_basic_block();\n+                for MatchArm { pat, guard, expr } in arms.iter() {\n+                    if guard.is_some() {\n+                        not_supported!(\"pattern matching with guard\");\n+                    }\n+                    let (then, otherwise) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        BindingAnnotation::Unannotated,\n+                    )?;\n+                    let block = self.lower_expr_to_place(*expr, place.clone(), then)?;\n+                    self.set_goto(block, end);\n+                    match otherwise {\n+                        Some(o) => current = o,\n+                        None => {\n+                            // The current pattern was irrefutable, so there is no need to generate code\n+                            // for the rest of patterns\n+                            break;\n+                        }\n+                    }\n+                }\n+                if self.is_unterminated(current) {\n+                    self.set_terminator(current, Terminator::Unreachable);\n+                }\n+                Ok(end)\n+            }\n+            Expr::Continue { label } => match label {\n+                Some(_) => not_supported!(\"continue with label\"),\n+                None => {\n+                    let loop_data =\n+                        self.current_loop_blocks.ok_or(MirLowerError::ContinueWithoutLoop)?;\n+                    self.set_goto(current, loop_data.begin);\n+                    let otherwise = self.new_basic_block();\n+                    Ok(otherwise)\n+                }\n+            },\n+            Expr::Break { expr, label } => {\n+                if expr.is_some() {\n+                    not_supported!(\"break with value\");\n+                }\n+                match label {\n+                    Some(_) => not_supported!(\"break with label\"),\n+                    None => {\n+                        let loop_data =\n+                            self.current_loop_blocks.ok_or(MirLowerError::BreakWithoutLoop)?;\n+                        self.set_goto(current, loop_data.end);\n+                        Ok(self.new_basic_block())\n+                    }\n+                }\n+            }\n+            Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    current = self.lower_expr_to_place(*expr, return_slot().into(), current)?;\n+                }\n+                self.set_terminator(current, Terminator::Return);\n+                Ok(self.new_basic_block())\n+            }\n+            Expr::Yield { .. } => not_supported!(\"yield\"),\n+            Expr::RecordLit { fields, .. } => {\n+                let variant_id = self\n+                    .infer\n+                    .variant_resolution_for_expr(expr_id)\n+                    .ok_or(MirLowerError::UnresolvedName)?;\n+                let subst = match self.expr_ty(expr_id).kind(Interner) {\n+                    TyKind::Adt(_, s) => s.clone(),\n+                    _ => not_supported!(\"Non ADT record literal\"),\n+                };\n+                let variant_data = variant_id.variant_data(self.db.upcast());\n+                match variant_id {\n+                    VariantId::EnumVariantId(_) | VariantId::StructId(_) => {\n+                        let mut operands = vec![None; variant_data.fields().len()];\n+                        for RecordLitField { name, expr } in fields.iter() {\n+                            let field_id =\n+                                variant_data.field(name).ok_or(MirLowerError::UnresolvedName)?;\n+                            let op;\n+                            (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                            operands[u32::from(field_id.into_raw()) as usize] = Some(op);\n+                        }\n+                        self.push_assignment(\n+                            current,\n+                            place,\n+                            Rvalue::Aggregate(\n+                                AggregateKind::Adt(variant_id, subst),\n+                                operands.into_iter().map(|x| x).collect::<Option<_>>().ok_or(\n+                                    MirLowerError::TypeError(\"missing field in record literal\"),\n+                                )?,\n+                            ),\n+                        );\n+                        Ok(current)\n+                    }\n+                    VariantId::UnionId(union_id) => {\n+                        let [RecordLitField { name, expr }] = fields.as_ref() else {\n+                            not_supported!(\"Union record literal with more than one field\");\n+                        };\n+                        let local_id =\n+                            variant_data.field(name).ok_or(MirLowerError::UnresolvedName)?;\n+                        let mut place = place;\n+                        place\n+                            .projection\n+                            .push(PlaceElem::Field(FieldId { parent: union_id.into(), local_id }));\n+                        self.lower_expr_to_place(*expr, place, current)\n+                    }\n+                }\n+            }\n+            Expr::Field { expr, name } => {\n+                let (mut current_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                if let TyKind::Tuple(..) = self.expr_ty(*expr).kind(Interner) {\n+                    let index = name\n+                        .as_tuple_index()\n+                        .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n+                    current_place.projection.push(ProjectionElem::TupleField(index))\n+                } else {\n+                    let field = self\n+                        .infer\n+                        .field_resolution(expr_id)\n+                        .ok_or(MirLowerError::UnresolvedName)?;\n+                    current_place.projection.push(ProjectionElem::Field(field));\n+                }\n+                self.push_assignment(current, place, Operand::Copy(current_place).into());\n+                Ok(current)\n+            }\n+            Expr::Await { .. } => not_supported!(\"await\"),\n+            Expr::Try { .. } => not_supported!(\"? operator\"),\n+            Expr::Yeet { .. } => not_supported!(\"yeet\"),\n+            Expr::TryBlock { .. } => not_supported!(\"try block\"),\n+            Expr::Async { .. } => not_supported!(\"async block\"),\n+            Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n+            Expr::Cast { expr, type_ref: _ } => {\n+                let (x, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                let source_ty = self.infer[*expr].clone();\n+                let target_ty = self.infer[expr_id].clone();\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::Cast(cast_kind(&source_ty, &target_ty)?, x, target_ty),\n+                );\n+                Ok(current)\n+            }\n+            Expr::Ref { expr, rawness: _, mutability } => {\n+                let p;\n+                (p, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                let bk = BorrowKind::from_hir(*mutability);\n+                self.push_assignment(current, place, Rvalue::Ref(bk, p));\n+                Ok(current)\n+            }\n+            Expr::Box { .. } => not_supported!(\"box expression\"),\n+            Expr::UnaryOp { expr, op } => match op {\n+                hir_def::expr::UnaryOp::Deref => {\n+                    let (mut tmp, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                    tmp.projection.push(ProjectionElem::Deref);\n+                    self.push_assignment(current, place, Operand::Copy(tmp).into());\n+                    Ok(current)\n+                }\n+                hir_def::expr::UnaryOp::Not => {\n+                    let (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                    self.push_assignment(current, place, Rvalue::UnaryOp(UnOp::Not, op));\n+                    Ok(current)\n+                }\n+                hir_def::expr::UnaryOp::Neg => {\n+                    let (op, current) = self.lower_expr_to_some_operand(*expr, current)?;\n+                    self.push_assignment(current, place, Rvalue::UnaryOp(UnOp::Neg, op));\n+                    Ok(current)\n+                }\n+            },\n+            Expr::BinaryOp { lhs, rhs, op } => {\n+                let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n+                if let hir_def::expr::BinaryOp::Assignment { op } = op {\n+                    if op.is_some() {\n+                        not_supported!(\"assignment with arith op (like +=)\");\n+                    }\n+                    let Some(lhs_place) = self.lower_expr_as_place(*lhs) else {\n+                        not_supported!(\"assignment to complex place\");\n+                    };\n+                    let rhs_op;\n+                    (rhs_op, current) = self.lower_expr_to_some_operand(*rhs, current)?;\n+                    self.push_assignment(current, lhs_place, rhs_op.into());\n+                    return Ok(current);\n+                }\n+                let lhs_op;\n+                (lhs_op, current) = self.lower_expr_to_some_operand(*lhs, current)?;\n+                let rhs_op;\n+                (rhs_op, current) = self.lower_expr_to_some_operand(*rhs, current)?;\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::CheckedBinaryOp(\n+                        match op {\n+                            hir_def::expr::BinaryOp::LogicOp(op) => match op {\n+                                hir_def::expr::LogicOp::And => BinOp::BitAnd, // FIXME: make these short circuit\n+                                hir_def::expr::LogicOp::Or => BinOp::BitOr,\n+                            },\n+                            hir_def::expr::BinaryOp::ArithOp(op) => BinOp::from(op),\n+                            hir_def::expr::BinaryOp::CmpOp(op) => BinOp::from(op),\n+                            hir_def::expr::BinaryOp::Assignment { .. } => unreachable!(), // handled above\n+                        },\n+                        lhs_op,\n+                        rhs_op,\n+                    ),\n+                );\n+                Ok(current)\n+            }\n+            Expr::Range { .. } => not_supported!(\"range\"),\n+            Expr::Index { base, index } => {\n+                let mut p_base;\n+                (p_base, current) = self.lower_expr_to_some_place(*base, current)?;\n+                let l_index = self.temp(self.expr_ty(*index))?;\n+                current = self.lower_expr_to_place(*index, l_index.into(), current)?;\n+                p_base.projection.push(ProjectionElem::Index(l_index));\n+                self.push_assignment(current, place, Operand::Copy(p_base).into());\n+                Ok(current)\n+            }\n+            Expr::Closure { .. } => not_supported!(\"closure\"),\n+            Expr::Tuple { exprs, is_assignee_expr: _ } => {\n+                let r = Rvalue::Aggregate(\n+                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n+                    exprs\n+                        .iter()\n+                        .map(|x| {\n+                            let o;\n+                            (o, current) = self.lower_expr_to_some_operand(*x, current)?;\n+                            Ok(o)\n+                        })\n+                        .collect::<Result<_>>()?,\n+                );\n+                self.push_assignment(current, place, r);\n+                Ok(current)\n+            }\n+            Expr::Unsafe { body } => self.lower_expr_to_place(*body, place, current),\n+            Expr::Array(l) => match l {\n+                Array::ElementList { elements, .. } => {\n+                    let elem_ty = match &self.expr_ty(expr_id).data(Interner).kind {\n+                        TyKind::Array(ty, _) => ty.clone(),\n+                        _ => {\n+                            return Err(MirLowerError::TypeError(\n+                                \"Array expression with non array type\",\n+                            ))\n+                        }\n+                    };\n+                    let r = Rvalue::Aggregate(\n+                        AggregateKind::Array(elem_ty),\n+                        elements\n+                            .iter()\n+                            .map(|x| {\n+                                let o;\n+                                (o, current) = self.lower_expr_to_some_operand(*x, current)?;\n+                                Ok(o)\n+                            })\n+                            .collect::<Result<_>>()?,\n+                    );\n+                    self.push_assignment(current, place, r);\n+                    Ok(current)\n+                }\n+                Array::Repeat { .. } => not_supported!(\"array repeat\"),\n+            },\n+            Expr::Literal(l) => {\n+                let ty = self.expr_ty(expr_id);\n+                let op = self.lower_literal_to_operand(ty, l)?;\n+                self.push_assignment(current, place, op.into());\n+                Ok(current)\n+            }\n+            Expr::Underscore => not_supported!(\"underscore\"),\n+        }\n+    }\n+\n+    fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n+        let size = layout_of_ty(self.db, &ty, self.owner.module(self.db.upcast()).krate())?\n+            .size\n+            .bytes_usize();\n+        let bytes = match l {\n+            hir_def::expr::Literal::String(b) => {\n+                let b = b.as_bytes();\n+                let mut data = vec![];\n+                data.extend(0usize.to_le_bytes());\n+                data.extend(b.len().to_le_bytes());\n+                let mut mm = MemoryMap::default();\n+                mm.insert(0, b.to_vec());\n+                return Ok(Operand::from_concrete_const(data, mm, ty));\n+            }\n+            hir_def::expr::Literal::ByteString(b) => {\n+                let mut data = vec![];\n+                data.extend(0usize.to_le_bytes());\n+                data.extend(b.len().to_le_bytes());\n+                let mut mm = MemoryMap::default();\n+                mm.insert(0, b.to_vec());\n+                return Ok(Operand::from_concrete_const(data, mm, ty));\n+            }\n+            hir_def::expr::Literal::Char(c) => u32::from(*c).to_le_bytes().into(),\n+            hir_def::expr::Literal::Bool(b) => vec![*b as u8],\n+            hir_def::expr::Literal::Int(x, _) => x.to_le_bytes()[0..size].into(),\n+            hir_def::expr::Literal::Uint(x, _) => x.to_le_bytes()[0..size].into(),\n+            hir_def::expr::Literal::Float(f, _) => match size {\n+                8 => f.into_f64().to_le_bytes().into(),\n+                4 => f.into_f32().to_le_bytes().into(),\n+                _ => {\n+                    return Err(MirLowerError::TypeError(\"float with size other than 4 or 8 bytes\"))\n+                }\n+            },\n+        };\n+        Ok(Operand::from_concrete_const(bytes, MemoryMap::default(), ty))\n+    }\n+\n+    fn new_basic_block(&mut self) -> BasicBlockId {\n+        self.result.basic_blocks.alloc(BasicBlock::default())\n+    }\n+\n+    fn lower_const(\n+        &mut self,\n+        const_id: hir_def::ConstId,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+    ) -> Result<BasicBlockId> {\n+        let c = self.db.const_eval(const_id)?;\n+        self.write_const_to_place(c, prev_block, place)\n+    }\n+\n+    fn write_const_to_place(\n+        &mut self,\n+        c: Const,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+    ) -> Result<BasicBlockId> {\n+        self.push_assignment(prev_block, place, Operand::Constant(c).into());\n+        Ok(prev_block)\n+    }\n+\n+    fn write_bytes_to_place(\n+        &mut self,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+        cv: Vec<u8>,\n+        ty: Ty,\n+    ) -> Result<BasicBlockId> {\n+        self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into());\n+        Ok(prev_block)\n+    }\n+\n+    fn lower_enum_variant(\n+        &mut self,\n+        variant_id: EnumVariantId,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+        ty: Ty,\n+        fields: Vec<Operand>,\n+    ) -> Result<BasicBlockId> {\n+        let subst = match ty.kind(Interner) {\n+            TyKind::Adt(_, subst) => subst.clone(),\n+            _ => not_supported!(\"Non ADT enum\"),\n+        };\n+        self.push_assignment(\n+            prev_block,\n+            place,\n+            Rvalue::Aggregate(AggregateKind::Adt(variant_id.into(), subst), fields),\n+        );\n+        Ok(prev_block)\n+    }\n+\n+    fn lower_call(\n+        &mut self,\n+        func: Operand,\n+        args: impl Iterator<Item = ExprId>,\n+        place: Place,\n+        mut current: BasicBlockId,\n+    ) -> Result<BasicBlockId> {\n+        let args = args\n+            .map(|arg| {\n+                let temp;\n+                (temp, current) = self.lower_expr_to_some_operand(arg, current)?;\n+                Ok(temp)\n+            })\n+            .collect::<Result<Vec<_>>>()?;\n+        let b = self.result.basic_blocks.alloc(BasicBlock {\n+            statements: vec![],\n+            terminator: None,\n+            is_cleanup: false,\n+        });\n+        self.set_terminator(\n+            current,\n+            Terminator::Call {\n+                func,\n+                args,\n+                destination: place,\n+                target: Some(b),\n+                cleanup: None,\n+                from_hir_call: true,\n+            },\n+        );\n+        Ok(b)\n+    }\n+\n+    fn is_unterminated(&mut self, source: BasicBlockId) -> bool {\n+        self.result.basic_blocks[source].terminator.is_none()\n+    }\n+\n+    fn set_terminator(&mut self, source: BasicBlockId, terminator: Terminator) {\n+        self.result.basic_blocks[source].terminator = Some(terminator);\n+    }\n+\n+    fn set_goto(&mut self, source: BasicBlockId, target: BasicBlockId) {\n+        self.set_terminator(source, Terminator::Goto { target });\n+    }\n+\n+    fn expr_ty(&self, e: ExprId) -> Ty {\n+        self.infer[e].clone()\n+    }\n+\n+    fn push_assignment(&mut self, block: BasicBlockId, place: Place, rvalue: Rvalue) {\n+        self.result.basic_blocks[block].statements.push(Statement::Assign(place, rvalue));\n+    }\n+\n+    /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n+    /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n+    /// can be the `current` block) and one for the mismatched path. If the input pattern is irrefutable, the\n+    /// mismatched path block is `None`.\n+    ///\n+    /// By default, it will create a new block for mismatched path. If you already have one, you can provide it with\n+    /// `current_else` argument to save an unneccessary jump. If `current_else` isn't `None`, the result mismatched path\n+    /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n+    /// so it should be an empty block.\n+    fn pattern_match(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        mut cond_place: Place,\n+        mut cond_ty: Ty,\n+        pattern: PatId,\n+        mut binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        Ok(match &self.body.pats[pattern] {\n+            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n+            Pat::Wild => (current, current_else),\n+            Pat::Tuple { args, ellipsis } => {\n+                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                let subst = match cond_ty.kind(Interner) {\n+                    TyKind::Tuple(_, s) => s,\n+                    _ => {\n+                        return Err(MirLowerError::TypeError(\n+                            \"non tuple type matched with tuple pattern\",\n+                        ))\n+                    }\n+                };\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args.iter().enumerate().map(|(i, x)| {\n+                        (\n+                            PlaceElem::TupleField(i),\n+                            *x,\n+                            subst.at(Interner, i).assert_ty_ref(Interner).clone(),\n+                        )\n+                    }),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            Pat::Or(_) => not_supported!(\"or pattern\"),\n+            Pat::Record { .. } => not_supported!(\"record pattern\"),\n+            Pat::Range { .. } => not_supported!(\"range pattern\"),\n+            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n+            Pat::Path(_) => not_supported!(\"path pattern\"),\n+            Pat::Lit(l) => {\n+                let then_target = self.new_basic_block();\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                match &self.body.exprs[*l] {\n+                    Expr::Literal(l) => match l {\n+                        hir_def::expr::Literal::Int(x, _) => {\n+                            self.set_terminator(\n+                                current,\n+                                Terminator::SwitchInt {\n+                                    discr: Operand::Copy(cond_place),\n+                                    targets: SwitchTargets::static_if(\n+                                        *x as u128,\n+                                        then_target,\n+                                        else_target,\n+                                    ),\n+                                },\n+                            );\n+                        }\n+                        hir_def::expr::Literal::Uint(x, _) => {\n+                            self.set_terminator(\n+                                current,\n+                                Terminator::SwitchInt {\n+                                    discr: Operand::Copy(cond_place),\n+                                    targets: SwitchTargets::static_if(*x, then_target, else_target),\n+                                },\n+                            );\n+                        }\n+                        _ => not_supported!(\"non int path literal\"),\n+                    },\n+                    _ => not_supported!(\"expression path literal\"),\n+                }\n+                (then_target, Some(else_target))\n+            }\n+            Pat::Bind { mode, name: _, subpat } => {\n+                let target_place = self.binding_locals[pattern];\n+                if let Some(subpat) = subpat {\n+                    (current, current_else) = self.pattern_match(\n+                        current,\n+                        current_else,\n+                        cond_place.clone(),\n+                        cond_ty,\n+                        *subpat,\n+                        binding_mode,\n+                    )?\n+                }\n+                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+                    binding_mode = *mode;\n+                }\n+                self.push_assignment(\n+                    current,\n+                    target_place.into(),\n+                    match binding_mode {\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                            Operand::Copy(cond_place).into()\n+                        }\n+                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n+                        BindingAnnotation::RefMut => Rvalue::Ref(\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            cond_place,\n+                        ),\n+                    },\n+                );\n+                (current, current_else)\n+            }\n+            Pat::TupleStruct { path: _, args, ellipsis } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                let subst = match cond_ty.kind(Interner) {\n+                    TyKind::Adt(_, s) => s,\n+                    _ => {\n+                        return Err(MirLowerError::TypeError(\n+                            \"non adt type matched with tuple struct\",\n+                        ))\n+                    }\n+                };\n+                let fields_type = self.db.field_types(variant);\n+                match variant {\n+                    VariantId::EnumVariantId(v) => {\n+                        let e = self.db.const_eval_discriminant(v)? as u128;\n+                        let next = self.new_basic_block();\n+                        let tmp = self.discr_temp_place();\n+                        self.push_assignment(\n+                            current,\n+                            tmp.clone(),\n+                            Rvalue::Discriminant(cond_place.clone()),\n+                        );\n+                        let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                        self.set_terminator(\n+                            current,\n+                            Terminator::SwitchInt {\n+                                discr: Operand::Copy(tmp),\n+                                targets: SwitchTargets::static_if(e, next, else_target),\n+                            },\n+                        );\n+                        let enum_data = self.db.enum_data(v.parent);\n+                        let fields =\n+                            enum_data.variants[v.local_id].variant_data.fields().iter().map(\n+                                |(x, _)| {\n+                                    (\n+                                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n+                                        fields_type[x].clone().substitute(Interner, subst),\n+                                    )\n+                                },\n+                            );\n+                        self.pattern_match_tuple_like(\n+                            next,\n+                            Some(else_target),\n+                            args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                            *ellipsis,\n+                            &cond_place,\n+                            binding_mode,\n+                        )?\n+                    }\n+                    VariantId::StructId(s) => {\n+                        let struct_data = self.db.struct_data(s);\n+                        let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n+                            (\n+                                PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n+                                fields_type[x].clone().substitute(Interner, subst),\n+                            )\n+                        });\n+                        self.pattern_match_tuple_like(\n+                            current,\n+                            current_else,\n+                            args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                            *ellipsis,\n+                            &cond_place,\n+                            binding_mode,\n+                        )?\n+                    }\n+                    VariantId::UnionId(_) => {\n+                        return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+                    }\n+                }\n+            }\n+            Pat::Ref { .. } => not_supported!(\"& pattern\"),\n+            Pat::Box { .. } => not_supported!(\"box pattern\"),\n+            Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n+        })\n+    }\n+\n+    fn pattern_match_tuple_like(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n+        ellipsis: Option<usize>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        if ellipsis.is_some() {\n+            not_supported!(\"tuple like pattern with ellipsis\");\n+        }\n+        for (proj, arg, ty) in args {\n+            let mut cond_place = cond_place.clone();\n+            cond_place.projection.push(proj);\n+            (current, current_else) =\n+                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n+        }\n+        Ok((current, current_else))\n+    }\n+\n+    fn discr_temp_place(&mut self) -> Place {\n+        match &self.discr_temp {\n+            Some(x) => x.clone(),\n+            None => {\n+                let tmp: Place =\n+                    self.temp(TyBuilder::discr_ty()).expect(\"discr_ty is never unsized\").into();\n+                self.discr_temp = Some(tmp.clone());\n+                tmp\n+            }\n+        }\n+    }\n+\n+    fn lower_loop(\n+        &mut self,\n+        prev_block: BasicBlockId,\n+        label: Option<LabelId>,\n+        f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId, BasicBlockId) -> Result<()>,\n+    ) -> Result<BasicBlockId> {\n+        if label.is_some() {\n+            not_supported!(\"loop with label\");\n+        }\n+        let begin = self.new_basic_block();\n+        let end = self.new_basic_block();\n+        let prev = mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end }));\n+        self.set_goto(prev_block, begin);\n+        f(self, begin, end)?;\n+        self.current_loop_blocks = prev;\n+        Ok(end)\n+    }\n+\n+    fn has_adjustments(&self, expr_id: ExprId) -> bool {\n+        !self.infer.expr_adjustments.get(&expr_id).map(|x| x.is_empty()).unwrap_or(true)\n+    }\n+}\n+\n+fn pattern_matching_dereference(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+    cond_place: &mut Place,\n+) {\n+    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n+        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n+            *binding_mode = BindingAnnotation::RefMut;\n+        } else {\n+            *binding_mode = BindingAnnotation::Ref;\n+        }\n+        *cond_ty = ty.clone();\n+        cond_place.projection.push(ProjectionElem::Deref);\n+    }\n+}\n+\n+fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n+    Ok(match (source_ty.kind(Interner), target_ty.kind(Interner)) {\n+        (TyKind::Scalar(s), TyKind::Scalar(t)) => match (s, t) {\n+            (chalk_ir::Scalar::Float(_), chalk_ir::Scalar::Float(_)) => CastKind::FloatToFloat,\n+            (chalk_ir::Scalar::Float(_), _) => CastKind::FloatToInt,\n+            (_, chalk_ir::Scalar::Float(_)) => CastKind::IntToFloat,\n+            (_, _) => CastKind::IntToInt,\n+        },\n+        // Enum to int casts\n+        (TyKind::Scalar(_), TyKind::Adt(..)) | (TyKind::Adt(..), TyKind::Scalar(_)) => {\n+            CastKind::IntToInt\n+        }\n+        (a, b) => not_supported!(\"Unknown cast between {a:?} and {b:?}\"),\n+    })\n+}\n+\n+pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n+    let body = db.body(def);\n+    let infer = db.infer(def);\n+    Ok(Arc::new(lower_to_mir(db, def, &body, &infer, body.body_expr)?))\n+}\n+\n+pub fn mir_body_recover(\n+    _db: &dyn HirDatabase,\n+    _cycle: &[String],\n+    _def: &DefWithBodyId,\n+) -> Result<Arc<MirBody>> {\n+    Err(MirLowerError::Loop)\n+}\n+\n+pub fn lower_to_mir(\n+    db: &dyn HirDatabase,\n+    owner: DefWithBodyId,\n+    body: &Body,\n+    infer: &InferenceResult,\n+    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we\n+    // need to take this input explicitly.\n+    root_expr: ExprId,\n+) -> Result<MirBody> {\n+    let mut basic_blocks = Arena::new();\n+    let start_block =\n+        basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n+    let mut locals = Arena::new();\n+    // 0 is return local\n+    locals.alloc(Local { mutability: Mutability::Mut, ty: infer[root_expr].clone() });\n+    let mut create_local_of_path = |p: PatId| {\n+        // FIXME: mutablity is broken\n+        locals.alloc(Local { mutability: Mutability::Not, ty: infer[p].clone() })\n+    };\n+    // 1 to param_len is for params\n+    let mut binding_locals: ArenaMap<PatId, LocalId> =\n+        body.params.iter().map(|&x| (x, create_local_of_path(x))).collect();\n+    // and then rest of bindings\n+    for (pat_id, _) in body.pats.iter() {\n+        if !binding_locals.contains_idx(pat_id) {\n+            binding_locals.insert(pat_id, create_local_of_path(pat_id));\n+        }\n+    }\n+    let mir = MirBody { basic_blocks, locals, start_block, owner, arg_count: body.params.len() };\n+    let mut ctx = MirLowerCtx {\n+        result: mir,\n+        db,\n+        infer,\n+        body,\n+        binding_locals,\n+        owner,\n+        current_loop_blocks: None,\n+        discr_temp: None,\n+    };\n+    let b = ctx.lower_expr_to_place(root_expr, return_slot().into(), start_block)?;\n+    ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+    Ok(ctx.result)\n+}"}, {"sha": "eca37149f0a0891ffcc64b24cd5125054afafaa8", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -50,7 +50,6 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n-    type_ref::ConstScalar,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n     EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n@@ -59,16 +58,16 @@ use hir_def::{\n use hir_expand::{name::name, MacroCallKind};\n use hir_ty::{\n     all_super_traits, autoderef,\n-    consteval::{unknown_const_as_generic, ComputedExpr, ConstEvalError, ConstExt},\n+    consteval::{try_const_usize, unknown_const_as_generic, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n     layout::layout_of_ty,\n     method_resolution::{self, TyFingerprint},\n+    mir::interpret_mir,\n     primitive::UintTy,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n-    ConcreteConst, ConstValue, GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar,\n-    Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind,\n-    WhereClause,\n+    GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n+    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -130,6 +129,7 @@ pub use {\n     },\n     hir_ty::{\n         display::{HirDisplay, HirDisplayError, HirWrite},\n+        mir::MirEvalError,\n         PointerCast, Safety,\n     },\n };\n@@ -1092,8 +1092,8 @@ impl Variant {\n         self.source(db)?.value.expr()\n     }\n \n-    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n-        db.const_eval_variant(self.into())\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<i128, ConstEvalError> {\n+        db.const_eval_discriminant(self.into())\n     }\n }\n \n@@ -1639,6 +1639,14 @@ impl Function {\n         let def_map = db.crate_def_map(loc.krate(db).into());\n         def_map.fn_as_proc_macro(self.id).map(|id| Macro { id: id.into() })\n     }\n+\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<(), MirEvalError> {\n+        let body = db\n+            .mir_body(self.id.into())\n+            .map_err(|e| MirEvalError::MirLowerError(self.id.into(), e))?;\n+        interpret_mir(db, &body, false)?;\n+        Ok(())\n+    }\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n@@ -1781,7 +1789,7 @@ impl Const {\n         Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n \n-    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<hir_ty::Const, ConstEvalError> {\n         db.const_eval(self.id)\n     }\n }\n@@ -3268,12 +3276,7 @@ impl Type {\n \n     pub fn as_array(&self, _db: &dyn HirDatabase) -> Option<(Type, usize)> {\n         if let TyKind::Array(ty, len) = &self.ty.kind(Interner) {\n-            match len.data(Interner).value {\n-                ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(len) }) => {\n-                    Some((self.derived(ty.clone()), len as usize))\n-                }\n-                _ => None,\n-            }\n+            try_const_usize(len).map(|x| (self.derived(ty.clone()), x as usize))\n         } else {\n             None\n         }"}, {"sha": "61e58cb1c4a716fa2c57edb52b85ee30df3ca286", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -791,7 +791,7 @@ impl SourceAnalyzer {\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-        method_resolution::lookup_impl_method(db, env, func, substs)\n+        method_resolution::lookup_impl_method(db, env, func, substs).0\n     }\n \n     fn resolve_impl_const_or_trait_def(\n@@ -809,7 +809,7 @@ impl SourceAnalyzer {\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-        method_resolution::lookup_impl_const(db, env, const_id, subs)\n+        method_resolution::lookup_impl_const(db, env, const_id, subs).0\n     }\n \n     fn lang_trait_fn("}, {"sha": "785ae3d09c6e3b32e7dca42ce9b42659fc2626e5", "filename": "crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -211,10 +211,8 @@ fn main() {\n         check_assist_not_applicable(\n             add_explicit_type,\n             r#\"\n-//- minicore: option\n-\n fn main() {\n-    let $0l = [0.0; Some(2).unwrap()];\n+    let $0l = [0.0; unresolved_function(5)];\n }\n \"#,\n         );"}, {"sha": "64b2221bdeab4cab2b3c5738a2e960f00c1f5b3e", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -30,6 +30,7 @@ pub struct HoverConfig {\n     pub documentation: bool,\n     pub keywords: bool,\n     pub format: HoverDocFormat,\n+    pub interpret_tests: bool,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "749c224c46207db391156e827469a7493b46de56", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -3,7 +3,8 @@ use std::fmt::Display;\n \n use either::Either;\n use hir::{\n-    Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo,\n+    db::DefDatabase, Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay,\n+    MirEvalError, Semantics, TypeInfo,\n };\n use ide_db::{\n     base_db::SourceDatabase,\n@@ -402,15 +403,28 @@ pub(super) fn definition(\n             ))\n         }),\n         Definition::Module(it) => label_and_docs(db, it),\n-        Definition::Function(it) => label_and_docs(db, it),\n+        Definition::Function(it) => label_and_layout_info_and_docs(db, it, |_| {\n+            if !config.interpret_tests {\n+                return None;\n+            }\n+            match it.eval(db) {\n+                Ok(()) => Some(\"pass\".into()),\n+                Err(MirEvalError::Panic) => Some(\"fail\".into()),\n+                Err(MirEvalError::MirLowerError(f, e)) => {\n+                    let name = &db.function_data(f).name;\n+                    Some(format!(\"error: fail to lower {name} due {e:?}\"))\n+                }\n+                Err(e) => Some(format!(\"error: {e:?}\")),\n+            }\n+        }),\n         Definition::Adt(it) => label_and_layout_info_and_docs(db, it, |&it| {\n             let layout = it.layout(db).ok()?;\n             Some(format!(\"size = {}, align = {}\", layout.size.bytes(), layout.align.abi.bytes()))\n         }),\n         Definition::Variant(it) => label_value_and_docs(db, it, |&it| {\n             if !it.parent_enum(db).is_data_carrying(db) {\n                 match it.eval(db) {\n-                    Ok(x) => Some(format!(\"{x}\")),\n+                    Ok(x) => Some(if x >= 10 { format!(\"{x} ({x:#X})\") } else { format!(\"{x}\") }),\n                     Err(_) => it.value(db).map(|x| format!(\"{x:?}\")),\n                 }\n             } else {\n@@ -420,7 +434,7 @@ pub(super) fn definition(\n         Definition::Const(it) => label_value_and_docs(db, it, |it| {\n             let body = it.eval(db);\n             match body {\n-                Ok(x) => Some(format!(\"{x}\")),\n+                Ok(x) => Some(format!(\"{}\", x.display(db))),\n                 Err(_) => {\n                     let source = it.source(db)?;\n                     let mut body = source.value.body()?.syntax().clone();"}, {"sha": "d4eb314a381b08ed09f108e712411a0465abba98", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 32, "deletions": 81, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -4,16 +4,19 @@ use syntax::TextRange;\n \n use crate::{fixture, HoverConfig, HoverDocFormat};\n \n+const HOVER_BASE_CONFIG: HoverConfig = HoverConfig {\n+    links_in_hover: false,\n+    documentation: true,\n+    format: HoverDocFormat::Markdown,\n+    keywords: true,\n+    interpret_tests: false,\n+};\n+\n fn check_hover_no_result(ra_fixture: &str) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap();\n@@ -25,12 +28,7 @@ fn check(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -47,12 +45,7 @@ fn check_hover_no_links(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: false,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HOVER_BASE_CONFIG,\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -71,9 +64,8 @@ fn check_hover_no_markdown(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n                 format: HoverDocFormat::PlainText,\n+                ..HOVER_BASE_CONFIG\n             },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n@@ -91,12 +83,7 @@ fn check_actions(ra_fixture: &str, expect: Expect) {\n     let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },\n             FileRange { file_id, range: position.range_or_empty() },\n         )\n         .unwrap()\n@@ -106,34 +93,13 @@ fn check_actions(ra_fixture: &str, expect: Expect) {\n \n fn check_hover_range(ra_fixture: &str, expect: Expect) {\n     let (analysis, range) = fixture::range(ra_fixture);\n-    let hover = analysis\n-        .hover(\n-            &HoverConfig {\n-                links_in_hover: false,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n-            range,\n-        )\n-        .unwrap()\n-        .unwrap();\n+    let hover = analysis.hover(&HOVER_BASE_CONFIG, range).unwrap().unwrap();\n     expect.assert_eq(hover.info.markup.as_str())\n }\n \n fn check_hover_range_no_results(ra_fixture: &str) {\n     let (analysis, range) = fixture::range(ra_fixture);\n-    let hover = analysis\n-        .hover(\n-            &HoverConfig {\n-                links_in_hover: false,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n-            range,\n-        )\n-        .unwrap();\n+    let hover = analysis.hover(&HOVER_BASE_CONFIG, range).unwrap();\n     assert!(hover.is_none());\n }\n \n@@ -490,7 +456,6 @@ fn hover_field_offset() {\n     // Hovering over the field when instantiating\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { fiel$0d_a: u8, field_b: i32, field_c: i16 }\n \"#,\n         expect![[r#\"\n@@ -512,7 +477,6 @@ fn hover_shows_struct_field_info() {\n     // Hovering over the field when instantiating\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { field_a: u32 }\n \n fn main() {\n@@ -535,7 +499,6 @@ fn main() {\n     // Hovering over the field in the definition\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { field_a$0: u32 }\n \n fn main() {\n@@ -568,7 +531,7 @@ fn hover_const_static() {\n             ```\n \n             ```rust\n-            const foo: u32 = 123 (0x7B)\n+            const foo: u32 = 123\n             ```\n         \"#]],\n     );\n@@ -1467,8 +1430,6 @@ fn my() {}\n fn test_hover_struct_doc_comment() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n /// This is an example\n /// multiline doc\n ///\n@@ -1527,7 +1488,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1556,7 +1517,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1584,7 +1545,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar\n+            pub struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1611,7 +1572,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar\n+            pub struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -2913,8 +2874,6 @@ fn main() { let foo_test = name_with_dashes::wrapper::Thing::new$0(); }\n fn hover_field_pat_shorthand_ref_match_ergonomics() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n struct S {\n     f: i32,\n }\n@@ -3506,8 +3465,8 @@ impl<const LEN: usize> Foo<LEN$0> {}\n }\n \n #[test]\n-fn hover_const_eval_variant() {\n-    // show hex for <10\n+fn hover_const_eval_discriminant() {\n+    // Don't show hex for <10\n     check(\n         r#\"\n #[repr(u8)]\n@@ -3532,7 +3491,7 @@ enum E {\n             This is a doc\n         \"#]],\n     );\n-    // show hex for >10\n+    // Show hex for >10\n     check(\n         r#\"\n #[repr(u8)]\n@@ -3656,7 +3615,7 @@ trait T {\n }\n impl T for i32 {\n     const AA: A = A {\n-        i: 2\n+        i: 2 + 3\n     }\n }\n fn main() {\n@@ -3671,9 +3630,7 @@ fn main() {\n         ```\n \n         ```rust\n-        const AA: A = A {\n-                i: 2\n-            }\n+        const AA: A = A { i: 5 }\n         ```\n     \"#]],\n     );\n@@ -3792,7 +3749,7 @@ const FOO$0: usize = 1 << 3;\n             This is a doc\n         \"#]],\n     );\n-    // show hex for >10\n+    // FIXME: show hex for >10\n     check(\n         r#\"\n /// This is a doc\n@@ -3806,7 +3763,7 @@ const FOO$0: usize = (1 << 3) + (1 << 2);\n             ```\n \n             ```rust\n-            const FOO: usize = 12 (0xC)\n+            const FOO: usize = 12\n             ```\n \n             ---\n@@ -3937,7 +3894,7 @@ const FOO$0: u8 = b'a';\n             ```\n \n             ```rust\n-            const FOO: u8 = 97 (0x61)\n+            const FOO: u8 = 97\n             ```\n \n             ---\n@@ -3959,7 +3916,7 @@ const FOO$0: u8 = b'\\x61';\n             ```\n \n             ```rust\n-            const FOO: u8 = 97 (0x61)\n+            const FOO: u8 = 97\n             ```\n \n             ---\n@@ -4354,8 +4311,6 @@ fn main() {\n fn hover_intra_doc_links() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n pub mod theitem {\n     /// This is the item. Cool!\n     pub struct TheItem;\n@@ -4496,7 +4451,7 @@ trait A where\n fn string_shadowed_with_inner_items() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:alloc target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n+//- /main.rs crate:main deps:alloc\n \n /// Custom `String` type.\n struct String;\n@@ -5191,7 +5146,7 @@ foo_macro!(\n             ```\n \n             ```rust\n-            pub struct Foo\n+            pub struct Foo // size = 0, align = 1\n             ```\n \n             ---\n@@ -5205,8 +5160,6 @@ foo_macro!(\n fn hover_intra_in_attr() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n #[doc = \"Doc comment for [`Foo$0`]\"]\n pub struct Foo(i32);\n \"#,\n@@ -5295,7 +5248,7 @@ pub struct Type;\n             ```\n \n             ```rust\n-            const KONST: dep::Type = $crate::Type\n+            const KONST: dep::Type = Type\n             ```\n         \"#]],\n     );\n@@ -5327,8 +5280,6 @@ enum Enum {\n fn hover_record_variant_field() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n enum Enum {\n     RecordV { field$0: u32 }\n }"}, {"sha": "67eaa553ada4eb79f771466f3e8145f4d3280de1", "filename": "crates/ide/src/inlay_hints/discriminant.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -59,8 +59,14 @@ fn variant_hints(\n         },\n         kind: InlayKind::Discriminant,\n         label: InlayHintLabel::simple(\n-            match &d {\n-                Ok(v) => format!(\"{}\", v),\n+            match d {\n+                Ok(x) => {\n+                    if x >= 10 {\n+                        format!(\"{x} ({x:#X})\")\n+                    } else {\n+                        format!(\"{x}\")\n+                    }\n+                }\n                 Err(_) => \"?\".into(),\n             },\n             Some(InlayTooltip::String(match &d {"}, {"sha": "c97691b14a57f1848f2043686d83c3cc851a80f1", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -139,6 +139,7 @@ impl StaticIndex<'_> {\n             documentation: true,\n             keywords: true,\n             format: crate::HoverDocFormat::Markdown,\n+            interpret_tests: false,\n         };\n         let tokens = tokens.filter(|token| {\n             matches!("}, {"sha": "9c832462be5cc0f15bc0f5dd1c7a47b1cc412aea", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -366,6 +366,8 @@ config_data! {\n         inlayHints_typeHints_hideClosureInitialization: bool       = \"false\",\n         /// Whether to hide inlay type hints for constructors.\n         inlayHints_typeHints_hideNamedConstructor: bool            = \"false\",\n+        /// Enables the experimental support for interpreting tests.\n+        interpret_tests: bool                                      = \"false\",\n \n         /// Join lines merges consecutive declaration and initialization of an assignment.\n         joinLines_joinAssignments: bool = \"true\",\n@@ -1444,6 +1446,7 @@ impl Config {\n                 }\n             },\n             keywords: self.data.hover_documentation_keywords_enable,\n+            interpret_tests: self.data.interpret_tests,\n         }\n     }\n "}, {"sha": "cd1235fa6dc4e04f1c5938ddba6292567c2b77ce", "filename": "crates/test-utils/src/fixture.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Ffixture.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -180,7 +180,9 @@ impl Fixture {\n         let mut cfg_key_values = Vec::new();\n         let mut env = FxHashMap::default();\n         let mut introduce_new_source_root = None;\n-        let mut target_data_layout = None;\n+        let mut target_data_layout = Some(\n+            \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        );\n         for component in components[1..].iter() {\n             let (key, value) =\n                 component.split_once(':').unwrap_or_else(|| panic!(\"invalid meta line: {meta:?}\"));"}, {"sha": "7b48e42489cafa61ea1127b6b324e1edaab6fdc5", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -510,6 +510,7 @@ pub mod fmt {\n pub mod slice {\n     #[lang = \"slice\"]\n     impl<T> [T] {\n+        #[lang = \"slice_len_fn\"]\n         pub fn len(&self) -> usize {\n             loop {}\n         }"}, {"sha": "1bc498c42cec22faf63787ee41ae8a312a3eed02", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -537,6 +537,11 @@ Only applies to closures with blocks, same as `#rust-analyzer.inlayHints.closure\n --\n Whether to hide inlay type hints for constructors.\n --\n+[[rust-analyzer.interpret.tests]]rust-analyzer.interpret.tests (default: `false`)::\n++\n+--\n+Enables the experimental support for interpreting tests.\n+--\n [[rust-analyzer.joinLines.joinAssignments]]rust-analyzer.joinLines.joinAssignments (default: `true`)::\n +\n --"}, {"sha": "effe4e279c76e98b79f890915a9ce8184ecac84d", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0be16b0b28143bca47a7598dbdf39e33692f690/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/a0be16b0b28143bca47a7598dbdf39e33692f690/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=a0be16b0b28143bca47a7598dbdf39e33692f690", "patch": "@@ -1110,6 +1110,11 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.interpret.tests\": {\n+                    \"markdownDescription\": \"Enables the experimental support for interpreting tests.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.joinLines.joinAssignments\": {\n                     \"markdownDescription\": \"Join lines merges consecutive declaration and initialization of an assignment.\",\n                     \"default\": true,"}]}