{"sha": "5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNjI2N2M4YjM0YmRiNmU3NTAxMmI4MTdlNjRkMTVjZjZlM2I0NWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-12-06T22:49:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-12-09T19:41:47Z"}, "message": "resolve: Make visibility resolution more speculative\n\nTo avoid potential duplicate diagnostics and separate the error reporting logic", "tree": {"sha": "04863ed0dd3674912c84c608b4dcad59f5f474dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04863ed0dd3674912c84c608b4dcad59f5f474dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "html_url": "https://github.com/rust-lang/rust/commit/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2c962d3d00d38aef9ed024caced7ef189cd2533", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c962d3d00d38aef9ed024caced7ef189cd2533", "html_url": "https://github.com/rust-lang/rust/commit/e2c962d3d00d38aef9ed024caced7ef189cd2533"}], "stats": {"total": 157, "additions": 87, "deletions": 70}, "files": [{"sha": "566ba129074370b0cba3dd10f151724577225fa2", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 36, "deletions": 60, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "patch": "@@ -12,7 +12,7 @@ use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleIm\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n+use crate::{ResolutionError, VisResolutionError, Determinacy, PathResult, CrateLint};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -32,8 +32,7 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind};\n use syntax::token::{self, Token};\n-use syntax::print::pprust;\n-use syntax::{span_err, struct_span_err};\n+use syntax::span_err;\n use syntax::source_map::{respan, Spanned};\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n@@ -192,22 +191,25 @@ impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        self.resolve_visibility_speculative(vis, false)\n+        self.resolve_visibility_speculative(vis, false).unwrap_or_else(|err| {\n+            self.r.report_vis_error(err);\n+            ty::Visibility::Public\n+        })\n     }\n \n-    fn resolve_visibility_speculative(\n+    fn resolve_visibility_speculative<'ast>(\n         &mut self,\n-        vis: &ast::Visibility,\n+        vis: &'ast ast::Visibility,\n         speculative: bool,\n-    ) -> ty::Visibility {\n+    ) -> Result<ty::Visibility, VisResolutionError<'ast>> {\n         let parent_scope = &self.parent_scope;\n         match vis.node {\n-            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Public => Ok(ty::Visibility::Public),\n             ast::VisibilityKind::Crate(..) => {\n-                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+                Ok(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)))\n             }\n             ast::VisibilityKind::Inherited => {\n-                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n+                Ok(ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id))\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n@@ -217,32 +219,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n                 let crate_root = if ident.is_path_segment_keyword() {\n                     None\n-                } else if ident.span.rust_2018() {\n-                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n-                    self.r.session.struct_span_err(ident.span, msg)\n-                        .span_suggestion(\n-                            path.span,\n-                            \"try\",\n-                            format!(\"crate::{}\", pprust::path_to_string(&path)),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n-                    return ty::Visibility::Public;\n-                } else {\n-                    let ctxt = ident.span.ctxt();\n+                } else if ident.span.rust_2015() {\n                     Some(Segment::from_ident(Ident::new(\n-                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n+                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ident.span.ctxt())\n                     )))\n+                } else {\n+                    return Err(VisResolutionError::Relative2018(ident.span, path));\n                 };\n \n                 let segments = crate_root.into_iter()\n                     .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n-                let expected_found_error = |this: &Self, res: Res| {\n-                    let path_str = Segment::names_to_string(&segments);\n-                    struct_span_err!(this.r.session, path.span, E0577,\n-                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n-                        .span_label(path.span, \"not a module\").emit();\n-                };\n+                let expected_found_error = |res| Err(VisResolutionError::ExpectedFound(\n+                    path.span, Segment::names_to_string(&segments), res\n+                ));\n                 match self.r.resolve_path(\n                     &segments,\n                     Some(TypeNS),\n@@ -258,42 +247,27 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n                         if module.is_normal() {\n                             if res == Res::Err {\n-                                ty::Visibility::Public\n+                                Ok(ty::Visibility::Public)\n                             } else {\n                                 let vis = ty::Visibility::Restricted(res.def_id());\n                                 if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    vis\n+                                    Ok(vis)\n                                 } else {\n-                                    struct_span_err!(self.r.session, path.span, E0742,\n-                                        \"visibilities can only be restricted to ancestor modules\")\n-                                        .emit();\n-                                    ty::Visibility::Public\n+                                    Err(VisResolutionError::AncestorOnly(path.span))\n                                 }\n                             }\n                         } else {\n-                            expected_found_error(self, res);\n-                            ty::Visibility::Public\n+                            expected_found_error(res)\n                         }\n                     }\n-                    PathResult::Module(..) => {\n-                        self.r.session.span_err(path.span, \"visibility must resolve to a module\");\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::NonModule(partial_res) => {\n-                        expected_found_error(self, partial_res.base_res());\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Failed { span, label, suggestion, .. } => {\n-                        self.r.report_error(\n-                            span, ResolutionError::FailedToResolve { label, suggestion }\n-                        );\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Indeterminate => {\n-                        span_err!(self.r.session, path.span, E0578,\n-                                  \"cannot determine resolution for the visibility\");\n-                        ty::Visibility::Public\n-                    }\n+                    PathResult::Module(..) =>\n+                        Err(VisResolutionError::ModuleOnly(path.span)),\n+                    PathResult::NonModule(partial_res) =>\n+                        expected_found_error(partial_res.base_res()),\n+                    PathResult::Failed { span, label, suggestion, .. } =>\n+                        Err(VisResolutionError::FailedToResolve(span, label, suggestion)),\n+                    PathResult::Indeterminate =>\n+                        Err(VisResolutionError::Indeterminate(path.span)),\n                 }\n             }\n         }\n@@ -766,9 +740,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         // NOTE: The field may be an expansion placeholder, but expansion sets\n                         // correct visibilities for unnamed field placeholders specifically, so the\n                         // constructor visibility should still be determined correctly.\n-                        let field_vis = self.resolve_visibility_speculative(&field.vis, true);\n-                        if ctor_vis.is_at_least(field_vis, &*self.r) {\n-                            ctor_vis = field_vis;\n+                        if let Ok(field_vis) =\n+                                self.resolve_visibility_speculative(&field.vis, true) {\n+                            if ctor_vis.is_at_least(field_vis, &*self.r) {\n+                                ctor_vis = field_vis;\n+                            }\n                         }\n                     }\n                     let ctor_res = Res::Def("}, {"sha": "f92415fc0521a2fd802754cb43ab876fd1f46199", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "patch": "@@ -11,6 +11,7 @@ use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::FxHashSet;\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use syntax::ast::{self, Ident, Path};\n+use syntax::print::pprust;\n use syntax::source_map::SourceMap;\n use syntax::struct_span_err;\n use syntax::symbol::{Symbol, kw};\n@@ -22,6 +23,7 @@ use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportRes\n use crate::path_names_to_string;\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n+use crate::VisResolutionError;\n \n use rustc_error_codes::*;\n \n@@ -357,6 +359,44 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    crate fn report_vis_error(&self, vis_resolution_error: VisResolutionError<'_>) {\n+        match vis_resolution_error {\n+            VisResolutionError::Relative2018(span, path) => {\n+                let mut err = self.session.struct_span_err(span,\n+                    \"relative paths are not supported in visibilities on 2018 edition\");\n+                err.span_suggestion(\n+                    path.span,\n+                    \"try\",\n+                    format!(\"crate::{}\", pprust::path_to_string(&path)),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err\n+            }\n+            VisResolutionError::AncestorOnly(span) => {\n+                struct_span_err!(self.session, span, E0742,\n+                    \"visibilities can only be restricted to ancestor modules\")\n+            }\n+            VisResolutionError::FailedToResolve(span, label, suggestion) => {\n+                self.into_struct_error(\n+                    span, ResolutionError::FailedToResolve { label, suggestion }\n+                )\n+            }\n+            VisResolutionError::ExpectedFound(span, path_str, res) => {\n+                let mut err = struct_span_err!(self.session, span, E0577,\n+                    \"expected module, found {} `{}`\", res.descr(), path_str);\n+                err.span_label(span, \"not a module\");\n+                err\n+            }\n+            VisResolutionError::Indeterminate(span) => {\n+                struct_span_err!(self.session, span, E0578,\n+                    \"cannot determine resolution for the visibility\")\n+            }\n+            VisResolutionError::ModuleOnly(span) => {\n+                self.session.struct_span_err(span, \"visibility must resolve to a module\")\n+            }\n+        }.emit()\n+    }\n+\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n         &mut self,"}, {"sha": "9db89c8273d9c16b956d9a5a122efb95b1a3aa7f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "patch": "@@ -218,6 +218,15 @@ enum ResolutionError<'a> {\n     SelfInTyParamDefault,\n }\n \n+enum VisResolutionError<'a> {\n+    Relative2018(Span, &'a ast::Path),\n+    AncestorOnly(Span),\n+    FailedToResolve(Span, String, Option<Suggestion>),\n+    ExpectedFound(Span, String, Res),\n+    Indeterminate(Span),\n+    ModuleOnly(Span),\n+}\n+\n // A minimal representation of a path segment. We use this in resolve because\n // we synthesize 'path segments' which don't have the rest of an AST or HIR\n // `PathSegment`."}, {"sha": "d1bd2a1e7272416d95ad11145bb4151fdbf1f2c5", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.rs?ref=5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "patch": "@@ -20,7 +20,6 @@ struct S {\n struct Z(\n     #[rustfmt::skip]\n     pub(in nonexistent) u8 //~ ERROR failed to resolve\n-                           //~| ERROR cannot determine resolution for the visibility\n );\n \n fn main() {}"}, {"sha": "41c3cea3021354d56ba96a3a97adcd726fee0e50", "filename": "src/test/ui/attributes/field-attributes-vis-unresolved.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f6267c8b34bdb6e75012b817e64d15cf6e3b45a/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Ffield-attributes-vis-unresolved.stderr?ref=5f6267c8b34bdb6e75012b817e64d15cf6e3b45a", "patch": "@@ -1,9 +1,3 @@\n-error[E0578]: cannot determine resolution for the visibility\n-  --> $DIR/field-attributes-vis-unresolved.rs:22:12\n-   |\n-LL |     pub(in nonexistent) u8\n-   |            ^^^^^^^^^^^\n-\n error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n   --> $DIR/field-attributes-vis-unresolved.rs:17:12\n    |\n@@ -16,7 +10,6 @@ error[E0433]: failed to resolve: maybe a missing crate `nonexistent`?\n LL |     pub(in nonexistent) u8\n    |            ^^^^^^^^^^^ maybe a missing crate `nonexistent`?\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0433, E0578.\n-For more information about an error, try `rustc --explain E0433`.\n+For more information about this error, try `rustc --explain E0433`."}]}