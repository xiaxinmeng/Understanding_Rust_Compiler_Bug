{"sha": "20af72b943527d584df4b99e157262f9b297b3e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYWY3MmI5NDM1MjdkNTg0ZGY0Yjk5ZTE1NzI2MmY5YjI5N2IzZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-30T09:24:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-30T09:24:20Z"}, "message": "Auto merge of #51106 - davidtwco:issue-50934, r=nikomatsakis\n\nOptimize the way that loans are killed in borrowck dataflow\n\nFixes #50934.\nr? @nikomatsakis", "tree": {"sha": "9fa410f7b57d6491ef63ec9d56f60f3698c6297d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fa410f7b57d6491ef63ec9d56f60f3698c6297d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20af72b943527d584df4b99e157262f9b297b3e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20af72b943527d584df4b99e157262f9b297b3e4", "html_url": "https://github.com/rust-lang/rust/commit/20af72b943527d584df4b99e157262f9b297b3e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20af72b943527d584df4b99e157262f9b297b3e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2408095f3456ba8974032e5dd0a2806cc7329cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2408095f3456ba8974032e5dd0a2806cc7329cfb", "html_url": "https://github.com/rust-lang/rust/commit/2408095f3456ba8974032e5dd0a2806cc7329cfb"}, {"sha": "3a9134dec568d39e3d9b064b532483eb9daa0a2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9134dec568d39e3d9b064b532483eb9daa0a2c", "html_url": "https://github.com/rust-lang/rust/commit/3a9134dec568d39e3d9b064b532483eb9daa0a2c"}], "stats": {"total": 92, "additions": 78, "deletions": 14}, "files": [{"sha": "dea2683789bdfb81729890c3b761a2947766b5fd", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -352,7 +352,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n+    crate fn region_value_str(&self, r: RegionVid) -> String {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");"}, {"sha": "a109389aa312c30d562247623ac1bb78b05dc6fe", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 77, "deletions": 13, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20af72b943527d584df4b99e157262f9b297b3e4/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=20af72b943527d584df4b99e157262f9b297b3e4", "patch": "@@ -17,10 +17,11 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n use rustc::ty::TyCtxt;\n-use rustc::ty::RegionKind;\n+use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n use rustc_data_structures::bitslice::BitwiseOperator;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n@@ -46,9 +47,65 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     root_scope: Option<region::Scope>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n+    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n \n     /// NLL region inference context with which NLL queries should be resolved\n-    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+    _nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+}\n+\n+fn precompute_borrows_out_of_scope<'a, 'tcx>(\n+    mir: &'a Mir<'tcx>,\n+    regioncx: &Rc<RegionInferenceContext<'tcx>>,\n+    borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n+    borrow_index: BorrowIndex,\n+    borrow_region: RegionVid,\n+    location: Location,\n+) {\n+    // Keep track of places we've locations to check and locations that we have checked.\n+    let mut stack = vec![ location ];\n+    let mut visited = FxHashSet();\n+    visited.insert(location);\n+\n+    debug!(\n+        \"borrow {:?} has region {:?} with value {:?}\",\n+        borrow_index,\n+        borrow_region,\n+        regioncx.region_value_str(borrow_region),\n+    );\n+    debug!(\"borrow {:?} starts at {:?}\", borrow_index, location);\n+    while let Some(location) = stack.pop() {\n+        // If region does not contain a point at the location, then add to list and skip\n+        // successor locations.\n+        if !regioncx.region_contains_point(borrow_region, location) {\n+            debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n+            borrows_out_of_scope_at_location\n+                .entry(location)\n+                .or_insert(vec![])\n+                .push(borrow_index);\n+            continue;\n+        }\n+\n+        let bb_data = &mir[location.block];\n+        // If this is the last statement in the block, then add the\n+        // terminator successors next.\n+        if location.statement_index == bb_data.statements.len() {\n+            // Add successors to locations to visit, if not visited before.\n+            if let Some(ref terminator) = bb_data.terminator {\n+                for block in terminator.successors() {\n+                    let loc = block.start_location();\n+                    if visited.insert(loc) {\n+                        stack.push(loc);\n+                    }\n+                }\n+            }\n+        } else {\n+            // Visit next statement in block.\n+            let loc = location.successor_within_block();\n+            if visited.insert(loc) {\n+                stack.push(loc);\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n@@ -65,18 +122,28 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n         });\n \n+        let mut borrows_out_of_scope_at_location = FxHashMap();\n+        for (borrow_index, borrow_data) in borrow_set.borrows.iter_enumerated() {\n+            let borrow_region = borrow_data.region.to_region_vid();\n+            let location = borrow_set.borrows[borrow_index].reserve_location;\n+\n+            precompute_borrows_out_of_scope(mir, &nonlexical_regioncx,\n+                                            &mut borrows_out_of_scope_at_location,\n+                                            borrow_index, borrow_region, location);\n+        }\n+\n         Borrows {\n             tcx: tcx,\n             mir: mir,\n             borrow_set: borrow_set.clone(),\n+            borrows_out_of_scope_at_location,\n             scope_tree,\n             root_scope,\n-            nonlexical_regioncx,\n+            _nonlexical_regioncx: nonlexical_regioncx,\n         }\n     }\n \n     crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrow_set.borrows }\n-\n     pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n@@ -89,23 +156,20 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n-        let regioncx = &self.nonlexical_regioncx;\n-\n         // NOTE: The state associated with a given `location`\n-        // reflects the dataflow on entry to the statement. If it\n-        // does not contain `borrow_region`, then then that means\n-        // that the statement at `location` kills the borrow.\n+        // reflects the dataflow on entry to the statement.\n+        // Iterate over each of the borrows that we've precomputed\n+        // to have went out of scope at this location and kill them.\n         //\n         // We are careful always to call this function *before* we\n         // set up the gen-bits for the statement or\n         // termanator. That way, if the effect of the statement or\n         // terminator *does* introduce a new loan of the same\n         // region, then setting that gen-bit will override any\n         // potential kill introduced here.\n-        for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n-            let borrow_region = borrow_data.region.to_region_vid();\n-            if !regioncx.region_contains_point(borrow_region, location) {\n-                sets.kill(&borrow_index);\n+        if let Some(indices) = self.borrows_out_of_scope_at_location.get(&location) {\n+            for index in indices {\n+                sets.kill(&index);\n             }\n         }\n     }"}]}