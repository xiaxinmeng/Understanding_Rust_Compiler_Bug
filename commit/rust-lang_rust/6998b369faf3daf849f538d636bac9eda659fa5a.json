{"sha": "6998b369faf3daf849f538d636bac9eda659fa5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OThiMzY5ZmFmM2RhZjg0OWY1MzhkNjM2YmFjOWVkYTY1OWZhNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-27T11:02:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-27T11:02:27Z"}, "message": "Auto merge of #52733 - pnkfelix:issue-51348-make-temp-for-each-candidate-in-arm, r=nikomatsakis\n\n[NLL] make temp for each candidate in `match` arm\n\nIn NLL, `ref mut` patterns leverage the two-phase borrow infrastructure to allow the shared borrows within a guard before the \"activation\" of the mutable borrow when we begin execution of the match arm's body. (There is further discussion of this on PR #50783.)\n\nTo accommodate the restrictions we impose on two-phase borrows (namely that there is a one-to-one mapping between each activation and the original initialization), this PR is making separate temps for each candidate pattern. So in an arm like this:\n```rust\nPatA(_, ref mut ident) |\nPatB(ref mut ident) |\nPatC(_, _, ref mut ident) |\nPatD(ref mut ident) if guard_stuff(ident) => ...\n```\n\ninstead of 3 temps (two for the guard and one for the arm body), we now have 4 + 2 temps associated with `ident`: one for each candidate plus the actual temp that the guard uses directly, and then the sixth is the temp used in the arm body.\n\nFix #51348", "tree": {"sha": "7e5d936229061e5ed7d2f33c8277e13961eba1be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e5d936229061e5ed7d2f33c8277e13961eba1be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6998b369faf3daf849f538d636bac9eda659fa5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6998b369faf3daf849f538d636bac9eda659fa5a", "html_url": "https://github.com/rust-lang/rust/commit/6998b369faf3daf849f538d636bac9eda659fa5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6998b369faf3daf849f538d636bac9eda659fa5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b18b9edf006c10f4e08794d31425001401e27a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/b18b9edf006c10f4e08794d31425001401e27a09", "html_url": "https://github.com/rust-lang/rust/commit/b18b9edf006c10f4e08794d31425001401e27a09"}, {"sha": "946264526ca0c4c89233410623f231a385e3be71", "url": "https://api.github.com/repos/rust-lang/rust/commits/946264526ca0c4c89233410623f231a385e3be71", "html_url": "https://github.com/rust-lang/rust/commit/946264526ca0c4c89233410623f231a385e3be71"}], "stats": {"total": 177, "additions": 137, "deletions": 40}, "files": [{"sha": "347bf61480ee4e9356e29bbcee2c0e80f1c553de", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -333,14 +333,21 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n \n         // Consider the borrow not activated to start. When we find an activation, we'll update\n         // this field.\n-        let borrow_data = &mut self.idx_vec[borrow_index];\n-        borrow_data.activation_location = TwoPhaseActivation::NotActivated;\n+        {\n+            let borrow_data = &mut self.idx_vec[borrow_index];\n+            borrow_data.activation_location = TwoPhaseActivation::NotActivated;\n+        }\n \n         // Insert `temp` into the list of pending activations. From\n         // now on, we'll be on the lookout for a use of it. Note that\n         // we are guaranteed that this use will come after the\n         // assignment.\n         let old_value = self.pending_activations.insert(temp, borrow_index);\n-        assert!(old_value.is_none());\n+        if let Some(old_index) = old_value {\n+            span_bug!(self.mir.source_info(start_location).span,\n+                      \"found already pending activation for temp: {:?} \\\n+                       at borrow_index: {:?} with associated data {:?}\",\n+                      temp, old_index, self.idx_vec[old_index]);\n+        }\n     }\n }"}, {"sha": "c3637a5abebdc4e31f9624dd722d0f34d234fbdf", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -16,6 +16,8 @@ use rustc::mir::*;\n use rustc::hir;\n use syntax_pos::Span;\n \n+use std::slice;\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Place<'tcx>,\n@@ -126,7 +128,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None,\n                             remainder_span,\n                             lint_level,\n-                            &pattern,\n+                            slice::from_ref(&pattern),\n                             ArmHasGuard(false),\n                             Some((None, initializer_span)),\n                         );\n@@ -138,8 +140,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 })\n                             }));\n                     } else {\n-                        scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n-                                                        ArmHasGuard(false), None);\n+                        scope = this.declare_bindings(\n+                            None, remainder_span, lint_level, slice::from_ref(&pattern),\n+                            ArmHasGuard(false), None);\n \n                         // FIXME(#47184): We currently only insert `UserAssertTy` statements for\n                         // patterns that are bindings, this is as we do not want to deconstruct"}, {"sha": "a38ca7ae5bf64953574c0659126fc4e1ef2fbfd0", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -11,7 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::ForGuard::{OutsideGuard, RefWithinGuard, ValWithinGuard};\n+use build::ForGuard::{OutsideGuard, RefWithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n@@ -87,14 +87,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Place::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n-                let place = if this.is_bound_var_in_guard(id) {\n-                    if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n-                        let index = this.var_local_id(id, RefWithinGuard);\n-                        Place::Local(index).deref()\n-                    } else {\n-                        let index = this.var_local_id(id, ValWithinGuard);\n-                        Place::Local(index)\n-                    }\n+                let place = if this.is_bound_var_in_guard(id) &&\n+                    this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards()\n+                {\n+                    let index = this.var_local_id(id, RefWithinGuard);\n+                    Place::Local(index).deref()\n                 } else {\n                     let index = this.var_local_id(id, OutsideGuard);\n                     Place::Local(index)"}, {"sha": "7c9496690280490da58c6aff5d69e07c52e5d18d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let body = self.hir.mirror(arm.body.clone());\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n-                                              &arm.patterns[0],\n+                                              &arm.patterns[..],\n                                               ArmHasGuard(arm.guard.is_some()),\n                                               Some((Some(&discriminant_place), discriminant_span)));\n             (body, scope.unwrap_or(self.source_scope))\n@@ -118,11 +118,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             arms.iter()\n                 .enumerate()\n                 .flat_map(|(arm_index, arm)| {\n-                    arm.patterns.iter()\n-                                .map(move |pat| (arm_index, pat, arm.guard.clone()))\n+                    arm.patterns.iter().enumerate()\n+                        .map(move |(pat_index, pat)| {\n+                            (arm_index, pat_index, pat, arm.guard.clone())\n+                        })\n                 })\n                 .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n-                .map(|((arm_index, pattern, guard),\n+                .map(|((arm_index, pat_index, pattern, guard),\n                        (pre_binding_block, next_candidate_pre_binding_block))| {\n \n                     if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n@@ -168,6 +170,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         bindings: vec![],\n                         guard,\n                         arm_index,\n+                        pat_index,\n                         pre_binding_block: *pre_binding_block,\n                         next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n                     }\n@@ -277,6 +280,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // since we don't call `match_candidates`, next fields is unused\n             arm_index: 0,\n+            pat_index: 0,\n             pre_binding_block: block,\n             next_candidate_pre_binding_block: block\n         };\n@@ -324,14 +328,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             mut visibility_scope: Option<SourceScope>,\n                             scope_span: Span,\n                             lint_level: LintLevel,\n-                            pattern: &Pattern<'tcx>,\n+                            patterns: &[Pattern<'tcx>],\n                             has_guard: ArmHasGuard,\n                             opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n                             -> Option<SourceScope> {\n         assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a visibility and a lint scope at the same time\");\n         let mut scope = self.source_scope;\n-        self.visit_bindings(pattern, &mut |this, mutability, name, mode, var, span, ty| {\n+        let num_patterns = patterns.len();\n+        self.visit_bindings(&patterns[0], &mut |this, mutability, name, mode, var, span, ty| {\n             if visibility_scope.is_none() {\n                 visibility_scope = Some(this.new_source_scope(scope_span,\n                                                            LintLevel::Inherited,\n@@ -349,8 +354,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 scope,\n             };\n             let visibility_scope = visibility_scope.unwrap();\n-            this.declare_binding(source_info, visibility_scope, mutability, name, mode, var,\n-                                 ty, has_guard, opt_match_place.map(|(x, y)| (x.cloned(), y)));\n+            this.declare_binding(source_info, visibility_scope, mutability, name, mode,\n+                                 num_patterns, var, ty, has_guard,\n+                                 opt_match_place.map(|(x, y)| (x.cloned(), y)));\n         });\n         visibility_scope\n     }\n@@ -453,6 +459,9 @@ pub struct Candidate<'pat, 'tcx:'pat> {\n     // ...and the blocks for add false edges between candidates\n     pre_binding_block: BasicBlock,\n     next_candidate_pre_binding_block: BasicBlock,\n+\n+    // This uniquely identifies this candidate *within* the arm.\n+    pat_index: usize,\n }\n \n #[derive(Clone, Debug)]\n@@ -972,7 +981,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n             if autoref {\n-                self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+                self.bind_matched_candidate_for_guard(\n+                    block, candidate.pat_index, &candidate.bindings);\n                 let guard_frame = GuardFrame {\n                     locals: candidate.bindings.iter()\n                         .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n@@ -1058,9 +1068,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // and thus all code/comments assume we are in that context.\n     fn bind_matched_candidate_for_guard(&mut self,\n                                         block: BasicBlock,\n+                                        pat_index: usize,\n                                         bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\",\n-               block, bindings);\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n+               block, pat_index, bindings);\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1099,8 +1110,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // used by the arm body itself. This eases\n                     // observing two-phase borrow restrictions.\n                     let val_for_guard = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, ValWithinGuard);\n-                    self.schedule_drop_for_binding(binding.var_id, binding.span, ValWithinGuard);\n+                        block, binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                    self.schedule_drop_for_binding(\n+                        binding.var_id, binding.span, ValWithinGuard(pat_index));\n \n                     // rust-lang/rust#27282: We reuse the two-phase\n                     // borrow infrastructure so that the mutable\n@@ -1146,16 +1158,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n     /// the bound `var` has type `T` in the arm body) in a pattern\n-    /// maps to *two* locals. The first local is a binding for\n+    /// maps to `2+N` locals. The first local is a binding for\n     /// occurrences of `var` in the guard, which will all have type\n-    /// `&T`. The second local is a binding for occurrences of `var`\n-    /// in the arm body, which will have type `T`.\n+    /// `&T`. The N locals are bindings for the `T` that is referenced\n+    /// by the first local; they are not used outside of the\n+    /// guard. The last local is a binding for occurrences of `var` in\n+    /// the arm body, which will have type `T`.\n+    ///\n+    /// The reason we have N locals rather than just 1 is to\n+    /// accommodate rust-lang/rust#51348: If the arm has N candidate\n+    /// patterns, then in general they can correspond to distinct\n+    /// parts of the matched data, and we want them to be distinct\n+    /// temps in order to simplify checks performed by our internal\n+    /// leveraging of two-phase borrows).\n     fn declare_binding(&mut self,\n                        source_info: SourceInfo,\n                        visibility_scope: SourceScope,\n                        mutability: Mutability,\n                        name: Name,\n                        mode: BindingMode,\n+                       num_patterns: usize,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n                        has_guard: ArmHasGuard,\n@@ -1189,7 +1211,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n-            let val_for_guard =  self.local_decls.push(local);\n+            let mut vals_for_guard = Vec::with_capacity(num_patterns);\n+            for _ in 0..num_patterns {\n+                let val_for_guard_idx =  self.local_decls.push(local.clone());\n+                vals_for_guard.push(val_for_guard_idx);\n+            }\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n                 mutability,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n@@ -1200,7 +1226,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 internal: false,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n-            LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n+            LocalsForNode::ForGuard { vals_for_guard, ref_for_guard, for_arm_body }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "afa0d28dd77180ebb6eef5e916cda5d9827d2939", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -631,6 +631,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n+            pat_index: candidate.pat_index,\n             pre_binding_block: candidate.pre_binding_block,\n             next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n         }\n@@ -694,6 +695,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n+            pat_index: candidate.pat_index,\n             pre_binding_block: candidate.pre_binding_block,\n             next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n         }"}, {"sha": "054bd69c361b92115eb6c60dd32e67ec3cccbcd4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -310,8 +310,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n #[derive(Debug)]\n enum LocalsForNode {\n+    /// In the usual case, a node-id for an identifier maps to at most\n+    /// one Local declaration.\n     One(Local),\n-    Three { val_for_guard: Local, ref_for_guard: Local, for_arm_body: Local },\n+\n+    /// The exceptional case is identifiers in a match arm's pattern\n+    /// that are referenced in a guard of that match arm. For these,\n+    /// we can have `2+k` Locals, where `k` is the number of candidate\n+    /// patterns (separated by `|`) in the arm.\n+    ///\n+    /// * `for_arm_body` is the Local used in the arm body (which is\n+    ///   just like the `One` case above),\n+    ///\n+    /// * `ref_for_guard` is the Local used in the arm's guard (which\n+    ///   is a reference to a temp that is an alias of\n+    ///   `for_arm_body`).\n+    ///\n+    /// * `vals_for_guard` is the `k` Locals; at most one of them will\n+    ///   get initialized by the arm's execution, and after it is\n+    ///   initialized, `ref_for_guard` will be assigned a reference to\n+    ///   it.\n+    ///\n+    /// There reason we have `k` Locals rather than just 1 is to\n+    /// accommodate some restrictions imposed by two-phase borrows,\n+    /// which apply when we have a `ref mut` pattern.\n+    ForGuard { vals_for_guard: Vec<Local>, ref_for_guard: Local, for_arm_body: Local },\n }\n \n #[derive(Debug)]\n@@ -350,7 +373,10 @@ struct GuardFrame {\n ///   3. the temp for use outside of guard expressions.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ForGuard {\n-    ValWithinGuard,\n+    /// The `usize` identifies for which candidate pattern we want the\n+    /// local binding. We keep a temp per-candidate to accommodate\n+    /// two-phase borrows (see `LocalsForNode` documentation).\n+    ValWithinGuard(usize),\n     RefWithinGuard,\n     OutsideGuard,\n }\n@@ -359,12 +385,15 @@ impl LocalsForNode {\n     fn local_id(&self, for_guard: ForGuard) -> Local {\n         match (self, for_guard) {\n             (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n-            (&LocalsForNode::Three { val_for_guard: local_id, .. }, ForGuard::ValWithinGuard) |\n-            (&LocalsForNode::Three { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n-            (&LocalsForNode::Three { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+            (&LocalsForNode::ForGuard { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n+            (&LocalsForNode::ForGuard { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n                 local_id,\n \n-            (&LocalsForNode::One(_), ForGuard::ValWithinGuard) |\n+            (&LocalsForNode::ForGuard { ref vals_for_guard, .. },\n+             ForGuard::ValWithinGuard(pat_idx)) =>\n+                vals_for_guard[pat_idx],\n+\n+            (&LocalsForNode::One(_), ForGuard::ValWithinGuard(_)) |\n             (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n                 bug!(\"anything with one local should never be within a guard.\"),\n         }\n@@ -740,7 +769,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &pattern,\n+                                                      LintLevel::Inherited, &[pattern.clone()],\n                                                       matches::ArmHasGuard(false),\n                                                       Some((Some(&place), span)));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place, false));"}, {"sha": "c9d39fa360efb66f0324e91869e13b06627ba1b2", "filename": "src/test/ui/borrowck/issue-51348-multi-ref-mut-in-guard.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Ftest%2Fui%2Fborrowck%2Fissue-51348-multi-ref-mut-in-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6998b369faf3daf849f538d636bac9eda659fa5a/src%2Ftest%2Fui%2Fborrowck%2Fissue-51348-multi-ref-mut-in-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51348-multi-ref-mut-in-guard.rs?ref=6998b369faf3daf849f538d636bac9eda659fa5a", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// We used to ICE if you had a single match arm with multiple\n+// candidate patterns with `ref mut` identifiers used in the arm's\n+// guard.\n+//\n+// Also, this test expands on the original bug's example by actually\n+// trying to double check that we are matching against the right part\n+// of the input data based on which candidate pattern actually fired.\n+\n+// run-pass\n+\n+#![feature(nll)]\n+\n+fn foo(x: &mut Result<(u32, u32), (u32, u32)>) -> u32 {\n+    match *x {\n+        Ok((ref mut v, _)) | Err((_, ref mut v)) if *v > 0 => { *v }\n+        _ => { 0 }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(foo(&mut Ok((3, 4))), 3);\n+    assert_eq!(foo(&mut Err((3, 4))), 4);\n+}"}]}