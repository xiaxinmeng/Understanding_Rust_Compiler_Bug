{"sha": "1a50f904effd780d93ca8b71f92eb0e7b7643924", "node_id": "C_kwDOAAsO6NoAKDFhNTBmOTA0ZWZmZDc4MGQ5M2NhOGI3MWY5MmViMGU3Yjc2NDM5MjQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-26T12:38:58Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-26T12:55:03Z"}, "message": "Reject recursive calls in inline_call", "tree": {"sha": "eeaa01eb8b8f32931cf19082788bd94509eb8ce0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeaa01eb8b8f32931cf19082788bd94509eb8ce0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a50f904effd780d93ca8b71f92eb0e7b7643924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a50f904effd780d93ca8b71f92eb0e7b7643924", "html_url": "https://github.com/rust-lang/rust/commit/1a50f904effd780d93ca8b71f92eb0e7b7643924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a50f904effd780d93ca8b71f92eb0e7b7643924/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514", "html_url": "https://github.com/rust-lang/rust/commit/1ccb21a0ca935bec27e6bda95f3c48c4eabcd514"}], "stats": {"total": 88, "additions": 67, "deletions": 21}, "files": [{"sha": "42a2ca23f7a200f495eedf481be8c31f78c16890", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1a50f904effd780d93ca8b71f92eb0e7b7643924/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a50f904effd780d93ca8b71f92eb0e7b7643924/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=1a50f904effd780d93ca8b71f92eb0e7b7643924", "patch": "@@ -1,7 +1,10 @@\n use ast::make;\n use hir::{db::HirDatabase, HasSource, PathResolution, Semantics, TypeInfo};\n use ide_db::{\n-    base_db::FileId, defs::Definition, path_transform::PathTransform, search::FileReference,\n+    base_db::{FileId, FileRange},\n+    defs::Definition,\n+    path_transform::PathTransform,\n+    search::{FileReference, SearchScope},\n     RootDatabase,\n };\n use itertools::izip;\n@@ -54,31 +57,43 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let def_file = ctx.frange.file_id;\n     let name = ctx.find_node_at_offset::<ast::Name>()?;\n-    let func_syn = name.syntax().parent().and_then(ast::Fn::cast)?;\n-    let func_body = func_syn.body()?;\n-    let param_list = func_syn.param_list()?;\n-    let function = ctx.sema.to_def(&func_syn)?;\n+    let ast_func = name.syntax().parent().and_then(ast::Fn::cast)?;\n+    let func_body = ast_func.body()?;\n+    let param_list = ast_func.param_list()?;\n+\n+    let function = ctx.sema.to_def(&ast_func)?;\n+\n     let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n \n     let usages = Definition::ModuleDef(hir::ModuleDef::Function(function)).usages(&ctx.sema);\n     if !usages.at_least_one() {\n         return None;\n     }\n \n+    let is_recursive_fn = usages\n+        .clone()\n+        .in_scope(SearchScope::file_range(FileRange {\n+            file_id: def_file,\n+            range: func_body.syntax().text_range(),\n+        }))\n+        .at_least_one();\n+    if is_recursive_fn {\n+        cov_mark::hit!(inline_into_callers_recursive);\n+        return None;\n+    }\n+\n     acc.add(\n         AssistId(\"inline_into_callers\", AssistKind::RefactorInline),\n         \"Inline into all callers\",\n         name.syntax().text_range(),\n         |builder| {\n-            let def_file = ctx.frange.file_id;\n-            let usages =\n-                Definition::ModuleDef(hir::ModuleDef::Function(function)).usages(&ctx.sema);\n             let mut usages = usages.all();\n             let current_file_usage = usages.references.remove(&def_file);\n \n-            let mut can_remove = true;\n-            let mut inline_refs = |file_id, refs: Vec<FileReference>| {\n+            let mut remove_def = true;\n+            let mut inline_refs_for_file = |file_id, refs: Vec<FileReference>| {\n                 builder.edit_file(file_id);\n                 let count = refs.len();\n                 let name_refs = refs.into_iter().filter_map(|file_ref| match file_ref.name {\n@@ -124,18 +139,18 @@ pub(crate) fn inline_into_callers(acc: &mut Assists, ctx: &AssistContext) -> Opt\n                         );\n                     })\n                     .count();\n-                can_remove &= replaced == count;\n+                remove_def &= replaced == count;\n             };\n             for (file_id, refs) in usages.into_iter() {\n-                inline_refs(file_id, refs);\n+                inline_refs_for_file(file_id, refs);\n             }\n             if let Some(refs) = current_file_usage {\n-                inline_refs(def_file, refs);\n+                inline_refs_for_file(def_file, refs);\n             } else {\n                 builder.edit_file(def_file);\n             }\n-            if can_remove {\n-                builder.delete(func_syn.syntax().text_range());\n+            if remove_def {\n+                builder.delete(ast_func.syntax().text_range());\n             }\n         },\n     )\n@@ -201,10 +216,15 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             )\n         };\n \n-    let hir::InFile { value: function_source, file_id } = function.source(ctx.db())?;\n-    let fn_body = function_source.body()?;\n-    let param_list = function_source.param_list()?;\n+    let fn_source = function.source(ctx.db())?;\n+    let fn_body = fn_source.value.body()?;\n+    let param_list = fn_source.value.param_list()?;\n \n+    let FileRange { file_id, range } = fn_source.syntax().original_file_range(ctx.sema.db);\n+    if file_id == ctx.frange.file_id && range.contains(ctx.frange.range.start()) {\n+        cov_mark::hit!(inline_call_recursive);\n+        return None;\n+    }\n     let params = get_fn_params(ctx.sema.db, function, &param_list)?;\n \n     if call_info.arguments.len() != params.len() {\n@@ -220,7 +240,6 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         label,\n         syntax.text_range(),\n         |builder| {\n-            let file_id = file_id.original_file(ctx.sema.db);\n             let replacement = inline(&ctx.sema, file_id, function, &fn_body, &params, &call_info);\n \n             builder.replace_ast(\n@@ -967,6 +986,32 @@ fn foo() {\n         foo * 0 + foo\n     };\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_callers_recursive() {\n+        cov_mark::check!(inline_into_callers_recursive);\n+        check_assist_not_applicable(\n+            inline_into_callers,\n+            r#\"\n+fn foo$0() {\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_call_recursive() {\n+        cov_mark::check!(inline_call_recursive);\n+        check_assist_not_applicable(\n+            inline_call,\n+            r#\"\n+fn foo() {\n+    foo$0();\n+}\n \"#,\n         );\n     }"}, {"sha": "00acfde243e2dac9e060d58027c47f490ea1b75e", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a50f904effd780d93ca8b71f92eb0e7b7643924/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a50f904effd780d93ca8b71f92eb0e7b7643924/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=1a50f904effd780d93ca8b71f92eb0e7b7643924", "patch": "@@ -315,6 +315,7 @@ impl Definition {\n     }\n }\n \n+#[derive(Clone)]\n pub struct FindUsages<'a> {\n     def: Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n@@ -341,7 +342,7 @@ impl<'a> FindUsages<'a> {\n         self\n     }\n \n-    pub fn at_least_one(self) -> bool {\n+    pub fn at_least_one(&self) -> bool {\n         let mut found = false;\n         self.search(&mut |_, _| {\n             found = true;\n@@ -359,7 +360,7 @@ impl<'a> FindUsages<'a> {\n         res\n     }\n \n-    fn search(self, sink: &mut dyn FnMut(FileId, FileReference) -> bool) {\n+    fn search(&self, sink: &mut dyn FnMut(FileId, FileReference) -> bool) {\n         let _p = profile::span(\"FindUsages:search\");\n         let sema = self.sema;\n "}]}