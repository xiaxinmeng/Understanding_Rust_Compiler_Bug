{"sha": "6872377357dbbf373cfd2aae352cb74cfcc66f34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NzIzNzczNTdkYmJmMzczY2ZkMmFhZTM1MmNiNzRjZmNjNjZmMzQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-17T06:37:11Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-17T10:41:38Z"}, "message": "Change `TokenTreeOrTokenTreeVec` to `TokenTreeOrTokenTreeSlice`.\n\nThis avoids a `to_owned` call that can be hot, speeding up the various\nruns of html5ever by 1--5%, and some runs of crates.io by 2--3%.", "tree": {"sha": "fedbc184d8155d43518d501049652d89d6fb661d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fedbc184d8155d43518d501049652d89d6fb661d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6872377357dbbf373cfd2aae352cb74cfcc66f34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6872377357dbbf373cfd2aae352cb74cfcc66f34", "html_url": "https://github.com/rust-lang/rust/commit/6872377357dbbf373cfd2aae352cb74cfcc66f34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6872377357dbbf373cfd2aae352cb74cfcc66f34/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc409ed0938cd2f501642abcaa675977fa5035a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc409ed0938cd2f501642abcaa675977fa5035a", "html_url": "https://github.com/rust-lang/rust/commit/6fc409ed0938cd2f501642abcaa675977fa5035a"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "7e6da37f722ee19e33f5d33d652d5f5926d390f8", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6872377357dbbf373cfd2aae352cb74cfcc66f34/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6872377357dbbf373cfd2aae352cb74cfcc66f34/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6872377357dbbf373cfd2aae352cb74cfcc66f34", "patch": "@@ -82,7 +82,7 @@\n \n pub use self::NamedMatch::*;\n pub use self::ParseResult::*;\n-use self::TokenTreeOrTokenTreeVec::*;\n+use self::TokenTreeOrTokenTreeSlice::*;\n \n use ast::Ident;\n use syntax_pos::{self, BytePos, Span};\n@@ -106,12 +106,12 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n /// Either a sequence of token trees or a single one. This is used as the representation of the\n /// sequence of tokens that make up a matcher.\n #[derive(Clone)]\n-enum TokenTreeOrTokenTreeVec {\n+enum TokenTreeOrTokenTreeSlice<'a> {\n     Tt(TokenTree),\n-    TtSeq(Vec<TokenTree>),\n+    TtSeq(&'a [TokenTree]),\n }\n \n-impl TokenTreeOrTokenTreeVec {\n+impl<'a> TokenTreeOrTokenTreeSlice<'a> {\n     /// Returns the number of constituent top-level token trees of `self` (top-level in that it\n     /// will not recursively descend into subtrees).\n     fn len(&self) -> usize {\n@@ -135,19 +135,19 @@ impl TokenTreeOrTokenTreeVec {\n /// This is used by `inner_parse_loop` to keep track of delimited submatchers that we have\n /// descended into.\n #[derive(Clone)]\n-struct MatcherTtFrame {\n+struct MatcherTtFrame<'a> {\n     /// The \"parent\" matcher that we are descending into.\n-    elts: TokenTreeOrTokenTreeVec,\n+    elts: TokenTreeOrTokenTreeSlice<'a>,\n     /// The position of the \"dot\" in `elts` at the time we descended.\n     idx: usize,\n }\n \n /// Represents a single \"position\" (aka \"matcher position\", aka \"item\"), as described in the module\n /// documentation.\n #[derive(Clone)]\n-struct MatcherPos {\n+struct MatcherPos<'a> {\n     /// The token or sequence of tokens that make up the matcher\n-    top_elts: TokenTreeOrTokenTreeVec,\n+    top_elts: TokenTreeOrTokenTreeSlice<'a>,\n     /// The position of the \"dot\" in this matcher\n     idx: usize,\n     /// The beginning position in the source that the beginning of this matcher corresponds to. In\n@@ -186,7 +186,7 @@ struct MatcherPos {\n     sep: Option<Token>,\n     /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n     /// before we enter the sequence.\n-    up: Option<Box<MatcherPos>>,\n+    up: Option<Box<MatcherPos<'a>>>,\n \n     // Specifically used to \"unzip\" token trees. By \"unzip\", we mean to unwrap the delimiters from\n     // a delimited token tree (e.g. something wrapped in `(` `)`) or to get the contents of a doc\n@@ -195,10 +195,10 @@ struct MatcherPos {\n     /// pat ) pat`), we need to keep track of the matchers we are descending into. This stack does\n     /// that where the bottom of the stack is the outermost matcher.\n     // Also, throughout the comments, this \"descent\" is often referred to as \"unzipping\"...\n-    stack: Vec<MatcherTtFrame>,\n+    stack: Vec<MatcherTtFrame<'a>>,\n }\n \n-impl MatcherPos {\n+impl<'a> MatcherPos<'a> {\n     /// Add `m` as a named match for the `idx`-th metavar.\n     fn push_match(&mut self, idx: usize, m: NamedMatch) {\n         let matches = Rc::make_mut(&mut self.matches[idx]);\n@@ -241,8 +241,8 @@ fn create_matches(len: usize) -> Vec<Rc<Vec<NamedMatch>>> {\n \n /// Generate the top-level matcher position in which the \"dot\" is before the first token of the\n /// matcher `ms` and we are going to start matching at position `lo` in the source.\n-fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> {\n-    let match_idx_hi = count_names(&ms[..]);\n+fn initial_matcher_pos(ms: &[TokenTree], lo: BytePos) -> Box<MatcherPos> {\n+    let match_idx_hi = count_names(ms);\n     let matches = create_matches(match_idx_hi);\n     Box::new(MatcherPos {\n         // Start with the top level matcher given to us\n@@ -394,12 +394,12 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n /// # Returns\n ///\n /// A `ParseResult`. Note that matches are kept track of through the items generated.\n-fn inner_parse_loop(\n+fn inner_parse_loop<'a>(\n     sess: &ParseSess,\n-    cur_items: &mut SmallVector<Box<MatcherPos>>,\n-    next_items: &mut Vec<Box<MatcherPos>>,\n-    eof_items: &mut SmallVector<Box<MatcherPos>>,\n-    bb_items: &mut SmallVector<Box<MatcherPos>>,\n+    cur_items: &mut SmallVector<Box<MatcherPos<'a>>>,\n+    next_items: &mut Vec<Box<MatcherPos<'a>>>,\n+    eof_items: &mut SmallVector<Box<MatcherPos<'a>>>,\n+    bb_items: &mut SmallVector<Box<MatcherPos<'a>>>,\n     token: &Token,\n     span: syntax_pos::Span,\n ) -> ParseResult<()> {\n@@ -596,7 +596,7 @@ pub fn parse(\n     // processes all of these possible matcher positions and produces posible next positions into\n     // `next_items`. After some post-processing, the contents of `next_items` replenish `cur_items`\n     // and we start over again.\n-    let mut cur_items = SmallVector::one(initial_matcher_pos(ms.to_owned(), parser.span.lo()));\n+    let mut cur_items = SmallVector::one(initial_matcher_pos(ms, parser.span.lo()));\n     let mut next_items = Vec::new();\n \n     loop {"}]}