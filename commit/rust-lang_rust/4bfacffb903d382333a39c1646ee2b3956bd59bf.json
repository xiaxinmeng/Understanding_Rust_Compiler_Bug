{"sha": "4bfacffb903d382333a39c1646ee2b3956bd59bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZmFjZmZiOTAzZDM4MjMzM2EzOWMxNjQ2ZWUyYjM5NTZiZDU5YmY=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2020-08-20T00:38:00Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2020-08-20T02:06:00Z"}, "message": "Optimise align_offset for stride=1 further\n\n`stride == 1` case can be computed more efficiently through `-p (mod\na)`. That, then translates to a nice and short sequence of LLVM\ninstructions:\n\n    %address = ptrtoint i8* %p to i64\n    %negptr = sub i64 0, %address\n    %offset = and i64 %negptr, %a_minus_one\n\nAnd produces pretty much ideal code-gen when this function is used in\nisolation.\n\nTypical use of this function will, however, involve use of\nthe result to offset a pointer, i.e.\n\n    %aligned = getelementptr inbounds i8, i8* %p, i64 %offset\n\nThis still looks very good, but LLVM does not really translate that to\nwhat would be considered ideal machine code (on any target). For example\nthat's the codegen we obtain for an unknown alignment:\n\n    ; x86_64\n    dec     rsi\n    mov     rax, rdi\n    neg     rax\n    and     rax, rsi\n    add     rax, rdi\n\nIn particular negating a pointer is not something that\u2019s going to be\noptimised for in the design of CISC architectures like x86_64. They\nare much better at offsetting pointers. And so we\u2019d love to utilize this\nability and produce code that's more like this:\n\n    ; x86_64\n    lea     rax, [rsi + rdi - 1]\n    neg     rsi\n    and     rax, rsi\n\nTo achieve this we need to give LLVM an opportunity to apply its\nvarious peep-hole optimisations that it does during DAG selection. In\nparticular, the `and` instruction appears to be a major inhibitor here.\nWe cannot, sadly, get rid of this load-bearing operation, but we can\nreorder operations such that LLVM has more to work with around this\ninstruction.\n\nOne such ordering is proposed in #75579 and results in LLVM IR that\nlooks broadly like this:\n\n    ; using add enables `lea` and similar CISCisms\n    %offset_ptr = add i64 %address, %a_minus_one\n    %mask = sub i64 0, %a\n    %masked = and i64 %offset_ptr, %mask\n    ; can be folded with `gepi` that may follow\n    %offset = sub i64 %masked, %address\n\n\u2026and generates the intended x86_64 machine code. One might also wonder\nhow the increased amount of code would impact a RISC target. Turns out\nnot much:\n\n    ; aarch64 previous                 ; aarch64 new\n    sub     x8, x1, #1                 add     x8, x1, x0\n    neg     x9, x0                     sub     x8, x8, #1\n    and     x8, x9, x8                 neg     x9, x1\n    add     x0, x0, x8                 and     x0, x8, x9\n\n    (and similarly for ppc, sparc, mips, riscv, etc)\n\nThe only target that seems to do worse is\u2026 wasm32.\n\nOnto actual measurements \u2013 the best way to evaluate snippets like these\nis to use llvm-mca. Much like Aarch64 assembly would allow to suspect,\nthere isn\u2019t any performance difference to be found. Both snippets\nexecute in same number of cycles for the CPUs I tried. On x86_64,\nwe get throughput improvement of >50%, however!", "tree": {"sha": "3084b81a34d78238e8c2743504b79bfa79554b4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3084b81a34d78238e8c2743504b79bfa79554b4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bfacffb903d382333a39c1646ee2b3956bd59bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bfacffb903d382333a39c1646ee2b3956bd59bf", "html_url": "https://github.com/rust-lang/rust/commit/4bfacffb903d382333a39c1646ee2b3956bd59bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bfacffb903d382333a39c1646ee2b3956bd59bf/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d22b18bf28a54586008e9d8d4bfd72012c00e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d22b18bf28a54586008e9d8d4bfd72012c00e2e", "html_url": "https://github.com/rust-lang/rust/commit/5d22b18bf28a54586008e9d8d4bfd72012c00e2e"}], "stats": {"total": 17, "additions": 14, "deletions": 3}, "files": [{"sha": "6f0e1e6a7b32252b42ae8491bd70059457eff9f1", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4bfacffb903d382333a39c1646ee2b3956bd59bf/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfacffb903d382333a39c1646ee2b3956bd59bf/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=4bfacffb903d382333a39c1646ee2b3956bd59bf", "patch": "@@ -1168,7 +1168,9 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n-    use intrinsics::{unchecked_shl, unchecked_shr, unchecked_sub, wrapping_mul, wrapping_sub};\n+    use intrinsics::{\n+        unchecked_shl, unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n+    };\n \n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n@@ -1223,8 +1225,17 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // SAFETY: `a` is a power-of-two, therefore non-zero.\n     let a_minus_one = unsafe { unchecked_sub(a, 1) };\n     if stride == 1 {\n-        // `stride == 1` case can be computed more efficiently through `-p (mod a)`.\n-        return wrapping_sub(0, p as usize) & a_minus_one;\n+        // `stride == 1` case can be computed more simply through `-p (mod a)`, but doing so\n+        // inhibits LLVM's ability to select instructions like `lea`. Instead we compute\n+        //\n+        //    round_up_to_next_alignment(p, a) - p\n+        //\n+        // which distributes operations around the load-bearing, but pessimizing `and` sufficiently\n+        // for LLVM to be able to utilize the various optimizations it knows about.\n+        return wrapping_sub(\n+            wrapping_add(p as usize, a_minus_one) & wrapping_sub(0, a),\n+            p as usize,\n+        );\n     }\n \n     let pmoda = p as usize & a_minus_one;"}]}