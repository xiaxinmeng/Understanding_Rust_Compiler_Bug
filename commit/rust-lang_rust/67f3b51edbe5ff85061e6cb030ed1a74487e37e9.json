{"sha": "67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "node_id": "C_kwDOAAsO6NoAKDY3ZjNiNTFlZGJlNWZmODUwNjFlNmNiMDMwZWQxYTc0NDg3ZTM3ZTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-04T17:30:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-04T17:30:43Z"}, "message": "Merge #11189\n\n11189: internal: Remove lossy `Definition::from_token`/`Definition::from_node` methods r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/11129\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "f019d16de12e16982b8730fdd8415a723487965a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f019d16de12e16982b8730fdd8415a723487965a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1IRDCRBK7hj4Ov3rIwAAvHIIAB1ryOu3O8LVNbFLx3QXX33B\naQgxwW0uvi3VDHsAXeyMELXxqVYnBYEFWer2ibdSVAAEtyM7n4ELfbzil6CFHhur\nCJnd65WKrNDKz4haLbtyCM6ngMAgWqSLvSaq2qd88FVHVTue/Yuy1deYpWWStedB\n135spQIcMtVQ6UAHwFpy/micvt65svNaxYTdlgu91bBLVt0Za9O5rDExk+2xBLbw\n76Kke6Jnfgq/hzxguJYcT1QP775qTPRd02sB+LotvKo8Q8fsmFePhAdI1lMDTjOV\nzoaJyBjjnNNU/M6FU+pgw0xptao32cPPtA8YSa/gUddB2cLaEP+yZraP5jByKhg=\n=X0Gv\n-----END PGP SIGNATURE-----\n", "payload": "tree f019d16de12e16982b8730fdd8415a723487965a\nparent 68bc12c3b80b0dce655c8602e683b1989640f00b\nparent c5a9985fc52324fdd70715e4ed748dea573facd6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641317443 +0000\ncommitter GitHub <noreply@github.com> 1641317443 +0000\n\nMerge #11189\n\n11189: internal: Remove lossy `Definition::from_token`/`Definition::from_node` methods r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/11129\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "html_url": "https://github.com/rust-lang/rust/commit/67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68bc12c3b80b0dce655c8602e683b1989640f00b", "url": "https://api.github.com/repos/rust-lang/rust/commits/68bc12c3b80b0dce655c8602e683b1989640f00b", "html_url": "https://github.com/rust-lang/rust/commit/68bc12c3b80b0dce655c8602e683b1989640f00b"}, {"sha": "c5a9985fc52324fdd70715e4ed748dea573facd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a9985fc52324fdd70715e4ed748dea573facd6", "html_url": "https://github.com/rust-lang/rust/commit/c5a9985fc52324fdd70715e4ed748dea573facd6"}], "stats": {"total": 183, "additions": 91, "deletions": 92}, "files": [{"sha": "29fc1fd2e03bd2b9ecdea234ff949a9578bec4d0", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "patch": "@@ -4,7 +4,7 @@ use crate::{doc_links::token_as_doc_comment, FilePosition, NavigationTarget, Ran\n use hir::{AsAssocItem, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n-    defs::Definition,\n+    defs::{Definition, IdentClass},\n     helpers::pick_best_token,\n     RootDatabase,\n };\n@@ -46,20 +46,20 @@ pub(crate) fn goto_definition(\n         .filter_map(|token| {\n             let parent = token.parent()?;\n             if let Some(tt) = ast::TokenTree::cast(parent) {\n-                if let x @ Some(_) =\n-                    try_lookup_include_path(sema, tt, token.clone(), position.file_id)\n+                if let Some(x) = try_lookup_include_path(sema, tt, token.clone(), position.file_id)\n                 {\n-                    return x;\n+                    return Some(vec![x]);\n                 }\n             }\n             Some(\n-                Definition::from_token(sema, &token)\n+                IdentClass::classify_token(sema, &token)?\n+                    .definitions()\n                     .into_iter()\n                     .flat_map(|def| {\n                         try_find_trait_item_definition(sema.db, &def)\n                             .unwrap_or_else(|| def_to_nav(sema.db, def))\n                     })\n-                    .collect::<Vec<_>>(),\n+                    .collect(),\n             )\n         })\n         .flatten()\n@@ -74,7 +74,7 @@ fn try_lookup_include_path(\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n-) -> Option<Vec<NavigationTarget>> {\n+) -> Option<NavigationTarget> {\n     let token = ast::String::cast(token)?;\n     let path = token.value()?.into_owned();\n     let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n@@ -84,7 +84,7 @@ fn try_lookup_include_path(\n     }\n     let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n     let size = sema.db.file_text(file_id).len().try_into().ok()?;\n-    Some(vec![NavigationTarget {\n+    Some(NavigationTarget {\n         file_id,\n         full_range: TextRange::new(0.into(), size),\n         name: path.into(),\n@@ -93,7 +93,7 @@ fn try_lookup_include_path(\n         container_name: None,\n         description: None,\n         docs: None,\n-    }])\n+    })\n }\n \n /// finds the trait definition of an impl'd item"}, {"sha": "b6d9e4021d9b8132e9403e0d5db993b0000d3fbf", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "patch": "@@ -1,7 +1,7 @@\n use hir::Semantics;\n use ide_db::{\n     base_db::{FileId, FilePosition},\n-    defs::Definition,\n+    defs::{Definition, IdentClass},\n     helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n     search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n@@ -293,7 +293,8 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n fn find_defs(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n     sema.descend_into_macros(token)\n         .into_iter()\n-        .flat_map(|token| Definition::from_token(sema, &token))\n+        .filter_map(|token| IdentClass::classify_token(sema, &token).map(IdentClass::definitions))\n+        .flatten()\n         .collect()\n }\n "}, {"sha": "21bea25a5f77ae7b629ba3f09c12ac558af726c5", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "patch": "@@ -9,7 +9,7 @@ use either::Either;\n use hir::{HasSource, Semantics};\n use ide_db::{\n     base_db::FileRange,\n-    defs::Definition,\n+    defs::{Definition, IdentClass},\n     helpers::{pick_best_token, FamousDefs},\n     FxIndexSet, RootDatabase,\n };\n@@ -129,8 +129,8 @@ pub(crate) fn hover(\n         .iter()\n         .filter_map(|token| {\n             let node = token.parent()?;\n-            let defs = Definition::from_token(sema, token);\n-            Some(defs.into_iter().zip(iter::once(node).cycle()))\n+            let class = IdentClass::classify_token(sema, token)?;\n+            Some(class.definitions().into_iter().zip(iter::once(node).cycle()))\n         })\n         .flatten()\n         .unique_by(|&(def, _)| def)"}, {"sha": "53f6d7ec7ad8bdd7aebbc508fa1e9de40d0b0c0d", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "patch": "@@ -4,7 +4,7 @@\n use hir::{db::DefDatabase, AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n use ide_db::{\n     base_db::{CrateOrigin, FileId, FileLoader, FilePosition},\n-    defs::Definition,\n+    defs::{Definition, IdentClass},\n     helpers::pick_best_token,\n     RootDatabase,\n };\n@@ -82,11 +82,10 @@ pub(crate) fn moniker(\n     let navs = sema\n         .descend_into_macros(original_token.clone())\n         .into_iter()\n-        .map(|token| {\n-            Definition::from_token(sema, &token)\n-                .into_iter()\n-                .flat_map(|def| def_to_moniker(sema.db, def, current_crate))\n-                .collect::<Vec<_>>()\n+        .filter_map(|token| {\n+            IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+                it.into_iter().flat_map(|def| def_to_moniker(sema.db, def, current_crate))\n+            })\n         })\n         .flatten()\n         .unique()"}, {"sha": "d5bfbd18941c3c8395940567d0391d8945568b22", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "patch": "@@ -6,7 +6,7 @@ use std::collections::HashMap;\n use hir::{db::HirDatabase, Crate, Module, Semantics};\n use ide_db::{\n     base_db::{FileId, FileRange, SourceDatabaseExt},\n-    defs::Definition,\n+    defs::{Definition, IdentClass},\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n@@ -195,9 +195,9 @@ impl StaticIndex<'_> {\n \n fn get_definition(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Definition> {\n     for token in sema.descend_into_macros(token) {\n-        let def = Definition::from_token(sema, &token);\n-        if let [x] = def.as_slice() {\n-            return Some(*x);\n+        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions);\n+        if let Some(&[x]) = def.as_deref() {\n+            return Some(x);\n         } else {\n             continue;\n         };"}, {"sha": "172acdbc3c402a53779a5acef58a174ccfc1a3ce", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 67, "deletions": 68, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f3b51edbe5ff85061e6cb030ed1a74487e37e9/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=67f3b51edbe5ff85061e6cb030ed1a74487e37e9", "patch": "@@ -42,74 +42,6 @@ pub enum Definition {\n }\n \n impl Definition {\n-    pub fn from_token(\n-        sema: &Semantics<RootDatabase>,\n-        token: &SyntaxToken,\n-    ) -> ArrayVec<Definition, 2> {\n-        let parent = match token.parent() {\n-            Some(parent) => parent,\n-            None => return Default::default(),\n-        };\n-        // resolve derives if possible\n-        if let Some(ident) = ast::Ident::cast(token.clone()) {\n-            let attr = ast::TokenTree::cast(parent.clone())\n-                .and_then(|tt| tt.parent_meta())\n-                .and_then(|meta| meta.parent_attr());\n-            if let Some(attr) = attr {\n-                return sema\n-                    .resolve_derive_ident(&attr, &ident)\n-                    .map(Into::into)\n-                    .into_iter()\n-                    .collect();\n-            }\n-        }\n-        Self::from_node(sema, &parent)\n-    }\n-\n-    pub fn from_node(sema: &Semantics<RootDatabase>, node: &SyntaxNode) -> ArrayVec<Definition, 2> {\n-        let mut res = ArrayVec::new();\n-        (|| {\n-            match_ast! {\n-                match node {\n-                    ast::Name(name) => {\n-                        match NameClass::classify(&sema, &name)? {\n-                            NameClass::Definition(it) | NameClass::ConstReference(it) => res.push(it),\n-                            NameClass::PatFieldShorthand { local_def, field_ref } => {\n-                                res.push(Definition::Local(local_def));\n-                                res.push(Definition::Field(field_ref));\n-                            }\n-                        }\n-                    },\n-                    ast::NameRef(name_ref) => {\n-                        match NameRefClass::classify(sema, &name_ref)? {\n-                            NameRefClass::Definition(it) => res.push(it),\n-                            NameRefClass::FieldShorthand { local_ref, field_ref } => {\n-                                res.push(Definition::Local(local_ref));\n-                                res.push(Definition::Field(field_ref));\n-                            }\n-                        }\n-                    },\n-                    ast::Lifetime(lifetime) => {\n-                        let def = if let Some(x) = NameClass::classify_lifetime(&sema, &lifetime) {\n-                            NameClass::defined(x)\n-                        } else {\n-                            NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n-                                NameRefClass::Definition(it) => Some(it),\n-                                _ => None,\n-                            })\n-                        };\n-                        if let Some(def) = def {\n-                            res.push(def);\n-                        }\n-                    },\n-                    _ => (),\n-                }\n-            }\n-            Some(())\n-        })();\n-        res\n-    }\n-\n     pub fn canonical_module_path(&self, db: &RootDatabase) -> Option<impl Iterator<Item = Module>> {\n         self.module(db).map(|it| it.path_to_root(db).into_iter().rev())\n     }\n@@ -184,6 +116,65 @@ impl Definition {\n     }\n }\n \n+pub enum IdentClass {\n+    NameClass(NameClass),\n+    NameRefClass(NameRefClass),\n+}\n+\n+impl IdentClass {\n+    pub fn classify_node(sema: &Semantics<RootDatabase>, node: &SyntaxNode) -> Option<IdentClass> {\n+        match_ast! {\n+            match node {\n+                ast::Name(name) => NameClass::classify(sema, &name).map(IdentClass::NameClass),\n+                ast::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref).map(IdentClass::NameRefClass),\n+                ast::Lifetime(lifetime) => {\n+                    NameClass::classify_lifetime(sema, &lifetime)\n+                        .map(IdentClass::NameClass)\n+                        .or_else(|| NameRefClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameRefClass))\n+                },\n+                _ => None,\n+            }\n+        }\n+    }\n+\n+    pub fn classify_token(\n+        sema: &Semantics<RootDatabase>,\n+        token: &SyntaxToken,\n+    ) -> Option<IdentClass> {\n+        let parent = token.parent()?;\n+        // resolve derives if possible\n+        if let Some(ident) = ast::Ident::cast(token.clone()) {\n+            let attr = ast::TokenTree::cast(parent.clone())\n+                .and_then(|tt| tt.parent_meta())\n+                .and_then(|meta| meta.parent_attr());\n+            if let Some(attr) = attr {\n+                return NameRefClass::classify_derive(sema, &attr, &ident)\n+                    .map(IdentClass::NameRefClass);\n+            }\n+        }\n+        Self::classify_node(sema, &parent)\n+    }\n+\n+    pub fn definitions(self) -> ArrayVec<Definition, 2> {\n+        let mut res = ArrayVec::new();\n+        match self {\n+            IdentClass::NameClass(NameClass::Definition(it) | NameClass::ConstReference(it)) => {\n+                res.push(it)\n+            }\n+            IdentClass::NameClass(NameClass::PatFieldShorthand { local_def, field_ref }) => {\n+                res.push(Definition::Local(local_def));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::NameRefClass(NameRefClass::Definition(it)) => res.push(it),\n+            IdentClass::NameRefClass(NameRefClass::FieldShorthand { local_ref, field_ref }) => {\n+                res.push(Definition::Local(local_ref));\n+                res.push(Definition::Field(field_ref));\n+            }\n+        }\n+        res\n+    }\n+}\n+\n /// On a first blush, a single `ast::Name` defines a single definition at some\n /// scope. That is, that, by just looking at the syntactical category, we can\n /// unambiguously define the semantic category.\n@@ -465,6 +456,14 @@ impl NameRefClass {\n             _ => None,\n         }\n     }\n+\n+    pub fn classify_derive(\n+        sema: &Semantics<RootDatabase>,\n+        attr: &ast::Attr,\n+        ident: &ast::Ident,\n+    ) -> Option<NameRefClass> {\n+        sema.resolve_derive_ident(&attr, &ident).map(Definition::from).map(NameRefClass::Definition)\n+    }\n }\n \n impl_from!("}]}