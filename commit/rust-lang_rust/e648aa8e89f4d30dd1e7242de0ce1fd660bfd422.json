{"sha": "e648aa8e89f4d30dd1e7242de0ce1fd660bfd422", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NDhhYThlODlmNGQzMGRkMWU3MjQyZGUwY2UxZmQ2NjBiZmQ0MjI=", "commit": {"author": {"name": "Samuel Holland", "email": "samuel@sholland.org", "date": "2019-09-05T01:40:18Z"}, "committer": {"name": "Samuel Holland", "email": "samuel@sholland.org", "date": "2019-11-06T02:23:58Z"}, "message": "Fix C aggregate-passing ABI on powerpc\n\nThe existing code (which looks like it was copied from MIPS) passes\naggregates by value in registers. This is wrong. According to the SVR4\npowerpc psABI, all aggregates are passed indirectly.\n\nSee #64259 for more discussion, which addresses the ABI for the special\ncase of ZSTs (empty structs).", "tree": {"sha": "797ed9c1638a7c31e51019506a06e25e5b98d6a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/797ed9c1638a7c31e51019506a06e25e5b98d6a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422", "html_url": "https://github.com/rust-lang/rust/commit/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422/comments", "author": {"login": "smaeul", "id": 5846453, "node_id": "MDQ6VXNlcjU4NDY0NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5846453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smaeul", "html_url": "https://github.com/smaeul", "followers_url": "https://api.github.com/users/smaeul/followers", "following_url": "https://api.github.com/users/smaeul/following{/other_user}", "gists_url": "https://api.github.com/users/smaeul/gists{/gist_id}", "starred_url": "https://api.github.com/users/smaeul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smaeul/subscriptions", "organizations_url": "https://api.github.com/users/smaeul/orgs", "repos_url": "https://api.github.com/users/smaeul/repos", "events_url": "https://api.github.com/users/smaeul/events{/privacy}", "received_events_url": "https://api.github.com/users/smaeul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smaeul", "id": 5846453, "node_id": "MDQ6VXNlcjU4NDY0NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5846453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smaeul", "html_url": "https://github.com/smaeul", "followers_url": "https://api.github.com/users/smaeul/followers", "following_url": "https://api.github.com/users/smaeul/following{/other_user}", "gists_url": "https://api.github.com/users/smaeul/gists{/gist_id}", "starred_url": "https://api.github.com/users/smaeul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smaeul/subscriptions", "organizations_url": "https://api.github.com/users/smaeul/orgs", "repos_url": "https://api.github.com/users/smaeul/repos", "events_url": "https://api.github.com/users/smaeul/events{/privacy}", "received_events_url": "https://api.github.com/users/smaeul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1423bec54cf2db283b614e527cfd602b481485d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1423bec54cf2db283b614e527cfd602b481485d1", "html_url": "https://github.com/rust-lang/rust/commit/1423bec54cf2db283b614e527cfd602b481485d1"}], "stats": {"total": 43, "additions": 11, "deletions": 32}, "files": [{"sha": "33335f462a7aeda8447b91eed74c59ad0ab15020", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=e648aa8e89f4d30dd1e7242de0ce1fd660bfd422", "patch": "@@ -554,7 +554,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),\n-            \"powerpc\" => powerpc::compute_abi_info(cx, self),\n+            \"powerpc\" => powerpc::compute_abi_info(self),\n             \"powerpc64\" => powerpc64::compute_abi_info(cx, self),\n             \"s390x\" => s390x::compute_abi_info(cx, self),\n             \"msp430\" => msp430::compute_abi_info(self),"}, {"sha": "740bd7222f237034bbcc7a6d6dbbd430a71b6980", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648aa8e89f4d30dd1e7242de0ce1fd660bfd422/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=e648aa8e89f4d30dd1e7242de0ce1fd660bfd422", "patch": "@@ -1,49 +1,28 @@\n-use crate::abi::call::{ArgAbi, FnAbi, Reg, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, Size, TyLayoutMethods};\n+use crate::abi::call::{ArgAbi, FnAbi};\n \n-fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(32);\n-    } else {\n+fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n+    if ret.layout.is_aggregate() {\n         ret.make_indirect();\n-        *offset += cx.data_layout().pointer_size;\n+    } else {\n+        ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'_, Ty>, offset: &mut Size)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    let dl = cx.data_layout();\n-    let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n-\n+fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform {\n-            unit: Reg::i32(),\n-            total: size\n-        });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with(Reg::i32());\n-        }\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-\n-    *offset = offset.align_to(align) + size.align_to(align);\n }\n \n-pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'_, Ty>)\n-    where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n-{\n-    let mut offset = Size::ZERO;\n+pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n     if !fn_abi.ret.is_ignore() {\n-        classify_ret(cx, &mut fn_abi.ret, &mut offset);\n+        classify_ret(&mut fn_abi.ret);\n     }\n \n     for arg in &mut fn_abi.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg(cx, arg, &mut offset);\n+        classify_arg(arg);\n     }\n }"}]}