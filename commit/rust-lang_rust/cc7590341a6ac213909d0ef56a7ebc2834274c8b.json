{"sha": "cc7590341a6ac213909d0ef56a7ebc2834274c8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNzU5MDM0MWE2YWMyMTM5MDlkMGVmNTZhN2ViYzI4MzQyNzRjOGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-11-03T18:15:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-11-11T17:22:28Z"}, "message": "std: Delete the `alloc_system` crate\n\nThis commit deletes the `alloc_system` crate from the standard\ndistribution. This unstable crate is no longer needed in the modern\nstable global allocator world, but rather its functionality is folded\ndirectly into the standard library. The standard library was already the\nonly stable location to access this crate, and as a result this should\nnot affect any stable code.", "tree": {"sha": "12aef157ad50b7c1161027a33f4a028e1628fabd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12aef157ad50b7c1161027a33f4a028e1628fabd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc7590341a6ac213909d0ef56a7ebc2834274c8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc7590341a6ac213909d0ef56a7ebc2834274c8b", "html_url": "https://github.com/rust-lang/rust/commit/cc7590341a6ac213909d0ef56a7ebc2834274c8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc7590341a6ac213909d0ef56a7ebc2834274c8b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3939322e3273059bdfedec52cb8d6f78476af7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3939322e3273059bdfedec52cb8d6f78476af7c", "html_url": "https://github.com/rust-lang/rust/commit/d3939322e3273059bdfedec52cb8d6f78476af7c"}], "stats": {"total": 958, "additions": 450, "deletions": 508}, "files": [{"sha": "32304c81182f16464301837615f71871247c279b", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -15,16 +15,6 @@ dependencies = [\n  \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins 0.0.0\",\n- \"core 0.0.0\",\n- \"dlmalloc 0.0.0\",\n- \"libc 0.0.0\",\n-]\n-\n [[package]]\n name = \"ammonia\"\n version = \"1.1.0\"\n@@ -2104,7 +2094,6 @@ name = \"rustc_asan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2276,7 +2265,6 @@ name = \"rustc_lsan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2328,7 +2316,6 @@ name = \"rustc_msan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2440,7 +2427,6 @@ name = \"rustc_tsan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2679,11 +2665,11 @@ name = \"std\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n+ \"dlmalloc 0.0.0\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\","}, {"sha": "0aab64465fd1c48ce6974392659cd60a1eca286a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -859,7 +859,6 @@ impl Step for Src {\n             \"src/build_helper\",\n             \"src/dlmalloc\",\n             \"src/liballoc\",\n-            \"src/liballoc_system\",\n             \"src/libbacktrace\",\n             \"src/libcompiler_builtins\",\n             \"src/libcore\","}, {"sha": "161f0c0062fa012d2685ef521403c960c50abae4", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\"}, {"sha": "bf256b23f9ac0eb459ad7a29a6be7eb6d239c64f", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc_system::System;\n-use std::alloc::{Global, Alloc, Layout};\n+use std::alloc::{Global, Alloc, Layout, System};\n \n /// https://github.com/rust-lang/rust/issues/45955\n #[test]"}, {"sha": "e514a8a69c020701ea4e42fb31425628901722e8", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![feature(allocator_api)]\n-#![feature(alloc_system)]\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n@@ -20,7 +19,6 @@\n #![feature(unboxed_closures)]\n #![feature(repeat_generic_slice)]\n \n-extern crate alloc_system;\n extern crate core;\n extern crate rand;\n "}, {"sha": "c34e2f203a8371267134c2cc1271fcb15e24f45f", "filename": "src/liballoc_system/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3939322e3273059bdfedec52cb8d6f78476af7c/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d3939322e3273059bdfedec52cb8d6f78476af7c/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=d3939322e3273059bdfedec52cb8d6f78476af7c", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"alloc_system\"\n-path = \"lib.rs\"\n-test = false\n-doc = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }\n-libc = { path = \"../rustc/libc_shim\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n-\n-# See comments in the source for what this dependency is\n-[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n-dlmalloc = { path = \"../rustc/dlmalloc_shim\" }"}, {"sha": "533eb23c193e148a916ce8c29ac1d7344c812878", "filename": "src/liballoc_system/lib.rs", "status": "removed", "additions": 0, "deletions": 410, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/d3939322e3273059bdfedec52cb8d6f78476af7c/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3939322e3273059bdfedec52cb8d6f78476af7c/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=d3939322e3273059bdfedec52cb8d6f78476af7c", "patch": "@@ -1,410 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![no_std]\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"alloc_system\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"32838\")]\n-\n-#![feature(allocator_api)]\n-#![feature(core_intrinsics)]\n-#![feature(nll)]\n-#![feature(staged_api)]\n-#![feature(rustc_attrs)]\n-#![cfg_attr(\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    feature(integer_atomics, stdsimd)\n-)]\n-#![cfg_attr(any(unix, target_os = \"cloudabi\", target_os = \"redox\"), feature(libc))]\n-\n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\")))]\n-#[allow(dead_code)]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n-#[allow(dead_code)]\n-const MIN_ALIGN: usize = 16;\n-\n-use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n-use core::ptr::NonNull;\n-\n-/// The default memory allocator provided by the operating system.\n-///\n-/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n-/// plus related functions.\n-///\n-/// This type can be used in a `static` item\n-/// with the `#[global_allocator]` attribute\n-/// to force the global allocator to be the system\u2019s one.\n-/// (The default is jemalloc for executables, on some platforms.)\n-///\n-/// ```rust\n-/// use std::alloc::System;\n-///\n-/// #[global_allocator]\n-/// static A: System = System;\n-///\n-/// fn main() {\n-///     let a = Box::new(4); // Allocates from the system allocator.\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// It can also be used directly to allocate memory\n-/// independently of the standard library\u2019s global allocator.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-pub struct System;\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl Alloc for System {\n-    #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&mut self,\n-                      ptr: NonNull<u8>,\n-                      layout: Layout,\n-                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n-    }\n-}\n-\n-#[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n-mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use core::cmp;\n-    use core::ptr;\n-\n-    impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n-                                              new_size: usize) -> *mut u8 {\n-            // Docs for GlobalAlloc::realloc require this to be valid:\n-            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n-\n-            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n-            if !new_ptr.is_null() {\n-                let size = cmp::min(old_layout.size(), new_size);\n-                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                GlobalAlloc::dealloc(self, ptr, old_layout);\n-            }\n-            new_ptr\n-        }\n-    }\n-}\n-\n-#[cfg(any(unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n-mod platform {\n-    extern crate libc;\n-\n-    use core::ptr;\n-\n-    use MIN_ALIGN;\n-    use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n-\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut u8\n-            } else {\n-                #[cfg(target_os = \"macos\")]\n-                {\n-                    if layout.align() > (1 << 31) {\n-                        return ptr::null_mut()\n-                    }\n-                }\n-                aligned_malloc(&layout)\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut u8\n-            } else {\n-                let ptr = self.alloc(layout.clone());\n-                if !ptr.is_null() {\n-                    ptr::write_bytes(ptr, 0, layout.size());\n-                }\n-                ptr\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-            libc::free(ptr as *mut libc::c_void)\n-        }\n-\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"android\",\n-              target_os = \"hermit\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\"))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        // On android we currently target API level 9 which unfortunately\n-        // doesn't have the `posix_memalign` API used below. Instead we use\n-        // `memalign`, but this unfortunately has the property on some systems\n-        // where the memory returned cannot be deallocated by `free`!\n-        //\n-        // Upon closer inspection, however, this appears to work just fine with\n-        // Android, so for this platform we should be fine to call `memalign`\n-        // (which is present in API level 9). Some helpful references could\n-        // possibly be chromium using memalign [1], attempts at documenting that\n-        // memalign + free is ok [2] [3], or the current source of chromium\n-        // which still uses memalign on android [4].\n-        //\n-        // [1]: https://codereview.chromium.org/10796020/\n-        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-        //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut u8\n-    }\n-\n-    #[cfg(not(any(target_os = \"android\",\n-                  target_os = \"hermit\",\n-                  target_os = \"redox\",\n-                  target_os = \"solaris\")))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        let mut out = ptr::null_mut();\n-        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-        if ret != 0 {\n-            ptr::null_mut()\n-        } else {\n-            out as *mut u8\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-#[allow(nonstandard_style)]\n-mod platform {\n-    use MIN_ALIGN;\n-    use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n-\n-    type LPVOID = *mut u8;\n-    type HANDLE = LPVOID;\n-    type SIZE_T = usize;\n-    type DWORD = u32;\n-    type BOOL = i32;\n-\n-    extern \"system\" {\n-        fn GetProcessHeap() -> HANDLE;\n-        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n-        fn GetLastError() -> DWORD;\n-    }\n-\n-    #[repr(C)]\n-    struct Header(*mut u8);\n-\n-    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n-\n-    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n-    }\n-\n-    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n-        *get_header(aligned) = Header(ptr);\n-        aligned\n-    }\n-\n-    #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n-        let ptr = if layout.align() <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), flags, layout.size())\n-        } else {\n-            let size = layout.size() + layout.align();\n-            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n-            if ptr.is_null() {\n-                ptr\n-            } else {\n-                align_ptr(ptr, layout.align())\n-            }\n-        };\n-        ptr as *mut u8\n-    }\n-\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            allocate_with_flags(layout, 0)\n-        }\n-\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n-        }\n-\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            if layout.align() <= MIN_ALIGN {\n-                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            } else {\n-                let header = get_header(ptr);\n-                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n-        }\n-    }\n-}\n-\n-// This is an implementation of a global allocator on the wasm32 platform when\n-// emscripten is not in use. In that situation there's no actual runtime for us\n-// to lean on for allocation, so instead we provide our own!\n-//\n-// The wasm32 instruction set has two instructions for getting the current\n-// amount of memory and growing the amount of memory. These instructions are the\n-// foundation on which we're able to build an allocator, so we do so! Note that\n-// the instructions are also pretty \"global\" and this is the \"global\" allocator\n-// after all!\n-//\n-// The current allocator here is the `dlmalloc` crate which we've got included\n-// in the rust-lang/rust repository as a submodule. The crate is a port of\n-// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n-// for now which is currently technically required (can't link with C yet).\n-//\n-// The crate itself provides a global allocator which on wasm has no\n-// synchronization as there are no threads!\n-#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n-mod platform {\n-    extern crate dlmalloc;\n-\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use System;\n-\n-    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n-\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.malloc(layout.size(), layout.align())\n-        }\n-\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.calloc(layout.size(), layout.align())\n-        }\n-\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            let _lock = lock::lock();\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n-        }\n-\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n-        }\n-    }\n-\n-    #[cfg(target_feature = \"atomics\")]\n-    mod lock {\n-        use core::arch::wasm32;\n-        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n-\n-        static LOCKED: AtomicI32 = AtomicI32::new(0);\n-\n-        pub struct DropLock;\n-\n-        pub fn lock() -> DropLock {\n-            loop {\n-                if LOCKED.swap(1, SeqCst) == 0 {\n-                    return DropLock\n-                }\n-                unsafe {\n-                    let r = wasm32::atomic::wait_i32(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1,  // expected value\n-                        -1, // timeout\n-                    );\n-                    debug_assert!(r == 0 || r == 1);\n-                }\n-            }\n-        }\n-\n-        impl Drop for DropLock {\n-            fn drop(&mut self) {\n-                let r = LOCKED.swap(0, SeqCst);\n-                debug_assert_eq!(r, 1);\n-                unsafe {\n-                    wasm32::atomic::wake(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1, // only one thread\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(target_feature = \"atomics\"))]\n-    mod lock {\n-        #[inline]\n-        pub fn lock() {} // no atomics, no threads, that's easy!\n-    }\n-}"}, {"sha": "734564c2d856777ab450b935e26c2537199259fa", "filename": "src/librustc_asan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_asan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_asan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2FCargo.toml?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_asan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "2573825a5ff45775601bfa7f14a25265d3998eaf", "filename": "src/librustc_lsan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_lsan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_lsan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2FCargo.toml?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_lsan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_lsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_lsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Flib.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "a14dd99eeb3b381653048d6e6dc871712397b625", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -16,7 +16,7 @@ use decoder::proc_macro_def_path_table;\n use schema::CrateRoot;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n@@ -871,17 +871,14 @@ impl<'a> CrateLoader<'a> {\n         // At this point we've determined that we need an allocator. Let's see\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n-        let mut all_rlib = true;\n-        for ct in self.sess.crate_types.borrow().iter() {\n-            match *ct {\n-                config::CrateType::Executable |\n-                config::CrateType::Dylib |\n-                config::CrateType::ProcMacro |\n-                config::CrateType::Cdylib |\n-                config::CrateType::Staticlib => all_rlib = false,\n-                config::CrateType::Rlib => {}\n-            }\n-        }\n+        let all_rlib = self.sess.crate_types.borrow()\n+            .iter()\n+            .all(|ct| {\n+                match *ct {\n+                    config::CrateType::Rlib => true,\n+                    _ => false,\n+                }\n+            });\n         if all_rlib {\n             self.sess.allocator_kind.set(None);\n             return\n@@ -1004,8 +1001,6 @@ impl<'a> CrateLoader<'a> {\n \n impl<'a> CrateLoader<'a> {\n     pub fn postprocess(&mut self, krate: &ast::Crate) {\n-        // inject the sanitizer runtime before the allocator runtime because all\n-        // sanitizers force the use of the `alloc_system` allocator\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);"}, {"sha": "29165675a2ad7e346052ccad9cdab39cf7d406b4", "filename": "src/librustc_msan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_msan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_msan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2FCargo.toml?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_msan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_msan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_msan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Flib.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "baadb64511ae1887aa50eff616ed18772919a77a", "filename": "src/librustc_tsan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_tsan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_tsan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2FCargo.toml?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_tsan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_tsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibrustc_tsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Flib.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "2b1d515c83b75a4d0090bc519a4d5104f09a82fc", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -14,7 +14,6 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n core = { path = \"../libcore\" }\n@@ -36,6 +35,9 @@ rustc_lsan = { path = \"../librustc_lsan\" }\n rustc_msan = { path = \"../librustc_msan\" }\n rustc_tsan = { path = \"../librustc_tsan\" }\n \n+[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+dlmalloc = { path = '../rustc/dlmalloc_shim' }\n+\n [build-dependencies]\n cc = \"1.0\"\n build_helper = { path = \"../build_helper\" }"}, {"sha": "485b2ffe1975ed5c5973066ceb1df9d6b9d8efac", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -73,15 +73,100 @@\n \n use core::sync::atomic::{AtomicPtr, Ordering};\n use core::{mem, ptr};\n+use core::ptr::NonNull;\n use sys_common::util::dumb_print;\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n pub use alloc_crate::alloc::*;\n \n+/// The default memory allocator provided by the operating system.\n+///\n+/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n+/// plus related functions.\n+///\n+/// This type implements the `GlobalAlloc` trait and Rust programs by deafult\n+/// work as if they had this definition:\n+///\n+/// ```rust\n+/// use std::alloc::System;\n+///\n+/// #[global_allocator]\n+/// static A: System = System;\n+///\n+/// fn main() {\n+///     let a = Box::new(4); // Allocates from the system allocator.\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// You can also define your own wrapper around `System` if you'd like, such as\n+/// keeping track of the number of all bytes allocated:\n+///\n+/// ```rust\n+/// use std::alloc::{System, GlobalAlloc, Layout};\n+/// use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering::SeqCst};\n+///\n+/// struct Counter;\n+///\n+/// static ALLOCATED: AtomicUsize = ATOMIC_USIZE_INIT;\n+///\n+/// unsafe impl GlobalAlloc for Counter {\n+///     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+///         let ret = System.alloc(layout);\n+///         if !ret.is_null() {\n+///             ALLOCATED.fetch_add(layout.size(), SeqCst);\n+///         }\n+///         return ret\n+///     }\n+///\n+///     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+///         System.dealloc(ptr, layout);\n+///         ALLOCATED.fetch_sub(layout.size(), SeqCst);\n+///     }\n+/// }\n+///\n+/// #[global_allocator]\n+/// static A: Counter = Counter;\n+///\n+/// fn main() {\n+///     println!(\"allocated bytes before main: {}\", ALLOCATED.load(SeqCst));\n+/// }\n+/// ```\n+///\n+/// It can also be used directly to allocate memory independently of whatever\n+/// global allocator has been selected for a Rust program. For example if a Rust\n+/// program opts in to using jemalloc as the global allocator, `System` will\n+/// still allocate memory using `malloc` and `HeapAlloc`.\n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-#[doc(inline)]\n-pub use alloc_system::System;\n+#[derive(Debug, Copy, Clone)]\n+pub struct System;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+unsafe impl Alloc for System {\n+    #[inline]\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&mut self,\n+                      ptr: NonNull<u8>,\n+                      layout: Layout,\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    }\n+}\n \n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n "}, {"sha": "f460d109c894a50b4f12ff30c27982c90a80891d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -235,7 +235,6 @@\n #![cfg_attr(test, feature(test, update_panic_count))]\n #![feature(alloc)]\n #![feature(alloc_error_handler)]\n-#![feature(alloc_system)]\n #![feature(allocator_api)]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n@@ -316,7 +315,7 @@\n \n #[cfg(stage0)]\n #[global_allocator]\n-static ALLOC: alloc_system::System = alloc_system::System;\n+static ALLOC: alloc::System = alloc::System;\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute\n // to import the prelude implicitly when building crates that depend on std.\n@@ -337,7 +336,6 @@ pub use core::{unreachable, unimplemented, write, writeln, try};\n #[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]\n extern crate alloc as alloc_crate;\n-extern crate alloc_system;\n #[doc(masked)]\n extern crate libc;\n "}, {"sha": "dfb56472c6c83a90d1223339fd82a86443577c8a", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -12,6 +12,8 @@ use io;\n use libc;\n use mem;\n \n+#[path = \"../unix/alloc.rs\"]\n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "edb407ecd23ce6af9ce6497eb790e34c674659fc", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -15,6 +15,8 @@ use io::{self, ErrorKind};\n pub use libc::strlen;\n pub use self::rand::hashmap_random_keys;\n \n+#[path = \"../unix/alloc.rs\"]\n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "2a7f1934518e133bb0b1eb9ef80296ddc54904d1", "filename": "src/libstd/sys/unix/alloc.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ptr;\n+use libc;\n+use sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use alloc::{GlobalAlloc, Layout, System};\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            libc::malloc(layout.size()) as *mut u8\n+        } else {\n+            #[cfg(target_os = \"macos\")]\n+            {\n+                if layout.align() > (1 << 31) {\n+                    return ptr::null_mut()\n+                }\n+            }\n+            aligned_malloc(&layout)\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            libc::calloc(layout.size(), 1) as *mut u8\n+        } else {\n+            let ptr = self.alloc(layout.clone());\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, layout.size());\n+            }\n+            ptr\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+        } else {\n+            realloc_fallback(self, ptr, layout, new_size)\n+        }\n+    }\n+}\n+\n+#[cfg(any(target_os = \"android\",\n+          target_os = \"hermit\",\n+          target_os = \"redox\",\n+          target_os = \"solaris\"))]\n+#[inline]\n+unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    // On android we currently target API level 9 which unfortunately\n+    // doesn't have the `posix_memalign` API used below. Instead we use\n+    // `memalign`, but this unfortunately has the property on some systems\n+    // where the memory returned cannot be deallocated by `free`!\n+    //\n+    // Upon closer inspection, however, this appears to work just fine with\n+    // Android, so for this platform we should be fine to call `memalign`\n+    // (which is present in API level 9). Some helpful references could\n+    // possibly be chromium using memalign [1], attempts at documenting that\n+    // memalign + free is ok [2] [3], or the current source of chromium\n+    // which still uses memalign on android [4].\n+    //\n+    // [1]: https://codereview.chromium.org/10796020/\n+    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+    //                                       /memory/aligned_memory.cc\n+    libc::memalign(layout.align(), layout.size()) as *mut u8\n+}\n+\n+#[cfg(not(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\")))]\n+#[inline]\n+unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    let mut out = ptr::null_mut();\n+    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+    if ret != 0 {\n+        ptr::null_mut()\n+    } else {\n+        out as *mut u8\n+    }\n+}"}, {"sha": "e8101bd0bc96452a9efe395097509a24fb989f92", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -36,6 +36,7 @@ pub use libc::strlen;\n #[macro_use]\n pub mod weak;\n \n+pub mod alloc;\n pub mod args;\n pub mod android;\n #[cfg(feature = \"backtrace\")]"}, {"sha": "0faa3c9a740f191fe843aba5394bffdf887dab0d", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is an implementation of a global allocator on the wasm32 platform when\n+//! emscripten is not in use. In that situation there's no actual runtime for us\n+//! to lean on for allocation, so instead we provide our own!\n+//!\n+//! The wasm32 instruction set has two instructions for getting the current\n+//! amount of memory and growing the amount of memory. These instructions are the\n+//! foundation on which we're able to build an allocator, so we do so! Note that\n+//! the instructions are also pretty \"global\" and this is the \"global\" allocator\n+//! after all!\n+//!\n+//! The current allocator here is the `dlmalloc` crate which we've got included\n+//! in the rust-lang/rust repository as a submodule. The crate is a port of\n+//! dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n+//! for now which is currently technically required (can't link with C yet).\n+//!\n+//! The crate itself provides a global allocator which on wasm has no\n+//! synchronization as there are no threads!\n+\n+extern crate dlmalloc;\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+\n+static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        let _lock = lock::lock();\n+        DLMALLOC.malloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        let _lock = lock::lock();\n+        DLMALLOC.calloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        let _lock = lock::lock();\n+        DLMALLOC.free(ptr, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        let _lock = lock::lock();\n+        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+    }\n+}\n+\n+#[cfg(target_feature = \"atomics\")]\n+mod lock {\n+    use arch::wasm32;\n+    use sync::atomic::{AtomicI32, Ordering::SeqCst};\n+\n+    static LOCKED: AtomicI32 = AtomicI32::new(0);\n+\n+    pub struct DropLock;\n+\n+    pub fn lock() -> DropLock {\n+        loop {\n+            if LOCKED.swap(1, SeqCst) == 0 {\n+                return DropLock\n+            }\n+            unsafe {\n+                let r = wasm32::atomic::wait_i32(\n+                    &LOCKED as *const AtomicI32 as *mut i32,\n+                    1,  // expected value\n+                    -1, // timeout\n+                );\n+                debug_assert!(r == 0 || r == 1);\n+            }\n+        }\n+    }\n+\n+    impl Drop for DropLock {\n+        fn drop(&mut self) {\n+            let r = LOCKED.swap(0, SeqCst);\n+            debug_assert_eq!(r, 1);\n+            unsafe {\n+                wasm32::atomic::wake(\n+                    &LOCKED as *const AtomicI32 as *mut i32,\n+                    1, // only one thread\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_feature = \"atomics\"))]\n+mod lock {\n+    #[inline]\n+    pub fn lock() {} // no atomics, no threads, that's easy!\n+}"}, {"sha": "e8f7e32ac9177253c30c0b4d2e47c07317fe1663", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -32,6 +32,7 @@ use sys_common::{AsInner, FromInner};\n use ffi::{OsString, OsStr};\n use time::Duration;\n \n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "e5de3e016c99b6d76535f0d4487915f971b5c1d8", "filename": "src/libstd/sys/windows/alloc.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+use sys::c;\n+use sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+\n+#[repr(C)]\n+struct Header(*mut u8);\n+\n+unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+    &mut *(ptr as *mut Header).offset(-1)\n+}\n+\n+unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+    let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n+    *get_header(aligned) = Header(ptr);\n+    aligned\n+}\n+\n+#[inline]\n+unsafe fn allocate_with_flags(layout: Layout, flags: c::DWORD) -> *mut u8 {\n+    if layout.align() <= MIN_ALIGN {\n+        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8\n+    }\n+\n+    let size = layout.size() + layout.align();\n+    let ptr = c::HeapAlloc(c::GetProcessHeap(), flags, size);\n+    if ptr.is_null() {\n+        ptr as *mut u8\n+    } else {\n+        align_ptr(ptr as *mut u8, layout.align())\n+    }\n+}\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        allocate_with_flags(layout, 0)\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        allocate_with_flags(layout, c::HEAP_ZERO_MEMORY)\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        if layout.align() <= MIN_ALIGN {\n+            let err = c::HeapFree(c::GetProcessHeap(), 0, ptr as c::LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                          c::GetLastError());\n+        } else {\n+            let header = get_header(ptr);\n+            let err = c::HeapFree(c::GetProcessHeap(), 0, header.0 as c::LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                          c::GetLastError());\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN {\n+            c::HeapReAlloc(c::GetProcessHeap(), 0, ptr as c::LPVOID, new_size) as *mut u8\n+        } else {\n+            realloc_fallback(self, ptr, layout, new_size)\n+        }\n+    }\n+}"}, {"sha": "c84874a3e880f56dfcaa688903e9f1d75b6df379", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -309,6 +309,8 @@ pub const FD_SETSIZE: usize = 64;\n \n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n+pub const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -1277,6 +1279,11 @@ extern \"system\" {\n \n     #[link_name = \"SystemFunction036\"]\n     pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n+\n+    pub fn GetProcessHeap() -> HANDLE;\n+    pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+    pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+    pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n }\n \n // Functions that aren't available on every version of Windows that we support,"}, {"sha": "f880bc8c050be28a5aa8f4f8fd4b5b28e54c5ec4", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -22,6 +22,7 @@ pub use self::rand::hashmap_random_keys;\n \n #[macro_use] pub mod compat;\n \n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "439a9dfb3fdb58f73ebba28e3cd157597e324c9f", "filename": "src/libstd/sys_common/alloc.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys_common%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys_common%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Falloc.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+use cmp;\n+use ptr;\n+\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values.\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"powerpc64\",\n+              target_arch = \"asmjs\",\n+              target_arch = \"wasm32\")))]\n+pub const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86_64\",\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\",\n+              target_arch = \"sparc64\")))]\n+pub const MIN_ALIGN: usize = 16;\n+\n+pub unsafe fn realloc_fallback(\n+    alloc: &System,\n+    ptr: *mut u8,\n+    old_layout: Layout,\n+    new_size: usize,\n+) -> *mut u8 {\n+    // Docs for GlobalAlloc::realloc require this to be valid:\n+    let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+\n+    let new_ptr = GlobalAlloc::alloc(alloc, new_layout);\n+    if !new_ptr.is_null() {\n+        let size = cmp::min(old_layout.size(), new_size);\n+        ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+        GlobalAlloc::dealloc(alloc, ptr, old_layout);\n+    }\n+    new_ptr\n+}"}, {"sha": "4b8cde3d1f486792fa0d788ab99db674c784949a", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -38,6 +38,7 @@ macro_rules! rtassert {\n     })\n }\n \n+pub mod alloc;\n pub mod at_exit_imp;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "12e9a54da52819939fcaccecb2fd1e549796ac7a", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7590341a6ac213909d0ef56a7ebc2834274c8b/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=cc7590341a6ac213909d0ef56a7ebc2834274c8b", "patch": "@@ -27,7 +27,6 @@\n //!\n //! - core may not have platform-specific code\n //! - libcompiler_builtins may have platform-specific code\n-//! - liballoc_system may have platform-specific code\n //! - libpanic_abort may have platform-specific code\n //! - libpanic_unwind may have platform-specific code\n //! - libunwind may have platform-specific code\n@@ -51,7 +50,6 @@ use std::iter::Iterator;\n // Paths that may contain platform-specific code\n const EXCEPTION_PATHS: &[&str] = &[\n     // std crates\n-    \"src/liballoc_system\",\n     \"src/libcompiler_builtins\",\n     \"src/liblibc\",\n     \"src/libpanic_abort\","}]}