{"sha": "64185014af8ffd81109cab1d1140c18933369071", "node_id": "C_kwDOAAsO6NoAKDY0MTg1MDE0YWY4ZmZkODExMDljYWIxZDExNDBjMTg5MzMzNjkwNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-26T08:51:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-26T08:51:11Z"}, "message": "Auto merge of #2363 - emarteca:int-function-args-returns, r=oli-obk\n\nAdding support for external C functions that have integer (or empty) args and/or returns\n\nStarts addressing `@https://github.com/rust-lang/miri/issues/11`\n\n### Implementation\nAdding support for calling external C functions that have any number of integer arguments (types of integers: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`) and an integer return type (or `void`).\nAs suggested in `@https://github.com/rust-lang/miri/issues/11,` the [`libffi` crate](https://docs.rs/libffi/latest/libffi/index.html) is used to dispatch the calls to external C functions.\n\n#### Modifications\nMain modifications are to:\n* [helper.rs](https://github.com/emarteca/miri/blob/int-function-args-returns/src/helpers.rs) : adding a function `call_and_add_external_c_fct_to_context` to read the code pointer to the external C function, dispatch the call, and save the return in MIRI internal memory. Handles all conversions between MIRI and C values (using some macros, also defined in this file).\n* [foreign_items.rs](https://github.com/emarteca/miri/blob/int-function-args-returns/src/shims/foreign_items.rs) : handles the calling of `call_and_add_external_c_fct_to_context` in [helper.rs](https://github.com/emarteca/miri/blob/int-function-args-returns/src/helpers.rs) when a foreign item is encountered. Also adds some structs to model C representations of arguments, and the signature of the external C call.\n\n### Testing\nAdds tests for the following external functions which are now supported:\n* [int tests](https://github.com/emarteca/miri/blob/int-function-args-returns/tests/pass/external_C/int_c_tests.rs):\n     - adds 2 to a provided int (no type of int specified, so autocasts)\n     - takes the sum of its 12 arguments (tests stack spill)\n     - adds 3 to a 16 bit int\n     - adds an `i16` to an `i64`\n     - returns -10 as an unsigned int\n* [void tests](https://github.com/emarteca/miri/blob/int-function-args-returns/tests/pass/external_C/print_from_c.rs)\n     - void function that prints from C\n\n### Code review\nThe code in this PR was reviewed by `@maurer` on [another fork](https://github.com/maurer/miri/pull/1) -- thanks!", "tree": {"sha": "83f91a3c04e512cb8f946199d0bea3b385cc2635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83f91a3c04e512cb8f946199d0bea3b385cc2635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64185014af8ffd81109cab1d1140c18933369071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64185014af8ffd81109cab1d1140c18933369071", "html_url": "https://github.com/rust-lang/rust/commit/64185014af8ffd81109cab1d1140c18933369071", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64185014af8ffd81109cab1d1140c18933369071/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5853bc724d469287ca3aeab2585413625f1a4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5853bc724d469287ca3aeab2585413625f1a4ba", "html_url": "https://github.com/rust-lang/rust/commit/d5853bc724d469287ca3aeab2585413625f1a4ba"}, {"sha": "88a78826154870f9778af49d48974fd180e31df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/88a78826154870f9778af49d48974fd180e31df8", "html_url": "https://github.com/rust-lang/rust/commit/88a78826154870f9778af49d48974fd180e31df8"}], "stats": {"total": 569, "additions": 565, "deletions": 4}, "files": [{"sha": "c1d3d33576fbb2483b9030010446f7c15587ed33", "filename": ".gitignore", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -2,10 +2,18 @@ target\n /doc\n tex/*/out\n *.dot\n+*.out\n *.rs.bk\n .vscode\n *.mm_profdata\n perf.data\n perf.data.old\n flamegraph.svg\n+<<<<<<< HEAD\n+=======\n+<<<<<<< HEAD\n+tests/extern-so/libtestlib.so\n+=======\n+>>>>>>> master\n+>>>>>>> 58ba05a0 (C FFI support for functions with int args and returns)\n .auto-*"}, {"sha": "084b7b27a2fbbaf995f0475ad315b747feb6a2ee", "filename": "Cargo.lock", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -2,6 +2,12 @@\n # It is not intended for manual editing.\n version = 3\n \n+[[package]]\n+name = \"abort_on_panic\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"955f37ac58af2416bac687c8ab66a4ccba282229bd7422a28d2281a5e66a6116\"\n+\n [[package]]\n name = \"addr2line\"\n version = \"0.17.0\"\n@@ -327,6 +333,36 @@ version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n \n+[[package]]\n+name = \"libffi\"\n+version = \"3.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0e08093a2ddeee94bd0c830a53d895ff91f1f3bb0f9b3c8c6b00739cdf76bc1d\"\n+dependencies = [\n+ \"abort_on_panic\",\n+ \"libc\",\n+ \"libffi-sys\",\n+]\n+\n+[[package]]\n+name = \"libffi-sys\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab4106b7f09d7b87d021334d5618fac1dfcfb824d4c5fe111ff0074dfd242e15\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n+[[package]]\n+name = \"libloading\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"lock_api\"\n version = \"0.4.5\"\n@@ -401,6 +437,8 @@ dependencies = [\n  \"getrandom\",\n  \"lazy_static\",\n  \"libc\",\n+ \"libffi\",\n+ \"libloading\",\n  \"log\",\n  \"measureme\",\n  \"rand\","}, {"sha": "d6d005ac369424df6b57bdcce4f4047ec08a412f", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -20,6 +20,8 @@ doctest = false # and no doc tests\n [dependencies]\n getrandom = { version = \"0.2\", features = [\"std\"] }\n env_logger = \"0.9\"\n+libffi = \"3.0.0\"\n+libloading = \"0.7\"\n log = \"0.4\"\n shell-escape = \"0.1.4\"\n rand = \"0.8\""}, {"sha": "8e96338a865f68e5e01f9c4171d277fe000fa4b7", "filename": "README.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -346,6 +346,17 @@ to Miri failing to detect cases of undefined behavior in a program.\n   this flag is **unsound**.\n * `-Zmiri-disable-weak-memory-emulation` disables the emulation of some C++11 weak\n   memory effects.\n+* `-Zmiri-extern-so-file=<path to a shared object file>` is an experimental flag for providing support\n+  for FFI calls. Functions not provided by that file are still executed via the usual Miri shims.\n+  **WARNING**: If an invalid/incorrect `.so` file is specified, this can cause undefined behaviour in Miri itself!\n+  And of course, Miri cannot do any checks on the actions taken by the external code.\n+  Note that Miri has its own handling of file descriptors, so if you want to replace *some* functions\n+  working on file descriptors, you will have to replace *all* of them, or the two kinds of\n+  file descriptors will be mixed up.\n+  This is **work in progress**; currently, only integer arguments and return values are\n+  supported (and no, pointer/integer casts to work around this limitation will not work;\n+  they will fail horribly).\n+  Follow [the discussion on supporting other types](https://github.com/rust-lang/miri/issues/2365). \n * `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n    This can be used to find which parts of your program are executing slowly under Miri.\n    The profile is written out to a file with the prefix `<name>`, and can be processed"}, {"sha": "c8121aa9733e9304b4ea1ff422c78b901e0e036c", "filename": "build.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    // Re-export the TARGET environment variable so it can\n+    // be accessed by miri.\n+    let target = std::env::var(\"TARGET\").unwrap();\n+    println!(\"cargo:rustc-env=TARGET={:?}\", target);\n+}"}, {"sha": "19f1a987ace4aac6b8c3162b2551d5d5c856ca2d", "filename": "miri", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/miri", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -108,6 +108,7 @@ esac\n \n ## Prepare the environment\n # Determine some toolchain properties\n+# export the target so its available in miri\n TARGET=$(rustc +$TOOLCHAIN --version --verbose | grep \"^host:\" | cut -d ' ' -f 2)\n SYSROOT=$(rustc +$TOOLCHAIN --print sysroot)\n LIBDIR=$SYSROOT/lib/rustlib/$TARGET/lib"}, {"sha": "fa6a307038937c58a8633f54595572e4300e660b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -530,6 +530,19 @@ fn main() {\n                 \"full\" => BacktraceStyle::Full,\n                 _ => show_error!(\"-Zmiri-backtrace may only be 0, 1, or full\"),\n             };\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-extern-so-file=\") {\n+            let filename = param.to_string();\n+            if std::path::Path::new(&filename).exists() {\n+                if let Some(other_filename) = miri_config.external_so_file {\n+                    panic!(\n+                        \"-Zmiri-extern-so-file external SO file is already set to {}\",\n+                        other_filename.display()\n+                    );\n+                }\n+                miri_config.external_so_file = Some(filename.into());\n+            } else {\n+                panic!(\"-Zmiri-extern-so-file path {} does not exist\", filename);\n+            }\n         } else {\n             // Forward to rustc.\n             rustc_args.push(arg);"}, {"sha": "511163a2e759a011c0692c20af6a5e073a05dbea", "filename": "src/eval.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -3,6 +3,7 @@\n use std::ffi::{OsStr, OsString};\n use std::iter;\n use std::panic::{self, AssertUnwindSafe};\n+use std::path::PathBuf;\n use std::thread;\n \n use log::info;\n@@ -128,6 +129,9 @@ pub struct MiriConfig {\n     pub report_progress: Option<u32>,\n     /// Whether Stacked Borrows retagging should recurse into fields of datatypes.\n     pub retag_fields: bool,\n+    /// The location of a shared object file to load when calling external functions\n+    /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n+    pub external_so_file: Option<PathBuf>,\n }\n \n impl Default for MiriConfig {\n@@ -159,6 +163,7 @@ impl Default for MiriConfig {\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n             retag_fields: false,\n+            external_so_file: None,\n         }\n     }\n }"}, {"sha": "841c1343fa3c78b93799b3f0951505ad51b6af4a", "filename": "src/machine.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -358,10 +358,14 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) report_progress: Option<u32>,\n     /// The number of blocks that passed since the last progress report.\n     pub(crate) since_progress_report: u32,\n+\n+    /// Handle of the optional shared object file for external functions.\n+    pub external_so_lib: Option<(libloading::Library, std::path::PathBuf)>,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     pub(crate) fn new(config: &MiriConfig, layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Self {\n+        let target_triple = &layout_cx.tcx.sess.opts.target_triple.to_string();\n         let local_crates = helpers::get_local_crates(layout_cx.tcx);\n         let layouts =\n             PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n@@ -412,6 +416,24 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             preemption_rate: config.preemption_rate,\n             report_progress: config.report_progress,\n             since_progress_report: 0,\n+            external_so_lib: config.external_so_file.as_ref().map(|lib_file_path| {\n+                // Check if host target == the session target.\n+                if option_env!(\"TARGET\") == Some(target_triple) {\n+                    panic!(\n+                        \"calling external C functions in linked .so file requires target and host to be the same\"\n+                    );\n+                }\n+                // Note: it is the user's responsibility to provide a correct SO file.\n+                // WATCH OUT: If an invalid/incorrect SO file is specified, this can cause\n+                // undefined behaviour in Miri itself!\n+                (\n+                    unsafe {\n+                        libloading::Library::new(lib_file_path)\n+                            .expect(\"Failed to read specified shared object file\")\n+                    },\n+                    lib_file_path.clone(),\n+                )\n+            }),\n         }\n     }\n "}, {"sha": "f1ae1e7d3f47f9bce9fa164a1983a9303fb4e1a1", "filename": "src/shims/ffi_support.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/src%2Fshims%2Fffi_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/src%2Fshims%2Fffi_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fffi_support.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,291 @@\n+use libffi::{high::call as ffi, low::CodePtr};\n+use std::ops::Deref;\n+\n+use rustc_middle::ty::{self as ty, IntTy, Ty, UintTy};\n+use rustc_span::Symbol;\n+use rustc_target::abi::HasDataLayout;\n+\n+use crate::*;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Extract the scalar value from the result of reading a scalar from the machine,\n+    /// and convert it to a `CArg`.\n+    fn scalar_to_carg(\n+        k: ScalarMaybeUninit<Provenance>,\n+        arg_type: Ty<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, CArg> {\n+        match arg_type.kind() {\n+            // If the primitive provided can be converted to a type matching the type pattern\n+            // then create a `CArg` of this primitive value with the corresponding `CArg` constructor.\n+            // the ints\n+            ty::Int(IntTy::I8) => {\n+                return Ok(CArg::Int8(k.to_i8()?));\n+            }\n+            ty::Int(IntTy::I16) => {\n+                return Ok(CArg::Int16(k.to_i16()?));\n+            }\n+            ty::Int(IntTy::I32) => {\n+                return Ok(CArg::Int32(k.to_i32()?));\n+            }\n+            ty::Int(IntTy::I64) => {\n+                return Ok(CArg::Int64(k.to_i64()?));\n+            }\n+            ty::Int(IntTy::Isize) => {\n+                // This will fail if host != target, but then the entire FFI thing probably won't work well\n+                // in that situation.\n+                return Ok(CArg::ISize(k.to_machine_isize(cx)?.try_into().unwrap()));\n+            }\n+            // the uints\n+            ty::Uint(UintTy::U8) => {\n+                return Ok(CArg::UInt8(k.to_u8()?));\n+            }\n+            ty::Uint(UintTy::U16) => {\n+                return Ok(CArg::UInt16(k.to_u16()?));\n+            }\n+            ty::Uint(UintTy::U32) => {\n+                return Ok(CArg::UInt32(k.to_u32()?));\n+            }\n+            ty::Uint(UintTy::U64) => {\n+                return Ok(CArg::UInt64(k.to_u64()?));\n+            }\n+            ty::Uint(UintTy::Usize) => {\n+                // This will fail if host != target, but then the entire FFI thing probably won't work well\n+                // in that situation.\n+                return Ok(CArg::USize(k.to_machine_usize(cx)?.try_into().unwrap()));\n+            }\n+            _ => {}\n+        }\n+        // If no primitives were returned then we have an unsupported type.\n+        throw_unsup_format!(\n+            \"unsupported scalar argument type to external C function: {:?}\",\n+            arg_type\n+        );\n+    }\n+\n+    /// Call external C function and\n+    /// store output, depending on return type in the function signature.\n+    fn call_external_c_and_store_return<'a>(\n+        &mut self,\n+        link_name: Symbol,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        ptr: CodePtr,\n+        libffi_args: Vec<libffi::high::Arg<'a>>,\n+    ) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+\n+        // Unsafe because of the call to external C code.\n+        // Because this is calling a C function it is not necessarily sound,\n+        // but there is no way around this and we've checked as much as we can.\n+        unsafe {\n+            // If the return type of a function is a primitive integer type,\n+            // then call the function (`ptr`) with arguments `libffi_args`, store the return value as the specified\n+            // primitive integer type, and then write this value out to the miri memory as an integer.\n+            match dest.layout.ty.kind() {\n+                // ints\n+                ty::Int(IntTy::I8) => {\n+                    let x = ffi::call::<i8>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::I16) => {\n+                    let x = ffi::call::<i16>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::I32) => {\n+                    let x = ffi::call::<i32>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::I64) => {\n+                    let x = ffi::call::<i64>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Int(IntTy::Isize) => {\n+                    let x = ffi::call::<isize>(ptr, libffi_args.as_slice());\n+                    // `isize` doesn't `impl Into<i128>`, so convert manually.\n+                    // Convert to `i64` since this covers both 32- and 64-bit machines.\n+                    this.write_int(i64::try_from(x).unwrap(), dest)?;\n+                    return Ok(());\n+                }\n+                // uints\n+                ty::Uint(UintTy::U8) => {\n+                    let x = ffi::call::<u8>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::U16) => {\n+                    let x = ffi::call::<u16>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::U32) => {\n+                    let x = ffi::call::<u32>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::U64) => {\n+                    let x = ffi::call::<u64>(ptr, libffi_args.as_slice());\n+                    this.write_int(x, dest)?;\n+                    return Ok(());\n+                }\n+                ty::Uint(UintTy::Usize) => {\n+                    let x = ffi::call::<usize>(ptr, libffi_args.as_slice());\n+                    // `usize` doesn't `impl Into<i128>`, so convert manually.\n+                    // Convert to `u64` since this covers both 32- and 64-bit machines.\n+                    this.write_int(u64::try_from(x).unwrap(), dest)?;\n+                    return Ok(());\n+                }\n+                // Functions with no declared return type (i.e., the default return)\n+                // have the output_type `Tuple([])`.\n+                ty::Tuple(t_list) =>\n+                    if t_list.len() == 0 {\n+                        ffi::call::<()>(ptr, libffi_args.as_slice());\n+                        return Ok(());\n+                    },\n+                _ => {}\n+            }\n+            // FIXME ellen! deal with all the other return types\n+            throw_unsup_format!(\"unsupported return type to external C function: {:?}\", link_name);\n+        }\n+    }\n+\n+    /// Get the pointer to the function of the specified name in the shared object file,\n+    /// if it exists. The function must be in the shared object file specified: we do *not*\n+    /// return pointers to functions in dependencies of the library.  \n+    fn get_func_ptr_explicitly_from_lib(&mut self, link_name: Symbol) -> Option<CodePtr> {\n+        let this = self.eval_context_mut();\n+        // Try getting the function from the shared library.\n+        // On windows `_lib_path` will be unused, hence the name starting with `_`.\n+        let (lib, _lib_path) = this.machine.external_so_lib.as_ref().unwrap();\n+        let func: libloading::Symbol<'_, unsafe extern \"C\" fn()> = unsafe {\n+            match lib.get(link_name.as_str().as_bytes()) {\n+                Ok(x) => x,\n+                Err(_) => {\n+                    return None;\n+                }\n+            }\n+        };\n+\n+        // FIXME: this is a hack!\n+        // The `libloading` crate will automatically load system libraries like `libc`.\n+        // On linux `libloading` is based on `dlsym`: https://docs.rs/libloading/0.7.3/src/libloading/os/unix/mod.rs.html#202\n+        // and `dlsym`(https://linux.die.net/man/3/dlsym) looks through the dependency tree of the\n+        // library if it can't find the symbol in the library itself.\n+        // So, in order to check if the function was actually found in the specified\n+        // `machine.external_so_lib` we need to check its `dli_fname` and compare it to\n+        // the specified SO file path.\n+        // This code is a reimplementation of the mechanism for getting `dli_fname` in `libloading`,\n+        // from: https://docs.rs/libloading/0.7.3/src/libloading/os/unix/mod.rs.html#411\n+        // using the `libc` crate where this interface is public.\n+        // No `libc::dladdr` on windows.\n+        #[cfg(unix)]\n+        let mut info = std::mem::MaybeUninit::<libc::Dl_info>::uninit();\n+        #[cfg(unix)]\n+        unsafe {\n+            if libc::dladdr(*func.deref() as *const _, info.as_mut_ptr()) != 0 {\n+                if std::ffi::CStr::from_ptr(info.assume_init().dli_fname).to_str().unwrap()\n+                    != _lib_path.to_str().unwrap()\n+                {\n+                    return None;\n+                }\n+            }\n+        }\n+        // Return a pointer to the function.\n+        Some(CodePtr(*func.deref() as *mut _))\n+    }\n+\n+    /// Call specified external C function, with supplied arguments.\n+    /// Need to convert all the arguments from their hir representations to\n+    /// a form compatible with C (through `libffi` call).\n+    /// Then, convert return from the C call into a corresponding form that\n+    /// can be stored in Miri internal memory.\n+    fn call_external_c_fct(\n+        &mut self,\n+        link_name: Symbol,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+        args: &[OpTy<'tcx, Provenance>],\n+    ) -> InterpResult<'tcx, bool> {\n+        // Get the pointer to the function in the shared object file if it exists.\n+        let code_ptr = match self.get_func_ptr_explicitly_from_lib(link_name) {\n+            Some(ptr) => ptr,\n+            None => {\n+                // Shared object file does not export this function -- try the shims next.\n+                return Ok(false);\n+            }\n+        };\n+\n+        let this = self.eval_context_mut();\n+\n+        // Get the function arguments, and convert them to `libffi`-compatible form.\n+        let mut libffi_args = Vec::<CArg>::with_capacity(args.len());\n+        for cur_arg in args.iter() {\n+            libffi_args.push(Self::scalar_to_carg(\n+                this.read_scalar(cur_arg)?,\n+                cur_arg.layout.ty,\n+                this,\n+            )?);\n+        }\n+\n+        // Convert them to `libffi::high::Arg` type.\n+        let libffi_args = libffi_args\n+            .iter()\n+            .map(|cur_arg| cur_arg.arg_downcast())\n+            .collect::<Vec<libffi::high::Arg<'_>>>();\n+\n+        // Call the function and store output, depending on return type in the function signature.\n+        self.call_external_c_and_store_return(link_name, dest, code_ptr, libffi_args)?;\n+        Ok(true)\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+/// Enum of supported arguments to external C functions.\n+// We introduce this enum instead of just calling `ffi::arg` and storing a list\n+// of `libffi::high::Arg` directly, because the `libffi::high::Arg` just wraps a reference\n+// to the value it represents: https://docs.rs/libffi/latest/libffi/high/call/struct.Arg.html\n+// and we need to store a copy of the value, and pass a reference to this copy to C instead.\n+pub enum CArg {\n+    /// 8-bit signed integer.\n+    Int8(i8),\n+    /// 16-bit signed integer.\n+    Int16(i16),\n+    /// 32-bit signed integer.\n+    Int32(i32),\n+    /// 64-bit signed integer.\n+    Int64(i64),\n+    /// isize.\n+    ISize(isize),\n+    /// 8-bit unsigned integer.\n+    UInt8(u8),\n+    /// 16-bit unsigned integer.\n+    UInt16(u16),\n+    /// 32-bit unsigned integer.\n+    UInt32(u32),\n+    /// 64-bit unsigned integer.\n+    UInt64(u64),\n+    /// usize.\n+    USize(usize),\n+}\n+\n+impl<'a> CArg {\n+    /// Convert a `CArg` to a `libffi` argument type.\n+    fn arg_downcast(&'a self) -> libffi::high::Arg<'a> {\n+        match self {\n+            CArg::Int8(i) => ffi::arg(i),\n+            CArg::Int16(i) => ffi::arg(i),\n+            CArg::Int32(i) => ffi::arg(i),\n+            CArg::Int64(i) => ffi::arg(i),\n+            CArg::ISize(i) => ffi::arg(i),\n+            CArg::UInt8(i) => ffi::arg(i),\n+            CArg::UInt16(i) => ffi::arg(i),\n+            CArg::UInt32(i) => ffi::arg(i),\n+            CArg::UInt64(i) => ffi::arg(i),\n+            CArg::USize(i) => ffi::arg(i),\n+        }\n+    }\n+}"}, {"sha": "b8862b3ba408fa8197bc5c2051221762dbbe1dcd", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -23,6 +23,7 @@ use rustc_target::{\n \n use super::backtrace::EvalContextExt as _;\n use crate::helpers::{convert::Truncate, target_os_is_unix};\n+use crate::shims::ffi_support::EvalContextExt as _;\n use crate::*;\n \n /// Returned by `emulate_foreign_item_by_name`.\n@@ -31,7 +32,7 @@ pub enum EmulateByNameResult<'mir, 'tcx> {\n     NeedsJumping,\n     /// Jumping has already been taken care of.\n     AlreadyJumped,\n-    /// A MIR body has been found for the function\n+    /// A MIR body has been found for the function.\n     MirBody(&'mir mir::Body<'tcx>, ty::Instance<'tcx>),\n     /// The item is not supported.\n     NotSupported,\n@@ -369,6 +370,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n \n+        // First deal with any external C functions in linked .so file\n+        // (if any SO file is specified, and if the host target == the session target)\n+        if this.machine.external_so_lib.as_ref().is_some() {\n+            // An Ok(false) here means that the function being called was not exported\n+            // by the specified SO file; we should continue and check if it corresponds to\n+            // a provided shim.\n+            if this.call_external_c_fct(link_name, dest, args)? {\n+                return Ok(EmulateByNameResult::NeedsJumping);\n+            }\n+        }\n+\n         // When adding a new shim, you should follow the following pattern:\n         // ```\n         // \"shim_name\" => {\n@@ -779,9 +791,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 target => throw_unsup_format!(\"the target `{}` is not supported\", target),\n             }\n         };\n-\n         // We only fall through to here if we did *not* hit the `_` arm above,\n-        // i.e., if we actually emulated the function.\n+        // i.e., if we actually emulated the function with one of the shims.\n         Ok(EmulateByNameResult::NeedsJumping)\n     }\n "}, {"sha": "ee2145db7e1b5fa0975d0b8a6f0ed5d0082d5596", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -1,6 +1,7 @@\n #![warn(clippy::integer_arithmetic)]\n \n mod backtrace;\n+pub mod ffi_support;\n pub mod foreign_items;\n pub mod intrinsics;\n pub mod unix;"}, {"sha": "fe0d9be28cf2a71c7527b0f9ecc00e7022c402a8", "filename": "tests/compiletest.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -1,13 +1,42 @@\n use colored::*;\n use regex::Regex;\n use std::path::{Path, PathBuf};\n-use std::{env, ffi::OsString};\n+use std::{env, ffi::OsString, process::Command};\n use ui_test::{color_eyre::Result, Config, DependencyBuilder, Mode, OutputConflictHandling};\n \n fn miri_path() -> PathBuf {\n     PathBuf::from(option_env!(\"MIRI\").unwrap_or(env!(\"CARGO_BIN_EXE_miri\")))\n }\n \n+// Build the shared object file for testing external C function calls.\n+fn build_so_for_c_ffi_tests() -> PathBuf {\n+    let cc = option_env!(\"CC\").unwrap_or(\"cc\");\n+    // Target directory that we can write to.\n+    let so_target_dir = Path::new(&env::var_os(\"CARGO_TARGET_DIR\").unwrap()).join(\"miri-extern-so\");\n+    // Create the directory if it does not already exist.\n+    std::fs::create_dir_all(&so_target_dir)\n+        .expect(\"Failed to create directory for shared object file\");\n+    let so_file_path = so_target_dir.join(\"libtestlib.so\");\n+    let cc_output = Command::new(cc)\n+        .args([\n+            \"-shared\",\n+            \"-o\",\n+            so_file_path.to_str().unwrap(),\n+            \"tests/extern-so/test.c\",\n+            // Only add the functions specified in libcode.version to the shared object file.\n+            // This is to avoid automatically adding `malloc`, etc.\n+            // Source: https://anadoxin.org/blog/control-over-symbol-exports-in-gcc.html/\n+            \"-fPIC\",\n+            \"-Wl,--version-script=tests/extern-so/libcode.version\",\n+        ])\n+        .output()\n+        .expect(\"failed to generate shared object file for testing external C function calls\");\n+    if !cc_output.status.success() {\n+        panic!(\"error in generating shared object file for testing external C function calls\");\n+    }\n+    so_file_path\n+}\n+\n fn run_tests(\n     mode: Mode,\n     path: &str,\n@@ -40,6 +69,16 @@ fn run_tests(\n         flags.push(target.into());\n     }\n \n+    // If we're on linux, and we're testing the extern-so functionality,\n+    // then build the shared object file for testing external C function calls\n+    // and push the relevant compiler flag.\n+    if cfg!(target_os = \"linux\") && path.starts_with(\"tests/extern-so/\") {\n+        let so_file_path = build_so_for_c_ffi_tests();\n+        let mut flag = std::ffi::OsString::from(\"-Zmiri-extern-so-file=\");\n+        flag.push(so_file_path.into_os_string());\n+        flags.push(flag);\n+    }\n+\n     let skip_ui_checks = env::var_os(\"MIRI_SKIP_UI_CHECKS\").is_some();\n \n     let output_conflict_handling = match (env::var_os(\"MIRI_BLESS\").is_some(), skip_ui_checks) {\n@@ -176,6 +215,10 @@ fn main() -> Result<()> {\n     ui(Mode::Pass, \"tests/pass-dep\", WithDependencies)?;\n     ui(Mode::Panic, \"tests/panic\", WithDependencies)?;\n     ui(Mode::Fail, \"tests/fail\", WithDependencies)?;\n+    if cfg!(target_os = \"linux\") {\n+        ui(Mode::Pass, \"tests/extern-so/pass\", WithoutDependencies)?;\n+        ui(Mode::Fail, \"tests/extern-so/fail\", WithDependencies)?;\n+    }\n \n     Ok(())\n }"}, {"sha": "3aaeb632cad7b66412891a372fbd92068cbe7d2c", "filename": "tests/extern-so/fail/function_not_in_so.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Ffail%2Ffunction_not_in_so.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Ffail%2Ffunction_not_in_so.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fextern-so%2Ffail%2Ffunction_not_in_so.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,12 @@\n+//@only-target-linux\n+//@only-on-host\n+\n+extern \"C\" {\n+    fn foo();\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo(); //~ ERROR: unsupported operation: can't call foreign function: foo\n+    }\n+}"}, {"sha": "8ff9ca74bc58463039d6ffb9cd15cca560608011", "filename": "tests/extern-so/fail/function_not_in_so.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Ffail%2Ffunction_not_in_so.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Ffail%2Ffunction_not_in_so.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fextern-so%2Ffail%2Ffunction_not_in_so.stderr?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,14 @@\n+error: unsupported operation: can't call foreign function: foo\n+  --> $DIR/function_not_in_so.rs:LL:CC\n+   |\n+LL |         foo();\n+   |         ^^^^^ can't call foreign function: foo\n+   |\n+   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/function_not_in_so.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "0f04b9aaebb38e00f1fa2cb997cd1f53e2bb62e8", "filename": "tests/extern-so/libcode.version", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Flibcode.version", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Flibcode.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fextern-so%2Flibcode.version?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,9 @@\n+CODEABI_1.0 {\n+    global: *add_one_int*; \n+        *printer*; \n+        *test_stack_spill*; \n+        *get_unsigned_int*; \n+        *add_int16*;\n+        *add_short_to_long*;\n+    local: *;\n+};"}, {"sha": "1e1d0b11e99ffd444443f5a3e11021307707a04b", "filename": "tests/extern-so/pass/call_extern_c_fcts.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Fpass%2Fcall_extern_c_fcts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Fpass%2Fcall_extern_c_fcts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fextern-so%2Fpass%2Fcall_extern_c_fcts.rs?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,46 @@\n+//@only-target-linux\n+//@only-on-host\n+\n+extern \"C\" {\n+    fn add_one_int(x: i32) -> i32;\n+    fn add_int16(x: i16) -> i16;\n+    fn test_stack_spill(\n+        a: i32,\n+        b: i32,\n+        c: i32,\n+        d: i32,\n+        e: i32,\n+        f: i32,\n+        g: i32,\n+        h: i32,\n+        i: i32,\n+        j: i32,\n+        k: i32,\n+        l: i32,\n+    ) -> i32;\n+    fn add_short_to_long(x: i16, y: i64) -> i64;\n+    fn get_unsigned_int() -> u32;\n+    fn printer();\n+}\n+\n+fn main() {\n+    unsafe {\n+        // test function that adds 2 to a provided int\n+        assert_eq!(add_one_int(1), 3);\n+\n+        // test function that takes the sum of its 12 arguments\n+        assert_eq!(test_stack_spill(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), 78);\n+\n+        // test function that adds 3 to a 16 bit int\n+        assert_eq!(add_int16(-1i16), 2i16);\n+\n+        // test function that adds an i16 to an i64\n+        assert_eq!(add_short_to_long(-1i16, 123456789123i64), 123456789122i64);\n+\n+        // test function that returns -10 as an unsigned int\n+        assert_eq!(get_unsigned_int(), (-10i32) as u32);\n+\n+        // test void function that prints from C\n+        printer();\n+    }\n+}"}, {"sha": "7ba13d2d7b02e396663d717879b01c9784c3ce3a", "filename": "tests/extern-so/pass/call_extern_c_fcts.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Fpass%2Fcall_extern_c_fcts.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Fpass%2Fcall_extern_c_fcts.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fextern-so%2Fpass%2Fcall_extern_c_fcts.stdout?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1 @@\n+printing from C"}, {"sha": "68714f1743b6ec751438ce1582302d3141778fee", "filename": "tests/extern-so/test.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/64185014af8ffd81109cab1d1140c18933369071/tests%2Fextern-so%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fextern-so%2Ftest.c?ref=64185014af8ffd81109cab1d1140c18933369071", "patch": "@@ -0,0 +1,27 @@\n+#include <stdio.h>\n+\n+int add_one_int(int x) {\n+  return 2 + x;\n+}\n+\n+void printer() {\n+  printf(\"printing from C\\n\");\n+}\n+\n+// function with many arguments, to test functionality when some args are stored\n+// on the stack\n+int test_stack_spill(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l) {\n+  return a+b+c+d+e+f+g+h+i+j+k+l;\n+}\n+\n+unsigned int get_unsigned_int() {\n+  return -10;\n+}\n+\n+short add_int16(short x) {\n+  return x + 3;\n+}\n+\n+long add_short_to_long(short x, long y) {\n+  return x + y;\n+}"}]}