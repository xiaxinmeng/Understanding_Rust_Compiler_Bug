{"sha": "7a9f282528fe95e160b177b880e06cc5ca2a426a", "node_id": "C_kwDOAAsO6NoAKDdhOWYyODI1MjhmZTk1ZTE2MGIxNzdiODgwZTA2Y2M1Y2EyYTQyNmE", "commit": {"author": {"name": "yanchith", "email": "yanchi.toth@gmail.com", "date": "2023-06-09T09:48:11Z"}, "committer": {"name": "yanchith", "email": "yanchi.toth@gmail.com", "date": "2023-06-09T09:48:11Z"}, "message": "Reallocatorize after merge", "tree": {"sha": "3464179fb972225af332a8b08944daaa3d811412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3464179fb972225af332a8b08944daaa3d811412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a9f282528fe95e160b177b880e06cc5ca2a426a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9f282528fe95e160b177b880e06cc5ca2a426a", "html_url": "https://github.com/rust-lang/rust/commit/7a9f282528fe95e160b177b880e06cc5ca2a426a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a9f282528fe95e160b177b880e06cc5ca2a426a/comments", "author": {"login": "yanchith", "id": 1099245, "node_id": "MDQ6VXNlcjEwOTkyNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1099245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yanchith", "html_url": "https://github.com/yanchith", "followers_url": "https://api.github.com/users/yanchith/followers", "following_url": "https://api.github.com/users/yanchith/following{/other_user}", "gists_url": "https://api.github.com/users/yanchith/gists{/gist_id}", "starred_url": "https://api.github.com/users/yanchith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yanchith/subscriptions", "organizations_url": "https://api.github.com/users/yanchith/orgs", "repos_url": "https://api.github.com/users/yanchith/repos", "events_url": "https://api.github.com/users/yanchith/events{/privacy}", "received_events_url": "https://api.github.com/users/yanchith/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yanchith", "id": 1099245, "node_id": "MDQ6VXNlcjEwOTkyNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1099245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yanchith", "html_url": "https://github.com/yanchith", "followers_url": "https://api.github.com/users/yanchith/followers", "following_url": "https://api.github.com/users/yanchith/following{/other_user}", "gists_url": "https://api.github.com/users/yanchith/gists{/gist_id}", "starred_url": "https://api.github.com/users/yanchith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yanchith/subscriptions", "organizations_url": "https://api.github.com/users/yanchith/orgs", "repos_url": "https://api.github.com/users/yanchith/repos", "events_url": "https://api.github.com/users/yanchith/events{/privacy}", "received_events_url": "https://api.github.com/users/yanchith/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb5c011670ce8d073d0aae8c45e73c20593bfa11", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5c011670ce8d073d0aae8c45e73c20593bfa11", "html_url": "https://github.com/rust-lang/rust/commit/cb5c011670ce8d073d0aae8c45e73c20593bfa11"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "abc29b32bbc0cd9398ff8be384c9b6dc09e5dc3d", "filename": "library/alloc/src/collections/binary_heap/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f282528fe95e160b177b880e06cc5ca2a426a/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f282528fe95e160b177b880e06cc5ca2a426a/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs?ref=7a9f282528fe95e160b177b880e06cc5ca2a426a", "patch": "@@ -280,7 +280,6 @@ pub struct BinaryHeap<\n     data: Vec<T, A>,\n }\n \n-// XXX: PeekMut<A>\n /// Structure wrapping a mutable reference to the greatest item on a\n /// `BinaryHeap`.\n ///\n@@ -289,8 +288,12 @@ pub struct BinaryHeap<\n ///\n /// [`peek_mut`]: BinaryHeap::peek_mut\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n-pub struct PeekMut<'a, T: 'a + Ord> {\n-    heap: &'a mut BinaryHeap<T>,\n+pub struct PeekMut<\n+    'a,\n+    T: 'a + Ord,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    heap: &'a mut BinaryHeap<T, A>,\n     // If a set_len + sift_down are required, this is Some. If a &mut T has not\n     // yet been exposed to peek_mut()'s caller, it's None.\n     original_len: Option<NonZeroUsize>,\n@@ -359,11 +362,10 @@ impl<'a, T: Ord, A: Allocator + 'a> DerefMut for PeekMut<'a, T, A> {\n     }\n }\n \n-// XXX: PeekMut<A>\n impl<'a, T: Ord, A: Allocator + 'a> PeekMut<'a, T, A> {\n     /// Removes the peeked value from the heap and returns it.\n     #[stable(feature = \"binary_heap_peek_mut_pop\", since = \"1.18.0\")]\n-    pub fn pop(mut this: PeekMut<'a, T>) -> T {\n+    pub fn pop(mut this: PeekMut<'a, T, A>) -> T {\n         if let Some(original_len) = this.original_len.take() {\n             // SAFETY: This is how many elements were in the Vec at the time of\n             // the BinaryHeap::peek_mut call.\n@@ -404,18 +406,21 @@ impl<T: fmt::Debug, A: Allocator> fmt::Debug for BinaryHeap<T, A> {\n     }\n }\n \n-struct RebuildOnDrop<'a, T: Ord> {\n-    heap: &'a mut BinaryHeap<T>,\n+struct RebuildOnDrop<\n+    'a,\n+    T: Ord,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    heap: &'a mut BinaryHeap<T, A>,\n     rebuild_from: usize,\n }\n \n-impl<'a, T: Ord> Drop for RebuildOnDrop<'a, T> {\n+impl<'a, T: Ord, A: Allocator> Drop for RebuildOnDrop<'a, T, A> {\n     fn drop(&mut self) {\n         self.heap.rebuild_tail(self.rebuild_from);\n     }\n }\n \n-// XXX: BinaryHeap<T, A>\n impl<T: Ord> BinaryHeap<T> {\n     /// Creates an empty `BinaryHeap` as a max-heap.\n     ///\n@@ -501,7 +506,6 @@ impl<T: Ord, A: Allocator> BinaryHeap<T, A> {\n         BinaryHeap { data: Vec::with_capacity_in(capacity, alloc) }\n     }\n \n-    // XXX: peek_mut\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n@@ -533,7 +537,7 @@ impl<T: Ord, A: Allocator> BinaryHeap<T, A> {\n     /// If the item is modified then the worst case time complexity is *O*(log(*n*)),\n     /// otherwise it's *O*(1).\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n-    pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n+    pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T, A>> {\n         if self.is_empty() {\n             None\n         } else {\n@@ -1813,7 +1817,7 @@ impl<T: Ord, A: Allocator> Extend<T> for BinaryHeap<T, A> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n+impl<'a, T: 'a + Ord + Copy, A: Allocator> Extend<&'a T> for BinaryHeap<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }"}]}