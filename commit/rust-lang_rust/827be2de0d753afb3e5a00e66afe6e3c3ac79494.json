{"sha": "827be2de0d753afb3e5a00e66afe6e3c3ac79494", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyN2JlMmRlMGQ3NTNhZmIzZTVhMDBlNjZhZmU2ZTNjM2FjNzk0OTQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-02-27T22:15:19Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-02-28T17:41:33Z"}, "message": "Add TCP functionality from net2", "tree": {"sha": "602ababcb35eff73ae93c3e8dd1ff1f23c60c02d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602ababcb35eff73ae93c3e8dd1ff1f23c60c02d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/827be2de0d753afb3e5a00e66afe6e3c3ac79494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/827be2de0d753afb3e5a00e66afe6e3c3ac79494", "html_url": "https://github.com/rust-lang/rust/commit/827be2de0d753afb3e5a00e66afe6e3c3ac79494", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/827be2de0d753afb3e5a00e66afe6e3c3ac79494/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5237b02b96b199abdcf1ddb472b0080fdff4ccd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5237b02b96b199abdcf1ddb472b0080fdff4ccd", "html_url": "https://github.com/rust-lang/rust/commit/c5237b02b96b199abdcf1ddb472b0080fdff4ccd"}], "stats": {"total": 440, "additions": 440, "deletions": 0}, "files": [{"sha": "b8530c98398c85985659a8b6654d3726ad80a091", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=827be2de0d753afb3e5a00e66afe6e3c3ac79494", "patch": "@@ -180,6 +180,117 @@ impl TcpStream {\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n     }\n+\n+    /// Sets the value of the `TCP_NODELAY` option on this socket.\n+    ///\n+    /// If set, this option disables the Nagle algorithm. This means that\n+    /// segments are always sent as soon as possible, even if there is only a\n+    /// small amount of data. When not set, data is buffered until there is a\n+    /// sufficient amount to send out, thereby avoiding the frequent sending of\n+    /// small packets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        self.0.set_nodelay(nodelay)\n+    }\n+\n+    /// Gets the value of the `TCP_NODELAY` option on this socket.\n+    ///\n+    /// For more information about this option, see [`set_nodelay`][link].\n+    ///\n+    /// [link]: #tymethod.set_nodelay\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        self.0.nodelay()\n+    }\n+\n+    /// Sets whether keepalive messages are enabled to be sent on this socket.\n+    ///\n+    /// On Unix, this option will set the `SO_KEEPALIVE` as well as the\n+    /// `TCP_KEEPALIVE` or `TCP_KEEPIDLE` option (depending on your platform).\n+    /// On Windows, this will set the `SIO_KEEPALIVE_VALS` option.\n+    ///\n+    /// If `None` is specified then keepalive messages are disabled, otherwise\n+    /// the duration specified will be the time to remain idle before sending a\n+    /// TCP keepalive probe.\n+    ///\n+    /// Some platforms specify this value in seconds, so sub-second\n+    /// specifications may be omitted.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n+        self.0.set_keepalive(keepalive)\n+    }\n+\n+    /// Returns whether keepalive messages are enabled on this socket, and if so\n+    /// the duration of time between them.\n+    ///\n+    /// For more information about this option, see [`set_keepalive`][link].\n+    ///\n+    /// [link]: #tymethod.set_keepalive\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n+        self.0.keepalive()\n+    }\n+\n+    /// Sets the value for the `IP_TTL` option on this socket.\n+    ///\n+    /// This value sets the time-to-live field that is used in every packet sent\n+    /// from this socket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        self.0.set_ttl(ttl)\n+    }\n+\n+    /// Gets the value of the `IP_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_ttl`][link].\n+    ///\n+    /// [link]: #tymethod.set_ttl\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        self.0.ttl()\n+    }\n+\n+    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n+    ///\n+    /// If this is set to `true` then the socket is restricted to sending and\n+    /// receiving IPv6 packets only. If this is the case, an IPv4 and an IPv6\n+    /// application can each bind the same port at the same time.\n+    ///\n+    /// If this is set to `false` then the socket can be used to send and\n+    /// receive packets from an IPv4-mapped IPv6 address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        self.0.set_only_v6(only_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_only_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_only_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        self.0.only_v6()\n+    }\n+\n+    /// Get the value of the `SO_ERROR` option on this socket.\n+    ///\n+    /// This will retrieve the stored error in the underlying socket, clearing\n+    /// the field in the process. This can be useful for checking errors between\n+    /// calls.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Moves this TCP stream into or out of nonblocking mode.\n+    ///\n+    /// On Unix this corresponds to calling fcntl, and on Windows this\n+    /// corresponds to calling ioctlsocket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -278,6 +389,67 @@ impl TcpListener {\n     pub fn incoming(&self) -> Incoming {\n         Incoming { listener: self }\n     }\n+\n+    /// Sets the value for the `IP_TTL` option on this socket.\n+    ///\n+    /// This value sets the time-to-live field that is used in every packet sent\n+    /// from this socket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        self.0.set_ttl(ttl)\n+    }\n+\n+    /// Gets the value of the `IP_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_ttl`][link].\n+    ///\n+    /// [link]: #tymethod.set_ttl\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        self.0.ttl()\n+    }\n+\n+    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n+    ///\n+    /// If this is set to `true` then the socket is restricted to sending and\n+    /// receiving IPv6 packets only. In this case two IPv4 and IPv6 applications\n+    /// can bind the same port at the same time.\n+    ///\n+    /// If this is set to `false` then the socket can be used to send and\n+    /// receive packets from an IPv4-mapped IPv6 address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        self.0.set_only_v6(only_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_only_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_only_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        self.0.only_v6()\n+    }\n+\n+    /// Get the value of the `SO_ERROR` option on this socket.\n+    ///\n+    /// This will retrieve the stored error in the underlying socket, clearing\n+    /// the field in the process. This can be useful for checking errors between\n+    /// calls.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Moves this TCP stream into or out of nonblocking mode.\n+    ///\n+    /// On Unix this corresponds to calling fcntl, and on Windows this\n+    /// corresponds to calling ioctlsocket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -969,4 +1141,63 @@ mod tests {\n         assert!(start.elapsed() > Duration::from_millis(400));\n         drop(listener);\n     }\n+\n+    #[test]\n+    fn nodelay() {\n+        let addr = next_test_ip4();\n+        let _listener = t!(TcpListener::bind(&addr));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+        assert_eq!(false, t!(stream.nodelay()));\n+        t!(stream.set_nodelay(true));\n+        assert_eq!(true, t!(stream.nodelay()));\n+        t!(stream.set_nodelay(false));\n+        assert_eq!(false, t!(stream.nodelay()));\n+    }\n+\n+    #[test]\n+    fn keepalive() {\n+        let addr = next_test_ip4();\n+        let _listener = t!(TcpListener::bind(&addr));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+        let dur = Duration::new(15410, 0);\n+\n+        assert_eq!(None, t!(stream.keepalive()));\n+        t!(stream.set_keepalive(Some(dur)));\n+        assert_eq!(Some(dur), t!(stream.keepalive()));\n+        t!(stream.set_keepalive(None));\n+        assert_eq!(None, t!(stream.keepalive()));\n+    }\n+\n+    #[test]\n+    fn ttl() {\n+        let ttl = 100;\n+\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        t!(listener.set_ttl(ttl));\n+        assert_eq!(ttl, t!(listener.ttl()));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+        t!(stream.set_ttl(ttl));\n+        assert_eq!(ttl, t!(stream.ttl()));\n+    }\n+\n+    #[test]\n+    fn set_nonblocking() {\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        t!(listener.set_nonblocking(true));\n+        t!(listener.set_nonblocking(false));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+        t!(stream.set_nonblocking(true));\n+        t!(stream.set_nonblocking(false));\n+    }\n }"}, {"sha": "0ac4056de8e05b67c026466269ce733b77c67c32", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=827be2de0d753afb3e5a00e66afe6e3c3ac79494", "patch": "@@ -228,6 +228,54 @@ impl TcpStream {\n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n         self.inner.duplicate().map(|s| TcpStream { inner: s })\n     }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c_int)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_TCP, c::TCP_NODELAY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n+        self.inner.set_keepalive(keepalive)\n+    }\n+\n+    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n+        self.inner.keepalive()\n+    }\n+\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.inner.set_nonblocking(nonblocking)\n+    }\n }\n \n impl FromInner<Socket> for TcpStream {\n@@ -307,6 +355,37 @@ impl TcpListener {\n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n         self.inner.duplicate().map(|s| TcpListener { inner: s })\n     }\n+\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.inner.set_nonblocking(nonblocking)\n+    }\n }\n \n impl FromInner<Socket> for TcpListener {"}, {"sha": "7a2ac7257afbcf084dc7b0e7691852dc7820619d", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=827be2de0d753afb3e5a00e66afe6e3c3ac79494", "patch": "@@ -35,6 +35,16 @@ use libc::SOCK_CLOEXEC;\n #[cfg(not(target_os = \"linux\"))]\n const SOCK_CLOEXEC: c_int = 0;\n \n+#[cfg(any(target_os = \"openbsd\", taret_os = \"freebsd\"))]\n+use libc::SO_KEEPALIVE as TCP_KEEPALIVE;\n+#[cfg(any(target_os = \"macos\", taret_os = \"ios\"))]\n+use libc::TCP_KEEPALIVE;\n+#[cfg(not(any(target_os = \"openbsd\",\n+              target_os = \"freebsd\",\n+              target_os = \"macos\",\n+              target_os = \"ios\")))]\n+use libc::TCP_KEEPIDLE as TCP_KEEPALIVE;\n+\n pub struct Socket(FileDesc);\n \n pub fn init() {}\n@@ -168,6 +178,44 @@ impl Socket {\n         try!(cvt(unsafe { libc::shutdown(self.0.raw(), how) }));\n         Ok(())\n     }\n+\n+    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n+        try!(setsockopt(self,\n+                        libc::SOL_SOCKET,\n+                        libc::SO_KEEPALIVE,\n+                        keepalive.is_some() as libc::c_int));\n+        if let Some(dur) = keepalive {\n+            let mut raw = dur.as_secs();\n+            if dur.subsec_nanos() > 0 {\n+                raw = raw.saturating_add(1);\n+            }\n+\n+            let raw = if raw > libc::c_int::max_value() as u64 {\n+                libc::c_int::max_value()\n+            } else {\n+                raw as libc::c_int\n+            };\n+\n+            try!(setsockopt(self, libc::IPPROTO_TCP, TCP_KEEPALIVE, raw));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n+        let raw: c_int = try!(getsockopt(self, libc::SOL_SOCKET, libc::SO_KEEPALIVE));\n+        if raw == 0 {\n+            return Ok(None);\n+        }\n+\n+        let raw: c_int = try!(getsockopt(self, libc::IPPROTO_TCP, TCP_KEEPALIVE));\n+        Ok(Some(Duration::from_secs(raw as u64)))\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as libc::c_ulong;\n+        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(|_| ())\n+    }\n }\n \n impl AsInner<c_int> for Socket {"}, {"sha": "cc420763fd787306ad27383865ad1ee6102cf580", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=827be2de0d753afb3e5a00e66afe6e3c3ac79494", "patch": "@@ -78,6 +78,13 @@ pub type SOCKET = ::os::windows::raw::SOCKET;\n pub type socklen_t = c_int;\n pub type ADDRESS_FAMILY = USHORT;\n \n+pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE =\n+    Option<unsafe extern \"system\" fn(dwError: DWORD,\n+                                     cbTransferred: DWORD,\n+                                     lpOverlapped: LPWSAOVERLAPPED,\n+                                     dwFlags: DWORD)>;\n+pub type LPWSAOVERLAPPED = *mut OVERLAPPED;\n+\n pub const TRUE: BOOL = 1;\n pub const FALSE: BOOL = 0;\n \n@@ -114,6 +121,9 @@ pub const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n pub const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n \n+pub const SIO_KEEPALIVE_VALS: DWORD = 0x98000004;\n+pub const FIONBIO: c_ulong = 0x8004667e;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {\n@@ -775,6 +785,13 @@ pub struct in6_addr {\n     pub s6_addr: [u8; 16],\n }\n \n+#[repr(C)]\n+pub struct tcp_keepalive {\n+    pub onoff: c_ulong,\n+    pub keepalivetime: c_ulong,\n+    pub keepaliveinterval: c_ulong,\n+}\n+\n #[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n pub enum UNWIND_HISTORY_TABLE {}\n \n@@ -833,6 +850,17 @@ extern \"system\" {\n                       lpProtocolInfo: LPWSAPROTOCOL_INFO,\n                       g: GROUP,\n                       dwFlags: DWORD) -> SOCKET;\n+    pub fn WSAIoctl(s: SOCKET,\n+                    dwIoControlCode: DWORD,\n+                    lpvInBuffer: LPVOID,\n+                    cbInBuffer: DWORD,\n+                    lpvOutBuffer: LPVOID,\n+                    cbOutBuffer: DWORD,\n+                    lpcbBytesReturned: LPDWORD,\n+                    lpOverlapped: LPWSAOVERLAPPED,\n+                    lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE)\n+                    -> c_int;\n+    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut u_long) -> c_int;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;"}, {"sha": "be13657aaf487be1eb4e4af3d80d1795ee46b836", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827be2de0d753afb3e5a00e66afe6e3c3ac79494/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=827be2de0d753afb3e5a00e66afe6e3c3ac79494", "patch": "@@ -185,6 +185,60 @@ impl Socket {\n         try!(cvt(unsafe { c::shutdown(self.0, how) }));\n         Ok(())\n     }\n+\n+    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n+        let ms = keepalive.map(sys::dur2timeout).unwrap_or(c::INFINITE);\n+        let ka = c::tcp_keepalive {\n+            onoff: keepalive.is_some() as c::c_ulong,\n+            keepalivetime: ms as c::c_ulong,\n+            keepaliveinterval: ms as c::c_ulong,\n+        };\n+        sys::cvt(unsafe {\n+            c::WSAIoctl(self.0,\n+                        c::SIO_KEEPALIVE_VALS,\n+                        &ka as *const _ as *mut _,\n+                        mem::size_of_val(&ka) as c::DWORD,\n+                        0 as *mut _,\n+                        0,\n+                        0 as *mut _,\n+                        0 as *mut _,\n+                        None)\n+        }).map(|_| ())\n+    }\n+\n+    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n+        let mut ka = c::tcp_keepalive {\n+            onoff: 0,\n+            keepalivetime: 0,\n+            keepaliveinterval: 0,\n+        };\n+        try!(sys::cvt(unsafe {\n+            WSAIoctl(self.0,\n+                     c::SIO_KEEPALIVE_VALS,\n+                     0 as *mut _,\n+                     0,\n+                     &mut ka as *mut _ as *mut _,\n+                     mem::size_of_val(&ka) as c::DWORD,\n+                     0 as *mut _,\n+                     0 as *mut _,\n+                     None)\n+        }));\n+\n+        if ka.onoff == 0 {\n+            Ok(None)\n+        } else {\n+            let secs = ka.keepaliveinterval / 1000;\n+            let nsec = (ka.keepaliveinterval % 1000) * 1000000;\n+            Ok(Some(Duration::new(secs as u64, nsec as u32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as c::c_ulong;\n+        sys::cvt(unsafe {\n+            c::ioctlsocket(self.0, c::FIONBIO as c::c_int, &mut nonblocking)\n+        }).map(|_| ())\n+    }\n }\n \n impl Drop for Socket {"}]}