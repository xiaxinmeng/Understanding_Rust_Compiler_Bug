{"sha": "c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "node_id": "C_kwDOAAsO6NoAKGMwYjBlZTViZGNiZjkwMDVjZGQ3ZjQ4ZTBhZDM1MGI0MjM4N2UxYzY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-01T06:06:12Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:51:30Z"}, "message": "Move some lints from `Misc` to `Operators`", "tree": {"sha": "edef4f3565f01eada156d73d12e8ff46f6a6fb9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edef4f3565f01eada156d73d12e8ff46f6a6fb9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "html_url": "https://github.com/rust-lang/rust/commit/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8df16ae1df9084dc8e20e835f3de981e32d110c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8df16ae1df9084dc8e20e835f3de981e32d110c", "html_url": "https://github.com/rust-lang/rust/commit/a8df16ae1df9084dc8e20e835f3de981e32d110c"}], "stats": {"total": 1014, "additions": 524, "deletions": 490}, "files": [{"sha": "06f8a6325ff9334805ea9b3ef2b08baa4bdee593", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -212,9 +212,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::WRONG_SELF_CONVENTION),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::CMP_NAN),\n-    LintId::of(misc::CMP_OWNED),\n-    LintId::of(misc::MODULO_ONE),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc::TOPLEVEL_REF_ARG),\n     LintId::of(misc::ZERO_PTR),\n@@ -251,6 +248,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::ASSIGN_OP_PATTERN),\n     LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::CMP_NAN),\n+    LintId::of(operators::CMP_OWNED),\n     LintId::of(operators::DOUBLE_COMPARISONS),\n     LintId::of(operators::DURATION_SUBSEC),\n     LintId::of(operators::EQ_OP),\n@@ -259,6 +258,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(operators::IDENTITY_OP),\n     LintId::of(operators::INEFFECTIVE_BIT_MASK),\n     LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n+    LintId::of(operators::MODULO_ONE),\n     LintId::of(operators::OP_REF),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),"}, {"sha": "7133b6cdd88f6ea36786430daf04b6b2a452b132", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -42,15 +42,15 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::CMP_NAN),\n-    LintId::of(misc::MODULO_ONE),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::CMP_NAN),\n     LintId::of(operators::EQ_OP),\n     LintId::of(operators::ERASING_OP),\n     LintId::of(operators::INEFFECTIVE_BIT_MASK),\n+    LintId::of(operators::MODULO_ONE),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),"}, {"sha": "139b55e965f1491c15b57265d631592c8c72dc0f", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -356,11 +356,6 @@ store.register_lints(&[\n     methods::WRONG_SELF_CONVENTION,\n     methods::ZST_OFFSET,\n     minmax::MIN_MAX,\n-    misc::CMP_NAN,\n-    misc::CMP_OWNED,\n-    misc::FLOAT_CMP,\n-    misc::FLOAT_CMP_CONST,\n-    misc::MODULO_ONE,\n     misc::SHORT_CIRCUIT_STATEMENT,\n     misc::TOPLEVEL_REF_ARG,\n     misc::USED_UNDERSCORE_BINDING,\n@@ -424,17 +419,22 @@ store.register_lints(&[\n     operators::ABSURD_EXTREME_COMPARISONS,\n     operators::ASSIGN_OP_PATTERN,\n     operators::BAD_BIT_MASK,\n+    operators::CMP_NAN,\n+    operators::CMP_OWNED,\n     operators::DOUBLE_COMPARISONS,\n     operators::DURATION_SUBSEC,\n     operators::EQ_OP,\n     operators::ERASING_OP,\n     operators::FLOAT_ARITHMETIC,\n+    operators::FLOAT_CMP,\n+    operators::FLOAT_CMP_CONST,\n     operators::FLOAT_EQUALITY_WITHOUT_ABS,\n     operators::IDENTITY_OP,\n     operators::INEFFECTIVE_BIT_MASK,\n     operators::INTEGER_ARITHMETIC,\n     operators::INTEGER_DIVISION,\n     operators::MISREFACTORED_ASSIGN_OP,\n+    operators::MODULO_ONE,\n     operators::OP_REF,\n     operators::VERBOSE_BIT_MASK,\n     option_env_unwrap::OPTION_ENV_UNWRAP,"}, {"sha": "0c02c2bef562684aa05bc224b9feca0e847f0a29", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -64,7 +64,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n     LintId::of(methods::MAP_UNWRAP_OR),\n     LintId::of(methods::UNNECESSARY_JOIN),\n-    LintId::of(misc::FLOAT_CMP),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n     LintId::of(mut_mut::MUT_MUT),\n@@ -75,6 +74,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(no_effect::NO_EFFECT_UNDERSCORE_BINDING),\n     LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n     LintId::of(non_expressive_names::SIMILAR_NAMES),\n+    LintId::of(operators::FLOAT_CMP),\n     LintId::of(operators::VERBOSE_BIT_MASK),\n     LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n     LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),"}, {"sha": "6bf519c24e848ad2272d6f11e48b1e5166a32596", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -22,7 +22,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n-    LintId::of(misc::CMP_OWNED),\n+    LintId::of(operators::CMP_OWNED),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n     LintId::of(types::BOX_COLLECTION),"}, {"sha": "e66dc67f3dc8932e99cf344d698685b5e703a9f1", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -38,7 +38,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(methods::FILETYPE_IS_FILE),\n     LintId::of(methods::GET_UNWRAP),\n     LintId::of(methods::UNWRAP_USED),\n-    LintId::of(misc::FLOAT_CMP_CONST),\n     LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n     LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n     LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n@@ -50,6 +49,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n     LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n     LintId::of(operators::FLOAT_ARITHMETIC),\n+    LintId::of(operators::FLOAT_CMP_CONST),\n     LintId::of(operators::INTEGER_ARITHMETIC),\n     LintId::of(operators::INTEGER_DIVISION),\n     LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),"}, {"sha": "df2430ced6b621b11d7e442e83b1f9c1a6d16178", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 6, "deletions": 477, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -1,28 +1,21 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then, span_lint_hir_and_then};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{implements_trait, is_copy};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n     self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n-    StmtKind, TyKind, UnOp,\n+    StmtKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n-use rustc_span::symbol::sym;\n \n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{\n-    get_item_name, get_parent_expr, in_constant, is_integer_const, iter_input_pats, last_path_segment,\n-    match_any_def_paths, path_def_id, paths, unsext, SpanlessEq,\n-};\n+use clippy_utils::{get_parent_expr, in_constant, iter_input_pats, last_path_segment, SpanlessEq};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -58,122 +51,6 @@ declare_clippy_lint! {\n     style,\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for comparisons to NaN.\n-    ///\n-    /// ### Why is this bad?\n-    /// NaN does not compare meaningfully to anything \u2013 not\n-    /// even itself \u2013 so those comparisons are simply wrong.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1.0;\n-    /// if x == f32::NAN { }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = 1.0f32;\n-    /// if x.is_nan() { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub CMP_NAN,\n-    correctness,\n-    \"comparisons to `NAN`, which will always return false, probably not intended\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for (in-)equality comparisons on floating-point\n-    /// values (apart from zero), except in functions called `*eq*` (which probably\n-    /// implement equality for a type involving floats).\n-    ///\n-    /// ### Why is this bad?\n-    /// Floating point calculations are usually imprecise, so\n-    /// asking if two values are *exactly* equal is asking for trouble. For a good\n-    /// guide on what to do, see [the floating point\n-    /// guide](http://www.floating-point-gui.de/errors/comparison).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 1.2331f64;\n-    /// let y = 1.2332f64;\n-    ///\n-    /// if y == 1.23f64 { }\n-    /// if y != x {} // where both are floats\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = 1.2331f64;\n-    /// # let y = 1.2332f64;\n-    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error_margin = std::f64::EPSILON;\n-    /// if (y - 1.23f64).abs() < error_margin { }\n-    /// if (y - x).abs() > error_margin { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_CMP,\n-    pedantic,\n-    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for conversions to owned values just for the sake\n-    /// of a comparison.\n-    ///\n-    /// ### Why is this bad?\n-    /// The comparison can operate on a reference, so creating\n-    /// an owned value effectively throws it away directly afterwards, which is\n-    /// needlessly consuming code and heap space.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = \"foo\";\n-    /// # let y = String::from(\"foo\");\n-    /// if x.to_owned() == y {}\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = \"foo\";\n-    /// # let y = String::from(\"foo\");\n-    /// if x == y {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub CMP_OWNED,\n-    perf,\n-    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for getting the remainder of a division by one or minus\n-    /// one.\n-    ///\n-    /// ### Why is this bad?\n-    /// The result for a divisor of one can only ever be zero; for\n-    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n-    /// the respective integer type) or results in zero. No one will write such code\n-    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n-    /// contest, it's probably a bad idea. Use something more underhanded.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// let a = x % 1;\n-    /// let a = x % -1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MODULO_ONE,\n-    correctness,\n-    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for the use of bindings with a single leading\n@@ -244,51 +121,11 @@ declare_clippy_lint! {\n     \"using `0 as *{const, mut} T`\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for (in-)equality comparisons on floating-point\n-    /// value and constant, except in functions called `*eq*` (which probably\n-    /// implement equality for a type involving floats).\n-    ///\n-    /// ### Why is this bad?\n-    /// Floating point calculations are usually imprecise, so\n-    /// asking if two values are *exactly* equal is asking for trouble. For a good\n-    /// guide on what to do, see [the floating point\n-    /// guide](http://www.floating-point-gui.de/errors/comparison).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: f64 = 1.0;\n-    /// const ONE: f64 = 1.00;\n-    ///\n-    /// if x == ONE { } // where both are floats\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x: f64 = 1.0;\n-    /// # const ONE: f64 = 1.00;\n-    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error_margin = std::f64::EPSILON;\n-    /// if (x - ONE).abs() < error_margin { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_CMP_CONST,\n-    restriction,\n-    \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n-}\n-\n declare_lint_pass!(MiscLints => [\n     TOPLEVEL_REF_ARG,\n-    CMP_NAN,\n-    FLOAT_CMP,\n-    CMP_OWNED,\n-    MODULO_ONE,\n     USED_UNDERSCORE_BINDING,\n     SHORT_CIRCUIT_STATEMENT,\n     ZERO_PTR,\n-    FLOAT_CMP_CONST\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for MiscLints {\n@@ -398,16 +235,9 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::Cast(e, ty) => {\n-                check_cast(cx, expr.span, e, ty);\n-                return;\n-            },\n-            ExprKind::Binary(ref cmp, left, right) => {\n-                check_binary(cx, expr, cmp, left, right);\n-                return;\n-            },\n-            _ => {},\n+        if let ExprKind::Cast(e, ty) = expr.kind {\n+            check_cast(cx, expr.span, e, ty);\n+            return;\n         }\n         if in_attributes_expansion(expr) || expr.span.is_desugaring(DesugaringKind::Await) {\n             // Don't lint things expanded by #[derive(...)], etc or `await` desugaring\n@@ -455,236 +285,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     }\n }\n \n-fn get_lint_and_message(\n-    is_comparing_constants: bool,\n-    is_comparing_arrays: bool,\n-) -> (&'static rustc_lint::Lint, &'static str) {\n-    if is_comparing_constants {\n-        (\n-            FLOAT_CMP_CONST,\n-            if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` constant arrays\"\n-            } else {\n-                \"strict comparison of `f32` or `f64` constant\"\n-            },\n-        )\n-    } else {\n-        (\n-            FLOAT_CMP,\n-            if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` arrays\"\n-            } else {\n-                \"strict comparison of `f32` or `f64`\"\n-            },\n-        )\n-    }\n-}\n-\n-fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n-    if_chain! {\n-        if !in_constant(cx, cmp_expr.hir_id);\n-        if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n-        if match value {\n-            Constant::F32(num) => num.is_nan(),\n-            Constant::F64(num) => num.is_nan(),\n-            _ => false,\n-        };\n-        then {\n-            span_lint(\n-                cx,\n-                CMP_NAN,\n-                cmp_expr.span,\n-                \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n-        res\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.typeck_results(), expr) {\n-        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n-            Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n-            Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n-            _ => false,\n-        }),\n-        _ => false,\n-    }\n-}\n-\n-// Return true if `expr` is the result of `signum()` invoked on a float value.\n-fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n-        return is_signum(cx, child_expr);\n-    }\n-\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n-        if sym!(signum) == method_name.ident.name;\n-        // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n-        // the method call)\n-        then {\n-            return is_float(cx, self_arg);\n-        }\n-    }\n-    false\n-}\n-\n-fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n-\n-    if let ty::Array(arr_ty, _) = value {\n-        return matches!(arr_ty.kind(), ty::Float(_));\n-    };\n-\n-    matches!(value, ty::Float(_))\n-}\n-\n-fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n-}\n-\n-#[expect(clippy::too_many_lines)]\n-fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n-    #[derive(Default)]\n-    struct EqImpl {\n-        ty_eq_other: bool,\n-        other_eq_ty: bool,\n-    }\n-\n-    impl EqImpl {\n-        fn is_implemented(&self) -> bool {\n-            self.ty_eq_other || self.other_eq_ty\n-        }\n-    }\n-\n-    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n-        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n-            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n-            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n-        })\n-    }\n-\n-    let typeck = cx.typeck_results();\n-    let (arg, arg_span) = match expr.kind {\n-        ExprKind::MethodCall(.., [arg], _)\n-            if typeck\n-                .type_dependent_def_id(expr.hir_id)\n-                .and_then(|id| cx.tcx.trait_of_item(id))\n-                .map_or(false, |id| {\n-                    matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ToString | sym::ToOwned))\n-                }) =>\n-        {\n-            (arg, arg.span)\n-        },\n-        ExprKind::Call(path, [arg])\n-            if path_def_id(cx, path)\n-                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n-                .map_or(false, |idx| match idx {\n-                    0 => true,\n-                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n-                    _ => false,\n-                }) =>\n-        {\n-            (arg, arg.span)\n-        },\n-        _ => return,\n-    };\n-\n-    let arg_ty = typeck.expr_ty(arg);\n-    let other_ty = typeck.expr_ty(other);\n-\n-    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n-    let with_deref = arg_ty\n-        .builtin_deref(true)\n-        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n-        .unwrap_or_default();\n-\n-    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n-        return;\n-    }\n-\n-    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n-\n-    let lint_span = if other_gets_derefed {\n-        expr.span.to(other.span)\n-    } else {\n-        expr.span\n-    };\n-\n-    span_lint_and_then(\n-        cx,\n-        CMP_OWNED,\n-        lint_span,\n-        \"this creates an owned instance just for comparison\",\n-        |diag| {\n-            // This also catches `PartialEq` implementations that call `to_owned`.\n-            if other_gets_derefed {\n-                diag.span_label(lint_span, \"try implementing the comparison without allocating\");\n-                return;\n-            }\n-\n-            let arg_snip = snippet(cx, arg_span, \"..\");\n-            let expr_snip;\n-            let eq_impl;\n-            if with_deref.is_implemented() {\n-                expr_snip = format!(\"*{}\", arg_snip);\n-                eq_impl = with_deref;\n-            } else {\n-                expr_snip = arg_snip.to_string();\n-                eq_impl = without_deref;\n-            };\n-\n-            let span;\n-            let hint;\n-            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n-                span = expr.span;\n-                hint = expr_snip;\n-            } else {\n-                span = expr.span.to(other.span);\n-\n-                let cmp_span = if other.span < expr.span {\n-                    other.span.between(expr.span)\n-                } else {\n-                    expr.span.between(other.span)\n-                };\n-                if eq_impl.ty_eq_other {\n-                    hint = format!(\n-                        \"{}{}{}\",\n-                        expr_snip,\n-                        snippet(cx, cmp_span, \"..\"),\n-                        snippet(cx, other.span, \"..\")\n-                    );\n-                } else {\n-                    hint = format!(\n-                        \"{}{}{}\",\n-                        snippet(cx, other.span, \"..\"),\n-                        snippet(cx, cmp_span, \"..\"),\n-                        expr_snip\n-                    );\n-                }\n-            }\n-\n-            diag.span_suggestion(\n-                span,\n-                \"try\",\n-                hint,\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n@@ -740,74 +340,3 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n         }\n     }\n }\n-\n-fn check_binary<'a>(\n-    cx: &LateContext<'a>,\n-    expr: &Expr<'_>,\n-    cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,\n-    left: &'a Expr<'_>,\n-    right: &'a Expr<'_>,\n-) {\n-    let op = cmp.node;\n-    if op.is_comparison() {\n-        check_nan(cx, left, expr);\n-        check_nan(cx, right, expr);\n-        check_to_owned(cx, left, right, true);\n-        check_to_owned(cx, right, left, false);\n-    }\n-    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-        if is_allowed(cx, left) || is_allowed(cx, right) {\n-            return;\n-        }\n-\n-        // Allow comparing the results of signum()\n-        if is_signum(cx, left) && is_signum(cx, right) {\n-            return;\n-        }\n-\n-        if let Some(name) = get_item_name(cx, expr) {\n-            let name = name.as_str();\n-            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n-                return;\n-            }\n-        }\n-        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-        let (lint, msg) = get_lint_and_message(\n-            is_named_constant(cx, left) || is_named_constant(cx, right),\n-            is_comparing_arrays,\n-        );\n-        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n-            let lhs = Sugg::hir(cx, left, \"..\");\n-            let rhs = Sugg::hir(cx, right, \"..\");\n-\n-            if !is_comparing_arrays {\n-                diag.span_suggestion(\n-                    expr.span,\n-                    \"consider comparing them within some margin of error\",\n-                    format!(\n-                        \"({}).abs() {} error_margin\",\n-                        lhs - rhs,\n-                        if op == BinOpKind::Eq { '<' } else { '>' }\n-                    ),\n-                    Applicability::HasPlaceholders, // snippet\n-                );\n-            }\n-            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n-        });\n-    } else if op == BinOpKind::Rem {\n-        if is_integer_const(cx, right, 1) {\n-            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-        }\n-\n-        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n-            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n-                span_lint(\n-                    cx,\n-                    MODULO_ONE,\n-                    expr.span,\n-                    \"any number modulo -1 will panic/overflow or result in 0\",\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "786ae1552ad3d01283d3e6e33dd8665cbe480c87", "filename": "clippy_lints/src/operators/cmp_nan.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -0,0 +1,30 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::in_constant;\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+\n+use super::CMP_NAN;\n+\n+pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    if op.is_comparison() && !in_constant(cx, e.hir_id) && (is_nan(cx, lhs) || is_nan(cx, rhs)) {\n+        span_lint(\n+            cx,\n+            CMP_NAN,\n+            e.span,\n+            \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n+        );\n+    }\n+}\n+\n+fn is_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), e) {\n+        match value {\n+            Constant::F32(num) => num.is_nan(),\n+            Constant::F64(num) => num.is_nan(),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e1f9b5906f667cdb8e62ae670ecba722bb13773f", "filename": "clippy_lints/src/operators/cmp_owned.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -0,0 +1,147 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use clippy_utils::{match_any_def_paths, path_def_id, paths};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::symbol::sym;\n+\n+use super::CMP_OWNED;\n+\n+pub(super) fn check(cx: &LateContext<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    if op.is_comparison() {\n+        check_op(cx, lhs, rhs, true);\n+        check_op(cx, rhs, lhs, false);\n+    }\n+}\n+\n+#[derive(Default)]\n+struct EqImpl {\n+    ty_eq_other: bool,\n+    other_eq_ty: bool,\n+}\n+impl EqImpl {\n+    fn is_implemented(&self) -> bool {\n+        self.ty_eq_other || self.other_eq_ty\n+    }\n+}\n+\n+fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+    cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+        ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+        other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+    })\n+}\n+\n+fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    let typeck = cx.typeck_results();\n+    let (arg, arg_span) = match expr.kind {\n+        ExprKind::MethodCall(.., [arg], _)\n+            if typeck\n+                .type_dependent_def_id(expr.hir_id)\n+                .and_then(|id| cx.tcx.trait_of_item(id))\n+                .map_or(false, |id| {\n+                    matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ToString | sym::ToOwned))\n+                }) =>\n+        {\n+            (arg, arg.span)\n+        },\n+        ExprKind::Call(path, [arg])\n+            if path_def_id(cx, path)\n+                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n+                .map_or(false, |idx| match idx {\n+                    0 => true,\n+                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n+                    _ => false,\n+                }) =>\n+        {\n+            (arg, arg.span)\n+        },\n+        _ => return,\n+    };\n+\n+    let arg_ty = typeck.expr_ty(arg);\n+    let other_ty = typeck.expr_ty(other);\n+\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n+        .builtin_deref(true)\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n+\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n+        return;\n+    }\n+\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n+\n+    let lint_span = if other_gets_derefed {\n+        expr.span.to(other.span)\n+    } else {\n+        expr.span\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        CMP_OWNED,\n+        lint_span,\n+        \"this creates an owned instance just for comparison\",\n+        |diag| {\n+            // This also catches `PartialEq` implementations that call `to_owned`.\n+            if other_gets_derefed {\n+                diag.span_label(lint_span, \"try implementing the comparison without allocating\");\n+                return;\n+            }\n+\n+            let arg_snip = snippet(cx, arg_span, \"..\");\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", arg_snip);\n+                eq_impl = with_deref;\n+            } else {\n+                expr_snip = arg_snip.to_string();\n+                eq_impl = without_deref;\n+            };\n+\n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+\n+                let cmp_span = if other.span < expr.span {\n+                    other.span.between(expr.span)\n+                } else {\n+                    expr.span.between(other.span)\n+                };\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\n+                        \"{}{}{}\",\n+                        expr_snip,\n+                        snippet(cx, cmp_span, \"..\"),\n+                        snippet(cx, other.span, \"..\")\n+                    );\n+                } else {\n+                    hint = format!(\n+                        \"{}{}{}\",\n+                        snippet(cx, other.span, \"..\"),\n+                        snippet(cx, cmp_span, \"..\"),\n+                        expr_snip\n+                    );\n+                }\n+            }\n+\n+            diag.span_suggestion(\n+                span,\n+                \"try\",\n+                hint,\n+                Applicability::MachineApplicable, // snippet\n+            );\n+        },\n+    );\n+}"}, {"sha": "0ef793443ff45ce618c7bfc2d32ae2363674c6d1", "filename": "clippy_lints/src/operators/float_cmp.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -0,0 +1,139 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_item_name;\n+use clippy_utils::sugg::Sugg;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::{FLOAT_CMP, FLOAT_CMP_CONST};\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n+        if is_allowed(cx, left) || is_allowed(cx, right) {\n+            return;\n+        }\n+\n+        // Allow comparing the results of signum()\n+        if is_signum(cx, left) && is_signum(cx, right) {\n+            return;\n+        }\n+\n+        if let Some(name) = get_item_name(cx, expr) {\n+            let name = name.as_str();\n+            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n+                return;\n+            }\n+        }\n+        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n+        let (lint, msg) = get_lint_and_message(\n+            is_named_constant(cx, left) || is_named_constant(cx, right),\n+            is_comparing_arrays,\n+        );\n+        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n+            let lhs = Sugg::hir(cx, left, \"..\");\n+            let rhs = Sugg::hir(cx, right, \"..\");\n+\n+            if !is_comparing_arrays {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"consider comparing them within some margin of error\",\n+                    format!(\n+                        \"({}).abs() {} error_margin\",\n+                        lhs - rhs,\n+                        if op == BinOpKind::Eq { '<' } else { '>' }\n+                    ),\n+                    Applicability::HasPlaceholders, // snippet\n+                );\n+            }\n+            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n+        });\n+    }\n+}\n+\n+fn get_lint_and_message(\n+    is_comparing_constants: bool,\n+    is_comparing_arrays: bool,\n+) -> (&'static rustc_lint::Lint, &'static str) {\n+    if is_comparing_constants {\n+        (\n+            FLOAT_CMP_CONST,\n+            if is_comparing_arrays {\n+                \"strict comparison of `f32` or `f64` constant arrays\"\n+            } else {\n+                \"strict comparison of `f32` or `f64` constant\"\n+            },\n+        )\n+    } else {\n+        (\n+            FLOAT_CMP,\n+            if is_comparing_arrays {\n+                \"strict comparison of `f32` or `f64` arrays\"\n+            } else {\n+                \"strict comparison of `f32` or `f64`\"\n+            },\n+        )\n+    }\n+}\n+\n+fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n+        res\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    match constant(cx, cx.typeck_results(), expr) {\n+        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n+            Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n+            Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n+            _ => false,\n+        }),\n+        _ => false,\n+    }\n+}\n+\n+// Return true if `expr` is the result of `signum()` invoked on a float value.\n+fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    // The negation of a signum is still a signum\n+    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n+        return is_signum(cx, child_expr);\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n+        if sym!(signum) == method_name.ident.name;\n+        // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n+        // the method call)\n+        then {\n+            return is_float(cx, self_arg);\n+        }\n+    }\n+    false\n+}\n+\n+fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n+\n+    if let ty::Array(arr_ty, _) = value {\n+        return matches!(arr_ty.kind(), ty::Float(_));\n+    };\n+\n+    matches!(value, ty::Float(_))\n+}\n+\n+fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n+}"}, {"sha": "e4aff267fefad199e885023976eb7fe3c4ab4a29", "filename": "clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -5,14 +5,18 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n mod absurd_extreme_comparisons;\n mod assign_op_pattern;\n mod bit_mask;\n+mod cmp_nan;\n+mod cmp_owned;\n mod double_comparison;\n mod duration_subsec;\n mod eq_op;\n mod erasing_op;\n+mod float_cmp;\n mod float_equality_without_abs;\n mod identity_op;\n mod integer_division;\n mod misrefactored_assign_op;\n+mod modulo_one;\n mod numeric_arithmetic;\n mod op_ref;\n mod verbose_bit_mask;\n@@ -464,6 +468,156 @@ declare_clippy_lint! {\n     \"integer division may cause loss of precision\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for comparisons to NaN.\n+    ///\n+    /// ### Why is this bad?\n+    /// NaN does not compare meaningfully to anything \u2013 not\n+    /// even itself \u2013 so those comparisons are simply wrong.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1.0;\n+    /// if x == f32::NAN { }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = 1.0f32;\n+    /// if x.is_nan() { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub CMP_NAN,\n+    correctness,\n+    \"comparisons to `NAN`, which will always return false, probably not intended\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for conversions to owned values just for the sake\n+    /// of a comparison.\n+    ///\n+    /// ### Why is this bad?\n+    /// The comparison can operate on a reference, so creating\n+    /// an owned value effectively throws it away directly afterwards, which is\n+    /// needlessly consuming code and heap space.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = \"foo\";\n+    /// # let y = String::from(\"foo\");\n+    /// if x.to_owned() == y {}\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = \"foo\";\n+    /// # let y = String::from(\"foo\");\n+    /// if x == y {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub CMP_OWNED,\n+    perf,\n+    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for (in-)equality comparisons on floating-point\n+    /// values (apart from zero), except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// ### Why is this bad?\n+    /// Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 1.2331f64;\n+    /// let y = 1.2332f64;\n+    ///\n+    /// if y == 1.23f64 { }\n+    /// if y != x {} // where both are floats\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = 1.2331f64;\n+    /// # let y = 1.2332f64;\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (y - 1.23f64).abs() < error_margin { }\n+    /// if (y - x).abs() > error_margin { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_CMP,\n+    pedantic,\n+    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for (in-)equality comparisons on floating-point\n+    /// value and constant, except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// ### Why is this bad?\n+    /// Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: f64 = 1.0;\n+    /// const ONE: f64 = 1.00;\n+    ///\n+    /// if x == ONE { } // where both are floats\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x: f64 = 1.0;\n+    /// # const ONE: f64 = 1.00;\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (x - ONE).abs() < error_margin { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_CMP_CONST,\n+    restriction,\n+    \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for getting the remainder of a division by one or minus\n+    /// one.\n+    ///\n+    /// ### Why is this bad?\n+    /// The result for a divisor of one can only ever be zero; for\n+    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n+    /// the respective integer type) or results in zero. No one will write such code\n+    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n+    /// contest, it's probably a bad idea. Use something more underhanded.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// let a = x % 1;\n+    /// let a = x % -1;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MODULO_ONE,\n+    correctness,\n+    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n+}\n+\n pub struct Operators {\n     arithmetic_context: numeric_arithmetic::Context,\n     verbose_bit_mask_threshold: u64,\n@@ -485,6 +639,11 @@ impl_lint_pass!(Operators => [\n     FLOAT_EQUALITY_WITHOUT_ABS,\n     IDENTITY_OP,\n     INTEGER_DIVISION,\n+    CMP_NAN,\n+    CMP_OWNED,\n+    FLOAT_CMP,\n+    FLOAT_CMP_CONST,\n+    MODULO_ONE,\n ]);\n impl Operators {\n     pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n@@ -515,6 +674,10 @@ impl<'tcx> LateLintPass<'tcx> for Operators {\n                 duration_subsec::check(cx, e, op.node, lhs, rhs);\n                 float_equality_without_abs::check(cx, e, op.node, lhs, rhs);\n                 integer_division::check(cx, e, op.node, lhs, rhs);\n+                cmp_nan::check(cx, e, op.node, lhs, rhs);\n+                cmp_owned::check(cx, op.node, lhs, rhs);\n+                float_cmp::check(cx, e, op.node, lhs, rhs);\n+                modulo_one::check(cx, e, op.node, rhs);\n             },\n             ExprKind::AssignOp(op, lhs, rhs) => {\n                 self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);"}, {"sha": "54eea14833ffe065c85c1584c516eeb39819afd9", "filename": "clippy_lints/src/operators/modulo_one.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6/clippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs?ref=c0b0ee5bdcbf9005cdd7f48e0ad350b42387e1c6", "patch": "@@ -0,0 +1,26 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::{is_integer_const, unsext};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MODULO_ONE;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, op: BinOpKind, right: &Expr<'_>) {\n+    if op == BinOpKind::Rem {\n+        if is_integer_const(cx, right, 1) {\n+            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+        }\n+\n+        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n+            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n+                span_lint(\n+                    cx,\n+                    MODULO_ONE,\n+                    expr.span,\n+                    \"any number modulo -1 will panic/overflow or result in 0\",\n+                );\n+            }\n+        };\n+    }\n+}"}]}