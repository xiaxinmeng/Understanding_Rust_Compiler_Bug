{"sha": "353283573896502c185d048b6f2c99561a343853", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MzI4MzU3Mzg5NjUwMmMxODVkMDQ4YjZmMmM5OTU2MWEzNDM4NTM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-12-03T17:50:16Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-12-04T16:43:24Z"}, "message": "Simplify", "tree": {"sha": "18579ad0c62a212184952620d1cb50440d899acd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18579ad0c62a212184952620d1cb50440d899acd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/353283573896502c185d048b6f2c99561a343853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/353283573896502c185d048b6f2c99561a343853", "html_url": "https://github.com/rust-lang/rust/commit/353283573896502c185d048b6f2c99561a343853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/353283573896502c185d048b6f2c99561a343853/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2216318484586fc1be1f637014d9a73c08596571", "url": "https://api.github.com/repos/rust-lang/rust/commits/2216318484586fc1be1f637014d9a73c08596571", "html_url": "https://github.com/rust-lang/rust/commit/2216318484586fc1be1f637014d9a73c08596571"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "f27c4c3bd59fab86e56cc9c3f460ce820a147d3e", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/353283573896502c185d048b6f2c99561a343853/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/353283573896502c185d048b6f2c99561a343853/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=353283573896502c185d048b6f2c99561a343853", "patch": "@@ -148,8 +148,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                         self.tables,\n                     );\n                     patcx.include_lint_checks();\n-                    let pattern: &_ =\n-                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&arm.pat)));\n+                    let pattern = patcx.lower_pattern(&arm.pat);\n+                    let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n                     if !patcx.errors.is_empty() {\n                         patcx.report_inlining_errors(arm.pat.span);\n                         have_errors = true;\n@@ -168,55 +168,57 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n-            let pat_ty = self.tables.node_type(scrut.hir_id);\n+            let scrut_ty = self.tables.node_type(scrut.hir_id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_visibly_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n-                    self.tcx.is_ty_uninhabited_from(module, pat_ty)\n+                    self.tcx.is_ty_uninhabited_from(module, scrut_ty)\n                 } else {\n-                    match pat_ty.kind {\n+                    match scrut_ty.kind {\n                         ty::Never => true,\n                         ty::Adt(def, _) if def.is_enum() => {\n-                            def.variants.is_empty() && !cx.is_foreign_non_exhaustive_enum(pat_ty)\n+                            def.variants.is_empty() && !cx.is_foreign_non_exhaustive_enum(scrut_ty)\n                         }\n                         _ => false,\n                     }\n                 };\n-                if !scrutinee_is_visibly_uninhabited {\n+                if scrutinee_is_visibly_uninhabited {\n+                    // If the type *is* uninhabited, it's vacuously exhaustive.\n+                    // This early return is only needed here because in the absence of the\n+                    // `exhaustive_patterns` feature, empty matches are not detected by `is_useful`\n+                    // to exhaustively match uninhabited types.\n+                    return;\n+                } else {\n                     // We know the type is inhabited, so this must be wrong\n-                    let (def_span, missing_variants) = match pat_ty.kind {\n-                        ty::Adt(def, _) if def.is_enum() => (\n-                            self.tcx.hir().span_if_local(def.did),\n-                            def.variants.iter().map(|variant| variant.ident).collect(),\n-                        ),\n-                        _ => (None, vec![]),\n+                    let (def_span, non_empty_enum) = match scrut_ty.kind {\n+                        ty::Adt(def, _) if def.is_enum() => {\n+                            (self.tcx.hir().span_if_local(def.did), !def.variants.is_empty())\n+                        }\n+                        _ => (None, false),\n                     };\n \n-                    if missing_variants.is_empty() {\n+                    if non_empty_enum {\n+                        // Continue to the normal code path to display missing variants.\n+                    } else {\n                         let mut err = create_e0004(\n                             self.tcx.sess,\n                             scrut.span,\n-                            format!(\"non-exhaustive patterns: type `{}` is non-empty\", pat_ty),\n+                            format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n                         );\n                         err.help(\n                             \"ensure that all possible cases are being handled, \\\n                              possibly by adding wildcards or more match arms\",\n                         );\n                         if let Some(sp) = def_span {\n-                            err.span_label(sp, format!(\"`{}` defined here\", pat_ty));\n+                            err.span_label(sp, format!(\"`{}` defined here\", scrut_ty));\n                         }\n                         err.emit();\n                         return;\n-                    } else {\n-                        // Continue to the normal code path\n                     }\n-                } else {\n-                    // If the type *is* uninhabited, it's vacuously exhaustive\n-                    return;\n                 }\n             }\n \n-            let scrut_ty = self.tables.node_type(scrut.hir_id);\n+            // Fifth, check if the match is exhaustive.\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n         })\n     }"}]}