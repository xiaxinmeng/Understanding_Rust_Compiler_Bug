{"sha": "d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "node_id": "C_kwDOAAsO6NoAKGQ2ZWI3YmNhMDkxOGI3YzVhOWYyNTIzMTBhZGUzNGQzOTNkNGNjMTQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-19T05:15:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-19T05:15:30Z"}, "message": "Rollup merge of #103166 - the8472:copied-next-chunk, r=m-ou-se\n\nOptimize `slice_iter.copied().next_chunk()`\n\n```\nOLD:\ntest iter::bench_copied_array_chunks                               ... bench:         371 ns/iter (+/- 7)\nNEW:\ntest iter::bench_copied_array_chunks                               ... bench:          31 ns/iter (+/- 0)\n```\n\nThe default `next_chunk` implementation suffers from having to assemble the array byte by byte via `next()`, checking the `Option<&T>` and then dereferencing `&T`. The specialization copies the chunk directly from the slice.", "tree": {"sha": "cfa349e766ee0661b3bb003340f250cbff8aa9c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfa349e766ee0661b3bb003340f250cbff8aa9c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjT4fyCRBK7hj4Ov3rIwAAhvAIAI8ltnGC7wkwvZcSRcKgoE+W\nlj/j2obwNyTjpSowiCvFKb8ZpIot0+5tpEDJR17aRq4OeNvbzMY0bM8Ty1P49X+O\nSfTqmHy5NS4IhWcXl+6vTcwnUmGHz4GrjUsrkmQ58AdIrz2oioCwLAnj+iuSLHiV\nJ3SQveKnW2IZl1hkaFenKbUaAZhsd/vHZh3MYMVeQbVXmGM+0pNkmplpeLvjmwqW\nutew3KEKa+toy5UB/5F9lUPaoSRZGyVoMjEPL1BJNzNloHBMVrf046LKmgJSNq06\nsVv8XkHK0ba7TPUNiZDiZ8Pz0TfVUaF+M+G2gn9U94q7Cx60zvv6XgBsOOfOL8U=\n=Moxm\n-----END PGP SIGNATURE-----\n", "payload": "tree cfa349e766ee0661b3bb003340f250cbff8aa9c7\nparent 2efc90e7381721df57348b61518b15794b75d189\nparent 873a18e2213a506d4cf6357e5faef0990ec08683\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1666156530 +0200\ncommitter GitHub <noreply@github.com> 1666156530 +0200\n\nRollup merge of #103166 - the8472:copied-next-chunk, r=m-ou-se\n\nOptimize `slice_iter.copied().next_chunk()`\n\n```\nOLD:\ntest iter::bench_copied_array_chunks                               ... bench:         371 ns/iter (+/- 7)\nNEW:\ntest iter::bench_copied_array_chunks                               ... bench:          31 ns/iter (+/- 0)\n```\n\nThe default `next_chunk` implementation suffers from having to assemble the array byte by byte via `next()`, checking the `Option<&T>` and then dereferencing `&T`. The specialization copies the chunk directly from the slice.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "html_url": "https://github.com/rust-lang/rust/commit/d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2efc90e7381721df57348b61518b15794b75d189", "url": "https://api.github.com/repos/rust-lang/rust/commits/2efc90e7381721df57348b61518b15794b75d189", "html_url": "https://github.com/rust-lang/rust/commit/2efc90e7381721df57348b61518b15794b75d189"}, {"sha": "873a18e2213a506d4cf6357e5faef0990ec08683", "url": "https://api.github.com/repos/rust-lang/rust/commits/873a18e2213a506d4cf6357e5faef0990ec08683", "html_url": "https://github.com/rust-lang/rust/commit/873a18e2213a506d4cf6357e5faef0990ec08683"}], "stats": {"total": 95, "additions": 95, "deletions": 0}, "files": [{"sha": "38887f29af1537733249ec7a3da964a6c0b25ed4", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "patch": "@@ -1,4 +1,6 @@\n use core::iter::*;\n+use core::mem;\n+use core::num::Wrapping;\n use test::{black_box, Bencher};\n \n #[bench]\n@@ -398,3 +400,21 @@ fn bench_trusted_random_access_adapters(b: &mut Bencher) {\n         acc\n     })\n }\n+\n+/// Exercises the iter::Copied specialization for slice::Iter\n+#[bench]\n+fn bench_copied_array_chunks(b: &mut Bencher) {\n+    let v = vec![1u8; 1024];\n+\n+    b.iter(|| {\n+        black_box(&v)\n+            .iter()\n+            .copied()\n+            .array_chunks::<{ mem::size_of::<u64>() }>()\n+            .map(|ary| {\n+                let d = u64::from_ne_bytes(ary);\n+                Wrapping(d.rotate_left(7).wrapping_add(1))\n+            })\n+            .sum::<Wrapping<u64>>()\n+    })\n+}"}, {"sha": "1e462e3fc3f8c4e2f8bb73f10c21f92db19fc822", "filename": "library/core/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/library%2Fcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/library%2Fcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Flib.rs?ref=d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "patch": "@@ -4,6 +4,7 @@\n #![feature(int_log)]\n #![feature(test)]\n #![feature(trusted_random_access)]\n+#![feature(iter_array_chunks)]\n \n extern crate test;\n "}, {"sha": "62d3afb81603dc19d1090a12d818361f201a0a42", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6eb7bca0918b7c5a9f252310ade34d393d4cc14/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=d6eb7bca0918b7c5a9f252310ade34d393d4cc14", "patch": "@@ -2,7 +2,10 @@ use crate::iter::adapters::{\n     zip::try_get_unchecked, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n use crate::iter::{FusedIterator, TrustedLen};\n+use crate::mem::MaybeUninit;\n+use crate::mem::SizedTypeProperties;\n use crate::ops::Try;\n+use crate::{array, ptr};\n \n /// An iterator that copies the elements of an underlying iterator.\n ///\n@@ -44,6 +47,15 @@ where\n         self.it.next().copied()\n     }\n \n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>>\n+    where\n+        Self: Sized,\n+    {\n+        <I as SpecNextChunk<'_, N, T>>::spec_next_chunk(&mut self.it)\n+    }\n+\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.it.size_hint()\n     }\n@@ -166,3 +178,65 @@ where\n     T: Copy,\n {\n }\n+\n+trait SpecNextChunk<'a, const N: usize, T: 'a>: Iterator<Item = &'a T>\n+where\n+    T: Copy,\n+{\n+    fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>>;\n+}\n+\n+impl<'a, const N: usize, I, T: 'a> SpecNextChunk<'a, N, T> for I\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    default fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>> {\n+        array::iter_next_chunk(&mut self.map(|e| *e))\n+    }\n+}\n+\n+impl<'a, const N: usize, T: 'a> SpecNextChunk<'a, N, T> for crate::slice::Iter<'a, T>\n+where\n+    T: Copy,\n+{\n+    fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>> {\n+        let mut raw_array = MaybeUninit::uninit_array();\n+\n+        let len = self.len();\n+\n+        if T::IS_ZST {\n+            if len < N {\n+                let _ = self.advance_by(len);\n+                // SAFETY: ZSTs can be conjured ex nihilo; only the amount has to be correct\n+                return Err(unsafe { array::IntoIter::new_unchecked(raw_array, 0..len) });\n+            }\n+\n+            let _ = self.advance_by(N);\n+            // SAFETY: ditto\n+            return Ok(unsafe { MaybeUninit::array_assume_init(raw_array) });\n+        }\n+\n+        if len < N {\n+            // SAFETY: `len` indicates that this many elements are available and we just checked that\n+            // it fits into the array.\n+            unsafe {\n+                ptr::copy_nonoverlapping(\n+                    self.as_ref().as_ptr(),\n+                    raw_array.as_mut_ptr() as *mut T,\n+                    len,\n+                );\n+                let _ = self.advance_by(len);\n+                return Err(array::IntoIter::new_unchecked(raw_array, 0..len));\n+            }\n+        }\n+\n+        // SAFETY: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n+        // the array.\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.as_ref().as_ptr(), raw_array.as_mut_ptr() as *mut T, N);\n+            let _ = self.advance_by(N);\n+            Ok(MaybeUninit::array_assume_init(raw_array))\n+        }\n+    }\n+}"}]}