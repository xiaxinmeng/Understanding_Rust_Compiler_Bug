{"sha": "f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNjBkNzk1ZjFhYzMxZWQwZTRlMmYzMjI1ZjkxMjJkYjczZTFiOTI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-08T20:57:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:16:06Z"}, "message": "resolve: Move some more code around\n\nMove methods logically belonging to build-reduced-graph into `impl BuildReducedGraphVisitor` and `build_reduced_graph.rs`\nMove types mostly specific to late resolution closer to the late resolution visitor", "tree": {"sha": "ce0d56d9282fd82c30e15af6201ad26cfe0d3189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce0d56d9282fd82c30e15af6201ad26cfe0d3189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "html_url": "https://github.com/rust-lang/rust/commit/f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c86ce76e51439a39765343f2f9ac03e12f04898", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c86ce76e51439a39765343f2f9ac03e12f04898", "html_url": "https://github.com/rust-lang/rust/commit/9c86ce76e51439a39765343f2f9ac03e12f04898"}], "stats": {"total": 1218, "additions": 602, "deletions": 616}, "files": [{"sha": "6e5750e752e9409b81f5190913a38dc39a466e61", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 360, "deletions": 147, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "patch": "@@ -3,13 +3,13 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use crate::macros::{InvocationData, LegacyScope};\n+use crate::macros::{InvocationData, LegacyBinding, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{ResolutionError, Determinacy};\n+use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -29,11 +29,11 @@ use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n-use syntax::span_err;\n+use syntax::{span_err, struct_span_err};\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n@@ -93,14 +93,195 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+        if def_id.krate == LOCAL_CRATE {\n+            return self.module_map[&def_id]\n+        }\n+\n+        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n+        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n+            return module;\n+        }\n+\n+        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n+            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n+        } else {\n+            let def_key = self.cstore.def_key(def_id);\n+            (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n+             Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n+        };\n+\n+        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n+        let module = self.arenas.alloc_module(ModuleData::new(\n+            parent, kind, def_id, ExpnId::root(), DUMMY_SP\n+        ));\n+        self.extern_module_map.insert((def_id, macros_only), module);\n+        module\n+    }\n+\n+    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+        let def_id = match self.macro_defs.get(&expn_id) {\n+            Some(def_id) => *def_id,\n+            None => return self.graph_root,\n+        };\n+        if let Some(id) = self.definitions.as_local_node_id(def_id) {\n+            self.local_macro_def_scopes[&id]\n+        } else if self.is_builtin_macro(Some(def_id)) {\n+            self.injected_crate.unwrap_or(self.graph_root)\n+        } else {\n+            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n+            self.get_module(module_def_id)\n+        }\n+    }\n+\n+    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n+        match res {\n+            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n+            Res::NonMacroAttr(attr_kind) =>\n+                Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            _ => None,\n+        }\n+    }\n+\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+        if let Some(ext) = self.macro_map.get(&def_id) {\n+            return Some(ext.clone());\n+        }\n+\n+        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n+            LoadedMacro::MacroDef(macro_def) => macro_def,\n+            LoadedMacro::ProcMacro(ext) => return Some(ext),\n+        };\n+\n+        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n+        self.macro_map.insert(def_id, ext.clone());\n+        Some(ext)\n+    }\n+\n+    /// Ensures that the reduced graph rooted at the given external module\n+    /// is built, building it if it is not.\n+    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n+        if module.populated.get() { return }\n+        let def_id = module.def_id().unwrap();\n+        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+            let child = child.map_id(|_| panic!(\"unexpected id\"));\n+            BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n+                .build_reduced_graph_for_external_crate_res(module, child);\n+        }\n+        module.populated.set(true)\n+    }\n+}\n+\n+pub struct BuildReducedGraphVisitor<'a, 'b> {\n+    pub r: &'b mut Resolver<'a>,\n+    pub parent_scope: ParentScope<'a>,\n+}\n+\n+impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n+    fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n+        let parent_scope = &self.parent_scope;\n+        match vis.node {\n+            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Crate(..) => {\n+                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+            }\n+            ast::VisibilityKind::Inherited => {\n+                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n+            }\n+            ast::VisibilityKind::Restricted { ref path, id, .. } => {\n+                // For visibilities we are not ready to provide correct implementation of \"uniform\n+                // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n+                // On 2015 edition visibilities are resolved as crate-relative by default,\n+                // so we are prepending a root segment if necessary.\n+                let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n+                let crate_root = if ident.is_path_segment_keyword() {\n+                    None\n+                } else if ident.span.rust_2018() {\n+                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n+                    self.r.session.struct_span_err(ident.span, msg)\n+                        .span_suggestion(\n+                            path.span,\n+                            \"try\",\n+                            format!(\"crate::{}\", path),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    return ty::Visibility::Public;\n+                } else {\n+                    let ctxt = ident.span.ctxt();\n+                    Some(Segment::from_ident(Ident::new(\n+                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n+                    )))\n+                };\n+\n+                let segments = crate_root.into_iter()\n+                    .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n+                let expected_found_error = |this: &Self, res: Res| {\n+                    let path_str = Segment::names_to_string(&segments);\n+                    struct_span_err!(this.r.session, path.span, E0577,\n+                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n+                        .span_label(path.span, \"not a module\").emit();\n+                };\n+                match self.r.resolve_path(\n+                    &segments,\n+                    Some(TypeNS),\n+                    parent_scope,\n+                    true,\n+                    path.span,\n+                    CrateLint::SimplePath(id),\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n+                        let res = module.res().expect(\"visibility resolved to unnamed block\");\n+                        self.r.record_partial_res(id, PartialRes::new(res));\n+                        if module.is_normal() {\n+                            if res == Res::Err {\n+                                ty::Visibility::Public\n+                            } else {\n+                                let vis = ty::Visibility::Restricted(res.def_id());\n+                                if self.r.is_accessible_from(vis, parent_scope.module) {\n+                                    vis\n+                                } else {\n+                                    let msg =\n+                                        \"visibilities can only be restricted to ancestor modules\";\n+                                    self.r.session.span_err(path.span, msg);\n+                                    ty::Visibility::Public\n+                                }\n+                            }\n+                        } else {\n+                            expected_found_error(self, res);\n+                            ty::Visibility::Public\n+                        }\n+                    }\n+                    PathResult::Module(..) => {\n+                        self.r.session.span_err(path.span, \"visibility must resolve to a module\");\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::NonModule(partial_res) => {\n+                        expected_found_error(self, partial_res.base_res());\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::Failed { span, label, suggestion, .. } => {\n+                        self.r.report_error(\n+                            span, ResolutionError::FailedToResolve { label, suggestion }\n+                        );\n+                        ty::Visibility::Public\n+                    }\n+                    PathResult::Indeterminate => {\n+                        span_err!(self.r.session, path.span, E0578,\n+                                  \"cannot determine resolution for the visibility\");\n+                        ty::Visibility::Public\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n         if !field_names.is_empty() {\n-            self.field_names.insert(def_id, field_names);\n+            self.r.field_names.insert(def_id, field_names);\n         }\n     }\n-}\n \n-impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n         block.stmts.iter().any(|statement| match statement.node {\n@@ -109,6 +290,54 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         })\n     }\n \n+    // Add an import directive to the current module.\n+    fn add_import_directive(\n+        &mut self,\n+        module_path: Vec<Segment>,\n+        subclass: ImportDirectiveSubclass<'a>,\n+        span: Span,\n+        id: NodeId,\n+        item: &ast::Item,\n+        root_span: Span,\n+        root_id: NodeId,\n+        vis: ty::Visibility,\n+    ) {\n+        let parent_scope = &self.parent_scope;\n+        let current_module = parent_scope.module;\n+        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+            parent_scope: parent_scope.clone(),\n+            module_path,\n+            imported_module: Cell::new(None),\n+            subclass,\n+            span,\n+            id,\n+            use_span: item.span,\n+            use_span_with_attributes: item.span_with_attributes(),\n+            has_attributes: !item.attrs.is_empty(),\n+            root_span,\n+            root_id,\n+            vis: Cell::new(vis),\n+            used: Cell::new(false),\n+        });\n+\n+        debug!(\"add_import_directive({:?})\", directive);\n+\n+        self.r.indeterminate_imports.push(directive);\n+        match directive.subclass {\n+            SingleImport { target, type_ns_only, .. } => {\n+                self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n+                    resolution.add_single_import(directive);\n+                });\n+            }\n+            // We don't add prelude imports to the globs since they only affect lexical scopes,\n+            // which are not relevant to import resolution.\n+            GlobImport { is_prelude: true, .. } => {}\n+            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n+            _ => unreachable!(),\n+        }\n+    }\n+\n     fn build_reduced_graph_for_use_tree(\n         &mut self,\n         // This particular use tree\n@@ -117,7 +346,6 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         parent_prefix: &[Segment],\n         nested: bool,\n         // The whole `use` item\n-        parent_scope: &ParentScope<'a>,\n         item: &Item,\n         vis: ty::Visibility,\n         root_span: Span,\n@@ -250,7 +478,6 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                     root_span,\n                     item.id,\n                     vis,\n-                    parent_scope.clone(),\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -267,7 +494,6 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                     root_span,\n                     item.id,\n                     vis,\n-                    parent_scope.clone(),\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -298,7 +524,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                         // This particular use tree\n                         tree, id, &prefix, true,\n                         // The whole `use` item\n-                        parent_scope, item, vis, root_span,\n+                        item, vis, root_span,\n                     );\n                 }\n \n@@ -322,7 +548,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                         // This particular use tree\n                         &tree, id, &prefix, true,\n                         // The whole `use` item\n-                        parent_scope, item, ty::Visibility::Invisible, root_span,\n+                        item, ty::Visibility::Invisible, root_span,\n                     );\n                 }\n             }\n@@ -331,20 +557,20 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n-        let parent_scope = &self.parent_scope.clone();\n+        let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident.gensym_if_underscore();\n         let sp = item.span;\n-        let vis = self.r.resolve_visibility(&item.vis, parent_scope);\n+        let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n                     // This particular use tree\n                     use_tree, item.id, &[], false,\n                     // The whole `use` item\n-                    parent_scope, item, vis, use_tree.span,\n+                    item, vis, use_tree.span,\n                 );\n             }\n \n@@ -376,13 +602,13 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                     }\n                 }\n \n-                let used = self.process_legacy_macro_imports(item, module, parent_scope);\n+                let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n                 let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent_scope: parent_scope.clone(),\n+                    parent_scope: self.parent_scope.clone(),\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -459,7 +685,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                self.r.define_macro(item, parent_scope);\n+                self.define_macro(item);\n             }\n \n             // These items live in the type namespace.\n@@ -515,14 +741,14 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n                 // Record field names for error reporting.\n                 let field_names = struct_def.fields().iter().filter_map(|field| {\n-                    let field_vis = self.r.resolve_visibility(&field.vis, parent_scope);\n+                    let field_vis = self.resolve_visibility(&field.vis);\n                     if ctor_vis.is_at_least(field_vis, &*self.r) {\n                         ctor_vis = field_vis;\n                     }\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n                 let item_def_id = self.r.definitions.local_def_id(item.id);\n-                self.r.insert_field_names(item_def_id, field_names);\n+                self.insert_field_names(item_def_id, field_names);\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n@@ -542,14 +768,18 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n-                    self.r.resolve_visibility(&field.vis, parent_scope);\n+                    self.resolve_visibility(&field.vis);\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n                 let item_def_id = self.r.definitions.local_def_id(item.id);\n-                self.r.insert_field_names(item_def_id, field_names);\n+                self.insert_field_names(item_def_id, field_names);\n             }\n \n-            ItemKind::Impl(..) => {}\n+            ItemKind::Impl(.., ref impl_items) => {\n+                for impl_item in impl_items {\n+                    self.resolve_visibility(&impl_item.vis);\n+                }\n+            }\n \n             ItemKind::Trait(..) => {\n                 let def_id = self.r.definitions.local_def_id(item.id);\n@@ -619,7 +849,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         };\n         let parent = self.parent_scope.module;\n         let expansion = self.parent_scope.expansion;\n-        let vis = self.r.resolve_visibility(&item.vis, &self.parent_scope);\n+        let vis = self.resolve_visibility(&item.vis);\n         self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n     }\n \n@@ -636,9 +866,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n             self.parent_scope.module = module; // Descend into the block.\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_res(\n         &mut self,\n@@ -654,12 +882,12 @@ impl<'a> Resolver<'a> {\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n             | Res::Def(kind @ DefKind::Enum, def_id) => {\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n             Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n@@ -668,140 +896,61 @@ impl<'a> Resolver<'a> {\n             | Res::Def(DefKind::TraitAlias, _)\n             | Res::PrimTy(..)\n             | Res::ToolMod => {\n-                self.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n             }\n             Res::Def(DefKind::Fn, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n             | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n             }\n             Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n-                        self.cstore.def_key(def_id).parent\n+                        self.r.cstore.def_key(def_id).parent\n                             .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.struct_constructors.insert(struct_def_id, (res, vis));\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n                 }\n             }\n             Res::Def(DefKind::Trait, def_id) => {\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n                                              expansion,\n                                              span);\n-                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n-                for child in self.cstore.item_children_untracked(def_id, self.session) {\n+                for child in self.r.cstore.item_children_untracked(def_id, self.r.session) {\n                     let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n                     let ns = if let Res::Def(DefKind::AssocTy, _) = res {\n                         TypeNS\n                     } else { ValueNS };\n-                    self.define(module, child.ident, ns,\n+                    self.r.define(module, child.ident, ns,\n                                 (res, ty::Visibility::Public, DUMMY_SP, expansion));\n \n-                    if self.cstore.associated_item_cloned_untracked(child.res.def_id())\n+                    if self.r.cstore.associated_item_cloned_untracked(child.res.def_id())\n                            .method_has_self_argument {\n-                        self.has_self.insert(res.def_id());\n+                        self.r.has_self.insert(res.def_id());\n                     }\n                 }\n                 module.populated.set(true);\n             }\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = self.cstore.struct_field_names_untracked(def_id);\n+                let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n             }\n             _ => bug!(\"unexpected resolution: {:?}\", res)\n         }\n     }\n \n-    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n-        if def_id.krate == LOCAL_CRATE {\n-            return self.module_map[&def_id]\n-        }\n-\n-        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n-        if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n-            return module;\n-        }\n-\n-        let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n-        } else {\n-            let def_key = self.cstore.def_key(def_id);\n-            (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n-             Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n-        };\n-\n-        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n-        let module = self.arenas.alloc_module(ModuleData::new(\n-            parent, kind, def_id, ExpnId::root(), DUMMY_SP\n-        ));\n-        self.extern_module_map.insert((def_id, macros_only), module);\n-        module\n-    }\n-\n-    pub fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n-        let def_id = match self.macro_defs.get(&expn_id) {\n-            Some(def_id) => *def_id,\n-            None => return self.graph_root,\n-        };\n-        if let Some(id) = self.definitions.as_local_node_id(def_id) {\n-            self.local_macro_def_scopes[&id]\n-        } else if self.is_builtin_macro(Some(def_id)) {\n-            self.injected_crate.unwrap_or(self.graph_root)\n-        } else {\n-            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_module(module_def_id)\n-        }\n-    }\n-\n-    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n-        match res {\n-            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n-            Res::NonMacroAttr(attr_kind) =>\n-                Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n-            _ => None,\n-        }\n-    }\n-\n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n-        if let Some(ext) = self.macro_map.get(&def_id) {\n-            return Some(ext.clone());\n-        }\n-\n-        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n-            LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return Some(ext),\n-        };\n-\n-        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n-        self.macro_map.insert(def_id, ext.clone());\n-        Some(ext)\n-    }\n-\n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n-        if module.populated.get() { return }\n-        let def_id = module.def_id().unwrap();\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n-            let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            self.build_reduced_graph_for_external_crate_res(module, child);\n-        }\n-        module.populated.set(true)\n-    }\n-}\n-\n-impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     fn legacy_import_macro(&mut self,\n                            name: Name,\n                            binding: &'a NameBinding<'a>,\n@@ -816,8 +965,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     }\n \n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>,\n-                                    parent_scope: &ParentScope<'a>) -> bool {\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n@@ -852,11 +1000,11 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n             }\n         }\n \n-        let arenas = self.r.arenas;\n-        let macro_use_directive = |span| arenas.alloc_import_directive(ImportDirective {\n+        let macro_use_directive =\n+                |this: &Self, span| this.r.arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent_scope: parent_scope.clone(),\n+            parent_scope: this.parent_scope.clone(),\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             use_span_with_attributes: item.span_with_attributes(),\n@@ -869,9 +1017,9 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n             used: Cell::new(false),\n         });\n \n-        let allow_shadowing = parent_scope.expansion == ExpnId::root();\n+        let allow_shadowing = self.parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n-            let directive = macro_use_directive(span);\n+            let directive = macro_use_directive(self, span);\n             self.r.potentially_unused_imports.push(directive);\n             module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n                 let imported_binding = self.r.import(binding, directive);\n@@ -883,12 +1031,12 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n-                    parent_scope,\n+                    &self.parent_scope,\n                     false,\n                     ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(ident.span);\n+                    let directive = macro_use_directive(self, ident.span);\n                     self.r.potentially_unused_imports.push(directive);\n                     let imported_binding = self.r.import(binding, directive);\n                     self.legacy_import_macro(ident.name, imported_binding,\n@@ -924,15 +1072,8 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n         false\n     }\n-}\n \n-pub struct BuildReducedGraphVisitor<'a, 'b> {\n-    pub r: &'a mut Resolver<'b>,\n-    pub parent_scope: ParentScope<'b>,\n-}\n-\n-impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> &'a InvocationData<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n@@ -947,11 +1088,83 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         invocation_data\n     }\n+\n+    fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n+        if attr::contains_name(&item.attrs, sym::proc_macro) {\n+            return Some((MacroKind::Bang, item.ident, item.span));\n+        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n+            return Some((MacroKind::Attr, item.ident, item.span));\n+        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n+            if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n+                if let Some(ident) = nested_meta.ident() {\n+                    return Some((MacroKind::Derive, ident, ident.span));\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n+        let parent_scope = &self.parent_scope;\n+        let expansion = parent_scope.expansion;\n+        let (ext, ident, span, is_legacy) = match &item.node {\n+            ItemKind::MacroDef(def) => {\n+                let ext = self.r.compile_macro(item, self.r.session.edition());\n+                (ext, item.ident, item.span, def.legacy)\n+            }\n+            ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n+                Some((macro_kind, ident, span)) => {\n+                    self.r.proc_macro_stubs.insert(item.id);\n+                    (self.r.dummy_ext(macro_kind), ident, span, false)\n+                }\n+                None => return parent_scope.legacy,\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let def_id = self.r.definitions.local_def_id(item.id);\n+        let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n+        self.r.macro_map.insert(def_id, ext);\n+        self.r.local_macro_def_scopes.insert(item.id, parent_scope.module);\n+\n+        if is_legacy {\n+            let ident = ident.modern();\n+            self.r.macro_names.insert(ident);\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n+            let vis = if is_macro_export {\n+                ty::Visibility::Public\n+            } else {\n+                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+            };\n+            let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n+            self.r.set_binding_parent_module(binding, parent_scope.module);\n+            self.r.all_macros.insert(ident.name, res);\n+            if is_macro_export {\n+                let module = self.r.graph_root;\n+                self.r.define(module, ident, MacroNS,\n+                            (res, vis, span, expansion, IsMacroExport));\n+            } else {\n+                self.r.check_reserved_macro_name(ident, res);\n+                self.r.unused_macros.insert(item.id, span);\n+            }\n+            LegacyScope::Binding(self.r.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent_legacy_scope: parent_scope.legacy, binding, ident\n+            }))\n+        } else {\n+            let module = parent_scope.module;\n+            let vis = self.resolve_visibility(&item.vis);\n+            if vis != ty::Visibility::Public {\n+                self.r.unused_macros.insert(item.id, span);\n+            }\n+            self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n+            self.parent_scope.legacy\n+        }\n+    }\n }\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n-        fn $visit(&mut self, node: &'a $ty) {\n+        fn $visit(&mut self, node: &'b $ty) {\n             if let $invoc(..) = node.node {\n                 self.visit_invoc(node.id);\n             } else {\n@@ -961,16 +1174,16 @@ macro_rules! method {\n     }\n }\n \n-impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n-    fn visit_item(&mut self, item: &'a Item) {\n+    fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.parent_scope.legacy = self.r.define_macro(item, &self.parent_scope);\n+                self.parent_scope.legacy = self.define_macro(item);\n                 return\n             }\n             ItemKind::Mac(..) => {\n@@ -991,15 +1204,15 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n             self.parent_scope.legacy = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'b ForeignItem) {\n         if let ForeignItemKind::Macro(_) = foreign_item.node {\n             self.visit_invoc(foreign_item.id);\n             return;\n@@ -1009,7 +1222,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n-    fn visit_block(&mut self, block: &'a Block) {\n+    fn visit_block(&mut self, block: &'b Block) {\n         let orig_current_module = self.parent_scope.module;\n         let orig_current_legacy_scope = self.parent_scope.legacy;\n         self.build_reduced_graph_for_block(block);\n@@ -1018,7 +1231,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         self.parent_scope.legacy = orig_current_legacy_scope;\n     }\n \n-    fn visit_trait_item(&mut self, item: &'a TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'b TraitItem) {\n         let parent = self.parent_scope.module;\n \n         if let TraitItemKind::Macro(_) = item.node {\n@@ -1059,7 +1272,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n             self.parent_scope.module.builtin_attrs.borrow_mut().push((\n                 attr.path.segments[0].ident, self.parent_scope.clone()"}, {"sha": "239042505d020adee83d020085513dd4c9ffb491", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 227, "deletions": 6, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "patch": "@@ -1,9 +1,9 @@\n use GenericParameters::*;\n+use RibKind::*;\n \n-use crate::{path_names_to_string, AliasPossibility, BindingError, CrateLint, LexicalScopeBinding};\n+use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n-use crate::{PathSource, ResolutionError, Resolver, Rib, RibKind, Segment, UseError};\n-use crate::RibKind::*;\n+use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use log::debug;\n use rustc::{bug, lint, span_bug};\n@@ -66,6 +66,230 @@ impl PatternSource {\n     }\n }\n \n+/// The rib kind restricts certain accesses,\n+/// e.g. to a `Res::Local` of an outer item.\n+#[derive(Copy, Clone, Debug)]\n+crate enum RibKind<'a> {\n+    /// No restriction needs to be applied.\n+    NormalRibKind,\n+\n+    /// We passed through an impl or trait and are now in one of its\n+    /// methods or associated types. Allow references to ty params that impl or trait\n+    /// binds. Disallow any other upvars (including other ty params that are\n+    /// upvars).\n+    AssocItemRibKind,\n+\n+    /// We passed through a function definition. Disallow upvars.\n+    /// Permit only those const parameters that are specified in the function's generics.\n+    FnItemRibKind,\n+\n+    /// We passed through an item scope. Disallow upvars.\n+    ItemRibKind,\n+\n+    /// We're in a constant item. Can't refer to dynamic stuff.\n+    ConstantItemRibKind,\n+\n+    /// We passed through a module.\n+    ModuleRibKind(Module<'a>),\n+\n+    /// We passed through a `macro_rules!` statement\n+    MacroDefinition(DefId),\n+\n+    /// All bindings in this rib are type parameters that can't be used\n+    /// from the default of a type parameter because they're not declared\n+    /// before said type parameter. Also see the `visit_generics` override.\n+    ForwardTyParamBanRibKind,\n+\n+    /// We forbid the use of type parameters as the types of const parameters.\n+    TyParamAsConstParamTy,\n+}\n+\n+/// A single local scope.\n+///\n+/// A rib represents a scope names can live in. Note that these appear in many places, not just\n+/// around braces. At any place where the list of accessible names (of the given namespace)\n+/// changes or a new restrictions on the name accessibility are introduced, a new rib is put onto a\n+/// stack. This may be, for example, a `let` statement (because it introduces variables), a macro,\n+/// etc.\n+///\n+/// Different [rib kinds](enum.RibKind) are transparent for different names.\n+///\n+/// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n+/// resolving, the name is looked up from inside out.\n+#[derive(Debug)]\n+crate struct Rib<'a, R = Res> {\n+    pub bindings: FxHashMap<Ident, R>,\n+    pub kind: RibKind<'a>,\n+}\n+\n+impl<'a, R> Rib<'a, R> {\n+    fn new(kind: RibKind<'a>) -> Rib<'a, R> {\n+        Rib {\n+            bindings: Default::default(),\n+            kind,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+crate enum AliasPossibility {\n+    No,\n+    Maybe,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+crate enum PathSource<'a> {\n+    // Type paths `Path`.\n+    Type,\n+    // Trait paths in bounds or impls.\n+    Trait(AliasPossibility),\n+    // Expression paths `path`, with optional parent context.\n+    Expr(Option<&'a Expr>),\n+    // Paths in path patterns `Path`.\n+    Pat,\n+    // Paths in struct expressions and patterns `Path { .. }`.\n+    Struct,\n+    // Paths in tuple struct patterns `Path(..)`.\n+    TupleStruct,\n+    // `m::A::B` in `<T as m::A>::B::C`.\n+    TraitItem(Namespace),\n+}\n+\n+impl<'a> PathSource<'a> {\n+    fn namespace(self) -> Namespace {\n+        match self {\n+            PathSource::Type | PathSource::Trait(_) | PathSource::Struct => TypeNS,\n+            PathSource::Expr(..) | PathSource::Pat | PathSource::TupleStruct => ValueNS,\n+            PathSource::TraitItem(ns) => ns,\n+        }\n+    }\n+\n+    fn defer_to_typeck(self) -> bool {\n+        match self {\n+            PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n+            PathSource::Struct | PathSource::TupleStruct => true,\n+            PathSource::Trait(_) | PathSource::TraitItem(..) => false,\n+        }\n+    }\n+\n+    fn descr_expected(self) -> &'static str {\n+        match self {\n+            PathSource::Type => \"type\",\n+            PathSource::Trait(_) => \"trait\",\n+            PathSource::Pat => \"unit struct/variant or constant\",\n+            PathSource::Struct => \"struct, variant or union type\",\n+            PathSource::TupleStruct => \"tuple struct/variant\",\n+            PathSource::TraitItem(ns) => match ns {\n+                TypeNS => \"associated type\",\n+                ValueNS => \"method or associated constant\",\n+                MacroNS => bug!(\"associated macro\"),\n+            },\n+            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n+                // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n+                // this is not precise but usually more helpful than just \"value\".\n+                Some(&ExprKind::Call(..)) => \"function\",\n+                _ => \"value\",\n+            },\n+        }\n+    }\n+\n+    crate fn is_expected(self, res: Res) -> bool {\n+        match self {\n+            PathSource::Type => match res {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::Enum, _)\n+                | Res::Def(DefKind::Trait, _)\n+                | Res::Def(DefKind::TraitAlias, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssocTy, _)\n+                | Res::PrimTy(..)\n+                | Res::Def(DefKind::TyParam, _)\n+                | Res::SelfTy(..)\n+                | Res::Def(DefKind::OpaqueTy, _)\n+                | Res::Def(DefKind::ForeignTy, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Trait(AliasPossibility::No) => match res {\n+                Res::Def(DefKind::Trait, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Trait(AliasPossibility::Maybe) => match res {\n+                Res::Def(DefKind::Trait, _) => true,\n+                Res::Def(DefKind::TraitAlias, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Expr(..) => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n+                | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+                | Res::Def(DefKind::Const, _)\n+                | Res::Def(DefKind::Static, _)\n+                | Res::Local(..)\n+                | Res::Def(DefKind::Fn, _)\n+                | Res::Def(DefKind::Method, _)\n+                | Res::Def(DefKind::AssocConst, _)\n+                | Res::SelfCtor(..)\n+                | Res::Def(DefKind::ConstParam, _) => true,\n+                _ => false,\n+            },\n+            PathSource::Pat => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) |\n+                Res::SelfCtor(..) => true,\n+                _ => false,\n+            },\n+            PathSource::TupleStruct => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..) => true,\n+                _ => false,\n+            },\n+            PathSource::Struct => match res {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::Variant, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssocTy, _)\n+                | Res::SelfTy(..) => true,\n+                _ => false,\n+            },\n+            PathSource::TraitItem(ns) => match res {\n+                Res::Def(DefKind::AssocConst, _)\n+                | Res::Def(DefKind::Method, _) if ns == ValueNS => true,\n+                Res::Def(DefKind::AssocTy, _) if ns == TypeNS => true,\n+                _ => false,\n+            },\n+        }\n+    }\n+\n+    fn error_code(self, has_unexpected_resolution: bool) -> &'static str {\n+        __diagnostic_used!(E0404);\n+        __diagnostic_used!(E0405);\n+        __diagnostic_used!(E0412);\n+        __diagnostic_used!(E0422);\n+        __diagnostic_used!(E0423);\n+        __diagnostic_used!(E0425);\n+        __diagnostic_used!(E0531);\n+        __diagnostic_used!(E0532);\n+        __diagnostic_used!(E0573);\n+        __diagnostic_used!(E0574);\n+        __diagnostic_used!(E0575);\n+        __diagnostic_used!(E0576);\n+        match (self, has_unexpected_resolution) {\n+            (PathSource::Trait(_), true) => \"E0404\",\n+            (PathSource::Trait(_), false) => \"E0405\",\n+            (PathSource::Type, true) => \"E0573\",\n+            (PathSource::Type, false) => \"E0412\",\n+            (PathSource::Struct, true) => \"E0574\",\n+            (PathSource::Struct, false) => \"E0422\",\n+            (PathSource::Expr(..), true) => \"E0423\",\n+            (PathSource::Expr(..), false) => \"E0425\",\n+            (PathSource::Pat, true) | (PathSource::TupleStruct, true) => \"E0532\",\n+            (PathSource::Pat, false) | (PathSource::TupleStruct, false) => \"E0531\",\n+            (PathSource::TraitItem(..), true) => \"E0575\",\n+            (PathSource::TraitItem(..), false) => \"E0576\",\n+        }\n+    }\n+}\n+\n struct LateResolutionVisitor<'a, 'b> {\n     r: &'b mut Resolver<'a>,\n \n@@ -786,9 +1010,6 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                             this.with_self_struct_ctor_rib(item_def_id, |this| {\n                                 debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n                                 for impl_item in impl_items {\n-                                    this.r.resolve_visibility(\n-                                        &impl_item.vis, &this.parent_scope\n-                                    );\n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n                                                                           AssocItemRibKind);"}, {"sha": "35cf720ad8742403f05742eccee07b5eed4b8c81", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "patch": "@@ -1,9 +1,9 @@\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n-use crate::{PathResult, PathSource, RibKind, Segment};\n+use crate::{PathResult, PathSource, Segment};\n use crate::path_names_to_string;\n use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n-use crate::late::LateResolutionVisitor;\n+use crate::late::{LateResolutionVisitor, RibKind};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;"}, {"sha": "83dc40c097b2925613ee8c431591ca33b2f7f3d2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 331, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(crate_visibility_modifier)]\n@@ -13,22 +11,19 @@\n pub use rustc::hir::def::{Namespace, PerNS};\n \n use Determinacy::*;\n-use RibKind::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::lint;\n-use rustc::hir::def::{\n-    self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap\n-};\n+use rustc::hir::def::{self, DefKind, PartialRes, CtorOf, NonMacroAttrKind, ExportMap};\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::{TraitMap, GlobMap};\n use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n-use rustc::{bug, span_bug};\n+use rustc::span_bug;\n \n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n@@ -40,7 +35,7 @@ use syntax::symbol::{Symbol, kw, sym};\n \n use syntax::visit::{self, Visitor};\n use syntax::attr;\n-use syntax::ast::{CRATE_NODE_ID, Crate, Expr, ExprKind};\n+use syntax::ast::{CRATE_NODE_ID, Crate};\n use syntax::ast::{ItemKind, Path};\n use syntax::{span_err, struct_span_err, unwrap_or};\n \n@@ -57,6 +52,7 @@ use rustc_data_structures::sync::Lrc;\n \n use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n+use late::{PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n@@ -199,165 +195,6 @@ enum ResolutionError<'a> {\n     ConstParamDependentOnTypeParam,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum AliasPossibility {\n-    No,\n-    Maybe,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum PathSource<'a> {\n-    // Type paths `Path`.\n-    Type,\n-    // Trait paths in bounds or impls.\n-    Trait(AliasPossibility),\n-    // Expression paths `path`, with optional parent context.\n-    Expr(Option<&'a Expr>),\n-    // Paths in path patterns `Path`.\n-    Pat,\n-    // Paths in struct expressions and patterns `Path { .. }`.\n-    Struct,\n-    // Paths in tuple struct patterns `Path(..)`.\n-    TupleStruct,\n-    // `m::A::B` in `<T as m::A>::B::C`.\n-    TraitItem(Namespace),\n-}\n-\n-impl<'a> PathSource<'a> {\n-    fn namespace(self) -> Namespace {\n-        match self {\n-            PathSource::Type | PathSource::Trait(_) | PathSource::Struct => TypeNS,\n-            PathSource::Expr(..) | PathSource::Pat | PathSource::TupleStruct => ValueNS,\n-            PathSource::TraitItem(ns) => ns,\n-        }\n-    }\n-\n-    fn defer_to_typeck(self) -> bool {\n-        match self {\n-            PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n-            PathSource::Struct | PathSource::TupleStruct => true,\n-            PathSource::Trait(_) | PathSource::TraitItem(..) => false,\n-        }\n-    }\n-\n-    fn descr_expected(self) -> &'static str {\n-        match self {\n-            PathSource::Type => \"type\",\n-            PathSource::Trait(_) => \"trait\",\n-            PathSource::Pat => \"unit struct/variant or constant\",\n-            PathSource::Struct => \"struct, variant or union type\",\n-            PathSource::TupleStruct => \"tuple struct/variant\",\n-            PathSource::TraitItem(ns) => match ns {\n-                TypeNS => \"associated type\",\n-                ValueNS => \"method or associated constant\",\n-                MacroNS => bug!(\"associated macro\"),\n-            },\n-            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n-                // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n-                // this is not precise but usually more helpful than just \"value\".\n-                Some(&ExprKind::Call(..)) => \"function\",\n-                _ => \"value\",\n-            },\n-        }\n-    }\n-\n-    fn is_expected(self, res: Res) -> bool {\n-        match self {\n-            PathSource::Type => match res {\n-                Res::Def(DefKind::Struct, _)\n-                | Res::Def(DefKind::Union, _)\n-                | Res::Def(DefKind::Enum, _)\n-                | Res::Def(DefKind::Trait, _)\n-                | Res::Def(DefKind::TraitAlias, _)\n-                | Res::Def(DefKind::TyAlias, _)\n-                | Res::Def(DefKind::AssocTy, _)\n-                | Res::PrimTy(..)\n-                | Res::Def(DefKind::TyParam, _)\n-                | Res::SelfTy(..)\n-                | Res::Def(DefKind::OpaqueTy, _)\n-                | Res::Def(DefKind::ForeignTy, _) => true,\n-                _ => false,\n-            },\n-            PathSource::Trait(AliasPossibility::No) => match res {\n-                Res::Def(DefKind::Trait, _) => true,\n-                _ => false,\n-            },\n-            PathSource::Trait(AliasPossibility::Maybe) => match res {\n-                Res::Def(DefKind::Trait, _) => true,\n-                Res::Def(DefKind::TraitAlias, _) => true,\n-                _ => false,\n-            },\n-            PathSource::Expr(..) => match res {\n-                Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n-                | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n-                | Res::Def(DefKind::Const, _)\n-                | Res::Def(DefKind::Static, _)\n-                | Res::Local(..)\n-                | Res::Def(DefKind::Fn, _)\n-                | Res::Def(DefKind::Method, _)\n-                | Res::Def(DefKind::AssocConst, _)\n-                | Res::SelfCtor(..)\n-                | Res::Def(DefKind::ConstParam, _) => true,\n-                _ => false,\n-            },\n-            PathSource::Pat => match res {\n-                Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n-                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) |\n-                Res::SelfCtor(..) => true,\n-                _ => false,\n-            },\n-            PathSource::TupleStruct => match res {\n-                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..) => true,\n-                _ => false,\n-            },\n-            PathSource::Struct => match res {\n-                Res::Def(DefKind::Struct, _)\n-                | Res::Def(DefKind::Union, _)\n-                | Res::Def(DefKind::Variant, _)\n-                | Res::Def(DefKind::TyAlias, _)\n-                | Res::Def(DefKind::AssocTy, _)\n-                | Res::SelfTy(..) => true,\n-                _ => false,\n-            },\n-            PathSource::TraitItem(ns) => match res {\n-                Res::Def(DefKind::AssocConst, _)\n-                | Res::Def(DefKind::Method, _) if ns == ValueNS => true,\n-                Res::Def(DefKind::AssocTy, _) if ns == TypeNS => true,\n-                _ => false,\n-            },\n-        }\n-    }\n-\n-    fn error_code(self, has_unexpected_resolution: bool) -> &'static str {\n-        __diagnostic_used!(E0404);\n-        __diagnostic_used!(E0405);\n-        __diagnostic_used!(E0412);\n-        __diagnostic_used!(E0422);\n-        __diagnostic_used!(E0423);\n-        __diagnostic_used!(E0425);\n-        __diagnostic_used!(E0531);\n-        __diagnostic_used!(E0532);\n-        __diagnostic_used!(E0573);\n-        __diagnostic_used!(E0574);\n-        __diagnostic_used!(E0575);\n-        __diagnostic_used!(E0576);\n-        match (self, has_unexpected_resolution) {\n-            (PathSource::Trait(_), true) => \"E0404\",\n-            (PathSource::Trait(_), false) => \"E0405\",\n-            (PathSource::Type, true) => \"E0573\",\n-            (PathSource::Type, false) => \"E0412\",\n-            (PathSource::Struct, true) => \"E0574\",\n-            (PathSource::Struct, false) => \"E0422\",\n-            (PathSource::Expr(..), true) => \"E0423\",\n-            (PathSource::Expr(..), false) => \"E0425\",\n-            (PathSource::Pat, true) | (PathSource::TupleStruct, true) => \"E0532\",\n-            (PathSource::Pat, false) | (PathSource::TupleStruct, false) => \"E0531\",\n-            (PathSource::TraitItem(..), true) => \"E0575\",\n-            (PathSource::TraitItem(..), false) => \"E0576\",\n-        }\n-    }\n-}\n-\n // A minimal representation of a path segment. We use this in resolve because\n // we synthesize 'path segments' which don't have the rest of an AST or HIR\n // `PathSegment`.\n@@ -463,71 +300,6 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     }\n }\n \n-/// The rib kind restricts certain accesses,\n-/// e.g. to a `Res::Local` of an outer item.\n-#[derive(Copy, Clone, Debug)]\n-enum RibKind<'a> {\n-    /// No restriction needs to be applied.\n-    NormalRibKind,\n-\n-    /// We passed through an impl or trait and are now in one of its\n-    /// methods or associated types. Allow references to ty params that impl or trait\n-    /// binds. Disallow any other upvars (including other ty params that are\n-    /// upvars).\n-    AssocItemRibKind,\n-\n-    /// We passed through a function definition. Disallow upvars.\n-    /// Permit only those const parameters that are specified in the function's generics.\n-    FnItemRibKind,\n-\n-    /// We passed through an item scope. Disallow upvars.\n-    ItemRibKind,\n-\n-    /// We're in a constant item. Can't refer to dynamic stuff.\n-    ConstantItemRibKind,\n-\n-    /// We passed through a module.\n-    ModuleRibKind(Module<'a>),\n-\n-    /// We passed through a `macro_rules!` statement\n-    MacroDefinition(DefId),\n-\n-    /// All bindings in this rib are type parameters that can't be used\n-    /// from the default of a type parameter because they're not declared\n-    /// before said type parameter. Also see the `visit_generics` override.\n-    ForwardTyParamBanRibKind,\n-\n-    /// We forbid the use of type parameters as the types of const parameters.\n-    TyParamAsConstParamTy,\n-}\n-\n-/// A single local scope.\n-///\n-/// A rib represents a scope names can live in. Note that these appear in many places, not just\n-/// around braces. At any place where the list of accessible names (of the given namespace)\n-/// changes or a new restrictions on the name accessibility are introduced, a new rib is put onto a\n-/// stack. This may be, for example, a `let` statement (because it introduces variables), a macro,\n-/// etc.\n-///\n-/// Different [rib kinds](enum.RibKind) are transparent for different names.\n-///\n-/// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n-/// resolving, the name is looked up from inside out.\n-#[derive(Debug)]\n-struct Rib<'a, R = Res> {\n-    bindings: FxHashMap<Ident, R>,\n-    kind: RibKind<'a>,\n-}\n-\n-impl<'a, R> Rib<'a, R> {\n-    fn new(kind: RibKind<'a>) -> Rib<'a, R> {\n-        Rib {\n-            bindings: Default::default(),\n-            kind,\n-        }\n-    }\n-}\n-\n /// An intermediate resolution result.\n ///\n /// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n@@ -2405,105 +2177,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_visibility(\n-        &mut self, vis: &ast::Visibility, parent_scope: &ParentScope<'a>\n-    ) -> ty::Visibility {\n-        match vis.node {\n-            ast::VisibilityKind::Public => ty::Visibility::Public,\n-            ast::VisibilityKind::Crate(..) => {\n-                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n-            }\n-            ast::VisibilityKind::Inherited => {\n-                ty::Visibility::Restricted(parent_scope.module.normal_ancestor_id)\n-            }\n-            ast::VisibilityKind::Restricted { ref path, id, .. } => {\n-                // For visibilities we are not ready to provide correct implementation of \"uniform\n-                // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n-                // On 2015 edition visibilities are resolved as crate-relative by default,\n-                // so we are prepending a root segment if necessary.\n-                let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n-                let crate_root = if ident.is_path_segment_keyword() {\n-                    None\n-                } else if ident.span.rust_2018() {\n-                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n-                    self.session.struct_span_err(ident.span, msg)\n-                        .span_suggestion(\n-                            path.span,\n-                            \"try\",\n-                            format!(\"crate::{}\", path),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n-                    return ty::Visibility::Public;\n-                } else {\n-                    let ctxt = ident.span.ctxt();\n-                    Some(Segment::from_ident(Ident::new(\n-                        kw::PathRoot, path.span.shrink_to_lo().with_ctxt(ctxt)\n-                    )))\n-                };\n-\n-                let segments = crate_root.into_iter()\n-                    .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n-                let expected_found_error = |this: &Self, res: Res| {\n-                    let path_str = Segment::names_to_string(&segments);\n-                    struct_span_err!(this.session, path.span, E0577,\n-                                     \"expected module, found {} `{}`\", res.descr(), path_str)\n-                        .span_label(path.span, \"not a module\").emit();\n-                };\n-                match self.resolve_path(\n-                    &segments,\n-                    Some(TypeNS),\n-                    parent_scope,\n-                    true,\n-                    path.span,\n-                    CrateLint::SimplePath(id),\n-                ) {\n-                    PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n-                        let res = module.res().expect(\"visibility resolved to unnamed block\");\n-                        self.record_partial_res(id, PartialRes::new(res));\n-                        if module.is_normal() {\n-                            if res == Res::Err {\n-                                ty::Visibility::Public\n-                            } else {\n-                                let vis = ty::Visibility::Restricted(res.def_id());\n-                                if self.is_accessible_from(vis, parent_scope.module) {\n-                                    vis\n-                                } else {\n-                                    let msg =\n-                                        \"visibilities can only be restricted to ancestor modules\";\n-                                    self.session.span_err(path.span, msg);\n-                                    ty::Visibility::Public\n-                                }\n-                            }\n-                        } else {\n-                            expected_found_error(self, res);\n-                            ty::Visibility::Public\n-                        }\n-                    }\n-                    PathResult::Module(..) => {\n-                        self.session.span_err(path.span, \"visibility must resolve to a module\");\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::NonModule(partial_res) => {\n-                        expected_found_error(self, partial_res.base_res());\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Failed { span, label, suggestion, .. } => {\n-                        self.report_error(\n-                            span, ResolutionError::FailedToResolve { label, suggestion }\n-                        );\n-                        ty::Visibility::Public\n-                    }\n-                    PathResult::Indeterminate => {\n-                        span_err!(self.session, path.span, E0578,\n-                                  \"cannot determine resolution for the visibility\");\n-                        ty::Visibility::Public\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }"}, {"sha": "1b6599e20e9a2d4ff91eba1876ec823df2b96083", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "patch": "@@ -3,15 +3,14 @@ use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope,\n use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n-use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n+use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::resolve_imports::ImportResolver;\n-use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident, ItemKind};\n-use syntax::attr::{self, StabilityLevel};\n+use syntax::ast::{self, Ident};\n+use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n@@ -115,21 +114,6 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n     }\n }\n \n-fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-    if attr::contains_name(&item.attrs, sym::proc_macro) {\n-        return Some((MacroKind::Bang, item.ident, item.span));\n-    } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n-        return Some((MacroKind::Attr, item.ident, item.span));\n-    } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n-        if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n-            if let Some(ident) = nested_meta.ident() {\n-                return Some((MacroKind::Derive, ident, ident.span));\n-            }\n-        }\n-    }\n-    None\n-}\n-\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -887,62 +871,4 @@ impl<'a> Resolver<'a> {\n \n         Lrc::new(result)\n     }\n-\n-    pub fn define_macro(\n-        &mut self, item: &ast::Item, parent_scope: &ParentScope<'a>,\n-    ) -> LegacyScope<'a> {\n-        let expansion = parent_scope.expansion;\n-        let (ext, ident, span, is_legacy) = match &item.node {\n-            ItemKind::MacroDef(def) => {\n-                let ext = self.compile_macro(item, self.session.edition());\n-                (ext, item.ident, item.span, def.legacy)\n-            }\n-            ItemKind::Fn(..) => match proc_macro_stub(item) {\n-                Some((macro_kind, ident, span)) => {\n-                    self.proc_macro_stubs.insert(item.id);\n-                    (self.dummy_ext(macro_kind), ident, span, false)\n-                }\n-                None => return parent_scope.legacy,\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        let def_id = self.definitions.local_def_id(item.id);\n-        let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n-        self.macro_map.insert(def_id, ext);\n-        self.local_macro_def_scopes.insert(item.id, parent_scope.module);\n-\n-        if is_legacy {\n-            let ident = ident.modern();\n-            self.macro_names.insert(ident);\n-            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n-            let vis = if is_macro_export {\n-                ty::Visibility::Public\n-            } else {\n-                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n-            };\n-            let binding = (res, vis, span, expansion).to_name_binding(self.arenas);\n-            self.set_binding_parent_module(binding, parent_scope.module);\n-            self.all_macros.insert(ident.name, res);\n-            if is_macro_export {\n-                let module = self.graph_root;\n-                self.define(module, ident, MacroNS,\n-                            (res, vis, span, expansion, IsMacroExport));\n-            } else {\n-                self.check_reserved_macro_name(ident, res);\n-                self.unused_macros.insert(item.id, span);\n-            }\n-            LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: parent_scope.legacy, binding, ident\n-            }))\n-        } else {\n-            let module = parent_scope.module;\n-            let vis = self.resolve_visibility(&item.vis, parent_scope);\n-            if vis != ty::Visibility::Public {\n-                self.unused_macros.insert(item.id, span);\n-            }\n-            self.define(module, ident, MacroNS, (res, vis, span, expansion));\n-            parent_scope.legacy\n-        }\n-    }\n }"}, {"sha": "5caaebf0e96c4d93db4c8dd104eb736e2cec77b9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f360d795f1ac31ed0e4e2f3225f9122db73e1b92/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f360d795f1ac31ed0e4e2f3225f9122db73e1b92", "patch": "@@ -8,7 +8,6 @@ use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyErro\n use crate::{Resolver, ResolutionError, Segment};\n use crate::{names_to_string, module_to_string};\n use crate::ModuleKind;\n-use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -27,7 +26,7 @@ use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n-use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n+use syntax::ast::{Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -153,10 +152,14 @@ impl<'a> NameResolution<'a> {\n                self.single_imports.is_empty() { Some(binding) } else { None }\n         })\n     }\n+\n+    crate fn add_single_import(&mut self, directive: &'a ImportDirective<'a>) {\n+        self.single_imports.insert(PtrKey(directive));\n+    }\n }\n \n impl<'a> Resolver<'a> {\n-    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n+    crate fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n         *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n@@ -417,57 +420,7 @@ impl<'a> Resolver<'a> {\n         // No resolution and no one else can define the name - determinate error.\n         Err((Determined, Weak::No))\n     }\n-}\n-\n-impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n-    // Add an import directive to the current module.\n-    pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Segment>,\n-                                subclass: ImportDirectiveSubclass<'a>,\n-                                span: Span,\n-                                id: NodeId,\n-                                item: &ast::Item,\n-                                root_span: Span,\n-                                root_id: NodeId,\n-                                vis: ty::Visibility,\n-                                parent_scope: ParentScope<'a>) {\n-        let current_module = parent_scope.module;\n-        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n-            parent_scope,\n-            module_path,\n-            imported_module: Cell::new(None),\n-            subclass,\n-            span,\n-            id,\n-            use_span: item.span,\n-            use_span_with_attributes: item.span_with_attributes(),\n-            has_attributes: !item.attrs.is_empty(),\n-            root_span,\n-            root_id,\n-            vis: Cell::new(vis),\n-            used: Cell::new(false),\n-        });\n-\n-        debug!(\"add_import_directive({:?})\", directive);\n-\n-        self.r.indeterminate_imports.push(directive);\n-        match directive.subclass {\n-            SingleImport { target, type_ns_only, .. } => {\n-                self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.insert(PtrKey(directive));\n-                });\n-            }\n-            // We don't add prelude imports to the globs since they only affect lexical scopes,\n-            // which are not relevant to import resolution.\n-            GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n \n-impl<'a> Resolver<'a> {\n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n     crate fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)"}]}