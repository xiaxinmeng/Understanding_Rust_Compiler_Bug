{"sha": "4f66117945df3b21e46ee9013e1c8a88f4b27842", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNjYxMTc5NDVkZjNiMjFlNDZlZTkwMTNlMWM4YTg4ZjRiMjc4NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-03T00:24:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-03T00:24:50Z"}, "message": "Auto merge of #76265 - Dylan-DPC:rollup-j3i509l, r=Dylan-DPC\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #75150 (Add a note for Ipv4Addr::to_ipv6_compatible)\n - #76120 (Add `[T; N]::as_[mut_]slice`)\n - #76142 (Make all methods of `std::net::Ipv4Addr` const)\n - #76164 (Link to slice pattern in array docs)\n - #76167 (Replace MinGW library hack with heuristic controlling link mode)\n - #76204 (Rename and expose LoopState as ControlFlow)\n - #76238 (Move to intra-doc links for library/core/src/iter/traits/iterator.rs)\n - #76242 (Read: adjust a FIXME reference)\n - #76243 (Fix typos in vec try_reserve(_exact) docs)\n - #76245 (inliner: Avoid query cycles when optimizing generators)\n - #76255 (Update books)\n - #76261 (Use intra-doc links in `core::marker`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d79737d21c995dda03c02c5db72b099a4f9f9c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d79737d21c995dda03c02c5db72b099a4f9f9c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f66117945df3b21e46ee9013e1c8a88f4b27842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f66117945df3b21e46ee9013e1c8a88f4b27842", "html_url": "https://github.com/rust-lang/rust/commit/4f66117945df3b21e46ee9013e1c8a88f4b27842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f66117945df3b21e46ee9013e1c8a88f4b27842/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51f79b618d41b8319134827d92ccc674dab4aa32", "url": "https://api.github.com/repos/rust-lang/rust/commits/51f79b618d41b8319134827d92ccc674dab4aa32", "html_url": "https://github.com/rust-lang/rust/commit/51f79b618d41b8319134827d92ccc674dab4aa32"}, {"sha": "af331a2d0150f7aac04f13c4d603bc17e79029a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/af331a2d0150f7aac04f13c4d603bc17e79029a0", "html_url": "https://github.com/rust-lang/rust/commit/af331a2d0150f7aac04f13c4d603bc17e79029a0"}], "stats": {"total": 669, "additions": 365, "deletions": 304}, "files": [{"sha": "c044020d9301b05ca70ab16d5de0c64ebb7e41d6", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 25, "deletions": 92, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1014,86 +1014,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n     }\n }\n \n-// Because windows-gnu target is meant to be self-contained for pure Rust code it bundles\n-// own mingw-w64 libraries. These libraries are usually not compatible with mingw-w64\n-// installed in the system. This breaks many cases where Rust is mixed with other languages\n-// (e.g. *-sys crates).\n-// We prefer system mingw-w64 libraries if they are available to avoid this issue.\n-fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n-    fn find_exe_in_path<P>(exe_name: P) -> Option<PathBuf>\n-    where\n-        P: AsRef<Path>,\n-    {\n-        for dir in env::split_paths(&env::var_os(\"PATH\")?) {\n-            let full_path = dir.join(&exe_name);\n-            if full_path.is_file() {\n-                return Some(fix_windows_verbatim_for_gcc(&full_path));\n-            }\n-        }\n-        None\n-    }\n-\n-    fn probe(sess: &Session) -> Option<PathBuf> {\n-        if let (linker, LinkerFlavor::Gcc) = linker_and_flavor(&sess) {\n-            let linker_path = if cfg!(windows) && linker.extension().is_none() {\n-                linker.with_extension(\"exe\")\n-            } else {\n-                linker\n-            };\n-            if let Some(linker_path) = find_exe_in_path(linker_path) {\n-                let mingw_arch = match &sess.target.target.arch {\n-                    x if x == \"x86\" => \"i686\",\n-                    x => x,\n-                };\n-                let mingw_bits = &sess.target.target.target_pointer_width;\n-                let mingw_dir = format!(\"{}-w64-mingw32\", mingw_arch);\n-                // Here we have path/bin/gcc but we need path/\n-                let mut path = linker_path;\n-                path.pop();\n-                path.pop();\n-                // Loosely based on Clang MinGW driver\n-                let probe_paths = vec![\n-                    path.join(&mingw_dir).join(\"lib\"),                // Typical path\n-                    path.join(&mingw_dir).join(\"sys-root/mingw/lib\"), // Rare path\n-                    path.join(format!(\n-                        \"lib/mingw/tools/install/mingw{}/{}/lib\",\n-                        &mingw_bits, &mingw_dir\n-                    )), // Chocolatey is creative\n-                ];\n-                for probe_path in probe_paths {\n-                    if probe_path.join(\"crt2.o\").exists() {\n-                        return Some(probe_path);\n-                    };\n-                }\n-            };\n-        };\n-        None\n-    }\n-\n-    let mut system_library_path = sess.system_library_path.borrow_mut();\n-    match &*system_library_path {\n-        Some(Some(compiler_libs_path)) => Some(compiler_libs_path.clone()),\n-        Some(None) => None,\n-        None => {\n-            let path = probe(sess);\n-            *system_library_path = Some(path.clone());\n-            path\n-        }\n-    }\n-}\n-\n fn get_object_file_path(sess: &Session, name: &str, self_contained: bool) -> PathBuf {\n-    // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n-    if sess.opts.cg.link_self_contained.is_none()\n-        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n-    {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            let file_path = compiler_libs_path.join(name);\n-            if file_path.exists() {\n-                return file_path;\n-            }\n-        }\n-    }\n     let fs = sess.target_filesearch(PathKind::Native);\n     let file_path = fs.get_lib_path().join(name);\n     if file_path.exists() {\n@@ -1286,6 +1207,28 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     }\n }\n \n+// Returns true if linker is located within sysroot\n+fn detect_self_contained_mingw(sess: &Session) -> bool {\n+    let (linker, _) = linker_and_flavor(&sess);\n+    // Assume `-C linker=rust-lld` as self-contained mode\n+    if linker == Path::new(\"rust-lld\") {\n+        return true;\n+    }\n+    let linker_with_extension = if cfg!(windows) && linker.extension().is_none() {\n+        linker.with_extension(\"exe\")\n+    } else {\n+        linker\n+    };\n+    for dir in env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()) {\n+        let full_path = dir.join(&linker_with_extension);\n+        // If linker comes from sysroot assume self-contained mode\n+        if full_path.is_file() && !full_path.starts_with(&sess.sysroot) {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n /// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n /// We only provide such support for a very limited number of targets.\n fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n@@ -1298,10 +1241,10 @@ fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n         // based on host and linker path, for example.\n         // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n         Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n-        // FIXME: Find some heuristic for \"native mingw toolchain is available\",\n-        // likely based on `get_crt_libs_path` (https://github.com/rust-lang/rust/pull/67429).\n         Some(CrtObjectsFallback::Mingw) => {\n-            sess.host == sess.target.target && sess.target.target.target_vendor != \"uwp\"\n+            sess.host == sess.target.target\n+                && sess.target.target.target_vendor != \"uwp\"\n+                && detect_self_contained_mingw(&sess)\n         }\n         // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n         Some(CrtObjectsFallback::Wasm) => true,\n@@ -1498,16 +1441,6 @@ fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'\n \n /// Add sysroot and other globally set directories to the directory search list.\n fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained: bool) {\n-    // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n-    if sess.opts.cg.link_self_contained.is_none()\n-        && cfg!(windows)\n-        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n-    {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            cmd.include_path(&compiler_libs_path);\n-        }\n-    }\n-\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();"}, {"sha": "428f4e138c7f986860e3154f0d70135b1bfa8e7f", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -107,8 +107,14 @@ impl Inliner<'tcx> {\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation.\n-                    // So don't do it if that is enabled.\n-                    if !self.tcx.dep_graph.is_fully_enabled() && self_hir_id < callee_hir_id {\n+                    // So don't do it if that is enabled. Also avoid inlining into generators,\n+                    // since their `optimized_mir` is used for layout computation, which can\n+                    // create a cycle, even when no attempt is made to inline the function\n+                    // in the other direction.\n+                    if !self.tcx.dep_graph.is_fully_enabled()\n+                        && self_hir_id < callee_hir_id\n+                        && caller_body.generator_kind.is_none()\n+                    {\n                         self.tcx.optimized_mir(callsite.callee)\n                     } else {\n                         continue;"}, {"sha": "52b9f73ba8825da7f4efd760f7deb2d3cf2eaee9", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -685,7 +685,7 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n-    /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n+    /// be inserted in the given `VecDeque<T>`. After calling `try_reserve_exact`,\n     /// capacity will be greater than or equal to `self.len() + additional`.\n     /// Does nothing if the capacity is already sufficient.\n     ///\n@@ -727,7 +727,7 @@ impl<T> VecDeque<T> {\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n     /// in the given `VecDeque<T>`. The collection may reserve more space to avoid\n-    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional`. Does nothing if\n     /// capacity is already sufficient.\n     ///"}, {"sha": "27eefb058421689cffcaaf6c1781e4d1f8e6c160", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -523,7 +523,7 @@ impl<T> Vec<T> {\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n     /// in the given `Vec<T>`. The collection may reserve more space to avoid\n-    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional`. Does nothing if\n     /// capacity is already sufficient.\n     ///\n@@ -559,7 +559,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n-    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n+    /// be inserted in the given `Vec<T>`. After calling `try_reserve_exact`,\n     /// capacity will be greater than or equal to `self.len() + additional`.\n     /// Does nothing if the capacity is already sufficient.\n     ///\n@@ -582,7 +582,7 @@ impl<T> Vec<T> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n-    ///     output.try_reserve(data.len())?;\n+    ///     output.try_reserve_exact(data.len())?;\n     ///\n     ///     // Now we know this can't OOM in the middle of our complex work\n     ///     output.extend(data.iter().map(|&val| {"}, {"sha": "f45c99c285c84c9cb301bf864b8049edefe1ef39", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -422,4 +422,17 @@ impl<T, const N: usize> [T; N] {\n         // and we just need to cast it to the correct type.\n         unsafe { crate::mem::transmute_copy::<_, [U; N]>(&dst) }\n     }\n+\n+    /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n+    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self\n+    }\n+\n+    /// Returns a mutable slice containing the entire array. Equivalent to\n+    /// `&mut s[..]`.\n+    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        self\n+    }\n }"}, {"sha": "f32c3963abea2e369da8dfae3230a93e7baafb73", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1,9 +1,9 @@\n use crate::cmp;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::ops::{Add, AddAssign, Try};\n+use crate::ops::{Add, AddAssign, ControlFlow, Try};\n \n-use super::{from_fn, LoopState};\n+use super::from_fn;\n use super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n \n mod chain;\n@@ -1164,10 +1164,10 @@ where\n         #[inline]\n         fn find<T, B>(\n             f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> LoopState<(), B> + '_ {\n+        ) -> impl FnMut((), T) -> ControlFlow<(), B> + '_ {\n             move |(), x| match f(x) {\n-                Some(x) => LoopState::Break(x),\n-                None => LoopState::Continue(()),\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::Continue(()),\n             }\n         }\n \n@@ -1864,13 +1864,13 @@ where\n             flag: &'a mut bool,\n             p: &'a mut impl FnMut(&T) -> bool,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n             move |acc, x| {\n                 if p(&x) {\n-                    LoopState::from_try(fold(acc, x))\n+                    ControlFlow::from_try(fold(acc, x))\n                 } else {\n                     *flag = true;\n-                    LoopState::Break(Try::from_ok(acc))\n+                    ControlFlow::Break(Try::from_ok(acc))\n                 }\n             }\n         }\n@@ -1963,8 +1963,8 @@ where\n     {\n         let Self { iter, predicate } = self;\n         iter.try_fold(init, |acc, x| match predicate(x) {\n-            Some(item) => LoopState::from_try(fold(acc, item)),\n-            None => LoopState::Break(Try::from_ok(acc)),\n+            Some(item) => ControlFlow::from_try(fold(acc, item)),\n+            None => ControlFlow::Break(Try::from_ok(acc)),\n         })\n         .into_try()\n     }\n@@ -2135,11 +2135,11 @@ where\n         fn check<T, Acc, R: Try<Ok = Acc>>(\n             mut n: usize,\n             mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> {\n             move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n-                if n == 0 { LoopState::Break(r) } else { LoopState::from_try(r) }\n+                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n             }\n         }\n \n@@ -2246,11 +2246,11 @@ where\n         fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n             n: &'a mut usize,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n             move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n-                if *n == 0 { LoopState::Break(r) } else { LoopState::from_try(r) }\n+                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n             }\n         }\n \n@@ -2414,10 +2414,10 @@ where\n             state: &'a mut St,\n             f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n             mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n             move |acc, x| match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n+                None => ControlFlow::Break(Try::from_ok(acc)),\n+                Some(x) => ControlFlow::from_try(fold(acc, x)),\n             }\n         }\n \n@@ -2638,10 +2638,10 @@ where\n         let error = &mut *self.error;\n         self.iter\n             .try_fold(init, |acc, x| match x {\n-                Ok(x) => LoopState::from_try(f(acc, x)),\n+                Ok(x) => ControlFlow::from_try(f(acc, x)),\n                 Err(e) => {\n                     *error = Err(e);\n-                    LoopState::Break(Try::from_ok(acc))\n+                    ControlFlow::Break(Try::from_ok(acc))\n                 }\n             })\n             .into_try()"}, {"sha": "bab8dda2915d974cb4d36b49630d6129ca3cfd0c", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -308,8 +308,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::ops::Try;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::Iterator;\n \n@@ -367,57 +365,3 @@ mod adapters;\n mod range;\n mod sources;\n mod traits;\n-\n-/// Used to make try_fold closures more like normal loops\n-#[derive(PartialEq)]\n-enum LoopState<C, B> {\n-    Continue(C),\n-    Break(B),\n-}\n-\n-impl<C, B> Try for LoopState<C, B> {\n-    type Ok = C;\n-    type Error = B;\n-    #[inline]\n-    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n-        match self {\n-            LoopState::Continue(y) => Ok(y),\n-            LoopState::Break(x) => Err(x),\n-        }\n-    }\n-    #[inline]\n-    fn from_error(v: Self::Error) -> Self {\n-        LoopState::Break(v)\n-    }\n-    #[inline]\n-    fn from_ok(v: Self::Ok) -> Self {\n-        LoopState::Continue(v)\n-    }\n-}\n-\n-impl<C, B> LoopState<C, B> {\n-    #[inline]\n-    fn break_value(self) -> Option<B> {\n-        match self {\n-            LoopState::Continue(..) => None,\n-            LoopState::Break(x) => Some(x),\n-        }\n-    }\n-}\n-\n-impl<R: Try> LoopState<R::Ok, R> {\n-    #[inline]\n-    fn from_try(r: R) -> Self {\n-        match Try::into_result(r) {\n-            Ok(v) => LoopState::Continue(v),\n-            Err(v) => LoopState::Break(Try::from_error(v)),\n-        }\n-    }\n-    #[inline]\n-    fn into_try(self) -> R {\n-        match self {\n-            LoopState::Continue(v) => Try::from_ok(v),\n-            LoopState::Break(v) => v,\n-        }\n-    }\n-}"}, {"sha": "25230519f3744f1b18d5cf7978417faeee8d6733", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1,5 +1,4 @@\n-use crate::iter::LoopState;\n-use crate::ops::Try;\n+use crate::ops::{ControlFlow, Try};\n \n /// An iterator able to yield elements from both ends.\n ///\n@@ -309,9 +308,9 @@ pub trait DoubleEndedIterator: Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n             move |(), x| {\n-                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+                if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::Continue(()) }\n             }\n         }\n "}, {"sha": "46ef12cd938b33e6f2fd25b0a912fd3765b3d321", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -3,9 +3,8 @@\n // can't split that into multiple files.\n \n use crate::cmp::{self, Ordering};\n-use crate::ops::{Add, Try};\n+use crate::ops::{Add, ControlFlow, Try};\n \n-use super::super::LoopState;\n use super::super::TrustedRandomAccess;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n@@ -22,8 +21,8 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n /// generally, please see the [module-level documentation]. In particular, you\n /// may want to know how to [implement `Iterator`][impl].\n ///\n-/// [module-level documentation]: index.html\n-/// [impl]: index.html#implementing-iterator\n+/// [module-level documentation]: crate::iter\n+/// [impl]: crate::iter#implementing-iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n     on(\n@@ -212,7 +211,7 @@ pub trait Iterator {\n     /// returning the number of times it saw [`Some`]. Note that [`next`] has to be\n     /// called at least once even if the iterator does not have any elements.\n     ///\n-    /// [`next`]: #tymethod.next\n+    /// [`next`]: Iterator::next\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -449,9 +448,7 @@ pub trait Iterator {\n     /// }\n     /// ```\n     ///\n-    /// [`once`]: fn.once.html\n-    /// [`Iterator`]: trait.Iterator.html\n-    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`once`]: crate::iter::once\n     /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -496,9 +493,6 @@ pub trait Iterator {\n     /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n     /// [`IntoIterator`], and so can be passed to `zip()` directly:\n     ///\n-    /// [`IntoIterator`]: trait.IntoIterator.html\n-    /// [`Iterator`]: trait.Iterator.html\n-    ///\n     /// ```\n     /// let s1 = &[1, 2, 3];\n     /// let s2 = &[4, 5, 6];\n@@ -530,8 +524,8 @@ pub trait Iterator {\n     /// assert_eq!((2, 'o'), zipper[2]);\n     /// ```\n     ///\n-    /// [`enumerate`]: #method.enumerate\n-    /// [`next`]: #tymethod.next\n+    /// [`enumerate`]: Iterator::enumerate\n+    /// [`next`]: Iterator::next\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>\n@@ -734,8 +728,8 @@ pub trait Iterator {\n     /// Why `filter_map` and not just [`filter`] and [`map`]? The key is in this\n     /// part:\n     ///\n-    /// [`filter`]: #method.filter\n-    /// [`map`]: #method.map\n+    /// [`filter`]: Iterator::filter\n+    /// [`map`]: Iterator::map\n     ///\n     /// > If the closure returns [`Some(element)`][`Some`], then that element is returned.\n     ///\n@@ -802,7 +796,7 @@ pub trait Iterator {\n     ///\n     /// [`usize`]: type@usize\n     /// [`usize::MAX`]: crate::usize::MAX\n-    /// [`zip`]: #method.zip\n+    /// [`zip`]: Iterator::zip\n     ///\n     /// # Examples\n     ///\n@@ -837,8 +831,8 @@ pub trait Iterator {\n     /// anything other than fetching the next value) of the [`next`] method\n     /// will occur.\n     ///\n-    /// [`peek`]: crate::iter::Peekable::peek\n-    /// [`next`]: #tymethod.next\n+    /// [`peek`]: Peekable::peek\n+    /// [`next`]: Iterator::next\n     ///\n     /// # Examples\n     ///\n@@ -876,7 +870,7 @@ pub trait Iterator {\n \n     /// Creates an iterator that [`skip`]s elements based on a predicate.\n     ///\n-    /// [`skip`]: #method.skip\n+    /// [`skip`]: Iterator::skip\n     ///\n     /// `skip_while()` takes a closure as an argument. It will call this\n     /// closure on each element of the iterator, and ignore elements\n@@ -1043,8 +1037,8 @@ pub trait Iterator {\n     ///\n     /// Here's the same example, but with [`take_while`] and [`map`]:\n     ///\n-    /// [`take_while`]: #method.take_while\n-    /// [`map`]: #method.map\n+    /// [`take_while`]: Iterator::take_while\n+    /// [`map`]: Iterator::map\n     ///\n     /// ```\n     /// let a = [-1i32, 4, 0, 1];\n@@ -1104,7 +1098,7 @@ pub trait Iterator {\n     /// It is also not specified what this iterator returns after the first` None` is returned.\n     /// If you need fused iterator, use [`fuse`].\n     ///\n-    /// [`fuse`]: #method.fuse\n+    /// [`fuse`]: Iterator::fuse\n     #[inline]\n     #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n     fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>\n@@ -1190,7 +1184,7 @@ pub trait Iterator {\n     /// An iterator adaptor similar to [`fold`] that holds internal state and\n     /// produces a new iterator.\n     ///\n-    /// [`fold`]: #method.fold\n+    /// [`fold`]: Iterator::fold\n     ///\n     /// `scan()` takes two arguments: an initial value which seeds the internal\n     /// state, and a closure with two arguments, the first being a mutable\n@@ -1246,8 +1240,8 @@ pub trait Iterator {\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n-    /// [`map`]: #method.map\n-    /// [`flatten`]: #method.flatten\n+    /// [`map`]: Iterator::map\n+    /// [`flatten`]: Iterator::flatten\n     ///\n     /// # Examples\n     ///\n@@ -1333,7 +1327,7 @@ pub trait Iterator {\n     /// two-dimensional and not one-dimensional. To get a one-dimensional\n     /// structure, you have to `flatten()` again.\n     ///\n-    /// [`flat_map()`]: #method.flat_map\n+    /// [`flat_map()`]: Iterator::flat_map\n     #[inline]\n     #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n     fn flatten(self) -> Flatten<Self>\n@@ -1640,7 +1634,7 @@ pub trait Iterator {\n     /// assert_eq!(Ok(vec![1, 3]), result);\n     /// ```\n     ///\n-    /// [`iter`]: #tymethod.next\n+    /// [`iter`]: Iterator::next\n     /// [`String`]: ../../std/string/struct.String.html\n     /// [`char`]: type@char\n     #[inline]\n@@ -1661,8 +1655,8 @@ pub trait Iterator {\n     ///\n     /// See also [`is_partitioned()`] and [`partition_in_place()`].\n     ///\n-    /// [`is_partitioned()`]: #method.is_partitioned\n-    /// [`partition_in_place()`]: #method.partition_in_place\n+    /// [`is_partitioned()`]: Iterator::is_partitioned\n+    /// [`partition_in_place()`]: Iterator::partition_in_place\n     ///\n     /// # Examples\n     ///\n@@ -1716,8 +1710,8 @@ pub trait Iterator {\n     ///\n     /// See also [`is_partitioned()`] and [`partition()`].\n     ///\n-    /// [`is_partitioned()`]: #method.is_partitioned\n-    /// [`partition()`]: #method.partition\n+    /// [`is_partitioned()`]: Iterator::is_partitioned\n+    /// [`partition()`]: Iterator::partition\n     ///\n     /// # Examples\n     ///\n@@ -1779,8 +1773,8 @@ pub trait Iterator {\n     ///\n     /// See also [`partition()`] and [`partition_in_place()`].\n     ///\n-    /// [`partition()`]: #method.partition\n-    /// [`partition_in_place()`]: #method.partition_in_place\n+    /// [`partition()`]: Iterator::partition\n+    /// [`partition_in_place()`]: Iterator::partition_in_place\n     ///\n     /// # Examples\n     ///\n@@ -1879,8 +1873,8 @@ pub trait Iterator {\n     /// This can also be thought of as the fallible form of [`for_each()`]\n     /// or as the stateless version of [`try_fold()`].\n     ///\n-    /// [`for_each()`]: #method.for_each\n-    /// [`try_fold()`]: #method.try_fold\n+    /// [`for_each()`]: Iterator::for_each\n+    /// [`try_fold()`]: Iterator::try_fold\n     ///\n     /// # Examples\n     ///\n@@ -2006,11 +2000,13 @@ pub trait Iterator {\n         accum\n     }\n \n-    /// The same as [`fold()`](#method.fold), but uses the first element in the\n+    /// The same as [`fold()`], but uses the first element in the\n     /// iterator as the initial value, folding every subsequent element into it.\n     /// If the iterator is empty, return `None`; otherwise, return the result\n     /// of the fold.\n     ///\n+    /// [`fold()`]: Iterator::fold\n+    ///\n     /// # Example\n     ///\n     /// Find the maximum value:\n@@ -2088,12 +2084,12 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n             move |(), x| {\n-                if f(x) { LoopState::Continue(()) } else { LoopState::Break(()) }\n+                if f(x) { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n             }\n         }\n-        self.try_fold((), check(f)) == LoopState::Continue(())\n+        self.try_fold((), check(f)) == ControlFlow::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -2141,13 +2137,13 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n             move |(), x| {\n-                if f(x) { LoopState::Break(()) } else { LoopState::Continue(()) }\n+                if f(x) { ControlFlow::Break(()) } else { ControlFlow::Continue(()) }\n             }\n         }\n \n-        self.try_fold((), check(f)) == LoopState::Break(())\n+        self.try_fold((), check(f)) == ControlFlow::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -2203,9 +2199,9 @@ pub trait Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n             move |(), x| {\n-                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+                if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::Continue(()) }\n             }\n         }\n \n@@ -2235,10 +2231,12 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         #[inline]\n-        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> LoopState<(), B> {\n+        fn check<T, B>(\n+            mut f: impl FnMut(T) -> Option<B>,\n+        ) -> impl FnMut((), T) -> ControlFlow<(), B> {\n             move |(), x| match f(x) {\n-                Some(x) => LoopState::Break(x),\n-                None => LoopState::Continue(()),\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::Continue(()),\n             }\n         }\n \n@@ -2274,15 +2272,15 @@ pub trait Iterator {\n         R: Try<Ok = bool>,\n     {\n         #[inline]\n-        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> LoopState<(), Result<T, R::Error>>\n+        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> ControlFlow<(), Result<T, R::Error>>\n         where\n             F: FnMut(&T) -> R,\n             R: Try<Ok = bool>,\n         {\n             move |(), x| match f(&x).into_result() {\n-                Ok(false) => LoopState::Continue(()),\n-                Ok(true) => LoopState::Break(Ok(x)),\n-                Err(x) => LoopState::Break(Err(x)),\n+                Ok(false) => ControlFlow::Continue(()),\n+                Ok(true) => ControlFlow::Break(Ok(x)),\n+                Err(x) => ControlFlow::Break(Err(x)),\n             }\n         }\n \n@@ -2352,10 +2350,14 @@ pub trait Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(T) -> bool,\n-        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+        ) -> impl FnMut(usize, T) -> ControlFlow<usize, usize> {\n             // The addition might panic on overflow\n             move |i, x| {\n-                if predicate(x) { LoopState::Break(i) } else { LoopState::Continue(Add::add(i, 1)) }\n+                if predicate(x) {\n+                    ControlFlow::Break(i)\n+                } else {\n+                    ControlFlow::Continue(Add::add(i, 1))\n+                }\n             }\n         }\n \n@@ -2411,10 +2413,10 @@ pub trait Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(T) -> bool,\n-        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+        ) -> impl FnMut(usize, T) -> ControlFlow<usize, usize> {\n             move |i, x| {\n                 let i = i - 1;\n-                if predicate(x) { LoopState::Break(i) } else { LoopState::Continue(i) }\n+                if predicate(x) { ControlFlow::Break(i) } else { ControlFlow::Continue(i) }\n             }\n         }\n \n@@ -2602,8 +2604,6 @@ pub trait Iterator {\n     /// This is only possible if the iterator has an end, so `rev()` only\n     /// works on [`DoubleEndedIterator`]s.\n     ///\n-    /// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2634,7 +2634,7 @@ pub trait Iterator {\n     ///\n     /// This function is, in some sense, the opposite of [`zip`].\n     ///\n-    /// [`zip`]: #method.zip\n+    /// [`zip`]: Iterator::zip\n     ///\n     /// # Examples\n     ///\n@@ -2713,7 +2713,7 @@ pub trait Iterator {\n     /// This is useful when you have an iterator over `&T`, but you need an\n     /// iterator over `T`.\n     ///\n-    /// [`clone`]: crate::clone::Clone::clone\n+    /// [`clone`]: Clone::clone\n     ///\n     /// # Examples\n     ///\n@@ -3201,7 +3201,7 @@ pub trait Iterator {\n     /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// ```\n     ///\n-    /// [`is_sorted`]: #method.is_sorted\n+    /// [`is_sorted`]: Iterator::is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool\n     where\n@@ -3230,7 +3230,7 @@ pub trait Iterator {\n     /// the elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see\n     /// its documentation for more information.\n     ///\n-    /// [`is_sorted`]: #method.is_sorted\n+    /// [`is_sorted`]: Iterator::is_sorted\n     ///\n     /// # Examples\n     ///"}, {"sha": "9340b591ebd7044ffa039bc724873cff07083847", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -111,13 +111,13 @@ pub trait Sized {\n ///   - `T` is not part of the type of any other fields\n ///   - `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`\n ///\n-/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n-/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n+/// `Unsize` is used along with [`ops::CoerceUnsized`] to allow\n+/// \"user-defined\" containers such as [`Rc`] to contain dynamically-sized\n /// types. See the [DST coercion RFC][RFC982] and [the nomicon entry on coercion][nomicon-coerce]\n /// for more details.\n ///\n-/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`ops::CoerceUnsized`]: crate::ops::CoerceUnsized\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n@@ -368,11 +368,7 @@ pub trait StructuralEq {\n ///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`Drop`]: ../../std/ops/trait.Drop.html\n-/// [`size_of::<T>`]: ../../std/mem/fn.size_of.html\n-/// [`Clone`]: ../clone/trait.Clone.html\n-/// [`String`]: ../../std/string/struct.String.html\n-/// [`i32`]: ../../std/primitive.i32.html\n+/// [`size_of::<T>`]: crate::mem::size_of\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n@@ -400,18 +396,18 @@ pub macro Copy($item:item) {\n /// This trait is automatically implemented when the compiler determines\n /// it's appropriate.\n ///\n-/// The precise definition is: a type `T` is `Sync` if and only if `&T` is\n-/// [`Send`][send]. In other words, if there is no possibility of\n+/// The precise definition is: a type `T` is [`Sync`] if and only if `&T` is\n+/// [`Send`]. In other words, if there is no possibility of\n /// [undefined behavior][ub] (including data races) when passing\n /// `&T` references between threads.\n ///\n-/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n-/// are all `Sync`, and so are simple aggregate types containing them,\n-/// like tuples, structs and enums. More examples of basic `Sync`\n+/// As one would expect, primitive types like [`u8`] and [`f64`]\n+/// are all [`Sync`], and so are simple aggregate types containing them,\n+/// like tuples, structs and enums. More examples of basic [`Sync`]\n /// types include \"immutable\" types like `&T`, and those with simple\n /// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n-/// most other collection types. (Generic parameters need to be `Sync`\n-/// for their container to be `Sync`.)\n+/// most other collection types. (Generic parameters need to be [`Sync`]\n+/// for their container to be [`Sync`].)\n ///\n /// A somewhat surprising consequence of the definition is that `&mut T`\n /// is `Sync` (if `T` is `Sync`) even though it seems like that might\n@@ -421,15 +417,15 @@ pub macro Copy($item:item) {\n /// of a data race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n-/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n+/// mutability\" in a non-thread-safe form, such as [`Cell`][cell]\n+/// and [`RefCell`][refcell]. These types allow for mutation of\n /// their contents even through an immutable, shared reference. For\n /// example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires\n /// only a shared reference [`&Cell<T>`][cell]. The method performs no\n /// synchronization, thus [`Cell`][cell] cannot be `Sync`.\n ///\n /// Another example of a non-`Sync` type is the reference-counting\n-/// pointer [`rc::Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n+/// pointer [`Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n /// a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n@@ -445,24 +441,21 @@ pub macro Copy($item:item) {\n /// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n /// from `&T` to `&mut T` is invalid.\n ///\n-/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n-/// details about `Sync`.\n+/// See [the Nomicon][nomicon-send-and-sync] for more details about `Sync`.\n ///\n-/// [send]: trait.Send.html\n-/// [u8]: ../../std/primitive.u8.html\n-/// [f64]: ../../std/primitive.f64.html\n /// [box]: ../../std/boxed/struct.Box.html\n /// [vec]: ../../std/vec/struct.Vec.html\n-/// [cell]: ../cell/struct.Cell.html\n-/// [refcell]: ../cell/struct.RefCell.html\n+/// [cell]: crate::cell::Cell\n+/// [refcell]: crate::cell::RefCell\n /// [rc]: ../../std/rc/struct.Rc.html\n /// [arc]: ../../std/sync/struct.Arc.html\n-/// [atomic data types]: ../sync/atomic/index.html\n+/// [atomic data types]: crate::sync::atomic\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n-/// [unsafecell]: ../cell/struct.UnsafeCell.html\n+/// [unsafecell]: crate::cell::UnsafeCell\n /// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [transmute]: ../../std/mem/fn.transmute.html\n+/// [transmute]: crate::mem::transmute\n+/// [nomicon-send-and-sync]: ../../nomicon/send-and-sync.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"sync_trait\")]\n #[lang = \"sync\"]\n@@ -698,7 +691,7 @@ mod impls {\n /// guarantees to [`mem::Discriminant`]. It is **undefined behavior** to transmute\n /// between `DiscriminantKind::Discriminant` and `mem::Discriminant`.\n ///\n-/// [`mem::Discriminant`]: https://doc.rust-lang.org/stable/core/mem/struct.Discriminant.html\n+/// [`mem::Discriminant`]: crate::mem::Discriminant\n #[unstable(\n     feature = \"discriminant_kind\",\n     issue = \"none\",\n@@ -733,7 +726,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n ///\n /// The [`Pin`][Pin] type is used instead to prevent moves through the type\n /// system. Pointers `P<T>` wrapped in the [`Pin<P<T>>`][Pin] wrapper can't be\n-/// moved out of. See the [`pin module`] documentation for more information on\n+/// moved out of. See the [`pin` module] documentation for more information on\n /// pinning.\n ///\n /// Implementing the `Unpin` trait for `T` lifts the restrictions of pinning off\n@@ -764,9 +757,9 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n ///\n /// This trait is automatically implemented for almost every type.\n ///\n-/// [`mem::replace`]: ../../std/mem/fn.replace.html\n+/// [`mem::replace`]: crate::mem::replace\n /// [Pin]: crate::pin::Pin\n-/// [`pin module`]: crate::pin\n+/// [`pin` module]: crate::pin\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n #[rustc_on_unimplemented(\n     on(_Self = \"std::future::Future\", note = \"consider using `Box::pin`\",),"}, {"sha": "687d423dcb6350f2fda54c4baba4f2e6389c2ae9", "filename": "library/core/src/ops/control_flow.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -0,0 +1,67 @@\n+use crate::ops::Try;\n+\n+/// Used to make try_fold closures more like normal loops\n+#[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum ControlFlow<C, B> {\n+    /// Continue in the loop, using the given value for the next iteration\n+    Continue(C),\n+    /// Exit the loop, yielding the given value\n+    Break(B),\n+}\n+\n+#[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+impl<C, B> Try for ControlFlow<C, B> {\n+    type Ok = C;\n+    type Error = B;\n+    #[inline]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n+        match self {\n+            ControlFlow::Continue(y) => Ok(y),\n+            ControlFlow::Break(x) => Err(x),\n+        }\n+    }\n+    #[inline]\n+    fn from_error(v: Self::Error) -> Self {\n+        ControlFlow::Break(v)\n+    }\n+    #[inline]\n+    fn from_ok(v: Self::Ok) -> Self {\n+        ControlFlow::Continue(v)\n+    }\n+}\n+\n+impl<C, B> ControlFlow<C, B> {\n+    /// Converts the `ControlFlow` into an `Option` which is `Some` if the\n+    /// `ControlFlow` was `Break` and `None` otherwise.\n+    #[inline]\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    pub fn break_value(self) -> Option<B> {\n+        match self {\n+            ControlFlow::Continue(..) => None,\n+            ControlFlow::Break(x) => Some(x),\n+        }\n+    }\n+}\n+\n+impl<R: Try> ControlFlow<R::Ok, R> {\n+    /// Create a `ControlFlow` from any type implementing `Try`.\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    #[inline]\n+    pub fn from_try(r: R) -> Self {\n+        match Try::into_result(r) {\n+            Ok(v) => ControlFlow::Continue(v),\n+            Err(v) => ControlFlow::Break(Try::from_error(v)),\n+        }\n+    }\n+\n+    /// Convert a `ControlFlow` into any type implementing `Try`;\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    #[inline]\n+    pub fn into_try(self) -> R {\n+        match self {\n+            ControlFlow::Continue(v) => Try::from_ok(v),\n+            ControlFlow::Break(v) => v,\n+        }\n+    }\n+}"}, {"sha": "2a4186f9d5db9cdb63f6c84e42f4206fddcaa6b7", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -140,6 +140,7 @@\n \n mod arith;\n mod bit;\n+mod control_flow;\n mod deref;\n mod drop;\n mod function;\n@@ -191,3 +192,6 @@ pub use self::unsize::CoerceUnsized;\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n pub use self::unsize::DispatchFromDyn;\n+\n+#[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+pub use self::control_flow::ControlFlow;"}, {"sha": "4a651e5aa0ee397bdc7974690cc274c3f93373f6", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1,5 +1,6 @@\n #![feature(alloc_layout_extra)]\n #![feature(array_chunks)]\n+#![feature(array_methods)]\n #![feature(array_map)]\n #![feature(bool_to_option)]\n #![feature(bound_cloned)]"}, {"sha": "b46bcfd16d28331b2cea805729627aa5dee40331", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1,4 +1,3 @@\n-use core::array::FixedSizeArray;\n use core::clone::Clone;\n use core::mem;\n use core::ops::DerefMut;"}, {"sha": "35598295a95151c2d9f94d39860801a732f54589", "filename": "library/core/tests/result.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fresult.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1,4 +1,3 @@\n-use core::array::FixedSizeArray;\n use core::ops::DerefMut;\n use core::option::*;\n "}, {"sha": "44d2937ee1bf2a1f5bba58c5b60b4fd47563a760", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -52,11 +52,14 @@ where\n     W: Write,\n {\n     let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n-    // FIXME(#76092): This is calling `get_mut` and `get_ref` on an uninitialized\n-    // `MaybeUninit`. Revisit this once we decided whether that is valid or not.\n-    // This is still technically undefined behavior due to creating a reference\n-    // to uninitialized data, but within libstd we can rely on more guarantees\n-    // than if this code were in an external lib.\n+    // FIXME: #42788\n+    //\n+    //   - This creates a (mut) reference to a slice of\n+    //     _uninitialized_ integers, which is **undefined behavior**\n+    //\n+    //   - Only the standard library gets to soundly \"ignore\" this,\n+    //     based on its privileged knowledge of unstable rustc\n+    //     internals;\n     unsafe {\n         reader.initializer().initialize(buf.assume_init_mut());\n     }"}, {"sha": "dc57c1c1f44db7198be286c6348fc3e65dc62766", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -240,6 +240,7 @@\n #![feature(const_fn_transmute)]\n #![feature(const_ipv6)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(const_ipv4)]\n #![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]"}, {"sha": "3f9afae880f932d0f3fed9763480fddb1d2802c0", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -365,8 +365,9 @@ impl Ipv4Addr {\n     /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n     /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn octets(&self) -> [u8; 4] {\n+    pub const fn octets(&self) -> [u8; 4] {\n         // This returns the order we want because s_addr is stored in big-endian.\n         self.inner.s_addr.to_ne_bytes()\n     }\n@@ -408,8 +409,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n     /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_loopback(&self) -> bool {\n+    pub const fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n \n@@ -437,8 +439,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n     /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_private(&self) -> bool {\n+    pub const fn is_private(&self) -> bool {\n         match self.octets() {\n             [10, ..] => true,\n             [172, b, ..] if b >= 16 && b <= 31 => true,\n@@ -463,8 +466,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n     /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_link_local(&self) -> bool {\n+    pub const fn is_link_local(&self) -> bool {\n         match self.octets() {\n             [169, 254, ..] => true,\n             _ => false,\n@@ -542,10 +546,13 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n     /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n     /// ```\n-    pub fn is_global(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_global(&self) -> bool {\n         // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n         // globally routable addresses in the 192.0.0.0/24 range.\n-        if u32::from(*self) == 0xc0000009 || u32::from(*self) == 0xc000000a {\n+        if u32::from_be_bytes(self.octets()) == 0xc0000009\n+            || u32::from_be_bytes(self.octets()) == 0xc000000a\n+        {\n             return true;\n         }\n         !self.is_private()\n@@ -577,7 +584,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n     /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n     /// ```\n-    pub fn is_shared(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_shared(&self) -> bool {\n         self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n     }\n \n@@ -609,7 +617,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n     /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n     /// ```\n-    pub fn is_ietf_protocol_assignment(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_ietf_protocol_assignment(&self) -> bool {\n         self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n     }\n \n@@ -632,7 +641,8 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n     /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n     /// ```\n-    pub fn is_benchmarking(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_benchmarking(&self) -> bool {\n         self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n     }\n \n@@ -664,7 +674,8 @@ impl Ipv4Addr {\n     /// // The broadcast address is not considered as reserved for future use by this implementation\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n     /// ```\n-    pub fn is_reserved(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    pub const fn is_reserved(&self) -> bool {\n         self.octets()[0] & 240 == 240 && !self.is_broadcast()\n     }\n \n@@ -685,8 +696,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n     /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_multicast(&self) -> bool {\n+    pub const fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n     }\n \n@@ -705,9 +717,10 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n     /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_broadcast(&self) -> bool {\n-        self == &Self::BROADCAST\n+    pub const fn is_broadcast(&self) -> bool {\n+        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n     }\n \n     /// Returns [`true`] if this address is in a range designated for documentation.\n@@ -731,8 +744,9 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n     /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_documentation(&self) -> bool {\n+    pub const fn is_documentation(&self) -> bool {\n         match self.octets() {\n             [192, 0, 2, _] => true,\n             [198, 51, 100, _] => true,\n@@ -745,6 +759,9 @@ impl Ipv4Addr {\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n     ///\n+    /// This isn't typically the method you want; these addresses don't typically\n+    /// function on modern systems. Use `to_ipv6_mapped` instead.\n+    ///\n     /// [`IPv6` address]: Ipv6Addr\n     ///\n     /// # Examples\n@@ -757,10 +774,13 @@ impl Ipv4Addr {\n     ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767)\n     /// );\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n+    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d])\n+        Ipv6Addr {\n+            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] },\n+        }\n     }\n \n     /// Converts this address to an IPv4-mapped [`IPv6` address].\n@@ -777,10 +797,13 @@ impl Ipv4Addr {\n     /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n     ///            Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n+    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         let [a, b, c, d] = self.octets();\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d])\n+        Ipv6Addr {\n+            inner: c::in6_addr { s6_addr: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] },\n+        }\n     }\n }\n "}, {"sha": "2a4cb22cc52a23fb142542589f350794470fc300", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -510,7 +510,7 @@ mod prim_pointer {}\n /// an array. Indeed, this provides most of the API for working with arrays.\n /// Slices have a dynamic size and do not coerce to arrays.\n ///\n-/// You can move elements out of an array with a slice pattern. If you want\n+/// You can move elements out of an array with a [slice pattern]. If you want\n /// one element, see [`mem::replace`].\n ///\n /// # Examples\n@@ -552,7 +552,7 @@ mod prim_pointer {}\n /// for x in &array { }\n /// ```\n ///\n-/// You can use a slice pattern to move elements out of an array:\n+/// You can use a [slice pattern] to move elements out of an array:\n ///\n /// ```\n /// fn move_away(_: String) { /* Do interesting things. */ }\n@@ -567,7 +567,7 @@ mod prim_pointer {}\n /// [`Hash`]: hash::Hash\n /// [`Borrow`]: borrow::Borrow\n /// [`BorrowMut`]: borrow::BorrowMut\n-///\n+/// [slice pattern]: ../reference/patterns.html#slice-patterns\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_array {}\n "}, {"sha": "e5ed97128302d5fa45dbac0e64426bc7649a558c", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1 +1 @@\n-Subproject commit c0a6a61b8205da14ac955425f74258ffd8ee065d\n+Subproject commit e5ed97128302d5fa45dbac0e64426bc7649a558c"}, {"sha": "81f16863014de60b53de401d71ff904d163ee030", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1 +1 @@\n-Subproject commit bd6e4a9f59c5c1545f572266af77f5c7a5bad6d1\n+Subproject commit 81f16863014de60b53de401d71ff904d163ee030"}, {"sha": "25391dba46262f882fa846beefaff54a966a8fa5", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1 +1 @@\n-Subproject commit 1b6c4b0afab97c0230433466c97167bbbe8445f6\n+Subproject commit 25391dba46262f882fa846beefaff54a966a8fa5"}, {"sha": "19f0a0372af497b34369cf182d9d16156cab2969", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -1 +1 @@\n-Subproject commit 80a10e22140e28392b99d24ed02f4c6d8cb770a0\n+Subproject commit 19f0a0372af497b34369cf182d9d16156cab2969"}, {"sha": "5c838159b986c55d5c934a0bbccb6ea0ba00cf65", "filename": "src/test/mir-opt/inline/inline-async.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/src%2Ftest%2Fmir-opt%2Finline%2Finline-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/src%2Ftest%2Fmir-opt%2Finline%2Finline-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-async.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -0,0 +1,18 @@\n+// Checks that inliner doesn't introduce cycles when optimizing generators.\n+// The outcome of optimization is not verfied, just the absence of the cycle.\n+// Regression test for #76181.\n+//\n+// edition:2018\n+\n+#![crate_type = \"lib\"]\n+\n+pub struct S;\n+\n+impl S {\n+    pub async fn g(&mut self) {\n+        self.h();\n+    }\n+    pub fn h(&mut self) {\n+        let _ = self.g();\n+    }\n+}"}, {"sha": "8c676999ae734c1952b339ad6a99b9b6403368d9", "filename": "src/test/ui/consts/std/net/ipv4.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f66117945df3b21e46ee9013e1c8a88f4b27842/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f66117945df3b21e46ee9013e1c8a88f4b27842/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv4.rs?ref=4f66117945df3b21e46ee9013e1c8a88f4b27842", "patch": "@@ -0,0 +1,58 @@\n+// run-pass\n+\n+#![feature(ip)]\n+#![feature(const_ipv4)]\n+\n+use std::net::{Ipv4Addr, Ipv6Addr};\n+\n+fn main() {\n+    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n+\n+    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [127, 0, 0, 1]);\n+\n+    const IS_UNSPECIFIED : bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK : bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_PRIVATE : bool = IP_ADDRESS.is_private();\n+    assert!(!IS_PRIVATE);\n+\n+    const IS_LINK_LOCAL : bool = IP_ADDRESS.is_link_local();\n+    assert!(!IS_LINK_LOCAL);\n+\n+    const IS_GLOBAL : bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_SHARED : bool = IP_ADDRESS.is_shared();\n+    assert!(!IS_SHARED);\n+\n+    const IS_IETF_PROTOCOL_ASSIGNMENT : bool = IP_ADDRESS.is_ietf_protocol_assignment();\n+    assert!(!IS_IETF_PROTOCOL_ASSIGNMENT);\n+\n+    const IS_BENCHMARKING : bool = IP_ADDRESS.is_benchmarking();\n+    assert!(!IS_BENCHMARKING);\n+\n+    const IS_RESERVED : bool = IP_ADDRESS.is_reserved();\n+    assert!(!IS_RESERVED);\n+\n+    const IS_MULTICAST : bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IS_BROADCAST : bool = IP_ADDRESS.is_broadcast();\n+    assert!(!IS_BROADCAST);\n+\n+    const IS_DOCUMENTATION : bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IP_V6_COMPATIBLE : Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n+    assert_eq!(IP_V6_COMPATIBLE,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1]));\n+\n+    const IP_V6_MAPPED : Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n+    assert_eq!(IP_V6_MAPPED,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1]));\n+}"}]}