{"sha": "1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOGJiNGM2YzFmZWYxZjhlYTUxM2UwN2QwYTdkNGM1NDgzMTI5ZDI=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-02T12:43:57Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-02T12:43:57Z"}, "message": "Merge branch 'master' into feature/themes", "tree": {"sha": "055ee515dfaad62af5d2a92bb4ab921a88ee09de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/055ee515dfaad62af5d2a92bb4ab921a88ee09de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "html_url": "https://github.com/rust-lang/rust/commit/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b6c68e51fcbba59c2e99c31d1400cbd6d44f928", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b6c68e51fcbba59c2e99c31d1400cbd6d44f928", "html_url": "https://github.com/rust-lang/rust/commit/1b6c68e51fcbba59c2e99c31d1400cbd6d44f928"}, {"sha": "eb8f76a86fe88fcad370577b344f397dd6118cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8f76a86fe88fcad370577b344f397dd6118cfd", "html_url": "https://github.com/rust-lang/rust/commit/eb8f76a86fe88fcad370577b344f397dd6118cfd"}], "stats": {"total": 708, "additions": 605, "deletions": 103}, "files": [{"sha": "c97ea18a24ea0f6e45373716c60090f278f048ae", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -1053,4 +1053,13 @@ impl AssocItem {\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n+\n+    pub fn container(self, db: &impl DefDatabase) -> Container {\n+        match self {\n+            AssocItem::Function(f) => f.container(db),\n+            AssocItem::Const(c) => c.container(db),\n+            AssocItem::TypeAlias(t) => t.container(db),\n+        }\n+        .expect(\"AssocItem without container\")\n+    }\n }"}, {"sha": "9c261eda9f01ad5d97a532d2de63ffbaefb010c7", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -77,9 +77,10 @@ impl GenericParams {\n         let parent = match def {\n             GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n             GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n+            GenericDef::Const(it) => it.container(db).map(GenericDef::from),\n             GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n             GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n-            GenericDef::ImplBlock(_) | GenericDef::Const(_) => None,\n+            GenericDef::ImplBlock(_) => None,\n         };\n         let mut generics = GenericParams {\n             def,"}, {"sha": "a4ca59bba1b4c1eb912d3924d469d64d7395f40d", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -27,9 +27,9 @@ use crate::{\n     },\n     ids::LocationCtx,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n-    ty::method_resolution::implements_trait,\n-    Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId, MacroDef, Module,\n-    Name, Path, Resolver, Static, Struct, Ty,\n+    ty::method_resolution::{self, implements_trait},\n+    AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId,\n+    MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n };\n \n fn try_get_resolver_for_node(\n@@ -255,7 +255,9 @@ impl SourceAnalyzer {\n \n         let items =\n             self.resolver.resolve_module_path(db, &path).take_types().map(PathResolution::Def);\n-        types.or(values).or(items)\n+        types.or(values).or(items).or_else(|| {\n+            self.resolver.resolve_path_as_macro(db, &path).map(|def| PathResolution::Macro(def))\n+        })\n     }\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n@@ -325,16 +327,42 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         ty: Ty,\n         name: Option<&Name>,\n-        callback: impl FnMut(&Ty, Function) -> Option<T>,\n+        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    ) -> Option<T> {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        // FIXME replace Unknown by bound vars here\n+        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        method_resolution::iterate_method_candidates(\n+            &canonical,\n+            db,\n+            &self.resolver,\n+            name,\n+            method_resolution::LookupMode::MethodCall,\n+            |ty, it| match it {\n+                AssocItem::Function(f) => callback(ty, f),\n+                _ => None,\n+            },\n+        )\n+    }\n+\n+    pub fn iterate_path_candidates<T>(\n+        &self,\n+        db: &impl HirDatabase,\n+        ty: Ty,\n+        name: Option<&Name>,\n+        callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n+        // FIXME replace Unknown by bound vars here\n         let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n-        crate::ty::method_resolution::iterate_method_candidates(\n+        method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n             &self.resolver,\n             name,\n+            method_resolution::LookupMode::Path,\n             callback,\n         )\n     }"}, {"sha": "d1a9d74111ad39290e4b2c04122ad4e29a1e8840", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -385,13 +385,22 @@ impl SubstsBuilder {\n         self.param_count - self.vec.len()\n     }\n \n-    pub fn fill_with_bound_vars(mut self, starting_from: u32) -> Self {\n-        self.vec.extend((starting_from..starting_from + self.remaining() as u32).map(Ty::Bound));\n-        self\n+    pub fn fill_with_bound_vars(self, starting_from: u32) -> Self {\n+        self.fill((starting_from..).map(Ty::Bound))\n+    }\n+\n+    pub fn fill_with_params(self) -> Self {\n+        let start = self.vec.len() as u32;\n+        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n+    }\n+\n+    pub fn fill_with_unknown(self) -> Self {\n+        self.fill(iter::repeat(Ty::Unknown))\n     }\n \n-    pub fn fill_with_unknown(mut self) -> Self {\n-        self.vec.extend(iter::repeat(Ty::Unknown).take(self.remaining()));\n+    pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()));\n+        assert_eq!(self.remaining(), 0);\n         self\n     }\n "}, {"sha": "59b7f7eb64f3ca503fdf7b9f52b6eb45b4f2f5f4", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -6,8 +6,8 @@ use super::{ExprOrPatId, InferenceContext, TraitRef};\n use crate::{\n     db::HirDatabase,\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n-    ty::{Substs, Ty, TypableDef, TypeWalk},\n-    AssocItem, HasGenericParams, Namespace, Path,\n+    ty::{method_resolution, Substs, Ty, TypableDef, TypeWalk},\n+    AssocItem, Container, HasGenericParams, Name, Namespace, Path,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -39,7 +39,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n-                path.segments.last().expect(\"path had at least one segment\"),\n+                &path.segments.last().expect(\"path had at least one segment\").name,\n                 id,\n             )?\n         } else {\n@@ -122,10 +122,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     return None;\n                 }\n \n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n \n-                self.resolve_ty_assoc_item(ty, segment, id)\n+                self.resolve_ty_assoc_item(ty, &segment.name, id)\n             }\n         }\n     }\n@@ -162,7 +165,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         let substs = Substs::build_for_def(self.db, item)\n             .use_parent_substs(&trait_ref.substs)\n-            .fill_with_unknown()\n+            .fill_with_params()\n             .build();\n \n         self.write_assoc_resolution(id, item);\n@@ -172,44 +175,51 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n-        segment: &PathSegment,\n+        name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         if let Ty::Unknown = ty {\n             return None;\n         }\n \n-        let krate = self.resolver.krate()?;\n-\n-        // Find impl\n-        // FIXME: consider trait candidates\n-        let item = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n-            AssocItem::Function(func) => {\n-                if segment.name == func.name(self.db) {\n-                    Some(AssocItem::Function(func))\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n-                    Some(AssocItem::Const(konst))\n-                } else {\n-                    None\n-                }\n-            }\n-            AssocItem::TypeAlias(_) => None,\n-        })?;\n-        let def = match item {\n-            AssocItem::Function(f) => ValueNs::Function(f),\n-            AssocItem::Const(c) => ValueNs::Const(c),\n-            AssocItem::TypeAlias(_) => unreachable!(),\n-        };\n-        let substs = self.find_self_types(&def, ty);\n+        let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n+\n+        method_resolution::iterate_method_candidates(\n+            &canonical_ty.value,\n+            self.db,\n+            &self.resolver.clone(),\n+            Some(name),\n+            method_resolution::LookupMode::Path,\n+            move |_ty, item| {\n+                let def = match item {\n+                    AssocItem::Function(f) => ValueNs::Function(f),\n+                    AssocItem::Const(c) => ValueNs::Const(c),\n+                    AssocItem::TypeAlias(_) => unreachable!(),\n+                };\n+                let substs = match item.container(self.db) {\n+                    Container::ImplBlock(_) => self.find_self_types(&def, ty.clone()),\n+                    Container::Trait(t) => {\n+                        // we're picking this method\n+                        let trait_substs = Substs::build_for_def(self.db, t)\n+                            .push(ty.clone())\n+                            .fill(std::iter::repeat_with(|| self.new_type_var()))\n+                            .build();\n+                        let substs = Substs::build_for_def(self.db, item)\n+                            .use_parent_substs(&trait_substs)\n+                            .fill_with_params()\n+                            .build();\n+                        self.obligations.push(super::Obligation::Trait(TraitRef {\n+                            trait_: t,\n+                            substs: trait_substs,\n+                        }));\n+                        Some(substs)\n+                    }\n+                };\n \n-        self.write_assoc_resolution(id, item);\n-        Some((def, substs))\n+                self.write_assoc_resolution(id, item);\n+                Some((def, substs))\n+            },\n+        )\n     }\n \n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {"}, {"sha": "8c3d32d09dcce7d79da50adbfbbb35914716a7ea", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 100, "deletions": 41, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -166,37 +166,78 @@ pub(crate) fn lookup_method(\n     name: &Name,\n     resolver: &Resolver,\n ) -> Option<(Ty, Function)> {\n-    iterate_method_candidates(ty, db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n+    iterate_method_candidates(ty, db, resolver, Some(name), LookupMode::MethodCall, |ty, f| match f\n+    {\n+        AssocItem::Function(f) => Some((ty.clone(), f)),\n+        _ => None,\n+    })\n+}\n+\n+/// Whether we're looking up a dotted method call (like `v.len()`) or a path\n+/// (like `Vec::new`).\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum LookupMode {\n+    /// Looking up a method call like `v.len()`: We only consider candidates\n+    /// that have a `self` parameter, and do autoderef.\n+    MethodCall,\n+    /// Looking up a path like `Vec::new` or `Vec::default`: We consider all\n+    /// candidates including associated constants, but don't do autoderef.\n+    Path,\n }\n \n // This would be nicer if it just returned an iterator, but that runs into\n // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+// FIXME add a context type here?\n pub(crate) fn iterate_method_candidates<T>(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    mode: LookupMode,\n+    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n-    // For method calls, rust first does any number of autoderef, and then one\n-    // autoref (i.e. when the method takes &self or &mut self). We just ignore\n-    // the autoref currently -- when we find a method matching the given name,\n-    // we assume it fits.\n+    let krate = resolver.krate()?;\n+    match mode {\n+        LookupMode::MethodCall => {\n+            // For method calls, rust first does any number of autoderef, and then one\n+            // autoref (i.e. when the method takes &self or &mut self). We just ignore\n+            // the autoref currently -- when we find a method matching the given name,\n+            // we assume it fits.\n \n-    // Also note that when we've got a receiver like &S, even if the method we\n-    // find in the end takes &self, we still do the autoderef step (just as\n-    // rustc does an autoderef and then autoref again).\n+            // Also note that when we've got a receiver like &S, even if the method we\n+            // find in the end takes &self, we still do the autoderef step (just as\n+            // rustc does an autoderef and then autoref again).\n \n-    let krate = resolver.krate()?;\n-    for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n-        if let Some(result) = iterate_inherent_methods(&derefed_ty, db, name, krate, &mut callback)\n-        {\n-            return Some(result);\n+            for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n+                if let Some(result) =\n+                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n+                {\n+                    return Some(result);\n+                }\n+                if let Some(result) = iterate_trait_method_candidates(\n+                    &derefed_ty,\n+                    db,\n+                    resolver,\n+                    name,\n+                    mode,\n+                    &mut callback,\n+                ) {\n+                    return Some(result);\n+                }\n+            }\n         }\n-        if let Some(result) =\n-            iterate_trait_method_candidates(&derefed_ty, db, resolver, name, &mut callback)\n-        {\n-            return Some(result);\n+        LookupMode::Path => {\n+            // No autoderef for path lookups\n+            if let Some(result) =\n+                iterate_inherent_methods(&ty, db, name, mode, krate, &mut callback)\n+            {\n+                return Some(result);\n+            }\n+            if let Some(result) =\n+                iterate_trait_method_candidates(&ty, db, resolver, name, mode, &mut callback)\n+            {\n+                return Some(result);\n+            }\n         }\n     }\n     None\n@@ -207,7 +248,8 @@ fn iterate_trait_method_candidates<T>(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    mode: LookupMode,\n+    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n@@ -231,22 +273,20 @@ fn iterate_trait_method_candidates<T>(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = inherently_implemented;\n-        for item in data.items() {\n-            if let AssocItem::Function(m) = *item {\n-                let data = m.data(db);\n-                if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n-                    if !known_implemented {\n-                        let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n-                        if db.trait_solve(krate, goal).is_none() {\n-                            continue 'traits;\n-                        }\n-                    }\n-                    known_implemented = true;\n-                    if let Some(result) = callback(&ty.value, m) {\n-                        return Some(result);\n-                    }\n+        for &item in data.items() {\n+            if !is_valid_candidate(db, name, mode, item) {\n+                continue;\n+            }\n+            if !known_implemented {\n+                let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n+                if db.trait_solve(krate, goal).is_none() {\n+                    continue 'traits;\n                 }\n             }\n+            known_implemented = true;\n+            if let Some(result) = callback(&ty.value, item) {\n+                return Some(result);\n+            }\n         }\n     }\n     None\n@@ -256,28 +296,47 @@ fn iterate_inherent_methods<T>(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n+    mode: LookupMode,\n     krate: Crate,\n-    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     for krate in def_crates(db, krate, &ty.value)? {\n         let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n             for item in impl_block.items(db) {\n-                if let AssocItem::Function(f) = item {\n-                    let data = f.data(db);\n-                    if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n-                        if let Some(result) = callback(&ty.value, f) {\n-                            return Some(result);\n-                        }\n-                    }\n+                if !is_valid_candidate(db, name, mode, item) {\n+                    continue;\n+                }\n+                if let Some(result) = callback(&ty.value, item) {\n+                    return Some(result);\n                 }\n             }\n         }\n     }\n     None\n }\n \n+fn is_valid_candidate(\n+    db: &impl HirDatabase,\n+    name: Option<&Name>,\n+    mode: LookupMode,\n+    item: AssocItem,\n+) -> bool {\n+    match item {\n+        AssocItem::Function(m) => {\n+            let data = m.data(db);\n+            name.map_or(true, |name| data.name() == name)\n+                && (data.has_self_param() || mode == LookupMode::Path)\n+        }\n+        AssocItem::Const(c) => {\n+            name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n+                && (mode == LookupMode::Path)\n+        }\n+        _ => false,\n+    }\n+}\n+\n pub(crate) fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,"}, {"sha": "bfef48b1613a5a29c3a1ebaa043a52098e487337", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 168, "deletions": 5, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -1841,8 +1841,8 @@ fn test() {\n     [243; 254) 'Struct::FOO': u32\n     [264; 265) 'y': u32\n     [268; 277) 'Enum::BAR': u32\n-    [287; 288) 'z': {unknown}\n-    [291; 304) 'TraitTest::ID': {unknown}\n+    [287; 288) 'z': u32\n+    [291; 304) 'TraitTest::ID': u32\n     \"###\n     );\n }\n@@ -2782,16 +2782,163 @@ fn test() {\n     [97; 99) 's1': S\n     [105; 121) 'Defaul...efault': fn default<S>() -> Self\n     [105; 123) 'Defaul...ault()': S\n-    [133; 135) 's2': {unknown}\n-    [138; 148) 'S::default': {unknown}\n-    [138; 150) 'S::default()': {unknown}\n+    [133; 135) 's2': S\n+    [138; 148) 'S::default': fn default<S>() -> Self\n+    [138; 150) 'S::default()': S\n     [160; 162) 's3': S\n     [165; 188) '<S as ...efault': fn default<S>() -> Self\n     [165; 190) '<S as ...ault()': S\n     \"###\n     );\n }\n \n+#[test]\n+fn infer_trait_assoc_method_generics_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> T;\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make();\n+    let b = G::<u64>::make();\n+    let c: f64 = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [127; 211) '{     ...e(); }': ()\n+    [137; 138) 'a': u32\n+    [141; 148) 'S::make': fn make<S, u32>() -> T\n+    [141; 150) 'S::make()': u32\n+    [160; 161) 'b': u64\n+    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> T\n+    [164; 180) 'G::<u6...make()': u64\n+    [190; 191) 'c': f64\n+    [199; 206) 'G::make': fn make<G<f64>, f64>() -> T\n+    [199; 208) 'G::make()': f64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (T, U);\n+}\n+struct S;\n+impl Trait<u32> for S {}\n+struct G<T>;\n+impl<T> Trait<T> for G<T> {}\n+fn test() {\n+    let a = S::make::<i64>();\n+    let b: (_, i64) = S::make();\n+    let c = G::<u32>::make::<i64>();\n+    let d: (u32, _) = G::make::<i64>();\n+    let e: (u32, i64) = G::make();\n+}\n+\"#),\n+        @r###\"\n+    [135; 313) '{     ...e(); }': ()\n+    [145; 146) 'a': (u32, i64)\n+    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (T, U)\n+    [149; 165) 'S::mak...i64>()': (u32, i64)\n+    [175; 176) 'b': (u32, i64)\n+    [189; 196) 'S::make': fn make<S, u32, i64>() -> (T, U)\n+    [189; 198) 'S::make()': (u32, i64)\n+    [208; 209) 'c': (u32, i64)\n+    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [212; 235) 'G::<u3...i64>()': (u32, i64)\n+    [245; 246) 'd': (u32, i64)\n+    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [259; 275) 'G::mak...i64>()': (u32, i64)\n+    [285; 286) 'e': (u32, i64)\n+    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [301; 310) 'G::make()': (u32, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_3() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<i32> {}\n+fn test() {\n+    let a = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [101; 127) '{     ...e(); }': ()\n+    [111; 112) 'a': (S<i32>, i64)\n+    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (Self, T)\n+    [115; 124) 'S::make()': (S<i32>, i64)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_4() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make() -> (Self, T);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+impl Trait<i32> for S<u32> {}\n+fn test() {\n+    let a: (S<u64>, _) = S::make();\n+    let b: (_, i32) = S::make();\n+}\n+\"#),\n+        @r###\"\n+    [131; 203) '{     ...e(); }': ()\n+    [141; 142) 'a': (S<u64>, i64)\n+    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (Self, T)\n+    [158; 167) 'S::make()': (S<u64>, i64)\n+    [177; 178) 'b': (S<u32>, i32)\n+    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (Self, T)\n+    [191; 200) 'S::make()': (S<u32>, i32)\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_assoc_method_generics_5() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn make<U>() -> (Self, T, U);\n+}\n+struct S<T>;\n+impl Trait<i64> for S<u64> {}\n+fn test() {\n+    let a = <S as Trait<i64>>::make::<u8>();\n+    let b: (S<u64>, _, _) = Trait::<i64>::make::<u8>();\n+}\n+\"#),\n+        @r###\"\n+    [107; 211) '{     ...>(); }': ()\n+    [117; 118) 'a': (S<u64>, i64, u8)\n+    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [121; 152) '<S as ...<u8>()': (S<u64>, i64, u8)\n+    [162; 163) 'b': (S<u64>, i64, u8)\n+    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [182; 208) 'Trait:...<u8>()': (S<u64>, i64, u8)\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_from_bound_1() {\n     assert_snapshot!(\n@@ -3303,6 +3450,22 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[ignore]\n+#[test]\n+fn method_resolution_by_value_before_autoref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone { fn clone(&self) -> Self; }\n+struct S;\n+impl Clone for S {}\n+impl Clone for &S {}\n+fn test() { (S.clone(), (&S).clone(), (&&S).clone())<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, S, &S)\");\n+}\n+\n #[test]\n fn method_resolution_trait_before_autoderef() {\n     let t = type_at("}, {"sha": "9ac9768afb203e35c762fa63a3a01976d37195b9", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 135, "deletions": 7, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -50,23 +50,46 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n+            ctx.analyzer.iterate_path_candidates(ctx.db, ty.clone(), None, |_ty, item| {\n+                match item {\n+                    hir::AssocItem::Function(func) => {\n+                        let data = func.data(ctx.db);\n+                        if !data.has_self_param() {\n+                            acc.add_function(ctx, func);\n+                        }\n+                    }\n+                    hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+                    hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+                }\n+                None::<()>\n+            });\n+            // Iterate assoc types separately\n+            // FIXME: complete T::AssocType\n             let krate = ctx.module.map(|m| m.krate());\n             if let Some(krate) = krate {\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     match item {\n-                        hir::AssocItem::Function(func) => {\n-                            let data = func.data(ctx.db);\n-                            if !data.has_self_param() {\n-                                acc.add_function(ctx, func);\n-                            }\n-                        }\n-                        hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+                        hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => {}\n                         hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n                     }\n                     None::<()>\n                 });\n             }\n         }\n+        hir::ModuleDef::Trait(t) => {\n+            for item in t.items(ctx.db) {\n+                match item {\n+                    hir::AssocItem::Function(func) => {\n+                        let data = func.data(ctx.db);\n+                        if !data.has_self_param() {\n+                            acc.add_function(ctx, func);\n+                        }\n+                    }\n+                    hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+                    hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+                }\n+            }\n+        }\n         _ => {}\n     };\n }\n@@ -558,6 +581,111 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_trait_associated_method_1() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Trait {\n+                  /// A trait method\n+                  fn m();\n+                }\n+\n+                fn foo() { let _ = Trait::<|> }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m()\",\n+                source_range: [73; 73),\n+                delete: [73; 73),\n+                insert: \"m()$0\",\n+                kind: Function,\n+                lookup: \"m\",\n+                detail: \"fn m()\",\n+                documentation: Documentation(\n+                    \"A trait method\",\n+                ),\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_trait_associated_method_2() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Trait {\n+                  /// A trait method\n+                  fn m();\n+                }\n+\n+                struct S;\n+                impl Trait for S {}\n+\n+                fn foo() { let _ = S::<|> }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m()\",\n+                source_range: [99; 99),\n+                delete: [99; 99),\n+                insert: \"m()$0\",\n+                kind: Function,\n+                lookup: \"m\",\n+                detail: \"fn m()\",\n+                documentation: Documentation(\n+                    \"A trait method\",\n+                ),\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_trait_associated_method_3() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Trait {\n+                  /// A trait method\n+                  fn m();\n+                }\n+\n+                struct S;\n+                impl Trait for S {}\n+\n+                fn foo() { let _ = <S as Trait>::<|> }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m()\",\n+                source_range: [110; 110),\n+                delete: [110; 110),\n+                insert: \"m()$0\",\n+                kind: Function,\n+                lookup: \"m\",\n+                detail: \"fn m()\",\n+                documentation: Documentation(\n+                    \"A trait method\",\n+                ),\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_type_alias() {\n         assert_debug_snapshot!("}, {"sha": "c1ce54bea394986b5570d5032f22425f4053e67c", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -315,6 +315,25 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_definition_works_for_macros_in_use_tree() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            use foo::foo<|>;\n+\n+            //- /foo/lib.rs\n+            #[macro_export]\n+            macro_rules! foo {\n+                () => {\n+                    {}\n+                };\n+            }\n+            \",\n+            \"foo MACRO_CALL FileId(2) [0; 66) [29; 32)\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_definition_works_for_methods() {\n         covers!(goto_definition_works_for_methods);\n@@ -371,6 +390,61 @@ mod tests {\n             \"spam RECORD_FIELD_DEF FileId(1) [17; 26) [17; 21)\",\n         );\n     }\n+\n+    #[test]\n+    fn goto_definition_works_for_ufcs_inherent_methods() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn frobnicate() {  }\n+            }\n+\n+            fn bar(foo: &Foo) {\n+                Foo::frobnicate<|>();\n+            }\n+            \",\n+            \"frobnicate FN_DEF FileId(1) [27; 47) [30; 40)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_definition_works_for_ufcs_trait_methods_through_traits() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            trait Foo {\n+                fn frobnicate();\n+            }\n+\n+            fn bar() {\n+                Foo::frobnicate<|>();\n+            }\n+            \",\n+            \"frobnicate FN_DEF FileId(1) [16; 32) [19; 29)\",\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_definition_works_for_ufcs_trait_methods_through_self() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            struct Foo;\n+            trait Trait {\n+                fn frobnicate();\n+            }\n+            impl Trait for Foo {}\n+\n+            fn bar() {\n+                Foo::frobnicate<|>();\n+            }\n+            \",\n+            \"frobnicate FN_DEF FileId(1) [30; 46) [33; 43)\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_definition_on_self() {\n         check_goto("}, {"sha": "1ec9881b980892298ceb88eee58778e33662eafc", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -112,6 +112,20 @@ fn test_doc_comment_of_items() {\n     assert_eq!(\"doc\", module.doc_comment_text().unwrap());\n }\n \n+#[test]\n+fn test_doc_comment_of_statics() {\n+    let file = SourceFile::parse(\n+        r#\"\n+        /// Number of levels\n+        static LEVELS: i32 = 0;\n+        \"#,\n+    )\n+    .ok()\n+    .unwrap();\n+    let st = file.syntax().descendants().find_map(StaticDef::cast).unwrap();\n+    assert_eq!(\"Number of levels\", st.doc_comment_text().unwrap());\n+}\n+\n #[test]\n fn test_doc_comment_preserves_indents() {\n     let file = SourceFile::parse("}, {"sha": "c36756d6c37ce6c58bc6f0a1206a3370a291eeae", "filename": "crates/ra_syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -147,7 +147,7 @@ fn n_attached_trivias<'a>(\n ) -> usize {\n     match kind {\n         MACRO_CALL | CONST_DEF | TYPE_ALIAS_DEF | STRUCT_DEF | ENUM_DEF | ENUM_VARIANT | FN_DEF\n-        | TRAIT_DEF | MODULE | RECORD_FIELD_DEF => {\n+        | TRAIT_DEF | MODULE | RECORD_FIELD_DEF | STATIC_DEF => {\n             let mut res = 0;\n             for (i, (kind, text)) in trivias.enumerate() {\n                 match kind {"}, {"sha": "bae4c4650c098b2afa97f952bbf3b3659f0cbb58", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=1d8bb4c6c1fef1f8ea513e07d0a7d4c5483129d2", "patch": "@@ -3,6 +3,7 @@\n pub mod codegen;\n \n use std::{\n+    env,\n     error::Error,\n     fs,\n     io::{Error as IoError, ErrorKind},\n@@ -17,7 +18,13 @@ pub type Result<T> = std::result::Result<T, Box<dyn Error>>;\n const TOOLCHAIN: &str = \"stable\";\n \n pub fn project_root() -> PathBuf {\n-    Path::new(&env!(\"CARGO_MANIFEST_DIR\")).ancestors().nth(1).unwrap().to_path_buf()\n+    Path::new(\n+        &env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned()),\n+    )\n+    .ancestors()\n+    .nth(1)\n+    .unwrap()\n+    .to_path_buf()\n }\n \n pub struct Cmd<'a> {"}]}