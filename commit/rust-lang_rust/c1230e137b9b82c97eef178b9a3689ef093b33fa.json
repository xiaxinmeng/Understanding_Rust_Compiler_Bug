{"sha": "c1230e137b9b82c97eef178b9a3689ef093b33fa", "node_id": "C_kwDOAAsO6NoAKGMxMjMwZTEzN2I5YjgyYzk3ZWVmMTc4YjlhMzY4OWVmMDkzYjMzZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-28T22:47:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-28T22:47:31Z"}, "message": "Auto merge of #95249 - HeroicKatora:set-ptr-value, r=dtolnay\n\nRefactor set_ptr_value as with_metadata_of\n\nReplaces `set_ptr_value` (#75091) with methods of reversed argument order:\n\n```rust\nimpl<T: ?Sized> *mut T {\n    pub fn with_metadata_of<U: ?Sized>(self, val: *mut U) -> *mut U;\n}\n\nimpl<T: ?Sized> *const T {\n    pub fn with_metadata_of<U: ?Sized>(self, val: *const U) -> *const U;\n}\n```\n\nBy reversing the arguments we achieve several clarifications:\n\n- The function closely resembles `cast` with an argument to\n  initialize the metadata. This is easier to teach and answers a long\n  outstanding question that had restricted cast to `Sized` pointee\n  targets. See multiples reviews of\n  <https://github.com/rust-lang/rust/pull/47631>\n- The 'object identity', in the form of provenance, is now preserved\n  from the receiver argument to the result. This helps explain the method as\n  a builder-style, instead of some kind of setter that would modify\n  something in-place. Ensuring that the result has the identity of the\n  `self` argument is also beneficial for an intuition of effects.\n- An outstanding concern, 'Correct argument type', is avoided by not\n  committing to any specific argument type. This is consistent with cast\n  which does not require its receiver to be a 'raw address'.\n\nHopefully the usage examples in `sync/rc.rs` serve as sufficient examples of the style to convince the reader of the readability improvements of this style, when compared to the previous order of arguments.\n\nI want to take the opportunity to motivate inclusion of this method _separate_ from metadata API, separate from `feature(ptr_metadata)`. It does _not_ involve the `Pointee` trait in any form. This may be regarded as a very, very light form that does not commit to any details of the pointee trait, or its associated metadata. There are several use cases for which this is already sufficient and no further inspection of metadata is necessary.\n\n- Storing the coercion of `*mut T` into `*mut dyn Trait` as a way to dynamically cast some an arbitrary instance of the same type to a dyn trait instance. In particular, one can have a field of type `Option<*mut dyn io::Seek>` to memorize if a particular writer is seekable. Then a method `fn(self: &T) -> Option<&dyn Seek>` can be provided, which does _not_ involve the static trait bound `T: Seek`. This makes it possible to create an API that is capable of utilizing seekable streams and non-seekable streams (instead of a possible less efficient manner such as more buffering) through the same entry-point.\n\n- Enabling more generic forms of unsizing for no-`std` smart pointers. Using the stable APIs only few concrete cases are available. One can unsize arrays to `[T]` by `ptr::slice_from_raw_parts` but unsizing a custom smart pointer to, e.g., `dyn Iterator`, `dyn Future`, `dyn Debug`, can't easily be done generically. Exposing `with_metadata_of` would allow smart pointers to offer their own `unsafe` escape hatch with similar parameters where the caller provides the unsized metadata. This is particularly interesting for embedded where `dyn`-trait usage can drastically reduce code size.", "tree": {"sha": "da70135abbfb4dffe8de53c17cdbe61d019d11a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da70135abbfb4dffe8de53c17cdbe61d019d11a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1230e137b9b82c97eef178b9a3689ef093b33fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1230e137b9b82c97eef178b9a3689ef093b33fa", "html_url": "https://github.com/rust-lang/rust/commit/c1230e137b9b82c97eef178b9a3689ef093b33fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1230e137b9b82c97eef178b9a3689ef093b33fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee915c34e2f33a07856a9e39be7e35e648bfbd5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee915c34e2f33a07856a9e39be7e35e648bfbd5d", "html_url": "https://github.com/rust-lang/rust/commit/ee915c34e2f33a07856a9e39be7e35e648bfbd5d"}, {"sha": "d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "url": "https://api.github.com/repos/rust-lang/rust/commits/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40", "html_url": "https://github.com/rust-lang/rust/commit/d489ea777d38c5d44a5394bcd4bdcc69eb3cda40"}], "stats": {"total": 183, "additions": 95, "deletions": 88}, "files": [{"sha": "3ddc9acb2e7db5f322485be3d27b7adf71daeba7", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=c1230e137b9b82c97eef178b9a3689ef093b33fa", "patch": "@@ -895,7 +895,7 @@ impl<T: ?Sized> Rc<T> {\n \n         // Reverse the offset to find the original RcBox.\n         let rc_ptr =\n-            unsafe { (ptr as *mut RcBox<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) };\n+            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut RcBox<T>) };\n \n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n@@ -1338,7 +1338,7 @@ impl<T: ?Sized> Rc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| (ptr as *mut RcBox<T>).set_ptr_value(mem),\n+                |mem| mem.with_metadata_of(ptr as *mut RcBox<T>),\n             )\n         }\n     }\n@@ -2264,7 +2264,7 @@ impl<T: ?Sized> Weak<T> {\n             let offset = unsafe { data_offset(ptr) };\n             // Thus, we reverse the offset to get the whole RcBox.\n             // SAFETY: the pointer originated from a Weak, so this offset is safe.\n-            unsafe { (ptr as *mut RcBox<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) }\n+            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut RcBox<T>) }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak."}, {"sha": "e2b9890850b3adf3ec47b9bf42321bd4fbc97f79", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=c1230e137b9b82c97eef178b9a3689ef093b33fa", "patch": "@@ -895,7 +895,8 @@ impl<T: ?Sized> Arc<T> {\n             let offset = data_offset(ptr);\n \n             // Reverse the offset to find the original ArcInner.\n-            let arc_ptr = (ptr as *mut ArcInner<T>).set_ptr_value((ptr as *mut u8).offset(-offset));\n+            let arc_ptr =\n+                (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut ArcInner<T>);\n \n             Self::from_ptr(arc_ptr)\n         }\n@@ -1182,7 +1183,7 @@ impl<T: ?Sized> Arc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| (ptr as *mut ArcInner<T>).set_ptr_value(mem) as *mut ArcInner<T>,\n+                |mem| mem.with_metadata_of(ptr as *mut ArcInner<T>),\n             )\n         }\n     }\n@@ -1888,7 +1889,7 @@ impl<T: ?Sized> Weak<T> {\n             let offset = unsafe { data_offset(ptr) };\n             // Thus, we reverse the offset to get the whole RcBox.\n             // SAFETY: the pointer originated from a Weak, so this offset is safe.\n-            unsafe { (ptr as *mut ArcInner<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) }\n+            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut ArcInner<T>) }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak."}, {"sha": "74c64370ddcda4997e398ff299d64910a2531c1a", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=c1230e137b9b82c97eef178b9a3689ef093b33fa", "patch": "@@ -48,6 +48,50 @@ impl<T: ?Sized> *const T {\n         self as _\n     }\n \n+    /// Use the pointer value in a new pointer of another type.\n+    ///\n+    /// In case `val` is a (fat) pointer to an unsized type, this operation\n+    /// will ignore the pointer part, whereas for (thin) pointers to sized\n+    /// types, this has the same effect as a simple cast.\n+    ///\n+    /// The resulting pointer will have provenance of `self`, i.e., for a fat\n+    /// pointer, this operation is semantically the same as creating a new\n+    /// fat pointer with the data pointer value of `self` but the metadata of\n+    /// `val`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = arr.as_ptr() as *const dyn Debug;\n+    /// let thin = ptr as *const u8;\n+    /// unsafe {\n+    ///     ptr = thin.add(8).with_metadata_of(ptr);\n+    ///     # assert_eq!(*(ptr as *const i32), 3);\n+    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[inline]\n+    pub fn with_metadata_of<U>(self, mut val: *const U) -> *const U\n+    where\n+        U: ?Sized,\n+    {\n+        let target = &mut val as *mut *const U as *mut *const u8;\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *target = self as *const u8 };\n+        val\n+    }\n+\n     /// Changes constness without changing the type.\n     ///\n     /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n@@ -764,47 +808,6 @@ impl<T: ?Sized> *const T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n-    /// Sets the pointer value to `ptr`.\n-    ///\n-    /// In case `self` is a (fat) pointer to an unsized type, this operation\n-    /// will only affect the pointer part, whereas for (thin) pointers to\n-    /// sized types, this has the same effect as a simple assignment.\n-    ///\n-    /// The resulting pointer will have provenance of `val`, i.e., for a fat\n-    /// pointer, this operation is semantically the same as creating a new\n-    /// fat pointer with the data pointer value of `val` but the metadata of\n-    /// `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This function is primarily useful for allowing byte-wise pointer\n-    /// arithmetic on potentially fat pointers:\n-    ///\n-    /// ```\n-    /// #![feature(set_ptr_value)]\n-    /// # use core::fmt::Debug;\n-    /// let arr: [i32; 3] = [1, 2, 3];\n-    /// let mut ptr = arr.as_ptr() as *const dyn Debug;\n-    /// let thin = ptr as *const u8;\n-    /// unsafe {\n-    ///     ptr = ptr.set_ptr_value(thin.add(8));\n-    ///     # assert_eq!(*(ptr as *const i32), 3);\n-    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n-    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n-    #[inline]\n-    pub fn set_ptr_value(mut self, val: *const u8) -> Self {\n-        let thin = &mut self as *mut *const T as *mut *const u8;\n-        // SAFETY: In case of a thin pointer, this operations is identical\n-        // to a simple assignment. In case of a fat pointer, with the current\n-        // fat pointer layout implementation, the first field of such a\n-        // pointer is always the data pointer, which is likewise assigned.\n-        unsafe { *thin = val };\n-        self\n-    }\n-\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "7e48eac4fe0330690cde143eded18320623c59e5", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1230e137b9b82c97eef178b9a3689ef093b33fa/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=c1230e137b9b82c97eef178b9a3689ef093b33fa", "patch": "@@ -47,6 +47,50 @@ impl<T: ?Sized> *mut T {\n         self as _\n     }\n \n+    /// Use the pointer value in a new pointer of another type.\n+    ///\n+    /// In case `val` is a (fat) pointer to an unsized type, this operation\n+    /// will ignore the pointer part, whereas for (thin) pointers to sized\n+    /// types, this has the same effect as a simple cast.\n+    ///\n+    /// The resulting pointer will have provenance of `self`, i.e., for a fat\n+    /// pointer, this operation is semantically the same as creating a new\n+    /// fat pointer with the data pointer value of `self` but the metadata of\n+    /// `val`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let mut arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = arr.as_mut_ptr() as *mut dyn Debug;\n+    /// let thin = ptr as *mut u8;\n+    /// unsafe {\n+    ///     ptr = thin.add(8).with_metadata_of(ptr);\n+    ///     # assert_eq!(*(ptr as *mut i32), 3);\n+    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[inline]\n+    pub fn with_metadata_of<U>(self, mut val: *mut U) -> *mut U\n+    where\n+        U: ?Sized,\n+    {\n+        let target = &mut val as *mut *mut U as *mut *mut u8;\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *target = self as *mut u8 };\n+        val\n+    }\n+\n     /// Changes constness without changing the type.\n     ///\n     /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n@@ -878,47 +922,6 @@ impl<T: ?Sized> *mut T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n-    /// Sets the pointer value to `ptr`.\n-    ///\n-    /// In case `self` is a (fat) pointer to an unsized type, this operation\n-    /// will only affect the pointer part, whereas for (thin) pointers to\n-    /// sized types, this has the same effect as a simple assignment.\n-    ///\n-    /// The resulting pointer will have provenance of `val`, i.e., for a fat\n-    /// pointer, this operation is semantically the same as creating a new\n-    /// fat pointer with the data pointer value of `val` but the metadata of\n-    /// `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This function is primarily useful for allowing byte-wise pointer\n-    /// arithmetic on potentially fat pointers:\n-    ///\n-    /// ```\n-    /// #![feature(set_ptr_value)]\n-    /// # use core::fmt::Debug;\n-    /// let mut arr: [i32; 3] = [1, 2, 3];\n-    /// let mut ptr = arr.as_mut_ptr() as *mut dyn Debug;\n-    /// let thin = ptr as *mut u8;\n-    /// unsafe {\n-    ///     ptr = ptr.set_ptr_value(thin.add(8));\n-    ///     # assert_eq!(*(ptr as *mut i32), 3);\n-    ///     println!(\"{:?}\", &*ptr); // will print \"3\"\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n-    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n-    #[inline]\n-    pub fn set_ptr_value(mut self, val: *mut u8) -> Self {\n-        let thin = &mut self as *mut *mut T as *mut *mut u8;\n-        // SAFETY: In case of a thin pointer, this operations is identical\n-        // to a simple assignment. In case of a fat pointer, with the current\n-        // fat pointer layout implementation, the first field of such a\n-        // pointer is always the data pointer, which is likewise assigned.\n-        unsafe { *thin = val };\n-        self\n-    }\n-\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}]}