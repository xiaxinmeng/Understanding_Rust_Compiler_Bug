{"sha": "5f65ee2713325683af32c956f7a33e3d6d7d9d90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNjVlZTI3MTMzMjU2ODNhZjMyYzk1NmY3YTMzZTNkNmQ3ZDlkOTA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-14T09:31:45Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-14T09:31:45Z"}, "message": "Refactor in preparation for `Value` locals.\n\nTurning locals into `Vec<Value>` will allow writing `PrimVal` results\ndirectly into the locals array without creating `memory::Allocation`s\nfor every local.\n\nThis will entail passing around a generalized kind of `Lvalue` instead\nof `Pointer`s for the destinations of operations. Replacing `Pointer`\nwith `Lvalue` is mostly done with this commit, but expanding `Lvalue`\nwill come later.\n\nThis commit turns every local from `Pointer` into `Value::ByRef(ptr)`.\nLocals which are `Value::ByVal(prim_val)` will come in a later commit.", "tree": {"sha": "77606ba087e5973f258fbd30e698dd0d6c42b58c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77606ba087e5973f258fbd30e698dd0d6c42b58c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f65ee2713325683af32c956f7a33e3d6d7d9d90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f65ee2713325683af32c956f7a33e3d6d7d9d90", "html_url": "https://github.com/rust-lang/rust/commit/5f65ee2713325683af32c956f7a33e3d6d7d9d90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f65ee2713325683af32c956f7a33e3d6d7d9d90/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb23b8d0a79b598d4a56d992fbb4c62a74d58b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb23b8d0a79b598d4a56d992fbb4c62a74d58b68", "html_url": "https://github.com/rust-lang/rust/commit/cb23b8d0a79b598d4a56d992fbb4c62a74d58b68"}], "stats": {"total": 410, "additions": 283, "deletions": 127}, "files": [{"sha": "dc787a7608c7d6a5f48372f8b9cf51438612be4e", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 142, "deletions": 62, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=5f65ee2713325683af32c956f7a33e3d6d7d9d90", "patch": "@@ -78,7 +78,7 @@ pub struct Frame<'a, 'tcx: 'a> {\n \n     /// The list of locals for the current function, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`.\n-    pub locals: Vec<Pointer>,\n+    pub locals: Vec<Value>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -93,7 +93,7 @@ pub struct Frame<'a, 'tcx: 'a> {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-struct Lvalue {\n+pub struct Lvalue {\n     ptr: Pointer,\n     extra: LvalueExtra,\n }\n@@ -157,7 +157,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloc_ret_ptr(&mut self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn alloc_ptr(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> EvalResult<'tcx, Pointer> {\n         let size = self.type_size_with_substs(ty, substs);\n         let align = self.type_align_with_substs(ty, substs);\n         self.memory.allocate(size, align)\n@@ -175,7 +179,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n-    fn target_isize_primval(&self, n: i64) -> PrimVal {\n+    fn isize_primval(&self, n: i64) -> PrimVal {\n         match self.memory.pointer_size() {\n             1 => PrimVal::I8(n as i8),\n             2 => PrimVal::I16(n as i16),\n@@ -185,7 +189,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn target_usize_primval(&self, n: u64) -> PrimVal {\n+    fn usize_primval(&self, n: u64) -> PrimVal {\n         match self.memory.pointer_size() {\n             1 => PrimVal::U8(n as u8),\n             2 => PrimVal::U16(n as u16),\n@@ -200,7 +204,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let ptr = self.memory.allocate(s.len(), 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(Value::ByValPair(PrimVal::Ptr(ptr), self.target_usize_primval(s.len() as u64)))\n+        Ok(Value::ByValPair(PrimVal::Ptr(ptr), self.usize_primval(s.len() as u64)))\n     }\n \n     fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n@@ -326,19 +330,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         span: codemap::Span,\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n-        return_ptr: Pointer,\n+        return_lvalue: Lvalue,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n         let local_tys = mir.local_decls.iter().map(|a| a.ty);\n \n         ::log_settings::settings().indentation += 1;\n \n+        // FIXME(solson)\n+        let return_ptr = return_lvalue.to_ptr();\n+\n         // directly change the first allocation (the return value) to *be* the allocation where the\n         // caller stores the result\n-        let locals: EvalResult<'tcx, Vec<Pointer>> = iter::once(Ok(return_ptr)).chain(local_tys.skip(1).map(|ty| {\n+        let locals: EvalResult<'tcx, Vec<Value>> = iter::once(Ok(Value::ByRef(return_ptr))).chain(local_tys.skip(1).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n             let align = self.type_align_with_substs(ty, substs);\n-            self.memory.allocate(size, align)\n+\n+            // FIXME(solson)\n+            self.memory.allocate(size, align).map(Value::ByRef)\n         })).collect();\n \n         self.stack.push(Frame {\n@@ -377,7 +386,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Pointer,\n+        dest: Lvalue,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n         use rustc::ty::layout::Layout::*;\n@@ -387,6 +396,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         };\n \n         let overflowed = self.intrinsic_overflowing(op, left, right, dest)?;\n+\n+        // FIXME(solson)\n+        let dest = dest.to_ptr();\n+\n         let offset = tup_layout.offsets[1].bytes() as isize;\n         self.memory.write_bool(dest.offset(offset), overflowed)\n     }\n@@ -398,26 +411,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n-        dest: Pointer,\n+        dest: Lvalue,\n     ) -> EvalResult<'tcx, bool> {\n         let left_primval = self.eval_operand_to_primval(left)?;\n         let right_primval = self.eval_operand_to_primval(right)?;\n         let (val, overflow) = primval::binary_op(op, left_primval, right_primval)?;\n-        self.memory.write_primval(dest, val)?;\n+        self.write_primval(dest, val)?;\n         Ok(overflow)\n     }\n \n     fn assign_fields<I: IntoIterator<Item = u64>>(\n         &mut self,\n-        dest: Pointer,\n+        dest: Lvalue,\n         offsets: I,\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n+        // FIXME(solson)\n+        let dest = dest.to_ptr();\n+\n         for (offset, operand) in offsets.into_iter().zip(operands) {\n             let value = self.eval_operand(operand)?;\n             let value_ty = self.operand_ty(operand);\n             let field_dest = dest.offset(offset as isize);\n-            self.write_value(value, field_dest, value_ty)?;\n+            self.write_value_to_ptr(value, field_dest, value_ty)?;\n         }\n         Ok(())\n     }\n@@ -431,7 +447,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         rvalue: &mir::Rvalue<'tcx>,\n         lvalue: &mir::Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n-        let dest = self.eval_lvalue(lvalue)?.to_ptr();\n+        let dest = self.eval_lvalue(lvalue)?;\n         let dest_ty = self.lvalue_ty(lvalue);\n         let dest_layout = self.type_layout(dest_ty);\n \n@@ -453,7 +469,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_primval(operand)?;\n-                self.memory.write_primval(dest, primval::unary_op(un_op, val)?)?;\n+                self.write_primval(dest, primval::unary_op(un_op, val)?)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -478,7 +494,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let discr_val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n                             let discr_size = discr.size().bytes() as usize;\n                             let discr_offset = variants[variant].offsets[0].bytes() as isize;\n-                            let discr_dest = dest.offset(discr_offset);\n+\n+                            // FIXME(solson)\n+                            let discr_dest = (dest.to_ptr()).offset(discr_offset);\n+\n                             self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n                             // Don't include the first offset; it's for the discriminant.\n@@ -500,7 +519,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 self.write_value(value, dest, value_ty)?;\n                             } else {\n                                 assert_eq!(operands.len(), 0);\n-                                self.memory.write_isize(dest, 0)?;\n+                                let zero = self.isize_primval(0);\n+                                self.write_primval(dest, zero)?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -518,6 +538,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     assert_eq!(self.type_size(operand_ty), 0);\n                                 }\n                                 let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield)?;\n+\n+                                // FIXME(solson)\n+                                let dest = dest.to_ptr();\n+\n                                 let dest = dest.offset(offset.bytes() as isize);\n                                 try!(self.memory.write_isize(dest, 0));\n                             }\n@@ -532,6 +556,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n                             let size = discr.size().bytes() as usize;\n \n+                            // FIXME(solson)\n+                            let dest = dest.to_ptr();\n+\n                             if signed {\n                                 self.memory.write_int(dest, val as i64, size)?;\n                             } else {\n@@ -553,20 +580,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 let elem_size = self.type_size(elem_ty);\n                 let value = self.eval_operand(operand)?;\n+\n+                // FIXME(solson)\n+                let dest = dest.to_ptr();\n+\n                 for i in 0..length {\n                     let elem_dest = dest.offset((i * elem_size) as isize);\n-                    self.write_value(value, elem_dest, elem_ty)?;\n+                    self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n                 }\n             }\n \n             Len(ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let (_, len) = src.elem_ty_and_len(ty);\n-                self.memory.write_usize(dest, len)?;\n+                let len_val = self.usize_primval(len);\n+                self.write_primval(dest, len_val)?;\n             }\n \n             Ref(_, _, ref lvalue) => {\n+                // FIXME(solson)\n+                let dest = dest.to_ptr();\n+\n                 let lvalue = self.eval_lvalue(lvalue)?;\n                 self.memory.write_ptr(dest, lvalue.ptr)?;\n                 let extra_ptr = dest.offset(self.memory.pointer_size() as isize);\n@@ -580,13 +615,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Box(ty) => {\n+                // FIXME(solson)\n+                let dest = dest.to_ptr();\n+\n                 let size = self.type_size(ty);\n                 let align = self.type_align(ty);\n                 let ptr = self.memory.allocate(size, align)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n+                // FIXME(solson)\n+                let dest = dest.to_ptr();\n+\n                 debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n@@ -778,7 +819,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n-            Local(i) => self.frame().locals[i.index()],\n+            Local(i) => {\n+                match self.frame().locals[i.index()] {\n+                    Value::ByRef(p) => p,\n+                    _ => bug!(),\n+                }\n+            }\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n@@ -910,7 +956,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n     }\n \n-    fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         let size = self.type_size(ty);\n         let align = self.type_align(ty);\n         self.memory.copy(src, dest, size, align)?;\n@@ -957,14 +1003,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    fn write_primval(\n+        &mut self,\n+        dest: Lvalue,\n+        val: PrimVal,\n+    ) -> EvalResult<'tcx, ()> {\n+        // FIXME(solson)\n+        let dest = dest.to_ptr();\n+\n+        self.memory.write_primval(dest, val)\n+    }\n+\n     fn write_value(\n+        &mut self,\n+        value: Value,\n+        dest: Lvalue,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        // FIXME(solson)\n+        let dest = dest.to_ptr();\n+        self.write_value_to_ptr(value, dest, dest_ty)\n+    }\n+\n+    fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n         dest: Pointer,\n-        dest_ty: Ty<'tcx>\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match value {\n-            Value::ByRef(ptr) => self.move_(ptr, dest, dest_ty),\n+            Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n             Value::ByVal(primval) => self.memory.write_primval(dest, primval),\n             Value::ByValPair(a, b) => {\n                 self.memory.write_primval(dest, a)?;\n@@ -984,7 +1052,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        use syntax::ast::{IntTy, UintTy, FloatTy};\n+        use syntax::ast::FloatTy;\n+\n         let val = match &ty.sty {\n             &ty::TyBool => PrimVal::Bool(self.memory.read_bool(ptr)?),\n             &ty::TyChar => {\n@@ -995,17 +1064,31 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n \n-            &ty::TyInt(IntTy::I8)    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n-            &ty::TyInt(IntTy::I16)   => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n-            &ty::TyInt(IntTy::I32)   => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n-            &ty::TyInt(IntTy::I64)   => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n-            &ty::TyUint(UintTy::U8)  => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n-            &ty::TyUint(UintTy::U16) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n-            &ty::TyUint(UintTy::U32) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n-            &ty::TyUint(UintTy::U64) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n+            &ty::TyInt(int_ty) => {\n+                use syntax::ast::IntTy::*;\n+                let size = match int_ty {\n+                    I8 => 1,\n+                    I16 => 2,\n+                    I32 => 4,\n+                    I64 => 8,\n+                    Is => self.memory.pointer_size(),\n+                };\n+                let n = self.memory.read_int(ptr, size)?;\n+                PrimVal::int_with_size(n, size)\n+            }\n \n-            &ty::TyInt(IntTy::Is)    => self.target_isize_primval(self.memory.read_isize(ptr)?),\n-            &ty::TyUint(UintTy::Us)  => self.target_usize_primval(self.memory.read_usize(ptr)?),\n+            &ty::TyUint(uint_ty) => {\n+                use syntax::ast::UintTy::*;\n+                let size = match uint_ty {\n+                    U8 => 1,\n+                    U16 => 2,\n+                    U32 => 4,\n+                    U64 => 8,\n+                    Us => self.memory.pointer_size(),\n+                };\n+                let n = self.memory.read_uint(ptr, size)?;\n+                PrimVal::uint_with_size(n, size)\n+            }\n \n             &ty::TyFloat(FloatTy::F32) => PrimVal::F32(self.memory.read_f32(ptr)?),\n             &ty::TyFloat(FloatTy::F64) => PrimVal::F64(self.memory.read_f64(ptr)?),\n@@ -1026,7 +1109,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let extra = match self.tcx.struct_tail(ty).sty {\n                         ty::TyTrait(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n-                        ty::TyStr => self.target_usize_primval(self.memory.read_usize(extra)?),\n+                        ty::TyStr => self.usize_primval(self.memory.read_usize(extra)?),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n                     };\n                     return Ok(Value::ByValPair(PrimVal::Ptr(p), extra));\n@@ -1036,16 +1119,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             &ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n-                    match (discr.size().bytes(), signed) {\n-                        (1, true)  => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n-                        (2, true)  => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n-                        (4, true)  => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n-                        (8, true)  => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n-                        (1, false) => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n-                        (2, false) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n-                        (4, false) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n-                        (8, false) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n-                        (size, _) => bug!(\"CEnum discr size {}\", size),\n+                    let size = discr.size().bytes() as usize;\n+                    if signed {\n+                        let n = self.memory.read_int(ptr, size)?;\n+                        PrimVal::int_with_size(n, size)\n+                    } else {\n+                        let n = self.memory.read_uint(ptr, size)?;\n+                        PrimVal::uint_with_size(n, size)\n                     }\n                 } else {\n                     bug!(\"primitive read of non-clike enum: {:?}\", ty);\n@@ -1100,7 +1180,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         // For now, upcasts are limited to changes in marker\n                         // traits, and hence never actually require an actual\n                         // change to the vtable.\n-                        self.write_value(src, dest, dest_ty)?;\n+                        self.write_value_to_ptr(src, dest, dest_ty)?;\n                     },\n                     (_, &ty::TyTrait(ref data)) => {\n                         let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n@@ -1146,7 +1226,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let src_f_ptr = src_ptr.offset(src_field_offset);\n                     let dst_f_ptr = dest.offset(dst_field_offset);\n                     if src_fty == dst_fty {\n-                        self.move_(src_f_ptr, dst_f_ptr, src_fty)?;\n+                        self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n                     } else {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, dst_f_ptr, dst_fty)?;\n                     }\n@@ -1161,10 +1241,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n impl Lvalue {\n+    fn from_ptr(ptr: Pointer) -> Self {\n+        Lvalue { ptr: ptr, extra: LvalueExtra::None }\n+    }\n+\n     fn to_ptr(self) -> Pointer {\n         assert_eq!(self.extra, LvalueExtra::None);\n         self.ptr\n     }\n+\n     fn elem_ty_and_len<'tcx>(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n         match ty.sty {\n             ty::TyArray(elem, n) => (elem, n as u64),\n@@ -1199,27 +1284,22 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let mir = mir_map.map.get(&def_id).expect(\"no mir for main function\");\n     let mut ecx = EvalContext::new(tcx, mir_map, memory_size, stack_limit);\n     let substs = subst::Substs::empty(tcx);\n-    let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n+    let return_ptr = ecx.alloc_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, return_ptr, StackPopCleanup::None)\n-        .expect(\"could not allocate first stack frame\");\n-\n-    // FIXME: this is a horrible and wrong way to detect the start function, but overwriting the first two locals shouldn't do much\n-    if mir.local_decls.len() > 2 {\n-        // start function\n-        let nargs = ecx.frame_mut().locals[1];\n-        let args = ecx.frame_mut().locals[2];\n-        // ignore errors, if the locals are too small this is not the start function\n-        let _ = ecx.memory_mut().write_usize(nargs, 0);\n-        let _ = ecx.memory_mut().write_usize(args, 0);\n-    }\n+    ecx.push_stack_frame(\n+        def_id,\n+        mir.span,\n+        CachedMir::Ref(mir),\n+        substs,\n+        Lvalue::from_ptr(return_ptr), // FIXME(solson)\n+        StackPopCleanup::None\n+    ).expect(\"could not allocate first stack frame\");\n \n     for _ in 0..step_limit {\n         match ecx.step() {\n             Ok(true) => {}\n             Ok(false) => return,\n-            // FIXME: diverging functions can end up here in some future miri\n             Err(e) => {\n                 report(tcx, &ecx, e);\n                 return;"}, {"sha": "7888257141caa1e09095f5c064b257654ad9fea6", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=5f65ee2713325683af32c956f7a33e3d6d7d9d90", "patch": "@@ -6,6 +6,7 @@ use super::{\n     CachedMir,\n     ConstantId,\n     EvalContext,\n+    Lvalue,\n     ConstantKind,\n     StackPopCleanup,\n };\n@@ -104,7 +105,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n // WARNING: make sure that any methods implemented on this type don't ever access ecx.stack\n // this includes any method that might access the stack\n-// basically don't call anything other than `load_mir`, `alloc_ret_ptr`, `push_stack_frame`\n+// basically don't call anything other than `load_mir`, `alloc_ptr`, `push_stack_frame`\n // The reason for this is, that `push_stack_frame` modifies the stack out of obvious reasons\n struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     span: Span,\n@@ -127,14 +128,15 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(def_id)?;\n-            let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n+            // FIXME(solson): Don't allocate a pointer unconditionally.\n+            let ptr = this.ecx.alloc_ptr(mir.return_ty, substs)?;\n             this.ecx.statics.insert(cid.clone(), ptr);\n             let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n                 StackPopCleanup::Freeze(ptr.alloc_id)\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, ptr, cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::from_ptr(ptr), cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -176,14 +178,15 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 let mir = self.mir.promoted[index].clone();\n                 let return_ty = mir.return_ty;\n                 self.try(|this| {\n-                    let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n+                    // FIXME(solson): Don't allocate a pointer unconditionally.\n+                    let return_ptr = this.ecx.alloc_ptr(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     this.ecx.statics.insert(cid.clone(), return_ptr);\n                     this.ecx.push_stack_frame(this.def_id,\n                                               constant.span,\n                                               mir,\n                                               this.substs,\n-                                              return_ptr,\n+                                              Lvalue::from_ptr(return_ptr),\n                                               StackPopCleanup::Freeze(return_ptr.alloc_id))\n                 });\n             }"}, {"sha": "5fd96426b798cd6cf5c4b9f0175aee5fb986a6d8", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=5f65ee2713325683af32c956f7a33e3d6d7d9d90", "patch": "@@ -5,26 +5,24 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n-use memory::Pointer;\n-use interpreter::EvalContext;\n-use primval::{self, PrimVal};\n use interpreter::value::Value;\n+use interpreter::{EvalContext, Lvalue};\n+use primval::{self, PrimVal};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n         &mut self,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n-        dest: Pointer,\n+        dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n         let args_ptrs: EvalResult<Vec<Value>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args_ptrs = args_ptrs?;\n-        let pointer_size = self.memory.pointer_size();\n         let i32 = self.tcx.types.i32;\n         let isize = self.tcx.types.isize;\n         let usize = self.tcx.types.usize;\n@@ -33,15 +31,41 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let intrinsic_name = &self.tcx.item_name(def_id).as_str()[..];\n         match intrinsic_name {\n-            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n-            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n-            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n+            \"add_with_overflow\" => {\n+                self.intrinsic_with_overflow(\n+                    mir::BinOp::Add,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_layout,\n+                )?\n+            }\n+\n+            \"sub_with_overflow\" => {\n+                self.intrinsic_with_overflow(\n+                    mir::BinOp::Sub,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_layout,\n+                )?\n+            }\n+\n+            \"mul_with_overflow\" => {\n+                self.intrinsic_with_overflow(\n+                    mir::BinOp::Mul,\n+                    &args[0],\n+                    &args[1],\n+                    dest,\n+                    dest_layout,\n+                )?\n+            }\n \n             \"arith_offset\" => {\n                 let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let offset = self.value_to_primval(args_ptrs[1], isize)?.expect_int(\"arith_offset second arg not isize\");\n                 let new_ptr = ptr.offset(offset as isize);\n-                self.memory.write_ptr(dest, new_ptr)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr))?;\n             }\n \n             \"assume\" => {\n@@ -72,62 +96,72 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_ty = substs.type_at(0);\n                 let num = self.value_to_primval(args_ptrs[0], elem_ty)?;\n                 let num = numeric_intrinsic(intrinsic_name, num);\n-                self.memory.write_primval(dest, num)?;\n+                self.write_primval(dest, num)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.memory.write_uint(dest, discr_val, 8)?;\n+                self.write_primval(dest, PrimVal::U64(discr_val))?;\n             }\n \n             \"fabsf32\" => {\n                 let f = self.value_to_primval(args_ptrs[2], f32)?.expect_f32(\"fabsf32 read non f32\");\n-                self.memory.write_f32(dest, f.abs())?;\n+                self.write_primval(dest, PrimVal::F32(f.abs()))?;\n             }\n \n             \"fabsf64\" => {\n                 let f = self.value_to_primval(args_ptrs[2], f64)?.expect_f64(\"fabsf64 read non f64\");\n-                self.memory.write_f64(dest, f.abs())?;\n+                self.write_primval(dest, PrimVal::F64(f.abs()))?;\n             }\n \n             \"fadd_fast\" => {\n                 let ty = substs.type_at(0);\n                 let a = self.value_to_primval(args_ptrs[0], ty)?;\n                 let b = self.value_to_primval(args_ptrs[0], ty)?;\n                 let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n-                self.memory.write_primval(dest, result.0)?;\n+                self.write_primval(dest, result.0)?;\n             }\n \n             \"likely\" |\n             \"unlikely\" |\n             \"forget\" => {}\n \n-            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n+            \"init\" => {\n+                // FIXME(solson)\n+                let dest = dest.to_ptr();\n+\n+                let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n+                self.memory.write_repeat(dest, 0, size)?;\n+            }\n \n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.type_align(elem_ty);\n-                self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n+                let align_val = self.usize_primval(elem_align as u64);\n+                self.write_primval(dest, align_val)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.type_layout(ty);\n                 let align = layout.align(&self.tcx.data_layout).pref();\n-                self.memory.write_uint(dest, align, pointer_size)?;\n+                let align_val = self.usize_primval(align);\n+                self.write_primval(dest, align_val)?;\n             }\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n-                self.write_value(args_ptrs[1], ptr, ty)?;\n+                self.write_value_to_ptr(args_ptrs[1], ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n                 let ty = substs.type_at(0);\n-                self.memory.write_bool(dest, self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment()))?;\n+                let env = self.tcx.empty_parameter_environment();\n+                let needs_drop = self.tcx.type_needs_drop_given_env(ty, &env);\n+                self.write_primval(dest, PrimVal::Bool(needs_drop))?;\n             }\n \n             \"offset\" => {\n@@ -137,7 +171,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                self.memory.write_ptr(dest, result_ptr)?;\n+                self.write_primval(dest, PrimVal::Ptr(result_ptr))?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -155,35 +189,37 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"powif32\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f32)?.expect_f32(\"powif32 first arg not f32\");\n                 let i = self.value_to_primval(args_ptrs[1], i32)?.expect_int(\"powif32 second arg not i32\");\n-                self.memory.write_f32(dest, f.powi(i as i32))?;\n+                self.write_primval(dest, PrimVal::F32(f.powi(i as i32)))?;\n             }\n \n             \"powif64\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f64)?.expect_f64(\"powif64 first arg not f64\");\n                 let i = self.value_to_primval(args_ptrs[1], i32)?.expect_int(\"powif64 second arg not i32\");\n-                self.memory.write_f64(dest, f.powi(i as i32))?;\n+                self.write_primval(dest, PrimVal::F64(f.powi(i as i32)))?;\n             }\n \n             \"sqrtf32\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f32)?.expect_f32(\"sqrtf32 first arg not f32\");\n-                self.memory.write_f32(dest, f.sqrt())?;\n+                self.write_primval(dest, PrimVal::F32(f.sqrt()))?;\n             }\n \n             \"sqrtf64\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f64)?.expect_f64(\"sqrtf64 first arg not f64\");\n-                self.memory.write_f64(dest, f.sqrt())?;\n+                self.write_primval(dest, PrimVal::F64(f.sqrt()))?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = self.type_size(ty) as u64;\n-                self.memory.write_uint(dest, size, pointer_size)?;\n+                let size_val = self.usize_primval(size);\n+                self.write_primval(dest, size_val)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, args_ptrs[0])?;\n-                self.memory.write_uint(dest, size, pointer_size)?;\n+                let size_val = self.usize_primval(size);\n+                self.write_primval(dest, size_val)?;\n             }\n             \"type_name\" => {\n                 let ty = substs.type_at(0);\n@@ -194,28 +230,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.memory.write_uint(dest, n, 8)?;\n+                self.write_primval(dest, PrimVal::U64(n))?;\n             }\n \n             \"transmute\" => {\n                 let ty = substs.type_at(0);\n                 self.write_value(args_ptrs[0], dest, ty)?;\n             }\n \n-            \"try\" => unimplemented!(),\n+            \"uninit\" => {\n+                // FIXME(solson)\n+                let dest = dest.to_ptr();\n \n-            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n+                let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n+                self.memory.mark_definedness(dest, size, false)?;\n+            }\n \n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n-                self.move_(ptr, dest, ty)?;\n+                self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n \n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n                 let dest = args_ptrs[0].read_ptr(&self.memory)?;\n-                self.write_value(args_ptrs[1], dest, ty)?;\n+                self.write_value_to_ptr(args_ptrs[1], dest, ty)?;\n             }\n \n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "b4559670405530467c2d92a2a1ca92f2790699f6", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=5f65ee2713325683af32c956f7a33e3d6d7d9d90", "patch": "@@ -12,7 +12,7 @@ use syntax::{ast, attr};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use primval::PrimVal;\n-use super::{EvalContext, IntegerExt, StackPopCleanup};\n+use super::{EvalContext, Lvalue, IntegerExt, StackPopCleanup};\n use super::value::Value;\n \n mod intrinsics;\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Call { ref func, ref args, ref destination, .. } => {\n                 let destination = match *destination {\n-                    Some((ref lv, target)) => Some((self.eval_lvalue(lv)?.to_ptr(), target)),\n+                    Some((ref lv, target)) => Some((self.eval_lvalue(lv)?, target)),\n                     None => None,\n                 };\n \n@@ -143,7 +143,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         fn_ty: &'tcx BareFnTy,\n-        destination: Option<(Pointer, mir::BasicBlock)>,\n+        destination: Option<(Lvalue, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx, ()> {\n@@ -184,15 +184,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     };\n \n                 let mir = self.load_mir(resolved_def_id)?;\n-                let (return_ptr, return_to_block) = match destination {\n-                    Some((ptr, block)) => (ptr, StackPopCleanup::Goto(block)),\n-                    None => (Pointer::never_ptr(), StackPopCleanup::None),\n+                let (return_lvalue, return_to_block) = match destination {\n+                    Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+                    None => {\n+                        // FIXME(solson)\n+                        let lvalue = Lvalue::from_ptr(Pointer::never_ptr());\n+                        (lvalue, StackPopCleanup::None)\n+                    }\n                 };\n-                self.push_stack_frame(resolved_def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n+\n+                self.push_stack_frame(\n+                    resolved_def_id,\n+                    span,\n+                    mir,\n+                    resolved_substs,\n+                    return_lvalue,\n+                    return_to_block\n+                )?;\n \n                 for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n                     // argument start at index 1, since index 0 is reserved for the return allocation\n                     let dest = self.frame().locals[i + 1];\n+\n+                    // FIXME(solson)\n+                    let dest = match dest {\n+                        Value::ByRef(p) => Lvalue::from_ptr(p),\n+                        _ => bug!(\"all locals should be ByRef until I finish refactoring\"),\n+                    };\n+\n                     self.write_value(arg_val, dest, arg_ty)?;\n                 }\n \n@@ -245,7 +264,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         def_id: DefId,\n         args: &[mir::Operand<'tcx>],\n-        dest: Pointer,\n+        dest: Lvalue,\n         dest_size: usize,\n     ) -> EvalResult<'tcx, ()> {\n         let name = self.tcx.item_name(def_id);\n@@ -269,18 +288,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match &link_name[..] {\n             \"__rust_allocate\" => {\n-                let size = self.value_to_primval(args[0], usize)?.expect_uint(\"__rust_allocate first arg not usize\");\n-                let align = self.value_to_primval(args[1], usize)?.expect_uint(\"__rust_allocate second arg not usize\");\n+                let size = self.value_to_primval(args[0], usize)?\n+                    .expect_uint(\"__rust_allocate first arg not usize\");\n+                let align = self.value_to_primval(args[1], usize)?\n+                    .expect_uint(\"__rust_allocate second arg not usize\");\n                 let ptr = self.memory.allocate(size as usize, align as usize)?;\n-                self.memory.write_ptr(dest, ptr)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr))?;\n             }\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n                 let size = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate third arg not usize\");\n                 let align = self.value_to_primval(args[3], usize)?.expect_uint(\"__rust_reallocate fourth arg not usize\");\n                 let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n-                self.memory.write_ptr(dest, new_ptr)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr))?;\n             }\n \n             \"memcmp\" => {\n@@ -300,7 +321,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n \n-                self.memory.write_int(dest, result, dest_size)?;\n+                self.write_primval(dest, PrimVal::int_with_size(result, dest_size))?;\n             }\n \n             _ => {"}, {"sha": "178dbac840198293928156694b9f4b2e89d4fe91", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=5f65ee2713325683af32c956f7a33e3d6d7d9d90", "patch": "@@ -1,5 +1,5 @@\n-use memory::{Memory, Pointer};\n use error::EvalResult;\n+use memory::{Memory, Pointer};\n use primval::PrimVal;\n \n /// A `Value` represents a single self-contained Rust value.\n@@ -11,15 +11,14 @@ use primval::PrimVal;\n /// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n-pub(super) enum Value {\n+pub enum Value {\n     ByRef(Pointer),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n \n-impl Value {\n-\n-    pub(super) fn read_ptr<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+impl<'a, 'tcx: 'a> Value {\n+    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n@@ -30,7 +29,7 @@ impl Value {\n         }\n     }\n \n-    pub(super) fn expect_vtable<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn expect_vtable(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr.offset(mem.pointer_size() as isize)),\n@@ -39,7 +38,7 @@ impl Value {\n         }\n     }\n \n-    pub(super) fn expect_slice_len<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, u64> {\n+    pub(super) fn expect_slice_len(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, u64> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),"}, {"sha": "26c1d715c4ce4a617f9c761bc7c9844103e8d6a5", "filename": "src/primval.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f65ee2713325683af32c956f7a33e3d6d7d9d90/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=5f65ee2713325683af32c956f7a33e3d6d7d9d90", "patch": "@@ -60,6 +60,28 @@ impl PrimVal {\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n+\n+    pub fn uint_with_size(n: u64, size: usize) -> Self {\n+        use self::PrimVal::*;\n+        match size {\n+            1 => U8(n as u8),\n+            2 => U16(n as u16),\n+            4 => U32(n as u32),\n+            8 => U64(n),\n+            _ => bug!(\"can't make uint ({}) with size {}\", n, size),\n+        }\n+    }\n+\n+    pub fn int_with_size(n: i64, size: usize) -> Self {\n+        use self::PrimVal::*;\n+        match size {\n+            1 => I8(n as i8),\n+            2 => I16(n as i16),\n+            4 => I32(n as i32),\n+            8 => I64(n),\n+            _ => bug!(\"can't make int ({}) with size {}\", n, size),\n+        }\n+    }\n }\n \n /// returns the result of the operation and whether the operation overflowed"}, {"sha": "8b884e22fedf7a72fe0b5dd23591eeb2fb670351", "filename": "tests/run-pass/start_fn.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb23b8d0a79b598d4a56d992fbb4c62a74d58b68/tests%2Frun-pass%2Fstart_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb23b8d0a79b598d4a56d992fbb4c62a74d58b68/tests%2Frun-pass%2Fstart_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstart_fn.rs?ref=cb23b8d0a79b598d4a56d992fbb4c62a74d58b68", "patch": "@@ -1,9 +0,0 @@\n-#![feature(start)]\n-\n-#[start]\n-fn foo(nargs: isize, args: *const *const u8) -> isize {\n-    if nargs > 0 {\n-        assert!(unsafe{*args} as usize != 0);\n-    }\n-    0\n-}"}]}