{"sha": "2c308b9a2a9b9d531cafa3f11cb1000ee5362e63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMzA4YjlhMmE5YjlkNTMxY2FmYTNmMTFjYjEwMDBlZTUzNjJlNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-24T21:49:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-24T21:49:15Z"}, "message": "Auto merge of #79347 - ssomers:btree_split_pointer_provenance, r=Mark-Simulacrum\n\nBTreeMap: respect pointer provenance rules in split_off\n\nThe test cases for `split_off` reported a few more violations (now that they support -Zmiri-track-raw-pointers). The functions `shift_kv` and `shift_edges` do not fix anything, I think, but if `move_kv` and `move_edges` exist, they deserve to live too.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "bed29139e1520b4077e58c34dd8c267cc229f0e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bed29139e1520b4077e58c34dd8c267cc229f0e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c308b9a2a9b9d531cafa3f11cb1000ee5362e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c308b9a2a9b9d531cafa3f11cb1000ee5362e63", "html_url": "https://github.com/rust-lang/rust/commit/2c308b9a2a9b9d531cafa3f11cb1000ee5362e63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c308b9a2a9b9d531cafa3f11cb1000ee5362e63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0edce6f4bbb4514482537f569f0b8ef48e71e0a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0edce6f4bbb4514482537f569f0b8ef48e71e0a0", "html_url": "https://github.com/rust-lang/rust/commit/0edce6f4bbb4514482537f569f0b8ef48e71e0a0"}, {"sha": "8824efd61c050d8ee138593b6128950ec25c752d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8824efd61c050d8ee138593b6128950ec25c752d", "html_url": "https://github.com/rust-lang/rust/commit/8824efd61c050d8ee138593b6128950ec25c752d"}], "stats": {"total": 178, "additions": 81, "deletions": 97}, "files": [{"sha": "769383515b7f12ebc8a3c882bdda153985c443ae", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 81, "deletions": 97, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/2c308b9a2a9b9d531cafa3f11cb1000ee5362e63/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c308b9a2a9b9d531cafa3f11cb1000ee5362e63/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=2c308b9a2a9b9d531cafa3f11cb1000ee5362e63", "patch": "@@ -35,6 +35,7 @@ use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull};\n+use core::slice::SliceIndex;\n \n use crate::alloc::{Allocator, Global, Layout};\n use crate::boxed::Box;\n@@ -507,30 +508,45 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Borrows exclusive access to an element of the key storage area.\n     ///\n     /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn key_area_mut_at(&mut self, idx: usize) -> &mut MaybeUninit<K> {\n-        debug_assert!(idx < self.len());\n-        unsafe { self.as_leaf_mut().keys.get_unchecked_mut(idx) }\n+    /// `index` is in bounds of 0..CAPACITY\n+    unsafe fn key_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    where\n+        I: SliceIndex<[MaybeUninit<K>], Output = Output>,\n+    {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.as_leaf_mut().keys.as_mut_slice().get_unchecked_mut(index) }\n     }\n \n-    /// Borrows exclusive access to an element of the value storage area.\n+    /// Borrows exclusive access to an element or slice of the node's value storage area.\n     ///\n     /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn val_area_mut_at(&mut self, idx: usize) -> &mut MaybeUninit<V> {\n-        debug_assert!(idx < self.len());\n-        unsafe { self.as_leaf_mut().vals.get_unchecked_mut(idx) }\n+    /// `index` is in bounds of 0..CAPACITY\n+    unsafe fn val_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    where\n+        I: SliceIndex<[MaybeUninit<V>], Output = Output>,\n+    {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.as_leaf_mut().vals.as_mut_slice().get_unchecked_mut(index) }\n     }\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Borrows exclusive access to an element of the storage area for edge contents.\n+    /// Borrows exclusive access to an element or slice of the node's storage area for edge contents.\n     ///\n     /// # Safety\n-    /// The node has at least `idx` initialized elements.\n-    unsafe fn edge_area_mut_at(&mut self, idx: usize) -> &mut MaybeUninit<BoxedNode<K, V>> {\n-        debug_assert!(idx <= self.len());\n-        unsafe { self.as_internal_mut().edges.get_unchecked_mut(idx) }\n+    /// `index` is in bounds of 0..CAPACITY + 1\n+    unsafe fn edge_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    where\n+        I: SliceIndex<[MaybeUninit<BoxedNode<K, V>>], Output = Output>,\n+    {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the edge slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.as_internal_mut().edges.as_mut_slice().get_unchecked_mut(index) }\n     }\n }\n \n@@ -559,37 +575,6 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Borrows exclusive access to a sized slice of key storage area in the node.\n-    unsafe fn key_area_slice(&mut self) -> &mut [MaybeUninit<K>] {\n-        let len = self.len();\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the key slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        unsafe { self.as_leaf_mut().keys.get_unchecked_mut(..len) }\n-    }\n-\n-    /// Borrows exclusive access to a sized slice of value storage area in the node.\n-    unsafe fn val_area_slice(&mut self) -> &mut [MaybeUninit<V>] {\n-        let len = self.len();\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the value slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        unsafe { self.as_leaf_mut().vals.get_unchecked_mut(..len) }\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Borrows exclusive access to a sized slice of storage area for edge contents in the node.\n-    unsafe fn edge_area_slice(&mut self) -> &mut [MaybeUninit<BoxedNode<K, V>>] {\n-        let len = self.len();\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the edge slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        unsafe { self.as_internal_mut().edges.get_unchecked_mut(..len + 1) }\n-    }\n-}\n-\n impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n     /// # Safety\n     /// - The node has more than `idx` initialized elements.\n@@ -650,12 +635,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n     /// Adds a key-value pair to the beginning of the node.\n     fn push_front(&mut self, key: K, val: V) {\n-        assert!(self.len() < CAPACITY);\n-\n+        let new_len = self.len() + 1;\n+        assert!(new_len <= CAPACITY);\n         unsafe {\n-            *self.len_mut() += 1;\n-            slice_insert(self.key_area_slice(), 0, key);\n-            slice_insert(self.val_area_slice(), 0, val);\n+            slice_insert(self.key_area_mut_at(..new_len), 0, key);\n+            slice_insert(self.val_area_mut_at(..new_len), 0, val);\n+            *self.len_mut() = new_len as u16;\n         }\n     }\n }\n@@ -697,14 +682,15 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Adds a key-value pair, and an edge to go to the left of that pair,\n     /// to the beginning of the node.\n     fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n+        let new_len = self.len() + 1;\n         assert!(edge.height == self.height - 1);\n-        assert!(self.len() < CAPACITY);\n+        assert!(new_len <= CAPACITY);\n \n         unsafe {\n-            *self.len_mut() += 1;\n-            slice_insert(self.key_area_slice(), 0, key);\n-            slice_insert(self.val_area_slice(), 0, val);\n-            slice_insert(self.edge_area_slice(), 0, edge.node);\n+            slice_insert(self.key_area_mut_at(..new_len), 0, key);\n+            slice_insert(self.val_area_mut_at(..new_len), 0, val);\n+            slice_insert(self.edge_area_mut_at(..new_len + 1), 0, edge.node);\n+            *self.len_mut() = new_len as u16;\n         }\n \n         self.correct_all_childrens_parent_links();\n@@ -749,12 +735,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let old_len = self.len();\n \n         unsafe {\n-            let key = slice_remove(self.key_area_slice(), 0);\n-            let val = slice_remove(self.val_area_slice(), 0);\n+            let key = slice_remove(self.key_area_mut_at(..old_len), 0);\n+            let val = slice_remove(self.val_area_mut_at(..old_len), 0);\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let node = slice_remove(internal.edge_area_slice(), 0);\n+                    let node = slice_remove(internal.edge_area_mut_at(..old_len + 1), 0);\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -975,11 +961,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// The returned pointer points to the inserted value.\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         debug_assert!(self.node.len() < CAPACITY);\n+        let new_len = self.node.len() + 1;\n \n         unsafe {\n-            *self.node.len_mut() += 1;\n-            slice_insert(self.node.key_area_slice(), self.idx, key);\n-            slice_insert(self.node.val_area_slice(), self.idx, val);\n+            slice_insert(self.node.key_area_mut_at(..new_len), self.idx, key);\n+            slice_insert(self.node.val_area_mut_at(..new_len), self.idx, val);\n+            *self.node.len_mut() = new_len as u16;\n \n             self.node.val_area_mut_at(self.idx).assume_init_mut()\n         }\n@@ -1033,14 +1020,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n+        let new_len = self.node.len() + 1;\n \n         unsafe {\n-            *self.node.len_mut() += 1;\n-            slice_insert(self.node.key_area_slice(), self.idx, key);\n-            slice_insert(self.node.val_area_slice(), self.idx, val);\n-            slice_insert(self.node.edge_area_slice(), self.idx + 1, edge.node);\n+            slice_insert(self.node.key_area_mut_at(..new_len), self.idx, key);\n+            slice_insert(self.node.val_area_mut_at(..new_len), self.idx, val);\n+            slice_insert(self.node.edge_area_mut_at(..new_len + 1), self.idx + 1, edge.node);\n+            *self.node.len_mut() = new_len as u16;\n \n-            self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n+            self.node.correct_childrens_parent_links(self.idx + 1..new_len + 1);\n         }\n     }\n \n@@ -1177,17 +1165,11 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n-    /// Helps implementations of `split` for a particular `NodeType`,\n-    /// by calculating the length of the new node.\n-    fn split_new_node_len(&self) -> usize {\n-        debug_assert!(self.idx < self.node.len());\n-        self.node.len() - self.idx - 1\n-    }\n-\n     /// Helps implementations of `split` for a particular `NodeType`,\n     /// by taking care of leaf data.\n     fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {\n-        let new_len = self.split_new_node_len();\n+        debug_assert!(self.idx < self.node.len());\n+        let new_len = self.node.len() - self.idx - 1;\n         new_node.len = new_len as u16;\n         unsafe {\n             let k = ptr::read(self.node.reborrow().key_at(self.idx));\n@@ -1234,10 +1216,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     pub fn remove(\n         mut self,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let old_len = self.node.len();\n         unsafe {\n-            let k = slice_remove(self.node.key_area_slice(), self.idx);\n-            let v = slice_remove(self.node.val_area_slice(), self.idx);\n-            *self.node.len_mut() -= 1;\n+            let k = slice_remove(self.node.key_area_mut_at(..old_len), self.idx);\n+            let v = slice_remove(self.node.val_area_mut_at(..old_len), self.idx);\n+            *self.node.len_mut() = (old_len - 1) as u16;\n             ((k, v), self.left_edge())\n         }\n     }\n@@ -1254,14 +1237,13 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n-            let new_len = self.split_new_node_len();\n-            // Move edges out before reducing length:\n+            let kv = self.split_leaf_data(&mut new_node.data);\n+            let new_len = usize::from(new_node.data.len);\n             ptr::copy_nonoverlapping(\n                 self.node.reborrow().edge_area().as_ptr().add(self.idx + 1),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n-            let kv = self.split_leaf_data(&mut new_node.data);\n \n             let height = self.node.height;\n             let mut right = NodeRef::from_new_internal(new_node, height);\n@@ -1384,23 +1366,25 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         unsafe {\n             *left_node.len_mut() = new_left_len as u16;\n \n-            let parent_key = slice_remove(parent_node.key_area_slice(), parent_idx);\n+            let parent_key =\n+                slice_remove(parent_node.key_area_mut_at(..old_parent_len), parent_idx);\n             left_node.key_area_mut_at(old_left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n                 right_node.reborrow().key_area().as_ptr(),\n-                left_node.key_area_slice().as_mut_ptr().add(old_left_len + 1),\n+                left_node.key_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n \n-            let parent_val = slice_remove(parent_node.val_area_slice(), parent_idx);\n+            let parent_val =\n+                slice_remove(parent_node.val_area_mut_at(..old_parent_len), parent_idx);\n             left_node.val_area_mut_at(old_left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n                 right_node.reborrow().val_area().as_ptr(),\n-                left_node.val_area_slice().as_mut_ptr().add(old_left_len + 1),\n+                left_node.val_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n \n-            slice_remove(&mut parent_node.edge_area_slice(), parent_idx + 1);\n+            slice_remove(&mut parent_node.edge_area_mut_at(..old_parent_len + 1), parent_idx + 1);\n             parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);\n             *parent_node.len_mut() -= 1;\n \n@@ -1411,7 +1395,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 let right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n                     right_node.reborrow().edge_area().as_ptr(),\n-                    left_node.edge_area_slice().as_mut_ptr().add(old_left_len + 1),\n+                    left_node.edge_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n                     right_len + 1,\n                 );\n \n@@ -1489,6 +1473,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             assert!(old_left_len >= count);\n \n             let new_left_len = old_left_len - count;\n+            let new_right_len = old_right_len + count;\n+            *left_node.len_mut() = new_left_len as u16;\n+            *right_node.len_mut() = new_right_len as u16;\n \n             // Move leaf data.\n             {\n@@ -1513,16 +1500,13 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            *left_node.len_mut() -= count as u16;\n-            *right_node.len_mut() += count as u16;\n-\n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n                     let left = left.reborrow();\n-                    let right_edges = right.edge_area_slice().as_mut_ptr();\n+                    let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n-                    right.correct_childrens_parent_links(count..count + old_right_len + 1);\n+                    right.correct_childrens_parent_links(count..new_right_len + 1);\n \n                     // Steal edges.\n                     move_edges(left, new_left_len + 1, right, 0, count);\n@@ -1546,7 +1530,10 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             assert!(old_left_len + count <= CAPACITY);\n             assert!(old_right_len >= count);\n \n+            let new_left_len = old_left_len + count;\n             let new_right_len = old_right_len - count;\n+            *left_node.len_mut() = new_left_len as u16;\n+            *right_node.len_mut() = new_right_len as u16;\n \n             // Move leaf data.\n             {\n@@ -1571,16 +1558,13 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n \n-            *left_node.len_mut() += count as u16;\n-            *right_node.len_mut() -= count as u16;\n-\n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Steal edges.\n                     move_edges(right.reborrow(), 0, left, old_left_len + 1, count);\n \n                     // Fill gap where stolen edges used to be.\n-                    let right_edges = right.edge_area_slice().as_mut_ptr();\n+                    let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n@@ -1614,8 +1598,8 @@ unsafe fn move_edges<'a, K: 'a, V: 'a>(\n ) {\n     unsafe {\n         let source_ptr = source.edge_area().as_ptr();\n-        let dest_ptr = dest.edge_area_slice().as_mut_ptr();\n-        ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n+        let dest_ptr = dest.edge_area_mut_at(dest_offset..).as_mut_ptr();\n+        ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr, count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }\n }"}]}