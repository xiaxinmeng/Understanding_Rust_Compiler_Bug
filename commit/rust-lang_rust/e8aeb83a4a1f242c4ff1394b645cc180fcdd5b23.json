{"sha": "e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YWViODNhNGExZjI0MmM0ZmYxMzk0YjY0NWNjMTgwZmNkZDViMjM=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-03T08:14:31Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-03T19:37:04Z"}, "message": "hir: add HirId methods", "tree": {"sha": "0677e02f97939be1f5237218163cf532cd1ea03b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0677e02f97939be1f5237218163cf532cd1ea03b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "html_url": "https://github.com/rust-lang/rust/commit/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28fec683f552cb2bc20644f06895232c574751ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/28fec683f552cb2bc20644f06895232c574751ab", "html_url": "https://github.com/rust-lang/rust/commit/28fec683f552cb2bc20644f06895232c574751ab"}], "stats": {"total": 139, "additions": 138, "deletions": 1}, "files": [{"sha": "9c4fa9e1272878fbe63170974b9cd6e92656f851", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n+use hir;\n use hir::def_id::{LOCAL_CRATE, CrateNum};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc_data_structures::svh::Svh;\n@@ -28,6 +29,8 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: NodeId,\n \n+    parent_hir: hir::HirId,\n+\n     // These fields keep track of the currently relevant DepNodes during\n     // the visitor's traversal.\n     current_dep_node_owner: DefIndex,\n@@ -145,6 +148,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             source_map: sess.source_map(),\n             map: repeat(None).take(sess.current_node_id_count()).collect(),\n             parent_node: CRATE_NODE_ID,\n+            parent_hir: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n@@ -156,6 +160,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         };\n         collector.insert_entry(CRATE_NODE_ID, Entry {\n             parent: CRATE_NODE_ID,\n+            parent_hir: hir::CRATE_HIR_ID,\n             dep_node: root_mod_sig_dep_index,\n             node: Node::Crate,\n         });\n@@ -226,6 +231,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     fn insert(&mut self, span: Span, id: NodeId, node: Node<'hir>) {\n         let entry = Entry {\n             parent: self.parent_node,\n+            parent_hir: self.parent_hir,\n             dep_node: if self.currently_in_body {\n                 self.current_full_dep_index\n             } else {"}, {"sha": "687daca3d3ff2f21083f5b206d510561a3006c15", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "patch": "@@ -20,7 +20,7 @@ use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n-use util::nodemap::NodeMap;\n+use util::nodemap::{HirIdMap, NodeMap};\n \n /// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n@@ -147,6 +147,7 @@ impl Decodable for DefPathTable {\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n+    hir_to_def_index: HirIdMap<DefIndex>,\n     def_index_to_node: [Vec<ast::NodeId>; 2],\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n     /// If `Mark` is an ID of some macro expansion,\n@@ -441,16 +442,34 @@ impl Definitions {\n         self.node_to_def_index.get(&node).cloned()\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn opt_def_index_from_hir_id(&self, hir: hir::HirId) -> Option<DefIndex> {\n+        self.hir_to_def_index.get(&hir).cloned()\n+    }\n+\n     #[inline]\n     pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n         self.opt_def_index(node).map(DefId::local)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn opt_local_def_id_from_hir_id(&self, hir: hir::HirId) -> Option<DefId> {\n+        self.opt_def_index_from_hir_id(hir).map(DefId::local)\n+    }\n+\n     #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap()\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn local_def_id_from_hir_id(&self, hir: hir::HirId) -> DefId {\n+        self.opt_local_def_id_from_hir_id(hir).unwrap()\n+    }\n+\n     #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n@@ -467,6 +486,21 @@ impl Definitions {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n+        if def_id.krate == LOCAL_CRATE {\n+            let hir_id = self.def_index_to_hir_id(def_id.index);\n+            if hir_id != hir::DUMMY_HIR_ID {\n+                Some(hir_id)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n         self.node_to_hir_id[node_id]\n@@ -515,6 +549,7 @@ impl Definitions {\n         assert!(self.def_index_to_node[address_space.index()].is_empty());\n         self.def_index_to_node[address_space.index()].push(ast::CRATE_NODE_ID);\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n+        self.hir_to_def_index.insert(hir::CRATE_HIR_ID, root_index);\n \n         // Allocate some other DefIndices that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n@@ -575,6 +610,9 @@ impl Definitions {\n         if node_id != ast::DUMMY_NODE_ID {\n             debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n             self.node_to_def_index.insert(node_id, index);\n+            if let Some(hir_id) = self.node_to_hir_id.get(node_id) {\n+                self.hir_to_def_index.insert(*hir_id, index);\n+            }\n         }\n \n         if expansion != Mark::root() {"}, {"sha": "c8e19c3b492606c0e40f539b04caa1f9151f503c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "patch": "@@ -40,6 +40,7 @@ pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: NodeId,\n+    parent_hir: HirId,\n     dep_node: DepNodeIndex,\n     node: Node<'hir>,\n }\n@@ -208,6 +209,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn read_by_hir_id(&self, hir_id: HirId) {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.read(node_id);\n+    }\n+\n     #[inline]\n     pub fn definitions(&self) -> &'hir Definitions {\n         self.definitions\n@@ -224,6 +231,11 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn def_path_from_hir_id(&self, id: HirId) -> DefPath {\n+        self.def_path(self.local_def_id_from_hir_id(id))\n+    }\n+\n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n         assert!(def_id.is_local());\n         self.definitions.def_path(def_id.index)\n@@ -237,6 +249,22 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n+        self.opt_local_def_id_from_hir_id(hir_id).unwrap_or_else(|| {\n+            let node_id = self.hir_to_node_id(hir_id);\n+            bug!(\"local_def_id_from_hir_id: no entry for `{:?}`, which has a map of `{:?}`\",\n+                 hir_id, self.find_entry(node_id))\n+        })\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn opt_local_def_id_from_hir_id(&self, hir_id: HirId) -> Option<DefId> {\n+        self.definitions.opt_local_def_id_from_hir_id(hir_id)\n+    }\n+\n     #[inline]\n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n         self.definitions.opt_local_def_id(node)\n@@ -247,6 +275,12 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    #[inline]\n+    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+        self.definitions.as_local_hir_id(def_id)\n+    }\n+\n     #[inline]\n     pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n         self.hir_to_node_id[&hir_id]\n@@ -566,6 +600,12 @@ impl<'hir> Map<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find node id {} in the AST map\", id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get(node_id)\n+    }\n+\n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n         self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n@@ -613,6 +653,12 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.find(node_id)\n+    }\n+\n     /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n     /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n     /// present in the map -- so passing the return value of get_parent_node to\n@@ -633,6 +679,13 @@ impl<'hir> Map<'hir> {\n         self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_node_by_hir_id(&self, id: HirId) -> HirId {\n+        let node_id = self.hir_to_node_id(id);\n+        let parent_node_id = self.get_parent_node(node_id);\n+        self.node_to_hir_id(parent_node_id)\n+    }\n+\n     /// Check if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: NodeId) -> bool {\n@@ -757,6 +810,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_item(&self, id: HirId) -> HirId {\n+        let node_id = self.hir_to_node_id(id);\n+        let parent_node_id = self.get_parent(node_id);\n+        self.node_to_hir_id(parent_node_id)\n+    }\n+\n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n@@ -814,6 +874,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_item(node_id)\n+    }\n+\n     pub fn expect_impl_item(&self, id: NodeId) -> &'hir ImplItem {\n         match self.find(id) {\n             Some(Node::ImplItem(item)) => item,\n@@ -960,13 +1026,28 @@ impl<'hir> Map<'hir> {\n         node_id_to_string(self, id, true)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_to_string(&self, id: HirId) -> String {\n+        hir_id_to_string(self, id, true)\n+    }\n+\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_to_user_string(&self, id: HirId) -> String {\n+        hir_id_to_string(self, id, false)\n+    }\n+\n     pub fn node_to_pretty_string(&self, id: NodeId) -> String {\n         print::to_string(self, |s| s.print_node(self.get(id)))\n     }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n+        print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n+    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n@@ -1310,6 +1391,12 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n     }\n }\n \n+// FIXME(@ljedrz): replace the NodeId variant\n+fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n+    let node_id = map.hir_to_node_id(id);\n+    node_id_to_string(map, node_id, include_id)\n+}\n+\n pub fn describe_def(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<Def> {\n     if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n         tcx.hir().describe_def(node_id)"}, {"sha": "adb7e1fb3e32279c27c8568f9c63317057d50024", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e8aeb83a4a1f242c4ff1394b645cc180fcdd5b23", "patch": "@@ -1,3 +1,4 @@\n+use hir;\n use hir::map::DefPathData;\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, DefIdTree, Ty, TyCtxt};\n@@ -76,6 +77,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.item_path_str(self.hir().local_def_id(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn hir_path_str(self, id: hir::HirId) -> String {\n+        self.item_path_str(self.hir().local_def_id_from_hir_id(id))\n+    }\n+\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {"}]}