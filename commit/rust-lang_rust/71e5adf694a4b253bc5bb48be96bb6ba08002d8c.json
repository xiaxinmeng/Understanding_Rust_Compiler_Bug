{"sha": "71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZTVhZGY2OTRhNGIyNTNiYzViYjQ4YmU5NmJiNmJhMDgwMDJkOGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-14T08:53:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:49:07Z"}, "message": "move tests over to crate-def-map", "tree": {"sha": "27208afed0ec41b07f8fffa05659259f13fc027c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27208afed0ec41b07f8fffa05659259f13fc027c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "html_url": "https://github.com/rust-lang/rust/commit/71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2195d1db6d70d64383bec82819fab02891d09744", "url": "https://api.github.com/repos/rust-lang/rust/commits/2195d1db6d70d64383bec82819fab02891d09744", "html_url": "https://github.com/rust-lang/rust/commit/2195d1db6d70d64383bec82819fab02891d09744"}], "stats": {"total": 1539, "additions": 689, "deletions": 850}, "files": [{"sha": "e8f3005f12465e1ff3258516e97d7e9f4c517c58", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -1,6 +1,6 @@\n test_utils::marks!(\n     name_res_works_for_broken_modules\n-    item_map_enum_importing\n+    can_import_enum_variant\n     type_var_cycles_resolve_completely\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var"}, {"sha": "59297425eb320a09aeaacb6cb7c9fd837e0a4d05", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -661,7 +661,7 @@ impl ItemMap {\n                 }\n                 ModuleDef::Enum(e) => {\n                     // enum variant\n-                    tested_by!(item_map_enum_importing);\n+                    tested_by!(can_import_enum_variant);\n                     match e.variant(db, &segment.name) {\n                         Some(variant) => PerNs::both(variant.into(), variant.into()),\n                         None => {\n@@ -693,6 +693,3 @@ impl ItemMap {\n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "37b36719f02f3c1cc696234f6a209217cee0822c", "filename": "crates/ra_hir/src/nameres/crate_def_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -273,7 +273,7 @@ impl CrateDefMap {\n                 }\n                 ModuleDef::Enum(e) => {\n                     // enum variant\n-                    tested_by!(item_map_enum_importing);\n+                    tested_by!(can_import_enum_variant);\n                     match e.variant(db, &segment.name) {\n                         Some(variant) => PerNs::both(variant.into(), variant.into()),\n                         None => {"}, {"sha": "68f74b8661c6bb0cc8e3906aff754821f3703b97", "filename": "crates/ra_hir/src/nameres/crate_def_map/collector.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -85,6 +85,12 @@ where\n                 break;\n             }\n         }\n+\n+        let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        // show unresolved imports in completion, etc\n+        for (module_id, import, import_data) in unresolved_imports {\n+            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n+        }\n     }\n \n     fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n@@ -415,7 +421,14 @@ where\n         modules[res].parent = Some(self.module_id);\n         modules[res].declaration = Some(declaration);\n         modules[res].definition = definition;\n-        modules[self.module_id].children.insert(name, res);\n+        modules[self.module_id].children.insert(name.clone(), res);\n+        let resolution = Resolution {\n+            def: PerNs::types(\n+                Module { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n+            ),\n+            import: None,\n+        };\n+        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n "}, {"sha": "36c1d74ceaf25948001bfc2b4e50ce682673cf23", "filename": "crates/ra_hir/src/nameres/crate_def_map/tests.rs", "status": "modified", "additions": 337, "deletions": 74, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -1,3 +1,7 @@\n+mod macros;\n+mod globs;\n+mod incremental;\n+\n use std::sync::Arc;\n \n use ra_db::SourceDatabase;\n@@ -62,6 +66,8 @@ fn crate_def_map_smoke_test() {\n         //- /lib.rs\n         mod foo;\n         struct S;\n+        use crate::foo::bar::E;\n+        use self::E::V;\n \n         //- /foo/mod.rs\n         pub mod bar;\n@@ -74,9 +80,13 @@ fn crate_def_map_smoke_test() {\n     );\n     assert_snapshot_matches!(map, @r###\"\n crate\n+V: t v\n+E: t\n+foo: t\n S: t v\n \n crate::foo\n+bar: t\n f: v\n \n crate::foo::bar\n@@ -87,91 +97,96 @@ E: t\n }\n \n #[test]\n-fn macro_rules_are_globally_visible() {\n+fn use_as() {\n     let map = def_map(\n         \"\n         //- /lib.rs\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n-        structs!(Foo);\n-        mod nested;\n+        mod foo;\n+\n+        use crate::foo::Baz as Foo;\n \n-        //- /nested.rs\n-        structs!(Bar, Baz);\n+        //- /foo/mod.rs\n+        pub struct Baz;\n         \",\n     );\n-    assert_snapshot_matches!(map, @r###\"\n+    assert_snapshot_matches!(map,\n+        @r###\"\n crate\n Foo: t v\n+foo: t\n \n-crate::nested\n-Bar: t v\n+crate::foo\n Baz: t v\n-\"###);\n+\"###\n+    );\n }\n \n #[test]\n-fn macro_rules_can_define_modules() {\n+fn use_trees() {\n     let map = def_map(\n         \"\n         //- /lib.rs\n-        macro_rules! m {\n-            ($name:ident) => { mod $name;  }\n-        }\n-        m!(n1);\n+        mod foo;\n+\n+        use crate::foo::bar::{Baz, Quux};\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n \n-        //- /n1.rs\n-        m!(n2)\n-        //- /n1/n2.rs\n-        struct X;\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        pub enum Quux {};\n         \",\n     );\n-    assert_snapshot_matches!(map, @r###\"\n+    assert_snapshot_matches!(map,\n+        @r###\"\n crate\n+Quux: t\n+Baz: t v\n+foo: t\n \n-crate::n1\n+crate::foo\n+bar: t\n \n-crate::n1::n2\n-X: t v\n-\"###);\n+crate::foo::bar\n+Quux: t\n+Baz: t v\n+\"###\n+    );\n }\n \n #[test]\n-fn macro_rules_from_other_crates_are_visible() {\n-    let map = def_map_with_crate_graph(\n+fn re_exports() {\n+    let map = def_map(\n         \"\n-        //- /main.rs\n-        foo::structs!(Foo, Bar)\n-        mod bar;\n+        //- /lib.rs\n+        mod foo;\n \n-        //- /bar.rs\n-        use crate::*;\n+        use self::foo::Baz;\n \n-        //- /lib.rs\n-        #[macro_export]\n-        macro_rules! structs {\n-            ($($i:ident),*) => {\n-                $(struct $i { field: u32 } )*\n-            }\n-        }\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        pub use self::bar::Baz;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n-    assert_snapshot_matches!(map, @r###\"\n+    assert_snapshot_matches!(map,\n+        @r###\"\n crate\n-Foo: t v\n-Bar: t v\n+Baz: t v\n+foo: t\n \n-crate::bar\n-Foo: t v\n-Bar: t v\n-\"###);\n+crate::foo\n+bar: t\n+Baz: t v\n+\n+crate::foo::bar\n+Baz: t v\n+\"###\n+    );\n }\n \n #[test]\n@@ -203,12 +218,152 @@ Baz: t v\n }\n \n #[test]\n-fn glob_across_crates() {\n-    covers!(glob_across_crates);\n+fn can_import_enum_variant() {\n+    covers!(can_import_enum_variant);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        enum E { V }\n+        use self::E::V;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+V: t v\n+E: t\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn edition_2015_imports() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        mod foo;\n+        mod bar;\n+\n+        //- /bar.rs\n+        struct Bar;\n+\n+        //- /foo.rs\n+        use bar::Bar;\n+        use other_crate::FromLib;\n+\n+        //- /lib.rs\n+        struct FromLib;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n+            \"other_crate\": (\"/lib.rs\", \"2018\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+bar: t\n+foo: t\n+\n+crate::bar\n+Bar: t v\n+\n+crate::foo\n+FromLib: t v\n+Bar: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn module_resolution_works_for_non_standard_filenames() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /my_library.rs\n+        mod foo;\n+        use self::foo::Bar;\n+\n+        //- /foo/mod.rs\n+        pub struct Bar;\n+        \",\n+        crate_graph! {\n+            \"my_library\": (\"/my_library.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Bar: t v\n+foo: t\n+\n+crate::foo\n+Bar: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn name_res_works_for_broken_modules() {\n+    covers!(name_res_works_for_broken_modules);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo // no `;`, no body\n+\n+        use self::foo::Baz;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        pub use self::bar::Baz;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+    );\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: _\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn item_map_using_self() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use crate::foo::bar::Baz::{self};\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+    );\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+\n+crate::foo::bar\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn item_map_across_crates() {\n     let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n-        use test_crate::*;\n+        use test_crate::Baz;\n \n         //- /lib.rs\n         pub struct Baz;\n@@ -218,48 +373,156 @@ fn glob_across_crates() {\n             \"test_crate\": (\"/lib.rs\", []),\n         },\n     );\n-    assert_snapshot_matches!(map, @r###\"\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n crate\n Baz: t v\n \"###\n     );\n }\n \n #[test]\n-fn item_map_enum_importing() {\n-    covers!(item_map_enum_importing);\n-    let map = def_map(\n+fn extern_crate_rename() {\n+    let map = def_map_with_crate_graph(\n         \"\n+        //- /main.rs\n+        extern crate alloc as alloc_crate;\n+\n+        mod alloc;\n+        mod sync;\n+\n+        //- /sync.rs\n+        use alloc_crate::Arc;\n+\n         //- /lib.rs\n-        enum E { V }\n-        use self::E::V;\n+        struct Arc;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"alloc\"]),\n+            \"alloc\": (\"/lib.rs\", []),\n+        },\n     );\n-    assert_snapshot_matches!(map, @r###\"\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n crate\n-V: t v\n-E: t\n+Arc: t v\n \"###\n     );\n }\n \n #[test]\n-fn glob_enum() {\n-    covers!(glob_enum);\n-    let map = def_map(\n+fn extern_crate_rename_2015_edition() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        extern crate alloc as alloc_crate;\n+\n+        mod alloc;\n+        mod sync;\n+\n+        //- /sync.rs\n+        use alloc_crate::Arc;\n+\n+        //- /lib.rs\n+        struct Arc;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n+            \"alloc\": (\"/lib.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Arc: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn import_across_source_roots() {\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n+        pub mod a {\n+            pub mod b {\n+                pub struct C;\n+            }\n         }\n-        use self::Foo::*;\n+\n+        //- root /main/\n+\n+        //- /main/main.rs\n+        use test_crate::a::b::C;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n     );\n-    assert_snapshot_matches!(map, @r###\"\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+C: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn reexport_across_crates() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        use test_crate::Baz;\n+\n+        //- /lib.rs\n+        pub use foo::Baz;\n+\n+        mod foo;\n+\n+        //- /foo.rs\n+        pub struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n crate\n-Foo: t\n-Bar: t v\n Baz: t v\n \"###\n     );\n }\n+\n+#[test]\n+fn values_dont_shadow_extern_crates() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        fn foo() {}\n+        use foo::Bar;\n+\n+        //- /foo/lib.rs\n+        pub struct Bar;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/foo/lib.rs\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Bar: t v\n+foo: v\n+\"###\n+    );\n+}"}, {"sha": "6e50c7ff6e931b1e0b4f480bd0609a02983f950c", "filename": "crates/ra_hir/src/nameres/crate_def_map/tests/globs.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fglobs.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -0,0 +1,118 @@\n+use super::*;\n+\n+#[test]\n+fn glob_1() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::Baz;\n+        pub struct Foo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+bar: t\n+Foo: t v\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+Foo: t v\n+Baz: t v\n+\n+crate::foo::bar\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_2() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::*;\n+        pub struct Foo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        pub use super::*;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+bar: t\n+Foo: t v\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+Foo: t v\n+Baz: t v\n+\n+crate::foo::bar\n+bar: t\n+Foo: t v\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_across_crates() {\n+    covers!(glob_across_crates);\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        use test_crate::*;\n+\n+        //- /lib.rs\n+        pub struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_enum() {\n+    covers!(glob_enum);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        enum Foo {\n+            Bar, Baz\n+        }\n+        use self::Foo::*;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Foo: t\n+Bar: t v\n+Baz: t v\n+\"###\n+    );\n+}"}, {"sha": "6987819233bdfda886741c3f441d6338dada1d2b", "filename": "crates/ra_hir/src/nameres/crate_def_map/tests/incremental.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fincremental.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -0,0 +1,123 @@\n+use super::*;\n+\n+use std::sync::Arc;\n+\n+use ra_db::SourceDatabase;\n+\n+fn check_def_map_is_not_recomputed(initial: &str, file_change: &str) {\n+    let (mut db, pos) = MockDatabase::with_position(initial);\n+    let crate_id = db.crate_graph().iter().next().unwrap();\n+    let krate = Crate { crate_id };\n+    {\n+        let events = db.log_executed(|| {\n+            db.crate_def_map(krate);\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n+    db.set_file_text(pos.file_id, Arc::new(file_change.to_string()));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            db.crate_def_map(krate);\n+        });\n+        assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n+}\n+\n+#[test]\n+fn typing_inside_a_function_should_not_invalidate_def_map() {\n+    check_def_map_is_not_recomputed(\n+        \"\n+        //- /lib.rs\n+        mod foo;<|>\n+\n+        use crate::foo::bar::Baz;\n+\n+        fn foo() -> i32 {\n+            1 + 1\n+        }\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+        \"\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+\n+        fn foo() -> i32 { 92 }\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn adding_inner_items_should_not_invalidate_def_map() {\n+    check_def_map_is_not_recomputed(\n+        \"\n+        //- /lib.rs\n+        struct S { a: i32}\n+        enum E { A }\n+        trait T {\n+            fn a() {}\n+        }\n+        mod foo;<|>\n+        impl S {\n+            fn a() {}\n+        }\n+        use crate::foo::bar::Baz;\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+        \"\n+        struct S { a: i32, b: () }\n+        enum E { A, B }\n+        trait T {\n+            fn a() {}\n+            fn b() {}\n+        }\n+        mod foo;<|>\n+        impl S {\n+            fn a() {}\n+            fn b() {}\n+        }\n+        use crate::foo::bar::Baz;\n+        \",\n+    );\n+}\n+\n+// It would be awesome to make this work, but it's unclear how\n+#[test]\n+#[ignore]\n+fn typing_inside_a_function_inside_a_macro_should_not_invalidate_def_map() {\n+    check_def_map_is_not_recomputed(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        <|>\n+        salsa::query_group! {\n+            trait Baz {\n+                fn foo() -> i32 { 1 + 1 }\n+            }\n+        }\n+        \",\n+        \"\n+        salsa::query_group! {\n+            trait Baz {\n+                fn foo() -> i32 { 92 }\n+            }\n+        }\n+        \",\n+    );\n+}"}, {"sha": "8781b026b6fb3ef1294a5a8013daa5b4442e6ae5", "filename": "crates/ra_hir/src/nameres/crate_def_map/tests/macros.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71e5adf694a4b253bc5bb48be96bb6ba08002d8c/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests%2Fmacros.rs?ref=71e5adf694a4b253bc5bb48be96bb6ba08002d8c", "patch": "@@ -0,0 +1,94 @@\n+use super::*;\n+\n+#[test]\n+fn macro_rules_are_globally_visible() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        structs!(Foo);\n+        mod nested;\n+\n+        //- /nested.rs\n+        structs!(Bar, Baz);\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+nested: t\n+Foo: t v\n+\n+crate::nested\n+Bar: t v\n+Baz: t v\n+\"###);\n+}\n+\n+#[test]\n+fn macro_rules_can_define_modules() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        macro_rules! m {\n+            ($name:ident) => { mod $name;  }\n+        }\n+        m!(n1);\n+\n+        //- /n1.rs\n+        m!(n2)\n+        //- /n1/n2.rs\n+        struct X;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+n1: t\n+\n+crate::n1\n+n2: t\n+\n+crate::n1::n2\n+X: t v\n+\"###);\n+}\n+\n+#[test]\n+fn macro_rules_from_other_crates_are_visible() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        foo::structs!(Foo, Bar)\n+        mod bar;\n+\n+        //- /bar.rs\n+        use crate::*;\n+\n+        //- /lib.rs\n+        #[macro_export]\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+bar: t\n+Foo: t v\n+Bar: t v\n+\n+crate::bar\n+bar: t\n+Foo: t v\n+Bar: t v\n+\"###);\n+}"}, {"sha": "961e442a9aad9692086849155f64a13938c5bf0d", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "removed", "additions": 0, "deletions": 769, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -1,769 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_db::SourceDatabase;\n-use test_utils::{assert_eq_text, covers};\n-\n-use crate::{\n-    ItemMap,\n-    PersistentHirDatabase,\n-    mock::MockDatabase,\n-    nameres::crate_def_map::ModuleId,\n-};\n-use super::Resolution;\n-\n-fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n-    let (db, pos) = MockDatabase::with_position(fixture);\n-    let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let module_id = module.module_id;\n-    (db.item_map(krate), module_id)\n-}\n-\n-fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n-    let mut lines = map[module_id]\n-        .items\n-        .iter()\n-        .map(|(name, res)| format!(\"{}: {}\", name, dump_resolution(res)))\n-        .collect::<Vec<_>>();\n-    lines.sort();\n-    let actual = lines.join(\"\\n\");\n-    let expected = expected.trim().lines().map(|it| it.trim()).collect::<Vec<_>>().join(\"\\n\");\n-    assert_eq_text!(&expected, &actual);\n-\n-    fn dump_resolution(resolution: &Resolution) -> &'static str {\n-        match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n-            (true, true) => \"t v\",\n-            (true, false) => \"t\",\n-            (false, true) => \"v\",\n-            (false, false) => \"_\",\n-        }\n-    }\n-}\n-\n-#[test]\n-fn item_map_smoke_test() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::bar::Baz;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn use_as() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::Baz as Foo;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Foo: t v\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn use_trees() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::bar::{Baz, Quux};\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub enum Quux {};\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            Quux: t\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn re_exports() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use self::foo::Baz;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        pub use self::bar::Baz;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn glob_1() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::Baz;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            Foo: t v\n-            bar: t\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn glob_2() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::*;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub use super::*;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            Foo: t v\n-            bar: t\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn glob_enum() {\n-    covers!(glob_enum);\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n-        }\n-        use self::Foo::*;\n-        <|>\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Bar: t v\n-            Baz: t v\n-            Foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn glob_across_crates() {\n-    covers!(glob_across_crates);\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        use test_crate::*;\n-\n-        //- /lib.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            Baz: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn edition_2015_imports() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        mod foo;\n-        mod bar;\n-\n-        //- /bar.rs\n-        struct Bar;\n-\n-        //- /foo.rs\n-        use bar::Bar;\n-        use other_crate::FromLib;\n-\n-        //- /lib.rs\n-        struct FromLib;\n-    \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n-        \"other_crate\": (\"/lib.rs\", \"2018\", []),\n-    });\n-    let foo_id = db.file_id_of(\"/foo.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, foo_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            Bar: t v\n-            FromLib: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn module_resolution_works_for_non_standard_filenames() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /my_library.rs\n-        mod foo;\n-        use self::foo::Bar;\n-\n-        //- /foo/mod.rs\n-        pub struct Bar;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"my_library\": (\"/my_library.rs\", []),\n-    });\n-    let file_id = db.file_id_of(\"/my_library.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, file_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let module_id = module.module_id;\n-    let item_map = db.item_map(krate);\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-        Bar: t v\n-        foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn std_prelude() {\n-    covers!(std_prelude);\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        use Foo::*;\n-\n-        //- /lib.rs\n-        mod prelude;\n-        #[prelude_import]\n-        use prelude::*;\n-\n-        //- /prelude.rs\n-        pub enum Foo { Bar, Baz };\n-    \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    eprintln!(\"module = {:?}\", module);\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            Bar: t v\n-            Baz: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn name_res_works_for_broken_modules() {\n-    covers!(name_res_works_for_broken_modules);\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo // no `;`, no body\n-\n-        use self::foo::Baz;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        pub use self::bar::Baz;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: _\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn item_map_using_self() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-            //- /lib.rs\n-            mod foo;\n-            use crate::foo::bar::Baz::{self};\n-            <|>\n-            //- /foo/mod.rs\n-            pub mod bar;\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            foo: t\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn item_map_enum_importing() {\n-    covers!(item_map_enum_importing);\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        enum E { V }\n-        use self::E::V;\n-        <|>\n-        \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-        E: t\n-        V: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn item_map_across_crates() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        use test_crate::Baz;\n-\n-        //- /lib.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Baz: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn extern_crate_rename() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        extern crate alloc as alloc_crate;\n-\n-        mod alloc;\n-        mod sync;\n-\n-        //- /sync.rs\n-        use alloc_crate::Arc;\n-\n-        //- /lib.rs\n-        struct Arc;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"alloc\"]),\n-        \"alloc\": (\"/lib.rs\", []),\n-    });\n-    let sync_id = db.file_id_of(\"/sync.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, sync_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Arc: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn extern_crate_rename_2015_edition() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        extern crate alloc as alloc_crate;\n-\n-        mod alloc;\n-        mod sync;\n-\n-        //- /sync.rs\n-        use alloc_crate::Arc;\n-\n-        //- /lib.rs\n-        struct Arc;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n-        \"alloc\": (\"/lib.rs\", []),\n-    });\n-    let sync_id = db.file_id_of(\"/sync.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, sync_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Arc: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn import_across_source_roots() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /lib.rs\n-        pub mod a {\n-            pub mod b {\n-                pub struct C;\n-            }\n-        }\n-\n-        //- root /main/\n-\n-        //- /main/main.rs\n-        use test_crate::a::b::C;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            C: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn reexport_across_crates() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        use test_crate::Baz;\n-\n-        //- /lib.rs\n-        pub use foo::Baz;\n-\n-        mod foo;\n-\n-        //- /foo.rs\n-        pub struct Baz;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Baz: t v\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn values_dont_shadow_extern_crates() {\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        fn foo() {}\n-        use foo::Bar;\n-\n-        //- /foo/lib.rs\n-        pub struct Bar;\n-        \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"foo\"]),\n-        \"foo\": (\"/foo/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Bar: t v\n-        foo: v\n-        \",\n-    );\n-}\n-\n-fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n-    let (mut db, pos) = MockDatabase::with_position(initial);\n-    let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    {\n-        let events = db.log_executed(|| {\n-            db.item_map(krate);\n-        });\n-        assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n-    }\n-    db.set_file_text(pos.file_id, Arc::new(file_change.to_string()));\n-\n-    {\n-        let events = db.log_executed(|| {\n-            db.item_map(krate);\n-        });\n-        assert!(!format!(\"{:?}\", events).contains(\"item_map\"), \"{:#?}\", events)\n-    }\n-}\n-\n-#[test]\n-fn typing_inside_a_function_should_not_invalidate_item_map() {\n-    check_item_map_is_not_recomputed(\n-        \"\n-        //- /lib.rs\n-        mod foo;<|>\n-\n-        use crate::foo::bar::Baz;\n-\n-        fn foo() -> i32 {\n-            1 + 1\n-        }\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-        \"\n-        mod foo;\n-\n-        use crate::foo::bar::Baz;\n-\n-        fn foo() -> i32 { 92 }\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn adding_inner_items_should_not_invalidate_item_map() {\n-    check_item_map_is_not_recomputed(\n-        \"\n-        //- /lib.rs\n-        struct S { a: i32}\n-        enum E { A }\n-        trait T {\n-            fn a() {}\n-        }\n-        mod foo;<|>\n-        impl S {\n-            fn a() {}\n-        }\n-        use crate::foo::bar::Baz;\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-        \"\n-        struct S { a: i32, b: () }\n-        enum E { A, B }\n-        trait T {\n-            fn a() {}\n-            fn b() {}\n-        }\n-        mod foo;<|>\n-        impl S {\n-            fn a() {}\n-            fn b() {}\n-        }\n-        use crate::foo::bar::Baz;\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn typing_inside_a_function_inside_a_macro_should_not_invalidate_item_map() {\n-    check_item_map_is_not_recomputed(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::bar::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        <|>\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 1 + 1 }\n-            }\n-        }\n-        \",\n-        \"\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 92 }\n-            }\n-        }\n-        \",\n-    );\n-}"}]}