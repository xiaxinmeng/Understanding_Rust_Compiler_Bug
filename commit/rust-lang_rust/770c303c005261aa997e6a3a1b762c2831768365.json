{"sha": "770c303c005261aa997e6a3a1b762c2831768365", "node_id": "C_kwDOAAsO6NoAKDc3MGMzMDNjMDA1MjYxYWE5OTdlNmEzYTFiNzYyYzI4MzE3NjgzNjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-16T22:22:42Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-18T18:50:18Z"}, "message": "Report reason why index impl is not satisfied deeply", "tree": {"sha": "7aff7ff2ed4319d8c443bd30470e5c5e4ddf0212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aff7ff2ed4319d8c443bd30470e5c5e4ddf0212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/770c303c005261aa997e6a3a1b762c2831768365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/770c303c005261aa997e6a3a1b762c2831768365", "html_url": "https://github.com/rust-lang/rust/commit/770c303c005261aa997e6a3a1b762c2831768365", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/770c303c005261aa997e6a3a1b762c2831768365/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a778ca1e35e4a8df95c00d800100d95e63e7722", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a778ca1e35e4a8df95c00d800100d95e63e7722", "html_url": "https://github.com/rust-lang/rust/commit/8a778ca1e35e4a8df95c00d800100d95e63e7722"}], "stats": {"total": 141, "additions": 141, "deletions": 0}, "files": [{"sha": "5c45e8f9d94109eba8524d95417cada84e747a2d", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/770c303c005261aa997e6a3a1b762c2831768365/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/770c303c005261aa997e6a3a1b762c2831768365/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=770c303c005261aa997e6a3a1b762c2831768365", "patch": "@@ -38,6 +38,7 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::InferOk;\n+use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n@@ -53,6 +54,8 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -2800,6 +2803,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     element_ty\n                 }\n                 None => {\n+                    // Attempt to *shallowly* search for an impl which matches,\n+                    // but has nested obligations which are unsatisfied.\n+                    for (base_t, _) in self.autoderef(base.span, base_t).silence_errors() {\n+                        if let Some((_, index_ty, element_ty)) =\n+                            self.find_and_report_unsatisfied_index_impl(expr.hir_id, base, base_t)\n+                        {\n+                            self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n+                            return element_ty;\n+                        }\n+                    }\n+\n                     let mut err = type_error_struct!(\n                         self.tcx.sess,\n                         expr.span,\n@@ -2843,6 +2857,89 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Try to match an implementation of `Index` against a self type, and report\n+    /// the unsatisfied predicates that result from confirming this impl.\n+    ///\n+    /// Given an index expression, sometimes the `Self` type shallowly but does not\n+    /// deeply satisfy an impl predicate. Instead of simply saying that the type\n+    /// does not support being indexed, we want to point out exactly what nested\n+    /// predicates cause this to be, so that the user can add them to fix their code.\n+    fn find_and_report_unsatisfied_index_impl(\n+        &self,\n+        index_expr_hir_id: HirId,\n+        base_expr: &hir::Expr<'_>,\n+        base_ty: Ty<'tcx>,\n+    ) -> Option<(ErrorGuaranteed, Ty<'tcx>, Ty<'tcx>)> {\n+        let index_trait_def_id = self.tcx.lang_items().index_trait()?;\n+\n+        let mut relevant_impls = vec![];\n+        self.tcx.for_each_relevant_impl(index_trait_def_id, base_ty, |impl_def_id| {\n+            relevant_impls.push(impl_def_id);\n+        });\n+        let [impl_def_id] = relevant_impls[..] else {\n+            // Only report unsatisfied impl predicates if there's one impl\n+            return None;\n+        };\n+\n+        self.commit_if_ok(|_| {\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n+            let impl_substs = self.fresh_substs_for_item(base_expr.span, impl_def_id);\n+            let impl_trait_ref =\n+                self.tcx.impl_trait_ref(impl_def_id).unwrap().subst(self.tcx, impl_substs);\n+            let cause = self.misc(base_expr.span);\n+\n+            // Match the impl self type against the base ty. If this fails,\n+            // we just skip this impl, since it's not particularly useful.\n+            let impl_trait_ref = ocx.normalize(&cause, self.param_env, impl_trait_ref);\n+            ocx.eq(&cause, self.param_env, impl_trait_ref.self_ty(), base_ty)?;\n+\n+            // Register the impl's predicates. One of these predicates\n+            // must be unsatisfied, or else we wouldn't have gotten here\n+            // in the first place.\n+            ocx.register_obligations(traits::predicates_for_generics(\n+                |idx, span| {\n+                    traits::ObligationCause::new(\n+                        base_expr.span,\n+                        self.body_id,\n+                        if span.is_dummy() {\n+                            traits::ExprItemObligation(impl_def_id, index_expr_hir_id, idx)\n+                        } else {\n+                            traits::ExprBindingObligation(impl_def_id, span, index_expr_hir_id, idx)\n+                        },\n+                    )\n+                },\n+                self.param_env,\n+                self.tcx.predicates_of(impl_def_id).instantiate(self.tcx, impl_substs),\n+            ));\n+\n+            // Normalize the output type, which we can use later on as the\n+            // return type of the index expression...\n+            let element_ty = ocx.normalize(\n+                &cause,\n+                self.param_env,\n+                self.tcx.mk_projection(\n+                    self.tcx\n+                        .associated_items(index_trait_def_id)\n+                        .filter_by_name_unhygienic(sym::Output)\n+                        .next()\n+                        .unwrap()\n+                        .def_id,\n+                    impl_trait_ref.substs,\n+                ),\n+            );\n+\n+            let errors = ocx.select_where_possible();\n+            // There should be at least one error reported. If not, we\n+            // will still delay a span bug in `report_fulfillment_errors`.\n+            Ok::<_, NoSolution>((\n+                self.err_ctxt().report_fulfillment_errors(&errors),\n+                impl_trait_ref.substs.type_at(1),\n+                element_ty,\n+            ))\n+        })\n+        .ok()\n+    }\n+\n     fn point_at_index_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,"}, {"sha": "8f3b97dc7414798b916dbbf494b212a9f9571ecc", "filename": "tests/ui/typeck/bad-index-due-to-nested.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/770c303c005261aa997e6a3a1b762c2831768365/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/770c303c005261aa997e6a3a1b762c2831768365/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.rs?ref=770c303c005261aa997e6a3a1b762c2831768365", "patch": "@@ -0,0 +1,15 @@\n+use std::collections::HashMap;\n+\n+pub struct Graph<V> {\n+    node_index_map: HashMap<V, usize>,\n+}\n+\n+impl<V> Graph<V> {\n+    pub fn node_index(&self, node: V) -> usize {\n+        self.node_index_map[&node]\n+        //~^ ERROR the trait bound `V: Eq` is not satisfied\n+        //~| ERROR the trait bound `V: Hash` is not satisfied\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fdacba793961bb2438f1dca9c55bb0e4eafbec8e", "filename": "tests/ui/typeck/bad-index-due-to-nested.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/770c303c005261aa997e6a3a1b762c2831768365/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/770c303c005261aa997e6a3a1b762c2831768365/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr?ref=770c303c005261aa997e6a3a1b762c2831768365", "patch": "@@ -0,0 +1,29 @@\n+error[E0277]: the trait bound `V: Eq` is not satisfied\n+  --> $DIR/bad-index-due-to-nested.rs:9:9\n+   |\n+LL |         self.node_index_map[&node]\n+   |         ^^^^^^^^^^^^^^^^^^^ the trait `Eq` is not implemented for `V`\n+   |\n+note: required by a bound in `<HashMap<K, V, S> as Index<&Q>>`\n+  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n+help: consider restricting type parameter `V`\n+   |\n+LL | impl<V: std::cmp::Eq> Graph<V> {\n+   |       ++++++++++++++\n+\n+error[E0277]: the trait bound `V: Hash` is not satisfied\n+  --> $DIR/bad-index-due-to-nested.rs:9:9\n+   |\n+LL |         self.node_index_map[&node]\n+   |         ^^^^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `V`\n+   |\n+note: required by a bound in `<HashMap<K, V, S> as Index<&Q>>`\n+  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n+help: consider restricting type parameter `V`\n+   |\n+LL | impl<V: std::hash::Hash> Graph<V> {\n+   |       +++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}