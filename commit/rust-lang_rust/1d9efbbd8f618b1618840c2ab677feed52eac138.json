{"sha": "1d9efbbd8f618b1618840c2ab677feed52eac138", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOWVmYmJkOGY2MThiMTYxODg0MGMyYWI2NzdmZWVkNTJlYWMxMzg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-26T09:11:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-26T09:11:17Z"}, "message": "Miri: replace canonical_alloc_id mechanism by extern_static_alloc_id which is called only when a pointer is 'imported' into the machine", "tree": {"sha": "f8e29c47b2b8b18c4ac1dc386503b91a0cf0b363", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8e29c47b2b8b18c4ac1dc386503b91a0cf0b363"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d9efbbd8f618b1618840c2ab677feed52eac138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9efbbd8f618b1618840c2ab677feed52eac138", "html_url": "https://github.com/rust-lang/rust/commit/1d9efbbd8f618b1618840c2ab677feed52eac138", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d9efbbd8f618b1618840c2ab677feed52eac138/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bbfa02b1b15974d5772b520aa027bf79f8c248e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bbfa02b1b15974d5772b520aa027bf79f8c248e", "html_url": "https://github.com/rust-lang/rust/commit/2bbfa02b1b15974d5772b520aa027bf79f8c248e"}], "stats": {"total": 175, "additions": 78, "deletions": 97}, "files": [{"sha": "ff6284e75db81a0302ba2efe819edebd9b773cff", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -502,8 +502,6 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// Accessing an unsupported foreign static.\n-    ReadForeignStatic(DefId),\n     /// Could not find MIR for a function.\n     NoMirFor(DefId),\n     /// Encountered a pointer where we needed raw bytes.\n@@ -515,15 +513,17 @@ pub enum UnsupportedOpInfo {\n     ReadBytesAsPointer,\n     /// Accessing thread local statics\n     ThreadLocalStatic(DefId),\n+    /// Accessing an unsupported extern static.\n+    ReadExternStatic(DefId),\n }\n \n impl fmt::Display for UnsupportedOpInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ReadForeignStatic(did) => {\n-                write!(f, \"cannot read from foreign (extern) static ({:?})\", did)\n+            ReadExternStatic(did) => {\n+                write!(f, \"cannot read from extern static ({:?})\", did)\n             }\n             NoMirFor(did) => write!(f, \"no MIR body is available for {:?}\", did),\n             ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),"}, {"sha": "0f580b308142f2b305cb1530b34213859f6085cc", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -323,14 +323,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the *canonical* machine pointer to the allocation.  Must never be used\n-    /// for any other pointers!\n+    /// the machine pointer to the allocation.  Must never be used\n+    /// for any other pointers, nor for TLS statics.\n     ///\n-    /// This represents a *direct* access to that memory, as opposed to access\n-    /// through a pointer that was created by the program.\n+    /// Using the resulting pointer represents a *direct* access to that memory\n+    /// (e.g. by directly using a `static`),\n+    /// as opposed to access through a pointer that was created by the program.\n+    ///\n+    /// This function can fail only if `ptr` points to an `extern static`.\n     #[inline(always)]\n-    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        self.memory.tag_global_base_pointer(ptr)\n+    pub fn global_base_pointer(&self, ptr: Pointer) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        self.memory.global_base_pointer(ptr)\n     }\n \n     #[inline(always)]"}, {"sha": "634f3c96e6c9f77b4c39afe1f123a1c5e90505e5", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -238,45 +238,30 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called for *every* memory access to determine the real ID of the given allocation.\n-    /// This provides a way for the machine to \"redirect\" certain allocations as it sees fit.\n-    ///\n-    /// This is used by Miri to redirect extern statics to real allocations.\n-    ///\n-    /// This function must be idempotent.\n-    #[inline]\n-    fn canonical_alloc_id(_mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n-        id\n+    /// Return the `AllocId` for the given thread-local static in the current thread.\n+    fn thread_local_static_alloc_id(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, AllocId> {\n+        throw_unsup!(ThreadLocalStatic(def_id))\n     }\n \n-    /// Called when converting a `ty::Const` to an operand (in\n-    /// `eval_const_to_op`).\n-    ///\n-    /// Miri uses this callback for creating per thread allocations for thread\n-    /// locals. In Rust, one way of creating a thread local is by marking a\n-    /// static with `#[thread_local]`. On supported platforms this gets\n-    /// translated to a LLVM thread local for which LLVM automatically ensures\n-    /// that each thread gets its own copy. Since LLVM automatically handles\n-    /// thread locals, the Rust compiler just treats thread local statics as\n-    /// regular statics even though accessing a thread local static should be an\n-    /// effectful computation that depends on the current thread. The long term\n-    /// plan is to change MIR to make accesses to thread locals explicit\n-    /// (https://github.com/rust-lang/rust/issues/70685). While the issue 70685\n-    /// is not fixed, our current workaround in Miri is to use this function to\n-    /// make per-thread copies of thread locals. Please note that we cannot make\n-    /// these copies in `canonical_alloc_id` because that is too late: for\n-    /// example, if one created a pointer in thread `t1` to a thread local and\n-    /// sent it to another thread `t2`, resolving the access in\n-    /// `canonical_alloc_id` would result in pointer pointing to `t2`'s thread\n-    /// local and not `t1` as it should.\n-    #[inline]\n-    fn adjust_global_const(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        val: mir::interpret::ConstValue<'tcx>,\n-    ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n-        Ok(val)\n+    /// Return the `AllocId` backing the given `extern static`.\n+    fn extern_static_alloc_id(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, AllocId> {\n+        // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n+        Ok(mem.tcx.create_static_alloc(def_id))\n     }\n \n+    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n+    /// this will return an unusable tag (i.e., accesses will be UB)!\n+    ///\n+    /// Called on the id returned by `thread_local_static_alloc_id` and `extern_static_alloc_id`, if needed.\n+    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n@@ -309,13 +294,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n-    /// this will return an unusable tag (i.e., accesses will be UB)!\n-    ///\n-    /// Expects `id` to be already canonical, if needed.\n-    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n-\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n@@ -375,13 +353,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64>;\n-\n-    fn thread_local_alloc_id(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        did: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n-        throw_unsup!(ThreadLocalStatic(did))\n-    }\n }\n \n // A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines"}, {"sha": "fce33eed66fe64453104d62b8b310072b10f7dd4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -137,15 +137,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the *canonical* machine pointer to the allocation.  Must never be used\n-    /// for any other pointers!\n+    /// the machine pointer to the allocation.  Must never be used\n+    /// for any other pointers, nor for TLS statics.\n     ///\n-    /// This represents a *direct* access to that memory, as opposed to access\n-    /// through a pointer that was created by the program.\n+    /// Using the resulting pointer represents a *direct* access to that memory\n+    /// (e.g. by directly using a `static`),\n+    /// as opposed to access through a pointer that was created by the program.\n+    ///\n+    /// This function can fail only if `ptr` points to an `extern static`.\n     #[inline]\n-    pub fn tag_global_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        ptr.with_tag(M::tag_global_base_pointer(&self.extra, id))\n+    pub fn global_base_pointer(&self, mut ptr: Pointer) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        // We need to handle `extern static`.\n+        let ptr = match self.tcx.get_global_alloc(ptr.alloc_id) {\n+            Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n+                bug!(\"global memory cannot point to thread-local static\")\n+            }\n+            Some(GlobalAlloc::Static(def_id)) if self.tcx.is_foreign_item(def_id) => {\n+                ptr.alloc_id = M::extern_static_alloc_id(self, def_id)?;\n+                ptr\n+            }\n+            _ => {\n+                // No need to change the `AllocId`.\n+                ptr\n+            }\n+        };\n+        // And we need to get the tag.\n+        let tag = M::tag_global_base_pointer(&self.extra, ptr.alloc_id);\n+        Ok(ptr.with_tag(tag))\n     }\n \n     pub fn create_fn_alloc(\n@@ -162,7 +180,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 id\n             }\n         };\n-        self.tag_global_base_pointer(Pointer::from(id))\n+        // Functions are global allocations, so make sure we get the right base pointer.\n+        // We know this is not an `extern static` so this cannmot fail.\n+        self.global_base_pointer(Pointer::from(id)).unwrap()\n     }\n \n     pub fn allocate(\n@@ -195,6 +215,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n             \"dynamically allocating global memory\"\n         );\n+        // This is a new allocation, not a new global one, so no `global_base_ptr`.\n         let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n         Pointer::from(id).with_tag(tag)\n@@ -437,6 +458,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n+                assert!(tcx.is_static(def_id));\n                 assert!(!tcx.is_thread_local_static(def_id));\n                 // Notice that every static has two `AllocId` that will resolve to the same\n                 // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n@@ -448,24 +470,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form.\n-                //\n-                // Assumes `id` is already canonical.\n                 if tcx.is_foreign_item(def_id) {\n-                    trace!(\"get_global_alloc: foreign item {:?}\", def_id);\n-                    throw_unsup!(ReadForeignStatic(def_id))\n+                    throw_unsup!(ReadExternStatic(def_id));\n                 }\n                 trace!(\"get_global_alloc: Need to compute {:?}\", def_id);\n                 let instance = Instance::mono(tcx, def_id);\n                 let gid = GlobalId { instance, promoted: None };\n                 // Use the raw query here to break validation cycles. Later uses of the static\n                 // will call the full query anyway.\n-                let raw_const =\n-                    tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-                        // no need to report anything, the const_eval call takes care of that\n-                        // for statics\n-                        assert!(tcx.is_static(def_id));\n-                        err\n-                    })?;\n+                let raw_const = tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid))?;\n                 // Make sure we use the ID of the resolved memory, not the lazy one!\n                 let id = raw_const.alloc_id;\n                 let allocation = tcx.global_alloc(id).unwrap_memory();\n@@ -482,6 +495,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             alloc,\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n+        // Sanity check that this is the same pointer we would have gotten via `global_base_pointer`.\n         debug_assert_eq!(tag, M::tag_global_base_pointer(memory_extra, id));\n         Ok(alloc)\n     }\n@@ -492,7 +506,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n-        let id = M::canonical_alloc_id(self, id);\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -529,7 +542,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &mut self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n-        let id = M::canonical_alloc_id(self, id);\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n@@ -568,7 +580,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n-        let id = M::canonical_alloc_id(self, id);\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n@@ -621,7 +632,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Assumes `id` is already canonical.\n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"reading fn ptr: {}\", id);\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n@@ -642,8 +652,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(ptr.erase_tag()))\n         }\n-        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        self.get_fn_alloc(id).ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n+        self.get_fn_alloc(ptr.alloc_id).ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "bb058476823e8afa132847aa0a430a4d072f8d73", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -541,9 +541,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         val: &ty::Const<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let tag_scalar = |scalar| match scalar {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_global_base_pointer(ptr)),\n-            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+        let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n+            Ok(match scalar {\n+                Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n+                Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+            })\n         };\n         // Early-return cases.\n         let val_val = match val.val {\n@@ -570,10 +572,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n-        // This call allows the machine to create fresh allocation ids for\n-        // thread-local statics (see the `adjust_global_const` function\n-        // documentation).\n-        let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n         let layout =\n             from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(val.ty))?;\n@@ -582,10 +580,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let id = self.tcx.create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n-                let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n+                let ptr = self.global_base_pointer(Pointer::new(id, offset))?;\n                 Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             }\n-            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x).into()),\n+            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x)?.into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n@@ -594,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n-                    self.tag_global_base_pointer(ptr).into(),\n+                    self.global_base_pointer(ptr)?.into(),\n                     u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))"}, {"sha": "76f0e82db96f391c2c0dddf97a4e8d95ef676963", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -1126,7 +1126,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         let _ = self.tcx.global_alloc(raw.alloc_id);\n-        let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n+        let ptr = self.global_base_pointer(Pointer::from(raw.alloc_id))?;\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }"}, {"sha": "3d1e3eccc6147a8f1b2d5367058b55c8c88a1f44", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9efbbd8f618b1618840c2ab677feed52eac138/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1d9efbbd8f618b1618840c2ab677feed52eac138", "patch": "@@ -141,8 +141,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Rvalue::*;\n         match *rvalue {\n             ThreadLocalRef(did) => {\n-                let id = M::thread_local_alloc_id(self, did)?;\n-                let val = Scalar::Ptr(self.tag_global_base_pointer(id.into()));\n+                let id = M::thread_local_static_alloc_id(self, did)?;\n+                let val = self.global_base_pointer(id.into())?;\n                 self.write_scalar(val, dest)?;\n             }\n "}]}