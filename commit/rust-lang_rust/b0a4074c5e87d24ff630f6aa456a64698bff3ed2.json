{"sha": "b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYTQwNzRjNWU4N2QyNGZmNjMwZjZhYTQ1NmE2NDY5OGJmZjNlZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-26T09:54:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-26T09:54:11Z"}, "message": "Auto merge of #41504 - eddyb:query-api, r=nikomatsakis\n\nImprove the librustc on-demand/query API ergonomics.\n\nQueries are now performed through these two forms:\n* `tcx.type_of(def_id)` (the most common usage)\n* `tcx.at(span).type_of(def_id)` (to provide a more specific location in the cycle stack)\n\nSeveral queries were renamed to work better as method names, i.e. by suffixing with `_of`.\n\nr? @nikomatsakis", "tree": {"sha": "c5d93f160323d8115205a38d6f4eebed323e8793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5d93f160323d8115205a38d6f4eebed323e8793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "html_url": "https://github.com/rust-lang/rust/commit/b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dad9814eb0964a92494fef9ce23b80353dc14c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/dad9814eb0964a92494fef9ce23b80353dc14c46", "html_url": "https://github.com/rust-lang/rust/commit/dad9814eb0964a92494fef9ce23b80353dc14c46"}, {"sha": "decf7598ef3a245ddaed9272091b3afc3466617f", "url": "https://api.github.com/repos/rust-lang/rust/commits/decf7598ef3a245ddaed9272091b3afc3466617f", "html_url": "https://github.com/rust-lang/rust/commit/decf7598ef3a245ddaed9272091b3afc3466617f"}], "stats": {"total": 1065, "additions": 508, "deletions": 557}, "files": [{"sha": "d234e408a22dcb15f95692fb914cd9c93b668ce0", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -52,7 +52,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Find the tables for this body.\n     let owner_def_id = tcx.hir.local_def_id(tcx.hir.body_owner(body.id()));\n-    let tables = tcx.item_tables(owner_def_id);\n+    let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut cfg_builder = CFGBuilder {\n         tcx: tcx,"}, {"sha": "e75513e924eec99432159477c298a13422bfaf61", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -450,7 +450,7 @@ impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n                     Option<ty::TypeckTables<'tcx>>,\n                     Option<ty::ParameterEnvironment<'tcx>>) {\n         let item_id = tcx.hir.body_owner(self);\n-        (Some(tcx.item_tables(tcx.hir.local_def_id(item_id))),\n+        (Some(tcx.typeck_tables_of(tcx.hir.local_def_id(item_id))),\n          None,\n          Some(ty::ParameterEnvironment::for_item(tcx, item_id)))\n     }\n@@ -1237,7 +1237,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             substs: &[Kind<'tcx>])\n                             -> Ty<'tcx> {\n         let default = if def.has_default {\n-            let default = self.tcx.item_type(def.def_id);\n+            let default = self.tcx.type_of(def.def_id);\n             Some(type_variable::Default {\n                 ty: default.subst_spanned(self.tcx, substs, Some(span)),\n                 origin_span: span,"}, {"sha": "6947e7c3f4085ce579d75f7a32f1bfd86f07bb3b", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -43,7 +43,7 @@ use std::fmt;\n use syntax::attr;\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use syntax_pos::{DUMMY_SP, MultiSpan, Span};\n+use syntax_pos::{MultiSpan, Span};\n use errors::{self, Diagnostic, DiagnosticBuilder};\n use hir;\n use hir::def_id::LOCAL_CRATE;\n@@ -1234,7 +1234,7 @@ fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n-    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir.krate();\n "}, {"sha": "74026abe64db2fd1c27a0b4a000bfbc490e04c5b", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -14,7 +14,7 @@ pub use rustc_const_math::ConstInt;\n use hir;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use ty::{self, TyCtxt};\n+use ty::TyCtxt;\n use ty::subst::Substs;\n use util::common::ErrorReported;\n use rustc_const_math::*;\n@@ -228,7 +228,7 @@ pub fn eval_length(tcx: TyCtxt,\n     let count_expr = &tcx.hir.body(count).value;\n     let count_def_id = tcx.hir.body_owner_def_id(count);\n     let substs = Substs::empty();\n-    match ty::queries::const_eval::get(tcx, count_expr.span, (count_def_id, substs)) {\n+    match tcx.at(count_expr.span).const_eval((count_def_id, substs)) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);"}, {"sha": "0840495ff77a893a3205b62a712c8690a6571329", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -26,7 +26,6 @@ use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n use syntax::attr;\n-use syntax::codemap::DUMMY_SP;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n@@ -160,7 +159,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n-                        let def = self.tcx.lookup_adt_def(def_id);\n+                        let def = self.tcx.adt_def(def_id);\n                         self.struct_has_extern_repr = def.repr.c();\n \n                         intravisit::walk_item(self, &item);\n@@ -433,7 +432,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.item_type(self.tcx.hir.local_def_id(field.id));\n+        let field_type = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n@@ -593,7 +592,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n     let krate = tcx.hir.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };"}, {"sha": "82e7d972c579a0cb5ff9607ce3cdff359cb617dc", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -998,7 +998,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {\n                     let enum_did = tcx.parent_def_id(variant_did).unwrap();\n-                    let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n+                    let downcast_cmt = if tcx.adt_def(enum_did).is_univariant() {\n                         cmt_pat\n                     } else {\n                         let cmt_pat_ty = cmt_pat.ty;"}, {"sha": "435dd05358d47e11162b8248ce191666a1e7b452", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -66,7 +66,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.infcx.tcx.item_type(def_id).sty {\n+        let intrinsic = match self.infcx.tcx.type_of(def_id).sty {\n             ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n             _ => return false\n         };"}, {"sha": "631046788629de547937c71f4feffbfe4d4f1da6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1426,7 +1426,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  entry_ln: LiveNode,\n                  body: &hir::Body)\n     {\n-        let fn_ty = self.ir.tcx.item_type(self.ir.tcx.hir.local_def_id(id));\n+        let fn_ty = self.ir.tcx.type_of(self.ir.tcx.hir.local_def_id(id));\n         let fn_sig = match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) => {\n                 self.ir.tcx.closure_type(closure_def_id)"}, {"sha": "677eca10d7bae7e1299c9ab05c83df921f80eb39", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1159,7 +1159,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     Def::VariantCtor(variant_did, ..) => {\n                         // univariant enums do not need downcasts\n                         let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n-                        if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n+                        if !self.tcx().adt_def(enum_did).is_univariant() {\n                             self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                         } else {\n                             cmt\n@@ -1177,7 +1177,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n-                    self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n+                    self.tcx().adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n                 Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty(&pat)?.sty {"}, {"sha": "431760b6fcd65187bca5eafec3f080bc1bea4cc1", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -28,7 +28,6 @@ use util::nodemap::{NodeSet, FxHashSet};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::DUMMY_SP;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -364,13 +363,13 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n }\n \n pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<NodeSet> {\n-    ty::queries::reachable_set::get(tcx, DUMMY_SP, LOCAL_CRATE)\n+    tcx.reachable_set(LOCAL_CRATE)\n }\n \n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> Rc<NodeSet> {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n-    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||"}, {"sha": "7431eb3fe96efd73e498dc53aca4def967de04bb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let sess = &tcx.sess;\n \n-    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability.borrow().staged_api[&LOCAL_CRATE] && tcx.sess.features.borrow().staged_api {\n         let krate = tcx.hir.krate();"}, {"sha": "724d4f457deae5ca59a604b73baed1e59f481d94", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1015,7 +1015,7 @@ impl<'tcx> Operand<'tcx> {\n     ) -> Self {\n         Operand::Constant(Constant {\n             span: span,\n-            ty: tcx.item_type(def_id).subst(tcx, substs),\n+            ty: tcx.type_of(def_id).subst(tcx, substs),\n             literal: Literal::Value { value: ConstVal::Function(def_id, substs) },\n         })\n     }"}, {"sha": "b6020df072853631ce43cfa14d2e01403ed8f9f4", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> Rvalue<'tcx> {\n                         )\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {\n-                        tcx.item_type(def.did).subst(tcx, substs)\n+                        tcx.type_of(def.did).subst(tcx, substs)\n                     }\n                     AggregateKind::Closure(did, substs) => {\n                         tcx.mk_closure_from_closure_substs(did, substs)"}, {"sha": "353677f4f2bed1a4f9c912e798d890639576ea94", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut self_match_impls = vec![];\n         let mut fuzzy_match_impls = vec![];\n \n-        self.tcx.lookup_trait_def(trait_ref.def_id)\n+        self.tcx.trait_def(trait_ref.def_id)\n             .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n                 let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n             if let Some(istring) = item.value_str() {\n                 let istring = &*istring.as_str();\n-                let generics = self.tcx.item_generics(trait_ref.def_id);\n+                let generics = self.tcx.generics_of(trait_ref.def_id);\n                 let generic_map = generics.types.iter().map(|param| {\n                     (param.name.as_str().to_string(),\n                         trait_ref.substs.type_for_def(param).to_string())\n@@ -372,7 +372,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                               trait_ref.skip_binder().self_ty(),\n                                               true);\n         let mut impl_candidates = Vec::new();\n-        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n+        let trait_def = self.tcx.trait_def(trait_ref.def_id());\n \n         match simp {\n             Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {"}, {"sha": "a7f9cc74c4f5837c0f58fa220ad6ad90cca6c549", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -641,7 +641,7 @@ pub fn get_vtable_methods<'a, 'tcx>(\n             // do not hold for this particular set of type parameters.\n             // Note that this method could then never be called, so we\n             // do not want to try and trans it, in that case (see #23435).\n-            let predicates = tcx.item_predicates(def_id).instantiate_own(tcx, substs);\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n             if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"get_vtable_methods: predicates do not hold\");\n                 return None;"}, {"sha": "351bde2177cb61a1872cb57e5a51c236e283196a", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -79,7 +79,7 @@ pub enum MethodViolationCode {\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n         // Because we query yes/no results frequently, we keep a cache:\n-        let def = self.lookup_trait_def(trait_def_id);\n+        let def = self.trait_def(trait_def_id);\n \n         let result = def.object_safety().unwrap_or_else(|| {\n             let result = self.object_safety_violations(trait_def_id).is_empty();\n@@ -167,9 +167,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             substs: Substs::identity_for_item(self, trait_def_id)\n         });\n         let predicates = if supertraits_only {\n-            self.item_super_predicates(trait_def_id)\n+            self.super_predicates_of(trait_def_id)\n         } else {\n-            self.item_predicates(trait_def_id)\n+            self.predicates_of(trait_def_id)\n         };\n         predicates\n             .predicates\n@@ -208,7 +208,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n         let free_substs = self.construct_free_substs(def_id,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = self.item_predicates(def_id);\n+        let predicates = self.predicates_of(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n@@ -281,7 +281,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n-        let ref sig = self.item_type(method.def_id).fn_sig();\n+        let ref sig = self.type_of(method.def_id).fn_sig();\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -292,7 +292,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !self.item_generics(method.def_id).types.is_empty() {\n+        if !self.generics_of(method.def_id).types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "7e0954c92a660961a309a6ebf95ed74a71b44998", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in trans.\n                 if self.selcx.projection_mode() == Reveal::All {\n-                    let generic_ty = self.tcx().item_type(def_id);\n+                    let generic_ty = self.tcx().type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                     self.fold_ty(concrete_ty)\n                 } else {\n@@ -787,7 +787,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().item_predicates(def_id);\n+    let trait_predicates = selcx.tcx().predicates_of(def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n@@ -1288,7 +1288,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                        obligation.predicate.trait_ref);\n                 tcx.types.err\n             } else {\n-                tcx.item_type(node_item.item.def_id)\n+                tcx.type_of(node_item.item.def_id)\n             };\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n             Progress {\n@@ -1317,7 +1317,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = selcx.tcx().lookup_trait_def(trait_def_id);\n+    let trait_def = selcx.tcx().trait_def(trait_def_id);\n \n     if !trait_def.is_complete(selcx.tcx()) {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);"}, {"sha": "cccc20e5b296bd692fdd23ec52144512fd942582", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -842,7 +842,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if let ImplCandidate(def_id) = candidate {\n-            if self.tcx().trait_impl_polarity(def_id) == hir::ImplPolarity::Negative {\n+            if self.tcx().impl_polarity(def_id) == hir::ImplPolarity::Negative {\n                 return Err(Unimplemented)\n             }\n         }\n@@ -1222,8 +1222,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id={:?}, substs={:?}\",\n                def_id, substs);\n \n-        let item_predicates = self.tcx().item_predicates(def_id);\n-        let bounds = item_predicates.instantiate(self.tcx(), substs);\n+        let predicates_of = self.tcx().predicates_of(def_id);\n+        let bounds = predicates_of.instantiate(self.tcx(), substs);\n         debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 bounds={:?}\",\n                bounds);\n@@ -1432,7 +1432,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n-        let def = self.tcx().lookup_trait_def(obligation.predicate.def_id());\n+        let def = self.tcx().trait_def(obligation.predicate.def_id());\n \n         def.for_each_relevant_impl(\n             self.tcx(),\n@@ -1947,7 +1947,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question.\n-                vec![self.tcx().item_type(def_id).subst(self.tcx(), substs)]\n+                vec![self.tcx().type_of(def_id).subst(self.tcx(), substs)]\n             }\n         }\n     }\n@@ -2526,7 +2526,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n-                    .map(|f| tcx.item_type(f.did))\n+                    .map(|f| tcx.type_of(f.did))\n                     .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n@@ -2844,7 +2844,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.item_predicates(def_id);\n+        let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.predicates.iter().flat_map(|predicate| {\n             let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,"}, {"sha": "6c685851e2593dc31c48ec3d9ed98b2971119dc8", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -117,7 +117,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+    let trait_def = tcx.trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n@@ -175,7 +175,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // See RFC 1210 for more details and justification.\n \n     // Currently we do not allow e.g. a negative impl to specialize a positive one\n-    if tcx.trait_impl_polarity(impl1_def_id) != tcx.trait_impl_polarity(impl2_def_id) {\n+    if tcx.impl_polarity(impl1_def_id) != tcx.impl_polarity(impl2_def_id) {\n         return false;\n     }\n "}, {"sha": "396c7dbd1a874b293c6d6b703c2400a33a11e9d4", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -130,7 +130,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = tcx.item_super_predicates(data.def_id());\n+                let predicates = tcx.super_predicates_of(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n@@ -301,7 +301,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n             None => { return None; }\n         };\n \n-        let predicates = self.tcx.item_super_predicates(def_id);\n+        let predicates = self.tcx.super_predicates_of(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend(\n             predicates.predicates\n@@ -368,7 +368,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n         super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n \n-    let predicates = selcx.tcx().item_predicates(impl_def_id);\n+    let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         super::normalize(selcx, ObligationCause::dummy(), &predicates);"}, {"sha": "ac7a72e66655f8b8549fccff325f206ec6fce3aa", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1258,7 +1258,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n-        let adt_def = self.lookup_adt_def(def_id);\n+        let adt_def = self.adt_def(def_id);\n         let substs = self.mk_substs(iter::once(Kind::from(ty)));\n         self.mk_ty(TyAdt(adt_def, substs))\n     }"}, {"sha": "7dca28df9da39ca006602d68ec229c133002bf5b", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> InstanceDef<'tcx> {\n \n     #[inline]\n     pub fn def_ty<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.item_type(self.def_id())\n+        tcx.type_of(self.def_id())\n     }\n \n     #[inline]"}, {"sha": "9aa2caadd1d37911acc8924f3992f65147c0d3c6", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // for local crates, check whether type info is\n             // available; typeck might not have completed yet\n             self.maps.impl_trait_ref.borrow().contains_key(&impl_def_id) &&\n-                self.maps.ty.borrow().contains_key(&impl_def_id)\n+                self.maps.type_of.borrow().contains_key(&impl_def_id)\n         };\n \n         if !use_types {\n@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let self_ty = self.item_type(impl_def_id);\n+        let self_ty = self.type_of(impl_def_id);\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),"}, {"sha": "1407e57dc2a6a7e48f56b027aaa34ca24462dd8d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -21,6 +21,7 @@ use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -175,7 +176,7 @@ impl<M: DepTrackingMapConfig<Key=DefId>> QueryDescription for M {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::super_predicates<'tcx> {\n+impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"computing the supertraits of `{}`\",\n                 tcx.item_path_str(def_id))\n@@ -329,14 +330,6 @@ macro_rules! define_maps {\n                 Self::try_get_with(tcx, span, key, Clone::clone)\n             }\n \n-            $(#[$attr])*\n-            pub fn get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) -> $V {\n-                Self::try_get(tcx, span, key).unwrap_or_else(|e| {\n-                    tcx.report_cycle(e);\n-                    Value::from_cycle_error(tcx.global_tcx())\n-                })\n-            }\n-\n             pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n                 // FIXME(eddyb) Move away from using `DepTrackingMap`\n                 // so we don't have to explicitly ignore a false edge:\n@@ -351,6 +344,45 @@ macro_rules! define_maps {\n             }\n         })*\n \n+        #[derive(Copy, Clone)]\n+        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            pub span: Span,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n+            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+            fn deref(&self) -> &Self::Target {\n+                &self.tcx\n+            }\n+        }\n+\n+        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n+            /// Return a transparent wrapper for `TyCtxt` which uses\n+            /// `span` as the location of queries performed through it.\n+            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n+                TyCtxtAt {\n+                    tcx: self,\n+                    span\n+                }\n+            }\n+\n+            $($(#[$attr])*\n+            pub fn $name(self, key: $K) -> $V {\n+                self.at(DUMMY_SP).$name(key)\n+            })*\n+        }\n+\n+        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n+            $($(#[$attr])*\n+            pub fn $name(self, key: $K) -> $V {\n+                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|e| {\n+                    self.report_cycle(e);\n+                    Value::from_cycle_error(self.global_tcx())\n+                })\n+            })*\n+        }\n+\n         pub struct Providers<$tcx> {\n             $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $V),*\n         }\n@@ -380,20 +412,20 @@ macro_rules! define_maps {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    pub ty: ItemSignature(DefId) -> Ty<'tcx>,\n+    pub type_of: ItemSignature(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    pub generics: ItemSignature(DefId) -> &'tcx ty::Generics,\n-    pub predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    pub generics_of: ItemSignature(DefId) -> &'tcx ty::Generics,\n+    pub predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    pub super_predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    pub super_predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n@@ -411,7 +443,7 @@ define_maps! { <'tcx>\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    pub variances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    pub variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n@@ -455,7 +487,7 @@ define_maps! { <'tcx>\n \n     pub typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n-    pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    pub typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n     pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n "}, {"sha": "9a8c91f5820dcfac4377bcb540bce5eeebe138f7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 26, "deletions": 96, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -165,9 +165,9 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n-            self_ty: tcx.item_type(impl_def_id),\n+            self_ty: tcx.type_of(impl_def_id),\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.item_predicates(impl_def_id).predicates\n+            predicates: tcx.predicates_of(impl_def_id).predicates\n         }.subst(tcx, impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n@@ -727,7 +727,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n                         instantiated: &mut InstantiatedPredicates<'tcx>,\n                         substs: &Substs<'tcx>) {\n         if let Some(def_id) = self.parent {\n-            tcx.item_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n+            tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n@@ -1633,7 +1633,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n-        tcx.item_predicates(self.did)\n+        tcx.predicates_of(self.did)\n     }\n \n     /// Returns an iterator over all fields contained\n@@ -1686,7 +1686,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::empty();\n-                match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n+                match tcx.const_eval((expr_did, substs)) {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n@@ -1725,7 +1725,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n                 ty::VariantDiscr::Explicit(expr_did) => {\n                     let substs = Substs::empty();\n-                    match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n+                    match tcx.const_eval((expr_did, substs)) {\n                         Ok(ConstVal::Integral(v)) => {\n                             explicit_value = v;\n                             break;\n@@ -1760,7 +1760,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {\n-        queries::adt_destructor::get(tcx, DUMMY_SP, self.did)\n+        tcx.adt_destructor(self.did)\n     }\n \n     /// Returns a list of types such that `Self: Sized` if and only\n@@ -1840,7 +1840,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     def_id: sized_trait,\n                     substs: tcx.mk_substs_trait(ty, &[])\n                 }).to_predicate();\n-                let predicates = tcx.item_predicates(self.did).predicates;\n+                let predicates = tcx.predicates_of(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n                     vec![]\n                 } else {\n@@ -1881,7 +1881,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n-        tcx.item_type(self.did).subst(tcx, subst)\n+        tcx.type_of(self.did).subst(tcx, subst)\n     }\n }\n \n@@ -2042,11 +2042,7 @@ impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n-        self.item_tables(self.hir.body_owner_def_id(body))\n-    }\n-\n-    pub fn item_tables(self, def_id: DefId) -> &'gcx TypeckTables<'gcx> {\n-        queries::typeck_tables::get(self, DUMMY_SP, def_id)\n+        self.typeck_tables_of(self.hir.body_owner_def_id(body))\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2136,24 +2132,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             .collect()\n     }\n \n-    pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n-        queries::impl_polarity::get(self, DUMMY_SP, id)\n-    }\n-\n     pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n         self.associated_items(did).any(|item| {\n             item.relevant_for_never()\n         })\n     }\n \n-    pub fn coerce_unsized_info(self, did: DefId) -> adjustment::CoerceUnsizedInfo {\n-        queries::coerce_unsized_info::get(self, DUMMY_SP, did)\n-    }\n-\n-    pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n-        queries::associated_item::get(self, DUMMY_SP, def_id)\n-    }\n-\n     fn associated_item_from_trait_item_ref(self,\n                                            parent_def_id: DefId,\n                                            parent_vis: &hir::Visibility,\n@@ -2205,23 +2189,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n-        queries::associated_item_def_ids::get(self, DUMMY_SP, def_id)\n-    }\n-\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n     pub fn associated_items(self, def_id: DefId)\n                             -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n         let def_ids = self.associated_item_def_ids(def_id);\n         (0..def_ids.len()).map(move |i| self.associated_item(def_ids[i]))\n     }\n \n-    /// Returns the trait-ref corresponding to a given impl, or None if it is\n-    /// an inherent impl.\n-    pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n-        queries::impl_trait_ref::get(self, DUMMY_SP, id)\n-    }\n-\n     /// Returns true if the impls are the same polarity and are implementing\n     /// a trait which contains no items\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n@@ -2236,7 +2210,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             .map_or(false, |trait_ref| {\n                 self.associated_item_def_ids(trait_ref.def_id).is_empty()\n             });\n-        self.trait_impl_polarity(def_id1) == self.trait_impl_polarity(def_id2)\n+        self.impl_polarity(def_id1) == self.impl_polarity(def_id2)\n             && trait1_is_empty\n             && trait2_is_empty\n     }\n@@ -2247,14 +2221,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match def {\n             Def::Variant(did) | Def::VariantCtor(did, ..) => {\n                 let enum_did = self.parent_def_id(did).unwrap();\n-                self.lookup_adt_def(enum_did).variant_with_id(did)\n+                self.adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n-                self.lookup_adt_def(did).struct_variant()\n+                self.adt_def(did).struct_variant()\n             }\n             Def::StructCtor(ctor_did, ..) => {\n                 let did = self.parent_def_id(ctor_did).expect(\"struct ctor has no parent\");\n-                self.lookup_adt_def(did).struct_variant()\n+                self.adt_def(did).struct_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n         }\n@@ -2323,40 +2297,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // If the given item is in an external crate, looks up its type and adds it to\n-    // the type cache. Returns the type parameters and type.\n-    pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n-        queries::ty::get(self, DUMMY_SP, did)\n-    }\n-\n-    /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n-        queries::trait_def::get(self, DUMMY_SP, did)\n-    }\n-\n-    /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n-        queries::adt_def::get(self, DUMMY_SP, did)\n-    }\n-\n-    /// Given the did of an item, returns its generics.\n-    pub fn item_generics(self, did: DefId) -> &'gcx Generics {\n-        queries::generics::get(self, DUMMY_SP, did)\n-    }\n-\n-    /// Given the did of an item, returns its full set of predicates.\n-    pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        queries::predicates::get(self, DUMMY_SP, did)\n-    }\n-\n-    /// Given the did of a trait, returns its superpredicates.\n-    pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        queries::super_predicates::get(self, DUMMY_SP, did)\n-    }\n-\n     /// Given the did of an item, returns its MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        queries::mir::get(self, DUMMY_SP, did).borrow()\n+        self.mir(did).borrow()\n     }\n \n     /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n@@ -2365,7 +2308,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         match instance {\n             ty::InstanceDef::Item(did) if true => self.item_mir(did),\n-            _ => queries::mir_shims::get(self, DUMMY_SP, instance).borrow(),\n+            _ => self.mir_shims(instance).borrow(),\n         }\n     }\n \n@@ -2397,12 +2340,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.get_attrs(did).iter().any(|item| item.check_name(attr))\n     }\n \n-    pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n-        queries::variances::get(self, DUMMY_SP, item_id)\n-    }\n-\n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n-        let def = self.lookup_trait_def(trait_def_id);\n+        let def = self.trait_def(trait_def_id);\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n@@ -2417,7 +2356,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // metadata and don't need to track edges.\n         let _ignore = self.dep_graph.in_ignore();\n \n-        let def = self.lookup_trait_def(trait_id);\n+        let def = self.trait_def(trait_id);\n         if def.flags.get().intersects(TraitFlags::HAS_REMOTE_IMPLS) {\n             return;\n         }\n@@ -2435,14 +2374,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::HAS_REMOTE_IMPLS);\n     }\n \n-    pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        queries::closure_kind::get(self, DUMMY_SP, def_id)\n-    }\n-\n-    pub fn closure_type(self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        queries::closure_type::get(self, DUMMY_SP, def_id)\n-    }\n-\n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n@@ -2551,7 +2482,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let tcx = self.global_tcx();\n-        let generic_predicates = tcx.item_predicates(def_id);\n+        let generic_predicates = tcx.predicates_of(def_id);\n         let bounds = generic_predicates.instantiate(tcx, free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates;\n@@ -2675,12 +2606,12 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)\n                                   -> &'tcx [Ty<'tcx>] {\n-    let def = tcx.lookup_adt_def(def_id);\n+    let def = tcx.adt_def(def_id);\n \n     let result = tcx.intern_type_list(&def.variants.iter().flat_map(|v| {\n         v.fields.last()\n     }).flat_map(|f| {\n-        def.sized_constraint_for_ty(tcx, tcx.item_type(f.did))\n+        def.sized_constraint_for_ty(tcx, tcx.type_of(f.did))\n     }).collect::<Vec<_>>());\n \n     debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n@@ -2692,23 +2623,23 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn adt_dtorck_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    def_id: DefId)\n                                    -> DtorckConstraint<'tcx> {\n-    let def = tcx.lookup_adt_def(def_id);\n+    let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     debug!(\"dtorck_constraint: {:?}\", def);\n \n     if def.is_phantom_data() {\n         let result = DtorckConstraint {\n             outlives: vec![],\n             dtorck_types: vec![\n-                tcx.mk_param_from_def(&tcx.item_generics(def_id).types[0])\n+                tcx.mk_param_from_def(&tcx.generics_of(def_id).types[0])\n            ]\n         };\n         debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n         return result;\n     }\n \n     let mut result = def.all_fields()\n-        .map(|field| tcx.item_type(field.did))\n+        .map(|field| tcx.type_of(field.did))\n         .map(|fty| tcx.dtorck_constraint_for_ty(span, fty, 0, fty))\n         .collect::<Result<DtorckConstraint, ErrorReported>>()\n         .unwrap_or(DtorckConstraint::empty());\n@@ -2765,9 +2696,8 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n /// A map for the local crate mapping each type to a vector of its\n /// inherent impls. This is not meant to be used outside of coherence;\n /// rather, you should request the vector for a specific type via\n-/// `ty::queries::inherent_impls::get(def_id)` so as to minimize your\n-/// dependencies (constructing this map requires touching the entire\n-/// crate).\n+/// `tcx.inherent_impls(def_id)` so as to minimize your dependencies\n+/// (constructing this map requires touching the entire crate).\n #[derive(Clone, Debug)]\n pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,"}, {"sha": "58ebc843da10615211217930b2ea927f79b3cfe3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -126,7 +126,7 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n     let variances;\n     let opt_variances = if relation.tcx().variance_computed.get() {\n-        variances = relation.tcx().item_variances(item_def_id);\n+        variances = relation.tcx().variances_of(item_def_id);\n         Some(&*variances)\n     } else {\n         None"}, {"sha": "7857d07ed0910de41aae5a39d10557eff16664c9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n     pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'acx>) ->\n         impl Iterator<Item=Ty<'tcx>> + 'tcx\n     {\n-        let generics = tcx.item_generics(def_id);\n+        let generics = tcx.generics_of(def_id);\n         self.substs[self.substs.len()-generics.own_count()..].iter().map(\n             |t| t.as_type().expect(\"unexpected region in upvars\"))\n     }\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n             (Projection(ref a), Projection(ref b)) => a.sort_key(tcx).cmp(&b.sort_key(tcx)),\n             (AutoTrait(ref a), AutoTrait(ref b)) =>\n-                tcx.lookup_trait_def(*a).def_path_hash.cmp(&tcx.lookup_trait_def(*b).def_path_hash),\n+                tcx.trait_def(*a).def_path_hash.cmp(&tcx.trait_def(*b).def_path_hash),\n             (Trait(_), _) => Ordering::Less,\n             (Projection(_), Trait(_)) => Ordering::Greater,\n             (Projection(_), _) => Ordering::Less,\n@@ -841,7 +841,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n         // We want something here that is stable across crate boundaries.\n         // The DefId isn't but the `deterministic_hash` of the corresponding\n         // DefPath is.\n-        let trait_def = tcx.lookup_trait_def(self.trait_ref.def_id);\n+        let trait_def = tcx.trait_def(self.trait_ref.def_id);\n         let def_path_hash = trait_def.def_path_hash;\n \n         // An `ast::Name` is also not stable (it's just an index into an"}, {"sha": "961140d5eac6069e4aa5a4000dafe8f579696654", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n-        let defs = tcx.item_generics(def_id);\n+        let defs = tcx.generics_of(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n         Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n         tcx.intern_substs(&substs)\n@@ -200,7 +200,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx>\n     {\n-        let defs = tcx.item_generics(def_id);\n+        let defs = tcx.generics_of(def_id);\n         let mut result = Vec::with_capacity(defs.count());\n         result.extend(self[..].iter().cloned());\n         Substs::fill_single(&mut result, defs, &mut mk_region, &mut mk_type);\n@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n-            let parent_defs = tcx.item_generics(def_id);\n+            let parent_defs = tcx.generics_of(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n         Substs::fill_single(substs, defs, mk_region, mk_type)\n@@ -297,7 +297,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        source_ancestor: DefId,\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n-        let defs = tcx.item_generics(source_ancestor);\n+        let defs = tcx.generics_of(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n \n@@ -553,7 +553,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        trait_id: DefId,\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n-        let defs = tcx.item_generics(trait_id);\n+        let defs = tcx.generics_of(trait_id);\n \n         ty::TraitRef {\n             def_id: trait_id,"}, {"sha": "87921c80502e09a48f6d21d0cea212392d30b5ff", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -369,11 +369,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         };\n \n-        ty::queries::coherent_trait::get(self, DUMMY_SP, (LOCAL_CRATE, drop_trait));\n+        self.coherent_trait((LOCAL_CRATE, drop_trait));\n \n         let mut dtor_did = None;\n-        let ty = self.item_type(adt_did);\n-        self.lookup_trait_def(drop_trait).for_each_relevant_impl(self, ty, |impl_did| {\n+        let ty = self.type_of(adt_did);\n+        self.trait_def(drop_trait).for_each_relevant_impl(self, ty, |impl_did| {\n             if let Some(item) = self.associated_items(impl_did).next() {\n                 if let Ok(()) = validate(self, impl_did) {\n                     dtor_did = Some(item.def_id);\n@@ -422,7 +422,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let impl_def_id = self.associated_item(dtor).container.id();\n-        let impl_generics = self.item_generics(impl_def_id);\n+        let impl_generics = self.generics_of(impl_def_id);\n \n         // We have a destructor - all the parameters that are not\n         // pure_wrt_drop (i.e, don't have a #[may_dangle] attribute)\n@@ -445,12 +445,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // <P1, P2, P0>, and then look up which of the impl substs refer to\n         // parameters marked as pure.\n \n-        let impl_substs = match self.item_type(impl_def_id).sty {\n+        let impl_substs = match self.type_of(impl_def_id).sty {\n             ty::TyAdt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n \n-        let item_substs = match self.item_type(def.did).sty {\n+        let item_substs = match self.type_of(def.did).sty {\n             ty::TyAdt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n@@ -522,7 +522,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::TyAdt(def, substs) => {\n                 let ty::DtorckConstraint {\n                     dtorck_types, outlives\n-                } = ty::queries::adt_dtorck_constraint::get(self, span, def.did);\n+                } = self.at(span).adt_dtorck_constraint(def.did);\n                 Ok(ty::DtorckConstraint {\n                     // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n                     // there, but that needs some way to handle cycles."}, {"sha": "6c7073de70bbdba0b36a7e49e1830544fc2bab3d", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -443,7 +443,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                            -> Vec<traits::PredicateObligation<'tcx>>\n     {\n         let predicates =\n-            self.infcx.tcx.item_predicates(def_id)\n+            self.infcx.tcx.predicates_of(def_id)\n                           .instantiate(self.infcx.tcx, substs);\n         let cause = self.cause(traits::ItemObligation(def_id));\n         predicates.predicates"}, {"sha": "df5a2731c8900427c082f6ebe57f822dabf10ab4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -104,7 +104,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n                 }\n             }\n         }\n-        let mut generics = tcx.item_generics(item_def_id);\n+        let mut generics = tcx.generics_of(item_def_id);\n         let mut path_def_id = did;\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n@@ -114,7 +114,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             // Methods.\n             assert!(is_value_path);\n             child_types = generics.types.len();\n-            generics = tcx.item_generics(def_id);\n+            generics = tcx.generics_of(def_id);\n             num_regions = generics.regions.len();\n             num_types = generics.types.len();\n \n@@ -144,7 +144,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n                         if !def.has_default {\n                             break;\n                         }\n-                        if tcx.item_type(def.def_id).subst(tcx, substs) != actual {\n+                        if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n                             break;\n                         }\n                         num_supplied_defaults += 1;\n@@ -772,11 +772,11 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 ty::tls::with(|tcx| {\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let item_predicates = tcx.item_predicates(def_id);\n+                    let predicates_of = tcx.predicates_of(def_id);\n                     let substs = tcx.lift(&substs).unwrap_or_else(|| {\n                         tcx.intern_substs(&[])\n                     });\n-                    let bounds = item_predicates.instantiate(tcx, substs);\n+                    let bounds = predicates_of.instantiate(tcx, substs);\n \n                     let mut first = true;\n                     let mut is_sized = false;"}, {"sha": "401c878cd4010446e0233a2a8faafe976bfa57dd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -42,7 +42,7 @@ use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n-use syntax_pos::{DUMMY_SP, MultiSpan, Span};\n+use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n@@ -63,7 +63,7 @@ pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n-        ty::queries::borrowck::get(tcx, DUMMY_SP, body_owner_def_id);\n+        tcx.borrowck(body_owner_def_id);\n     });\n }\n \n@@ -87,7 +87,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let attributes = tcx.get_attrs(owner_def_id);\n-    let tables = tcx.item_tables(owner_def_id);\n+    let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut bccx = &mut BorrowckCtxt {\n         tcx: tcx,\n@@ -169,7 +169,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n {\n     let owner_id = tcx.hir.body_owner(body_id);\n     let owner_def_id = tcx.hir.local_def_id(owner_id);\n-    let tables = tcx.item_tables(owner_def_id);\n+    let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,"}, {"sha": "9470316c7e7e018799cc5677c4fed84f05842828", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -27,7 +27,7 @@ use rustc::util::nodemap::DefIdMap;\n \n use syntax::ast;\n use rustc::hir::{self, Expr};\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::cmp::Ordering;\n \n@@ -299,7 +299,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           match cx.tables.qpath_def(qpath, e.id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                    match ty::queries::const_eval::get(tcx, e.span, (def_id, substs)) {\n+                    match tcx.at(e.span).const_eval((def_id, substs)) {\n                         Ok(val) => val,\n                         Err(ConstEvalErr { kind: TypeckError, .. }) => {\n                             signal!(e, TypeckError);\n@@ -376,7 +376,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           let callee_cx = ConstContext {\n             tcx: tcx,\n-            tables: tcx.item_tables(def_id),\n+            tables: tcx.typeck_tables_of(def_id),\n             substs: substs,\n             fn_args: Some(call_args)\n           };\n@@ -607,7 +607,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Float(f) => cast_const_float(tcx, f, ty),\n         Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n         Variant(v) => {\n-            let adt = tcx.lookup_adt_def(tcx.parent_def_id(v).unwrap());\n+            let adt = tcx.adt_def(tcx.parent_def_id(v).unwrap());\n             let idx = adt.variant_index_with_id(v);\n             cast_const_int(tcx, adt.discriminant_for_variant(tcx, idx), ty)\n         }\n@@ -767,13 +767,13 @@ fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let cx = ConstContext {\n         tcx,\n-        tables: tcx.item_tables(def_id),\n+        tables: tcx.typeck_tables_of(def_id),\n         substs: substs,\n         fn_args: None\n     };\n \n     let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-        ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+        tcx.mir_const_qualif(def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n         tcx.sess.cstore.item_body(tcx, def_id)"}, {"sha": "aea40b85535488982d30dca2b4df7f24b4695960", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n-                let adt_def = self.tcx.lookup_adt_def(enum_id);\n+                let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     let substs = match ty.sty {\n                         TypeVariants::TyAdt(_, substs) => substs,\n@@ -591,7 +591,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     Some((def_id, _substs)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = tcx.item_tables(def_id);\n+                        self.tables = tcx.typeck_tables_of(def_id);\n                         let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n                             tcx.hir.body(tcx.hir.body_owned_by(id))\n                         } else {"}, {"sha": "c8644820ac0d0faf135f80019a61df2c6253e083", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n                 let def_id = cx.tcx.hir.local_def_id(it.id);\n-                self.check_heap_type(cx, it.span, cx.tcx.item_type(def_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n             }\n             _ => ()\n         }\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n                 for struct_field in struct_def.fields() {\n                     let def_id = cx.tcx.hir.local_def_id(struct_field.id);\n                     self.check_heap_type(cx, struct_field.span,\n-                                         cx.tcx.item_type(def_id));\n+                                         cx.tcx.type_of(def_id));\n                 }\n             }\n             _ => (),\n@@ -504,21 +504,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(cx.tcx.hir.local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemUnion(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(cx.tcx.hir.local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(cx.tcx.hir.local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -582,10 +582,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let debug_def = cx.tcx.lookup_trait_def(debug);\n+            let debug_def = cx.tcx.trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if let Some(ty_def) = cx.tcx.item_type(d).ty_to_def_id() {\n+                if let Some(ty_def) = cx.tcx.type_of(d).ty_to_def_id() {\n                     if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def) {\n                         impls.insert(node_id);\n                     }\n@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         }\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n-            match cx.tcx.item_type(def_id).sty {\n+            match cx.tcx.type_of(def_id).sty {\n                 ty::TyFnDef(.., bfty) if bfty.abi() == RustIntrinsic => (),\n                 _ => return false,\n             }\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.item_type(ctx.tcx.hir.local_def_id(field.id));\n+                let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n                 if field_ty.needs_drop(ctx.tcx, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,"}, {"sha": "c2181c9764c6cdfe97ab27138216502ef3fbb543", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -660,7 +660,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n         let def_id = self.cx.tcx.hir.local_def_id(id);\n-        let sig = self.cx.tcx.item_type(def_id).fn_sig();\n+        let sig = self.cx.tcx.type_of(def_id).fn_sig();\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n@@ -677,7 +677,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n     fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n         let def_id = self.cx.tcx.hir.local_def_id(id);\n-        let ty = self.cx.tcx.item_type(def_id);\n+        let ty = self.cx.tcx.type_of(def_id);\n         self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n }\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.item_type(cx.tcx.hir.local_def_id(it.id));\n+                let t = cx.tcx.type_of(cx.tcx.hir.local_def_id(it.id));\n                 let layout = cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx).unwrap_or_else(|e| {"}, {"sha": "f310279ea3c3a5cbed159dd5bf7304bb0a677fc2", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -69,10 +69,10 @@ macro_rules! provide {\n }\n \n provide! { <'tcx> tcx, def_id, cdata\n-    ty => { cdata.get_type(def_id.index, tcx) }\n-    generics => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n-    predicates => { cdata.get_predicates(def_id.index, tcx) }\n-    super_predicates => { cdata.get_super_predicates(def_id.index, tcx) }\n+    type_of => { cdata.get_type(def_id.index, tcx) }\n+    generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n+    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n         tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n     }\n@@ -81,7 +81,7 @@ provide! { <'tcx> tcx, def_id, cdata\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n     }\n-    variances => { Rc::new(cdata.get_item_variances(def_id.index)) }\n+    variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n         let mut result = vec![];\n         cdata.each_child_of_item(def_id.index, |child| result.push(child.def.def_id()));\n@@ -108,7 +108,7 @@ provide! { <'tcx> tcx, def_id, cdata\n         mir\n     }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n-    typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n+    typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }"}, {"sha": "1656d489269d0fe9cfc364d584f0d20c1df5939a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n         let def_id = DefId::decode(self)?;\n-        Ok(self.tcx().lookup_adt_def(def_id))\n+        Ok(self.tcx().adt_def(def_id))\n     }\n }\n "}, {"sha": "783e7604cdaf1b424e0effa9d38b4f0a94ece427", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -36,7 +36,7 @@ use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n-use syntax_pos::{self, DUMMY_SP};\n+use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -242,12 +242,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         debug!(\"EntryBuilder::encode_item_variances({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq_from_slice(&tcx.item_variances(def_id))\n+        self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n-        let ty = tcx.item_type(def_id);\n+        let ty = tcx.type_of(def_id);\n         debug!(\"EntryBuilder::encode_item_type({:?}) => {:?}\", def_id, ty);\n         self.lazy(&ty)\n     }\n@@ -261,7 +261,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                                 (enum_did, Untracked(index)): (DefId, Untracked<usize>))\n                                 -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let def = tcx.lookup_adt_def(enum_did);\n+        let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.did;\n         debug!(\"EntryBuilder::encode_enum_variant_info({:?})\", def_id);\n@@ -341,7 +341,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n-        let def = self.tcx.lookup_adt_def(adt_def_id);\n+        let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n@@ -365,7 +365,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                                                                                        usize)>))\n                     -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let variant = &tcx.lookup_adt_def(adt_def_id).variants[variant_index];\n+        let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n@@ -397,7 +397,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n         debug!(\"EntryBuilder::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n-        let variant = tcx.lookup_adt_def(adt_def_id).struct_variant();\n+        let variant = tcx.adt_def(adt_def_id).struct_variant();\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -439,13 +439,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n         debug!(\"EntryBuilder::encode_generics({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(tcx.item_generics(def_id))\n+        self.lazy(tcx.generics_of(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n         debug!(\"EntryBuilder::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.item_predicates(def_id))\n+        self.lazy(&tcx.predicates_of(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -547,7 +547,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let kind = match impl_item.kind {\n             ty::AssociatedKind::Const => {\n                 EntryKind::AssociatedConst(container,\n-                    ty::queries::mir_const_qualif::get(self.tcx, ast_item.span, def_id))\n+                    self.tcx.at(ast_item.span).mir_const_qualif(def_id))\n             }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n@@ -570,7 +570,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let (ast, mir) = if let hir::ImplItemKind::Const(_, body) = ast_item.node {\n             (Some(body), true)\n         } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n-            let generics = self.tcx.item_generics(def_id);\n+            let generics = self.tcx.generics_of(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n             let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n             let is_const_fn = sig.constness == hir::Constness::Const;\n@@ -656,7 +656,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemConst(..) => {\n-                EntryKind::Const(ty::queries::mir_const_qualif::get(tcx, item.span, def_id))\n+                EntryKind::Const(tcx.at(item.span).mir_const_qualif(def_id))\n             }\n             hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n@@ -674,7 +674,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             hir::ItemTy(..) => EntryKind::Type,\n             hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n-                let variant = tcx.lookup_adt_def(def_id).struct_variant();\n+                let variant = tcx.adt_def(def_id).struct_variant();\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n@@ -694,7 +694,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 }), repr_options)\n             }\n             hir::ItemUnion(..) => {\n-                let variant = tcx.lookup_adt_def(def_id).struct_variant();\n+                let variant = tcx.adt_def(def_id).struct_variant();\n                 let repr_options = get_repr_options(&tcx, def_id);\n \n                 EntryKind::Union(self.lazy(&VariantData {\n@@ -716,7 +716,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             hir::ItemImpl(_, polarity, ..) => {\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n-                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+                    let trait_def = tcx.trait_def(trait_ref.def_id);\n                     trait_def.ancestors(def_id).skip(1).next().and_then(|node| {\n                         match node {\n                             specialization_graph::Node::Impl(parent) => Some(parent),\n@@ -732,7 +732,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 let coerce_unsized_info =\n                     trait_ref.and_then(|t| {\n                         if Some(t.def_id) == tcx.lang_items.coerce_unsized_trait() {\n-                            Some(ty::queries::coerce_unsized_info::get(tcx, item.span, def_id))\n+                            Some(tcx.at(item.span).coerce_unsized_info(def_id))\n                         } else {\n                             None\n                         }\n@@ -748,12 +748,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 EntryKind::Impl(self.lazy(&data))\n             }\n             hir::ItemTrait(..) => {\n-                let trait_def = tcx.lookup_trait_def(def_id);\n+                let trait_def = tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n-                    super_predicates: self.lazy(&tcx.item_super_predicates(def_id)),\n+                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(&data))\n@@ -774,15 +774,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                         .map(|foreign_item| tcx.hir.local_def_id(foreign_item.id).index))\n                 }\n                 hir::ItemEnum(..) => {\n-                    let def = self.tcx.lookup_adt_def(def_id);\n+                    let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.variants.iter().map(|v| {\n                         assert!(v.did.is_local());\n                         v.did.index\n                     }))\n                 }\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) => {\n-                    let def = self.tcx.lookup_adt_def(def_id);\n+                    let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.struct_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n@@ -919,7 +919,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemEnum(..) => {\n                 self.encode_fields(def_id);\n \n-                let def = self.tcx.lookup_adt_def(def_id);\n+                let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter().enumerate() {\n                     self.record(variant.did,\n                                 EntryBuilder::encode_enum_variant_info,\n@@ -1169,7 +1169,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let body = tcx.hir.body_owned_by(id);\n \n         Entry {\n-            kind: EntryKind::Const(ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id)),\n+            kind: EntryKind::Const(tcx.mir_const_qualif(def_id)),\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n@@ -1539,7 +1539,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n-    let ty = tcx.item_type(did);\n+    let ty = tcx.type_of(did);\n     match ty.sty {\n         ty::TyAdt(ref def, _) => return def.repr,\n         _ => bug!(\"{} is not an ADT\", ty),"}, {"sha": "95b20560c62a1f475a9599cbc941d1489128ecfb", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -784,7 +784,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,\n-            ty: tcx.item_type(free_func).subst(tcx, substs),\n+            ty: tcx.type_of(free_func).subst(tcx, substs),\n             literal: Literal::Value {\n                 value: ConstVal::Function(free_func, substs),\n             }"}, {"sha": "7b267fa276b1873598cdd609c8496b6d9da5ea14", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -594,7 +594,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let c = &cx.tcx.hir.body(count).value;\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::empty();\n-            let count = match ty::queries::const_eval::get(cx.tcx, c.span, (def_id, substs)) {\n+            let count = match cx.tcx.at(c.span).const_eval((def_id, substs)) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")"}, {"sha": "e73eaafc4b9fe4d3c6e3d6de15c8da6d8b35e5c5", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n-                let method_ty = self.tcx.item_type(item.def_id);\n+                let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,\n                         Literal::Value {"}, {"sha": "77f5c8ff124dff119d1346281d8a52fa6fa8c408", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -139,7 +139,7 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             // types/lifetimes replaced)\n             let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n \n-            let ty = tcx.item_type(tcx.hir.local_def_id(id));\n+            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n             let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n                 // HACK(eddyb) Avoid having RustCall on closures,"}, {"sha": "9e57472c23657ca86f2e201acd4a5aedef825e29", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -167,7 +167,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         param_env.free_substs\n     };\n-    let fn_ty = tcx.item_type(def_id).subst(tcx, substs);\n+    let fn_ty = tcx.type_of(def_id).subst(tcx, substs);\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n     let span = tcx.def_span(def_id);\n \n@@ -290,7 +290,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let fn_ty = tcx.item_type(def_id).subst(tcx, param_env.free_substs);\n+    let fn_ty = tcx.type_of(def_id).subst(tcx, param_env.free_substs);\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n     let span = tcx.def_span(def_id);\n \n@@ -332,7 +332,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         CallKind::Direct(def_id) => (\n             Operand::Constant(Constant {\n                 span: span,\n-                ty: tcx.item_type(def_id).subst(tcx, param_env.free_substs),\n+                ty: tcx.type_of(def_id).subst(tcx, param_env.free_substs),\n                 literal: Literal::Value {\n                     value: ConstVal::Function(def_id, param_env.free_substs),\n                 },\n@@ -422,7 +422,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = match tcx.item_type(def_id).sty {\n+    let sig = match tcx.type_of(def_id).sty {\n         ty::TyFnDef(_, _, fty) => tcx.no_late_bound_regions(&fty)\n             .expect(\"LBR in ADT constructor signature\"),\n         _ => bug!(\"unexpected type for ctor {:?}\", def_id)"}, {"sha": "afb775aa01e70a73c35726397186446ba8bc7a71", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 let mut span = None;\n \n                 self.tcx\n-                    .lookup_trait_def(drop_trait_id)\n+                    .trait_def(drop_trait_id)\n                     .for_each_relevant_impl(self.tcx, self.mir.return_ty, |impl_did| {\n                         self.tcx.hir\n                             .as_local_node_id(impl_did)\n@@ -573,9 +573,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if substs.types().next().is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n-                        let bits = ty::queries::mir_const_qualif::get(self.tcx,\n-                                                                      constant.span,\n-                                                                      def_id);\n+                        let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n                         self.add(qualif);\n@@ -959,7 +957,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n             let src = MirSource::from_node(tcx, id);\n \n             if let MirSource::Const(_) = src {\n-                ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+                tcx.mir_const_qualif(def_id);\n                 continue;\n             }\n "}, {"sha": "d2e4c1a9649838f3fd1cb5b2d948fff1fedb49a1", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n             Lvalue::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(lvalue, sty);\n-                let ty = self.tcx().item_type(def_id);\n+                let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(&ty);\n                 if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty) {\n                     span_mirbug!("}, {"sha": "f275b4cafaf93760763533795312a7af824d0a30", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         };\n \n         let outer_tables = self.tables;\n-        self.tables = self.tcx.item_tables(self.tcx.hir.local_def_id(item_id));\n+        self.tables = self.tcx.typeck_tables_of(self.tcx.hir.local_def_id(item_id));\n \n         let body = self.tcx.hir.body(body_id);\n         if !self.in_fn {"}, {"sha": "82c91727293eddec09cc30f3b8ba3605f69b46ec", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -37,7 +37,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::NodeSet;\n use syntax::ast;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n use std::cmp;\n use std::mem::replace;\n@@ -87,7 +87,7 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n-        let ty_def_id = match self.tcx.item_type(item_def_id).sty {\n+        let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n             ty::TyAdt(adt, _) => adt.did,\n             ty::TyDynamic(ref obj, ..) if obj.principal().is_some() =>\n                 obj.principal().unwrap().def_id(),\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemConst(..) | hir::ItemStatic(..) |\n             hir::ItemFn(..) | hir::ItemTy(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates().item_type();\n+                    self.reach(item.id).generics().predicates().ty();\n                 }\n             }\n             hir::ItemTrait(.., ref trait_item_refs) => {\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                            !trait_item_ref.defaultness.has_value() {\n                             // No type to visit.\n                         } else {\n-                            reach.item_type();\n+                            reach.ty();\n                         }\n                     }\n                 }\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     for impl_item_ref in impl_item_refs {\n                         let id = impl_item_ref.id.node_id;\n                         if trait_ref.is_some() || self.get(id).is_some() {\n-                            self.reach(id).generics().predicates().item_type();\n+                            self.reach(id).generics().predicates().ty();\n                         }\n                     }\n                 }\n@@ -277,7 +277,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 for variant in &def.variants {\n                     if self.get(variant.node.data.id()).is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach(field.id).item_type();\n+                            self.reach(field.id).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if self.get(foreign_item.id).is_some() {\n-                        self.reach(foreign_item.id).generics().predicates().item_type();\n+                        self.reach(foreign_item.id).generics().predicates().ty();\n                     }\n                 }\n             }\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.reach(item.id).generics().predicates();\n                     for field in struct_def.fields() {\n                         if self.get(field.id).is_some() {\n-                            self.reach(field.id).item_type();\n+                            self.reach(field.id).ty();\n                         }\n                     }\n                 }\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         if let hir::TyImplTrait(..) = ty.node {\n             if self.get(ty.id).is_some() {\n                 // Reach the (potentially private) type and the API being exposed.\n-                self.reach(ty.id).item_type().predicates();\n+                self.reach(ty.id).ty().predicates();\n             }\n         }\n \n@@ -360,21 +360,21 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        for def in &self.ev.tcx.item_generics(self.item_def_id).types {\n+        for def in &self.ev.tcx.generics_of(self.item_def_id).types {\n             if def.has_default {\n-                self.ev.tcx.item_type(def.def_id).visit_with(self);\n+                self.ev.tcx.type_of(def.def_id).visit_with(self);\n             }\n         }\n         self\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        self.ev.tcx.item_predicates(self.item_def_id).visit_with(self);\n+        self.ev.tcx.predicates_of(self.item_def_id).visit_with(self);\n         self\n     }\n \n-    fn item_type(&mut self) -> &mut Self {\n-        self.ev.tcx.item_type(self.item_def_id).visit_with(self);\n+    fn ty(&mut self) -> &mut Self {\n+        self.ev.tcx.type_of(self.item_def_id).visit_with(self);\n         self\n     }\n \n@@ -868,21 +868,21 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        for def in &self.tcx.item_generics(self.item_def_id).types {\n+        for def in &self.tcx.generics_of(self.item_def_id).types {\n             if def.has_default {\n-                self.tcx.item_type(def.def_id).visit_with(self);\n+                self.tcx.type_of(def.def_id).visit_with(self);\n             }\n         }\n         self\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        self.tcx.item_predicates(self.item_def_id).visit_with(self);\n+        self.tcx.predicates_of(self.item_def_id).visit_with(self);\n         self\n     }\n \n-    fn item_type(&mut self) -> &mut Self {\n-        self.tcx.item_type(self.item_def_id).visit_with(self);\n+    fn ty(&mut self) -> &mut Self {\n+        self.tcx.type_of(self.item_def_id).visit_with(self);\n         self\n     }\n \n@@ -1048,7 +1048,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemTy(..) => {\n-                self.check(item.id, item_visibility).generics().predicates().item_type();\n+                self.check(item.id, item_visibility).generics().predicates().ty();\n \n                 // Recurse for e.g. `impl Trait` (see `visit_ty`).\n                 self.inner_visibility = item_visibility;\n@@ -1065,7 +1065,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                        !trait_item_ref.defaultness.has_value() {\n                         // No type to visit.\n                     } else {\n-                        check.item_type();\n+                        check.ty();\n                     }\n                 }\n             }\n@@ -1074,15 +1074,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n                 for variant in &def.variants {\n                     for field in variant.node.data.fields() {\n-                        self.check(field.id, item_visibility).item_type();\n+                        self.check(field.id, item_visibility).ty();\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n-                    self.check(foreign_item.id, vis).generics().predicates().item_type();\n+                    self.check(foreign_item.id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity\n@@ -1092,7 +1092,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n                 for field in struct_def.fields() {\n                     let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n-                    self.check(field.id, min(item_visibility, field_visibility)).item_type();\n+                    self.check(field.id, min(item_visibility, field_visibility)).ty();\n                 }\n             }\n             // The interface is empty\n@@ -1101,15 +1101,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of inherent impls have their own publicity\n             hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n                 let ty_vis =\n-                    self.check(item.id, ty::Visibility::Invisible).item_type().min_visibility;\n+                    self.check(item.id, ty::Visibility::Invisible).ty().min_visibility;\n                 self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n                         ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n                     self.check(impl_item.id, min(impl_item_vis, ty_vis))\n-                        .generics().predicates().item_type();\n+                        .generics().predicates().ty();\n \n                     // Recurse for e.g. `impl Trait` (see `visit_ty`).\n                     self.inner_visibility = impl_item_vis;\n@@ -1120,11 +1120,11 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n                 let vis = self.check(item.id, ty::Visibility::Invisible)\n-                              .item_type().impl_trait_ref().min_visibility;\n+                              .ty().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n-                    self.check(impl_item.id, vis).generics().predicates().item_type();\n+                    self.check(impl_item.id, vis).generics().predicates().ty();\n \n                     // Recurse for e.g. `impl Trait` (see `visit_ty`).\n                     self.inner_visibility = vis;\n@@ -1144,7 +1144,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // e.g. `impl Iterator<Item=T>` has two predicates,\n             // `X: Iterator` and `<X as Iterator>::Item == T`,\n             // where `X` is the `impl Iterator<Item=T>` itself,\n-            // stored in `item_predicates`, not in the `Ty` itself.\n+            // stored in `predicates_of`, not in the `Ty` itself.\n             self.check(ty.id, self.inner_visibility).predicates();\n         }\n \n@@ -1166,7 +1166,7 @@ pub fn provide(providers: &mut Providers) {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<AccessLevels> {\n     tcx.dep_graph.with_ignore(|| { // FIXME\n-        ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE)\n+        tcx.privacy_access_levels(LOCAL_CRATE)\n     })\n }\n "}, {"sha": "9e3e727d4bdcd0d2d9b68ac9851ce1fbfc0928bc", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -114,7 +114,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        match self.tcx.maps.typeck_tables.borrow().get(&item_def_id) {\n+        match self.tcx.maps.typeck_tables_of.borrow().get(&item_def_id) {\n             Some(tables) => {\n                 let old_tables = self.save_ctxt.tables;\n                 self.save_ctxt.tables = tables;"}, {"sha": "e2c399e85cd599284691c8da891a25d0ee214c79", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -341,7 +341,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n             filter!(self.span_utils, sub_span, field.span, None);\n             let def_id = self.tcx.hir.local_def_id(field.id);\n-            let typ = self.tcx.item_type(def_id).to_string();\n+            let typ = self.tcx.type_of(def_id).to_string();\n \n             let span = field.span;\n             let text = self.span_utils.snippet(field.span);"}, {"sha": "a96128fcf2f5305a06afb2105fd28baff96aba7b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -232,7 +232,7 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) |\n             DefPathData::ValueNs(_) => {\n-                instance_ty = tcx.item_type(ty_def_id);\n+                instance_ty = tcx.type_of(ty_def_id);\n                 break;\n             }\n             _ => {"}, {"sha": "e8cca7bc74f1a7d0050284ce24d21ca8760a5246", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1041,7 +1041,7 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.hir.local_def_id(id);\n-                let generics = tcx.item_generics(def_id);\n+                let generics = tcx.generics_of(def_id);\n                 let attributes = tcx.get_attrs(def_id);\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n                 // Functions marked with #[inline] are only ever translated"}, {"sha": "78e0a524ef2dc833b4912f9393833d78c1f9c0be", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -21,9 +21,8 @@ use declare;\n use llvm::{self, ValueRef};\n use monomorphize::{self, Instance};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use syntax_pos::DUMMY_SP;\n use trans_item::TransItem;\n use type_of;\n \n@@ -105,7 +104,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n         // fn foo(); }` are assumed not to unwind **unless** they have\n         // a `#[unwind]` attribute.\n-        if !ty::queries::is_foreign_item::get(tcx, DUMMY_SP, instance.def_id()) {\n+        if !tcx.is_foreign_item(instance.def_id()) {\n             attributes::unwind(llfn, true);\n             unsafe {\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);"}, {"sha": "93ec7e11606dfa1ac9112fbae714c51d0b6876eb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -935,14 +935,14 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if !tcx.item_generics(method.def_id).types.is_empty() {\n+                    if !tcx.generics_of(method.def_id).types.is_empty() {\n                         continue;\n                     }\n \n                     let instance =\n                         monomorphize::resolve(scx, method.def_id, callee_substs);\n \n-                    let predicates = tcx.item_predicates(instance.def_id()).predicates\n+                    let predicates = tcx.predicates_of(instance.def_id()).predicates\n                         .subst(tcx, instance.substs);\n                     if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;"}, {"sha": "025062f7ddef92e36e22a8a867ac1f5f6461b086", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -563,7 +563,7 @@ pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                         substs: &'tcx Substs<'tcx>)\n                         -> Ty<'tcx>\n {\n-    let ty = shared.tcx().item_type(def_id);\n+    let ty = shared.tcx().type_of(def_id);\n     shared.tcx().trans_apply_param_substs(substs, &ty)\n }\n "}, {"sha": "982ea5ffeb70bc3b487cbef32fe71486e415bdb4", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -237,7 +237,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().item_generics(fn_def_id);\n+    let generics = cx.tcx().generics_of(fn_def_id);\n     let substs = instance.substs.truncate_to(cx.tcx(), generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n@@ -382,7 +382,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_type_parameter_names(cx: &CrateContext, generics: &ty::Generics) -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx().item_generics(def_id))\n+            get_type_parameter_names(cx, cx.tcx().generics_of(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names"}, {"sha": "d8e139dc505b6129764db5f8990224352f5058f6", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -444,7 +444,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             },\n             ty::TyClosure(def_id, ref closure_substs) => {\n                 self.push_def_path(def_id, output);\n-                let generics = self.tcx.item_generics(self.tcx.closure_base_def_id(def_id));\n+                let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n                 let substs = closure_substs.substs.truncate_to(self.tcx, generics);\n                 self.push_type_params(substs, iter::empty(), output);\n             }"}, {"sha": "92f80a3607b6e728fed327bb8b9178dc80d5c8e4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -217,7 +217,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let decl_generics = tcx.item_generics(def_id);\n+        let decl_generics = tcx.generics_of(def_id);\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n@@ -238,7 +238,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let default_needs_object_self = |p: &ty::TypeParameterDef| {\n             if is_object && p.has_default {\n-                if ty::queries::ty::get(tcx, span, p.def_id).has_self_ty() {\n+                if tcx.at(span).type_of(p.def_id).has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n                     // that references self, in an object type.\n                     return true;\n@@ -307,7 +307,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     // This is a default type parameter.\n                     self.normalize_ty(\n                         span,\n-                        ty::queries::ty::get(tcx, span, def.def_id)\n+                        tcx.at(span).type_of(def.def_id)\n                             .subst_spanned(tcx, substs, Some(span))\n                     )\n                 }\n@@ -458,7 +458,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n+        let trait_def = self.tcx().trait_def(trait_def_id);\n \n         match trait_segment.parameters {\n             hir::AngleBracketedParameters(_) => {\n@@ -600,7 +600,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n         self.normalize_ty(\n             span,\n-            ty::queries::ty::get(self.tcx(), span, did).subst(self.tcx(), substs)\n+            self.tcx().at(span).type_of(did).subst(self.tcx(), substs)\n         )\n     }\n \n@@ -1014,7 +1014,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n                 let item_id = tcx.hir.get_parent_node(node_id);\n                 let item_def_id = tcx.hir.local_def_id(item_id);\n-                let generics = tcx.item_generics(item_def_id);\n+                let generics = tcx.generics_of(item_def_id);\n                 let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n                 tcx.mk_param(index, tcx.hir.name(node_id))\n             }\n@@ -1024,7 +1024,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_type_params(&path.segments);\n \n-                let ty = ty::queries::ty::get(tcx, span, def_id);\n+                let ty = tcx.at(span).type_of(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "a38840552c23c39de628e2470eeae59f7ad1202a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -180,10 +180,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n-    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n-    let impl_m_predicates = tcx.item_predicates(impl_m.def_id);\n-    let trait_m_predicates = tcx.item_predicates(trait_m.def_id);\n+    let impl_m_generics = tcx.generics_of(impl_m.def_id);\n+    let trait_m_generics = tcx.generics_of(trait_m.def_id);\n+    let impl_m_predicates = tcx.predicates_of(impl_m.def_id);\n+    let trait_m_predicates = tcx.predicates_of(trait_m.def_id);\n \n     // Check region bounds.\n     check_region_bounds_on_impl_method(tcx,\n@@ -199,7 +199,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n-    let impl_predicates = tcx.item_predicates(impl_m_predicates.parent.unwrap());\n+    let impl_predicates = tcx.predicates_of(impl_m_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n@@ -261,7 +261,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let tcx = infcx.tcx;\n \n         let m_sig = |method: &ty::AssociatedItem| {\n-            match tcx.item_type(method.def_id).sty {\n+            match tcx.type_of(method.def_id).sty {\n                 ty::TyFnDef(_, _, f) => f,\n                 _ => bug!()\n             }\n@@ -509,7 +509,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n-        let method_ty = tcx.item_type(method.def_id);\n+        let method_ty = tcx.type_of(method.def_id);\n         let self_arg_ty = *method_ty.fn_sig().input(0).skip_binder();\n         match ExplicitSelf::determine(untransformed_self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => \"self\".to_string(),\n@@ -567,8 +567,8 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         trait_m: &ty::AssociatedItem,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n-    let impl_m_generics = tcx.item_generics(impl_m.def_id);\n-    let trait_m_generics = tcx.item_generics(trait_m.def_id);\n+    let impl_m_generics = tcx.generics_of(impl_m.def_id);\n+    let trait_m_generics = tcx.generics_of(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.types.len();\n     let num_trait_m_type_params = trait_m_generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n@@ -637,7 +637,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n     let m_fty = |method: &ty::AssociatedItem| {\n-        match tcx.item_type(method.def_id).sty {\n+        match tcx.type_of(method.def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n             _ => bug!()\n         }\n@@ -750,8 +750,8 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = tcx.item_type(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n-        let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.type_of(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n+        let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n         // There is no \"body\" here, so just pass dummy id."}, {"sha": "d92dafe6904590e57f5ae09bc3861df60fe9a1be", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                match self.tcx.item_type(def_id).sty {\n+                match self.tcx.type_of(def_id).sty {\n                     ty::TypeVariants::TyFnDef(_, _, sig) => {\n                         sig.inputs().skip_binder().len() == 1\n                     }"}, {"sha": "8d26f007429750188a8cc6a7c21930b861d4e8ad", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -42,8 +42,8 @@ use syntax_pos::Span;\n pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  drop_impl_did: DefId)\n                                  -> Result<(), ErrorReported> {\n-    let dtor_self_type = tcx.item_type(drop_impl_did);\n-    let dtor_predicates = tcx.item_predicates(drop_impl_did);\n+    let dtor_self_type = tcx.type_of(drop_impl_did);\n+    let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyAdt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(tcx,\n@@ -85,7 +85,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-        let named_type = tcx.item_type(self_type_did);\n+        let named_type = tcx.type_of(self_type_did);\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n@@ -175,7 +175,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n-    let generic_assumptions = tcx.item_predicates(self_type_did);\n+    let generic_assumptions = tcx.predicates_of(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;"}, {"sha": "2a97bc1d98fe95e83326d218096dbe4bd3fdc36b", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -46,7 +46,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::Unsafety::Unsafe,\n         abi\n     )));\n-    let i_n_tps = tcx.item_generics(def_id).types.len();\n+    let i_n_tps = tcx.generics_of(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, _, ref generics) => generics.span,\n@@ -64,7 +64,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            &ObligationCause::new(it.span,\n                                                  it.id,\n                                                  ObligationCauseCode::IntrinsicType),\n-                           tcx.item_type(def_id),\n+                           tcx.type_of(def_id),\n                            fty);\n     }\n }\n@@ -324,7 +324,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let def_id = tcx.hir.local_def_id(it.id);\n-    let i_n_tps = tcx.item_generics(def_id).types.len();\n+    let i_n_tps = tcx.generics_of(def_id).types.len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n@@ -367,7 +367,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     let mut structural_to_nomimal = FxHashMap();\n \n-                    let sig = tcx.item_type(def_id).fn_sig();\n+                    let sig = tcx.type_of(def_id).fn_sig();\n                     let sig = tcx.no_late_bound_regions(&sig).unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,"}, {"sha": "f0a74ea4be92cd812f3d017e242ea9c9fb155fdd", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let method_generics = self.tcx.item_generics(pick.item.def_id);\n+        let method_generics = self.tcx.generics_of(pick.item.def_id);\n         let num_method_types = method_generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n@@ -358,14 +358,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let def_id = pick.item.def_id;\n-        let method_predicates = self.tcx.item_predicates(def_id)\n+        let method_predicates = self.tcx.predicates_of(def_id)\n                                     .instantiate(self.tcx, all_substs);\n         let method_predicates = self.normalize_associated_types_in(self.span,\n                                                                    &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let sig = self.tcx.item_type(def_id).fn_sig();\n+        let sig = self.tcx.type_of(def_id).fn_sig();\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type."}, {"sha": "57a9a08a9663d91b5755eea7811a537729b6bd7e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n         let def_id = method_item.def_id;\n-        let generics = tcx.item_generics(def_id);\n+        let generics = tcx.generics_of(def_id);\n         assert_eq!(generics.types.len(), 0);\n         assert_eq!(generics.regions.len(), 0);\n \n@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let original_method_ty = tcx.item_type(def_id);\n+        let original_method_ty = tcx.type_of(def_id);\n         let fn_sig = original_method_ty.fn_sig();\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n-        let bounds = self.tcx.item_predicates(def_id).instantiate(self.tcx, substs);\n+        let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n         let bounds = match self.normalize_associated_types_in_as_infer_ok(span, &bounds) {\n             InferOk { value, obligations: o } => {\n                 obligations.extend(o);"}, {"sha": "3cd53c378dd1b79cc12f333a9e4c36c777409912", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n-        let impl_def_ids = ty::queries::inherent_impls::get(self.tcx, self.span, def_id);\n+        let impl_def_ids = self.tcx.at(self.span).inherent_impls(def_id);\n         for &impl_def_id in impl_def_ids.iter() {\n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n@@ -661,7 +661,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                expected: ty::Ty<'tcx>) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n-                let fty = self.tcx.item_type(def_id).fn_sig();\n+                let fty = self.tcx.type_of(def_id).fn_sig();\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let output = fty.output().subst(self.tcx, substs);\n@@ -706,7 +706,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                      import_id: Option<ast::NodeId>,\n                                                      trait_def_id: DefId,\n                                                      item: ty::AssociatedItem) {\n-        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n+        let trait_def = self.tcx.trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n         trait_def.for_each_impl(self.tcx, |impl_def_id| {\n@@ -756,7 +756,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let impl_type = self.tcx.item_type(impl_def_id);\n+        let impl_type = self.tcx.type_of(impl_def_id);\n         let impl_simplified_type =\n             match ty::fast_reject::simplify_type(self.tcx, impl_type, false) {\n                 Some(simplified_type) => simplified_type,\n@@ -858,7 +858,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                    def_id,\n                    substs);\n \n-            let trait_predicates = self.tcx.item_predicates(def_id);\n+            let trait_predicates = self.tcx.predicates_of(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n@@ -1167,7 +1167,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx.item_predicates(impl_def_id);\n+            let impl_bounds = self.tcx.predicates_of(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n                 traits::normalize(selcx, cause.clone(), &impl_bounds);\n@@ -1276,7 +1276,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n                             -> Ty<'tcx> {\n-        let self_ty = self.tcx.item_type(method).fn_sig().input(0);\n+        let self_ty = self.tcx.type_of(method).fn_sig().input(0);\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                self_ty,\n@@ -1289,7 +1289,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        let generics = self.tcx.item_generics(method);\n+        let generics = self.tcx.generics_of(method);\n         assert_eq!(substs.types().count(), generics.parent_types as usize);\n         assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n \n@@ -1323,7 +1323,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n-        let impl_ty = self.tcx.item_type(impl_def_id);\n+        let impl_ty = self.tcx.type_of(impl_def_id);\n \n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,"}, {"sha": "1c0c68ae7d7cb14998795c08a98944393c66010c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -621,22 +621,22 @@ pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n }\n \n pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n-    ty::queries::typeck_item_bodies::get(tcx, DUMMY_SP, LOCAL_CRATE)\n+    tcx.typeck_item_bodies(LOCAL_CRATE)\n }\n \n fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> CompileResult {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.sess.track_errors(|| {\n         tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n-            tcx.item_tables(body_owner_def_id);\n+            tcx.typeck_tables_of(body_owner_def_id);\n         });\n     })\n }\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_item_bodies,\n-        typeck_tables,\n+        typeck_tables_of,\n         closure_type,\n         closure_kind,\n         adt_destructor,\n@@ -648,14 +648,14 @@ fn closure_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::PolyFnSig<'tcx> {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.item_tables(def_id).closure_tys[&node_id]\n+    tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n }\n \n fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.item_tables(def_id).closure_kinds[&node_id]\n+    tcx.typeck_tables_of(def_id).closure_kinds[&node_id]\n }\n \n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -664,14 +664,14 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n }\n \n-fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> &'tcx ty::TypeckTables<'tcx> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n-        return tcx.item_tables(outer_def_id);\n+        return tcx.typeck_tables_of(outer_def_id);\n     }\n \n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -736,7 +736,7 @@ fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     Inherited::build(tcx, id).enter(|inh| {\n         let fcx = if let Some(decl) = fn_decl {\n-            let fn_sig = tcx.item_type(def_id).fn_sig();\n+            let fn_sig = tcx.type_of(def_id).fn_sig();\n \n             check_abi(tcx, span, fn_sig.abi());\n \n@@ -752,7 +752,7 @@ fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             check_fn(&inh, fn_sig, decl, id, body)\n         } else {\n             let fcx = FnCtxt::new(&inh, body.value.id);\n-            let expected_type = tcx.item_type(def_id);\n+            let expected_type = tcx.type_of(def_id);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n@@ -946,7 +946,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           id: ast::NodeId,\n                           span: Span) {\n     let def_id = tcx.hir.local_def_id(id);\n-    let def = tcx.lookup_adt_def(def_id);\n+    let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n \n@@ -956,7 +956,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // if struct is packed and not aligned, check fields for alignment.\n     // Checks for combining packed and align attrs on single struct are done elsewhere.\n-    if tcx.lookup_adt_def(def_id).repr.packed() && tcx.lookup_adt_def(def_id).repr.align == 0 {\n+    if tcx.adt_def(def_id).repr.packed() && tcx.adt_def(def_id).repr.align == 0 {\n         check_packed(tcx, span, def_id);\n     }\n }\n@@ -965,7 +965,7 @@ fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          id: ast::NodeId,\n                          span: Span) {\n     let def_id = tcx.hir.local_def_id(id);\n-    let def = tcx.lookup_adt_def(def_id);\n+    let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n }\n@@ -979,7 +979,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n       // Consts can play a role in type-checking, so they are included here.\n       hir::ItemStatic(..) |\n       hir::ItemConst(..) => {\n-        tcx.item_tables(tcx.hir.local_def_id(it.id));\n+        tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum(tcx,\n@@ -1013,7 +1013,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n       }\n       hir::ItemTy(_, ref generics) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n-        let pty_ty = tcx.item_type(def_id);\n+        let pty_ty = tcx.type_of(def_id);\n         check_bounds_are_used(tcx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n@@ -1029,7 +1029,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n             }\n         } else {\n             for item in &m.items {\n-                let generics = tcx.item_generics(tcx.hir.local_def_id(item.id));\n+                let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n                 if !generics.types.is_empty() {\n                     let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -1052,7 +1052,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = tcx.item_generics(def_id);\n+    let generics = tcx.generics_of(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -1159,7 +1159,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if impl_trait_ref.references_error() { return; }\n \n     // Locate trait definition and items\n-    let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n+    let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n     let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir.impl_item(iiref.id));\n@@ -1280,11 +1280,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let signature = |item: &ty::AssociatedItem| {\n         match item.kind {\n             ty::AssociatedKind::Method => {\n-                format!(\"{}\", tcx.item_type(item.def_id).fn_sig().0)\n+                format!(\"{}\", tcx.type_of(item.def_id).fn_sig().0)\n             }\n             ty::AssociatedKind::Type => format!(\"type {};\", item.name.to_string()),\n             ty::AssociatedKind::Const => {\n-                format!(\"const {}: {:?};\", item.name.to_string(), tcx.item_type(item.def_id))\n+                format!(\"const {}: {:?};\", item.name.to_string(), tcx.type_of(item.def_id))\n             }\n         }\n     };\n@@ -1330,7 +1330,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  sp: Span,\n                                  item_def_id: DefId)\n                                  -> bool {\n-    let rty = tcx.item_type(item_def_id);\n+    let rty = tcx.type_of(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n     // (1) types that contain themselves and (2) types that contain a different\n@@ -1348,7 +1348,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n-    let t = tcx.item_type(def_id);\n+    let t = tcx.type_of(def_id);\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n             let fields = &def.struct_variant().fields;\n@@ -1387,14 +1387,14 @@ fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId)\n fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 def_id: DefId,\n                                 stack: &mut Vec<DefId>) -> bool {\n-    let t = tcx.item_type(def_id);\n+    let t = tcx.type_of(def_id);\n     if stack.contains(&def_id) {\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n         return false;\n     }\n     match t.sty {\n         ty::TyAdt(def, substs) if def.is_struct() => {\n-            if tcx.lookup_adt_def(def.did).repr.align > 0 {\n+            if tcx.adt_def(def.did).repr.align > 0 {\n                 return true;\n             }\n             // push struct def_id before checking fields\n@@ -1424,7 +1424,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             vs: &'tcx [hir::Variant],\n                             id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(id);\n-    let def = tcx.lookup_adt_def(def_id);\n+    let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() && tcx.has_attr(def_id, \"repr\") {\n@@ -1445,7 +1445,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for v in vs {\n         if let Some(e) = v.node.disr_expr {\n-            tcx.item_tables(tcx.hir.local_def_id(e.node_id));\n+            tcx.typeck_tables_of(tcx.hir.local_def_id(e.node_id));\n         }\n     }\n \n@@ -1493,7 +1493,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let item_id = tcx.hir.ty_param_owner(node_id);\n         let item_def_id = tcx.hir.local_def_id(item_id);\n-        let generics = tcx.item_generics(item_def_id);\n+        let generics = tcx.generics_of(item_def_id);\n         let index = generics.type_param_to_index[&def_id.index];\n         ty::GenericPredicates {\n             parent: None,\n@@ -1792,7 +1792,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// generic type scheme.\n     fn instantiate_bounds(&self, span: Span, def_id: DefId, substs: &Substs<'tcx>)\n                           -> ty::InstantiatedPredicates<'tcx> {\n-        let bounds = self.tcx.item_predicates(def_id);\n+        let bounds = self.tcx.predicates_of(def_id);\n         let result = bounds.instantiate(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &result);\n         debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n@@ -1817,8 +1817,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.anon_types.borrow_mut().insert(id, ty_var);\n \n-                let item_predicates = self.tcx.item_predicates(def_id);\n-                let bounds = item_predicates.instantiate(self.tcx, substs);\n+                let predicates_of = self.tcx.predicates_of(def_id);\n+                let bounds = predicates_of.instantiate(self.tcx, substs);\n \n                 for predicate in bounds.predicates {\n                     // Change the predicate to refer to the type variable,\n@@ -2614,7 +2614,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span, // (potential) receiver for this impl\n                         did: DefId)\n                         -> TypeAndSubsts<'tcx> {\n-        let ity = self.tcx.item_type(did);\n+        let ity = self.tcx.type_of(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n         let substs = self.fresh_substs_for_item(span, did);\n@@ -4208,11 +4208,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::VariantCtor(def_id, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                let mut generics = self.tcx.item_generics(def_id);\n+                let mut generics = self.tcx.generics_of(def_id);\n                 if let Some(def_id) = generics.parent {\n                     // Variant and struct constructors use the\n                     // generics of their parent type definition.\n-                    generics = self.tcx.item_generics(def_id);\n+                    generics = self.tcx.generics_of(def_id);\n                 }\n                 type_segment = Some((segments.last().unwrap(), generics));\n             }\n@@ -4222,7 +4222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n                 fn_segment = Some((segments.last().unwrap(),\n-                                   self.tcx.item_generics(def_id)));\n+                                   self.tcx.generics_of(def_id)));\n             }\n \n             // Case 3. Reference to a method or associated const.\n@@ -4236,9 +4236,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::ImplContainer(_) => {}\n                 }\n \n-                let generics = self.tcx.item_generics(def_id);\n+                let generics = self.tcx.generics_of(def_id);\n                 if segments.len() >= 2 {\n-                    let parent_generics = self.tcx.item_generics(generics.parent.unwrap());\n+                    let parent_generics = self.tcx.generics_of(generics.parent.unwrap());\n                     type_segment = Some((&segments[segments.len() - 2], parent_generics));\n                 } else {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n@@ -4351,7 +4351,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.to_ty(ast_ty)\n             } else if !infer_types && def.has_default {\n                 // No type parameter provided, but a default exists.\n-                let default = self.tcx.item_type(def.def_id);\n+                let default = self.tcx.type_of(def.def_id);\n                 self.normalize_ty(\n                     span,\n                     default.subst_spanned(self.tcx, substs, Some(span))\n@@ -4367,7 +4367,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let ty = self.tcx.item_type(def.def_id());\n+        let ty = self.tcx.type_of(def.def_id());\n         assert!(!substs.has_escaping_regions());\n         assert!(!ty.has_escaping_regions());\n \n@@ -4387,7 +4387,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // is inherent, there is no `Self` parameter, instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n-            let ty = self.tcx.item_type(impl_def_id);\n+            let ty = self.tcx.type_of(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n             match self.sub_types(false, &self.misc(span), self_ty, impl_ty) {"}, {"sha": "3508ddbe5f48929221c086f9e6cb2a115732a995", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -1725,7 +1725,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // ```\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.item_predicates(projection_ty.trait_ref.def_id);\n+        let trait_predicates = self.tcx.predicates_of(projection_ty.trait_ref.def_id);\n         assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)"}, {"sha": "5bb45cbb1ae8ae3472edeefa124157ea181bdb3b", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -168,18 +168,18 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let (mut implied_bounds, self_ty) = match item.container {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx.item_type(def_id))\n+                                              fcx.tcx.type_of(def_id))\n             };\n \n             match item.kind {\n                 ty::AssociatedKind::Const => {\n-                    let ty = fcx.tcx.item_type(item.def_id);\n+                    let ty = fcx.tcx.type_of(item.def_id);\n                     let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n-                    let method_ty = fcx.tcx.item_type(item.def_id);\n+                    let method_ty = fcx.tcx.type_of(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n                     let sig = method_ty.fn_sig();\n@@ -191,7 +191,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n                 ty::AssociatedKind::Type => {\n                     if item.defaultness.has_value() {\n-                        let ty = fcx.tcx.item_type(item.def_id);\n+                        let ty = fcx.tcx.type_of(item.def_id);\n                         let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n@@ -262,7 +262,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         //\n         // 3) that the trait definition does not have any type parameters\n \n-        let predicates = self.tcx.item_predicates(trait_def_id);\n+        let predicates = self.tcx.predicates_of(trait_def_id);\n \n         // We must exclude the Self : Trait predicate contained by all\n         // traits.\n@@ -277,7 +277,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             });\n \n-        let has_ty_params = self.tcx.item_generics(trait_def_id).types.len() > 1;\n+        let has_ty_params = self.tcx.generics_of(trait_def_id).types.len() > 1;\n \n         // We use an if-else here, since the generics will also trigger\n         // an extraneous error message when we find predicates like\n@@ -334,7 +334,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let ty = fcx.tcx.item_type(def_id);\n+            let ty = fcx.tcx.type_of(def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n             let sig = item_ty.fn_sig();\n \n@@ -354,7 +354,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let ty = fcx.tcx.item_type(fcx.tcx.hir.local_def_id(item.id));\n+            let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.parameter_environment\n                                                           .free_substs,\n@@ -393,7 +393,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx.item_type(item_def_id);\n+                    let self_ty = fcx.tcx.type_of(item_def_id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n@@ -468,7 +468,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let span = method_sig.decl.inputs[0].span;\n \n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let method_ty = fcx.tcx.item_type(method.def_id);\n+        let method_ty = fcx.tcx.type_of(method.def_id);\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n         let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n \n@@ -502,14 +502,14 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                      ast_generics: &hir::Generics)\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item.id);\n-        let ty = self.tcx.item_type(item_def_id);\n+        let ty = self.tcx.type_of(item_def_id);\n         if self.tcx.has_error_field(ty) {\n             return;\n         }\n \n-        let ty_predicates = self.tcx.item_predicates(item_def_id);\n+        let ty_predicates = self.tcx.predicates_of(item_def_id);\n         assert_eq!(ty_predicates.parent, None);\n-        let variances = self.tcx.item_variances(item_def_id);\n+        let variances = self.tcx.variances_of(item_def_id);\n \n         let mut constrained_parameters: FxHashSet<_> =\n             variances.iter().enumerate()\n@@ -561,8 +561,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n-    let generics = tcx.item_generics(def_id);\n-    let parent = tcx.item_generics(generics.parent.unwrap());\n+    let generics = tcx.generics_of(def_id);\n+    let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n                                        .iter()\n                                        .map(|tp| (tp.name, tp.def_id))\n@@ -631,7 +631,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fields =\n             struct_def.fields().iter()\n             .map(|field| {\n-                let field_ty = self.tcx.item_type(self.tcx.hir.local_def_id(field.id));\n+                let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n                 let field_ty = self.instantiate_type_scheme(field.span,\n                                                             &self.parameter_environment\n                                                                  .free_substs,\n@@ -660,7 +660,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             None => {\n                 // Inherent impl: take implied bounds from the self type.\n-                let self_ty = self.tcx.item_type(impl_def_id);\n+                let self_ty = self.tcx.type_of(impl_def_id);\n                 let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n                 vec![self_ty]\n             }"}, {"sha": "a985ac61cb3a90412c841fa74f6c56b26acf373b", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -67,7 +67,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let item_def_id = tcx.hir.local_def_id(item_id);\n \n         // this will have been written by the main typeck pass\n-        if let Some(tables) = tcx.maps.typeck_tables.borrow().get(&item_def_id) {\n+        if let Some(tables) = tcx.maps.typeck_tables_of.borrow().get(&item_def_id) {\n             let imports = &tables.used_trait_imports;\n             debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n             used_trait_imports.extend(imports);"}, {"sha": "57193b3584dfa97b80f93be60cbb21ecf5910761", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           _drop_did: DefId,\n                                           impl_did: DefId) {\n-    match tcx.item_type(impl_did).sty {\n+    match tcx.type_of(impl_did).sty {\n         ty::TyAdt(..) => {}\n         _ => {\n             // Destructors only work on nominal types.\n@@ -101,7 +101,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     };\n \n-    let self_type = tcx.item_type(impl_did);\n+    let self_type = tcx.type_of(impl_did);\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n            self_type);\n \n@@ -170,7 +170,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // course.\n     if impl_did.is_local() {\n         let span = tcx.def_span(impl_did);\n-        ty::queries::coerce_unsized_info::get(tcx, span, impl_did);\n+        tcx.at(span).coerce_unsized_info(impl_did);\n     }\n }\n \n@@ -192,7 +192,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = tcx.item_type(impl_did);\n+    let source = tcx.type_of(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n@@ -259,7 +259,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     .filter_map(|(i, f)| {\n                         let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                        if tcx.item_type(f.did).is_phantom_data() {\n+                        if tcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }"}, {"sha": "400aaf82fe428f5c7aa11e9b7238b936679d17a4", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -14,7 +14,7 @@\n //! for any change, but it is very cheap to compute. In practice, most\n //! code in the compiler never *directly* requests this map. Instead,\n //! it requests the inherent impls specific to some type (via\n-//! `ty::queries::inherent_impls::get(def_id)`). That value, however,\n+//! `tcx.inherent_impls(def_id)`). That value, however,\n //! is computed by selecting an idea from this table.\n \n use rustc::dep_graph::DepNode;\n@@ -26,7 +26,7 @@ use rustc::util::nodemap::DefIdMap;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -67,7 +67,7 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n \n     let result = tcx.dep_graph.with_ignore(|| {\n-        let crate_map = ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, ty_def_id.krate);\n+        let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n         match crate_map.inherent_impls.get(&ty_def_id) {\n             Some(v) => v.clone(),\n             None => Rc::new(vec![]),\n@@ -106,7 +106,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n         }\n \n         let def_id = self.tcx.hir.local_def_id(item.id);\n-        let self_ty = self.tcx.item_type(def_id);\n+        let self_ty = self.tcx.type_of(def_id);\n         match self_ty.sty {\n             ty::TyAdt(def, _) => {\n                 self.check_def_id(item, def.did);"}, {"sha": "34aec8ef1ac8c1f8e9961228ecdad38afd357aed", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -14,8 +14,6 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt};\n \n-use syntax_pos::DUMMY_SP;\n-\n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -68,7 +66,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     }\n \n     fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n-        let impls = ty::queries::inherent_impls::get(self.tcx, DUMMY_SP, ty_def_id);\n+        let impls = self.tcx.inherent_impls(ty_def_id);\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {"}, {"sha": "56ae9d545751f56c1eae0aed72d6e8592ca70a87", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -16,11 +16,10 @@\n // mappings. That mapping code resides here.\n \n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::{TyCtxt, TypeFoldable};\n use rustc::ty::maps::Providers;\n \n use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n \n mod builtin;\n mod inherent_impls;\n@@ -47,7 +46,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n         }\n \n         enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+        let trait_def = tcx.trait_def(trait_ref.def_id);\n         trait_def.record_local_impl(tcx, impl_def_id, trait_ref);\n     }\n }\n@@ -132,14 +131,14 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n-        ty::queries::coherent_trait::get(tcx, DUMMY_SP, (LOCAL_CRATE, trait_def_id));\n+        tcx.coherent_trait((LOCAL_CRATE, trait_def_id));\n     }\n \n     unsafety::check(tcx);\n     orphan::check(tcx);\n     overlap::check_default_impls(tcx);\n \n     // these queries are executed for side-effects (error reporting):\n-    ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n-    ty::queries::crate_inherent_impls_overlap_check::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    tcx.crate_inherent_impls(LOCAL_CRATE);\n+    tcx.crate_inherent_impls_overlap_check(LOCAL_CRATE);\n }"}, {"sha": "383a9e0e69542caeadd47d406d3d3d76f90d69b5", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -41,7 +41,7 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     let _task =\n         tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n-    let def = tcx.lookup_trait_def(trait_def_id);\n+    let def = tcx.trait_def(trait_def_id);\n \n     // attempt to insert into the specialization graph\n     let insert_result = def.add_impl_for_specialization(tcx, impl_def_id);"}, {"sha": "4463cff9c503f50161fa0b0b52d710c24d1fca06", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -34,7 +34,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n             None => {}\n \n             Some(trait_ref) => {\n-                let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n+                let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                 let unsafe_attr = impl_generics.and_then(|g| g.carries_unsafe_attr());\n                 match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n                     (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {"}, {"sha": "099586e6bcc2a5b9482ab198b8f7ff254a626b0b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -31,7 +31,7 @@ then types, or something like that) because the user can introduce\n arbitrary interdependencies. So instead we generally convert things\n lazilly and on demand, and include logic that checks for cycles.\n Demand is driven by calls to `AstConv::get_item_type_scheme` or\n-`AstConv::lookup_trait_def`.\n+`AstConv::trait_def`.\n \n Currently, we \"convert\" types and traits in two phases (note that\n conversion only affects the types of items / enum variants / methods;\n@@ -91,10 +91,10 @@ pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        ty,\n-        generics,\n-        predicates,\n-        super_predicates,\n+        type_of,\n+        generics_of,\n+        predicates_of,\n+        super_predicates_of,\n         type_param_predicates,\n         trait_def,\n         adt_def,\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         for param in &generics.ty_params {\n             if param.default.is_some() {\n                 let def_id = self.tcx.hir.local_def_id(param.id);\n-                self.tcx.item_type(def_id);\n+                self.tcx.type_of(def_id);\n             }\n         }\n         intravisit::walk_generics(self, generics);\n@@ -150,17 +150,17 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n             let def_id = self.tcx.hir.local_def_id(expr.id);\n-            self.tcx.item_generics(def_id);\n-            self.tcx.item_type(def_id);\n+            self.tcx.generics_of(def_id);\n+            self.tcx.type_of(def_id);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.tcx.item_generics(def_id);\n-            self.tcx.item_predicates(def_id);\n+            self.tcx.generics_of(def_id);\n+            self.tcx.predicates_of(def_id);\n         }\n         intravisit::walk_ty(self, ty);\n     }\n@@ -207,7 +207,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                  def_id: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {\n-        ty::queries::type_param_predicates::get(self.tcx, span, (self.item_def_id, def_id))\n+        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n@@ -271,15 +271,15 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let param_owner = tcx.hir.ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n-    let generics = tcx.item_generics(param_owner_def_id);\n+    let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.type_param_to_index[&def_id.index];\n     let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n     let parent = if item_def_id == param_owner_def_id {\n         None\n     } else {\n-        tcx.item_generics(item_def_id).parent\n+        tcx.generics_of(item_def_id).parent\n     };\n \n     let mut result = parent.map_or(ty::GenericPredicates {\n@@ -452,43 +452,43 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n         hir::ItemForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n                 let def_id = tcx.hir.local_def_id(item.id);\n-                tcx.item_generics(def_id);\n-                tcx.item_type(def_id);\n-                tcx.item_predicates(def_id);\n+                tcx.generics_of(def_id);\n+                tcx.type_of(def_id);\n+                tcx.predicates_of(def_id);\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            tcx.item_generics(def_id);\n-            tcx.item_type(def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.type_of(def_id);\n+            tcx.predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         },\n         hir::ItemDefaultImpl(..) => {\n             tcx.impl_trait_ref(def_id);\n         }\n         hir::ItemImpl(..) => {\n-            tcx.item_generics(def_id);\n-            tcx.item_type(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.type_of(def_id);\n             tcx.impl_trait_ref(def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.predicates_of(def_id);\n         },\n         hir::ItemTrait(..) => {\n-            tcx.item_generics(def_id);\n-            tcx.lookup_trait_def(def_id);\n-            ty::queries::super_predicates::get(tcx, it.span, def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.trait_def(def_id);\n+            tcx.at(it.span).super_predicates_of(def_id);\n+            tcx.predicates_of(def_id);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n-            tcx.item_generics(def_id);\n-            tcx.item_type(def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.type_of(def_id);\n+            tcx.predicates_of(def_id);\n \n             for f in struct_def.fields() {\n                 let def_id = tcx.hir.local_def_id(f.id);\n-                tcx.item_generics(def_id);\n-                tcx.item_type(def_id);\n-                tcx.item_predicates(def_id);\n+                tcx.generics_of(def_id);\n+                tcx.type_of(def_id);\n+                tcx.predicates_of(def_id);\n             }\n \n             if !struct_def.is_struct() {\n@@ -497,55 +497,55 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(tcx, it.span, generics, \"type\");\n-            tcx.item_generics(def_id);\n-            tcx.item_type(def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.type_of(def_id);\n+            tcx.predicates_of(def_id);\n         }\n         hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) => {\n-            tcx.item_generics(def_id);\n-            tcx.item_type(def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.type_of(def_id);\n+            tcx.predicates_of(def_id);\n         }\n     }\n }\n \n fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast::NodeId) {\n     let trait_item = tcx.hir.expect_trait_item(trait_item_id);\n     let def_id = tcx.hir.local_def_id(trait_item.id);\n-    tcx.item_generics(def_id);\n+    tcx.generics_of(def_id);\n \n     match trait_item.node {\n         hir::TraitItemKind::Const(..) |\n         hir::TraitItemKind::Type(_, Some(_)) |\n         hir::TraitItemKind::Method(..) => {\n-            tcx.item_type(def_id);\n+            tcx.type_of(def_id);\n         }\n \n         hir::TraitItemKind::Type(_, None) => {}\n     };\n \n-    tcx.item_predicates(def_id);\n+    tcx.predicates_of(def_id);\n }\n \n fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(impl_item_id);\n-    tcx.item_generics(def_id);\n-    tcx.item_type(def_id);\n-    tcx.item_predicates(def_id);\n+    tcx.generics_of(def_id);\n+    tcx.type_of(def_id);\n+    tcx.predicates_of(def_id);\n }\n \n fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   ctor_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    tcx.item_generics(def_id);\n-    tcx.item_type(def_id);\n-    tcx.item_predicates(def_id);\n+    tcx.generics_of(def_id);\n+    tcx.type_of(def_id);\n+    tcx.predicates_of(def_id);\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         variants: &[hir::Variant]) {\n-    let def = tcx.lookup_adt_def(def_id);\n+    let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<ConstInt>;\n@@ -556,7 +556,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n             let substs = Substs::empty();\n-            let result = ty::queries::const_eval::get(tcx, variant.span, (expr_did, substs));\n+            let result = tcx.at(variant.span).const_eval((expr_did, substs));\n \n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error\n@@ -583,9 +583,9 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         for f in variant.node.data.fields() {\n             let def_id = tcx.hir.local_def_id(f.id);\n-            tcx.item_generics(def_id);\n-            tcx.item_type(def_id);\n-            tcx.item_predicates(def_id);\n+            tcx.generics_of(def_id);\n+            tcx.type_of(def_id);\n+            tcx.predicates_of(def_id);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n@@ -686,9 +686,9 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Ensures that the super-predicates of the trait with def-id\n /// trait_def_id are converted and stored. This also ensures that\n /// the transitive super-predicates are converted;\n-fn super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              trait_def_id: DefId)\n-                              -> ty::GenericPredicates<'tcx> {\n+fn super_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 trait_def_id: DefId)\n+                                 -> ty::GenericPredicates<'tcx> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n@@ -725,7 +725,7 @@ fn super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n     for bound in superbounds.iter().filter_map(|p| p.to_opt_poly_trait_ref()) {\n-        ty::queries::super_predicates::get(tcx, item.span, bound.def_id());\n+        tcx.at(item.span).super_predicates_of(bound.def_id());\n     }\n \n     ty::GenericPredicates {\n@@ -767,9 +767,9 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.alloc_trait_def(def)\n }\n \n-fn generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                      def_id: DefId)\n-                      -> &'tcx ty::Generics {\n+fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         def_id: DefId)\n+                         -> &'tcx ty::Generics {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -873,7 +873,7 @@ fn generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut parent_has_self = false;\n     let mut own_start = has_self as u32;\n     let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n-        let generics = tcx.item_generics(def_id);\n+        let generics = tcx.generics_of(def_id);\n         assert_eq!(has_self, false);\n         parent_has_self = generics.has_self;\n         own_start = generics.count() as u32;\n@@ -958,9 +958,9 @@ fn generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                def_id: DefId)\n-                -> Ty<'tcx> {\n+fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     def_id: DefId)\n+                     -> Ty<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -1017,7 +1017,7 @@ fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ItemEnum(..) |\n                 ItemStruct(..) |\n                 ItemUnion(..) => {\n-                    let def = tcx.lookup_adt_def(def_id);\n+                    let def = tcx.adt_def(def_id);\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n@@ -1049,12 +1049,12 @@ fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeStructCtor(&ref def) |\n         NodeVariant(&Spanned { node: hir::Variant_ { data: ref def, .. }, .. }) => {\n-            let ty = tcx.item_type(tcx.hir.get_parent_did(node_id));\n+            let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n             match *def {\n                 VariantData::Unit(..) | VariantData::Struct(..) => ty,\n                 VariantData::Tuple(ref fields, _) => {\n                     let inputs = fields.iter().map(|f| {\n-                        tcx.item_type(tcx.hir.local_def_id(f.id))\n+                        tcx.type_of(tcx.hir.local_def_id(f.id))\n                     });\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n@@ -1089,7 +1089,7 @@ fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             NodeVariant(&Spanned { node: Variant_ { disr_expr: Some(e), .. }, .. })\n                 if e.node_id == node_id => {\n-                    tcx.lookup_adt_def(tcx.hir.get_parent_did(node_id))\n+                    tcx.adt_def(tcx.hir.get_parent_did(node_id))\n                         .repr.discr_type().to_ty(tcx)\n                 }\n \n@@ -1104,7 +1104,7 @@ fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n             let owner = tcx.hir.get_parent_did(node_id);\n-            tcx.item_tables(owner).node_id_to_type(node_id)\n+            tcx.typeck_tables_of(owner).node_id_to_type(node_id)\n         }\n \n         x => {\n@@ -1127,7 +1127,7 @@ fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n-                let selfty = tcx.item_type(def_id);\n+                let selfty = tcx.type_of(def_id);\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n             })\n         }\n@@ -1141,7 +1141,7 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     match tcx.hir.expect_item(node_id).node {\n         hir::ItemImpl(_, polarity, ..) => polarity,\n-        ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n+        ref item => bug!(\"impl_polarity: {:?} not an impl\", item)\n     }\n }\n \n@@ -1205,9 +1205,9 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n         .filter(move |l| !tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n }\n \n-fn predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        def_id: DefId)\n-                        -> ty::GenericPredicates<'tcx> {\n+fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> ty::GenericPredicates<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -1280,7 +1280,7 @@ fn predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => &no_generics\n     };\n \n-    let generics = tcx.item_generics(def_id);\n+    let generics = tcx.generics_of(def_id);\n     let parent_count = generics.parent_count() as u32;\n     let has_own_self = generics.has_self && parent_count == 0;\n \n@@ -1291,7 +1291,7 @@ fn predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n     if let Some((trait_ref, _)) = is_trait {\n-        predicates = tcx.item_super_predicates(def_id).predicates;\n+        predicates = tcx.super_predicates_of(def_id).predicates;\n \n         // Add in a predicate that `Self:Trait` (where `Trait` is the\n         // current trait).  This is needed for builtin bounds.\n@@ -1410,7 +1410,7 @@ fn predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n     if let NodeItem(&Item { node: ItemImpl(..), .. }) = node {\n-        let self_ty = tcx.item_type(def_id);\n+        let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n         ctp::setup_constraining_predicates(&mut predicates,\n                                            trait_ref,"}, {"sha": "1c44572fbb4af3e828d23e25254788202e710c00", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -95,9 +95,9 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  impl_item_refs: &[hir::ImplItemRef])\n {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_self_ty = tcx.item_type(impl_def_id);\n-    let impl_generics = tcx.item_generics(impl_def_id);\n-    let impl_predicates = tcx.item_predicates(impl_def_id);\n+    let impl_self_ty = tcx.type_of(impl_def_id);\n+    let impl_generics = tcx.generics_of(impl_def_id);\n+    let impl_predicates = tcx.predicates_of(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n@@ -120,7 +120,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n         })\n         .flat_map(|def_id| {\n-            ctp::parameters_for(&tcx.item_type(def_id), true)\n+            ctp::parameters_for(&tcx.type_of(def_id), true)\n         }).collect();\n     for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n         .zip(&impl_hir_generics.lifetimes)"}, {"sha": "94b4bfade9498e0ac764b19da57b5ceecd284267", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -179,7 +179,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               main_id: ast::NodeId,\n                               main_span: Span) {\n     let main_def_id = tcx.hir.local_def_id(main_id);\n-    let main_t = tcx.item_type(main_def_id);\n+    let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.hir.find(main_id) {\n@@ -229,7 +229,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                start_id: ast::NodeId,\n                                start_span: Span) {\n     let start_def_id = tcx.hir.local_def_id(start_id);\n-    let start_t = tcx.item_type(start_def_id);\n+    let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n             match tcx.hir.find(start_id) {"}, {"sha": "5bbc285c3d5ce17fb0053141d7272b1de65b48db", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -81,22 +81,22 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                let generics = tcx.item_generics(did);\n+                let generics = tcx.generics_of(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.lookup_adt_def(did).all_fields() {\n+                for field in tcx.adt_def(did).all_fields() {\n                     self.add_constraints_from_ty(generics,\n-                                                 tcx.item_type(field.did),\n+                                                 tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                let generics = tcx.item_generics(did);\n+                let generics = tcx.generics_of(did);\n                 let trait_ref = ty::TraitRef {\n                     def_id: did,\n                     substs: Substs::identity_for_item(tcx, did)\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n-            let variances = self.tcx().item_variances(item_def_id);\n+            let variances = self.tcx().variances_of(item_def_id);\n             self.constant_term(variances[index])\n         }\n     }\n@@ -286,10 +286,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                trait_ref,\n                variance);\n \n-        let trait_generics = self.tcx().item_generics(trait_ref.def_id);\n+        let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n         // This edge is actually implied by the call to\n-        // `lookup_trait_def`, but I'm trying to be future-proof. See\n+        // `trait_def`, but I'm trying to be future-proof. See\n         // README.md for a discussion on dep-graph management.\n         self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n@@ -345,10 +345,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.tcx().item_generics(def.did);\n+                let adt_generics = self.tcx().generics_of(def.did);\n \n                 // This edge is actually implied by the call to\n-                // `lookup_trait_def`, but I'm trying to be future-proof. See\n+                // `trait_def`, but I'm trying to be future-proof. See\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(VarianceDepNode(def.did));\n \n@@ -362,10 +362,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n-                let trait_generics = self.tcx().item_generics(trait_ref.def_id);\n+                let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n \n                 // This edge is actually implied by the call to\n-                // `lookup_trait_def`, but I'm trying to be future-proof. See\n+                // `trait_def`, but I'm trying to be future-proof. See\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n "}, {"sha": "27116cbbb7aef45596a3d78dbe8b2693fdb05d40", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -137,8 +137,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                           item_variances);\n             }\n \n-            tcx.maps.variances\n-               .borrow_mut()\n+            tcx.maps.variances_of.borrow_mut()\n                .insert(item_def_id, Rc::new(item_variances));\n         }\n     }"}, {"sha": "61ff154e458d381f651ffc67e4bc75d8dece8725", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -178,8 +178,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n             let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx.maps.variances\n-                .borrow_mut()\n+            self.tcx.maps.variances_of.borrow_mut()\n                 .insert(item_def_id, self.empty_variances.clone());\n         }\n     }"}, {"sha": "71bb53e9b81c74be8f0d72bb86f45fc9fd2e968b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -15,7 +15,6 @@ use std::io;\n use std::iter::once;\n \n use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n use rustc::hir;\n \n use rustc::hir::def::{Def, CtorKind};\n@@ -152,89 +151,89 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n \n pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n-    let predicates = cx.tcx.item_predicates(did);\n-    let generics = (cx.tcx.item_generics(did), &predicates).clean(cx);\n+    let predicates = cx.tcx.predicates_of(did);\n+    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n-        unsafety: cx.tcx.lookup_trait_def(did).unsafety,\n+        unsafety: cx.tcx.trait_def(did).unsafety,\n         generics: generics,\n         items: trait_items,\n         bounds: supertrait_bounds,\n     }\n }\n \n fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n-    let sig = cx.tcx.item_type(did).fn_sig();\n+    let sig = cx.tcx.type_of(did).fn_sig();\n \n     let constness = if cx.tcx.sess.cstore.is_const_fn(did) {\n         hir::Constness::Const\n     } else {\n         hir::Constness::NotConst\n     };\n \n-    let predicates = cx.tcx.item_predicates(did);\n+    let predicates = cx.tcx.predicates_of(did);\n     clean::Function {\n         decl: (did, sig).clean(cx),\n-        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n         unsafety: sig.unsafety(),\n         constness: constness,\n         abi: sig.abi(),\n     }\n }\n \n fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n-    let predicates = cx.tcx.item_predicates(did);\n+    let predicates = cx.tcx.predicates_of(did);\n \n     clean::Enum {\n-        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n         variants_stripped: false,\n-        variants: cx.tcx.lookup_adt_def(did).variants.clean(cx),\n+        variants: cx.tcx.adt_def(did).variants.clean(cx),\n     }\n }\n \n fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n-    let predicates = cx.tcx.item_predicates(did);\n-    let variant = cx.tcx.lookup_adt_def(did).struct_variant();\n+    let predicates = cx.tcx.predicates_of(did);\n+    let variant = cx.tcx.adt_def(did).struct_variant();\n \n     clean::Struct {\n         struct_type: match variant.ctor_kind {\n             CtorKind::Fictive => doctree::Plain,\n             CtorKind::Fn => doctree::Tuple,\n             CtorKind::Const => doctree::Unit,\n         },\n-        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n-    let predicates = cx.tcx.item_predicates(did);\n-    let variant = cx.tcx.lookup_adt_def(did).struct_variant();\n+    let predicates = cx.tcx.predicates_of(did);\n+    let variant = cx.tcx.adt_def(did).struct_variant();\n \n     clean::Union {\n         struct_type: doctree::Plain,\n-        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n-    let predicates = cx.tcx.item_predicates(did);\n+    let predicates = cx.tcx.predicates_of(did);\n \n     clean::Typedef {\n-        type_: cx.tcx.item_type(did).clean(cx),\n-        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n+        type_: cx.tcx.type_of(did).clean(cx),\n+        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n     }\n }\n \n pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n-    for &did in ty::queries::inherent_impls::get(tcx, DUMMY_SP, did).iter() {\n+    for &did in tcx.inherent_impls(did).iter() {\n         build_impl(cx, did, &mut impls);\n     }\n \n@@ -326,7 +325,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n         });\n     }\n \n-    let for_ = tcx.item_type(did).clean(cx);\n+    let for_ = tcx.type_of(did).clean(cx);\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n@@ -336,7 +335,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n         }\n     }\n \n-    let predicates = tcx.item_predicates(did);\n+    let predicates = tcx.predicates_of(did);\n     let trait_items = tcx.associated_items(did).filter_map(|item| {\n         match item.kind {\n             ty::AssociatedKind::Const => {\n@@ -348,7 +347,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n                 Some(clean::Item {\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::AssociatedConstItem(\n-                        tcx.item_type(item.def_id).clean(cx),\n+                        tcx.type_of(item.def_id).clean(cx),\n                         default,\n                     ),\n                     source: tcx.def_span(item.def_id).clean(cx),\n@@ -388,7 +387,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             }\n             ty::AssociatedKind::Type => {\n                 let typedef = clean::Typedef {\n-                    type_: tcx.item_type(item.def_id).clean(cx),\n+                    type_: tcx.type_of(item.def_id).clean(cx),\n                     generics: clean::Generics {\n                         lifetimes: vec![],\n                         type_params: vec![],\n@@ -408,7 +407,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             }\n         }\n     }).collect::<Vec<_>>();\n-    let polarity = tcx.trait_impl_polarity(did);\n+    let polarity = tcx.impl_polarity(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n             clean::TraitBound(polyt, _) => polyt.trait_,\n@@ -432,7 +431,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             provided_trait_methods: provided,\n             trait_: trait_,\n             for_: for_,\n-            generics: (tcx.item_generics(did), &predicates).clean(cx),\n+            generics: (tcx.generics_of(did), &predicates).clean(cx),\n             items: trait_items,\n             polarity: Some(polarity.clean(cx)),\n         }),\n@@ -496,14 +495,14 @@ fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n \n fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n     clean::Constant {\n-        type_: cx.tcx.item_type(did).clean(cx),\n+        type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did)\n     }\n }\n \n fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: cx.tcx.item_type(did).clean(cx),\n+        type_: cx.tcx.type_of(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "a25eb60d2a2fc0f934a888023493909b48ddcf80", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -606,7 +606,7 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef {\n             did: self.def_id,\n             bounds: vec![], // these are filled in from the where-clauses\n             default: if self.has_default {\n-                Some(cx.tcx.item_type(self.def_id).clean(cx))\n+                Some(cx.tcx.type_of(self.def_id).clean(cx))\n             } else {\n                 None\n             }\n@@ -1356,19 +1356,19 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n-                let ty = cx.tcx.item_type(self.def_id);\n+                let ty = cx.tcx.type_of(self.def_id);\n                 AssociatedConstItem(ty.clean(cx), None)\n             }\n             ty::AssociatedKind::Method => {\n-                let generics = (cx.tcx.item_generics(self.def_id),\n-                                &cx.tcx.item_predicates(self.def_id)).clean(cx);\n-                let sig = cx.tcx.item_type(self.def_id).fn_sig();\n+                let generics = (cx.tcx.generics_of(self.def_id),\n+                                &cx.tcx.predicates_of(self.def_id)).clean(cx);\n+                let sig = cx.tcx.type_of(self.def_id).fn_sig();\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n                 if self.method_has_self_argument {\n                     let self_ty = match self.container {\n                         ty::ImplContainer(def_id) => {\n-                            cx.tcx.item_type(def_id)\n+                            cx.tcx.type_of(def_id)\n                         }\n                         ty::TraitContainer(_) => cx.tcx.mk_self_type()\n                     };\n@@ -1418,8 +1418,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // are actually located on the trait/impl itself, so we need to load\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n-                    let predicates = cx.tcx.item_predicates(did);\n-                    let generics = (cx.tcx.item_generics(did), &predicates).clean(cx);\n+                    let predicates = cx.tcx.predicates_of(did);\n+                    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n                             WherePredicate::BoundPredicate {\n@@ -1454,7 +1454,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n \n                 let ty = if self.defaultness.has_value() {\n-                    Some(cx.tcx.item_type(self.def_id))\n+                    Some(cx.tcx.type_of(self.def_id))\n                 } else {\n                     None\n                 };\n@@ -1922,9 +1922,9 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyAnon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let item_predicates = cx.tcx.item_predicates(def_id);\n+                let predicates_of = cx.tcx.predicates_of(def_id);\n                 let substs = cx.tcx.lift(&substs).unwrap();\n-                let bounds = item_predicates.instantiate(cx.tcx, substs);\n+                let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {\n                     predicate.to_opt_poly_trait_ref().clean(cx)\n                 }).collect())\n@@ -1963,7 +1963,7 @@ impl<'tcx> Clean<Item> for ty::FieldDef {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(cx.tcx.item_type(self.did).clean(cx)),\n+            inner: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n         }\n     }\n }\n@@ -2116,7 +2116,7 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n             CtorKind::Const => VariantKind::CLike,\n             CtorKind::Fn => {\n                 VariantKind::Tuple(\n-                    self.fields.iter().map(|f| cx.tcx.item_type(f.did).clean(cx)).collect()\n+                    self.fields.iter().map(|f| cx.tcx.type_of(f.did).clean(cx)).collect()\n                 )\n             }\n             CtorKind::Fictive => {\n@@ -2132,7 +2132,7 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),\n-                            inner: StructFieldItem(cx.tcx.item_type(field.did).clean(cx))\n+                            inner: StructFieldItem(cx.tcx.type_of(field.did).clean(cx))\n                         }\n                     }).collect()\n                 })"}, {"sha": "be02d24e44151c0275edfabcbb910a542ea917cd", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0a4074c5e87d24ff630f6aa456a64698bff3ed2/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=b0a4074c5e87d24ff630f6aa456a64698bff3ed2", "patch": "@@ -153,7 +153,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let predicates = cx.tcx.item_super_predicates(child).predicates;\n+    let predicates = cx.tcx.super_predicates_of(child).predicates;\n     predicates.iter().filter_map(|pred| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.0.trait_ref.self_ty().is_self() {"}]}