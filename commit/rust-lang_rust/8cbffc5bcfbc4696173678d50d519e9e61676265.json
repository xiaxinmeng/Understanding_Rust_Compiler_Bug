{"sha": "8cbffc5bcfbc4696173678d50d519e9e61676265", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYmZmYzViY2ZiYzQ2OTYxNzM2NzhkNTBkNTE5ZTllNjE2NzYyNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-05T13:08:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-05T13:08:37Z"}, "message": "Auto merge of #33905 - eddyb:mir-overflow, r=nikomatsakis\n\n[MIR] Implement overflow checking\n\nThe initial set of changes is from @Aatch's #33255 PR, rebased on master, plus:\n\nAdded an `Assert` terminator to MIR, to simplify working with overflow and bounds checks.\nWith this terminator, error cases can be accounted for directly, instead of looking for lang item calls.\nIt also keeps the MIR slimmer, with no extra explicit blocks for the actual panic calls.\n\nWarnings can be produced when the `Assert` is known to always panic at runtime, e.g.:\n```rust\nwarning: index out of bounds: the len is 1 but the index is 3\n --> <anon>:1:14\n1 |> fn main() { &[std::io::stdout()][3]; }\n  |>              ^^^^^^^^^^^^^^^^^^^^^^\n```\n\nGeneralized the `OperandValue::FatPtr` optimization to any aggregate pair of immediates.\nThis allows us to generate the same IR for overflow checks as old trans, not something worse.\nFor example, addition on `i16` calls `llvm.sadd.with.overflow.i16`, which returns `{i16, i1}`.\nHowever, the Rust type `(i16, bool)`, has to be `{i16, i8}`, only an immediate `bool` is `i1`.\nBut if we split the pair into an `i16` and an `i1`, we can pass them around as such for free.\n\nThe latest addition is a rebase of #34054, updated to work for pairs too. Closes #34054, fixes #33873.\n\nLast but not least, the `#[rustc_inherit_overflow_checks]` attribute was introduced to control the\noverflow checking behavior of generic or `#[inline]` functions, when translated in another crate.\n\nIt is **not** intended to be used by crates other than `libcore`, which is in the unusual position of\nbeing distributed as only an optimized build with no checks, even when used from debug mode.\nBefore MIR-based translation, this worked out fine, as the decision for overflow was made at\ntranslation time, in the crate being compiled, but MIR stored in `rlib` has to contain the checks.\n\nTo avoid always generating the checks and slowing everything down, a decision was made to\nuse an attribute in the few spots of `libcore` that need it (see #33255 for previous discussion):\n* `core::ops::{Add, Sub, Mul, Neg, Shl, Shr}` implementations for integers, which have `#[inline]` methods and can be used in generic abstractions from other crates\n* `core::ops::{Add, Sub, Mul, Neg, Shl, Shr}Assign` same as above, for augmented assignment\n* `pow` and `abs` methods on integers, which intentionally piggy-back on built-in multiplication and negation, respectively, to get overflow checks\n* `core::iter::{Iterator, Chain, Peek}::count` and `core::iter::Enumerate::{next, nth}`, also documented as panicking on overflow, from addition, counting elements of an iterator in an `usize`", "tree": {"sha": "58f9919328e7f2c37d8165a315067c75ef09b4b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58f9919328e7f2c37d8165a315067c75ef09b4b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cbffc5bcfbc4696173678d50d519e9e61676265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cbffc5bcfbc4696173678d50d519e9e61676265", "html_url": "https://github.com/rust-lang/rust/commit/8cbffc5bcfbc4696173678d50d519e9e61676265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cbffc5bcfbc4696173678d50d519e9e61676265/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22b36c70f936c647a589c266060651fb7cf1164f", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b36c70f936c647a589c266060651fb7cf1164f", "html_url": "https://github.com/rust-lang/rust/commit/22b36c70f936c647a589c266060651fb7cf1164f"}, {"sha": "cee244d4f02df90732c9e182f3567036ac695928", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee244d4f02df90732c9e182f3567036ac695928", "html_url": "https://github.com/rust-lang/rust/commit/cee244d4f02df90732c9e182f3567036ac695928"}], "stats": {"total": 1794, "additions": 1363, "deletions": 431}, "files": [{"sha": "71ca5ccdc8dfbe713d3dde62264a623f617c90c3", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -172,6 +172,7 @@ pub trait Iterator {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize where Self: Sized {\n         // Might overflow."}, {"sha": "ae1e311682617cbffb4215a2ed76cf6a62259590", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -510,6 +510,7 @@ impl<A, B> Iterator for Chain<A, B> where\n     }\n \n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     fn count(self) -> usize {\n         match self.state {\n             ChainState::Both => self.a.count() + self.b.count(),\n@@ -932,6 +933,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     ///\n     /// Might panic if the index of the element overflows a `usize`.\n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         self.iter.next().map(|a| {\n             let ret = (self.count, a);\n@@ -947,6 +949,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n         self.iter.nth(n).map(|a| {\n             let i = self.count + n;\n@@ -1008,6 +1011,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n     }\n \n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     fn count(self) -> usize {\n         (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n     }"}, {"sha": "883e9206dde1d3ad9e2a8fd3e4bc1b0c373ba939", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -1033,7 +1033,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n+        #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n             let mut acc = Self::one();\n@@ -1075,7 +1075,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n+        #[rustc_inherit_overflow_checks]\n         pub fn abs(self) -> Self {\n             if self.is_negative() {\n                 // Note that the #[inline] above means that the overflow\n@@ -2061,7 +2061,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n+        #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n             let mut acc = Self::one();"}, {"sha": "50c4dc697c2062f7de9c2f9e3661cc228749c27d", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -208,6 +208,7 @@ macro_rules! add_impl {\n             type Output = $t;\n \n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n \n@@ -261,6 +262,7 @@ macro_rules! sub_impl {\n             type Output = $t;\n \n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n \n@@ -314,6 +316,7 @@ macro_rules! mul_impl {\n             type Output = $t;\n \n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n \n@@ -511,6 +514,7 @@ macro_rules! neg_impl_core {\n             type Output = $t;\n \n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn neg(self) -> $t { let $id = self; $body }\n         }\n \n@@ -788,6 +792,7 @@ macro_rules! shl_impl {\n             type Output = $t;\n \n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn shl(self, other: $f) -> $t {\n                 self << other\n             }\n@@ -859,6 +864,7 @@ macro_rules! shr_impl {\n             type Output = $t;\n \n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn shr(self, other: $f) -> $t {\n                 self >> other\n             }\n@@ -923,6 +929,7 @@ macro_rules! add_assign_impl {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl AddAssign for $t {\n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn add_assign(&mut self, other: $t) { *self += other }\n         }\n     )+)\n@@ -967,6 +974,7 @@ macro_rules! sub_assign_impl {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl SubAssign for $t {\n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn sub_assign(&mut self, other: $t) { *self -= other }\n         }\n     )+)\n@@ -1011,6 +1019,7 @@ macro_rules! mul_assign_impl {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl MulAssign for $t {\n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn mul_assign(&mut self, other: $t) { *self *= other }\n         }\n     )+)\n@@ -1275,6 +1284,7 @@ macro_rules! shl_assign_impl {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for $t {\n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn shl_assign(&mut self, other: $f) {\n                 *self <<= other\n             }\n@@ -1337,6 +1347,7 @@ macro_rules! shr_assign_impl {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for $t {\n             #[inline]\n+            #[rustc_inherit_overflow_checks]\n             fn shr_assign(&mut self, other: $f) {\n                 *self >>= other\n             }"}, {"sha": "9666741d032b81386a1ba68d12323741442308e5", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,7 +10,7 @@\n \n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n-use rustc_const_math::{ConstUsize, ConstInt};\n+use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -354,6 +354,16 @@ pub enum TerminatorKind<'tcx> {\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>\n     },\n+\n+    /// Jump to the target if the condition has the expected value,\n+    /// otherwise panic with a message and a cleanup target.\n+    Assert {\n+        cond: Operand<'tcx>,\n+        expected: bool,\n+        msg: AssertMessage<'tcx>,\n+        target: BasicBlock,\n+        cleanup: Option<BasicBlock>\n+    }\n }\n \n impl<'tcx> Terminator<'tcx> {\n@@ -389,6 +399,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Drop { ref target, unwind: None, .. } => {\n                 slice::ref_slice(target).into_cow()\n             }\n+            Assert { target, cleanup: Some(unwind), .. } => vec![target, unwind].into_cow(),\n+            Assert { ref target, .. } => slice::ref_slice(target).into_cow(),\n         }\n     }\n \n@@ -413,6 +425,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Drop { ref mut target, unwind: None, .. } => {\n                 vec![target]\n             }\n+            Assert { ref mut target, cleanup: Some(ref mut unwind), .. } => vec![target, unwind],\n+            Assert { ref mut target, .. } => vec![target]\n         }\n     }\n }\n@@ -495,6 +509,26 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n+            Assert { ref cond, expected, ref msg, .. } => {\n+                write!(fmt, \"assert(\")?;\n+                if !expected {\n+                    write!(fmt, \"!\")?;\n+                }\n+                write!(fmt, \"{:?}, \", cond)?;\n+\n+                match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        write!(fmt, \"{:?}, {:?}, {:?}\",\n+                               \"index out of bounds: the len is {} but the index is {}\",\n+                               len, index)?;\n+                    }\n+                    AssertMessage::Math(ref err) => {\n+                        write!(fmt, \"{:?}\", err.description())?;\n+                    }\n+                }\n+\n+                write!(fmt, \")\")\n+            }\n         }\n     }\n \n@@ -532,10 +566,21 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Drop { unwind: Some(_), .. } => {\n                 vec![\"return\".into_cow(), \"unwind\".into_cow()]\n             }\n+            Assert { cleanup: None, .. } => vec![\"\".into()],\n+            Assert { .. } =>\n+                vec![\"success\".into_cow(), \"unwind\".into_cow()]\n         }\n     }\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AssertMessage<'tcx> {\n+    BoundsCheck {\n+        len: Operand<'tcx>,\n+        index: Operand<'tcx>\n+    },\n+    Math(ConstMathErr)\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // Statements\n@@ -787,6 +832,7 @@ pub enum Rvalue<'tcx> {\n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n     BinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n+    CheckedBinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n \n     UnaryOp(UnOp, Operand<'tcx>),\n \n@@ -880,6 +926,16 @@ pub enum BinOp {\n     Gt,\n }\n \n+impl BinOp {\n+    pub fn is_checkable(self) -> bool {\n+        use self::BinOp::*;\n+        match self {\n+            Add | Sub | Mul | Shl | Shr => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n@@ -898,6 +954,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Len(ref a) => write!(fmt, \"Len({:?})\", a),\n             Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?})\", lv, ty, kind),\n             BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n+            CheckedBinaryOp(ref op, ref a, ref b) => {\n+                write!(fmt, \"Checked{:?}({:?}, {:?})\", op, a, b)\n+            }\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n             InlineAsm { ref asm, ref outputs, ref inputs } => {"}, {"sha": "d0ac98a79587abf643317dcc1636e7382f9d98a3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -183,6 +183,13 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                 let rhs_ty = self.operand_ty(tcx, rhs);\n                 Some(self.binop_ty(tcx, op, lhs_ty, rhs_ty))\n             }\n+            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = self.operand_ty(tcx, lhs);\n+                let rhs_ty = self.operand_ty(tcx, rhs);\n+                let ty = self.binop_ty(tcx, op, lhs_ty, rhs_ty);\n+                let ty = tcx.mk_tup(vec![ty, tcx.types.bool]);\n+                Some(ty)\n+            }\n             Rvalue::UnaryOp(_, ref operand) => {\n                 Some(self.operand_ty(tcx, operand))\n             }"}, {"sha": "5c9582b945bb8b145211f3b6fa3663dc0dbe1d0e", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -127,6 +127,11 @@ macro_rules! make_mir_visitor {\n                 self.super_terminator_kind(block, kind);\n             }\n \n+            fn visit_assert_message(&mut self,\n+                                    msg: & $($mutability)* AssertMessage<'tcx>) {\n+                self.super_assert_message(msg);\n+            }\n+\n             fn visit_rvalue(&mut self,\n                             rvalue: & $($mutability)* Rvalue<'tcx>) {\n                 self.super_rvalue(rvalue);\n@@ -426,6 +431,31 @@ macro_rules! make_mir_visitor {\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n+\n+                    TerminatorKind::Assert { ref $($mutability)* cond,\n+                                             expected: _,\n+                                             ref $($mutability)* msg,\n+                                             target,\n+                                             cleanup } => {\n+                        self.visit_operand(cond);\n+                        self.visit_assert_message(msg);\n+                        self.visit_branch(block, target);\n+                        cleanup.map(|t| self.visit_branch(block, t));\n+                    }\n+                }\n+            }\n+\n+            fn super_assert_message(&mut self,\n+                                    msg: & $($mutability)* AssertMessage<'tcx>) {\n+                match *msg {\n+                    AssertMessage::BoundsCheck {\n+                        ref $($mutability)* len,\n+                        ref $($mutability)* index\n+                    } => {\n+                        self.visit_operand(len);\n+                        self.visit_operand(index);\n+                    }\n+                    AssertMessage::Math(_) => {}\n                 }\n             }\n \n@@ -461,6 +491,9 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::BinaryOp(_bin_op,\n+                                     ref $($mutability)* lhs,\n+                                     ref $($mutability)* rhs) |\n+                    Rvalue::CheckedBinaryOp(_bin_op,\n                                      ref $($mutability)* lhs,\n                                      ref $($mutability)* rhs) => {\n                         self.visit_operand(lhs);"}, {"sha": "81655b5e386f626ea074a7bc77da633b10270648", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -450,13 +450,14 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n             repr::TerminatorKind::Return |\n             repr::TerminatorKind::Resume => {}\n             repr::TerminatorKind::Goto { ref target } |\n+            repr::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n             repr::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n-\n             repr::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: None\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n+            repr::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n             repr::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n             repr::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: Some(ref unwind)"}, {"sha": "27d208240ac1cd2d8dc730585838f90ce8ef7bd7", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -595,7 +595,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                             bb_ctxt.on_operand(SK::Repeat, operand, source),\n                         Rvalue::Cast(ref _kind, ref operand, ref _ty) =>\n                             bb_ctxt.on_operand(SK::Cast, operand, source),\n-                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) => {\n+                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) |\n+                        Rvalue::CheckedBinaryOp(ref _binop, ref operand1, ref operand2) => {\n                             bb_ctxt.on_operand(SK::BinaryOp, operand1, source);\n                             bb_ctxt.on_operand(SK::BinaryOp, operand2, source);\n                         }\n@@ -662,6 +663,22 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                 bb_ctxt.on_operand(SK::If, cond, source);\n             }\n \n+            TerminatorKind::Assert {\n+                ref cond, expected: _,\n+                ref msg, target: _, cleanup: _\n+            } => {\n+                // The `cond` is always of (copyable) type `bool`,\n+                // so there will never be anything to move.\n+                let _ = cond;\n+                match *msg {\n+                    AssertMessage:: BoundsCheck { ref len, ref index } => {\n+                        // Same for the usize length and index in bounds-checking.\n+                        let _ = (len, index);\n+                    }\n+                    AssertMessage::Math(_) => {}\n+                }\n+            }\n+\n             TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n             TerminatorKind::Switch { adt_def: _, targets: _, ref discr } => {\n                 // The `discr` is not consumed; that is instead"}, {"sha": "785b734b79976b38a3ead4b7705292b8967855b6", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -380,12 +380,6 @@ pub enum ErrKind {\n     NotOn(ConstVal),\n     CallOn(ConstVal),\n \n-    DivideByZero,\n-    DivideWithOverflow,\n-    ModuloByZero,\n-    ModuloWithOverflow,\n-    ShiftLeftWithOverflow,\n-    ShiftRightWithOverflow,\n     MissingStructField,\n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n@@ -396,7 +390,7 @@ pub enum ErrKind {\n     IndexedNonVec,\n     IndexNegative,\n     IndexNotInt,\n-    IndexOutOfBounds,\n+    IndexOutOfBounds { len: u64, index: u64 },\n     RepeatCountNotNatural,\n     RepeatCountNotInt,\n \n@@ -436,12 +430,6 @@ impl ConstEvalErr {\n             NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n             CallOn(ref const_val) => format!(\"call on {}\", const_val.description()).into_cow(),\n \n-            DivideByZero         => \"attempted to divide by zero\".into_cow(),\n-            DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n-            ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n-            ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n-            ShiftLeftWithOverflow => \"attempted left shift with overflow\".into_cow(),\n-            ShiftRightWithOverflow => \"attempted right shift with overflow\".into_cow(),\n             MissingStructField  => \"nonexistent struct field\".into_cow(),\n             NonConstPath        => \"non-constant path in constant expression\".into_cow(),\n             UnimplementedConstVal(what) =>\n@@ -453,7 +441,10 @@ impl ConstEvalErr {\n             IndexedNonVec => \"indexing is only supported for arrays\".into_cow(),\n             IndexNegative => \"indices must be non-negative integers\".into_cow(),\n             IndexNotInt => \"indices must be integers\".into_cow(),\n-            IndexOutOfBounds => \"array index out of bounds\".into_cow(),\n+            IndexOutOfBounds { len, index } => {\n+                format!(\"index out of bounds: the len is {} but the index is {}\",\n+                        len, index).into_cow()\n+            }\n             RepeatCountNotNatural => \"repeat count must be a natural number\".into_cow(),\n             RepeatCountNotInt => \"repeat count must be integers\".into_cow(),\n \n@@ -847,30 +838,33 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n         assert_eq!(idx as usize as u64, idx);\n         match arr {\n-            Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n+            Array(_, n) if idx >= n => {\n+                signal!(e, IndexOutOfBounds { len: n, index: idx })\n+            }\n             Array(v, n) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n                 assert_eq!(n as usize as u64, n);\n                 eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args)?\n             } else {\n                 bug!()\n             },\n \n-            Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n+            Repeat(_, n) if idx >= n => {\n+                signal!(e, IndexOutOfBounds { len: n, index: idx })\n+            }\n             Repeat(elem, _) => eval_const_expr_partial(\n                 tcx,\n                 &tcx.map.expect_expr(elem),\n                 ty_hint,\n                 fn_args,\n             )?,\n \n-            ByteStr(ref data) if idx >= data.len() as u64 => signal!(e, IndexOutOfBounds),\n+            ByteStr(ref data) if idx >= data.len() as u64 => {\n+                signal!(e, IndexOutOfBounds { len: data.len() as u64, index: idx })\n+            }\n             ByteStr(data) => {\n                 Integral(U8(data[idx as usize]))\n             },\n \n-            Str(ref s) if idx as usize >= s.len() => signal!(e, IndexOutOfBounds),\n-            // FIXME: return a const char\n-            Str(_) => signal!(e, UnimplementedConstVal(\"indexing into str\")),\n             _ => signal!(e, IndexedNonVec),\n         }\n       }"}, {"sha": "9970810d4e278c58227bcf418a2abc4413ca5d5b", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast;\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n pub enum ConstMathErr {\n     NotInRange,\n     CmpBetweenUnequalTypes,\n@@ -25,7 +25,7 @@ pub enum ConstMathErr {\n }\n pub use self::ConstMathErr::*;\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n pub enum Op {\n     Add,\n     Sub,"}, {"sha": "bb5aca2d8d7c3db2d626c56c2ad5be1a43a62bb5", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -66,15 +66,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                            idx.clone(),\n                                                            Operand::Consume(len.clone())));\n \n-                let (success, failure) = (this.cfg.start_new_block(), this.cfg.start_new_block());\n-                this.cfg.terminate(block,\n-                                   scope_id,\n-                                   expr_span,\n-                                   TerminatorKind::If {\n-                                       cond: Operand::Consume(lt),\n-                                       targets: (success, failure),\n-                                   });\n-                this.panic_bounds_check(failure, idx.clone(), Operand::Consume(len), expr_span);\n+                let msg = AssertMessage::BoundsCheck {\n+                    len: Operand::Consume(len),\n+                    index: idx.clone()\n+                };\n+                let success = this.assert(block, Operand::Consume(lt), true,\n+                                          msg, expr_span);\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {"}, {"sha": "67cf5473f79c0855d48bae1a74cd617fcfa591c0", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 168, "deletions": 1, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,12 +10,20 @@\n \n //! See docs in build/expr/mod.rs\n \n+use std;\n+\n+use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fnv::FnvHashMap;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n+use rustc_const_math::{ConstInt, ConstIsize};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty;\n use rustc::mir::repr::*;\n+use syntax::ast;\n+use syntax::codemap::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an rvalue.\n@@ -66,10 +74,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(block = this.as_operand(block, lhs));\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n-                block.and(Rvalue::BinaryOp(op, lhs, rhs))\n+                this.build_binary_op(block, op, expr_span, expr.ty,\n+                                     lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n                 let arg = unpack!(block = this.as_operand(block, arg));\n+                // Check for -MIN on signed integers\n+                if this.hir.check_overflow() && op == UnOp::Neg && expr.ty.is_signed() {\n+                    let bool_ty = this.hir.bool_ty();\n+\n+                    let minval = this.minval_literal(expr_span, expr.ty);\n+                    let is_min = this.temp(bool_ty);\n+\n+                    this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n+                                         Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n+\n+                    let err = ConstMathErr::Overflow(Op::Neg);\n+                    block = this.assert(block, Operand::Consume(is_min), false,\n+                                        AssertMessage::Math(err), expr_span);\n+                }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n             ExprKind::Box { value, value_extents } => {\n@@ -218,4 +241,148 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn build_binary_op(&mut self, mut block: BasicBlock,\n+                           op: BinOp, span: Span, ty: ty::Ty<'tcx>,\n+                           lhs: Operand<'tcx>, rhs: Operand<'tcx>) -> BlockAnd<Rvalue<'tcx>> {\n+        let scope_id = self.innermost_scope_id();\n+        let bool_ty = self.hir.bool_ty();\n+        if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n+            let result_tup = self.hir.tcx().mk_tup(vec![ty, bool_ty]);\n+            let result_value = self.temp(result_tup);\n+\n+            self.cfg.push_assign(block, scope_id, span,\n+                                 &result_value, Rvalue::CheckedBinaryOp(op,\n+                                                                        lhs,\n+                                                                        rhs));\n+            let val_fld = Field::new(0);\n+            let of_fld = Field::new(1);\n+\n+            let val = result_value.clone().field(val_fld, ty);\n+            let of = result_value.field(of_fld, bool_ty);\n+\n+            let err = ConstMathErr::Overflow(match op {\n+                BinOp::Add => Op::Add,\n+                BinOp::Sub => Op::Sub,\n+                BinOp::Mul => Op::Mul,\n+                BinOp::Shl => Op::Shl,\n+                BinOp::Shr => Op::Shr,\n+                _ => {\n+                    bug!(\"MIR build_binary_op: {:?} is not checkable\", op)\n+                }\n+            });\n+\n+            block = self.assert(block, Operand::Consume(of), false,\n+                                AssertMessage::Math(err), span);\n+\n+            block.and(Rvalue::Use(Operand::Consume(val)))\n+        } else {\n+            if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n+                // Checking division and remainder is more complex, since we 1. always check\n+                // and 2. there are two possible failure cases, divide-by-zero and overflow.\n+\n+                let (zero_err, overflow_err) = if op == BinOp::Div {\n+                    (ConstMathErr::DivisionByZero,\n+                     ConstMathErr::Overflow(Op::Div))\n+                } else {\n+                    (ConstMathErr::RemainderByZero,\n+                     ConstMathErr::Overflow(Op::Rem))\n+                };\n+\n+                // Check for / 0\n+                let is_zero = self.temp(bool_ty);\n+                let zero = self.zero_literal(span, ty);\n+                self.cfg.push_assign(block, scope_id, span, &is_zero,\n+                                     Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n+\n+                block = self.assert(block, Operand::Consume(is_zero), false,\n+                                    AssertMessage::Math(zero_err), span);\n+\n+                // We only need to check for the overflow in one case:\n+                // MIN / -1, and only for signed values.\n+                if ty.is_signed() {\n+                    let neg_1 = self.neg_1_literal(span, ty);\n+                    let min = self.minval_literal(span, ty);\n+\n+                    let is_neg_1 = self.temp(bool_ty);\n+                    let is_min   = self.temp(bool_ty);\n+                    let of       = self.temp(bool_ty);\n+\n+                    // this does (rhs == -1) & (lhs == MIN). It could short-circuit instead\n+\n+                    self.cfg.push_assign(block, scope_id, span, &is_neg_1,\n+                                         Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), neg_1));\n+                    self.cfg.push_assign(block, scope_id, span, &is_min,\n+                                         Rvalue::BinaryOp(BinOp::Eq, lhs.clone(), min));\n+\n+                    let is_neg_1 = Operand::Consume(is_neg_1);\n+                    let is_min = Operand::Consume(is_min);\n+                    self.cfg.push_assign(block, scope_id, span, &of,\n+                                         Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n+\n+                    block = self.assert(block, Operand::Consume(of), false,\n+                                        AssertMessage::Math(overflow_err), span);\n+                }\n+            }\n+\n+            block.and(Rvalue::BinaryOp(op, lhs, rhs))\n+        }\n+    }\n+\n+    // Helper to get a `-1` value of the appropriate type\n+    fn neg_1_literal(&mut self, span: Span, ty: ty::Ty<'tcx>) -> Operand<'tcx> {\n+        let literal = match ty.sty {\n+            ty::TyInt(ity) => {\n+                let val = match ity {\n+                    ast::IntTy::I8  => ConstInt::I8(-1),\n+                    ast::IntTy::I16 => ConstInt::I16(-1),\n+                    ast::IntTy::I32 => ConstInt::I32(-1),\n+                    ast::IntTy::I64 => ConstInt::I64(-1),\n+                    ast::IntTy::Is => {\n+                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let val = ConstIsize::new(-1, int_ty).unwrap();\n+                        ConstInt::Isize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            _ => {\n+                span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n+            }\n+        };\n+\n+        self.literal_operand(span, ty, literal)\n+    }\n+\n+    // Helper to get the minimum value of the appropriate type\n+    fn minval_literal(&mut self, span: Span, ty: ty::Ty<'tcx>) -> Operand<'tcx> {\n+        let literal = match ty.sty {\n+            ty::TyInt(ity) => {\n+                let val = match ity {\n+                    ast::IntTy::I8  => ConstInt::I8(std::i8::MIN),\n+                    ast::IntTy::I16 => ConstInt::I16(std::i16::MIN),\n+                    ast::IntTy::I32 => ConstInt::I32(std::i32::MIN),\n+                    ast::IntTy::I64 => ConstInt::I64(std::i64::MIN),\n+                    ast::IntTy::Is => {\n+                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let min = match int_ty {\n+                            ast::IntTy::I32 => std::i32::MIN as i64,\n+                            ast::IntTy::I64 => std::i64::MIN,\n+                            _ => unreachable!()\n+                        };\n+                        let val = ConstIsize::new(min, int_ty).unwrap();\n+                        ConstInt::Isize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            _ => {\n+                span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)\n+            }\n+        };\n+\n+        self.literal_operand(span, ty, literal)\n+    }\n }"}, {"sha": "24369aaff3f5c89c9dc7a2affa215fec29623e02", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -63,17 +63,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n \n+                let lhs = this.hir.mirror(lhs);\n+                let lhs_ty = lhs.ty;\n+\n                 // As above, RTL.\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n \n                 // we don't have to drop prior contents or anything\n                 // because AssignOp is only legal for Copy types\n                 // (overloaded ops should be desugared into a call).\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Consume(lhs.clone()),\n-                                                      rhs));\n+                let result = unpack!(block = this.build_binary_op(block, op, expr_span, lhs_ty,\n+                                                  Operand::Consume(lhs.clone()), rhs));\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs, result);\n \n                 block.unit()\n             }"}, {"sha": "00e89095276312df1e1bf599846ac7f4b44e53a9", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -12,9 +12,14 @@\n //! kind of thing.\n \n use build::Builder;\n-use rustc::ty::Ty;\n+\n+use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{self, Ty};\n+\n use rustc::mir::repr::*;\n use std::u32;\n+use syntax::ast;\n use syntax::codemap::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -50,6 +55,53 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         Rvalue::Aggregate(AggregateKind::Tuple, vec![])\n     }\n \n+    // Returns a zero literal operand for the appropriate type, works for\n+    // bool, char, integers and floats.\n+    pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+        let literal = match ty.sty {\n+            ty::TyBool => {\n+                self.hir.false_literal()\n+            }\n+            ty::TyChar => Literal::Value { value: ConstVal::Char('\\0') },\n+            ty::TyUint(ity) => {\n+                let val = match ity {\n+                    ast::UintTy::U8  => ConstInt::U8(0),\n+                    ast::UintTy::U16 => ConstInt::U16(0),\n+                    ast::UintTy::U32 => ConstInt::U32(0),\n+                    ast::UintTy::U64 => ConstInt::U64(0),\n+                    ast::UintTy::Us => {\n+                        let uint_ty = self.hir.tcx().sess.target.uint_type;\n+                        let val = ConstUsize::new(0, uint_ty).unwrap();\n+                        ConstInt::Usize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            ty::TyInt(ity) => {\n+                let val = match ity {\n+                    ast::IntTy::I8  => ConstInt::I8(0),\n+                    ast::IntTy::I16 => ConstInt::I16(0),\n+                    ast::IntTy::I32 => ConstInt::I32(0),\n+                    ast::IntTy::I64 => ConstInt::I64(0),\n+                    ast::IntTy::Is => {\n+                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let val = ConstIsize::new(0, int_ty).unwrap();\n+                        ConstInt::Isize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            ty::TyFloat(_) => Literal::Value { value: ConstVal::Float(0.0) },\n+            _ => {\n+                span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)\n+            }\n+        };\n+\n+        self.literal_operand(span, ty, literal)\n+    }\n+\n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n                       scope_id: ScopeId,"}, {"sha": "209649dd2fd1832a2f8f335ca24dafeb78bce770", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -517,7 +517,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n \n-\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n                                   span: Span,\n@@ -538,48 +537,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-    // Panicking\n-    // =========\n-    // FIXME: should be moved into their own module\n-    pub fn panic_bounds_check(&mut self,\n-                              block: BasicBlock,\n-                              index: Operand<'tcx>,\n-                              len: Operand<'tcx>,\n-                              span: Span) {\n-        // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n-        let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n-        let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n-        let args = self.hir.tcx().replace_late_bound_regions(&func.ty.fn_args(), |_| region).0;\n-\n-        let ref_ty = args[0];\n-        let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n-            tyandmut.ty\n-        } else {\n-            span_bug!(span, \"unexpected panic_bound_check type: {:?}\", func.ty);\n-        };\n-\n-        let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n-        let (file, line) = self.span_to_fileline_args(span);\n-        let elems = vec![Operand::Constant(file), Operand::Constant(line)];\n-        let scope_id = self.innermost_scope_id();\n-        // FIXME: We should have this as a constant, rather than a stack variable (to not pollute\n-        // icache with cold branch code), however to achieve that we either have to rely on rvalue\n-        // promotion or have some way, in MIR, to create constants.\n-        self.cfg.push_assign(block, scope_id, span, &tuple, // tuple = (file_arg, line_arg);\n-                             Rvalue::Aggregate(AggregateKind::Tuple, elems));\n-        // FIXME: is this region really correct here?\n-        self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n-                             Rvalue::Ref(region, BorrowKind::Shared, tuple));\n-        let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n-            func: Operand::Constant(func),\n-            args: vec![Operand::Consume(tuple_ref), index, len],\n-            destination: None,\n-            cleanup: cleanup,\n-        });\n-    }\n-\n     /// Create diverge cleanup and branch to it from `block`.\n+    // FIXME: Remove this (used only for unreachable cases in match).\n     pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n         // fn(&(msg: &'static str filename: &'static str, line: u32)) -> !\n         let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n@@ -622,6 +581,32 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         });\n     }\n \n+    /// Create an Assert terminator and return the success block.\n+    /// If the boolean condition operand is not the expected value,\n+    /// a runtime panic will be caused with the given message.\n+    pub fn assert(&mut self, block: BasicBlock,\n+                  cond: Operand<'tcx>,\n+                  expected: bool,\n+                  msg: AssertMessage<'tcx>,\n+                  span: Span)\n+                  -> BasicBlock {\n+        let scope_id = self.innermost_scope_id();\n+\n+        let success_block = self.cfg.start_new_block();\n+        let cleanup = self.diverge_cleanup();\n+\n+        self.cfg.terminate(block, scope_id, span,\n+                           TerminatorKind::Assert {\n+                               cond: cond,\n+                               expected: expected,\n+                               msg: msg,\n+                               target: success_block,\n+                               cleanup: cleanup\n+                           });\n+\n+        success_block\n+    }\n+\n     fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Constant<'tcx> {\n         let funcdid = match self.hir.tcx().lang_items.require(lang_item) {\n             Ok(d) => d,"}, {"sha": "25860ae7ef1ee606d3e0bb1a630157e94f412c65", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -17,32 +17,70 @@\n \n use hair::*;\n use rustc::mir::repr::*;\n+use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::FnKind;\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::parse::token;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n+use syntax::attr::AttrMetaMethods;\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    constness: hir::Constness\n+    constness: hir::Constness,\n+\n+    /// True if this constant/function needs overflow checks.\n+    check_overflow: bool\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               constness: hir::Constness)\n+               src: MirSource)\n                -> Cx<'a, 'gcx, 'tcx> {\n+        let constness = match src {\n+            MirSource::Const(_) |\n+            MirSource::Static(..) => hir::Constness::Const,\n+            MirSource::Fn(id) => {\n+                let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n+                match fn_like.map(|f| f.kind()) {\n+                    Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n+                    Some(FnKind::Method(_, m, _, _)) => m.constness,\n+                    _ => hir::Constness::NotConst\n+                }\n+            }\n+            MirSource::Promoted(..) => bug!()\n+        };\n+\n+        let attrs = infcx.tcx.map.attrs(src.item_id());\n+\n+        // Some functions always have overflow checks enabled,\n+        // however, they may not get codegen'd, depending on\n+        // the settings for the crate they are translated in.\n+        let mut check_overflow = attrs.iter().any(|item| {\n+            item.check_name(\"rustc_inherit_overflow_checks\")\n+        });\n+\n+        // Respect -Z force-overflow-checks=on and -C debug-assertions.\n+        check_overflow |= infcx.tcx.sess.opts.debugging_opts.force_overflow_checks\n+               .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n+\n+        // Constants and const fn's always need overflow checks.\n+        check_overflow |= constness == hir::Constness::Const;\n+\n         Cx {\n             tcx: infcx.tcx,\n             infcx: infcx,\n             constness: constness,\n+            check_overflow: check_overflow\n         }\n     }\n }\n@@ -154,6 +192,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n+\n+    pub fn check_overflow(&self) -> bool {\n+        self.check_overflow\n+    }\n }\n \n mod block;"}, {"sha": "a55fbe3641c665c2d5f28ca00111635ddfc74cef", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -32,7 +32,6 @@ use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n-use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -116,20 +115,7 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n     {\n         let src = self.src;\n         let mir = self.infcx.enter(|infcx| {\n-            let constness = match src {\n-                MirSource::Const(_) |\n-                MirSource::Static(..) => hir::Constness::Const,\n-                MirSource::Fn(id) => {\n-                    let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n-                    match fn_like.map(|f| f.kind()) {\n-                        Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n-                        Some(FnKind::Method(_, m, _, _)) => m.constness,\n-                        _ => hir::Constness::NotConst\n-                    }\n-                }\n-                MirSource::Promoted(..) => bug!()\n-            };\n-            let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n+            let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, src));\n \n             // Convert the Mir to global types.\n             let mut globalizer = GlobalizeMir {"}, {"sha": "590106e0a225be4eef740171ae90c24705eb203d", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -30,6 +30,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n                 /* nothing to do */\n             },\n             TerminatorKind::Call { cleanup: ref mut unwind, .. } |\n+            TerminatorKind::Assert { cleanup: ref mut unwind, .. } |\n             TerminatorKind::DropAndReplace { ref mut unwind, .. } |\n             TerminatorKind::Drop { ref mut unwind, .. } => {\n                 unwind.take();"}, {"sha": "b9eec6ecd9c5890260911d971a404a8ce0d30586", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 64, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -332,61 +332,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Returns true if the block ends in a bounds check branch, i.e.:\n-    /// len = Len(array);\n-    /// cond = Lt(idx, len);\n-    /// if cond {\n-    ///     ...\n-    /// } else {\n-    ///     loc = (...);\n-    ///     loc_ref = &loc;\n-    ///     panic_bounds_check(loc_ref, idx, len);\n-    /// }\n-    fn is_bounds_check(&self, bb: BasicBlock,\n-                       cond_op: &Operand<'tcx>,\n-                       if_else: BasicBlock) -> bool {\n-        use rustc::mir::repr::Lvalue::*;\n-        use rustc::mir::repr::Operand::Consume;\n-        use rustc::mir::repr::Rvalue::*;\n-        use rustc::mir::repr::StatementKind::*;\n-        use rustc::mir::repr::TerminatorKind::*;\n-\n-        let stmts = &self.mir[bb].statements;\n-        let stmts_panic = &self.mir[if_else].statements;\n-        if stmts.len() < 2 || stmts_panic.len() != 2 {\n-            return false;\n-        }\n-\n-        let all = (&stmts[stmts.len() - 2].kind,\n-                   &stmts[stmts.len() - 1].kind,\n-                   cond_op,\n-                   &stmts_panic[0].kind,\n-                   &stmts_panic[1].kind,\n-                   &self.mir[if_else].terminator().kind);\n-        match all {\n-            (&Assign(Temp(len), Len(_)),\n-             &Assign(Temp(cond), BinaryOp(BinOp::Lt, ref idx, Consume(Temp(len2)))),\n-             /* if */ &Consume(Temp(cond2)), /* {...} else */\n-             &Assign(Temp(loc), Aggregate(..)),\n-             &Assign(Temp(loc_ref), Ref(_, _, Temp(loc2))),\n-             &Call {\n-                func: Operand::Constant(Constant {\n-                    literal: Literal::Item { def_id, .. }, ..\n-                }),\n-                ref args,\n-                destination: None,\n-                ..\n-            }) => {\n-                len == len2 && cond == cond2 && loc == loc2 &&\n-                args[0] == Consume(Temp(loc_ref)) &&\n-                args[1] == *idx &&\n-                args[2] == Consume(Temp(len)) &&\n-                Some(def_id) == self.tcx.lang_items.panic_bounds_check_fn()\n-            }\n-            _ => false\n-        }\n-    }\n-\n     /// Qualify a whole const, static initializer or const fn.\n     fn qualify_const(&mut self) -> Qualif {\n         let mir = self.mir;\n@@ -402,6 +347,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::Goto { target } |\n                 // Drops are considered noops.\n                 TerminatorKind::Drop { target, .. } |\n+                TerminatorKind::Assert { target, .. } |\n                 TerminatorKind::Call { destination: Some((_, target)), .. } => {\n                     Some(target)\n                 }\n@@ -411,15 +357,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     return Qualif::empty();\n                 }\n \n-                // Need to allow bounds checking branches.\n-                TerminatorKind::If { ref cond, targets: (if_true, if_else) } => {\n-                    if self.is_bounds_check(bb, cond, if_else) {\n-                        Some(if_true)\n-                    } else {\n-                        None\n-                    }\n-                }\n-\n+                TerminatorKind::If {..} |\n                 TerminatorKind::Switch {..} |\n                 TerminatorKind::SwitchInt {..} |\n                 TerminatorKind::DropAndReplace { .. } |\n@@ -630,6 +568,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::Use(_) |\n             Rvalue::Repeat(..) |\n             Rvalue::UnaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n             Rvalue::Cast(CastKind::ReifyFnPointer, _, _) |\n             Rvalue::Cast(CastKind::UnsafeFnPointer, _, _) |\n             Rvalue::Cast(CastKind::Unsize, _, _) => {}"}, {"sha": "d008918026ab8bab84a21753af82bb93bcab2889", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -181,7 +181,17 @@ fn simplify_branches(mir: &mut Mir) {\n                     }\n                 }\n \n+                TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n+                    literal: Literal::Value {\n+                        value: ConstVal::Bool(cond)\n+                    }, ..\n+                }), expected, .. } if cond == expected => {\n+                    changed = true;\n+                    TerminatorKind::Goto { target: target }\n+                }\n+\n                 TerminatorKind::SwitchInt { ref targets, .. } if targets.len() == 1 => {\n+                    changed = true;\n                     TerminatorKind::Goto { target: targets[0] }\n                 }\n                 _ => continue"}, {"sha": "019ed670d1f83d16cec395d97deec990a4c77faa", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -431,6 +431,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.check_call_inputs(mir, term, &sig, args);\n                 }\n             }\n+            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+                let cond_ty = mir.operand_ty(tcx, cond);\n+                if cond_ty != tcx.types.bool {\n+                    span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n+                }\n+\n+                if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                    if mir.operand_ty(tcx, len) != tcx.types.usize {\n+                        span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n+                    }\n+                    if mir.operand_ty(tcx, index) != tcx.types.usize {\n+                        span_mirbug!(self, index, \"bounds-check index non-usize {:?}\", index)\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -561,7 +576,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Drop { target, unwind, .. } |\n-            TerminatorKind::DropAndReplace { target, unwind, .. } => {\n+            TerminatorKind::DropAndReplace { target, unwind, .. } |\n+            TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n                 self.assert_iscleanup(mir, block, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {"}, {"sha": "f524bc8596a5460d6b6d6823e5542d95cd22e59f", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -880,7 +880,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                rhs_t: Ty<'tcx>,\n                                debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n-        let did = langcall(bcx,\n+        let did = langcall(bcx.tcx(),\n                            None,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);"}, {"sha": "cd20a75db81bfab83acb10fd240243622c8abca4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -769,12 +769,12 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                              rhs: ValueRef,\n                                              rhs_t: Ty<'tcx>)\n                                              -> Block<'blk, 'tcx> {\n-    let (zero_text, overflow_text) = if divrem.node == hir::BiDiv {\n-        (\"attempted to divide by zero\",\n-         \"attempted to divide with overflow\")\n+    use rustc_const_math::{ConstMathErr, Op};\n+\n+    let (zero_err, overflow_err) = if divrem.node == hir::BiDiv {\n+        (ConstMathErr::DivisionByZero, ConstMathErr::Overflow(Op::Div))\n     } else {\n-        (\"attempted remainder with a divisor of zero\",\n-         \"attempted remainder with overflow\")\n+        (ConstMathErr::RemainderByZero, ConstMathErr::Overflow(Op::Rem))\n     };\n     let debug_loc = call_info.debug_loc();\n \n@@ -802,7 +802,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, call_info, InternedString::new(zero_text))\n+        controlflow::trans_fail(bcx, call_info, InternedString::new(zero_err.description()))\n     });\n \n     // To quote LLVM's documentation for the sdiv instruction:\n@@ -828,7 +828,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               C_integral(llty, min, true),\n                               debug_loc);\n             with_cond(bcx, is_min, |bcx| {\n-                controlflow::trans_fail(bcx, call_info, InternedString::new(overflow_text))\n+                controlflow::trans_fail(bcx, call_info,\n+                                        InternedString::new(overflow_err.description()))\n             })\n         })\n     } else {"}, {"sha": "884833ca79a2fec425e1fefbd45b983f06993137", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -39,6 +39,7 @@ use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::Layout;\n use rustc::traits::{self, SelectionContext, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::hir;\n@@ -99,6 +100,63 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     }\n }\n \n+/// Returns Some([a, b]) if the type has a pair of fields with types a and b.\n+pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n+                                  -> Option<[Ty<'tcx>; 2]> {\n+    match ty.sty {\n+        ty::TyEnum(adt, substs) | ty::TyStruct(adt, substs) => {\n+            assert_eq!(adt.variants.len(), 1);\n+            let fields = &adt.variants[0].fields;\n+            if fields.len() != 2 {\n+                return None;\n+            }\n+            Some([monomorphize::field_ty(ccx.tcx(), substs, &fields[0]),\n+                  monomorphize::field_ty(ccx.tcx(), substs, &fields[1])])\n+        }\n+        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+        ty::TyTuple(tys) => {\n+            if tys.len() != 2 {\n+                return None;\n+            }\n+            Some([tys[0], tys[1]])\n+        }\n+        _ => None\n+    }\n+}\n+\n+/// Returns true if the type is represented as a pair of immediates.\n+pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n+                                  -> bool {\n+    let tcx = ccx.tcx();\n+    let layout = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+        match ty.layout(&infcx) {\n+            Ok(layout) => layout,\n+            Err(err) => {\n+                bug!(\"type_is_imm_pair: layout for `{:?}` failed: {}\",\n+                     ty, err);\n+            }\n+        }\n+    });\n+\n+    match *layout {\n+        Layout::FatPointer { .. } => true,\n+        Layout::Univariant { ref variant, .. } => {\n+            // There must be only 2 fields.\n+            if variant.offset_after_field.len() != 2 {\n+                return false;\n+            }\n+\n+            match type_pair_fields(ccx, ty) {\n+                Some([a, b]) => {\n+                    type_is_immediate(ccx, a) && type_is_immediate(ccx, b)\n+                }\n+                None => false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     use machine::llsize_of_alloc;\n@@ -1165,18 +1223,18 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-pub fn langcall(bcx: Block,\n+pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,\n                 li: LangItem)\n                 -> DefId {\n-    match bcx.tcx().lang_items.require(li) {\n+    match tcx.lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[..]),\n-                None => bcx.tcx().sess.fatal(&msg[..]),\n+                Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n+                None => tcx.sess.fatal(&msg[..]),\n             }\n         }\n     }"}, {"sha": "6788d5de6d8698218f37ae5f6e986033d6bbc494", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -716,7 +716,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if iv >= len {\n                 // FIXME #3170: report this earlier on in the const-eval\n                 // pass. Reporting here is a bit late.\n-                const_err(cx, e.span, Err(ErrKind::IndexOutOfBounds), trueconst)?;\n+                const_err(cx, e.span, Err(ErrKind::IndexOutOfBounds {\n+                    len: len,\n+                    index: iv\n+                }), trueconst)?;\n                 C_undef(val_ty(arr).element_type())\n             } else {\n                 const_get_elt(arr, &[iv as c_uint])"}, {"sha": "0f686227c6f98f3241f980a5ece22ac8cfb093c8", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -400,7 +400,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let align = machine::llalign_of_min(ccx, val_ty(expr_file_line_const));\n     let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n-    let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n+    let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicFnLangItem);\n     Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }\n@@ -428,7 +428,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let align = machine::llalign_of_min(ccx, val_ty(file_line_const));\n     let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n-    let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n+    let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }"}, {"sha": "09fd3abd91f11cd58cc586513b2a6b2b062074c7", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -2220,6 +2220,8 @@ impl OverflowOpViaIntrinsic {\n                                         rhs: ValueRef,\n                                         binop_debug_loc: DebugLoc)\n                                         -> (Block<'blk, 'tcx>, ValueRef) {\n+        use rustc_const_math::{ConstMathErr, Op};\n+\n         let llfn = self.to_intrinsic(bcx, lhs_t);\n \n         let val = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n@@ -2230,13 +2232,19 @@ impl OverflowOpViaIntrinsic {\n                         binop_debug_loc);\n \n         let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n-        Call(bcx, expect, &[cond, C_integral(Type::i1(bcx.ccx()), 0, false)],\n-             binop_debug_loc);\n+        let expected = Call(bcx, expect, &[cond, C_bool(bcx.ccx(), false)],\n+                            binop_debug_loc);\n+\n+        let op = match *self {\n+            OverflowOpViaIntrinsic::Add => Op::Add,\n+            OverflowOpViaIntrinsic::Sub => Op::Sub,\n+            OverflowOpViaIntrinsic::Mul => Op::Mul\n+        };\n \n         let bcx =\n-            base::with_cond(bcx, cond, |bcx|\n+            base::with_cond(bcx, expected, |bcx|\n                 controlflow::trans_fail(bcx, info,\n-                    InternedString::new(\"arithmetic operation overflowed\")));\n+                    InternedString::new(ConstMathErr::Overflow(op).description())));\n \n         (bcx, result)\n     }\n@@ -2252,6 +2260,8 @@ impl OverflowOpViaInputCheck {\n                                           binop_debug_loc: DebugLoc)\n                                           -> (Block<'blk, 'tcx>, ValueRef)\n     {\n+        use rustc_const_math::{ConstMathErr, Op};\n+\n         let lhs_llty = val_ty(lhs);\n         let rhs_llty = val_ty(rhs);\n \n@@ -2266,16 +2276,16 @@ impl OverflowOpViaInputCheck {\n \n         let outer_bits = And(bcx, rhs, invert_mask, binop_debug_loc);\n         let cond = build_nonzero_check(bcx, outer_bits, binop_debug_loc);\n-        let result = match *self {\n+        let (result, op) = match *self {\n             OverflowOpViaInputCheck::Shl =>\n-                build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n+                (build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc), Op::Shl),\n             OverflowOpViaInputCheck::Shr =>\n-                build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc),\n+                (build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc), Op::Shr)\n         };\n         let bcx =\n             base::with_cond(bcx, cond, |bcx|\n                 controlflow::trans_fail(bcx, info,\n-                    InternedString::new(\"shift operation overflowed\")));\n+                    InternedString::new(ConstMathErr::Overflow(op).description())));\n \n         (bcx, result)\n     }"}, {"sha": "211efeb4e4baa6209ee8f8cb8797cbd206bd032b", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -53,7 +53,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n \n-    let def_id = langcall(bcx, None, \"\", ExchangeFreeFnLangItem);\n+    let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n     Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n         .call(bcx, debug_loc, ArgVals(&args), None).bcx"}, {"sha": "59143bc01bf7a7ce74b0b3323f0b5d6e38dda653", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -39,6 +39,8 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n             // in an ValueRef without an alloca.\n             assert!(common::type_is_immediate(bcx.ccx(), ty) ||\n                     common::type_is_fat_ptr(bcx.tcx(), ty));\n+        } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n+            // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n             // type_is_immediate() may *still* be true, particularly\n@@ -111,6 +113,21 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n                     context: LvalueContext) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n+        // Allow uses of projections of immediate pair fields.\n+        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n+            if let mir::Lvalue::Temp(index) = proj.base {\n+                let ty = self.mir.temp_decls[index as usize].ty;\n+                let ty = self.bcx.monomorphize(&ty);\n+                if common::type_is_imm_pair(self.bcx.ccx(), ty) {\n+                    if let mir::ProjectionElem::Field(..) = proj.elem {\n+                        if let LvalueContext::Consume = context {\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         match *lvalue {\n             mir::Lvalue::Temp(index) => {\n                 match context {\n@@ -161,6 +178,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n                     /* nothing to do */\n                 }\n                 TerminatorKind::Call { cleanup: unwind, .. } |\n+                TerminatorKind::Assert { cleanup: unwind, .. } |\n                 TerminatorKind::DropAndReplace { unwind, .. } |\n                 TerminatorKind::Drop { unwind, .. } => {\n                     if let Some(unwind) = unwind {"}, {"sha": "b7aca4c8d7fed0fcd304cc8ded79840a7ac55fb0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 233, "deletions": 43, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -9,29 +9,37 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n+use rustc_const_eval::ErrKind;\n+use rustc::middle::lang_items;\n use rustc::ty;\n use rustc::mir::repr as mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, LandingPad, C_undef};\n+use common::{self, Block, BlockAndBuilder, LandingPad};\n+use common::{C_bool, C_str_slice, C_struct, C_u32, C_uint, C_undef};\n+use consts;\n use debuginfo::DebugLoc;\n use Disr;\n-use machine::{llalign_of_min, llbitsize_of_real};\n+use machine::{llalign_of_min, llbitsize_of_real, llsize_of_store};\n use meth;\n use type_of;\n use glue;\n use type_::Type;\n+\n use rustc_data_structures::fnv::FnvHashMap;\n+use syntax::parse::token;\n \n use super::{MirContext, TempRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n+use super::operand::OperandValue::*;\n+\n+use std::cmp;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n@@ -212,6 +220,110 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n+            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                let cond = self.trans_operand(&bcx, cond).immediate();\n+                let const_cond = common::const_to_opt_uint(cond).map(|c| c == 1);\n+\n+                // Don't translate the panic block if success if known.\n+                if const_cond == Some(expected) {\n+                    funclet_br(self, bcx, target);\n+                    return;\n+                }\n+\n+                // Pass the condition through llvm.expect for branch hinting.\n+                let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx(), expected)], None);\n+\n+                // Create the failure block and the conditional branch to it.\n+                let lltarget = llblock(self, target);\n+                let panic_block = self.fcx.new_block(\"panic\", None);\n+                if expected {\n+                    bcx.cond_br(cond, lltarget, panic_block.llbb);\n+                } else {\n+                    bcx.cond_br(cond, panic_block.llbb, lltarget);\n+                }\n+\n+                // After this point, bcx is the block for the call to panic.\n+                bcx = panic_block.build();\n+\n+                // Get the location information.\n+                let loc = bcx.sess().codemap().lookup_char_pos(terminator.span.lo);\n+                let filename = token::intern_and_get_ident(&loc.file.name);\n+                let filename = C_str_slice(bcx.ccx(), filename);\n+                let line = C_u32(bcx.ccx(), loc.line as u32);\n+\n+                // Put together the arguments to the panic entry point.\n+                let (lang_item, args, const_err) = match *msg {\n+                    mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        let len = self.trans_operand(&mut bcx, len).immediate();\n+                        let index = self.trans_operand(&mut bcx, index).immediate();\n+\n+                        let const_err = common::const_to_opt_uint(len).and_then(|len| {\n+                            common::const_to_opt_uint(index).map(|index| {\n+                                ErrKind::IndexOutOfBounds {\n+                                    len: len,\n+                                    index: index\n+                                }\n+                            })\n+                        });\n+\n+                        let file_line = C_struct(bcx.ccx(), &[filename, line], false);\n+                        let align = llalign_of_min(bcx.ccx(), common::val_ty(file_line));\n+                        let file_line = consts::addr_of(bcx.ccx(),\n+                                                        file_line,\n+                                                        align,\n+                                                        \"panic_bounds_check_loc\");\n+                        (lang_items::PanicBoundsCheckFnLangItem,\n+                         vec![file_line, index, len],\n+                         const_err)\n+                    }\n+                    mir::AssertMessage::Math(ref err) => {\n+                        let msg_str = token::intern_and_get_ident(err.description());\n+                        let msg_str = C_str_slice(bcx.ccx(), msg_str);\n+                        let msg_file_line = C_struct(bcx.ccx(),\n+                                                     &[msg_str, filename, line],\n+                                                     false);\n+                        let align = llalign_of_min(bcx.ccx(), common::val_ty(msg_file_line));\n+                        let msg_file_line = consts::addr_of(bcx.ccx(),\n+                                                            msg_file_line,\n+                                                            align,\n+                                                            \"panic_loc\");\n+                        (lang_items::PanicFnLangItem,\n+                         vec![msg_file_line],\n+                         Some(ErrKind::Math(err.clone())))\n+                    }\n+                };\n+\n+                // If we know we always panic, and the error message\n+                // is also constant, then we can produce a warning.\n+                if const_cond == Some(!expected) {\n+                    if let Some(err) = const_err {\n+                        let _ = consts::const_err(bcx.ccx(),\n+                                                  terminator.span,\n+                                                  Err::<(), _>(err),\n+                                                  consts::TrueConst::No);\n+                    }\n+                }\n+\n+                // Obtain the panic entry point.\n+                let def_id = common::langcall(bcx.tcx(), Some(terminator.span), \"\", lang_item);\n+                let callee = Callee::def(bcx.ccx(), def_id,\n+                    bcx.ccx().empty_substs_for_def_id(def_id));\n+                let llfn = callee.reify(bcx.ccx()).val;\n+\n+                // Translate the actual panic invoke/call.\n+                if let Some(unwind) = cleanup {\n+                    bcx.invoke(llfn,\n+                               &args,\n+                               self.unreachable_block().llbb,\n+                               llblock(self, unwind),\n+                               cleanup_bundle);\n+                } else {\n+                    bcx.call(llfn, &args, cleanup_bundle);\n+                    bcx.unreachable();\n+                }\n+            }\n+\n             mir::TerminatorKind::DropAndReplace { .. } => {\n                 bug!(\"undesugared DropAndReplace in trans: {:?}\", data);\n             }\n@@ -319,8 +431,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     }\n \n-                    let val = self.trans_operand(&bcx, arg).val;\n-                    self.trans_argument(&bcx, val, &mut llargs, &fn_ty,\n+                    let op = self.trans_operand(&bcx, arg);\n+                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n                                         &mut idx, &mut callee.data);\n                 }\n                 if let Some(tup) = untuple {\n@@ -358,7 +470,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n-                                val: OperandValue::Ref(dst),\n+                                val: Ref(dst),\n                                 ty: sig.output.unwrap()\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n@@ -396,7 +508,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         ret_bcx.at_start(|ret_bcx| {\n                             debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n-                                val: OperandValue::Immediate(invokeret),\n+                                val: Immediate(invokeret),\n                                 ty: sig.output.unwrap()\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n@@ -407,7 +519,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     fn_ty.apply_attrs_callsite(llret);\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n-                            val: OperandValue::Immediate(llret),\n+                            val: Immediate(llret),\n                             ty: sig.output.unwrap()\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n@@ -422,25 +534,36 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     fn trans_argument(&mut self,\n                       bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                      val: OperandValue,\n+                      mut op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n                       next_idx: &mut usize,\n                       callee: &mut CalleeData) {\n-        // Treat the values in a fat pointer separately.\n-        if let FatPtr(ptr, meta) = val {\n-            if *next_idx == 0 {\n-                if let Virtual(idx) = *callee {\n-                    let llfn = bcx.with_block(|bcx| {\n-                        meth::get_virtual_method(bcx, meta, idx)\n-                    });\n-                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n-                    *callee = Fn(bcx.pointercast(llfn, llty));\n+        if let Pair(a, b) = op.val {\n+            // Treat the values in a fat pointer separately.\n+            if common::type_is_fat_ptr(bcx.tcx(), op.ty) {\n+                let (ptr, meta) = (a, b);\n+                if *next_idx == 0 {\n+                    if let Virtual(idx) = *callee {\n+                        let llfn = bcx.with_block(|bcx| {\n+                            meth::get_virtual_method(bcx, meta, idx)\n+                        });\n+                        let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                        *callee = Fn(bcx.pointercast(llfn, llty));\n+                    }\n                 }\n+\n+                let imm_op = |x| OperandRef {\n+                    val: Immediate(x),\n+                    // We won't be checking the type again.\n+                    ty: bcx.tcx().types.err\n+                };\n+                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, callee);\n+                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n+                return;\n             }\n-            self.trans_argument(bcx, Immediate(ptr), llargs, fn_ty, next_idx, callee);\n-            self.trans_argument(bcx, Immediate(meta), llargs, fn_ty, next_idx, callee);\n-            return;\n+\n+            op = op.pack_if_pair(bcx);\n         }\n \n         let arg = &fn_ty.args[*next_idx];\n@@ -456,15 +579,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n-        let (mut llval, by_ref) = match val {\n+        let (mut llval, by_ref) = match op.val {\n             Immediate(llval) if arg.is_indirect() || arg.cast.is_some() => {\n                 let llscratch = build::AllocaFcx(bcx.fcx(), arg.original_ty, \"arg\");\n                 bcx.store(llval, llscratch);\n                 (llscratch, true)\n             }\n             Immediate(llval) => (llval, false),\n             Ref(llval) => (llval, true),\n-            FatPtr(_, _) => bug!(\"fat pointers handled above\")\n+            Pair(..) => bug!(\"pairs handled above\")\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -511,12 +634,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n                     let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n                         let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n-                        FatPtr(lldata, llextra)\n+                        Pair(lldata, llextra)\n                     } else {\n                         // trans_argument will load this if it needs to\n                         Ref(ptr)\n                     };\n-                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                    let op = OperandRef {\n+                        val: val,\n+                        ty: ty\n+                    };\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n                 }\n \n             }\n@@ -528,11 +655,29 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n                     }\n                     // If the tuple is immediate, the elements are as well\n-                    let val = Immediate(elem);\n-                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                    let op = OperandRef {\n+                        val: Immediate(elem),\n+                        ty: ty\n+                    };\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                }\n+            }\n+            Pair(a, b) => {\n+                let elems = [a, b];\n+                for (n, &ty) in arg_types.iter().enumerate() {\n+                    let mut elem = elems[n];\n+                    // Truncate bools to i1, if needed\n+                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n+                        elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n+                    }\n+                    // Pair is always made up of immediates\n+                    let op = OperandRef {\n+                        val: Immediate(elem),\n+                        ty: ty\n+                    };\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n                 }\n             }\n-            FatPtr(_, _) => bug!(\"tuple is a fat pointer?!\")\n         }\n \n     }\n@@ -688,7 +833,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let f = Callee::def(bcx.ccx(), def_id, substs);\n                 let datum = f.reify(bcx.ccx());\n                 val = OperandRef {\n-                    val: OperandValue::Immediate(datum.val),\n+                    val: Immediate(datum.val),\n                     ty: datum.ty\n                 };\n             }\n@@ -707,29 +852,74 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     op: OperandRef<'tcx>) {\n         use self::ReturnDest::*;\n \n-        match dest {\n-            Nothing => (),\n-            Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n+        // Handle the simple cases that don't require casts, first.\n+        let llcast_ty = match dest {\n+            Nothing => return,\n+            Store(dst) => {\n+                if let Some(llcast_ty) = ret_ty.cast {\n+                    llcast_ty\n+                } else {\n+                    ret_ty.store(bcx, op.immediate(), dst);\n+                    return;\n+                }\n+            }\n             IndirectOperand(tmp, idx) => {\n                 let op = self.trans_load(bcx, tmp, op.ty);\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                return;\n             }\n             DirectOperand(idx) => {\n-                let op = if type_is_fat_ptr(bcx.tcx(), op.ty) {\n-                    let llval = op.immediate();\n-                    let ptr = bcx.extract_value(llval, 0);\n-                    let meta = bcx.extract_value(llval, 1);\n-\n-                    OperandRef {\n-                        val: OperandValue::FatPtr(ptr, meta),\n-                        ty: op.ty\n-                    }\n+                if let Some(llcast_ty) = ret_ty.cast {\n+                    llcast_ty\n                 } else {\n-                    op\n-                };\n+                    let op = op.unpack_if_pair(bcx);\n+                    self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                    return;\n+                }\n+            }\n+        };\n+\n+        // The actual return type is a struct, but the ABI\n+        // adaptation code has cast it into some scalar type.  The\n+        // code that follows is the only reliable way I have\n+        // found to do a transform like i64 -> {i32,i32}.\n+        // Basically we dump the data onto the stack then memcpy it.\n+        //\n+        // Other approaches I tried:\n+        // - Casting rust ret pointer to the foreign type and using Store\n+        //   is (a) unsafe if size of foreign type > size of rust type and\n+        //   (b) runs afoul of strict aliasing rules, yielding invalid\n+        //   assembly under -O (specifically, the store gets removed).\n+        // - Truncating foreign type to correct integral type and then\n+        //   bitcasting to the struct type yields invalid cast errors.\n+\n+        // We instead thus allocate some scratch space...\n+        let llscratch = bcx.alloca(llcast_ty, \"fn_ret_cast\");\n+        bcx.with_block(|bcx| base::call_lifetime_start(bcx, llscratch));\n+\n+        // ...where we first store the value...\n+        bcx.store(op.immediate(), llscratch);\n+\n+        let ccx = bcx.ccx();\n+        match dest {\n+            Store(dst) => {\n+                // ...and then memcpy it to the intended destination.\n+                base::call_memcpy(bcx,\n+                                  bcx.pointercast(dst, Type::i8p(ccx)),\n+                                  bcx.pointercast(llscratch, Type::i8p(ccx)),\n+                                  C_uint(ccx, llsize_of_store(ccx, ret_ty.original_ty)),\n+                                  cmp::min(llalign_of_min(ccx, ret_ty.original_ty),\n+                                           llalign_of_min(ccx, llcast_ty)) as u32);\n+            }\n+            DirectOperand(idx) => {\n+                let llptr = bcx.pointercast(llscratch, ret_ty.original_ty.ptr_to());\n+                let op = self.trans_load(bcx, llptr, op.ty);\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }\n+            Nothing | IndirectOperand(_, _) => bug!()\n         }\n+\n+        bcx.with_block(|bcx| base::call_lifetime_end(bcx, llscratch));\n     }\n }\n "}, {"sha": "d352a8241acd48a555c06a25b2640af35ba0c640", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 187, "deletions": 101, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -12,12 +12,13 @@ use llvm::{self, ValueRef};\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::ErrKind;\n use rustc_const_math::ConstInt::*;\n+use rustc_const_math::ConstMathErr;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n use {abi, adt, base, Disr};\n@@ -98,9 +99,15 @@ impl<'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n+    fn get_pair(&self) -> (ValueRef, ValueRef) {\n+        (const_get_elt(self.llval, &[0]),\n+         const_get_elt(self.llval, &[1]))\n+    }\n+\n     fn get_fat_ptr(&self) -> (ValueRef, ValueRef) {\n-        (const_get_elt(self.llval, &[abi::FAT_PTR_ADDR as u32]),\n-         const_get_elt(self.llval, &[abi::FAT_PTR_EXTRA as u32]))\n+        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+        self.get_pair()\n     }\n \n     fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n@@ -115,9 +122,9 @@ impl<'tcx> Const<'tcx> {\n         let llty = type_of::immediate_type_of(ccx, self.ty);\n         let llvalty = val_ty(self.llval);\n \n-        let val = if common::type_is_fat_ptr(ccx.tcx(), self.ty) {\n-            let (data, extra) = self.get_fat_ptr();\n-            OperandValue::FatPtr(data, extra)\n+        let val = if common::type_is_imm_pair(ccx, self.ty) {\n+            let (a, b) = self.get_pair();\n+            OperandValue::Pair(a, b)\n         } else if common::type_is_immediate(ccx, self.ty) && llty == llvalty {\n             // If the types match, we can use the value directly.\n             OperandValue::Immediate(self.llval)\n@@ -263,15 +270,22 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalFailure> {\n         let tcx = self.ccx.tcx();\n         let mut bb = mir::START_BLOCK;\n+\n+        // Make sure to evaluate all statemenets to\n+        // report as many errors as we possibly can.\n+        let mut failure = Ok(());\n+\n         loop {\n             let data = self.mir.basic_block_data(bb);\n             for statement in &data.statements {\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n                         let ty = self.mir.lvalue_ty(tcx, dest);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        let value = self.const_rvalue(rvalue, ty, statement.span)?;\n-                        self.store(dest, value, statement.span);\n+                        match self.const_rvalue(rvalue, ty, statement.span) {\n+                            Ok(value) => self.store(dest, value, statement.span),\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                     }\n                 }\n             }\n@@ -282,19 +296,35 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Drop { target, .. } | // No dropping.\n                 mir::TerminatorKind::Goto { target } => target,\n                 mir::TerminatorKind::Return => {\n+                    failure?;\n                     return Ok(self.return_value.unwrap_or_else(|| {\n                         span_bug!(span, \"no returned value in constant\");\n                     }))\n                 }\n \n-                // This is only supported to make bounds checking work.\n-                mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n+                mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, .. } => {\n                     let cond = self.const_operand(cond, span)?;\n-                    if common::const_to_uint(cond.llval) != 0 {\n-                        true_bb\n-                    } else {\n-                        false_bb\n+                    let cond_bool = common::const_to_uint(cond.llval) != 0;\n+                    if cond_bool != expected {\n+                        let err = match *msg {\n+                            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                                let len = self.const_operand(len, span)?;\n+                                let index = self.const_operand(index, span)?;\n+                                ErrKind::IndexOutOfBounds {\n+                                    len: common::const_to_uint(len.llval),\n+                                    index: common::const_to_uint(index.llval)\n+                                }\n+                            }\n+                            mir::AssertMessage::Math(ref err) => {\n+                                ErrKind::Math(err.clone())\n+                            }\n+                        };\n+                        match consts::const_err(self.ccx, span, Err(err), TrueConst::Yes) {\n+                            Ok(()) => {}\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                     }\n+                    target\n                 }\n \n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n@@ -308,22 +338,21 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                        func, fn_ty)\n                     };\n \n-                    // Indexing OOB doesn't call a const fn, handle it.\n-                    if Some(instance.def) == tcx.lang_items.panic_bounds_check_fn() {\n-                        consts::const_err(self.ccx, span,\n-                                          Err(ErrKind::IndexOutOfBounds),\n-                                          TrueConst::Yes)?;\n+                    let mut const_args = Vec::with_capacity(args.len());\n+                    for arg in args {\n+                        match self.const_operand(arg, span) {\n+                            Ok(arg) => const_args.push(arg),\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                     }\n-\n-                    let args = args.iter().map(|arg| {\n-                        self.const_operand(arg, span)\n-                    }).collect::<Result<Vec<_>, _>>()?;\n-                    let value = MirConstContext::trans_def(self.ccx, instance, args)?;\n                     if let Some((ref dest, target)) = *destination {\n-                        self.store(dest, value, span);\n+                        match MirConstContext::trans_def(self.ccx, instance, const_args) {\n+                            Ok(value) => self.store(dest, value, span),\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                         target\n                     } else {\n-                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind)\n+                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind);\n                     }\n                 }\n                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -413,8 +442,16 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         } else {\n                             span_bug!(span, \"index is not an integer-constant expression\")\n                         };\n-                        (Base::Value(const_get_elt(base.llval, &[iv as u32])),\n-                         ptr::null_mut())\n+\n+                        // Produce an undef instead of a LLVM assertion on OOB.\n+                        let len = common::const_to_uint(tr_base.len(self.ccx));\n+                        let llelem = if iv < len {\n+                            const_get_elt(base.llval, &[iv as u32])\n+                        } else {\n+                            C_undef(type_of::type_of(self.ccx, projected_ty))\n+                        };\n+\n+                        (Base::Value(llelem), ptr::null_mut())\n                     }\n                     _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n                 };\n@@ -485,9 +522,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                let fields = operands.iter().map(|operand| {\n-                    Ok(self.const_operand(operand, span)?.llval)\n-                }).collect::<Result<Vec<_>, _>>()?;\n+                // Make sure to evaluate all operands to\n+                // report as many errors as we possibly can.\n+                let mut fields = Vec::with_capacity(operands.len());\n+                let mut failure = Ok(());\n+                for operand in operands {\n+                    match self.const_operand(operand, span) {\n+                        Ok(val) => fields.push(val.llval),\n+                        Err(err) => if failure.is_ok() { failure = Err(err); }\n+                    }\n+                }\n+                failure?;\n \n                 // FIXME Shouldn't need to manually trigger closure instantiations.\n                 if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n@@ -656,7 +701,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 consts::ptrcast(data_ptr, ll_cast_ty)\n                             }\n                         } else {\n-                            bug!(\"Unexpected non-FatPtr operand\")\n+                            bug!(\"Unexpected non-fat-pointer operand\")\n                         }\n                     }\n                 };\n@@ -702,73 +747,28 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let ty = lhs.ty;\n                 let binop_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n-                assert!(!ty.is_simd());\n-                let is_float = ty.is_fp();\n-                let signed = ty.is_signed();\n-\n-                if let (Some(lhs), Some(rhs)) = (to_const_int(lhs, ty, tcx),\n-                                                 to_const_int(rhs, ty, tcx)) {\n-                    let result = match op {\n-                        mir::BinOp::Add => lhs + rhs,\n-                        mir::BinOp::Sub => lhs - rhs,\n-                        mir::BinOp::Mul => lhs * rhs,\n-                        mir::BinOp::Div => lhs / rhs,\n-                        mir::BinOp::Rem => lhs % rhs,\n-                        mir::BinOp::Shl => lhs << rhs,\n-                        mir::BinOp::Shr => lhs >> rhs,\n-                        _ => Ok(lhs)\n-                    };\n-                    consts::const_err(self.ccx, span,\n-                                      result.map_err(ErrKind::Math),\n-                                      TrueConst::Yes)?;\n-                }\n-\n-                let llval = unsafe {\n-                    match op {\n-                        mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n-                        mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n-\n-                        mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n-                        mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n-\n-                        mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n-                        mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n-\n-                        mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n-                        mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n-                        mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n+                Const::new(const_scalar_binop(op, lhs, rhs, ty), binop_ty)\n+            }\n \n-                        mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n-                        mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n-                        mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n+            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.const_operand(lhs, span)?;\n+                let rhs = self.const_operand(rhs, span)?;\n+                let ty = lhs.ty;\n+                let val_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let binop_ty = tcx.mk_tup(vec![val_ty, tcx.types.bool]);\n+                let (lhs, rhs) = (lhs.llval, rhs.llval);\n+                assert!(!ty.is_fp());\n \n-                        mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n-                        mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n-                        mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n-                        mir::BinOp::Shl    => {\n-                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                            llvm::LLVMConstShl(lhs, rhs)\n-                        }\n-                        mir::BinOp::Shr    => {\n-                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                            if signed { llvm::LLVMConstAShr(lhs, rhs) }\n-                            else      { llvm::LLVMConstLShr(lhs, rhs) }\n-                        }\n-                        mir::BinOp::Eq | mir::BinOp::Ne |\n-                        mir::BinOp::Lt | mir::BinOp::Le |\n-                        mir::BinOp::Gt | mir::BinOp::Ge => {\n-                            if is_float {\n-                                let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n-                                llvm::ConstFCmp(cmp, lhs, rhs)\n-                            } else {\n-                                let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n-                                                                         signed);\n-                                llvm::ConstICmp(cmp, lhs, rhs)\n-                            }\n-                        }\n+                match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n+                    Some((llval, of)) => {\n+                        let llof = C_bool(self.ccx, of);\n+                        Const::new(C_struct(self.ccx, &[llval, llof], false), binop_ty)\n                     }\n-                };\n-                Const::new(llval, binop_ty)\n+                    None => {\n+                        span_bug!(span, \"{:?} got non-integer operands: {:?} and {:?}\",\n+                                  rvalue, Value(lhs), Value(rhs));\n+                    }\n+                }\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n@@ -781,11 +781,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::UnOp::Neg => {\n-                        if let Some(cval) = to_const_int(lloperand, operand.ty, tcx) {\n-                            consts::const_err(self.ccx, span,\n-                                              (-cval).map_err(ErrKind::Math),\n-                                              TrueConst::Yes)?;\n-                        }\n                         let is_float = operand.ty.is_fp();\n                         unsafe {\n                             if is_float {\n@@ -804,6 +799,97 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n         Ok(val)\n     }\n+\n+}\n+\n+pub fn const_scalar_binop(op: mir::BinOp,\n+                          lhs: ValueRef,\n+                          rhs: ValueRef,\n+                          input_ty: Ty) -> ValueRef {\n+    assert!(!input_ty.is_simd());\n+    let is_float = input_ty.is_fp();\n+    let signed = input_ty.is_signed();\n+\n+    unsafe {\n+        match op {\n+            mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n+            mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n+\n+            mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n+            mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n+\n+            mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n+            mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n+\n+            mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n+            mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n+            mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n+\n+            mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n+            mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n+            mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n+\n+            mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n+            mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n+            mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n+            mir::BinOp::Shl    => {\n+                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                llvm::LLVMConstShl(lhs, rhs)\n+            }\n+            mir::BinOp::Shr    => {\n+                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                if signed { llvm::LLVMConstAShr(lhs, rhs) }\n+                else      { llvm::LLVMConstLShr(lhs, rhs) }\n+            }\n+            mir::BinOp::Eq | mir::BinOp::Ne |\n+            mir::BinOp::Lt | mir::BinOp::Le |\n+            mir::BinOp::Gt | mir::BinOp::Ge => {\n+                if is_float {\n+                    let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n+                    llvm::ConstFCmp(cmp, lhs, rhs)\n+                } else {\n+                    let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n+                                                                signed);\n+                    llvm::ConstICmp(cmp, lhs, rhs)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                            op: mir::BinOp,\n+                                            lllhs: ValueRef,\n+                                            llrhs: ValueRef,\n+                                            input_ty: Ty<'tcx>)\n+                                            -> Option<(ValueRef, bool)> {\n+    if let (Some(lhs), Some(rhs)) = (to_const_int(lllhs, input_ty, tcx),\n+                                     to_const_int(llrhs, input_ty, tcx)) {\n+        let result = match op {\n+            mir::BinOp::Add => lhs + rhs,\n+            mir::BinOp::Sub => lhs - rhs,\n+            mir::BinOp::Mul => lhs * rhs,\n+            mir::BinOp::Shl => lhs << rhs,\n+            mir::BinOp::Shr => lhs >> rhs,\n+            _ => {\n+                bug!(\"Operator `{:?}` is not a checkable operator\", op)\n+            }\n+        };\n+\n+        let of = match result {\n+            Ok(_) => false,\n+            Err(ConstMathErr::Overflow(_)) |\n+            Err(ConstMathErr::ShiftNegative) => true,\n+            Err(err) => {\n+                bug!(\"Operator `{:?}` on `{:?}` and `{:?}` errored: {}\",\n+                     op, lhs, rhs, err.description());\n+            }\n+        };\n+\n+        Some((const_scalar_binop(op, lllhs, llrhs, input_ty), of))\n+    } else {\n+        None\n+    }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {"}, {"sha": "c21f112b5f60380f6db299ab13bf534c78149fbb", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 100, "deletions": 20, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -13,12 +13,12 @@ use rustc::ty::Ty;\n use rustc::mir::repr as mir;\n use base;\n use common::{self, Block, BlockAndBuilder};\n-use datum;\n use value::Value;\n+use type_of;\n+use type_::Type;\n \n use std::fmt;\n \n-use super::lvalue::load_fat_ptr;\n use super::{MirContext, TempRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -31,9 +31,8 @@ pub enum OperandValue {\n     Ref(ValueRef),\n     /// A single LLVM value.\n     Immediate(ValueRef),\n-    /// A fat pointer. The first ValueRef is the data and the second\n-    /// is the extra.\n-    FatPtr(ValueRef, ValueRef)\n+    /// A pair of immediate LLVM values. Used by fat pointers too.\n+    Pair(ValueRef, ValueRef)\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -64,15 +63,15 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n                 write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n                        Value(i), self.ty)\n             }\n-            OperandValue::FatPtr(a, d) => {\n-                write!(f, \"OperandRef(FatPtr({:?}, {:?}) @ {:?})\",\n-                       Value(a), Value(d), self.ty)\n+            OperandValue::Pair(a, b) => {\n+                write!(f, \"OperandRef(Pair({:?}, {:?}) @ {:?})\",\n+                       Value(a), Value(b), self.ty)\n             }\n         }\n     }\n }\n \n-impl<'tcx> OperandRef<'tcx> {\n+impl<'bcx, 'tcx> OperandRef<'tcx> {\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {\n@@ -81,6 +80,54 @@ impl<'tcx> OperandRef<'tcx> {\n             _ => bug!()\n         }\n     }\n+\n+    /// If this operand is a Pair, we return an\n+    /// Immediate aggregate with the two values.\n+    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>)\n+                        -> OperandRef<'tcx> {\n+        if let OperandValue::Pair(a, b) = self.val {\n+            // Reconstruct the immediate aggregate.\n+            let llty = type_of::type_of(bcx.ccx(), self.ty);\n+            let mut llpair = common::C_undef(llty);\n+            let elems = [a, b];\n+            for i in 0..2 {\n+                let mut elem = elems[i];\n+                // Extend boolean i1's to i8.\n+                if common::val_ty(elem) == Type::i1(bcx.ccx()) {\n+                    elem = bcx.zext(elem, Type::i8(bcx.ccx()));\n+                }\n+                llpair = bcx.insert_value(llpair, elem, i);\n+            }\n+            self.val = OperandValue::Immediate(llpair);\n+        }\n+        self\n+    }\n+\n+    /// If this operand is a pair in an Immediate,\n+    /// we return a Pair with the two halves.\n+    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>)\n+                          -> OperandRef<'tcx> {\n+        if let OperandValue::Immediate(llval) = self.val {\n+            // Deconstruct the immediate aggregate.\n+            if common::type_is_imm_pair(bcx.ccx(), self.ty) {\n+                let mut a = bcx.extract_value(llval, 0);\n+                let mut b = bcx.extract_value(llval, 1);\n+\n+                let pair_fields = common::type_pair_fields(bcx.ccx(), self.ty);\n+                if let Some([a_ty, b_ty]) = pair_fields {\n+                    if a_ty.is_bool() {\n+                        a = bcx.trunc(a, Type::i1(bcx.ccx()));\n+                    }\n+                    if b_ty.is_bool() {\n+                        b = bcx.trunc(b, Type::i1(bcx.ccx()));\n+                    }\n+                }\n+\n+                self.val = OperandValue::Pair(a, b);\n+            }\n+        }\n+        self\n+    }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n@@ -92,15 +139,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n-        let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n-            datum::ByValue => {\n-                OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n-            }\n-            datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                let (lldata, llextra) = load_fat_ptr(bcx, llval);\n-                OperandValue::FatPtr(lldata, llextra)\n-            }\n-            datum::ByRef => OperandValue::Ref(llval)\n+        let val = if common::type_is_imm_pair(bcx.ccx(), ty) {\n+            let a_ptr = bcx.struct_gep(llval, 0);\n+            let b_ptr = bcx.struct_gep(llval, 1);\n+\n+            // This is None only for fat pointers, which don't\n+            // need any special load-time behavior anyway.\n+            let pair_fields = common::type_pair_fields(bcx.ccx(), ty);\n+            let (a, b) = if let Some([a_ty, b_ty]) = pair_fields {\n+                (base::load_ty_builder(bcx, a_ptr, a_ty),\n+                 base::load_ty_builder(bcx, b_ptr, b_ty))\n+            } else {\n+                (bcx.load(a_ptr), bcx.load(b_ptr))\n+            };\n+            OperandValue::Pair(a, b)\n+        } else if common::type_is_immediate(bcx.ccx(), ty) {\n+            OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n+        } else {\n+            OperandValue::Ref(llval)\n         };\n \n         OperandRef { val: val, ty: ty }\n@@ -131,6 +187,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 }\n \n+                // Moves out of pair fields are trivial.\n+                if let &mir::Lvalue::Projection(ref proj) = lvalue {\n+                    if let mir::Lvalue::Temp(index) = proj.base {\n+                        let temp_ref = &self.temps[index as usize];\n+                        if let &TempRef::Operand(Some(o)) = temp_ref {\n+                            match (o.val, &proj.elem) {\n+                                (OperandValue::Pair(a, b),\n+                                 &mir::ProjectionElem::Field(ref f, ty)) => {\n+                                    let llval = [a, b][f.index()];\n+                                    return OperandRef {\n+                                        val: OperandValue::Immediate(llval),\n+                                        ty: bcx.monomorphize(&ty)\n+                                    };\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+                }\n+\n                 // for most lvalues, to consume them we just load them\n                 // out from their home\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n@@ -173,8 +249,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match operand.val {\n             OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n             OperandValue::Immediate(s) => base::store_ty(bcx, s, lldest, operand.ty),\n-            OperandValue::FatPtr(data, extra) => {\n-                base::store_fat_ptr(bcx, data, extra, lldest, operand.ty);\n+            OperandValue::Pair(a, b) => {\n+                use build::*;\n+                let a = base::from_immediate(bcx, a);\n+                let b = base::from_immediate(bcx, b);\n+                Store(bcx, a, StructGEP(bcx, lldest, 0));\n+                Store(bcx, b, StructGEP(bcx, lldest, 1));\n             }\n         }\n     }"}, {"sha": "ba351d07016c5e84621b50de01a556de383d9cf5", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 165, "deletions": 13, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n+use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::mir::repr as mir;\n \n use asm;\n use base;\n use callee::Callee;\n-use common::{self, C_uint, BlockAndBuilder, Result};\n+use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use adt;\n@@ -27,6 +27,7 @@ use value::Value;\n use Disr;\n \n use super::MirContext;\n+use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::lvalue::{LvalueRef, get_dataptr, get_meta};\n \n@@ -66,9 +67,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n                 let operand = self.trans_operand(&bcx, source);\n+                let operand = operand.pack_if_pair(&bcx);\n                 bcx.with_block(|bcx| {\n                     match operand.val {\n-                        OperandValue::FatPtr(..) => bug!(),\n+                        OperandValue::Pair(..) => bug!(),\n                         OperandValue::Immediate(llval) => {\n                             // unsize from an immediate structure. We don't\n                             // really need a temporary alloca here, but\n@@ -253,7 +255,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         assert!(common::type_is_fat_ptr(bcx.tcx(), cast_ty));\n \n                         match operand.val {\n-                            OperandValue::FatPtr(lldata, llextra) => {\n+                            OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer - this is a\n                                 // \"trait-object-to-supertrait\" coercion, for\n                                 // example,\n@@ -262,15 +264,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // the types match up.\n                                 let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx(), cast_ty);\n                                 let lldata = bcx.pointercast(lldata, llcast_ty);\n-                                OperandValue::FatPtr(lldata, llextra)\n+                                OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n                                 let (lldata, llextra) = bcx.with_block(|bcx| {\n                                     base::unsize_thin_ptr(bcx, lldata,\n                                                           operand.ty, cast_ty)\n                                 });\n-                                OperandValue::FatPtr(lldata, llextra)\n+                                OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n                                 bug!(\"by-ref operand {:?} in trans_rvalue_operand\",\n@@ -341,21 +343,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n                         let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n                         let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n-                        if let OperandValue::FatPtr(data_ptr, meta_ptr) = operand.val {\n+                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n                             if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n                                 let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n                                 assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n-                                OperandValue::FatPtr(data_cast, meta_ptr)\n+                                OperandValue::Pair(data_cast, meta_ptr)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n                                 let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n-                            bug!(\"Unexpected non-FatPtr operand\")\n+                            bug!(\"Unexpected non-Pair operand\")\n                         }\n                     }\n                 };\n@@ -384,8 +386,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 } else {\n                     OperandRef {\n-                        val: OperandValue::FatPtr(tr_lvalue.llval,\n-                                                  tr_lvalue.llextra),\n+                        val: OperandValue::Pair(tr_lvalue.llval,\n+                                                tr_lvalue.llextra),\n                         ty: ref_ty,\n                     }\n                 };\n@@ -406,8 +408,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let rhs = self.trans_operand(&bcx, rhs);\n                 let llresult = if common::type_is_fat_ptr(bcx.tcx(), lhs.ty) {\n                     match (lhs.val, rhs.val) {\n-                        (OperandValue::FatPtr(lhs_addr, lhs_extra),\n-                         OperandValue::FatPtr(rhs_addr, rhs_extra)) => {\n+                        (OperandValue::Pair(lhs_addr, lhs_extra),\n+                         OperandValue::Pair(rhs_addr, rhs_extra)) => {\n                             bcx.with_block(|bcx| {\n                                 base::compare_fat_ptrs(bcx,\n                                                        lhs_addr, lhs_extra,\n@@ -430,6 +432,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n                 (bcx, operand)\n             }\n+            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.trans_operand(&bcx, lhs);\n+                let rhs = self.trans_operand(&bcx, rhs);\n+                let result = self.trans_scalar_checked_binop(&bcx, op,\n+                                                             lhs.immediate(), rhs.immediate(),\n+                                                             lhs.ty);\n+                let val_ty = self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty);\n+                let operand_ty = bcx.tcx().mk_tup(vec![val_ty, bcx.tcx().types.bool]);\n+                let operand = OperandRef {\n+                    val: result,\n+                    ty: operand_ty\n+                };\n+\n+                (bcx, operand)\n+            }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.trans_operand(&bcx, operand);\n@@ -556,6 +573,68 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn trans_scalar_checked_binop(&mut self,\n+                                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                      op: mir::BinOp,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      input_ty: Ty<'tcx>) -> OperandValue {\n+        // This case can currently arise only from functions marked\n+        // with #[rustc_inherit_overflow_checks] and inlined from\n+        // another crate (mostly core::num generic/#[inline] fns),\n+        // while the current crate doesn't use overflow checks.\n+        if !bcx.ccx().check_overflow() {\n+            let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n+            return OperandValue::Pair(val, C_bool(bcx.ccx(), false));\n+        }\n+\n+        // First try performing the operation on constants, which\n+        // will only succeed if both operands are constant.\n+        // This is necessary to determine when an overflow Assert\n+        // will always panic at runtime, and produce a warning.\n+        match const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n+            Some((val, of)) => {\n+                return OperandValue::Pair(val, C_bool(bcx.ccx(), of));\n+            }\n+            None => {}\n+        }\n+\n+        let (val, of) = match op {\n+            // These are checked using intrinsics\n+            mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {\n+                let oop = match op {\n+                    mir::BinOp::Add => OverflowOp::Add,\n+                    mir::BinOp::Sub => OverflowOp::Sub,\n+                    mir::BinOp::Mul => OverflowOp::Mul,\n+                    _ => unreachable!()\n+                };\n+                let intrinsic = get_overflow_intrinsic(oop, bcx, input_ty);\n+                let res = bcx.call(intrinsic, &[lhs, rhs], None);\n+\n+                (bcx.extract_value(res, 0),\n+                 bcx.extract_value(res, 1))\n+            }\n+            mir::BinOp::Shl | mir::BinOp::Shr => {\n+                let lhs_llty = val_ty(lhs);\n+                let rhs_llty = val_ty(rhs);\n+                let invert_mask = bcx.with_block(|bcx| {\n+                    common::shift_mask_val(bcx, lhs_llty, rhs_llty, true)\n+                });\n+                let outer_bits = bcx.and(rhs, invert_mask);\n+\n+                let of = bcx.icmp(llvm::IntNE, outer_bits, C_null(rhs_llty));\n+                let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n+\n+                (val, of)\n+            }\n+            _ => {\n+                bug!(\"Operator `{:?}` is not a checkable operator\", op)\n+            }\n+        };\n+\n+        OperandValue::Pair(val, of)\n+    }\n }\n \n pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n@@ -566,6 +645,7 @@ pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n         mir::Rvalue::Len(..) |\n         mir::Rvalue::Cast(..) | // (*)\n         mir::Rvalue::BinaryOp(..) |\n+        mir::Rvalue::CheckedBinaryOp(..) |\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Box(..) |\n         mir::Rvalue::Use(..) =>\n@@ -579,3 +659,75 @@ pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n \n     // (*) this is only true if the type is suitable\n }\n+\n+#[derive(Copy, Clone)]\n+enum OverflowOp {\n+    Add, Sub, Mul\n+}\n+\n+fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> ValueRef {\n+    use syntax::ast::IntTy::*;\n+    use syntax::ast::UintTy::*;\n+    use rustc::ty::{TyInt, TyUint};\n+\n+    let tcx = bcx.tcx();\n+\n+    let new_sty = match ty.sty {\n+        TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            \"32\" => TyInt(I32),\n+            \"64\" => TyInt(I64),\n+            _ => panic!(\"unsupported target word size\")\n+        },\n+        TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            \"32\" => TyUint(U32),\n+            \"64\" => TyUint(U64),\n+            _ => panic!(\"unsupported target word size\")\n+        },\n+        ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n+        _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n+    };\n+\n+    let name = match oop {\n+        OverflowOp::Add => match new_sty {\n+            TyInt(I8) => \"llvm.sadd.with.overflow.i8\",\n+            TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n+            TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n+            TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n+\n+            TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n+            TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n+            TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n+            TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n+\n+            _ => unreachable!(),\n+        },\n+        OverflowOp::Sub => match new_sty {\n+            TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n+            TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n+            TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n+            TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n+\n+            TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n+            TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n+            TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n+            TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n+\n+            _ => unreachable!(),\n+        },\n+        OverflowOp::Mul => match new_sty {\n+            TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n+            TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n+            TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n+            TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n+\n+            TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n+            TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n+            TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n+            TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n+\n+            _ => unreachable!(),\n+        },\n+    };\n+\n+    bcx.ccx().get_intrinsic(&name)\n+}"}, {"sha": "86c4a33896d15ade49115cbcfdf5f74243f2f388", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -502,6 +502,13 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                          is just used to make tests pass \\\n                                          and will never be stable\",\n                                         cfg_fn!(rustc_attrs))),\n+    (\"rustc_inherit_overflow_checks\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                         \"the `#[rustc_inherit_overflow_checks]` \\\n+                                                          attribute is just used to control \\\n+                                                          overflow checking behavior of several \\\n+                                                          libcore functions that are inlined \\\n+                                                          across crates and will never be stable\",\n+                                                          cfg_fn!(rustc_attrs))),\n \n     (\"allow_internal_unstable\", Normal, Gated(\"allow_internal_unstable\",\n                                               EXPLAIN_ALLOW_INTERNAL_UNSTABLE,"}, {"sha": "e65230389f9c0412297a2d5fa95c25934e1ada3b", "filename": "src/test/compile-fail/array_const_index-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,7 +10,7 @@\n \n const A: &'static [i32] = &[];\n const B: i32 = (&A)[1];\n-//~^ ERROR: array index out of bounds\n+//~^ ERROR index out of bounds: the len is 0 but the index is 1\n \n fn main() {\n     let _ = B;"}, {"sha": "69d84e24c4982db2c7d5549461b425eb2f74a4b3", "filename": "src/test/compile-fail/array_const_index-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n const A: [i32; 0] = [];\n-const B: i32 = A[1]; //~ ERROR: array index out of bounds\n+const B: i32 = A[1];\n+//~^ ERROR index out of bounds: the len is 0 but the index is 1\n \n fn main() {\n     let _ = B;"}, {"sha": "faabed4fd5e422d5f73ba2a92fc8b705848d8c72", "filename": "src/test/compile-fail/const-array-oob.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n #![feature(const_indexing)]\n \n const FOO: [u32; 3] = [1, 2, 3];\n const BAR: u32 = FOO[5]; // no error, because the error below occurs before regular const eval\n \n const BLUB: [u32; FOO[4]] = [5, 6];\n-//~^ ERROR array length constant evaluation error: array index out of bounds [E0250]\n+//~^ ERROR array length constant evaluation error: index out of bounds: the len is 3 but the index is 4 [E0250]\n \n fn main() {\n     let _ = BAR;"}, {"sha": "f666140970b6e125b0d27f0740c15dfdbfbe1ca2", "filename": "src/test/compile-fail/const-err-early.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -15,8 +15,10 @@ pub const A: i8 = -std::i8::MIN; //~ ERROR attempted to negate with overflow\n pub const B: u8 = 200u8 + 200u8; //~ ERROR attempted to add with overflow\n pub const C: u8 = 200u8 * 4; //~ ERROR attempted to multiply with overflow\n pub const D: u8 = 42u8 - (42u8 + 1); //~ ERROR attempted to subtract with overflow\n-pub const E: u8 = [5u8][1]; //~ ERROR index out of bounds\n+pub const E: u8 = [5u8][1];\n+//~^ ERROR index out of bounds: the len is 1 but the index is 1\n \n fn main() {\n-    let _e = [6u8][1]; //~ ERROR: array index out of bounds\n+    let _e = [6u8][1];\n+    //~^ ERROR index out of bounds: the len is 1 but the index is 1\n }"}, {"sha": "a1d3888e78ea0dc16fe3d9cd6bd454a0764fc51e", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Zforce-overflow-checks=on\n+\n // these errors are not actually \"const_err\", they occur in trans/consts\n // and are unconditional warnings that can't be denied or allowed\n \n-#![feature(rustc_attrs)]\n #![allow(exceeding_bitshifts)]\n #![allow(const_err)]\n \n@@ -21,10 +22,9 @@ fn black_box<T>(_: T) {\n \n // Make sure that the two uses get two errors.\n const FOO: u8 = [5u8][1];\n-//~^ ERROR array index out of bounds\n-//~^^ ERROR array index out of bounds\n+//~^ ERROR index out of bounds: the len is 1 but the index is 1\n+//~^^ ERROR index out of bounds: the len is 1 but the index is 1\n \n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let a = -std::i8::MIN;\n     //~^ WARN attempted to negate with overflow\n@@ -36,7 +36,7 @@ fn main() {\n     let d = 42u8 - (42u8 + 1);\n     //~^ WARN attempted to subtract with overflow\n     let _e = [5u8][1];\n-    //~^ WARN array index out of bounds\n+    //~^ WARN index out of bounds: the len is 1 but the index is 1\n     black_box(a);\n     black_box(b);\n     black_box(c);"}, {"sha": "3dfcb5bb29a24a68701b48d195f62aca3361240c", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n #![allow(unused_imports)]\n \n // Note: the relevant lint pass here runs before some of the constant\n@@ -104,7 +103,6 @@ const VALS_U64: (u64, u64, u64, u64) =\n      //~^ ERROR attempted to multiply with overflow\n      );\n \n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     foo(VALS_I8);\n     foo(VALS_I16);"}, {"sha": "d63b0097e5a0ce3fe0dc5ae0bdc7a66d2fefc212", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n const FOO: &'static[u32] = &[1, 2, 3];\n-const BAR: u32 = FOO[5]; //~ ERROR array index out of bounds\n+const BAR: u32 = FOO[5];\n+//~^ ERROR index out of bounds: the len is 3 but the index is 5\n \n fn main() {\n     let _ = BAR;"}, {"sha": "3d9bee3c86a569fe8bc6691925afa1c04e2c3cd1", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -12,8 +12,6 @@\n \n // error-pattern:attempted to divide by zero\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let y = 0;\n     let _z = 1 / y;"}, {"sha": "686c3eb2f83b860ad66b29eb85cd439463973289", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,10 +10,8 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:attempted remainder with a divisor of zero\n+// error-pattern:attempted to calculate the remainder with a divisor of zero\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let y = 0;\n     let _z = 1 % y;"}, {"sha": "ecb8c676cf700d689cda252865747949a14bc3f5", "filename": "src/test/run-fail/overflowing-add.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-add.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,12 +10,10 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'arithmetic operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to add with overflow'\n // compile-flags: -C debug-assertions\n \n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 200u8 + 200u8 + 200u8;\n }"}, {"sha": "e277886d003dce43e3ea65bc456386b109158061", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift left with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 1_i32 << 32;\n }"}, {"sha": "42cb0f2d55bc1ba90c2a1223c995ad3d2bed71a5", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift left with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 1 << -1;\n }"}, {"sha": "8c6623dcf50ceeff50c1225bbf6e54c0013f47f2", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift left with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 1_u64 << 64;\n }"}, {"sha": "3b7a00a2c73c6dd3cba02828e4bdec4b19428f32", "filename": "src/test/run-fail/overflowing-lsh-4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,16 +10,14 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift left with overflow'\n // compile-flags: -C debug-assertions\n \n // This function is checking that our automatic truncation does not\n // sidestep the overflow checking.\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     // this signals overflow when checking is on\n     let x = 1_i8 << 17;"}, {"sha": "0e168bf6ffbc6e3c60b8ec0e60438b472c344a6a", "filename": "src/test/run-fail/overflowing-mul.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,11 +10,9 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'arithmetic operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to multiply with overflow'\n // compile-flags: -C debug-assertions\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let x = 200u8 * 4;\n }"}, {"sha": "84e41ea848809b2ff82637112cba4e0682879500", "filename": "src/test/run-fail/overflowing-neg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -13,8 +13,6 @@\n // error-pattern:thread 'main' panicked at 'attempted to negate with overflow'\n // compile-flags: -C debug-assertions\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -std::i8::MIN;\n }"}, {"sha": "9172374ec2818b41e7a1a2e48b7de662271eef68", "filename": "src/test/run-fail/overflowing-pow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-pow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-pow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-pow.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:thread 'main' panicked at 'arithmetic operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to multiply with overflow'\n // compile-flags: -C debug-assertions\n \n fn main() {"}, {"sha": "d275792485d5126851e89d77f94714d86f2df4b1", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift right with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -1_i32 >> 32;\n }"}, {"sha": "1b888cddf64436a9e7ffe5ea54e33b0512adacdd", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift right with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -1_i32 >> -1;\n }"}, {"sha": "be5c213493d6dbb90dfa2d2489d127f17920e033", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift right with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -1_i64 >> 64;\n }"}, {"sha": "820d9611d6acb973922b2cf36fadb603dd136612", "filename": "src/test/run-fail/overflowing-rsh-4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,16 +10,14 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift right with overflow'\n // compile-flags: -C debug-assertions\n \n // This function is checking that our (type-based) automatic\n // truncation does not sidestep the overflow checking.\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     // this signals overflow when checking is on\n     let x = 2_i8 >> 17;"}, {"sha": "b87be696fcb213ba699d2715985a990b30b567d1", "filename": "src/test/run-fail/overflowing-rsh-5.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,13 +10,11 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift right with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _n = 1i64 >> [64][0];\n }"}, {"sha": "554675686b5e293d80b54f9bb905d112ffe10f61", "filename": "src/test/run-fail/overflowing-rsh-6.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,14 +10,12 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'shift operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to shift right with overflow'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n #![feature(const_indexing)]\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _n = 1i64 >> [64][0];\n }"}, {"sha": "1cb207240ca492e2b8185733e7a51ae136d701a2", "filename": "src/test/run-fail/overflowing-sub.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -10,11 +10,9 @@\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-// error-pattern:thread 'main' panicked at 'arithmetic operation overflowed'\n+// error-pattern:thread 'main' panicked at 'attempted to subtract with overflow'\n // compile-flags: -C debug-assertions\n \n-#![feature(rustc_attrs)]\n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 42u8 - (42u8 + 1);\n }"}, {"sha": "65682cb86c36881c1ddaca9a586f469d3b97337f", "filename": "src/test/run-make/debug-assertions/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-make%2Fdebug-assertions%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-make%2Fdebug-assertions%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdebug-assertions%2Fdebug.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -37,7 +37,6 @@ fn debug_assert() {\n }\n \n fn overflow() {\n-    #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n     fn add(a: u8, b: u8) -> u8 { a + b }\n \n     add(200u8, 200u8);"}, {"sha": "8d15fe30a1b07dd9116bc5adee951cebfa9ceb13", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -19,13 +19,11 @@ use std::thread;\n macro_rules! check {\n     ($($e:expr),*) => {\n         $(assert!(thread::spawn({\n-            #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n             move|| { $e; }\n         }).join().is_err());)*\n     }\n }\n \n-#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     check![\n         isize::min_value() / -1,"}, {"sha": "8a723967aff5f04ce6764f9cb121f127b741b181", "filename": "src/test/run-pass/mir_cast_fn_ret.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cbffc5bcfbc4696173678d50d519e9e61676265/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_cast_fn_ret.rs?ref=8cbffc5bcfbc4696173678d50d519e9e61676265", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+pub extern \"C\" fn tuple2() -> (u16, u8) {\n+    (1, 2)\n+}\n+\n+pub extern \"C\" fn tuple3() -> (u8, u8, u8) {\n+    (1, 2, 3)\n+}\n+\n+#[rustc_mir]\n+pub fn test2() -> u8 {\n+    tuple2().1\n+}\n+\n+#[rustc_mir]\n+pub fn test3() -> u8 {\n+    tuple3().2\n+}\n+\n+fn main() {\n+    assert_eq!(test2(), 2);\n+    assert_eq!(test3(), 3);\n+}"}]}