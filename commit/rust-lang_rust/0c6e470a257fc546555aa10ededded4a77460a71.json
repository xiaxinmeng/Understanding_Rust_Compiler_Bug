{"sha": "0c6e470a257fc546555aa10ededded4a77460a71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNmU0NzBhMjU3ZmM1NDY1NTVhYTEwZWRlZGRlZDRhNzc0NjBhNzE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-26T23:54:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-27T21:37:04Z"}, "message": "Convert core::result to camel case", "tree": {"sha": "fb54281612401dba521efedab7626474c80195a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb54281612401dba521efedab7626474c80195a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c6e470a257fc546555aa10ededded4a77460a71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6e470a257fc546555aa10ededded4a77460a71", "html_url": "https://github.com/rust-lang/rust/commit/0c6e470a257fc546555aa10ededded4a77460a71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c6e470a257fc546555aa10ededded4a77460a71/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1582012eafb8b672e15b12b5424e72ea6096af", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1582012eafb8b672e15b12b5424e72ea6096af", "html_url": "https://github.com/rust-lang/rust/commit/3a1582012eafb8b672e15b12b5424e72ea6096af"}], "stats": {"total": 1690, "additions": 845, "deletions": 845}, "files": [{"sha": "6e4862b5e9331a482c7d239a88d564524ab525d4", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -7,7 +7,7 @@ import rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n                                      get_cargo_sysroot, libdir};\n import syntax::diagnostic;\n \n-import result::{ok, err};\n+import result::{Ok, Err};\n import io::WriterUtil;\n import std::{map, json, tempfile, term, sort, getopts};\n import map::hashmap;\n@@ -429,14 +429,14 @@ fn try_parse_sources(filename: &Path, sources: map::hashmap<~str, source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(result::get(c)) {\n-        ok(json::dict(j)) => {\n+        Ok(json::dict(j)) => {\n           for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n                 debug!(\"source: %s\", k);\n             }\n         }\n-        ok(_) => fail ~\"malformed sources.json\",\n-        err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n+        Ok(_) => fail ~\"malformed sources.json\",\n+        Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n     }\n }\n \n@@ -548,17 +548,17 @@ fn load_source_info(c: cargo, src: source) {\n     if !os::path_exists(&srcfile) { return; }\n     let srcstr = io::read_whole_file_str(&srcfile);\n     match json::from_str(result::get(srcstr)) {\n-        ok(json::dict(s)) => {\n+        Ok(json::dict(s)) => {\n             let o = parse_source(src.name, json::dict(s));\n \n             src.key = o.key;\n             src.keyfp = o.keyfp;\n         }\n-        ok(_) => {\n+        Ok(_) => {\n             warn(~\"malformed source.json: \" + src.name +\n                  ~\"(source info is not a dict)\");\n         }\n-        err(e) => {\n+        Err(e) => {\n             warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n@@ -570,7 +570,7 @@ fn load_source_packages(c: cargo, src: source) {\n     if !os::path_exists(&pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(&pkgfile);\n     match json::from_str(result::get(pkgstr)) {\n-        ok(json::list(js)) => {\n+        Ok(json::list(js)) => {\n           for (*js).each |j| {\n                 match j {\n                     json::dict(p) => {\n@@ -583,20 +583,20 @@ fn load_source_packages(c: cargo, src: source) {\n                 }\n             }\n         }\n-        ok(_) => {\n+        Ok(_) => {\n             warn(~\"malformed packages.json: \" + src.name +\n                  ~\"(packages is not a list)\");\n         }\n-        err(e) => {\n+        Err(e) => {\n             warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n \n fn build_cargo_options(argv: ~[~str]) -> options {\n     let matches = match getopts::getopts(argv, opts()) {\n-        result::ok(m) => m,\n-        result::err(f) => {\n+        result::Ok(m) => m,\n+        result::Err(f) => {\n             fail fmt!(\"%s\", getopts::fail_str(f));\n         }\n     };\n@@ -626,8 +626,8 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n \n fn configure(opts: options) -> cargo {\n     let home = match get_cargo_root() {\n-        ok(home) => home,\n-        err(_err) => result::get(get_cargo_sysroot())\n+        Ok(home) => home,\n+        Err(_err) => result::get(get_cargo_sysroot())\n     };\n \n     let get_cargo_dir = match opts.mode {\n@@ -1571,7 +1571,7 @@ fn dump_sources(c: cargo) {\n     }\n \n     match io::buffered_file_writer(&out) {\n-        result::ok(writer) => {\n+        result::Ok(writer) => {\n             let hash = map::str_hash();\n             let root = json::dict(hash);\n \n@@ -1600,7 +1600,7 @@ fn dump_sources(c: cargo) {\n \n             writer.write_str(json::to_str(root));\n         }\n-        result::err(e) => {\n+        result::Err(e) => {\n             error(fmt!(\"could not dump sources: %s\", e));\n         }\n     }"}, {"sha": "ee99b32e89383f518e0ace499c577f59365765a1", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -6,7 +6,7 @@ import vec;\n import task;\n \n import core::result;\n-import result::{ok, err};\n+import result::{Ok, Err};\n \n import common::config;\n import common::mode_run_pass;\n@@ -38,8 +38,8 @@ fn parse_config(args: ~[~str]) -> config {\n     let args_ = vec::tail(args);\n     let matches =\n         match getopts::getopts(args_, opts) {\n-          ok(m) => m,\n-          err(f) => fail getopts::fail_str(f)\n+          Ok(m) => m,\n+          Err(f) => fail getopts::fail_str(f)\n         };\n \n     fn opt_path(m: getopts::matches, nm: ~str) -> Path {"}, {"sha": "d1dbfecb555c997fecabcff171f405757f56bb21", "filename": "src/libcore/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -4,7 +4,7 @@\n \n //! A type that represents one of two alternatives\n \n-import result::result;\n+import result::Result;\n \n /// The either type\n enum Either<T, U> {\n@@ -83,7 +83,7 @@ pure fn flip<T: copy, U: copy>(eith: &Either<T, U>) -> Either<U, T> {\n     }\n }\n \n-pure fn to_result<T: copy, U: copy>(eith: &Either<T, U>) -> result<U, T> {\n+pure fn to_result<T: copy, U: copy>(eith: &Either<T, U>) -> Result<U, T> {\n     /*!\n      * Converts either::t to a result::t\n      *\n@@ -92,8 +92,8 @@ pure fn to_result<T: copy, U: copy>(eith: &Either<T, U>) -> result<U, T> {\n      */\n \n     match *eith {\n-      Right(r) => result::ok(r),\n-      Left(l) => result::err(l)\n+      Right(r) => result::Ok(r),\n+      Left(l) => result::Err(l)\n     }\n }\n "}, {"sha": "dd98e471d7d1549e0abe1a82ece6502d7004f8c3", "filename": "src/libcore/io.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -4,7 +4,7 @@ Module: io\n Basic input/output\n */\n \n-import result::result;\n+import result::Result;\n \n import dvec::{DVec, dvec};\n import libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n@@ -264,16 +264,16 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n \n fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n \n-fn file_reader(path: &Path) -> result<Reader, ~str> {\n+fn file_reader(path: &Path) -> Result<Reader, ~str> {\n     let f = os::as_c_charp(path.to_str(), |pathbuf| {\n         os::as_c_charp(\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n         )\n     });\n-    return if f as uint == 0u { result::err(~\"error opening \"\n+    return if f as uint == 0u { result::Err(~\"error opening \"\n                                             + path.to_str()) }\n     else {\n-        result::ok(FILE_reader(f, true))\n+        result::Ok(FILE_reader(f, true))\n     }\n }\n \n@@ -421,7 +421,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n \n \n fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n-    -> result<Writer, ~str> {\n+    -> Result<Writer, ~str> {\n \n     #[cfg(windows)]\n     fn wb() -> c_int { (O_WRONLY | O_BINARY) as c_int }\n@@ -443,10 +443,10 @@ fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n                    (S_IRUSR | S_IWUSR) as c_int)\n     };\n     if fd < (0 as c_int) {\n-        result::err(fmt!(\"error opening %s: %s\", path.to_str(),\n+        result::Err(fmt!(\"error opening %s: %s\", path.to_str(),\n                          os::last_os_error()))\n     } else {\n-        result::ok(fd_writer(fd, true))\n+        result::Ok(fd_writer(fd, true))\n     }\n }\n \n@@ -623,21 +623,21 @@ impl<T: Writer> T : WriterUtil {\n     fn write_u8(n: u8) { self.write(&[n]) }\n }\n \n-fn file_writer(path: &Path, flags: ~[FileFlag]) -> result<Writer, ~str> {\n-    result::chain(mk_file_writer(path, flags), |w| result::ok(w))\n+fn file_writer(path: &Path, flags: ~[FileFlag]) -> Result<Writer, ~str> {\n+    result::chain(mk_file_writer(path, flags), |w| result::Ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-fn buffered_file_writer(path: &Path) -> result<Writer, ~str> {\n+fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n     let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n         do os::as_c_charp(\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n         }\n     };\n-    return if f as uint == 0u { result::err(~\"error opening \"\n+    return if f as uint == 0u { result::Err(~\"error opening \"\n                                             + path.to_str()) }\n-    else { result::ok(FILE_writer(f, true)) }\n+    else { result::Ok(FILE_writer(f, true)) }\n }\n \n // FIXME (#2004) it would be great if this could be a const\n@@ -719,21 +719,21 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n     return bpos as uint;\n }\n \n-fn read_whole_file_str(file: &Path) -> result<~str, ~str> {\n+fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n     result::chain(read_whole_file(file), |bytes| {\n         if str::is_utf8(bytes) {\n-            result::ok(str::from_bytes(bytes))\n+            result::Ok(str::from_bytes(bytes))\n        } else {\n-           result::err(file.to_str() + ~\" is not UTF-8\")\n+           result::Err(file.to_str() + ~\" is not UTF-8\")\n        }\n     })\n }\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n-fn read_whole_file(file: &Path) -> result<~[u8], ~str> {\n+fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n     result::chain(file_reader(file), |rdr| {\n-        result::ok(rdr.read_whole_stream())\n+        result::Ok(rdr.read_whole_stream())\n     })\n }\n \n@@ -892,30 +892,30 @@ mod tests {\n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n-          result::err(e) => {\n+          result::Err(e) => {\n             assert e == ~\"error opening not a file\";\n           }\n-          result::ok(_) => fail\n+          result::Ok(_) => fail\n         }\n     }\n \n     #[test]\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), ~[]) {\n-          result::err(e) => {\n+          result::Err(e) => {\n             assert str::starts_with(e, \"error opening\");\n           }\n-          result::ok(_) => fail\n+          result::Ok(_) => fail\n         }\n     }\n \n     #[test]\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n-          result::err(e) => {\n+          result::Err(e) => {\n             assert str::starts_with(e, \"error opening\");\n           }\n-          result::ok(_) => fail\n+          result::Ok(_) => fail\n         }\n     }\n "}, {"sha": "e39ce87264ee56cf5ec4e70a0a1d4ba10a0b93d6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -3,11 +3,11 @@\n import either::Either;\n \n /// The result type\n-enum result<T, U> {\n+enum Result<T, U> {\n     /// Contains the successful result value\n-    ok(T),\n+    Ok(T),\n     /// Contains the error value\n-    err(U)\n+    Err(U)\n }\n \n /**\n@@ -17,10 +17,10 @@ enum result<T, U> {\n  *\n  * If the result is an error\n  */\n-pure fn get<T: copy, U>(res: result<T, U>) -> T {\n+pure fn get<T: copy, U>(res: Result<T, U>) -> T {\n     match res {\n-      ok(t) => t,\n-      err(the_err) => unchecked {\n+      Ok(t) => t,\n+      Err(the_err) => unchecked {\n         fail fmt!(\"get called on error result: %?\", the_err)\n       }\n     }\n@@ -33,10 +33,10 @@ pure fn get<T: copy, U>(res: result<T, U>) -> T {\n  *\n  * If the result is an error\n  */\n-pure fn get_ref<T, U>(res: &a/result<T, U>) -> &a/T {\n+pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n     match *res {\n-        ok(ref t) => t,\n-        err(ref the_err) => unchecked {\n+        Ok(ref t) => t,\n+        Err(ref the_err) => unchecked {\n             fail fmt!(\"get_ref called on error result: %?\", the_err)\n         }\n     }\n@@ -49,23 +49,23 @@ pure fn get_ref<T, U>(res: &a/result<T, U>) -> &a/T {\n  *\n  * If the result is not an error\n  */\n-pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n+pure fn get_err<T, U: copy>(res: Result<T, U>) -> U {\n     match res {\n-      err(u) => u,\n-      ok(_) => fail ~\"get_error called on ok result\"\n+      Err(u) => u,\n+      Ok(_) => fail ~\"get_error called on ok result\"\n     }\n }\n \n /// Returns true if the result is `ok`\n-pure fn is_ok<T, U>(res: result<T, U>) -> bool {\n+pure fn is_ok<T, U>(res: Result<T, U>) -> bool {\n     match res {\n-      ok(_) => true,\n-      err(_) => false\n+      Ok(_) => true,\n+      Err(_) => false\n     }\n }\n \n /// Returns true if the result is `err`\n-pure fn is_err<T, U>(res: result<T, U>) -> bool {\n+pure fn is_err<T, U>(res: Result<T, U>) -> bool {\n     !is_ok(res)\n }\n \n@@ -75,10 +75,10 @@ pure fn is_err<T, U>(res: result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> Either<T, U> {\n+pure fn to_either<T: copy, U: copy>(res: Result<U, T>) -> Either<T, U> {\n     match res {\n-      ok(res) => either::Right(res),\n-      err(fail_) => either::Left(fail_)\n+      Ok(res) => either::Right(res),\n+      Err(fail_) => either::Left(fail_)\n     }\n }\n \n@@ -96,11 +96,11 @@ pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> Either<T, U> {\n  *         ok(parse_buf(buf))\n  *     }\n  */\n-fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n-    -> result<U, V> {\n+fn chain<T, U: copy, V: copy>(res: Result<T, V>, op: fn(T) -> Result<U, V>)\n+    -> Result<U, V> {\n     match res {\n-      ok(t) => op(t),\n-      err(e) => err(e)\n+      Ok(t) => op(t),\n+      Err(e) => Err(e)\n     }\n }\n \n@@ -113,12 +113,12 @@ fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n  * successful result while handling an error.\n  */\n fn chain_err<T: copy, U: copy, V: copy>(\n-    res: result<T, V>,\n-    op: fn(V) -> result<T, U>)\n-    -> result<T, U> {\n+    res: Result<T, V>,\n+    op: fn(V) -> Result<T, U>)\n+    -> Result<T, U> {\n     match res {\n-      ok(t) => ok(t),\n-      err(v) => op(v)\n+      Ok(t) => Ok(t),\n+      Err(v) => op(v)\n     }\n }\n \n@@ -136,10 +136,10 @@ fn chain_err<T: copy, U: copy, V: copy>(\n  *         print_buf(buf)\n  *     }\n  */\n-fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n+fn iter<T, E>(res: Result<T, E>, f: fn(T)) {\n     match res {\n-      ok(t) => f(t),\n-      err(_) => ()\n+      Ok(t) => f(t),\n+      Err(_) => ()\n     }\n }\n \n@@ -151,10 +151,10 @@ fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n+fn iter_err<T, E>(res: Result<T, E>, f: fn(E)) {\n     match res {\n-      ok(_) => (),\n-      err(e) => f(e)\n+      Ok(_) => (),\n+      Err(e) => f(e)\n     }\n }\n \n@@ -172,11 +172,11 @@ fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n  *         parse_buf(buf)\n  *     }\n  */\n-fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n-  -> result<U, E> {\n+fn map<T, E: copy, U: copy>(res: Result<T, E>, op: fn(T) -> U)\n+  -> Result<U, E> {\n     match res {\n-      ok(t) => ok(op(t)),\n-      err(e) => err(e)\n+      Ok(t) => Ok(op(t)),\n+      Err(e) => Err(e)\n     }\n }\n \n@@ -188,62 +188,62 @@ fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n-  -> result<T, F> {\n+fn map_err<T: copy, E, F: copy>(res: Result<T, E>, op: fn(E) -> F)\n+  -> Result<T, F> {\n     match res {\n-      ok(t) => ok(t),\n-      err(e) => err(op(e))\n+      Ok(t) => Ok(t),\n+      Err(e) => Err(op(e))\n     }\n }\n \n-impl<T, E> result<T, E> {\n+impl<T, E> Result<T, E> {\n     fn is_ok() -> bool { is_ok(self) }\n \n     fn is_err() -> bool { is_err(self) }\n \n     fn iter(f: fn(T)) {\n         match self {\n-          ok(t) => f(t),\n-          err(_) => ()\n+          Ok(t) => f(t),\n+          Err(_) => ()\n         }\n     }\n \n     fn iter_err(f: fn(E)) {\n         match self {\n-          ok(_) => (),\n-          err(e) => f(e)\n+          Ok(_) => (),\n+          Err(e) => f(e)\n         }\n     }\n }\n \n-impl<T: copy, E> result<T, E> {\n+impl<T: copy, E> Result<T, E> {\n     fn get() -> T { get(self) }\n \n-    fn map_err<F:copy>(op: fn(E) -> F) -> result<T,F> {\n+    fn map_err<F:copy>(op: fn(E) -> F) -> Result<T,F> {\n         match self {\n-          ok(t) => ok(t),\n-          err(e) => err(op(e))\n+          Ok(t) => Ok(t),\n+          Err(e) => Err(op(e))\n         }\n     }\n }\n \n-impl<T, E: copy> result<T, E> {\n+impl<T, E: copy> Result<T, E> {\n     fn get_err() -> E { get_err(self) }\n \n-    fn map<U:copy>(op: fn(T) -> U) -> result<U,E> {\n+    fn map<U:copy>(op: fn(T) -> U) -> Result<U,E> {\n         match self {\n-          ok(t) => ok(op(t)),\n-          err(e) => err(e)\n+          Ok(t) => Ok(op(t)),\n+          Err(e) => Err(e)\n         }\n     }\n }\n \n-impl<T: copy, E: copy> result<T, E> {\n-    fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n+impl<T: copy, E: copy> Result<T, E> {\n+    fn chain<U:copy>(op: fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n-    fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n+    fn chain_err<F:copy>(op: fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n@@ -266,27 +266,27 @@ impl<T: copy, E: copy> result<T, E> {\n  *     }\n  */\n fn map_vec<T,U:copy,V:copy>(\n-    ts: &[T], op: fn(T) -> result<V,U>) -> result<~[V],U> {\n+    ts: &[T], op: fn(T) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = ~[];\n     vec::reserve(vs, vec::len(ts));\n     for vec::each(ts) |t| {\n         match op(t) {\n-          ok(v) => vec::push(vs, v),\n-          err(u) => return err(u)\n+          Ok(v) => vec::push(vs, v),\n+          Err(u) => return Err(u)\n         }\n     }\n-    return ok(vs);\n+    return Ok(vs);\n }\n \n fn map_opt<T,U:copy,V:copy>(\n-    o_t: Option<T>, op: fn(T) -> result<V,U>) -> result<Option<V>,U> {\n+    o_t: Option<T>, op: fn(T) -> Result<V,U>) -> Result<Option<V>,U> {\n \n     match o_t {\n-      None => ok(None),\n+      None => Ok(None),\n       Some(t) => match op(t) {\n-        ok(v) => ok(Some(v)),\n-        err(e) => err(e)\n+        Ok(v) => Ok(Some(v)),\n+        Err(e) => Err(e)\n       }\n     }\n }\n@@ -301,7 +301,7 @@ fn map_opt<T,U:copy,V:copy>(\n  * to accommodate an error like the vectors being of different lengths.\n  */\n fn map_vec2<S,T,U:copy,V:copy>(ss: &[S], ts: &[T],\n-                               op: fn(S,T) -> result<V,U>) -> result<~[V],U> {\n+                               op: fn(S,T) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n@@ -310,12 +310,12 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: &[S], ts: &[T],\n     let mut i = 0u;\n     while i < n {\n         match op(ss[i],ts[i]) {\n-          ok(v) => vec::push(vs, v),\n-          err(u) => return err(u)\n+          Ok(v) => vec::push(vs, v),\n+          Err(u) => return Err(u)\n         }\n         i += 1u;\n     }\n-    return ok(vs);\n+    return Ok(vs);\n }\n \n /**\n@@ -324,27 +324,27 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: &[S], ts: &[T],\n  * on its own as no result vector is built.\n  */\n fn iter_vec2<S,T,U:copy>(ss: &[S], ts: &[T],\n-                         op: fn(S,T) -> result<(),U>) -> result<(),U> {\n+                         op: fn(S,T) -> Result<(),U>) -> Result<(),U> {\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {\n         match op(ss[i],ts[i]) {\n-          ok(()) => (),\n-          err(u) => return err(u)\n+          Ok(()) => (),\n+          Err(u) => return Err(u)\n         }\n         i += 1u;\n     }\n-    return ok(());\n+    return Ok(());\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-fn unwrap<T, U>(-res: result<T, U>) -> T {\n+fn unwrap<T, U>(-res: Result<T, U>) -> T {\n     unsafe {\n         let addr = match res {\n-          ok(x) => ptr::addr_of(x),\n-          err(_) => fail ~\"error result\"\n+          Ok(x) => ptr::addr_of(x),\n+          Err(_) => fail ~\"error result\"\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(res);\n@@ -354,13 +354,13 @@ fn unwrap<T, U>(-res: result<T, U>) -> T {\n \n #[cfg(test)]\n mod tests {\n-    fn op1() -> result::result<int, ~str> { result::ok(666) }\n+    fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n \n-    fn op2(&&i: int) -> result::result<uint, ~str> {\n-        result::ok(i as uint + 1u)\n+    fn op2(&&i: int) -> result::Result<uint, ~str> {\n+        result::Ok(i as uint + 1u)\n     }\n \n-    fn op3() -> result::result<int, ~str> { result::err(~\"sadface\") }\n+    fn op3() -> result::Result<int, ~str> { result::Err(~\"sadface\") }\n \n     #[test]\n     fn chain_success() {\n@@ -375,33 +375,33 @@ mod tests {\n     #[test]\n     fn test_impl_iter() {\n         let mut valid = false;\n-        ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n+        Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n         assert valid;\n \n-        err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n+        Err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_iter_err() {\n         let mut valid = true;\n-        ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n+        Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n         assert valid;\n \n         valid = false;\n-        err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n+        Err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_map() {\n-        assert ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == ok(~\"b\");\n-        assert err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == err(~\"a\");\n+        assert Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\");\n+        assert Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\");\n     }\n \n     #[test]\n     fn test_impl_map_err() {\n-        assert ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == ok(~\"a\");\n-        assert err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == err(~\"b\");\n+        assert Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\");\n+        assert Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\");\n     }\n }"}, {"sha": "8b4b078d5f54589faba08f7728744a9d201715fc", "filename": "src/libcore/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -27,7 +27,7 @@\n  * ~~~\n  */\n \n-import result::result;\n+import result::Result;\n \n export Task;\n export TaskResult;\n@@ -406,7 +406,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T: send>(+f: fn~() -> T) -> result<T,()> {\n+    fn try<T: send>(+f: fn~() -> T) -> Result<T,()> {\n         let po = comm::port();\n         let ch = comm::chan(po);\n         let mut result = None;\n@@ -415,8 +415,8 @@ impl TaskBuilder {\n             comm::send(ch, f());\n         }\n         match future::get(&option::unwrap(result)) {\n-            Success => result::ok(comm::recv(po)),\n-            Failure => result::err(())\n+            Success => result::Ok(comm::recv(po)),\n+            Failure => result::Err(())\n         }\n     }\n }\n@@ -526,7 +526,7 @@ fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     task().sched_mode(mode).spawn(f)\n }\n \n-fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n+fn try<T:send>(+f: fn~() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -1769,7 +1769,7 @@ fn test_try_success() {\n     match do try {\n         ~\"Success!\"\n     } {\n-        result::ok(~\"Success!\") => (),\n+        result::Ok(~\"Success!\") => (),\n         _ => fail\n     }\n }\n@@ -1780,8 +1780,8 @@ fn test_try_fail() {\n     match do try {\n         fail\n     } {\n-        result::err(()) => (),\n-        result::ok(()) => fail\n+        result::Err(()) => (),\n+        result::Ok(()) => fail\n     }\n }\n "}, {"sha": "bf85f19a51697cfc113165427d45c7deb34d9903", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -62,7 +62,7 @@\n  *     }\n  */\n \n-import core::result::{err, ok};\n+import core::result::{Err, Ok};\n import core::option;\n import core::option::{Some, None};\n export opt;\n@@ -179,7 +179,7 @@ fn fail_str(f: fail_) -> ~str {\n  * The result of parsing a command line with a set of options\n  * (result::t<matches, fail_>)\n  */\n-type result = result::result<matches, fail_>;\n+type result = result::Result<matches, fail_>;\n \n /**\n  * Parse command line arguments according to the provided options\n@@ -261,12 +261,12 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                 name_pos += 1u;\n                 let optid = match find_opt(opts, nm) {\n                   Some(id) => id,\n-                  None => return err(unrecognized_option(name_str(nm)))\n+                  None => return Err(unrecognized_option(name_str(nm)))\n                 };\n                 match opts[optid].hasarg {\n                   no => {\n                     if !option::is_none::<~str>(i_arg) {\n-                        return err(unexpected_argument(name_str(nm)));\n+                        return Err(unexpected_argument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], given);\n                   }\n@@ -283,7 +283,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n                         vec::push(vals[optid],\n                                   val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n-                        return err(argument_missing(name_str(nm)));\n+                        return Err(argument_missing(name_str(nm)));\n                     } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n                 }\n@@ -297,17 +297,17 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n         let occ = opts[i].occur;\n         if occ == req {\n             if n == 0u {\n-                return err(option_missing(name_str(opts[i].name)));\n+                return Err(option_missing(name_str(opts[i].name)));\n             }\n         }\n         if occ != multi {\n             if n > 1u {\n-                return err(option_duplicated(name_str(opts[i].name)));\n+                return Err(option_duplicated(name_str(opts[i].name)));\n             }\n         }\n         i += 1u;\n     }\n-    return ok({opts: opts, vals: vec::from_mut(vals), free: free});\n+    return Ok({opts: opts, vals: vec::from_mut(vals), free: free});\n }\n \n fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n@@ -404,7 +404,7 @@ fn opt_default(m: matches, nm: ~str, def: ~str) -> Option<~str> {\n #[cfg(test)]\n mod tests {\n     import opt = getopts;\n-    import result::{err, ok};\n+    import result::{Err, Ok};\n \n     enum fail_type {\n         argument_missing_,\n@@ -432,7 +432,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n@@ -446,7 +446,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_missing_),\n+          Err(f) => check_fail_type(f, option_missing_),\n           _ => fail\n         }\n     }\n@@ -457,7 +457,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n     }\n@@ -468,7 +468,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n     }\n@@ -479,7 +479,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n@@ -493,7 +493,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_missing_),\n+          Err(f) => check_fail_type(f, option_missing_),\n           _ => fail\n         }\n     }\n@@ -504,7 +504,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n     }\n@@ -515,7 +515,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n     }\n@@ -528,7 +528,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n@@ -542,7 +542,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(m) => assert (!opt_present(m, ~\"test\")),\n           _ => fail\n         }\n     }\n@@ -553,7 +553,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n     }\n@@ -564,7 +564,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n     }\n@@ -575,7 +575,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n@@ -589,7 +589,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(m) => assert (!opt_present(m, ~\"t\")),\n           _ => fail\n         }\n     }\n@@ -600,7 +600,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n     }\n@@ -611,7 +611,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n     }\n@@ -624,7 +624,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (opt_present(m, ~\"test\")),\n+          Ok(m) => assert (opt_present(m, ~\"test\")),\n           _ => fail\n         }\n     }\n@@ -635,7 +635,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(m) => assert (!opt_present(m, ~\"test\")),\n           _ => fail\n         }\n     }\n@@ -646,7 +646,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => {\n+          Err(f) => {\n             log(error, fail_str(f));\n             check_fail_type(f, unexpected_argument_);\n           }\n@@ -660,7 +660,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n     }\n@@ -671,7 +671,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (opt_present(m, ~\"t\")),\n+          Ok(m) => assert (opt_present(m, ~\"t\")),\n           _ => fail\n         }\n     }\n@@ -682,7 +682,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(m) => assert (!opt_present(m, ~\"t\")),\n           _ => fail\n         }\n     }\n@@ -693,7 +693,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             // The next variable after the flag is just a free argument\n \n             assert (m.free[0] == ~\"20\");\n@@ -708,7 +708,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, option_duplicated_),\n           _ => fail\n         }\n     }\n@@ -721,7 +721,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n@@ -735,7 +735,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(m) => assert (!opt_present(m, ~\"test\")),\n           _ => fail\n         }\n     }\n@@ -746,7 +746,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n     }\n@@ -757,7 +757,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n             assert (opt_strs(m, ~\"test\")[0] == ~\"20\");\n@@ -773,7 +773,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n@@ -787,7 +787,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(m) => assert (!opt_present(m, ~\"t\")),\n           _ => fail\n         }\n     }\n@@ -798,7 +798,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, argument_missing_),\n           _ => fail\n         }\n     }\n@@ -809,7 +809,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n             assert (opt_strs(m, ~\"t\")[0] == ~\"20\");\n@@ -825,7 +825,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, unrecognized_option_),\n+          Err(f) => check_fail_type(f, unrecognized_option_),\n           _ => fail\n         }\n     }\n@@ -836,7 +836,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          err(f) => check_fail_type(f, unrecognized_option_),\n+          Err(f) => check_fail_type(f, unrecognized_option_),\n           _ => fail\n         }\n     }\n@@ -853,7 +853,7 @@ mod tests {\n              optopt(~\"notpresent\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          ok(m) => {\n+          Ok(m) => {\n             assert (m.free[0] == ~\"prog\");\n             assert (m.free[1] == ~\"free1\");\n             assert (opt_str(m, ~\"s\") == ~\"20\");\n@@ -876,8 +876,8 @@ mod tests {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = match getopts(args, opts) {\n-          result::ok(m) => m,\n-          result::err(_) => fail\n+          result::Ok(m) => m,\n+          result::Err(_) => fail\n         };\n         assert opts_present(matches, ~[~\"e\"]);\n         assert opts_present(matches, ~[~\"encrypt\"]);\n@@ -897,8 +897,8 @@ mod tests {\n         let args = ~[~\"-Lfoo\"];\n         let opts = ~[optmulti(~\"L\")];\n         let matches = match getopts(args, opts) {\n-          result::ok(m) => m,\n-          result::err(_) => fail\n+          result::Ok(m) => m,\n+          result::Err(_) => fail\n         };\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";"}, {"sha": "aec68965e660ceef88675259cbce039a03ac5a36", "filename": "src/libstd/json.rs", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -3,7 +3,7 @@\n \n //! json serialization\n \n-import result::{result, ok, err};\n+import result::{Result, Ok, Err};\n import io;\n import io::WriterUtil;\n import map;\n@@ -138,18 +138,18 @@ impl parser {\n         self.ch\n     }\n \n-    fn error<T>(+msg: ~str) -> result<T, error> {\n-        err({ line: self.line, col: self.col, msg: @msg })\n+    fn error<T>(+msg: ~str) -> Result<T, error> {\n+        Err({ line: self.line, col: self.col, msg: @msg })\n     }\n \n-    fn parse() -> result<json, error> {\n+    fn parse() -> Result<json, error> {\n         match self.parse_value() {\n-          ok(value) => {\n+          Ok(value) => {\n             // Skip trailing whitespaces.\n             self.parse_whitespace();\n             // Make sure there is no trailing characters.\n             if self.eof() {\n-                ok(value)\n+                Ok(value)\n             } else {\n                 self.error(~\"trailing characters\")\n             }\n@@ -158,7 +158,7 @@ impl parser {\n         }\n     }\n \n-    fn parse_value() -> result<json, error> {\n+    fn parse_value() -> Result<json, error> {\n         self.parse_whitespace();\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n@@ -169,8 +169,8 @@ impl parser {\n           'f' => self.parse_ident(~\"alse\", boolean(false)),\n           '0' to '9' | '-' => self.parse_number(),\n           '\"' => match self.parse_str() {\n-            ok(s) => ok(string(s)),\n-            err(e) => err(e)\n+            Ok(s) => Ok(string(s)),\n+            Err(e) => Err(e)\n           },\n           '[' => self.parse_list(),\n           '{' => self.parse_object(),\n@@ -182,16 +182,16 @@ impl parser {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: ~str, value: json) -> result<json, error> {\n+    fn parse_ident(ident: ~str, value: json) -> Result<json, error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n-            ok(value)\n+            Ok(value)\n         } else {\n             self.error(~\"invalid syntax\")\n         }\n     }\n \n-    fn parse_number() -> result<json, error> {\n+    fn parse_number() -> Result<json, error> {\n         let mut neg = 1f;\n \n         if self.ch == '-' {\n@@ -200,28 +200,28 @@ impl parser {\n         }\n \n         let mut res = match self.parse_integer() {\n-          ok(res) => res,\n-          err(e) => return err(e)\n+          Ok(res) => res,\n+          Err(e) => return Err(e)\n         };\n \n         if self.ch == '.' {\n             match self.parse_decimal(res) {\n-              ok(r) => res = r,\n-              err(e) => return err(e)\n+              Ok(r) => res = r,\n+              Err(e) => return Err(e)\n             }\n         }\n \n         if self.ch == 'e' || self.ch == 'E' {\n             match self.parse_exponent(res) {\n-              ok(r) => res = r,\n-              err(e) => return err(e)\n+              Ok(r) => res = r,\n+              Err(e) => return Err(e)\n             }\n         }\n \n-        ok(num(neg * res))\n+        Ok(num(neg * res))\n     }\n \n-    fn parse_integer() -> result<float, error> {\n+    fn parse_integer() -> Result<float, error> {\n         let mut res = 0f;\n \n         match self.ch {\n@@ -250,10 +250,10 @@ impl parser {\n           _ => return self.error(~\"invalid number\")\n         }\n \n-        ok(res)\n+        Ok(res)\n     }\n \n-    fn parse_decimal(res: float) -> result<float, error> {\n+    fn parse_decimal(res: float) -> Result<float, error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -276,10 +276,10 @@ impl parser {\n             }\n         }\n \n-        ok(res)\n+        Ok(res)\n     }\n \n-    fn parse_exponent(res: float) -> result<float, error> {\n+    fn parse_exponent(res: float) -> Result<float, error> {\n         self.bump();\n \n         let mut res = res;\n@@ -317,10 +317,10 @@ impl parser {\n             res *= exp;\n         }\n \n-        ok(res)\n+        Ok(res)\n     }\n \n-    fn parse_str() -> result<@~str, error> {\n+    fn parse_str() -> Result<@~str, error> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -367,7 +367,7 @@ impl parser {\n             } else {\n                 if self.ch == '\"' {\n                     self.bump();\n-                    return ok(@res);\n+                    return Ok(@res);\n                 }\n                 str::push_char(res, self.ch);\n             }\n@@ -376,20 +376,20 @@ impl parser {\n         self.error(~\"EOF while parsing string\")\n     }\n \n-    fn parse_list() -> result<json, error> {\n+    fn parse_list() -> Result<json, error> {\n         self.bump();\n         self.parse_whitespace();\n \n         let mut values = ~[];\n \n         if self.ch == ']' {\n             self.bump();\n-            return ok(list(@values));\n+            return Ok(list(@values));\n         }\n \n         loop {\n             match self.parse_value() {\n-              ok(v) => vec::push(values, v),\n+              Ok(v) => vec::push(values, v),\n               e => return e\n             }\n \n@@ -400,21 +400,21 @@ impl parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return ok(list(@values)); }\n+              ']' => { self.bump(); return Ok(list(@values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n     }\n \n-    fn parse_object() -> result<json, error> {\n+    fn parse_object() -> Result<json, error> {\n         self.bump();\n         self.parse_whitespace();\n \n         let values = map::str_hash();\n \n         if self.ch == '}' {\n           self.bump();\n-          return ok(dict(values));\n+          return Ok(dict(values));\n         }\n \n         while !self.eof() {\n@@ -425,8 +425,8 @@ impl parser {\n             }\n \n             let key = match self.parse_str() {\n-              ok(key) => key,\n-              err(e) => return err(e)\n+              Ok(key) => key,\n+              Err(e) => return Err(e)\n             };\n \n             self.parse_whitespace();\n@@ -438,14 +438,14 @@ impl parser {\n             self.bump();\n \n             match self.parse_value() {\n-              ok(value) => { values.insert(copy *key, value); }\n+              Ok(value) => { values.insert(copy *key, value); }\n               e => return e\n             }\n             self.parse_whitespace();\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return ok(dict(values)); }\n+              '}' => { self.bump(); return Ok(dict(values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -458,7 +458,7 @@ impl parser {\n }\n \n /// Deserializes a json value from an io::reader\n-fn from_reader(rdr: io::Reader) -> result<json, error> {\n+fn from_reader(rdr: io::Reader) -> Result<json, error> {\n     let parser = parser_({\n         rdr: rdr,\n         mut ch: rdr.read_char(),\n@@ -470,7 +470,7 @@ fn from_reader(rdr: io::Reader) -> result<json, error> {\n }\n \n /// Deserializes a json value from a string\n-fn from_str(s: ~str) -> result<json, error> {\n+fn from_str(s: ~str) -> Result<json, error> {\n     io::with_str_reader(s, from_reader)\n }\n \n@@ -705,138 +705,138 @@ mod tests {\n     #[test]\n     fn test_trailing_characters() {\n         assert from_str(~\"nulla\") ==\n-            err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n+            Err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n         assert from_str(~\"truea\") ==\n-            err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n+            Err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n         assert from_str(~\"falsea\") ==\n-            err({line: 1u, col: 6u, msg: @~\"trailing characters\"});\n+            Err({line: 1u, col: 6u, msg: @~\"trailing characters\"});\n         assert from_str(~\"1a\") ==\n-            err({line: 1u, col: 2u, msg: @~\"trailing characters\"});\n+            Err({line: 1u, col: 2u, msg: @~\"trailing characters\"});\n         assert from_str(~\"[]a\") ==\n-            err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+            Err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n         assert from_str(~\"{}a\") ==\n-            err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+            Err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert from_str(~\"n\") ==\n-            err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"nul\") ==\n-            err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"t\") ==\n-            err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"truz\") ==\n-            err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"f\") ==\n-            err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"faz\") ==\n-            err({line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n \n-        assert from_str(~\"null\") == ok(null);\n-        assert from_str(~\"true\") == ok(boolean(true));\n-        assert from_str(~\"false\") == ok(boolean(false));\n-        assert from_str(~\" null \") == ok(null);\n-        assert from_str(~\" true \") == ok(boolean(true));\n-        assert from_str(~\" false \") == ok(boolean(false));\n+        assert from_str(~\"null\") == Ok(null);\n+        assert from_str(~\"true\") == Ok(boolean(true));\n+        assert from_str(~\"false\") == Ok(boolean(false));\n+        assert from_str(~\" null \") == Ok(null);\n+        assert from_str(~\" true \") == Ok(boolean(true));\n+        assert from_str(~\" false \") == Ok(boolean(false));\n     }\n \n     #[test]\n     fn test_read_num() {\n         assert from_str(~\"+\") ==\n-            err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n         assert from_str(~\".\") ==\n-            err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"-\") ==\n-            err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n+            Err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n         assert from_str(~\"00\") ==\n-            err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n+            Err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n         assert from_str(~\"1.\") ==\n-            err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n+            Err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n         assert from_str(~\"1e\") ==\n-            err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n+            Err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n         assert from_str(~\"1e+\") ==\n-            err({line: 1u, col: 4u, msg: @~\"invalid number\"});\n+            Err({line: 1u, col: 4u, msg: @~\"invalid number\"});\n \n-        assert from_str(~\"3\") == ok(num(3f));\n-        assert from_str(~\"3.1\") == ok(num(3.1f));\n-        assert from_str(~\"-1.2\") == ok(num(-1.2f));\n-        assert from_str(~\"0.4\") == ok(num(0.4f));\n-        assert from_str(~\"0.4e5\") == ok(num(0.4e5f));\n-        assert from_str(~\"0.4e+15\") == ok(num(0.4e15f));\n-        assert from_str(~\"0.4e-01\") == ok(num(0.4e-01f));\n-        assert from_str(~\" 3 \") == ok(num(3f));\n+        assert from_str(~\"3\") == Ok(num(3f));\n+        assert from_str(~\"3.1\") == Ok(num(3.1f));\n+        assert from_str(~\"-1.2\") == Ok(num(-1.2f));\n+        assert from_str(~\"0.4\") == Ok(num(0.4f));\n+        assert from_str(~\"0.4e5\") == Ok(num(0.4e5f));\n+        assert from_str(~\"0.4e+15\") == Ok(num(0.4e15f));\n+        assert from_str(~\"0.4e-01\") == Ok(num(0.4e-01f));\n+        assert from_str(~\" 3 \") == Ok(num(3f));\n     }\n \n     #[test]\n     fn test_read_str() {\n         assert from_str(~\"\\\"\") ==\n-            err({line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n+            Err({line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n         assert from_str(~\"\\\"lol\") ==\n-            err({line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n+            Err({line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n \n-        assert from_str(~\"\\\"\\\"\") == ok(string(@~\"\"));\n-        assert from_str(~\"\\\"foo\\\"\") == ok(string(@~\"foo\"));\n-        assert from_str(~\"\\\"\\\\\\\"\\\"\") == ok(string(@~\"\\\"\"));\n-        assert from_str(~\"\\\"\\\\b\\\"\") == ok(string(@~\"\\x08\"));\n-        assert from_str(~\"\\\"\\\\n\\\"\") == ok(string(@~\"\\n\"));\n-        assert from_str(~\"\\\"\\\\r\\\"\") == ok(string(@~\"\\r\"));\n-        assert from_str(~\"\\\"\\\\t\\\"\") == ok(string(@~\"\\t\"));\n-        assert from_str(~\" \\\"foo\\\" \") == ok(string(@~\"foo\"));\n+        assert from_str(~\"\\\"\\\"\") == Ok(string(@~\"\"));\n+        assert from_str(~\"\\\"foo\\\"\") == Ok(string(@~\"foo\"));\n+        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(string(@~\"\\\"\"));\n+        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(string(@~\"\\x08\"));\n+        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(string(@~\"\\n\"));\n+        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(string(@~\"\\r\"));\n+        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(string(@~\"\\t\"));\n+        assert from_str(~\" \\\"foo\\\" \") == Ok(string(@~\"foo\"));\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert from_str(~\"[\") ==\n-            err({line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n+            Err({line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n         assert from_str(~\"[1\") ==\n-            err({line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n+            Err({line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n         assert from_str(~\"[1,\") ==\n-            err({line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n+            Err({line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n         assert from_str(~\"[1,]\") ==\n-            err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+            Err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"[6 7]\") ==\n-            err({line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n-\n-        assert from_str(~\"[]\") == ok(list(@~[]));\n-        assert from_str(~\"[ ]\") == ok(list(@~[]));\n-        assert from_str(~\"[true]\") == ok(list(@~[boolean(true)]));\n-        assert from_str(~\"[ false ]\") == ok(list(@~[boolean(false)]));\n-        assert from_str(~\"[null]\") == ok(list(@~[null]));\n-        assert from_str(~\"[3, 1]\") == ok(list(@~[num(3f), num(1f)]));\n-        assert from_str(~\"\\n[3, 2]\\n\") == ok(list(@~[num(3f), num(2f)]));\n+            Err({line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n+\n+        assert from_str(~\"[]\") == Ok(list(@~[]));\n+        assert from_str(~\"[ ]\") == Ok(list(@~[]));\n+        assert from_str(~\"[true]\") == Ok(list(@~[boolean(true)]));\n+        assert from_str(~\"[ false ]\") == Ok(list(@~[boolean(false)]));\n+        assert from_str(~\"[null]\") == Ok(list(@~[null]));\n+        assert from_str(~\"[3, 1]\") == Ok(list(@~[num(3f), num(1f)]));\n+        assert from_str(~\"\\n[3, 2]\\n\") == Ok(list(@~[num(3f), num(2f)]));\n         assert from_str(~\"[2, [4, 1]]\") ==\n-               ok(list(@~[num(2f), list(@~[num(4f), num(1f)])]));\n+               Ok(list(@~[num(2f), list(@~[num(4f), num(1f)])]));\n     }\n \n     #[test]\n     fn test_read_dict() {\n         assert from_str(~\"{\") ==\n-            err({line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{ \") ==\n-            err({line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{1\") ==\n-            err({line: 1u, col: 2u, msg: @~\"key must be a string\"});\n+            Err({line: 1u, col: 2u, msg: @~\"key must be a string\"});\n         assert from_str(~\"{ \\\"a\\\"\") ==\n-            err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{\\\"a\\\"\") ==\n-            err({line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{\\\"a\\\" \") ==\n-            err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n \n         assert from_str(~\"{\\\"a\\\" 1\") ==\n-            err({line: 1u, col: 6u, msg: @~\"expected `:`\"});\n+            Err({line: 1u, col: 6u, msg: @~\"expected `:`\"});\n         assert from_str(~\"{\\\"a\\\":\") ==\n-            err({line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n+            Err({line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n         assert from_str(~\"{\\\"a\\\":1\") ==\n-            err({line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{\\\"a\\\":1 1\") ==\n-            err({line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n+            Err({line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n         assert from_str(~\"{\\\"a\\\":1,\") ==\n-            err({line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n \n         assert eq(result::get(from_str(~\"{}\")), mk_dict(~[]));\n         assert eq(result::get(from_str(~\"{\\\"a\\\": 3}\")),\n@@ -879,6 +879,6 @@ mod tests {\n     #[test]\n     fn test_multiline_errors() {\n         assert from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            err({line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n+            Err({line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n     }\n }"}, {"sha": "9458aca8db4d69030e22e63403ccef3055e633b6", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -85,7 +85,7 @@ enum ip_get_addr_err {\n  * object in the case of failure\n  */\n fn get_addr(++node: ~str, iotask: iotask)\n-        -> result::result<~[ip_addr], ip_get_addr_err> {\n+        -> result::Result<~[ip_addr], ip_get_addr_err> {\n     do core::comm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| unsafe {\n             log(debug, fmt!(\"slice len %?\", len));\n@@ -108,7 +108,7 @@ fn get_addr(++node: ~str, iotask: iotask)\n                     set_data_for_req(handle_ptr, handle_data_ptr);\n                   }\n                   _ => {\n-                    output_ch.send(result::err(get_addr_unknown_error));\n+                    output_ch.send(result::Err(get_addr_unknown_error));\n                   }\n                 }\n             };\n@@ -135,8 +135,8 @@ mod v4 {\n      */\n     fn parse_addr(ip: ~str) -> ip_addr {\n         match try_parse_addr(ip) {\n-          result::ok(addr) => copy(addr),\n-          result::err(err_data) => fail err_data.err_msg\n+          result::Ok(addr) => copy(addr),\n+          result::Err(err_data) => fail err_data.err_msg\n         }\n     }\n     // the simple, old style numberic representation of\n@@ -153,31 +153,31 @@ mod v4 {\n             *((ptr::addr_of(self)) as *u32)\n         }\n     }\n-    fn parse_to_ipv4_rep(ip: ~str) -> result::result<ipv4_rep, ~str> {\n+    fn parse_to_ipv4_rep(ip: ~str) -> result::Result<ipv4_rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             match uint::from_str(s) {\n               Some(n) if n <= 255u => n,\n               _ => 256u\n             }\n         });\n         if vec::len(parts) != 4u {\n-                result::err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n+                result::Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n                 }\n         else if vec::contains(parts, 256u) {\n-                result::err(fmt!(\"invalid octal in addr '%s'\", ip))\n+                result::Err(fmt!(\"invalid octal in addr '%s'\", ip))\n                 }\n         else {\n-            result::ok({a: parts[0] as u8, b: parts[1] as u8,\n+            result::Ok({a: parts[0] as u8, b: parts[1] as u8,\n                         c: parts[2] as u8, d: parts[3] as u8})\n         }\n     }\n-    fn try_parse_addr(ip: ~str) -> result::result<ip_addr,parse_addr_err> {\n+    fn try_parse_addr(ip: ~str) -> result::Result<ip_addr,parse_addr_err> {\n         unsafe {\n             let INADDR_NONE = ll::get_INADDR_NONE();\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n             if result::is_err(ip_rep_result) {\n                 let err_str = result::get_err(ip_rep_result);\n-                return result::err({err_msg: err_str})\n+                return result::Err({err_msg: err_str})\n             }\n             // ipv4_rep.as_u32 is unsafe :/\n             let input_is_inaddr_none =\n@@ -190,15 +190,15 @@ mod v4 {\n             let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n             if result::is_err(ref_ip_rep_result) {\n                 let err_str = result::get_err(ref_ip_rep_result);\n-                return result::err({err_msg: err_str})\n+                return result::Err({err_msg: err_str})\n             }\n             if result::get(ref_ip_rep_result).as_u32() == INADDR_NONE &&\n                  !input_is_inaddr_none {\n-                return result::err(\n+                return result::Err(\n                     {err_msg: ~\"uv_ip4_name produced invalid result.\"})\n             }\n             else {\n-                result::ok(ipv4(copy(new_addr)))\n+                result::Ok(ipv4(copy(new_addr)))\n             }\n         }\n     }\n@@ -221,11 +221,11 @@ mod v6 {\n      */\n     fn parse_addr(ip: ~str) -> ip_addr {\n         match try_parse_addr(ip) {\n-          result::ok(addr) => copy(addr),\n-          result::err(err_data) => fail err_data.err_msg\n+          result::Ok(addr) => copy(addr),\n+          result::Err(err_data) => fail err_data.err_msg\n         }\n     }\n-    fn try_parse_addr(ip: ~str) -> result::result<ip_addr,parse_addr_err> {\n+    fn try_parse_addr(ip: ~str) -> result::Result<ip_addr,parse_addr_err> {\n         unsafe {\n             // need to figure out how to establish a parse failure..\n             let new_addr = uv_ip6_addr(ip, 22);\n@@ -235,18 +235,18 @@ mod v6 {\n             // '::' appears to be uv_ip6_name() returns for bogus\n             // parses..\n             if  ip != ~\"::\" && reparsed_name == ~\"::\" {\n-                result::err({err_msg:fmt!(\"failed to parse '%s'\",\n+                result::Err({err_msg:fmt!(\"failed to parse '%s'\",\n                                            ip)})\n             }\n             else {\n-                result::ok(ipv6(new_addr))\n+                result::Ok(ipv6(new_addr))\n             }\n         }\n     }\n }\n \n type get_addr_data = {\n-    output_ch: comm::Chan<result::result<~[ip_addr],ip_get_addr_err>>\n+    output_ch: comm::Chan<result::Result<~[ip_addr],ip_get_addr_err>>\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n@@ -272,7 +272,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                     log(debug, ~\"curr_addr is not of family AF_INET or \"+\n                         ~\"AF_INET6. Error.\");\n                     (*handle_data).output_ch.send(\n-                        result::err(get_addr_unknown_error));\n+                        result::Err(get_addr_unknown_error));\n                     break;\n                 };\n                 out_vec += ~[new_ip_addr];\n@@ -289,18 +289,18 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n             }\n             log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n                             vec::len(out_vec)));\n-            (*handle_data).output_ch.send(result::ok(out_vec));\n+            (*handle_data).output_ch.send(result::Ok(out_vec));\n         }\n         else {\n             log(debug, ~\"addrinfo pointer is NULL\");\n             (*handle_data).output_ch.send(\n-                result::err(get_addr_unknown_error));\n+                result::Err(get_addr_unknown_error));\n         }\n     }\n     else {\n         log(debug, ~\"status != 0 error in get_addr_cb\");\n         (*handle_data).output_ch.send(\n-            result::err(get_addr_unknown_error));\n+            result::Err(get_addr_unknown_error));\n     }\n     if res != (ptr::null::<addrinfo>()) {\n         uv_freeaddrinfo(res);\n@@ -327,11 +327,11 @@ mod test {\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         match v4::try_parse_addr(~\"b4df00d\") {\n-          result::err(err_info) => {\n+          result::Err(err_info) => {\n             log(debug, fmt!(\"got error as expected %?\", err_info));\n             assert true;\n           }\n-          result::ok(addr) => {\n+          result::Ok(addr) => {\n             fail fmt!(\"Expected failure, but got addr %?\", addr);\n           }\n         }\n@@ -340,11 +340,11 @@ mod test {\n     #[ignore(target_os=\"win32\")]\n     fn test_ip_ipv6_bad_parse() {\n         match v6::try_parse_addr(~\"::,~2234k;\") {\n-          result::err(err_info) => {\n+          result::Err(err_info) => {\n             log(debug, fmt!(\"got error as expected %?\", err_info));\n             assert true;\n           }\n-          result::ok(addr) => {\n+          result::Ok(addr) => {\n             fail fmt!(\"Expected failure, but got addr %?\", addr);\n           }\n         }"}, {"sha": "07c5319ae3d0f4dcdceb78dc5a5afc221b5356c1", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -120,15 +120,15 @@ enum tcp_connect_err_data {\n  */\n fn connect(-input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n-    -> result::result<tcp_socket, tcp_connect_err_data> unsafe {\n+    -> result::Result<tcp_socket, tcp_connect_err_data> unsafe {\n     let result_po = core::comm::port::<conn_attempt>();\n     let closed_signal_po = core::comm::port::<()>();\n     let conn_data = {\n         result_ch: core::comm::chan(result_po),\n         closed_signal_ch: core::comm::chan(closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n-    let reader_po = core::comm::port::<result::result<~[u8], tcp_err_data>>();\n+    let reader_po = core::comm::port::<result::Result<~[u8], tcp_err_data>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n     let socket_data = @{\n@@ -220,7 +220,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n     match core::comm::recv(result_po) {\n       conn_success => {\n         log(debug, ~\"tcp::connect - received success on result_po\");\n-        result::ok(tcp_socket(socket_data))\n+        result::Ok(tcp_socket(socket_data))\n       }\n       conn_failure(err_data) => {\n         core::comm::recv(closed_signal_po);\n@@ -232,7 +232,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n           ~\"ECONNREFUSED\" => connection_refused,\n           _ => generic_connect_err(err_data.err_name, err_data.err_msg)\n         };\n-        result::err(tcp_conn_err)\n+        result::Err(tcp_conn_err)\n       }\n     }\n }\n@@ -252,7 +252,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n  * `tcp_err_data` value as the `err` variant\n  */\n fn write(sock: tcp_socket, raw_write_data: ~[u8])\n-    -> result::result<(), tcp_err_data> unsafe {\n+    -> result::Result<(), tcp_err_data> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     write_common_impl(socket_data_ptr, raw_write_data)\n }\n@@ -289,7 +289,7 @@ fn write(sock: tcp_socket, raw_write_data: ~[u8])\n  * value as the `err` variant\n  */\n fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n-    -> future::Future<result::result<(), tcp_err_data>> unsafe {\n+    -> future::Future<result::Result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n         let data_copy = copy(raw_write_data);\n@@ -313,8 +313,8 @@ fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n  * `tcp_err_data` record\n  */\n fn read_start(sock: tcp_socket)\n-    -> result::result<comm::Port<\n-        result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+    -> result::Result<comm::Port<\n+        result::Result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_start_common_impl(socket_data)\n }\n@@ -327,8 +327,8 @@ fn read_start(sock: tcp_socket)\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n fn read_stop(sock: tcp_socket,\n-             -read_port: comm::Port<result::result<~[u8], tcp_err_data>>) ->\n-    result::result<(), tcp_err_data> unsafe {\n+             -read_port: comm::Port<result::Result<~[u8], tcp_err_data>>) ->\n+    result::Result<(), tcp_err_data> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(*sock.socket_data);\n     read_stop_common_impl(socket_data)\n@@ -350,7 +350,7 @@ fn read_stop(sock: tcp_socket,\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n fn read(sock: tcp_socket, timeout_msecs: uint)\n-    -> result::result<~[u8],tcp_err_data> {\n+    -> result::Result<~[u8],tcp_err_data> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_common_impl(socket_data, timeout_msecs)\n }\n@@ -385,7 +385,7 @@ fn read(sock: tcp_socket, timeout_msecs: uint)\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n fn read_future(sock: tcp_socket, timeout_msecs: uint)\n-    -> future::Future<result::result<~[u8],tcp_err_data>> {\n+    -> future::Future<result::Result<~[u8],tcp_err_data>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n         read_common_impl(socket_data, timeout_msecs)\n@@ -462,7 +462,7 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n  * as the `err` variant of a `result`.\n  */\n fn accept(new_conn: tcp_new_connection)\n-    -> result::result<tcp_socket, tcp_err_data> unsafe {\n+    -> result::Result<tcp_socket, tcp_err_data> unsafe {\n \n     match new_conn{\n       new_tcp_conn(server_handle_ptr) => {\n@@ -524,8 +524,8 @@ fn accept(new_conn: tcp_new_connection)\n         }\n         // UNSAFE LIBUV INTERACTION END\n         match core::comm::recv(result_po) {\n-          Some(err_data) => result::err(err_data),\n-          None => result::ok(tcp_socket(client_socket_data))\n+          Some(err_data) => result::Err(err_data),\n+          None => result::Ok(tcp_socket(client_socket_data))\n         }\n       }\n     }\n@@ -564,7 +564,7 @@ fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n                                comm::Chan<Option<tcp_err_data>>))\n-    -> result::result<(), tcp_listen_err_data> unsafe {\n+    -> result::Result<(), tcp_listen_err_data> unsafe {\n     do listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n         // on_connect_cb\n         |handle| unsafe {\n@@ -580,7 +580,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n-    -> result::result<(), tcp_listen_err_data> unsafe {\n+    -> result::Result<(), tcp_listen_err_data> unsafe {\n     let stream_closed_po = core::comm::port::<()>();\n     let kill_po = core::comm::port::<Option<tcp_err_data>>();\n     let kill_ch = core::comm::chan(kill_po);\n@@ -666,16 +666,16 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         match err_data.err_name {\n           ~\"EACCES\" => {\n             log(debug, ~\"Got EACCES error\");\n-            result::err(access_denied)\n+            result::Err(access_denied)\n           }\n           ~\"EADDRINUSE\" => {\n             log(debug, ~\"Got EADDRINUSE error\");\n-            result::err(address_in_use)\n+            result::Err(address_in_use)\n           }\n           _ => {\n             log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n                             err_data.err_name, err_data.err_msg));\n-            result::err(\n+            result::Err(\n                 generic_listen_err(err_data.err_name, err_data.err_msg))\n           }\n         }\n@@ -692,10 +692,10 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         stream_closed_po.recv();\n         match kill_result {\n           // some failure post bind/listen\n-          Some(err_data) => result::err(generic_listen_err(err_data.err_name,\n+          Some(err_data) => result::Err(generic_listen_err(err_data.err_name,\n                                                            err_data.err_msg)),\n           // clean exit\n-          None => result::ok(())\n+          None => result::Ok(())\n         }\n       }\n     }\n@@ -722,29 +722,29 @@ fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n impl tcp_socket {\n-    fn read_start() -> result::result<comm::Port<\n-        result::result<~[u8], tcp_err_data>>, tcp_err_data> {\n+    fn read_start() -> result::Result<comm::Port<\n+        result::Result<~[u8], tcp_err_data>>, tcp_err_data> {\n         read_start(self)\n     }\n     fn read_stop(-read_port:\n-                 comm::Port<result::result<~[u8], tcp_err_data>>) ->\n-        result::result<(), tcp_err_data> {\n+                 comm::Port<result::Result<~[u8], tcp_err_data>>) ->\n+        result::Result<(), tcp_err_data> {\n         read_stop(self, read_port)\n     }\n     fn read(timeout_msecs: uint) ->\n-        result::result<~[u8], tcp_err_data> {\n+        result::Result<~[u8], tcp_err_data> {\n         read(self, timeout_msecs)\n     }\n     fn read_future(timeout_msecs: uint) ->\n-        future::Future<result::result<~[u8], tcp_err_data>> {\n+        future::Future<result::Result<~[u8], tcp_err_data>> {\n         read_future(self, timeout_msecs)\n     }\n     fn write(raw_write_data: ~[u8])\n-        -> result::result<(), tcp_err_data> {\n+        -> result::Result<(), tcp_err_data> {\n         write(self, raw_write_data)\n     }\n     fn write_future(raw_write_data: ~[u8])\n-        -> future::Future<result::result<(), tcp_err_data>> {\n+        -> future::Future<result::Result<(), tcp_err_data>> {\n         write_future(self, raw_write_data)\n     }\n }\n@@ -856,13 +856,13 @@ fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n \n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n-    -> result::result<~[u8],tcp_err_data> unsafe {\n+    -> result::Result<~[u8],tcp_err_data> unsafe {\n     log(debug, ~\"starting tcp::read\");\n     let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n     if result::is_err(rs_result) {\n         let err_data = result::get_err(rs_result);\n-        result::err(err_data)\n+        result::Err(err_data)\n     }\n     else {\n         log(debug, ~\"tcp::read before recv_timeout\");\n@@ -881,7 +881,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n                 err_msg: ~\"req timed out\"\n             };\n             read_stop_common_impl(socket_data);\n-            result::err(err_data)\n+            result::Err(err_data)\n           }\n           Some(data_result) => {\n             log(debug, ~\"tcp::read got data\");\n@@ -894,7 +894,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n \n // shared impl for read_stop\n fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n-    result::result<(), tcp_err_data> unsafe {\n+    result::Result<(), tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = core::comm::port::<Option<tcp_err_data>>();\n     let stop_ch = core::comm::chan(stop_po);\n@@ -913,15 +913,15 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n         }\n     };\n     match core::comm::recv(stop_po) {\n-      Some(err_data) => result::err(err_data.to_tcp_err()),\n-      None => result::ok(())\n+      Some(err_data) => result::Err(err_data.to_tcp_err()),\n+      None => result::Ok(())\n     }\n }\n \n // shared impl for read_start\n fn read_start_common_impl(socket_data: *tcp_socket_data)\n-    -> result::result<comm::Port<\n-        result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+    -> result::Result<comm::Port<\n+        result::Result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = core::comm::port::<Option<uv::ll::uv_err_data>>();\n     let start_ch = core::comm::chan(start_po);\n@@ -943,8 +943,8 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n         }\n     };\n     match core::comm::recv(start_po) {\n-      Some(err_data) => result::err(err_data.to_tcp_err()),\n-      None => result::ok((*socket_data).reader_po)\n+      Some(err_data) => result::Err(err_data.to_tcp_err()),\n+      None => result::Ok((*socket_data).reader_po)\n     }\n }\n \n@@ -953,7 +953,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n // shared implementation used by write and write_future\n fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n                      raw_write_data: ~[u8])\n-    -> result::result<(), tcp_err_data> unsafe {\n+    -> result::Result<(), tcp_err_data> unsafe {\n     let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n     let stream_handle_ptr =\n         (*socket_data_ptr).stream_handle_ptr;\n@@ -989,8 +989,8 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     // ownership of everything to the I/O task and let it deal with the\n     // aftermath, so we don't have to sit here blocking.\n     match core::comm::recv(result_po) {\n-      tcp_write_success => result::ok(()),\n-      tcp_write_error(err_data) => result::err(err_data.to_tcp_err())\n+      tcp_write_success => result::Ok(()),\n+      tcp_write_error(err_data) => result::Err(err_data.to_tcp_err())\n     }\n }\n \n@@ -1083,7 +1083,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         log(debug, fmt!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n                         err_data.err_name, err_data.err_msg));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n-        core::comm::send(reader_ch, result::err(err_data));\n+        core::comm::send(reader_ch, result::Err(err_data));\n       }\n       // do nothing .. unneeded buf\n       0 => (),\n@@ -1094,7 +1094,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let new_bytes = vec::unsafe::from_buf(buf_base, nread as uint);\n-        core::comm::send(reader_ch, result::ok(new_bytes));\n+        core::comm::send(reader_ch, result::Ok(new_bytes));\n       }\n     }\n     uv::ll::free_base_of_buf(buf);\n@@ -1197,8 +1197,8 @@ enum conn_attempt {\n }\n \n type tcp_socket_data = {\n-    reader_po: comm::Port<result::result<~[u8], tcp_err_data>>,\n-    reader_ch: comm::Chan<result::result<~[u8], tcp_err_data>>,\n+    reader_po: comm::Port<result::Result<~[u8], tcp_err_data>>,\n+    reader_ch: comm::Chan<result::Result<~[u8], tcp_err_data>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -1515,7 +1515,7 @@ mod test {\n                             ~\"connection!\");\n                         let received_req_bytes = read(sock, 0u);\n                         match received_req_bytes {\n-                          result::ok(data) => {\n+                          result::Ok(data) => {\n                             log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n                             log(debug, fmt!(\"SERVER: REQ data len: %?\",\n                                             vec::len(data)));\n@@ -1526,7 +1526,7 @@ mod test {\n                             log(debug, ~\"SERVER: after write.. die\");\n                             core::comm::send(kill_ch, None);\n                           }\n-                          result::err(err_data) => {\n+                          result::Err(err_data) => {\n                             log(debug, fmt!(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg));\n                             core::comm::send(kill_ch, Some(err_data));\n@@ -1585,7 +1585,7 @@ mod test {\n \n     fn run_tcp_test_client(server_ip: ~str, server_port: uint, resp: ~str,\n                           client_ch: comm::Chan<~str>,\n-                          iotask: iotask) -> result::result<~str,\n+                          iotask: iotask) -> result::Result<~str,\n                                                     tcp_connect_err_data> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n@@ -1594,7 +1594,7 @@ mod test {\n         if result::is_err(connect_result) {\n             log(debug, ~\"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n-            err(err_data)\n+            Err(err_data)\n         }\n         else {\n             let sock = result::unwrap(connect_result);\n@@ -1603,14 +1603,14 @@ mod test {\n             let read_result = sock.read(0u);\n             if read_result.is_err() {\n                 log(debug, ~\"CLIENT: failure to read\");\n-                ok(~\"\")\n+                Ok(~\"\")\n             }\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n                 let ret_val = client_ch.recv();\n                 log(debug, fmt!(\"CLIENT: after client_ch recv ret: '%s'\",\n                    ret_val));\n-                ok(ret_val)\n+                Ok(ret_val)\n             }\n         }\n     }"}, {"sha": "8e8a7419902496a3bd7242cd9067d84a8b434679", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -330,38 +330,38 @@ fn query_to_str(query: query) -> ~str {\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n+fn get_scheme(rawurl: ~str) -> result::Result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' to 'Z' | 'a' to 'z' => again,\n           '0' to '9' | '+' | '-' | '.' => {\n             if i == 0 {\n-                return result::err(@~\"url: Scheme must begin with a letter.\");\n+                return result::Err(@~\"url: Scheme must begin with a letter.\");\n             }\n             again;\n           }\n           ':' => {\n             if i == 0 {\n-                return result::err(@~\"url: Scheme cannot be empty.\");\n+                return result::Err(@~\"url: Scheme cannot be empty.\");\n             } else {\n-                return result::ok((rawurl.slice(0,i),\n+                return result::Ok((rawurl.slice(0,i),\n                                 rawurl.slice(i+1,str::len(rawurl))));\n             }\n           }\n           _ => {\n-            return result::err(@~\"url: Invalid character in scheme.\");\n+            return result::Err(@~\"url: Invalid character in scheme.\");\n           }\n         }\n     };\n-    return result::err(@~\"url: Scheme must be terminated with a colon.\");\n+    return result::Err(@~\"url: Scheme must be terminated with a colon.\");\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: ~str) ->\n-    result::result<(Option<userinfo>, ~str, Option<~str>, ~str), @~str> {\n+    result::Result<(Option<userinfo>, ~str, Option<~str>, ~str), @~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n-        return result::ok((option::None, ~\"\", option::None, copy rawurl));\n+        return result::Ok((option::None, ~\"\", option::None, copy rawurl));\n     }\n \n     enum state {\n@@ -407,7 +407,7 @@ fn get_authority(rawurl: ~str) ->\n             // separators, don't change anything\n           }\n           _ => {\n-            return result::err(@~\"Illegal character in authority\");\n+            return result::Err(@~\"Illegal character in authority\");\n           }\n         }\n \n@@ -423,7 +423,7 @@ fn get_authority(rawurl: ~str) ->\n               pass_host_port => {\n                 // multiple colons means ipv6 address.\n                 if in == unreserved {\n-                    return result::err(\n+                    return result::Err(\n                         @~\"Illegal characters in IPv6 address.\");\n                 }\n                 st = ip6_host;\n@@ -432,13 +432,13 @@ fn get_authority(rawurl: ~str) ->\n                 pos = i;\n                 // can't be sure whether this is an ipv6 address or a port\n                 if in == unreserved {\n-                    return result::err(@~\"Illegal characters in authority.\");\n+                    return result::Err(@~\"Illegal characters in authority.\");\n                 }\n                 st = ip6_port;\n               }\n               ip6_port => {\n                 if in == unreserved {\n-                    return result::err(@~\"Illegal characters in authority.\");\n+                    return result::Err(@~\"Illegal characters in authority.\");\n                 }\n                 st = ip6_host;\n               }\n@@ -450,7 +450,7 @@ fn get_authority(rawurl: ~str) ->\n                 }\n               }\n               _ => {\n-                return result::err(@~\"Invalid ':' in authority.\");\n+                return result::Err(@~\"Invalid ':' in authority.\");\n               }\n             }\n             in = digit; // reset input class\n@@ -474,7 +474,7 @@ fn get_authority(rawurl: ~str) ->\n                 st = in_host;\n               }\n               _ => {\n-                return result::err(@~\"Invalid '@' in authority.\");\n+                return result::Err(@~\"Invalid '@' in authority.\");\n               }\n             }\n             begin = i+1;\n@@ -507,7 +507,7 @@ fn get_authority(rawurl: ~str) ->\n       }\n       pass_host_port | ip6_port => {\n         if in != digit {\n-            return result::err(@~\"Non-digit characters in port.\");\n+            return result::Err(@~\"Non-digit characters in port.\");\n         }\n         host = str::slice(rawurl, begin, pos);\n         port = option::Some(str::slice(rawurl, pos+1, end));\n@@ -517,21 +517,21 @@ fn get_authority(rawurl: ~str) ->\n       }\n       in_port => {\n         if in != digit {\n-            return result::err(@~\"Non-digit characters in port.\");\n+            return result::Err(@~\"Non-digit characters in port.\");\n         }\n         port = option::Some(str::slice(rawurl, pos+1, end));\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n     else { str::slice(rawurl, end, len) };\n-    return result::ok((userinfo, host, port, rest));\n+    return result::Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: ~str, authority : bool) ->\n-    result::result<(~str, ~str), @~str> {\n+    result::Result<(~str, ~str), @~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n     for str::each_chari(rawurl) |i,c| {\n@@ -545,39 +545,39 @@ fn get_path(rawurl: ~str, authority : bool) ->\n             end = i;\n             break;\n           }\n-          _ => return result::err(@~\"Invalid character in path.\")\n+          _ => return result::Err(@~\"Invalid character in path.\")\n         }\n     }\n \n     if authority {\n         if end != 0 && !str::starts_with(rawurl, ~\"/\") {\n-            return result::err(@~\"Non-empty path must begin with\\\n+            return result::Err(@~\"Non-empty path must begin with\\\n                                '/' in presence of authority.\");\n         }\n     }\n \n-    return result::ok((decode_component(str::slice(rawurl, 0, end)),\n+    return result::Ok((decode_component(str::slice(rawurl, 0, end)),\n                     str::slice(rawurl, end, len)));\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: ~str) ->\n-    result::result<(query, Option<~str>), @~str> {\n+    result::Result<(query, Option<~str>), @~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n             let f = decode_component(str::slice(rawurl,\n                                                 1,\n                                                 str::len(rawurl)));\n-            return result::ok((~[], option::Some(f)));\n+            return result::Ok((~[], option::Some(f)));\n         } else {\n-            return result::ok((~[], option::None));\n+            return result::Ok((~[], option::None));\n         }\n     }\n     let (q, r) = split_char_first(str::slice(rawurl, 1,\n                                              str::len(rawurl)), '#');\n     let f = if str::len(r) != 0 {\n         option::Some(decode_component(r)) } else { option::None };\n-    return result::ok((query_from_str(q), f));\n+    return result::Ok((query_from_str(q), f));\n }\n \n /**\n@@ -593,37 +593,37 @@ fn get_query_fragment(rawurl: ~str) ->\n  *\n  */\n \n-fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n+fn from_str(rawurl: ~str) -> result::Result<url, ~str> {\n     // scheme\n     let mut schm = get_scheme(rawurl);\n     if result::is_err(schm) {\n-        return result::err(copy *result::get_err(schm));\n+        return result::Err(copy *result::get_err(schm));\n     }\n     let (scheme, rest) = result::unwrap(schm);\n \n     // authority\n     let mut auth = get_authority(rest);\n     if result::is_err(auth) {\n-        return result::err(copy *result::get_err(auth));\n+        return result::Err(copy *result::get_err(auth));\n     }\n     let (userinfo, host, port, rest) = result::unwrap(auth);\n \n     // path\n     let has_authority = if host == ~\"\" { false } else { true };\n     let mut pth = get_path(rest, has_authority);\n     if result::is_err(pth) {\n-        return result::err(copy *result::get_err(pth));\n+        return result::Err(copy *result::get_err(pth));\n     }\n     let (path, rest) = result::unwrap(pth);\n \n     // query and fragment\n     let mut qry = get_query_fragment(rest);\n     if result::is_err(qry) {\n-        return result::err(copy *result::get_err(qry));\n+        return result::Err(copy *result::get_err(qry));\n     }\n     let (query, fragment) = result::unwrap(qry);\n \n-    return result::ok(url(scheme, userinfo, host,\n+    return result::Ok(url(scheme, userinfo, host,\n                        port, path, query, fragment));\n }\n "}, {"sha": "a1416177a6a8c9188d07b2d5266529cc0cc2e874", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -855,7 +855,7 @@ mod tests {\n         let m = ~mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try {\n             do m2.lock {\n                 fail;\n             }\n@@ -871,7 +871,7 @@ mod tests {\n         let m = ~mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try {\n             let (c,p) = pipes::stream();\n             do task::spawn { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n@@ -896,7 +896,7 @@ mod tests {\n         let m2 = ~m.clone();\n         let (c,p) = pipes::stream();\n \n-        let result: result::result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (c,p) = pipes::stream();\n@@ -1196,7 +1196,7 @@ mod tests {\n         let x = ~rwlock();\n         let x2 = ~x.clone();\n \n-        let result: result::result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try {\n             do lock_rwlock_in_mode(x2, mode1) {\n                 fail;\n             }"}, {"sha": "46ad1a95dc3f7f3096959b16c1b1b40a809fb393", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -6,7 +6,7 @@\n // while providing a base that other test frameworks may build off of.\n \n import either::Either;\n-import result::{ok, err};\n+import result::{Ok, Err};\n import io::WriterUtil;\n import libc::size_t;\n import task::TaskBuilder;\n@@ -71,8 +71,8 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n     let matches =\n         match getopts::getopts(args_, opts) {\n-          ok(m) => m,\n-          err(f) => return either::Right(getopts::fail_str(f))\n+          Ok(m) => m,\n+          Err(f) => return either::Right(getopts::fail_str(f))\n         };\n \n     let filter =\n@@ -143,8 +143,8 @@ fn run_tests_console(opts: test_opts,\n     let log_out = match opts.logfile {\n         Some(path) => match io::file_writer(&Path(path),\n                                             ~[io::Create, io::Truncate]) {\n-          result::ok(w) => Some(w),\n-          result::err(s) => {\n+          result::Ok(w) => Some(w),\n+          result::Err(s) => {\n               fail(fmt!(\"can't open output file: %s\", s))\n           }\n         },"}, {"sha": "174f92a3486f5798da4f2ba45430b9976443a231", "filename": "src/libstd/time.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -3,7 +3,7 @@\n \n import libc::{c_char, c_int, c_long, size_t, time_t};\n import io::Reader;\n-import result::{result, ok, err};\n+import result::{Result, Ok, Err};\n \n export\n     timespec,\n@@ -131,7 +131,7 @@ fn now() -> tm {\n }\n \n /// Parses the time from the string according to the format string.\n-fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n+fn strptime(s: &str, format: &str) -> Result<tm, ~str> {\n     type tm_mut = {\n        mut tm_sec: i32,\n        mut tm_min: i32,\n@@ -197,20 +197,20 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n         Some((value, pos))\n     }\n \n-    fn parse_char(s: &str, pos: uint, c: char) -> result<uint, ~str> {\n+    fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ~str> {\n         let {ch, next} = str::char_range_at(s, pos);\n \n         if c == ch {\n-            ok(next)\n+            Ok(next)\n         } else {\n-            err(fmt!(\"Expected %?, found %?\",\n+            Err(fmt!(\"Expected %?, found %?\",\n                 str::from_char(c),\n                 str::from_char(ch)))\n         }\n     }\n \n     fn parse_type(s: &str, pos: uint, ch: char, tm: &tm_mut)\n-      -> result<uint, ~str> {\n+      -> Result<uint, ~str> {\n         match ch {\n           'A' => match match_strs(s, pos, ~[\n               (~\"Sunday\", 0_i32),\n@@ -221,8 +221,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"Friday\", 5_i32),\n               (~\"Saturday\", 6_i32)\n           ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-            None => err(~\"Invalid day\")\n+            Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n+            None => Err(~\"Invalid day\")\n           },\n           'a' => match match_strs(s, pos, ~[\n               (~\"Sun\", 0_i32),\n@@ -233,8 +233,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"Fri\", 5_i32),\n               (~\"Sat\", 6_i32)\n           ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-            None => err(~\"Invalid day\")\n+            Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n+            None => Err(~\"Invalid day\")\n           },\n           'B' => match match_strs(s, pos, ~[\n               (~\"January\", 0_i32),\n@@ -250,8 +250,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"November\", 10_i32),\n               (~\"December\", 11_i32)\n           ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-            None => err(~\"Invalid month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n+            None => Err(~\"Invalid month\")\n           },\n           'b' | 'h' => match match_strs(s, pos, ~[\n               (~\"Jan\", 0_i32),\n@@ -267,16 +267,16 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               (~\"Nov\", 10_i32),\n               (~\"Dec\", 11_i32)\n           ]) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-            None => err(~\"Invalid month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n+            None => Err(~\"Invalid month\")\n           },\n           'C' => match match_digits(s, pos, 2u, false) {\n             Some(item) => {\n                 let (v, pos) = item;\n                   tm.tm_year += (v * 100_i32) - 1900_i32;\n-                  ok(pos)\n+                  Ok(pos)\n               }\n-            None => err(~\"Invalid year\")\n+            None => Err(~\"Invalid year\")\n           },\n           'c' => {\n             parse_type(s, pos, 'a', tm)\n@@ -297,12 +297,12 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n                 .chain(|pos| parse_type(s, pos, 'y', tm))\n           }\n           'd' => match match_digits(s, pos, 2u, false) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-            None => err(~\"Invalid day of the month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n+            None => Err(~\"Invalid day of the month\")\n           },\n           'e' => match match_digits(s, pos, 2u, true) {\n-            Some(item) => { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-            None => err(~\"Invalid day of the month\")\n+            Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n+            None => Err(~\"Invalid day of the month\")\n           },\n           'F' => {\n             parse_type(s, pos, 'Y', tm)\n@@ -314,8 +314,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n           'H' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              Some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              None => err(~\"Invalid hour\")\n+              Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n+              None => Err(~\"Invalid hour\")\n             }\n           }\n           'I' => {\n@@ -324,9 +324,9 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n-                  ok(pos)\n+                  Ok(pos)\n               }\n-              None => err(~\"Invalid hour\")\n+              None => Err(~\"Invalid hour\")\n             }\n           }\n           'j' => {\n@@ -335,16 +335,16 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_yday = v - 1_i32;\n-                ok(pos)\n+                Ok(pos)\n               }\n-              None => err(~\"Invalid year\")\n+              None => Err(~\"Invalid year\")\n             }\n           }\n           'k' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, true) {\n-              Some(item) => { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              None => err(~\"Invalid hour\")\n+              Some(item) => { let (v, pos) = item; tm.tm_hour = v; Ok(pos) }\n+              None => Err(~\"Invalid hour\")\n             }\n           }\n           'l' => {\n@@ -353,16 +353,16 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                   let (v, pos) = item;\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n-                  ok(pos)\n+                  Ok(pos)\n               }\n-              None => err(~\"Invalid hour\")\n+              None => Err(~\"Invalid hour\")\n             }\n           }\n           'M' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 2u, false) {\n-              Some(item) => { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n-              None => err(~\"Invalid minute\")\n+              Some(item) => { let (v, pos) = item; tm.tm_min = v; Ok(pos) }\n+              None => Err(~\"Invalid minute\")\n             }\n           }\n           'm' => {\n@@ -371,23 +371,23 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_mon = v - 1_i32;\n-                ok(pos)\n+                Ok(pos)\n               }\n-              None => err(~\"Invalid month\")\n+              None => Err(~\"Invalid month\")\n             }\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n                                   ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n \n-            Some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-            None => err(~\"Invalid hour\")\n+            Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n+            None => Err(~\"Invalid hour\")\n           },\n           'p' => match match_strs(s, pos,\n                                   ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n \n-            Some(item) => { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-            None => err(~\"Invalid hour\")\n+            Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n+            None => Err(~\"Invalid hour\")\n           },\n           'R' => {\n             parse_type(s, pos, 'H', tm)\n@@ -409,9 +409,9 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_sec = v;\n-                ok(pos)\n+                Ok(pos)\n               }\n-              None => err(~\"Invalid second\")\n+              None => Err(~\"Invalid second\")\n             }\n           }\n           //'s' {}\n@@ -429,9 +429,9 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_wday = v;\n-                ok(pos)\n+                Ok(pos)\n               }\n-              None => err(~\"Invalid weekday\")\n+              None => Err(~\"Invalid weekday\")\n             }\n           }\n           'v' => {\n@@ -445,8 +445,8 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n           'w' => {\n             // FIXME (#2350): range check.\n             match match_digits(s, pos, 1u, false) {\n-              Some(item) => { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              None => err(~\"Invalid weekday\")\n+              Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n+              None => Err(~\"Invalid weekday\")\n             }\n           }\n           //'X' {}\n@@ -457,9 +457,9 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n-                ok(pos)\n+                Ok(pos)\n               }\n-              None => err(~\"Invalid weekday\")\n+              None => Err(~\"Invalid weekday\")\n             }\n           }\n           'y' => {\n@@ -468,16 +468,16 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n               Some(item) => {\n                 let (v, pos) = item;\n                 tm.tm_year = v - 1900_i32;\n-                ok(pos)\n+                Ok(pos)\n               }\n-              None => err(~\"Invalid weekday\")\n+              None => Err(~\"Invalid weekday\")\n             }\n           }\n           'Z' => {\n             if match_str(s, pos, ~\"UTC\") || match_str(s, pos, ~\"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n                 tm.tm_zone = ~\"UTC\";\n-                ok(pos + 3u)\n+                Ok(pos + 3u)\n             } else {\n                 // It's odd, but to maintain compatibility with c's\n                 // strptime we ignore the timezone.\n@@ -489,7 +489,7 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n                     if ch == ' ' { break; }\n                 }\n \n-                ok(pos)\n+                Ok(pos)\n             }\n           }\n           'z' => {\n@@ -504,17 +504,17 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n                         tm.tm_zone = ~\"UTC\";\n                     }\n \n-                    ok(pos)\n+                    Ok(pos)\n                   }\n-                  None => err(~\"Invalid zone offset\")\n+                  None => Err(~\"Invalid zone offset\")\n                 }\n             } else {\n-                err(~\"Invalid zone offset\")\n+                Err(~\"Invalid zone offset\")\n             }\n           }\n           '%' => parse_char(s, pos, '%'),\n           ch => {\n-            err(fmt!(\"unknown formatting type: %?\", str::from_char(ch)))\n+            Err(fmt!(\"unknown formatting type: %?\", str::from_char(ch)))\n           }\n         }\n     }\n@@ -536,15 +536,15 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n         };\n         let mut pos = 0u;\n         let len = str::len(s);\n-        let mut result = err(~\"Invalid time\");\n+        let mut result = Err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             match rdr.read_char() {\n               '%' => match parse_type(s, pos, rdr.read_char(), &tm) {\n-                ok(next) => pos = next,\n-                  err(e) => { result = err(e); break; }\n+                Ok(next) => pos = next,\n+                  Err(e) => { result = Err(e); break; }\n               },\n               c => {\n                 if c != ch { break }\n@@ -554,7 +554,7 @@ fn strptime(s: &str, format: &str) -> result<tm, ~str> {\n         }\n \n         if pos == len && rdr.eof() {\n-            ok(tm_({\n+            Ok(tm_({\n                 tm_sec: tm.tm_sec,\n                 tm_min: tm.tm_min,\n                 tm_hour: tm.tm_hour,\n@@ -947,7 +947,7 @@ mod tests {\n         tzset();\n \n         match strptime(~\"\", ~\"\") {\n-          ok(tm) => {\n+          Ok(tm) => {\n             assert tm.tm_sec == 0_i32;\n             assert tm.tm_min == 0_i32;\n             assert tm.tm_hour == 0_i32;\n@@ -960,17 +960,17 @@ mod tests {\n             assert tm.tm_zone == ~\"\";\n             assert tm.tm_nsec == 0_i32;\n           }\n-          err(_) => ()\n+          Err(_) => ()\n         }\n \n         let format = ~\"%a %b %e %T %Y\";\n-        assert strptime(~\"\", format) == err(~\"Invalid time\");\n+        assert strptime(~\"\", format) == Err(~\"Invalid time\");\n         assert strptime(~\"Fri Feb 13 15:31:30\", format)\n-            == err(~\"Invalid time\");\n+            == Err(~\"Invalid time\");\n \n         match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n-          err(e) => fail e,\n-          ok(tm) => {\n+          Err(e) => fail e,\n+          Ok(tm) => {\n             assert tm.tm_sec == 30_i32;\n             assert tm.tm_min == 31_i32;\n             assert tm.tm_hour == 15_i32;\n@@ -988,8 +988,8 @@ mod tests {\n \n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n-              ok(tm) => tm.strftime(format) == str::from_slice(s),\n-              err(e) => fail e\n+              Ok(tm) => tm.strftime(format) == str::from_slice(s),\n+              Err(e) => fail e\n             }\n         }\n "}, {"sha": "2af871ba1235acab270706f9f355fa43fb0021f0", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -72,8 +72,8 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n     match res {\n-      result::ok(_) => { /* Continue. */ }\n-      result::err(e) => {\n+      result::Ok(_) => { /* Continue. */ }\n+      result::Err(e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal(e);\n       }\n     }\n@@ -88,13 +88,13 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     let file = expr_to_str(cx, args[0], ~\"#include_bin requires a string\");\n \n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n-      result::ok(src) => {\n+      result::Ok(src) => {\n         let u8_exprs = vec::map(src, |char: u8| {\n             mk_u8(cx, sp, char)\n         });\n         return mk_base_vec_e(cx, sp, u8_exprs);\n       }\n-      result::err(e) => {\n+      result::Err(e) => {\n         cx.parse_sess().span_diagnostic.handler().fatal(e)\n       }\n     }"}, {"sha": "82a3c4ce6c50db8624856f1a8b6796153791901d", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -187,8 +187,8 @@ fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n    (parser, string_reader) {\n     let res = io::read_whole_file_str(path);\n     match res {\n-      result::ok(_) => { /* Continue. */ }\n-      result::err(e) => sess.span_diagnostic.handler().fatal(e)\n+      result::Ok(_) => { /* Continue. */ }\n+      result::Err(e) => sess.span_diagnostic.handler().fatal(e)\n     }\n     let src = @result::unwrap(res);\n     let filemap = codemap::new_filemap(path.to_str(), src,"}, {"sha": "39f8bb59c1fdb202583f82f45517022d5045cd5e", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -54,8 +54,8 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n         // Crude, but there's no lib function for this and I'm not\n         // up to writing it just now\n         match io::file_reader(path) {\n-          result::ok(_) => true,\n-          result::err(_) => false\n+          result::Ok(_) => true,\n+          result::Err(_) => false\n         }\n     }\n "}, {"sha": "f73d4163e9c1632ead18c1184c84046f4590177a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -1,6 +1,6 @@\n import print::pprust::expr_to_str;\n \n-import result::result;\n+import result::Result;\n import either::{Either, Left, Right};\n import std::map::{hashmap, str_hash};\n import token::{can_begin_expr, is_ident, is_ident_or_path, is_plain_ident,"}, {"sha": "8023194f3d99b49ea41f3975cf5a461084702b47", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -8,7 +8,7 @@ import middle::{trans, freevars, kind, ty, typeck, lint};\n import syntax::print::{pp, pprust};\n import util::ppaux;\n import back::link;\n-import result::{ok, err};\n+import result::{Ok, Err};\n import std::getopts;\n import io::WriterUtil;\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n@@ -715,8 +715,8 @@ mod test {\n     fn test_switch_implies_cfg_test() {\n         let matches =\n             match getopts::getopts(~[~\"--test\"], opts()) {\n-              ok(m) => m,\n-              err(f) => fail ~\"test_switch_implies_cfg_test: \" +\n+              Ok(m) => m,\n+              Err(f) => fail ~\"test_switch_implies_cfg_test: \" +\n                              getopts::fail_str(f)\n             };\n         let sessopts = build_session_options(matches, diagnostic::emit);\n@@ -731,8 +731,8 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             match getopts::getopts(~[~\"--test\", ~\"--cfg=test\"], opts()) {\n-              ok(m) => m,\n-              err(f) => {\n+              Ok(m) => m,\n+              Err(f) => {\n                 fail ~\"test_switch_implies_cfg_test_unless_cfg_test: \" +\n                     getopts::fail_str(f);\n               }"}, {"sha": "950c8ddb4638ae7e9a02d9a0b81001e740d941c0", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -9,7 +9,7 @@ use syntax(vers = \"0.3\");\n import core::*;\n \n // -*- rust -*-\n-import result::{ok, err};\n+import result::{Ok, Err};\n import std::getopts;\n import std::map::hashmap;\n import getopts::{opt_present};\n@@ -124,8 +124,8 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n \n     let matches =\n         match getopts::getopts(args, opts()) {\n-          ok(m) => m,\n-          err(f) => {\n+          Ok(m) => m,\n+          Err(f) => {\n             early_error(demitter, getopts::fail_str(f))\n           }\n         };\n@@ -242,8 +242,8 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n \n         f(demitter)\n     } {\n-        result::ok(_) => { /* fallthrough */ }\n-        result::err(_) => {\n+        result::Ok(_) => { /* fallthrough */ }\n+        result::Err(_) => {\n             // Task failed without emitting a fatal diagnostic\n             if comm::recv(p) == done {\n                 diagnostic::emit("}, {"sha": "c0639a7bb8a423e8508df80488e14ebd5ae4b99a", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -2,7 +2,7 @@\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n \n-import result::result;\n+import result::Result;\n export filesearch;\n export mk_filesearch;\n export pick;\n@@ -43,12 +43,12 @@ fn mk_filesearch(maybe_sysroot: Option<Path>,\n                       make_target_lib_path(&self.sysroot,\n                                            self.target_triple));\n             match get_cargo_lib_path_nearest() {\n-              result::ok(p) => vec::push(paths, p),\n-              result::err(_) => ()\n+              result::Ok(p) => vec::push(paths, p),\n+              result::Err(_) => ()\n             }\n             match get_cargo_lib_path() {\n-              result::ok(p) => vec::push(paths, p),\n-              result::err(_) => ()\n+              result::Ok(p) => vec::push(paths, p),\n+              result::Err(_) => ()\n             }\n             paths\n         }\n@@ -112,31 +112,31 @@ fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n     }\n }\n \n-fn get_cargo_sysroot() -> result<Path, ~str> {\n-    result::ok(get_default_sysroot().push_many([libdir(), ~\"cargo\"]))\n+fn get_cargo_sysroot() -> Result<Path, ~str> {\n+    result::Ok(get_default_sysroot().push_many([libdir(), ~\"cargo\"]))\n }\n \n-fn get_cargo_root() -> result<Path, ~str> {\n+fn get_cargo_root() -> Result<Path, ~str> {\n     match os::getenv(~\"CARGO_ROOT\") {\n-        Some(_p) => result::ok(Path(_p)),\n+        Some(_p) => result::Ok(Path(_p)),\n         None => match os::homedir() {\n-          Some(_q) => result::ok(_q.push(\".cargo\")),\n-          None => result::err(~\"no CARGO_ROOT or home directory\")\n+          Some(_q) => result::Ok(_q.push(\".cargo\")),\n+          None => result::Err(~\"no CARGO_ROOT or home directory\")\n         }\n     }\n }\n \n-fn get_cargo_root_nearest() -> result<Path, ~str> {\n+fn get_cargo_root_nearest() -> Result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n         let cwd = os::getcwd();\n         let cwd_cargo = cwd.push(\".cargo\");\n         let mut par_cargo = cwd.pop().push(\".cargo\");\n-        let mut rslt = result::ok(cwd_cargo);\n+        let mut rslt = result::Ok(cwd_cargo);\n \n         if !os::path_is_dir(&cwd_cargo) && cwd_cargo != p {\n             while par_cargo != p {\n                 if os::path_is_dir(&par_cargo) {\n-                    rslt = result::ok(par_cargo);\n+                    rslt = result::Ok(par_cargo);\n                     break;\n                 }\n                 if par_cargo.components.len() == 1 {\n@@ -150,15 +150,15 @@ fn get_cargo_root_nearest() -> result<Path, ~str> {\n     }\n }\n \n-fn get_cargo_lib_path() -> result<Path, ~str> {\n+fn get_cargo_lib_path() -> Result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n-        result::ok(p.push(libdir()))\n+        result::Ok(p.push(libdir()))\n     }\n }\n \n-fn get_cargo_lib_path_nearest() -> result<Path, ~str> {\n+fn get_cargo_lib_path_nearest() -> Result<Path, ~str> {\n     do result::chain(get_cargo_root_nearest()) |p| {\n-        result::ok(p.push(libdir()))\n+        result::Ok(p.push(libdir()))\n     }\n }\n "}, {"sha": "47c0c94b3337bb4a6b6a54111dc37eb92f1025a3", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -224,7 +224,7 @@ import util::ppaux::{ty_to_str, region_to_str, explain_region};\n import std::map::{int_hash, hashmap, set};\n import std::list;\n import std::list::{list, cons, nil};\n-import result::{result, ok, err};\n+import result::{Result, Ok, Err};\n import syntax::print::pprust;\n import util::common::indenter;\n import ty::to_str;\n@@ -327,7 +327,7 @@ enum bckerr_code {\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n // shorthand for something that fails with `bckerr` or succeeds with `T`\n-type bckres<T> = result<T, bckerr>;\n+type bckres<T> = Result<T, bckerr>;\n \n /// a complete record of a loan that was granted\n type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n@@ -404,8 +404,8 @@ impl borrowck_ctxt {\n \n     fn report_if_err(bres: bckres<()>) {\n         match bres {\n-          ok(()) => (),\n-          err(e) => self.report(e)\n+          Ok(()) => (),\n+          Err(e) => self.report(e)\n         }\n     }\n "}, {"sha": "08f01f41941e08e56c690db7c0f9ce206aa42886", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -276,9 +276,9 @@ impl gather_loan_ctxt {\n           // error will be reported.\n           Some(_) => {\n             match self.bccx.loan(cmt, scope_r, req_mutbl) {\n-              err(e) => { self.bccx.report(e); }\n-              ok(loans) if loans.len() == 0 => {}\n-              ok(loans) => {\n+              Err(e) => { self.bccx.report(e); }\n+              Ok(loans) if loans.len() == 0 => {}\n+              Ok(loans) => {\n                 match scope_r {\n                   ty::re_scope(scope_id) => {\n                     self.add_loans(scope_id, loans);\n@@ -318,19 +318,19 @@ impl gather_loan_ctxt {\n                     do self.bccx.preserve(cmt, scope_r,\n                                           self.item_ub,\n                                           self.root_ub).chain |pc2| {\n-                        ok(pc1.combine(pc2))\n+                        Ok(pc1.combine(pc2))\n                     }\n                 }\n             };\n \n             match result {\n-              ok(pc_ok) => {\n+              Ok(pc_ok) => {\n                 // we were able guarantee the validity of the ptr,\n                 // perhaps by rooting or because it is immutably\n                 // rooted.  good.\n                 self.bccx.stable_paths += 1;\n               }\n-              ok(pc_if_pure(e)) => {\n+              Ok(pc_if_pure(e)) => {\n                 // we are only able to guarantee the validity if\n                 // the scope is pure\n                 match scope_r {\n@@ -353,7 +353,7 @@ impl gather_loan_ctxt {\n                   }\n                 }\n               }\n-              err(e) => {\n+              Err(e) => {\n                 // we cannot guarantee the validity of this pointer\n                 self.bccx.report(e);\n               }\n@@ -376,7 +376,7 @@ impl gather_loan_ctxt {\n           (m_const, _) |\n           (m_imm, m_imm) |\n           (m_mutbl, m_mutbl) => {\n-            ok(pc_ok)\n+            Ok(pc_ok)\n           }\n \n           (_, m_const) |\n@@ -386,9 +386,9 @@ impl gather_loan_ctxt {\n                      code: err_mutbl(req_mutbl, cmt.mutbl)};\n             if req_mutbl == m_imm {\n                 // you can treat mutable things as imm if you are pure\n-                ok(pc_if_pure(e))\n+                Ok(pc_if_pure(e))\n             } else {\n-                err(e)\n+                Err(e)\n             }\n           }\n         }"}, {"sha": "0b0ad514be7a77fc47b8f628711871170f850c18", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -3,7 +3,7 @@\n // of the scope S, presuming that the returned set of loans `Ls` are honored.\n \n export public_methods;\n-import result::{result, ok, err};\n+import result::{Result, Ok, Err};\n \n impl borrowck_ctxt {\n     fn loan(cmt: cmt,\n@@ -13,8 +13,8 @@ impl borrowck_ctxt {\n                               scope_region: scope_region,\n                               loans: @dvec()});\n         match lc.loan(cmt, mutbl) {\n-          ok(()) => {ok(lc.loans)}\n-          err(e) => {err(e)}\n+          Ok(()) => {Ok(lc.loans)}\n+          Err(e) => {Err(e)}\n         }\n     }\n }\n@@ -47,11 +47,11 @@ impl loan_ctxt {\n             (*self.loans).push({lp: option::get(cmt.lp),\n                                 cmt: cmt,\n                                 mutbl: mutbl});\n-            ok(())\n+            Ok(())\n         } else {\n             // The loan being requested lives longer than the data\n             // being loaned out!\n-            err({cmt:cmt, code:err_out_of_scope(scope_ub,\n+            Err({cmt:cmt, code:err_out_of_scope(scope_ub,\n                                                 self.scope_region)})\n         }\n     }"}, {"sha": "8e28a26f8d5c49e92cab150e14b75ccce810dda1", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -68,7 +68,7 @@ priv impl &preserve_ctxt {\n             self.compare_scope(cmt, ty::re_scope(self.item_ub))\n           }\n           cat_special(sk_static_item) | cat_special(sk_method) => {\n-            ok(pc_ok)\n+            Ok(pc_ok)\n           }\n           cat_rvalue => {\n             // when we borrow an rvalue, we can keep it rooted but only\n@@ -147,7 +147,7 @@ priv impl &preserve_ctxt {\n           }\n           cat_deref(_, _, unsafe_ptr) => {\n             // Unsafe pointers are the user's problem\n-            ok(pc_ok)\n+            Ok(pc_ok)\n           }\n           cat_deref(base, derefs, gc_ptr) => {\n             // GC'd pointers of type @MT: if this pointer lives in\n@@ -160,14 +160,14 @@ priv impl &preserve_ctxt {\n                 let non_rooting_ctxt =\n                     preserve_ctxt({root_managed_data: false with **self});\n                 match (&non_rooting_ctxt).preserve(base) {\n-                  ok(pc_ok) => {\n-                    ok(pc_ok)\n+                  Ok(pc_ok) => {\n+                    Ok(pc_ok)\n                   }\n-                  ok(pc_if_pure(_)) => {\n+                  Ok(pc_if_pure(_)) => {\n                     debug!(\"must root @T, otherwise purity req'd\");\n                     self.attempt_root(cmt, base, derefs)\n                   }\n-                  err(e) => {\n+                  Err(e) => {\n                     debug!(\"must root @T, err: %s\",\n                            self.bccx.bckerr_code_to_str(e.code));\n                     self.attempt_root(cmt, base, derefs)\n@@ -251,25 +251,25 @@ priv impl &preserve_ctxt {\n         match self.preserve(cmt_base) {\n           // the base is preserved, but if we are not mutable then\n           // purity is required\n-          ok(pc_ok) => {\n+          Ok(pc_ok) => {\n             match cmt_base.mutbl {\n               m_mutbl | m_const => {\n-                ok(pc_if_pure({cmt:cmt, code:code}))\n+                Ok(pc_if_pure({cmt:cmt, code:code}))\n               }\n               m_imm => {\n-                ok(pc_ok)\n+                Ok(pc_ok)\n               }\n             }\n           }\n \n           // the base requires purity too, that's fine\n-          ok(pc_if_pure(e)) => {\n-            ok(pc_if_pure(e))\n+          Ok(pc_if_pure(e)) => {\n+            Ok(pc_if_pure(e))\n           }\n \n           // base is not stable, doesn't matter\n-          err(e) => {\n-            err(e)\n+          Err(e) => {\n+            Err(e)\n           }\n         }\n     }\n@@ -279,9 +279,9 @@ priv impl &preserve_ctxt {\n     fn compare_scope(cmt: cmt,\n                      scope_ub: ty::region) -> bckres<preserve_condition> {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n-            ok(pc_ok)\n+            Ok(pc_ok)\n         } else {\n-            err({cmt:cmt, code:err_out_of_scope(scope_ub,\n+            Err({cmt:cmt, code:err_out_of_scope(scope_ub,\n                                                 self.scope_region)})\n         }\n     }\n@@ -306,7 +306,7 @@ priv impl &preserve_ctxt {\n             // would be sort of pointless to avoid rooting the inner\n             // box by rooting an outer box, as it would just keep more\n             // memory live than necessary, so we set root_ub to none.\n-            return err({cmt:cmt, code:err_root_not_permitted});\n+            return Err({cmt:cmt, code:err_root_not_permitted});\n         }\n \n         let root_region = ty::re_scope(self.root_ub);\n@@ -322,18 +322,18 @@ priv impl &preserve_ctxt {\n                 #debug[\"Elected to root\"];\n                 let rk = {id: base.id, derefs: derefs};\n                 self.bccx.root_map.insert(rk, scope_id);\n-                return ok(pc_ok);\n+                return Ok(pc_ok);\n             } else {\n                 #debug[\"Unable to root\"];\n-                return err({cmt:cmt,\n+                return Err({cmt:cmt,\n                          code:err_out_of_root_scope(root_region,\n                                                     self.scope_region)});\n             }\n           }\n \n           // we won't be able to root long enough\n           _ => {\n-              return err({cmt:cmt,\n+              return Err({cmt:cmt,\n                        code:err_out_of_root_scope(root_region,\n                                                   self.scope_region)});\n           }"}, {"sha": "db7b8a356cabc3998a4caa5e118a05ea76615f22", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -2,7 +2,7 @@\n #[warn(deprecated_pattern)];\n \n import std::{map, smallintmap};\n-import result::result;\n+import result::Result;\n import std::map::hashmap;\n import driver::session;\n import session::session;\n@@ -2613,24 +2613,24 @@ fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n \n // Unifies `m1` and `m2`.  Returns unified value or failure code.\n fn unify_mode(cx: ctxt, modes: expected_found<ast::mode>)\n-    -> result<ast::mode, type_err> {\n+    -> Result<ast::mode, type_err> {\n \n     let m1 = modes.expected;\n     let m2 = modes.found;\n     match (canon_mode(cx, m1), canon_mode(cx, m2)) {\n       (m1, m2) if (m1 == m2) => {\n-        result::ok(m1)\n+        result::Ok(m1)\n       }\n       (ast::infer(_), ast::infer(id2)) => {\n         cx.inferred_modes.insert(id2, m1);\n-        result::ok(m1)\n+        result::Ok(m1)\n       }\n       (ast::infer(id), m) | (m, ast::infer(id)) => {\n         cx.inferred_modes.insert(id, m);\n-        result::ok(m1)\n+        result::Ok(m1)\n       }\n       (_, _) => {\n-        result::err(terr_mode_mismatch(modes))\n+        result::Err(terr_mode_mismatch(modes))\n       }\n     }\n }"}, {"sha": "51c152f3948dbc6fe25bc829634017dae545980a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -38,7 +38,7 @@ independently:\n \n */\n \n-import result::result;\n+import result::Result;\n import syntax::{ast, ast_util, ast_map};\n import ast::spanned;\n import ast::{required, provided};\n@@ -226,8 +226,8 @@ fn require_same_types(\n     }\n \n     match infer::mk_eqty(l_infcx, t1_is_expected, span, t1, t2) {\n-      result::ok(()) => true,\n-      result::err(ref terr) => {\n+      result::Ok(()) => true,\n+      result::Err(ref terr) => {\n         l_tcx.sess.span_err(span, msg() + ~\": \" +\n             ty::type_err_to_str(l_tcx, terr));\n         false"}, {"sha": "d4d31cebff324ecc5dcb46491ab1454b87b2b984", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -57,11 +57,11 @@ trait ast_conv {\n \n fn get_region_reporting_err(tcx: ty::ctxt,\n                             span: span,\n-                            res: result<ty::region, ~str>) -> ty::region {\n+                            res: Result<ty::region, ~str>) -> ty::region {\n \n     match res {\n-      result::ok(r) => r,\n-      result::err(e) => {\n+      result::Ok(r) => r,\n+      result::Err(e) => {\n         tcx.sess.span_err(span, e);\n         ty::re_static\n       }"}, {"sha": "bc9762a43e54d8ad71ee51c8c76f9b1268b3f4b1", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -553,17 +553,17 @@ impl @fn_ctxt: ast_conv {\n }\n \n impl @fn_ctxt: region_scope {\n-    fn anon_region(span: span) -> result<ty::region, ~str> {\n-        result::ok(self.infcx.next_region_var_nb(span))\n+    fn anon_region(span: span) -> Result<ty::region, ~str> {\n+        result::Ok(self.infcx.next_region_var_nb(span))\n     }\n-    fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             match self.in_scope_regions.find(ty::br_named(id)) {\n-              Some(r) => result::ok(r),\n+              Some(r) => result::Ok(r),\n               None if id == syntax::parse::token::special_idents::blk\n-                  => result::ok(self.block_region()),\n+                  => result::Ok(self.block_region()),\n               None => {\n-                result::err(fmt!(\"named region `%s` not in scope here\",\n+                result::Err(fmt!(\"named region `%s` not in scope here\",\n                                  self.ccx.tcx.sess.str_of(id)))\n               }\n             }\n@@ -656,35 +656,35 @@ impl @fn_ctxt {\n     }\n \n     fn mk_subty(a_is_expected: bool, span: span,\n-                sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+                sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n         infer::mk_subty(self.infcx, a_is_expected, span, sub, sup)\n     }\n \n-    fn can_mk_subty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+    fn can_mk_subty(sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx, sub, sup)\n     }\n \n     fn mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n-                   sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+                   sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n         let anmnt = &{expr_id: expr.id, span: expr.span,\n                       borrow_lb: borrow_lb};\n         infer::mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n     fn can_mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n-                       sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+                       sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n         let anmnt = &{expr_id: expr.id, span: expr.span,\n                       borrow_lb: borrow_lb};\n         infer::can_mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n     fn mk_eqty(a_is_expected: bool, span: span,\n-               sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+               sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx, a_is_expected, span, sub, sup)\n     }\n \n     fn mk_subr(a_is_expected: bool, span: span,\n-               sub: ty::region, sup: ty::region) -> result<(), ty::type_err> {\n+               sub: ty::region, sup: ty::region) -> Result<(), ty::type_err> {\n         infer::mk_subr(self.infcx, a_is_expected, span, sub, sup)\n     }\n \n@@ -1181,7 +1181,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match expected {\n           Some(t) => {\n             match resolve_type(fcx.infcx, t, force_tvar) {\n-              result::ok(t) => unpack(ty::get(t).struct),\n+              result::Ok(t) => unpack(ty::get(t).struct),\n               _ => None\n             }\n           }\n@@ -1551,8 +1551,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match expr_opt {\n           None => match fcx.mk_eqty(false, expr.span,\n                                     ret_ty, ty::mk_nil(tcx)) {\n-            result::ok(_) => { /* fall through */ }\n-            result::err(_) => {\n+            result::Ok(_) => { /* fall through */ }\n+            result::Err(_) => {\n                 tcx.sess.span_err(\n                     expr.span,\n                     ~\"`return;` in function returning non-nil\");\n@@ -1626,8 +1626,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           Some(ty::ty_fn(fty)) => {\n             match fcx.mk_subty(false, expr.span,\n                                fty.output, ty::mk_bool(tcx)) {\n-              result::ok(_) => (),\n-              result::err(_) => {\n+              result::Ok(_) => (),\n+              result::Err(_) => {\n                 tcx.sess.span_fatal(\n                     expr.span, fmt!(\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n@@ -2417,7 +2417,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     match infer::resolve_type(fcx.infcx, tp, force_tvar) {\n-      result::ok(t_s) if !ty::type_is_var(t_s) => return t_s,\n+      result::Ok(t_s) if !ty::type_is_var(t_s) => return t_s,\n       _ => {\n         fcx.ccx.tcx.sess.span_fatal\n             (sp, ~\"the type of this value must be known in this context\");"}, {"sha": "7dc1dc2606b557e0da91e1af7126e31ddc0b941a", "filename": "src/rustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -8,8 +8,8 @@ fn suptype(fcx: @fn_ctxt, sp: span,\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx, false, sp,\n                           actual, expected) {\n-      result::ok(()) => { /* ok */ }\n-      result::err(ref err) => {\n+      result::Ok(()) => { /* ok */ }\n+      result::Err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, actual, err);\n       }\n     }\n@@ -19,8 +19,8 @@ fn eqtype(fcx: @fn_ctxt, sp: span,\n           expected: ty::t, actual: ty::t) {\n \n     match infer::mk_eqty(fcx.infcx, false, sp, actual, expected) {\n-      result::ok(()) => { /* ok */ }\n-      result::err(ref err) => {\n+      result::Ok(()) => { /* ok */ }\n+      result::Err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, actual, err);\n       }\n     }\n@@ -31,8 +31,8 @@ fn assign(fcx: @fn_ctxt, sp: span, borrow_lb: ast::node_id,\n           expected: ty::t, expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, borrow_lb, expr_ty, expected) {\n-      result::ok(()) => { /* ok */ }\n-      result::err(ref err) => {\n+      result::Ok(()) => { /* ok */ }\n+      result::Err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);\n       }\n     }"}, {"sha": "0283758b7495b1d29e8a789d3e805e0e29a9f5f2", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -434,7 +434,7 @@ struct lookup {\n \n     fn check_type_match(impl_ty: ty::t,\n                         mode: method_lookup_mode)\n-        -> result<(), ty::type_err> {\n+        -> Result<(), ty::type_err> {\n         // Depending on our argument, we find potential matches by\n         // checking subtypability, type assignability, or reference\n         // subtypability. Collect the matches.\n@@ -492,8 +492,8 @@ struct lookup {\n             let matches = self.check_type_match(impl_ty, mode);\n             debug!(\"matches = %?\", matches);\n             match matches {\n-              result::err(_) => { /* keep looking */ }\n-              result::ok(_) => {\n+              result::Err(_) => { /* keep looking */ }\n+              result::Ok(_) => {\n                 if !self.candidate_impls.contains_key(im.did) {\n                     let fty = self.ty_from_did(m.did);\n                     self.candidates.push(\n@@ -650,8 +650,8 @@ struct lookup {\n                 // is not from an impl, this'll basically be a no-nop.\n                 match self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n                                            cand.self_ty, cand.rcvr_ty) {\n-                  result::ok(_) => (),\n-                  result::err(_) => {\n+                  result::Ok(_) => (),\n+                  result::Err(_) => {\n                     self.tcx().sess.span_bug(\n                         self.expr.span,\n                         fmt!(\"%s was assignable to %s but now is not?\","}, {"sha": "ee8c20592b48df2bf8323dc98263f63ed100f62b", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -187,8 +187,8 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n         // check_cast_for_escaping_regions() in kind.rs explaining how\n         // it goes about doing that.\n         match rcx.resolve_node_type(e.id) {\n-          result::err(_) => { return; /* typeck will fail anyhow */ }\n-          result::ok(target_ty) => {\n+          result::Err(_) => { return; /* typeck will fail anyhow */ }\n+          result::Ok(target_ty) => {\n             match ty::get(target_ty).struct {\n               ty::ty_trait(_, substs, _) => {\n                 let trait_region = match substs.self_r {\n@@ -213,8 +213,8 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n \n       ast::expr_fn(*) | ast::expr_fn_block(*) => {\n         match rcx.resolve_node_type(e.id) {\n-          result::err(_) => return,   // Typechecking will fail anyhow.\n-          result::ok(function_type) => {\n+          result::Err(_) => return,   // Typechecking will fail anyhow.\n+          result::Ok(function_type) => {\n             match ty::get(function_type).struct {\n               ty::ty_fn({\n                 proto: proto_vstore(vstore_slice(region)), _\n@@ -249,8 +249,8 @@ fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty = match rcx.resolve_node_type(id) {\n-      result::err(_) => return true,\n-      result::ok(ty) => ty\n+      result::Err(_) => return true,\n+      result::Ok(ty) => ty\n     };\n \n     // find the region where this expr evaluation is taking place\n@@ -279,8 +279,8 @@ fn constrain_free_variables(\n         let en_region = encl_region_of_def(rcx.fcx, def);\n         match rcx.fcx.mk_subr(true, freevar.span,\n                               region, en_region) {\n-          result::ok(()) => {}\n-          result::err(_) => {\n+          result::Ok(()) => {}\n+          result::Err(_) => {\n             tcx.sess.span_err(\n                 freevar.span,\n                 ~\"captured variable does not outlive the enclosing closure\");\n@@ -331,7 +331,7 @@ fn constrain_regions_in_type(\n         }\n \n         match rcx.fcx.mk_subr(true, span, encl_region, region) {\n-          result::err(_) => {\n+          result::Err(_) => {\n             tcx.sess.span_err(\n                 span,\n                 fmt!(\"reference is not valid outside of its lifetime\"));\n@@ -341,7 +341,7 @@ fn constrain_regions_in_type(\n                 region);\n             rcx.errors_reported += 1u;\n           }\n-          result::ok(()) => {\n+          result::Ok(()) => {\n           }\n         }\n     }"}, {"sha": "97bbe98f243958931d040a158f0a7827b8ae4a1f", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -194,8 +194,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             impl_self_ty(fcx, expr, im.did, false);\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n                         match fcx.mk_subty(false, expr.span, ty, for_ty) {\n-                          result::err(_) => again,\n-                          result::ok(()) => ()\n+                          result::Err(_) => again,\n+                          result::Ok(()) => ()\n                         }\n \n                         // check that desired trait type unifies\n@@ -260,15 +260,15 @@ fn fixup_ty(fcx: @fn_ctxt,\n {\n     let tcx = fcx.ccx.tcx;\n     match resolve_type(fcx.infcx, ty, resolve_and_force_all_but_regions) {\n-      result::ok(new_type) => Some(new_type),\n-      result::err(e) if !is_early => {\n+      result::Ok(new_type) => Some(new_type),\n+      result::Err(e) if !is_early => {\n         tcx.sess.span_fatal(\n             expr.span,\n             fmt!(\"cannot determine a type \\\n                   for this bounded type parameter: %s\",\n                  fixup_err_to_str(e)))\n       }\n-      result::err(_) => {\n+      result::Err(_) => {\n         None\n       }\n     }"}, {"sha": "6bbd757ac98f5405e07de23f451d1d5fa7399a71", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -11,8 +11,8 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n     Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx, typ, resolve_all | force_all) {\n-      result::ok(new_type) => return Some(new_type),\n-      result::err(e) => {\n+      result::Ok(new_type) => return Some(new_type),\n+      result::Err(e) => {\n         if !fcx.ccx.tcx.sess.has_errors() {\n             fcx.ccx.tcx.sess.span_err(\n                 sp,\n@@ -128,13 +128,13 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n     let var_ty = ty::mk_var(wbcx.fcx.tcx(), var_id);\n     match resolve_type(wbcx.fcx.infcx, var_ty, resolve_all | force_all) {\n-      result::ok(lty) => {\n+      result::Ok(lty) => {\n         debug!(\"Type for local %s (id %d) resolved to %s\",\n                pat_to_str(l.node.pat, wbcx.fcx.ccx.tcx.sess.intr()),l.node.id,\n                wbcx.fcx.infcx.ty_to_str(lty));\n         write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n       }\n-      result::err(e) => {\n+      result::Err(e) => {\n         wbcx.fcx.ccx.tcx.sess.span_err(\n             l.span,\n             fmt!(\"cannot determine a type \\"}, {"sha": "dfe6ce77bc147d2a6f4af30a5a358c8440db6db9", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -31,7 +31,7 @@ import syntax::visit::{visit_mod};\n import util::ppaux::ty_to_str;\n \n import dvec::{DVec, dvec};\n-import result::ok;\n+import result::Ok;\n import std::map::{hashmap, int_hash};\n import uint::range;\n import vec::{len, push};\n@@ -43,7 +43,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n     match resolve_type(inference_context,\n                      original_type,\n                      resolve_ivar) {\n-        ok(resulting_type) if !type_is_var(resulting_type) => {\n+        Ok(resulting_type) if !type_is_var(resulting_type) => {\n             resolved_type = resulting_type;\n         }\n         _ => {"}, {"sha": "774f5a1f4e04d1a75b7826c8caf3f4321d44b1fe", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -255,7 +255,7 @@ import middle::ty::{tv_vid, tvi_vid, region_vid, vid,\n import syntax::{ast, ast_util};\n import syntax::ast::{ret_style, purity};\n import util::ppaux::{ty_to_str, mt_to_str};\n-import result::{result, ok, err, map_vec, map_vec2, iter_vec2};\n+import result::{Result, Ok, Err, map_vec, map_vec2, iter_vec2};\n import ty::{mk_fn, type_is_bot};\n import check::regionmanip::{replace_bound_regions_in_fn_ty};\n import driver::session::session;\n@@ -309,7 +309,7 @@ type assignment = {\n type bound<T:copy> = Option<T>;\n type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n \n-type cres<T> = result<T,ty::type_err>;\n+type cres<T> = Result<T,ty::type_err>;\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n@@ -358,8 +358,8 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n     }\n }\n \n-type ures = result::result<(), ty::type_err>;\n-type fres<T> = result::result<T, fixup_err>;\n+type ures = result::Result<(), ty::type_err>;\n+type fres<T> = result::Result<T, fixup_err>;\n \n fn new_vals_and_bindings<V:copy, T:copy>() -> vals_and_bindings<V, T> {\n     vals_and_bindings {\n@@ -463,14 +463,14 @@ fn resolve_region(cx: infer_ctxt, r: ty::region, modes: uint)\n fn resolve_borrowings(cx: infer_ctxt) {\n     for cx.borrowings.each |item| {\n         match resolve_region(cx, item.scope, resolve_all|force_all) {\n-          ok(region) => {\n+          Ok(region) => {\n             debug!(\"borrowing for expr %d resolved to region %?, mutbl %?\",\n                    item.expr_id, region, item.mutbl);\n             cx.tcx.borrowings.insert(\n                 item.expr_id, {region: region, mutbl: item.mutbl});\n           }\n \n-          err(e) => {\n+          Err(e) => {\n             let str = fixup_err_to_str(e);\n             cx.tcx.sess.span_err(\n                 item.span,\n@@ -481,13 +481,13 @@ fn resolve_borrowings(cx: infer_ctxt) {\n }\n \n trait then {\n-    fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n-        -> result<T,ty::type_err>;\n+    fn then<T:copy>(f: fn() -> Result<T,ty::type_err>)\n+        -> Result<T,ty::type_err>;\n }\n \n impl ures: then {\n-    fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n-        -> result<T,ty::type_err> {\n+    fn then<T:copy>(f: fn() -> Result<T,ty::type_err>)\n+        -> Result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n }\n@@ -500,8 +500,8 @@ trait cres_helpers<T> {\n impl<T:copy> cres<T>: cres_helpers<T> {\n     fn to_ures() -> ures {\n         match self {\n-          ok(_v) => ok(()),\n-          err(e) => err(e)\n+          Ok(_v) => Ok(()),\n+          Err(e) => Err(e)\n         }\n     }\n \n@@ -510,14 +510,14 @@ impl<T:copy> cres<T>: cres_helpers<T> {\n             if s == t {\n                 self\n             } else {\n-                err(f())\n+                Err(f())\n             }\n         }\n     }\n }\n \n fn uok() -> ures {\n-    ok(())\n+    Ok(())\n }\n \n fn rollback_to<V:copy vid, T:copy>(\n@@ -570,7 +570,7 @@ impl infer_ctxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n+    fn commit<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n         assert !self.in_snapshot();\n \n         debug!(\"commit()\");\n@@ -588,21 +588,21 @@ impl infer_ctxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n+    fn try<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n             match r {\n-              ok(_) => (),\n-              err(_) => self.rollback_to(&snapshot)\n+              Ok(_) => (),\n+              Err(_) => self.rollback_to(&snapshot)\n             }\n             r\n         }\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n+    fn probe<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -674,8 +674,8 @@ impl infer_ctxt {\n \n     fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n-          result::ok(new_type) => new_type,\n-          result::err(_) => typ\n+          result::Ok(new_type) => new_type,\n+          result::Err(_) => typ\n         }\n     }\n }"}, {"sha": "6f8fa5647a9fd88d7ca2ea915b80f524042ff01f", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -113,8 +113,8 @@ fn eq_regions<C: combine>(self: &C, a: ty::region, b: ty::region) -> ures {\n             // found in the original error\n             match e {\n               ty::terr_regions_does_not_outlive(a1, b1) =>\n-                err(ty::terr_regions_not_same(a1, b1)),\n-              _ => err(e)\n+                Err(ty::terr_regions_not_same(a1, b1)),\n+              _ => Err(e)\n             }\n         }).to_ures()\n     }\n@@ -127,11 +127,11 @@ fn eq_opt_regions<C:combine>(\n \n     match (a, b) {\n       (None, None) => {\n-        ok(None)\n+        Ok(None)\n       }\n       (Some(a), Some(b)) => {\n         do eq_regions(self, a, b).then {\n-            ok(Some(a))\n+            Ok(Some(a))\n         }\n       }\n       (_, _) => {\n@@ -162,21 +162,21 @@ fn super_substs<C:combine>(\n         let polyty = ty::lookup_item_type(self.infcx().tcx, did);\n         match (polyty.region_param, a, b) {\n           (None, None, None) => {\n-            ok(None)\n+            Ok(None)\n           }\n           (Some(ty::rv_invariant), Some(a), Some(b)) => {\n             do eq_regions(self, a, b).then {\n-                ok(Some(a))\n+                Ok(Some(a))\n             }\n           }\n           (Some(ty::rv_covariant), Some(a), Some(b)) => {\n             do self.regions(a, b).chain |r| {\n-                ok(Some(r))\n+                Ok(Some(r))\n             }\n           }\n           (Some(ty::rv_contravariant), Some(a), Some(b)) => {\n             do self.contraregions(a, b).chain |r| {\n-                ok(Some(r))\n+                Ok(Some(r))\n             }\n           }\n           (_, _, _) => {\n@@ -200,7 +200,7 @@ fn super_substs<C:combine>(\n             do relate_region_param(self, did,\n                                    a.self_r, b.self_r).chain |self_r|\n             {\n-                ok({self_r: self_r, self_ty: self_ty, tps: tps})\n+                Ok({self_r: self_r, self_ty: self_ty, tps: tps})\n             }\n         }\n     }\n@@ -217,9 +217,9 @@ fn super_tps<C:combine>(\n     if vec::same_length(as, bs) {\n         iter_vec2(as, bs, |a, b| {\n             eq_tys(self, a, b)\n-        }).then(|| ok(as.to_vec()) )\n+        }).then(|| Ok(as.to_vec()) )\n     } else {\n-        err(ty::terr_ty_param_size(\n+        Err(ty::terr_ty_param_size(\n             expected_found(self, as.len(), bs.len())))\n     }\n }\n@@ -232,17 +232,17 @@ fn super_self_tys<C:combine>(\n \n     match (a, b) {\n       (None, None) => {\n-        ok(None)\n+        Ok(None)\n       }\n       (Some(a), Some(b)) => {\n-        eq_tys(self, a, b).then(|| ok(Some(a)) )\n+        eq_tys(self, a, b).then(|| Ok(Some(a)) )\n       }\n       (None, Some(_)) |\n       (Some(_), None) => {\n         // I think it should never happen that we unify two substs and\n         // one of them has a self_ty and one doesn't...? I could be\n         // wrong about this.\n-        err(ty::terr_self_substs)\n+        Err(ty::terr_self_substs)\n       }\n     }\n }\n@@ -252,10 +252,10 @@ fn super_flds<C:combine>(\n \n     if a.ident == b.ident {\n         self.mts(a.mt, b.mt)\n-            .chain(|mt| ok({ident: a.ident, mt: mt}) )\n-            .chain_err(|e| err(ty::terr_in_field(@e, a.ident)) )\n+            .chain(|mt| Ok({ident: a.ident, mt: mt}) )\n+            .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n     } else {\n-        err(ty::terr_record_fields(\n+        Err(ty::terr_record_fields(\n             expected_found(self, a.ident, b.ident)))\n     }\n }\n@@ -274,7 +274,7 @@ fn super_args<C:combine>(\n \n     do self.modes(a.mode, b.mode).chain |m| {\n         do self.contratys(a.ty, b.ty).chain |t| {\n-            ok({mode: m, ty: t})\n+            Ok({mode: m, ty: t})\n         }\n     }\n }\n@@ -286,16 +286,16 @@ fn super_vstores<C:combine>(\n     match (a, b) {\n       (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n         do self.contraregions(a_r, b_r).chain |r| {\n-            ok(ty::vstore_slice(r))\n+            Ok(ty::vstore_slice(r))\n         }\n       }\n \n       _ if a == b => {\n-        ok(a)\n+        Ok(a)\n       }\n \n       _ => {\n-        err(ty::terr_vstores_differ(vk, expected_found(self, a, b)))\n+        Err(ty::terr_vstores_differ(vk, expected_found(self, a, b)))\n       }\n     }\n }\n@@ -309,7 +309,7 @@ fn super_fns<C:combine>(\n         if vec::same_length(a_args, b_args) {\n             map_vec2(a_args, b_args, |a, b| self.args(a, b) )\n         } else {\n-            err(ty::terr_arg_count)\n+            Err(ty::terr_arg_count)\n         }\n     }\n \n@@ -321,7 +321,7 @@ fn super_fns<C:combine>(\n                     // FIXME: uncomment if #2588 doesn't get accepted:\n                     // self.infcx().constrvecs(a_f.constraints,\n                     //                         b_f.constraints).then {||\n-                        ok({purity: purity,\n+                        Ok({purity: purity,\n                             proto: p,\n                             bounds: a_f.bounds, // XXX: This is wrong!\n                             inputs: inputs,\n@@ -354,15 +354,15 @@ fn super_tys<C:combine>(\n \n       // Relate integral variables to other types\n       (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) => {\n-        self.infcx().vars_integral(a_id, b_id).then(|| ok(a) )\n+        self.infcx().vars_integral(a_id, b_id).then(|| Ok(a) )\n       }\n       (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n       (ty::ty_var_integral(a_id), ty::ty_uint(_)) => {\n-        self.infcx().var_integral_sub_t(a_id, b).then(|| ok(a) )\n+        self.infcx().var_integral_sub_t(a_id, b).then(|| Ok(a) )\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) => {\n-        self.infcx().t_sub_var_integral(a, b_id).then(|| ok(a) )\n+        self.infcx().t_sub_var_integral(a, b_id).then(|| Ok(a) )\n       }\n \n       (ty::ty_int(_), _) |\n@@ -371,31 +371,31 @@ fn super_tys<C:combine>(\n         let as = ty::get(a).struct;\n         let bs = ty::get(b).struct;\n         if as == bs {\n-            ok(a)\n+            Ok(a)\n         } else {\n-            err(ty::terr_sorts(expected_found(self, a, b)))\n+            Err(ty::terr_sorts(expected_found(self, a, b)))\n         }\n       }\n \n       (ty::ty_nil, _) |\n       (ty::ty_bool, _) => {\n         let cfg = tcx.sess.targ_cfg;\n         if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n-            ok(a)\n+            Ok(a)\n         } else {\n-            err(ty::terr_sorts(expected_found(self, a, b)))\n+            Err(ty::terr_sorts(expected_found(self, a, b)))\n         }\n       }\n \n       (ty::ty_param(a_p), ty::ty_param(b_p)) if a_p.idx == b_p.idx => {\n-        ok(a)\n+        Ok(a)\n       }\n \n       (ty::ty_enum(a_id, ref a_substs),\n        ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n         do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            ok(ty::mk_enum(tcx, a_id, substs))\n+            Ok(ty::mk_enum(tcx, a_id, substs))\n         }\n       }\n \n@@ -404,85 +404,85 @@ fn super_tys<C:combine>(\n       if a_id == b_id => {\n         do self.substs(a_id, a_substs, b_substs).chain |substs| {\n             do self.vstores(ty::terr_trait, a_vstore, b_vstore).chain |vs| {\n-                ok(ty::mk_trait(tcx, a_id, substs, vs))\n+                Ok(ty::mk_trait(tcx, a_id, substs, vs))\n             }\n         }\n       }\n \n       (ty::ty_class(a_id, ref a_substs), ty::ty_class(b_id, ref b_substs))\n       if a_id == b_id => {\n         do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            ok(ty::mk_class(tcx, a_id, substs))\n+            Ok(ty::mk_class(tcx, a_id, substs))\n         }\n       }\n \n       (ty::ty_box(a_mt), ty::ty_box(b_mt)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n-            ok(ty::mk_box(tcx, mt))\n+            Ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n-            ok(ty::mk_uniq(tcx, mt))\n+            Ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n-            ok(ty::mk_ptr(tcx, mt))\n+            Ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n \n       (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) => {\n         do self.contraregions(a_r, b_r).chain |r| {\n             do self.mts(a_mt, b_mt).chain |mt| {\n-                ok(ty::mk_rptr(tcx, r, mt))\n+                Ok(ty::mk_rptr(tcx, r, mt))\n             }\n         }\n       }\n \n       (ty::ty_evec(a_mt, vs_a), ty::ty_evec(b_mt, vs_b)) => {\n         do self.mts(a_mt, b_mt).chain |mt| {\n             do self.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n-                ok(ty::mk_evec(tcx, mt, vs))\n+                Ok(ty::mk_evec(tcx, mt, vs))\n             }\n         }\n       }\n \n       (ty::ty_estr(vs_a), ty::ty_estr(vs_b)) => {\n         do self.vstores(ty::terr_str, vs_a, vs_b).chain |vs| {\n-            ok(ty::mk_estr(tcx,vs))\n+            Ok(ty::mk_estr(tcx,vs))\n         }\n       }\n \n       (ty::ty_rec(as), ty::ty_rec(bs)) => {\n         if vec::same_length(as, bs) {\n             map_vec2(as, bs, |a,b| {\n                 self.flds(a, b)\n-            }).chain(|flds| ok(ty::mk_rec(tcx, flds)) )\n+            }).chain(|flds| Ok(ty::mk_rec(tcx, flds)) )\n         } else {\n-            err(ty::terr_record_size(expected_found(self, as.len(),\n+            Err(ty::terr_record_size(expected_found(self, as.len(),\n                                                     bs.len())))\n         }\n       }\n \n       (ty::ty_tup(as), ty::ty_tup(bs)) => {\n         if vec::same_length(as, bs) {\n             map_vec2(as, bs, |a, b| self.tys(a, b) )\n-                .chain(|ts| ok(ty::mk_tup(tcx, ts)) )\n+                .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n-            err(ty::terr_tuple_size(expected_found(self, as.len(), bs.len())))\n+            Err(ty::terr_tuple_size(expected_found(self, as.len(), bs.len())))\n         }\n       }\n \n       (ty::ty_fn(ref a_fty), ty::ty_fn(ref b_fty)) => {\n         do self.fns(a_fty, b_fty).chain |fty| {\n-            ok(ty::mk_fn(tcx, fty))\n+            Ok(ty::mk_fn(tcx, fty))\n         }\n       }\n \n-      _ => err(ty::terr_sorts(expected_found(self, a, b)))\n+      _ => Err(ty::terr_sorts(expected_found(self, a, b)))\n     }\n }\n "}, {"sha": "7243efb9db72ebf383927ecb59418ba67b7c469f", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -26,17 +26,17 @@ impl Glb: combine {\n           // the precise type from the mut side.\n           (m_mutbl, m_const) => {\n             Sub(*self).tys(a.ty, b.ty).chain(|_t| {\n-                ok({ty: a.ty, mutbl: m_mutbl})\n+                Ok({ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_const, m_mutbl) => {\n             Sub(*self).tys(b.ty, a.ty).chain(|_t| {\n-                ok({ty: b.ty, mutbl: m_mutbl})\n+                Ok({ty: b.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_mutbl, m_mutbl) => {\n             eq_tys(&self, a.ty, b.ty).then(|| {\n-                ok({ty: a.ty, mutbl: m_mutbl})\n+                Ok({ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n \n@@ -46,22 +46,22 @@ impl Glb: combine {\n           (m_const, m_imm) |\n           (m_imm, m_imm) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                ok({ty: t, mutbl: m_imm})\n+                Ok({ty: t, mutbl: m_imm})\n             })\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n           (m_const, m_const) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                ok({ty: t, mutbl: m_const})\n+                Ok({ty: t, mutbl: m_const})\n             })\n           }\n \n           // There is no mutual subtype of these combinations.\n           (m_mutbl, m_imm) |\n           (m_imm, m_mutbl) => {\n-              err(ty::terr_mutability)\n+              Err(ty::terr_mutability)\n           }\n         }\n     }\n@@ -72,39 +72,39 @@ impl Glb: combine {\n \n     fn protos(p1: ty::fn_proto, p2: ty::fn_proto) -> cres<ty::fn_proto> {\n         match (p1, p2) {\n-            (ty::proto_vstore(ty::vstore_slice(_)), _) => ok(p2),\n-            (_, ty::proto_vstore(ty::vstore_slice(_))) => ok(p1),\n+            (ty::proto_vstore(ty::vstore_slice(_)), _) => Ok(p2),\n+            (_, ty::proto_vstore(ty::vstore_slice(_))) => Ok(p1),\n             (ty::proto_vstore(v1), ty::proto_vstore(v2)) => {\n                 self.infcx.try(|| {\n                     do self.vstores(terr_fn, v1, v2).chain |vs| {\n-                        ok(ty::proto_vstore(vs))\n+                        Ok(ty::proto_vstore(vs))\n                     }\n                 }).chain_err(|_err| {\n                     // XXX: Totally unsound, but fixed up later.\n-                    ok(ty::proto_bare)\n+                    Ok(ty::proto_bare)\n                 })\n             }\n-            _ => ok(ty::proto_bare)\n+            _ => Ok(ty::proto_bare)\n         }\n     }\n \n     fn purities(a: purity, b: purity) -> cres<purity> {\n         match (a, b) {\n-          (pure_fn, _) | (_, pure_fn) => ok(pure_fn),\n-          (extern_fn, _) | (_, extern_fn) => ok(extern_fn),\n-          (impure_fn, _) | (_, impure_fn) => ok(impure_fn),\n-          (unsafe_fn, unsafe_fn) => ok(unsafe_fn)\n+          (pure_fn, _) | (_, pure_fn) => Ok(pure_fn),\n+          (extern_fn, _) | (_, extern_fn) => Ok(extern_fn),\n+          (impure_fn, _) | (_, impure_fn) => Ok(impure_fn),\n+          (unsafe_fn, unsafe_fn) => Ok(unsafe_fn)\n         }\n     }\n \n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n         match (r1, r2) {\n           (ast::return_val, ast::return_val) => {\n-            ok(ast::return_val)\n+            Ok(ast::return_val)\n           }\n           (ast::noreturn, _) |\n           (_, ast::noreturn) => {\n-            ok(ast::noreturn)\n+            Ok(ast::noreturn)\n           }\n         }\n     }"}, {"sha": "82f69df7fe6a6bbc9d8e98fb6ab832919969349b", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -20,7 +20,7 @@ impl Lub: lattice_ops {\n         {ub: Some(t) with b}\n     }\n     fn ty_bot(t: ty::t) -> cres<ty::t> {\n-        ok(t)\n+        Ok(t)\n     }\n }\n \n@@ -30,7 +30,7 @@ impl Glb: lattice_ops {\n         {lb: Some(t) with b}\n     }\n     fn ty_bot(_t: ty::t) -> cres<ty::t> {\n-        ok(ty::mk_bot(self.infcx.tcx))\n+        Ok(ty::mk_bot(self.infcx.tcx))\n     }\n }\n \n@@ -40,7 +40,7 @@ fn lattice_tys<L:lattice_ops combine>(\n     debug!(\"%s.lattice_tys(%s, %s)\", self.tag(),\n            a.to_str(self.infcx()),\n            b.to_str(self.infcx()));\n-    if a == b { return ok(a); }\n+    if a == b { return Ok(a); }\n     do indent {\n         match (ty::get(a).struct, ty::get(b).struct) {\n           (ty::ty_bot, _) => self.ty_bot(b),\n@@ -90,7 +90,7 @@ fn lattice_vars<L:lattice_ops combine>(\n            b_vid.to_str(), b_bounds.to_str(self.infcx()));\n \n     if a_vid == b_vid {\n-        return ok(a_t);\n+        return Ok(a_t);\n     }\n \n     // If both A and B have an UB type, then we can just compute the\n@@ -99,16 +99,16 @@ fn lattice_vars<L:lattice_ops combine>(\n     match (a_bnd, b_bnd) {\n       (Some(a_ty), Some(b_ty)) => {\n         match self.infcx().try(|| c_ts(a_ty, b_ty) ) {\n-            ok(t) => return ok(t),\n-            err(_) => { /*fallthrough */ }\n+            Ok(t) => return Ok(t),\n+            Err(_) => { /*fallthrough */ }\n         }\n       }\n       _ => {/*fallthrough*/}\n     }\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    var_sub_var(self, a_vid, b_vid).then(|| ok(a_t) )\n+    var_sub_var(self, a_vid, b_vid).then(|| Ok(a_t) )\n }\n \n fn lattice_var_and_t<L:lattice_ops combine>(\n@@ -141,7 +141,7 @@ fn lattice_var_and_t<L:lattice_ops combine>(\n         let a_bounds = self.with_bnd(a_bounds, b);\n         do bnds(self, a_bounds.lb, a_bounds.ub).then {\n             self.infcx().set(vb, a_id, root(a_bounds, nde_a.rank));\n-            ok(b)\n+            Ok(b)\n         }\n       }\n     }"}, {"sha": "c2477c695bfbeb9b6354a24a1bcd9c81f6644056", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -13,7 +13,7 @@ impl Lub: combine {\n     fn lub() -> Lub { Lub(*self) }\n     fn glb() -> Glb { Glb(*self) }\n \n-    fn bot_ty(b: ty::t) -> cres<ty::t> { ok(b) }\n+    fn bot_ty(b: ty::t) -> cres<ty::t> { Ok(b) }\n     fn ty_bot(b: ty::t) -> cres<ty::t> { self.bot_ty(b) } // commutative\n \n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n@@ -32,17 +32,17 @@ impl Lub: combine {\n \n         match m {\n           m_imm | m_const => {\n-            self.tys(a.ty, b.ty).chain(|t| ok({ty: t, mutbl: m}) )\n+            self.tys(a.ty, b.ty).chain(|t| Ok({ty: t, mutbl: m}) )\n           }\n \n           m_mutbl => {\n             self.infcx.try(|| {\n                 eq_tys(&self, a.ty, b.ty).then(|| {\n-                    ok({ty: a.ty, mutbl: m})\n+                    Ok({ty: a.ty, mutbl: m})\n                 })\n             }).chain_err(|_e| {\n                 self.tys(a.ty, b.ty).chain(|t| {\n-                    ok({ty: t, mutbl: m_const})\n+                    Ok({ty: t, mutbl: m_const})\n                 })\n             })\n           }\n@@ -56,35 +56,35 @@ impl Lub: combine {\n     // XXX: Wrong.\n     fn protos(p1: ty::fn_proto, p2: ty::fn_proto) -> cres<ty::fn_proto> {\n         match (p1, p2) {\n-            (ty::proto_bare, _) => ok(p2),\n-            (_, ty::proto_bare) => ok(p1),\n+            (ty::proto_bare, _) => Ok(p2),\n+            (_, ty::proto_bare) => Ok(p1),\n             (ty::proto_vstore(v1), ty::proto_vstore(v2)) => {\n                 self.infcx.try(|| {\n                     do self.vstores(terr_fn, v1, v2).chain |vs| {\n-                        ok(ty::proto_vstore(vs))\n+                        Ok(ty::proto_vstore(vs))\n                     }\n                 }).chain_err(|_err| {\n                     // XXX: Totally unsound, but fixed up later.\n-                    ok(ty::proto_vstore(ty::vstore_slice(ty::re_static)))\n+                    Ok(ty::proto_vstore(ty::vstore_slice(ty::re_static)))\n                 })\n             }\n         }\n     }\n \n     fn purities(a: purity, b: purity) -> cres<purity> {\n         match (a, b) {\n-          (unsafe_fn, _) | (_, unsafe_fn) => ok(unsafe_fn),\n-          (impure_fn, _) | (_, impure_fn) => ok(impure_fn),\n-          (extern_fn, _) | (_, extern_fn) => ok(extern_fn),\n-          (pure_fn, pure_fn) => ok(pure_fn)\n+          (unsafe_fn, _) | (_, unsafe_fn) => Ok(unsafe_fn),\n+          (impure_fn, _) | (_, impure_fn) => Ok(impure_fn),\n+          (extern_fn, _) | (_, extern_fn) => Ok(extern_fn),\n+          (pure_fn, pure_fn) => Ok(pure_fn)\n         }\n     }\n \n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n         match (r1, r2) {\n           (ast::return_val, _) |\n-          (_, ast::return_val) => ok(ast::return_val),\n-          (ast::noreturn, ast::noreturn) => ok(ast::noreturn)\n+          (_, ast::return_val) => Ok(ast::return_val),\n+          (ast::noreturn, ast::noreturn) => Ok(ast::noreturn)\n         }\n     }\n "}, {"sha": "a39152e155e7dc1c9e93410b86fa336d7040cb82", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -306,8 +306,8 @@ because `&x` was created alone, but is relatable to `&A`.\n #[warn(deprecated_pattern)];\n \n import dvec::{DVec, dvec};\n-import result::result;\n-import result::{ok, err};\n+import result::Result;\n+import result::{Ok, Err};\n import std::map::{hashmap, uint_hash};\n import std::cell::{Cell, empty_cell};\n import std::list::{list, nil, cons};\n@@ -478,21 +478,21 @@ impl RegionVarBindings {\n         match (sub, sup) {\n           (ty::re_var (sub_id), ty::re_var(sup_id)) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), span);\n-            ok(())\n+            Ok(())\n           }\n           (r, ty::re_var(sup_id)) => {\n             self.add_constraint(ConstrainRegSubVar(r, sup_id), span);\n-            ok(())\n+            Ok(())\n           }\n           (ty::re_var(sub_id), r) => {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), span);\n-            ok(())\n+            Ok(())\n           }\n           _ => {\n             if self.is_subregion_of(sub, sup) {\n-                ok(())\n+                Ok(())\n             } else {\n-                err(ty::terr_regions_does_not_outlive(sub, sup))\n+                Err(ty::terr_regions_does_not_outlive(sub, sup))\n             }\n           }\n         }\n@@ -505,7 +505,7 @@ impl RegionVarBindings {\n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n           (ty::re_static, _) | (_, ty::re_static) => {\n-            ok(ty::re_static) // nothing lives longer than static\n+            Ok(ty::re_static) // nothing lives longer than static\n           }\n \n           (ty::re_var(*), _) | (_, ty::re_var(*)) => {\n@@ -515,7 +515,7 @@ impl RegionVarBindings {\n           }\n \n           _ => {\n-            ok(self.lub_concrete_regions(a, b))\n+            Ok(self.lub_concrete_regions(a, b))\n           }\n         }\n     }\n@@ -528,7 +528,7 @@ impl RegionVarBindings {\n         match (a, b) {\n           (ty::re_static, r) | (r, ty::re_static) => {\n             // static lives longer than everything else\n-            ok(r)\n+            Ok(r)\n           }\n \n           (ty::re_var(*), _) | (_, ty::re_var(*)) => {\n@@ -561,7 +561,7 @@ impl RegionVarBindings {\n \n         let vars = TwoRegions { a: a, b: b };\n         match combines.find(vars) {\n-          Some(c) => ok(ty::re_var(c)),\n+          Some(c) => Ok(ty::re_var(c)),\n           None => {\n             let c = self.new_region_var(span);\n             combines.insert(vars, c);\n@@ -571,7 +571,7 @@ impl RegionVarBindings {\n             do relate(a, ty::re_var(c)).then {\n                 do relate(b, ty::re_var(c)).then {\n                     debug!(\"combine_vars() c=%?\", ty::re_var(c));\n-                    ok(ty::re_var(c))\n+                    Ok(ty::re_var(c))\n                 }\n             }\n           }\n@@ -655,7 +655,7 @@ priv impl RegionVarBindings {\n         match (a, b) {\n           (ty::re_static, r) | (r, ty::re_static) => {\n             // static lives longer than everything else\n-            ok(r)\n+            Ok(r)\n           }\n \n           (ty::re_var(v_id), _) | (_, ty::re_var(v_id)) => {\n@@ -674,26 +674,26 @@ priv impl RegionVarBindings {\n             // big the free region is precisely, the GLB is undefined.\n             let rm = self.tcx.region_map;\n             match region::nearest_common_ancestor(rm, f_id, s_id) {\n-              Some(r_id) if r_id == f_id => ok(s),\n-              _ => err(ty::terr_regions_no_overlap(b, a))\n+              Some(r_id) if r_id == f_id => Ok(s),\n+              _ => Err(ty::terr_regions_no_overlap(b, a))\n             }\n           }\n \n           (ty::re_scope(a_id), ty::re_scope(b_id)) |\n           (ty::re_free(a_id, _), ty::re_free(b_id, _)) => {\n             if a == b {\n                 // Same scope or same free identifier, easy case.\n-                ok(a)\n+                Ok(a)\n             } else {\n                 // We want to generate the intersection of two\n                 // scopes or two free regions.  So, if one of\n                 // these scopes is a subscope of the other, return\n                 // it.  Otherwise fail.\n                 let rm = self.tcx.region_map;\n                 match region::nearest_common_ancestor(rm, a_id, b_id) {\n-                  Some(r_id) if a_id == r_id => ok(ty::re_scope(b_id)),\n-                  Some(r_id) if b_id == r_id => ok(ty::re_scope(a_id)),\n-                  _ => err(ty::terr_regions_no_overlap(b, a))\n+                  Some(r_id) if a_id == r_id => Ok(ty::re_scope(b_id)),\n+                  Some(r_id) if b_id == r_id => Ok(ty::re_scope(a_id)),\n+                  _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n           }\n@@ -706,9 +706,9 @@ priv impl RegionVarBindings {\n           (ty::re_free(_, _), ty::re_bound(_)) |\n           (ty::re_scope(_), ty::re_bound(_)) => {\n             if a == b {\n-                ok(a)\n+                Ok(a)\n             } else {\n-                err(ty::terr_regions_no_overlap(b, a))\n+                Err(ty::terr_regions_no_overlap(b, a))\n             }\n           }\n         }\n@@ -961,7 +961,7 @@ impl RegionVarBindings {\n                        a_region: region,\n                        b_region: region) -> bool {\n             match self.glb_concrete_regions(a_region, b_region) {\n-              ok(glb) => {\n+              Ok(glb) => {\n                 if glb == a_region {\n                     false\n                 } else {\n@@ -971,7 +971,7 @@ impl RegionVarBindings {\n                     true\n                 }\n               }\n-              err(_) => {\n+              Err(_) => {\n                 a_node.value = ErrorValue;\n                 false\n               }\n@@ -1101,8 +1101,8 @@ impl RegionVarBindings {\n             for vec::each(upper_bounds) |upper_bound_2| {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n-                  ok(_) => {}\n-                  err(_) => {\n+                  Ok(_) => {}\n+                  Err(_) => {\n \n                     if self.is_reported(dup_map,\n                                         upper_bound_1.region,"}, {"sha": "a921ca7bddd60f6763d5ad2467def77bbcdb35a2", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -92,18 +92,18 @@ impl resolve_state {\n             debug!(\"Resolved to %s (modes=%x)\",\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.modes);\n-            return ok(rty);\n+            return Ok(rty);\n           }\n-          Some(e) => return err(e)\n+          Some(e) => return Err(e)\n         }\n     }\n \n     fn resolve_region_chk(orig: ty::region) -> fres<ty::region> {\n         self.err = None;\n         let resolved = indent(|| self.resolve_region(orig) );\n         match self.err {\n-          None => ok(resolved),\n-          Some(e) => err(e)\n+          None => Ok(resolved),\n+          Some(e) => Err(e)\n         }\n     }\n "}, {"sha": "7a039ae497a07c6f493ba8457fd732dcbd91e7ae", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -34,8 +34,8 @@ impl Sub: combine {\n                b.to_str(self.infcx));\n         do indent {\n             match self.infcx.region_vars.make_subregion(self.span, a, b) {\n-              ok(()) => ok(a),\n-              err(e) => err(e)\n+              Ok(()) => Ok(a),\n+              Err(e) => Err(e)\n             }\n         }\n     }\n@@ -44,41 +44,41 @@ impl Sub: combine {\n         debug!(\"mts(%s <: %s)\", a.to_str(self.infcx), b.to_str(self.infcx));\n \n         if a.mutbl != b.mutbl && b.mutbl != m_const {\n-            return err(ty::terr_mutability);\n+            return Err(ty::terr_mutability);\n         }\n \n         match b.mutbl {\n           m_mutbl => {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n-            eq_tys(&self, a.ty, b.ty).then(|| ok(a) )\n+            eq_tys(&self, a.ty, b.ty).then(|| Ok(a) )\n           }\n           m_imm | m_const => {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain(|_t| ok(a) )\n+            self.tys(a.ty, b.ty).chain(|_t| Ok(a) )\n           }\n         }\n     }\n \n     fn protos(a: ty::fn_proto, b: ty::fn_proto) -> cres<ty::fn_proto> {\n         match (a, b) {\n             (ty::proto_bare, _) =>\n-                ok(ty::proto_bare),\n+                Ok(ty::proto_bare),\n \n             (ty::proto_vstore(ty::vstore_box),\n              ty::proto_vstore(ty::vstore_slice(_))) =>\n-                ok(ty::proto_vstore(ty::vstore_box)),\n+                Ok(ty::proto_vstore(ty::vstore_box)),\n \n             (ty::proto_vstore(ty::vstore_uniq),\n              ty::proto_vstore(ty::vstore_slice(_))) =>\n-                ok(ty::proto_vstore(ty::vstore_uniq)),\n+                Ok(ty::proto_vstore(ty::vstore_uniq)),\n \n             (_, ty::proto_bare) =>\n-                err(ty::terr_proto_mismatch(expected_found(&self, a, b))),\n+                Err(ty::terr_proto_mismatch(expected_found(&self, a, b))),\n \n             (ty::proto_vstore(vs_a), ty::proto_vstore(vs_b)) => {\n                 do self.vstores(ty::terr_fn, vs_a, vs_b).chain |vs_c| {\n-                    ok(ty::proto_vstore(vs_c))\n+                    Ok(ty::proto_vstore(vs_c))\n                 }\n             }\n         }\n@@ -99,23 +99,23 @@ impl Sub: combine {\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"%s.tys(%s, %s)\", self.tag(),\n                a.to_str(self.infcx), b.to_str(self.infcx));\n-        if a == b { return ok(a); }\n+        if a == b { return Ok(a); }\n         do indent {\n             match (ty::get(a).struct, ty::get(b).struct) {\n               (ty::ty_bot, _) => {\n-                ok(a)\n+                Ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-                var_sub_var(&self, a_id, b_id).then(|| ok(a) )\n+                var_sub_var(&self, a_id, b_id).then(|| Ok(a) )\n               }\n               (ty::ty_var(a_id), _) => {\n-                var_sub_t(&self, a_id, b).then(|| ok(a) )\n+                var_sub_t(&self, a_id, b).then(|| Ok(a) )\n               }\n               (_, ty::ty_var(b_id)) => {\n-                t_sub_var(&self, a, b_id).then(|| ok(a) )\n+                t_sub_var(&self, a, b_id).then(|| Ok(a) )\n               }\n               (_, ty::ty_bot) => {\n-                err(ty::terr_sorts(expected_found(&self, a, b)))\n+                Err(ty::terr_sorts(expected_found(&self, a, b)))\n               }\n               _ => {\n                 super_tys(&self, a, b)"}, {"sha": "ed9daafeba35e9b859ac2ffb741175a49e8272d2", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -69,12 +69,12 @@ fn merge_bnd<C: combine>(\n     let _r = indenter();\n \n     match (a, b) {\n-      (None, None) => ok(None),\n-      (Some(_), None) => ok(a),\n-      (None, Some(_)) => ok(b),\n+      (None, None) => Ok(None),\n+      (Some(_), None) => Ok(a),\n+      (None, Some(_)) => Ok(b),\n       (Some(v_a), Some(v_b)) => {\n         do merge_op(v_a, v_b).chain |v| {\n-            ok(Some(v))\n+            Ok(Some(v))\n         }\n       }\n     }\n@@ -96,7 +96,7 @@ fn merge_bnds<C: combine>(\n                    a.lb.to_str(self.infcx()),\n                    b.lb.to_str(self.infcx()),\n                    lb.to_str(self.infcx()));\n-            ok({lb: lb, ub: ub})\n+            Ok({lb: lb, ub: ub})\n         }\n     }\n }\n@@ -198,8 +198,8 @@ fn var_sub_var<C: combine>(self: &C,\n       (Some(a_ub), Some(b_lb)) => {\n         let r = self.infcx().try(|| self.sub().tys(a_ub, b_lb));\n         match r {\n-          ok(_ty) => return result::ok(()),\n-          err(_) => { /*fallthrough */ }\n+          Ok(_ty) => return result::Ok(()),\n+          Err(_) => { /*fallthrough */ }\n         }\n       }\n       _ => { /*fallthrough*/ }\n@@ -311,7 +311,7 @@ impl infer_ctxt {\n         // possible types.\n         let intersection = intersection(a_pt, b_pt);\n         if *intersection == INT_TY_SET_EMPTY {\n-            return err(ty::terr_no_integral_type);\n+            return Err(ty::terr_no_integral_type);\n         }\n \n         // Rank optimization\n@@ -351,7 +351,7 @@ impl infer_ctxt {\n             intersection(a_pt,\n                          convert_integral_ty_to_int_ty_set(self.tcx, b));\n         if *intersection == INT_TY_SET_EMPTY {\n-            return err(ty::terr_no_integral_type);\n+            return Err(ty::terr_no_integral_type);\n         }\n         self.set(vb, a_id, root(intersection, nde_a.rank));\n         uok()\n@@ -369,7 +369,7 @@ impl infer_ctxt {\n             intersection(b_pt,\n                          convert_integral_ty_to_int_ty_set(self.tcx, a));\n         if *intersection == INT_TY_SET_EMPTY {\n-            return err(ty::terr_no_integral_type);\n+            return Err(ty::terr_no_integral_type);\n         }\n         self.set(vb, b_id, root(intersection, nde_b.rank));\n         uok()"}, {"sha": "42a16ad5ab339c2750ace176041568818279eae6", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -1,37 +1,37 @@\n-import result::result;\n+import result::Result;\n import syntax::parse::token::special_idents;\n \n trait region_scope {\n-    fn anon_region(span: span) -> result<ty::region, ~str>;\n-    fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str>;\n+    fn anon_region(span: span) -> Result<ty::region, ~str>;\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str>;\n }\n \n enum empty_rscope { empty_rscope }\n impl empty_rscope: region_scope {\n-    fn anon_region(_span: span) -> result<ty::region, ~str> {\n-        result::ok(ty::re_static)\n+    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n+        result::Ok(ty::re_static)\n     }\n-    fn named_region(_span: span, id: ast::ident) -> result<ty::region, ~str> {\n-        if id == special_idents::static { result::ok(ty::re_static) }\n-        else { result::err(~\"only the static region is allowed here\") }\n+    fn named_region(_span: span, id: ast::ident) -> Result<ty::region, ~str> {\n+        if id == special_idents::static { result::Ok(ty::re_static) }\n+        else { result::Err(~\"only the static region is allowed here\") }\n     }\n }\n \n enum type_rscope = Option<ty::region_variance>;\n impl type_rscope: region_scope {\n-    fn anon_region(_span: span) -> result<ty::region, ~str> {\n+    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n         match *self {\n-          Some(_) => result::ok(ty::re_bound(ty::br_self)),\n-          None => result::err(~\"to use region types here, the containing \\\n+          Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n+          None => result::Err(~\"to use region types here, the containing \\\n                                 type must be declared with a region bound\")\n         }\n     }\n-    fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             if id == special_idents::self_ {\n                 self.anon_region(span)\n             } else {\n-                result::err(~\"named regions other than `self` are not \\\n+                result::Err(~\"named regions other than `self` are not \\\n                              allowed as part of a type declaration\")\n             }\n         }\n@@ -51,10 +51,10 @@ fn in_anon_rscope<RS: region_scope copy owned>(self: RS, r: ty::region)\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n impl @anon_rscope: region_scope {\n-    fn anon_region(_span: span) -> result<ty::region, ~str> {\n-        result::ok(self.anon)\n+    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n+        result::Ok(self.anon)\n     }\n-    fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n         self.base.named_region(span, id)\n     }\n }\n@@ -69,14 +69,14 @@ fn in_binding_rscope<RS: region_scope copy owned>(self: RS)\n     @binding_rscope { base: base, anon_bindings: 0 }\n }\n impl @binding_rscope: region_scope {\n-    fn anon_region(_span: span) -> result<ty::region, ~str> {\n+    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n         let idx = self.anon_bindings;\n         self.anon_bindings += 1;\n-        result::ok(ty::re_bound(ty::br_anon(idx)))\n+        result::Ok(ty::re_bound(ty::br_anon(idx)))\n     }\n-    fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n         do self.base.named_region(span, id).chain_err |_e| {\n-            result::ok(ty::re_bound(ty::br_named(id)))\n+            result::Ok(ty::re_bound(ty::br_named(id)))\n         }\n     }\n }"}, {"sha": "2a0f161c5fe4b3884fb7a2d50693276b3b6d8f2d", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -1,4 +1,4 @@\n-import result::result;\n+import result::Result;\n import std::getopts;\n \n export output_format;\n@@ -90,29 +90,29 @@ fn mock_program_output(_prog: &str, _args: &[~str]) -> {\n     }\n }\n \n-fn parse_config(args: ~[~str]) -> result<config, ~str> {\n+fn parse_config(args: ~[~str]) -> Result<config, ~str> {\n     parse_config_(args, run::program_output)\n }\n \n fn parse_config_(\n     args: ~[~str],\n     program_output: program_output\n-) -> result<config, ~str> {\n+) -> Result<config, ~str> {\n     let args = vec::tail(args);\n     let opts = vec::unzip(opts()).first();\n     match getopts::getopts(args, opts) {\n-        result::ok(matches) => {\n+        result::Ok(matches) => {\n             if vec::len(matches.free) == 1u {\n                 let input_crate = Path(vec::head(matches.free));\n                 config_from_opts(&input_crate, matches, program_output)\n             } else if vec::is_empty(matches.free) {\n-                result::err(~\"no crates specified\")\n+                result::Err(~\"no crates specified\")\n             } else {\n-                result::err(~\"multiple crates specified\")\n+                result::Err(~\"multiple crates specified\")\n             }\n         }\n-        result::err(f) => {\n-            result::err(getopts::fail_str(f))\n+        result::Err(f) => {\n+            result::Err(getopts::fail_str(f))\n         }\n     }\n }\n@@ -121,27 +121,27 @@ fn config_from_opts(\n     input_crate: &Path,\n     matches: getopts::matches,\n     program_output: program_output\n-) -> result<config, ~str> {\n+) -> Result<config, ~str> {\n \n     let config = default_config(input_crate);\n-    let result = result::ok(config);\n+    let result = result::Ok(config);\n     let result = do result::chain(result) |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = option::map(output_dir, |s| Path(s));\n-        result::ok({\n+        result::Ok({\n             output_dir: option::get_default(output_dir, config.output_dir)\n             with config\n         })\n     };\n     let result = do result::chain(result) |config| {\n         let output_format = getopts::opt_maybe_str(\n             matches, opt_output_format());\n-        do option::map_default(output_format, result::ok(config))\n+        do option::map_default(output_format, result::Ok(config))\n             |output_format| {\n             do result::chain(parse_output_format(output_format))\n                 |output_format| {\n \n-                result::ok({\n+                result::Ok({\n                     output_format: output_format\n                     with config\n                 })\n@@ -151,11 +151,11 @@ fn config_from_opts(\n     let result = do result::chain(result) |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n-        do option::map_default(output_style, result::ok(config))\n+        do option::map_default(output_style, result::Ok(config))\n             |output_style| {\n             do result::chain(parse_output_style(output_style))\n                 |output_style| {\n-                result::ok({\n+                result::Ok({\n                     output_style: output_style\n                     with config\n                 })\n@@ -167,7 +167,7 @@ fn config_from_opts(\n         let pandoc_cmd = maybe_find_pandoc(\n             config, pandoc_cmd, program_output);\n         do result::chain(pandoc_cmd) |pandoc_cmd| {\n-            result::ok({\n+            result::Ok({\n                 pandoc_cmd: pandoc_cmd\n                 with config\n             })\n@@ -176,29 +176,29 @@ fn config_from_opts(\n     return result;\n }\n \n-fn parse_output_format(output_format: ~str) -> result<output_format, ~str> {\n+fn parse_output_format(output_format: ~str) -> Result<output_format, ~str> {\n     match output_format {\n-      ~\"markdown\" => result::ok(markdown),\n-      ~\"html\" => result::ok(pandoc_html),\n-      _ => result::err(fmt!(\"unknown output format '%s'\", output_format))\n+      ~\"markdown\" => result::Ok(markdown),\n+      ~\"html\" => result::Ok(pandoc_html),\n+      _ => result::Err(fmt!(\"unknown output format '%s'\", output_format))\n     }\n }\n \n-fn parse_output_style(output_style: ~str) -> result<output_style, ~str> {\n+fn parse_output_style(output_style: ~str) -> Result<output_style, ~str> {\n     match output_style {\n-      ~\"doc-per-crate\" => result::ok(doc_per_crate),\n-      ~\"doc-per-mod\" => result::ok(doc_per_mod),\n-      _ => result::err(fmt!(\"unknown output style '%s'\", output_style))\n+      ~\"doc-per-crate\" => result::Ok(doc_per_crate),\n+      ~\"doc-per-mod\" => result::Ok(doc_per_mod),\n+      _ => result::Err(fmt!(\"unknown output style '%s'\", output_style))\n     }\n }\n \n fn maybe_find_pandoc(\n     config: config,\n     maybe_pandoc_cmd: Option<~str>,\n     program_output: program_output\n-) -> result<Option<~str>, ~str> {\n+) -> Result<Option<~str>, ~str> {\n     if config.output_format != pandoc_html {\n-        return result::ok(maybe_pandoc_cmd);\n+        return result::Ok(maybe_pandoc_cmd);\n     }\n \n     let possible_pandocs = match maybe_pandoc_cmd {\n@@ -220,9 +220,9 @@ fn maybe_find_pandoc(\n     };\n \n     if option::is_some(pandoc) {\n-        result::ok(pandoc)\n+        result::Ok(pandoc)\n     } else {\n-        result::err(~\"couldn't find pandoc\")\n+        result::Err(~\"couldn't find pandoc\")\n     }\n }\n \n@@ -240,7 +240,7 @@ fn should_find_pandoc() {\n         }\n     };\n     let result = maybe_find_pandoc(config, None, mock_program_output);\n-    assert result == result::ok(Some(~\"pandoc\"));\n+    assert result == result::Ok(Some(~\"pandoc\"));\n }\n \n #[test]\n@@ -257,12 +257,12 @@ fn should_error_with_no_pandoc() {\n         }\n     };\n     let result = maybe_find_pandoc(config, None, mock_program_output);\n-    assert result == result::err(~\"couldn't find pandoc\");\n+    assert result == result::Err(~\"couldn't find pandoc\");\n }\n \n #[cfg(test)]\n mod test {\n-    fn parse_config(args: ~[~str]) -> result<config, ~str> {\n+    fn parse_config(args: ~[~str]) -> Result<config, ~str> {\n         parse_config_(args, mock_program_output)\n     }\n }"}, {"sha": "066e59d4094920f37151a7aca8f50ef14a3af8eb", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -258,10 +258,10 @@ fn write_file(path: &Path, s: ~str) {\n     import io::WriterUtil;\n \n     match io::file_writer(path, ~[io::Create, io::Truncate]) {\n-      result::ok(writer) => {\n+      result::Ok(writer) => {\n         writer.write_str(s);\n       }\n-      result::err(e) => fail e\n+      result::Err(e) => fail e\n     }\n }\n "}, {"sha": "c55579adb41317b76c174b587680030312e554d0", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -108,8 +108,8 @@ fn main(args: ~[~str]) {\n     }\n \n     let config = match config::parse_config(args) {\n-      result::ok(config) => config,\n-      result::err(err) => {\n+      result::Ok(config) => config,\n+      result::Err(err) => {\n         io::println(fmt!(\"error: %s\", err));\n         return;\n       }"}, {"sha": "cb40b444d170018b745e607c66eb3847ee405b80", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -21,7 +21,7 @@ import pipes::send;\n import pipes::recv;\n \n import core::result;\n-import result::{ok, err};\n+import result::{Ok, Err};\n \n fn fib(n: int) -> int {\n     fn pfib(c: chan<int>, n: int) {\n@@ -52,8 +52,8 @@ fn parse_opts(argv: ~[~str]) -> config {\n     let opt_args = vec::slice(argv, 1u, vec::len(argv));\n \n     match getopts::getopts(opt_args, opts) {\n-      ok(m) => { return {stress: getopts::opt_present(m, ~\"stress\")} }\n-      err(_) => { fail; }\n+      Ok(m) => { return {stress: getopts::opt_present(m, ~\"stress\")} }\n+      Err(_) => { fail; }\n     }\n }\n "}, {"sha": "2fb2cfe1da97f576edc348be631dafaccd126661", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -51,7 +51,7 @@ fn main(args: ~[~str]) {\n     // Main group #0 waits for unsupervised group #1.\n     // Grandparent group #1 waits for middle group #2, then fails, killing #3.\n     // Middle group #2 creates grandchild_group #3, waits for it to be ready, exits.\n-    let x: result::result<(),()> = do task::try { // unlinked\n+    let x: result::Result<(),()> = do task::try { // unlinked\n         do spawn_supervised_blocking(\"grandparent\") {\n             do spawn_supervised_blocking(\"middle\") {\n                 grandchild_group(num_tasks);"}, {"sha": "73b24dd2b5423a09720d8ea4a5f062aa3e764a69", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -81,8 +81,8 @@ impl io::Reader: word_reader {\n \n fn file_word_reader(filename: ~str) -> word_reader {\n     match io::file_reader(&Path(filename)) {\n-      result::ok(f) => { f as word_reader }\n-      result::err(e) => { fail fmt!(\"%?\", e) }\n+      result::Ok(f) => { f as word_reader }\n+      result::Err(e) => { fail fmt!(\"%?\", e) }\n     }\n }\n "}, {"sha": "fbc8378643b96c8255702b26b4a2f102b27427c5", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c6e470a257fc546555aa10ededded4a77460a71/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=0c6e470a257fc546555aa10ededded4a77460a71", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:get called on error result: ~\"kitty\"\n fn main() {\n-  log(error, result::get(result::err::<int,~str>(~\"kitty\")));\n+  log(error, result::get(result::Err::<int,~str>(~\"kitty\")));\n }"}]}