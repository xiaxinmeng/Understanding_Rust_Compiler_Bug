{"sha": "6f8b6c8c3650e8d73be07f119b6a435cad6db438", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmOGI2YzhjMzY1MGU4ZDczYmUwN2YxMTliNmE0MzVjYWQ2ZGI0Mzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-09T21:44:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-09T21:44:40Z"}, "message": "syntax: De-doc comment to fix nightlies\n\nThis reverts the promotion from line-comment to doc-comment in 4989a56 to fix\nthe compiler-docs target.\n\nCloses #15553", "tree": {"sha": "861a11b4707e32e3a09d74605769ecdb75a01c17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/861a11b4707e32e3a09d74605769ecdb75a01c17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f8b6c8c3650e8d73be07f119b6a435cad6db438", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8b6c8c3650e8d73be07f119b6a435cad6db438", "html_url": "https://github.com/rust-lang/rust/commit/6f8b6c8c3650e8d73be07f119b6a435cad6db438", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f8b6c8c3650e8d73be07f119b6a435cad6db438/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c460d38363e315a3e993649215aa6846ac2b70e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c460d38363e315a3e993649215aa6846ac2b70e3", "html_url": "https://github.com/rust-lang/rust/commit/c460d38363e315a3e993649215aa6846ac2b70e3"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "778f77ac7a8181383aae92d48cf0e41226e0848b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6f8b6c8c3650e8d73be07f119b6a435cad6db438/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8b6c8c3650e8d73be07f119b6a435cad6db438/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6f8b6c8c3650e8d73be07f119b6a435cad6db438", "patch": "@@ -561,56 +561,56 @@ pub enum TokenTree {\n     TTNonterminal(Span, Ident)\n }\n \n-/// Matchers are nodes defined-by and recognized-by the main rust parser and\n-/// language, but they're only ever found inside syntax-extension invocations;\n-/// indeed, the only thing that ever _activates_ the rules in the rust parser\n-/// for parsing a matcher is a matcher looking for the 'matchers' nonterminal\n-/// itself. Matchers represent a small sub-language for pattern-matching\n-/// token-trees, and are thus primarily used by the macro-defining extension\n-/// itself.\n-///\n-/// MatchTok\n-/// --------\n-///\n-///     A matcher that matches a single token, denoted by the token itself. So\n-///     long as there's no $ involved.\n-///\n-///\n-/// MatchSeq\n-/// --------\n-///\n-///     A matcher that matches a sequence of sub-matchers, denoted various\n-///     possible ways:\n-///\n-///             $(M)*       zero or more Ms\n-///             $(M)+       one or more Ms\n-///             $(M),+      one or more comma-separated Ms\n-///             $(A B C);*  zero or more semi-separated 'A B C' seqs\n-///\n-///\n-/// MatchNonterminal\n-/// -----------------\n-///\n-///     A matcher that matches one of a few interesting named rust\n-///     nonterminals, such as types, expressions, items, or raw token-trees. A\n-///     black-box matcher on expr, for example, binds an expr to a given ident,\n-///     and that ident can re-occur as an interpolation in the RHS of a\n-///     macro-by-example rule. For example:\n-///\n-///        $foo:expr   =>     1 + $foo    // interpolate an expr\n-///        $foo:tt     =>     $foo        // interpolate a token-tree\n-///        $foo:tt     =>     bar! $foo   // only other valid interpolation\n-///                                       // is in arg position for another\n-///                                       // macro\n-///\n-/// As a final, horrifying aside, note that macro-by-example's input is\n-/// also matched by one of these matchers. Holy self-referential! It is matched\n-/// by a MatchSeq, specifically this one:\n-///\n-///                   $( $lhs:matchers => $rhs:tt );+\n-///\n-/// If you understand that, you have closed the loop and understand the whole\n-/// macro system. Congratulations.\n+// Matchers are nodes defined-by and recognized-by the main rust parser and\n+// language, but they're only ever found inside syntax-extension invocations;\n+// indeed, the only thing that ever _activates_ the rules in the rust parser\n+// for parsing a matcher is a matcher looking for the 'matchers' nonterminal\n+// itself. Matchers represent a small sub-language for pattern-matching\n+// token-trees, and are thus primarily used by the macro-defining extension\n+// itself.\n+//\n+// MatchTok\n+// --------\n+//\n+//     A matcher that matches a single token, denoted by the token itself. So\n+//     long as there's no $ involved.\n+//\n+//\n+// MatchSeq\n+// --------\n+//\n+//     A matcher that matches a sequence of sub-matchers, denoted various\n+//     possible ways:\n+//\n+//             $(M)*       zero or more Ms\n+//             $(M)+       one or more Ms\n+//             $(M),+      one or more comma-separated Ms\n+//             $(A B C);*  zero or more semi-separated 'A B C' seqs\n+//\n+//\n+// MatchNonterminal\n+// -----------------\n+//\n+//     A matcher that matches one of a few interesting named rust\n+//     nonterminals, such as types, expressions, items, or raw token-trees. A\n+//     black-box matcher on expr, for example, binds an expr to a given ident,\n+//     and that ident can re-occur as an interpolation in the RHS of a\n+//     macro-by-example rule. For example:\n+//\n+//        $foo:expr   =>     1 + $foo    // interpolate an expr\n+//        $foo:tt     =>     $foo        // interpolate a token-tree\n+//        $foo:tt     =>     bar! $foo   // only other valid interpolation\n+//                                       // is in arg position for another\n+//                                       // macro\n+//\n+// As a final, horrifying aside, note that macro-by-example's input is\n+// also matched by one of these matchers. Holy self-referential! It is matched\n+// by a MatchSeq, specifically this one:\n+//\n+//                   $( $lhs:matchers => $rhs:tt );+\n+//\n+// If you understand that, you have closed the loop and understand the whole\n+// macro system. Congratulations.\n pub type Matcher = Spanned<Matcher_>;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]"}]}