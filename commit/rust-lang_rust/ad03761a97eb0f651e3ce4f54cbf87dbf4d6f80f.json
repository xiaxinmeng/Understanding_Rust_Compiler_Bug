{"sha": "ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMDM3NjFhOTdlYjBmNjUxZTNjZTRmNTRjYmY4N2RiZjRkNmY4MGY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T10:44:11Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-22T10:47:47Z"}, "message": "Remove preconditions from libraries\n\nCloses #1805", "tree": {"sha": "03eb60b2d440ebfc6b668e359c28fe0e8e69b042", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03eb60b2d440ebfc6b668e359c28fe0e8e69b042"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "html_url": "https://github.com/rust-lang/rust/commit/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "html_url": "https://github.com/rust-lang/rust/commit/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb"}], "stats": {"total": 105, "additions": 18, "deletions": 87}, "files": [{"sha": "a66f5d87024d08b30016aa630e40b2f6a86de62e", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -40,7 +40,6 @@ fn get_sysroot_absolute_rt_lib(sess: session::session) -> fs::path {\n         + filesearch::relative_target_lib_path(\n             sess.opts.target_triple)\n         + [os::dylib_filename(\"rustrt\")];\n-    check vec::is_not_empty(path);\n     fs::connect_many(path)\n }\n \n@@ -174,7 +173,6 @@ fn get_install_prefix_rpath(cwd: fs::path, target_triple: str) -> str {\n \n     let path = [install_prefix]\n         + filesearch::relative_target_lib_path(target_triple);\n-    check vec::is_not_empty(path);\n     get_absolute(cwd, fs::connect_many(path))\n }\n "}, {"sha": "dca76bddf66d62e7546a260d4d387a4978b0253c", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -209,7 +209,6 @@ fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n     cx.current = start_current;\n     visit();\n     let cx_blocks = cx.blocks;\n-    check is_not_empty(cx_blocks);\n     cx.blocks = tail(cx_blocks);\n     let branches = if tp == func { local.exits + [cx.current] }\n                    else { local.exits };"}, {"sha": "76aea3a1e3b413ef53cc1996c944436153fa9790", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -289,7 +289,6 @@ fn map_crate(e: @env, c: @ast::crate) {\n                 alt follow_import(*e, sc, *path, vp.span) {\n                   some(imp) {\n                     let glob = {def: imp, path: vp};\n-                    check list::is_not_empty(sc);\n                     alt list::head(sc) {\n                       scope_item(i) {\n                         e.mod_map.get(i.id).glob_imports += [glob];\n@@ -585,7 +584,6 @@ fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n }\n \n fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n-    check list::is_not_empty(sc);\n     let loc_pos = alt list::head(sc) {\n       scope_block(_, _, pos) { pos }\n       _ { @mutable 0u }"}, {"sha": "c15acf64af0f3087bcaf336813fe02adfad3d834", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -278,7 +278,6 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n     while i < size {\n-        check (valid_variant_index(i, bcx, vdefs_tg, vdefs_var));\n         let r =\n             // invariant needed:\n             // how do we know it even makes sense to pass in ty_param_substs"}, {"sha": "d0370d992a8306dac207fb171143d7859c9f45f7", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -355,9 +355,10 @@ fn GEP_tup_like(bcx: block, t: ty::t, base: ValueRef, ixs: [int])\n // is meaningless, as it will be cast away.\n fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n            variant_id: ast::def_id, ty_substs: [ty::t],\n-           ix: uint) : valid_variant_index(ix, cx, enum_id, variant_id) ->\n-   result {\n+           ix: uint) -> result {\n     let variant = ty::enum_variant_with_id(cx.tcx(), enum_id, variant_id);\n+    assert ix < variant.args.len();\n+\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n \n@@ -1119,7 +1120,6 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             let j = 0u;\n             let v_id = variant.id;\n             for a: ty::arg in args {\n-                check (valid_variant_index(j, cx, tid, v_id));\n                 let rslt = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let llfldp_a = rslt.val;\n                 cx = rslt.bcx;\n@@ -4031,7 +4031,6 @@ fn trans_enum_variant(ccx: crate_ctxt, enum_id: ast::node_id,\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n     for va: ast::variant_arg in variant.node.args {\n-        check (valid_variant_index(i, bcx, t_id, v_id));\n         let rslt = GEP_enum(bcx, llblobptr, t_id, v_id, ty_param_substs, i);\n         bcx = rslt.bcx;\n         let lldestptr = rslt.val;"}, {"sha": "0559a6b02af86d077b0b8de8b6837c326c33f7f4", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -529,7 +529,6 @@ fn add_span_comment(bcx: block, sp: span, text: str) {\n fn add_comment(bcx: block, text: str) {\n     let ccx = bcx.ccx();\n     if (!ccx.sess.opts.no_asm_comments) {\n-        check str::is_not_empty(\"$\");\n         let sanitized = str::replace(text, \"$\", \"\");\n         let comment_text = \"; \" + sanitized;\n         let asm = str::as_buf(comment_text, {|c|"}, {"sha": "24af4e33b9abf3bf7c01b51d492e0fc6ba63eb14", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -835,20 +835,6 @@ fn C_shape(ccx: crate_ctxt, bytes: [u8]) -> ValueRef {\n     ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n }\n \n-\n-pure fn valid_variant_index(ix: uint, cx: block, enum_id: ast::def_id,\n-                            variant_id: ast::def_id) -> bool {\n-\n-    // Handwaving: it's ok to pretend this code is referentially\n-    // transparent, because the relevant parts of the type context don't\n-    // change. (We're not adding new variants during trans.)\n-    unchecked{\n-        let variant =\n-            ty::enum_variant_with_id(cx.tcx(), enum_id, variant_id);\n-        ix < variant.args.len()\n-    }\n-}\n-\n pure fn type_has_static_size(cx: crate_ctxt, t: ty::t) -> bool {\n     !ty::type_has_dynamic_size(cx.tcx, t)\n }"}, {"sha": "7cdb56676653c6d34ce34c755efa15748042f00f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -888,7 +888,6 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         /* Should be a predicate (pure boolean function) applied to\n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n-\n         let e = parse_expr(p);\n         hi = e.span.hi;\n         ex = ast::expr_check(ast::checked_expr, e);"}, {"sha": "3e23e09f8ea409bcabe5984475d9efacc491c1ae", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -89,7 +89,6 @@ fn relative_target_lib_path(target_triple: str) -> [fs::path] {\n fn make_target_lib_path(sysroot: fs::path,\n                         target_triple: str) -> fs::path {\n     let path = [sysroot] + relative_target_lib_path(target_triple);\n-    check vec::is_not_empty(path);\n     let path = fs::connect_many(path);\n     ret path;\n }\n@@ -112,7 +111,6 @@ fn get_sysroot(maybe_sysroot: option<fs::path>) -> fs::path {\n \n fn get_cargo_sysroot() -> result::t<fs::path, str> {\n     let path = [get_default_sysroot(), libdir(), \"cargo\"];\n-    check vec::is_not_empty(path);\n     result::ok(fs::connect_many(path))\n }\n "}, {"sha": "d81f2d45d4080512d437680152c7995474819a4d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -659,7 +659,8 @@ Returns:\n \n The original string with all occurances of `from` replaced with `to`\n */\n-fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str unsafe {\n+fn replace(s: str, from: str, to: str) -> str unsafe {\n+    assert is_not_empty(from);\n     if len_bytes(s) == 0u {\n         ret \"\";\n     } else if starts_with(s, from) {\n@@ -1922,12 +1923,10 @@ mod tests {\n     #[test]\n     fn test_replace() {\n         let a = \"a\";\n-        check (is_not_empty(a));\n         assert (replace(\"\", a, \"b\") == \"\");\n         assert (replace(\"a\", a, \"b\") == \"b\");\n         assert (replace(\"ab\", a, \"b\") == \"bb\");\n         let test = \"test\";\n-        check (is_not_empty(test));\n         assert (replace(\" test test \", test, \"toast\") == \" toast toast \");\n         assert (replace(\" test test \", test, \"\") == \"   \");\n     }\n@@ -1939,7 +1938,6 @@ mod tests {\n \n         let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n         let A = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        check is_not_empty(a);\n         assert (replace(data, a, repl) ==  A);\n     }\n \n@@ -1950,7 +1948,6 @@ mod tests {\n \n         let b = \"\u0e30\u0e40\";\n         let B = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        check is_not_empty(b);\n         assert (replace(data, b,   repl) ==  B);\n     }\n \n@@ -1961,7 +1958,6 @@ mod tests {\n \n         let c = \"\u4e2d\u534e\";\n         let C = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        check is_not_empty(c);\n         assert (replace(data, c, repl) ==  C);\n     }\n \n@@ -1971,7 +1967,6 @@ mod tests {\n         let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = \"\u0e44\u0e17\u534e\";\n-        check is_not_empty(d);\n         assert (replace(data, d, repl) == data);\n     }\n "}, {"sha": "f225840eacdf24e43742d2fc0c7b7ab3cfba0e74", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -180,7 +180,7 @@ Returns the first element of a vector\n Predicates:\n <is_not_empty> (v)\n */\n-pure fn head<T: copy>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n+pure fn head<T: copy>(v: [const T]) -> T { v[0] }\n \n /*\n Function: tail\n@@ -240,9 +240,7 @@ Returns the last element of a non-empty vector `v`\n Predicates:\n <is_not_empty> (v)\n */\n-pure fn last_total<T: copy>(v: [const T]) : is_not_empty(v) -> T {\n-    ret v[len(v) - 1u];\n-}\n+pure fn last_total<T: copy>(v: [const T]) -> T { v[len(v) - 1u] }\n \n /*\n Function: slice\n@@ -886,10 +884,10 @@ Preconditions:\n \n <same_length> (v, u)\n */\n-fn zip<T: copy, U: copy>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n+fn zip<T: copy, U: copy>(v: [T], u: [U]) -> [(T, U)] {\n     let zipped = [];\n     let sz = len(v), i = 0u;\n-    assert (sz == len(u));\n+    assert sz == len(u);\n     while i < sz { zipped += [(v[i], u[i])]; i += 1u; }\n     ret zipped;\n }\n@@ -940,7 +938,8 @@ Function: enum_chars\n \n Returns a vector containing a range of chars\n */\n-fn enum_chars(start: u8, end: u8) : ::u8::le(start, end) -> [char] {\n+fn enum_chars(start: u8, end: u8) -> [char] {\n+    assert start < end;\n     let i = start;\n     let r = [];\n     while i <= end { r += [i as char]; i += 1u as u8; }\n@@ -953,7 +952,8 @@ Function: enum_uints\n \n Returns a vector containing a range of uints\n */\n-fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n+fn enum_uints(start: uint, end: uint) -> [uint] {\n+    assert start < end;\n     let i = start;\n     let r = [];\n     while i <= end { r += [i]; i += 1u; }\n@@ -1329,18 +1329,15 @@ mod tests {\n     #[test]\n     fn test_head() {\n         let a = [11, 12];\n-        check (is_not_empty(a));\n         assert (head(a) == 11);\n     }\n \n     #[test]\n     fn test_tail() {\n         let a = [11];\n-        check (is_not_empty(a));\n         assert (tail(a) == []);\n \n         a = [11, 12];\n-        check (is_not_empty(a));\n         assert (tail(a) == [12]);\n     }\n \n@@ -1667,7 +1664,6 @@ mod tests {\n         let v1 = [1, 2, 3];\n         let v2 = [4, 5, 6];\n \n-        check (same_length(v1, v2)); // Silly, but what else can we do?\n         let z1 = zip(v1, v2);\n \n         assert ((1, 4) == z1[0]);"}, {"sha": "30abbb1e70aa91d9c0abeb100605be69d243a04f", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -107,12 +107,11 @@ Connects a vector of path segments into a single path.\n \n Inserts path separators as needed.\n */\n-fn connect_many(paths: [path]) : vec::is_not_empty(paths) -> path {\n+fn connect_many(paths: [path]) -> path {\n     ret if vec::len(paths) == 1u {\n         paths[0]\n     } else {\n         let rest = vec::slice(paths, 1u, vec::len(paths));\n-        check vec::is_not_empty(rest);\n         connect(paths[0], connect_many(rest))\n     }\n }"}, {"sha": "3c2d6988587f6a4592ca2046ad5be3152e9eb019", "filename": "src/libstd/list.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -140,11 +140,8 @@ Function: head\n \n Returns the first element of a list\n */\n-pure fn head<T: copy>(ls: list<T>) : is_not_empty(ls) -> T {\n-    alt ls {\n-        cons(hd, _) { ret hd; }\n-        nil { fail \"list empty\" }\n-    }\n+pure fn head<T: copy>(ls: list<T>) -> T {\n+    alt check ls { cons(hd, _) { hd } }\n }\n \n /*\n@@ -205,15 +202,12 @@ mod tests {\n     fn test_from_vec() {\n         let l = from_vec([0, 1, 2]);\n \n-        check is_not_empty(l);\n         assert (head(l) == 0);\n \n         let tail_l = tail(l);\n-        check is_not_empty(tail_l);\n         assert (head(tail_l) == 1);\n \n         let tail_tail_l = tail(tail_l);\n-        check is_not_empty(tail_tail_l);\n         assert (head(tail_tail_l) == 2);\n     }\n \n@@ -227,15 +221,12 @@ mod tests {\n     fn test_from_vec_mut() {\n         let l = from_vec([mutable 0, 1, 2]);\n \n-        check is_not_empty(l);\n         assert (head(l) == 0);\n \n         let tail_l = tail(l);\n-        check is_not_empty(tail_l);\n         assert (head(tail_l) == 1);\n \n         let tail_tail_l = tail(tail_l);\n-        check is_not_empty(tail_tail_l);\n         assert (head(tail_tail_l) == 2);\n     }\n "}, {"sha": "cceff6d66bba8a49ed2d28d63ebb009a5abbef81", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -252,8 +252,6 @@ mod test_qsort {\n \n         let immut_names = vec::from_mut(names);\n \n-        // Silly, but what else can we do?\n-        check (vec::same_length(expected, immut_names));\n         let pairs = vec::zip(expected, immut_names);\n         for (a, b) in pairs { #debug(\"%d %d\", a, b); assert (a == b); }\n     }"}, {"sha": "6f39ea14047025b23b1a30fbad2ba5d05e45d4ab", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=ad03761a97eb0f651e3ce4f54cbf87dbf4d6f80f", "patch": "@@ -47,7 +47,6 @@ type test_desc = {\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n fn test_main(args: [str], tests: [test_desc]) {\n-    check (vec::is_not_empty(args));\n     let opts =\n         alt parse_opts(args) {\n           either::left(o) { o }\n@@ -61,8 +60,7 @@ type test_opts = {filter: option<str>, run_ignored: bool};\n type opt_res = either::t<test_opts, str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: [str]) : vec::is_not_empty(args) -> opt_res {\n-\n+fn parse_opts(args: [str]) -> opt_res {\n     let args_ = vec::tail(args);\n     let opts = [getopts::optflag(\"ignored\")];\n     let match =\n@@ -407,7 +405,6 @@ mod tests {\n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n         let args = [\"progname\", \"filter\"];\n-        check (vec::is_not_empty(args));\n         let opts = alt parse_opts(args) { either::left(o) { o }\n           _ { fail \"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n         assert (str::eq(\"filter\", option::get(opts.filter)));\n@@ -416,7 +413,6 @@ mod tests {\n     #[test]\n     fn parse_ignored_flag() {\n         let args = [\"progname\", \"filter\", \"--ignored\"];\n-        check (vec::is_not_empty(args));\n         let opts = alt parse_opts(args) { either::left(o) { o }\n           _ { fail \"Malformed arg in parse_ignored_flag\"; } };\n         assert (opts.run_ignored);\n@@ -469,12 +465,10 @@ mod tests {\n          \"test::ignored_tests_result_in_ignored\", \"test::parse_ignored_flag\",\n          \"test::sort_tests\"];\n \n-    check (vec::same_length(expected, filtered));\n     let pairs = vec::zip(expected, filtered);\n \n-\n     for (a, b) in pairs { assert (a == b.name); }\n-    }\n+}\n }\n \n "}, {"sha": "dac5b6d7e8fc0827e6e7e1fc5dee3002a010ce8a", "filename": "src/test/compile-fail/zip-missing-check.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57b6775c3a2d9dbe7fae69c189b8ae9032315cb/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fzip-missing-check.rs?ref=e57b6775c3a2d9dbe7fae69c189b8ae9032315cb", "patch": "@@ -1,17 +0,0 @@\n-// error-pattern:Unsatisfied precondition constraint (for example, same_length\n-use std;\n-import uint;\n-import u8;\n-import vec::*;\n-\n-fn main() {\n-    let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;\n-    // Silly, but necessary\n-    check (u8::le(a, j));\n-    check (uint::le(k, l));\n-    let chars = enum_chars(a, j);\n-    let ints = enum_uints(k, l);\n-\n-    let ps = zip(chars, ints);\n-    fail \"the impossible happened\";\n-}"}]}