{"sha": "87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "node_id": "C_kwDOAAsO6NoAKDg3ZWYzN2RiZDdkMjZhNDBiYjI5OWFhMTUxYjVlZmZkZmNjMWNlYzk", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-10-14T21:16:25Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2023-02-01T20:50:34Z"}, "message": "rustc_parse: migrate more to diagnostic structs", "tree": {"sha": "b14aff290b47d456e664934a343aa4a75abb83b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b14aff290b47d456e664934a343aa4a75abb83b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "html_url": "https://github.com/rust-lang/rust/commit/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac9c66bff549242b2b4784ff044ec6a4434c1b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac9c66bff549242b2b4784ff044ec6a4434c1b59", "html_url": "https://github.com/rust-lang/rust/commit/ac9c66bff549242b2b4784ff044ec6a4434c1b59"}], "stats": {"total": 1448, "additions": 967, "deletions": 481}, "files": [{"sha": "5e138a94758d584aa312804c32c2ce17fd5e2c12", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -390,3 +390,152 @@ parse_where_clause_before_tuple_struct_body = where clauses are not allowed befo\n     .name_label = while parsing this tuple struct\n     .body_label = the struct body\n     .suggestion = move the body before the where clause\n+\n+parse_async_fn_in_2015 = `async fn` is not permitted in Rust 2015\n+    .label = to use `async fn`, switch to Rust 2018 or later\n+\n+parse_async_block_in_2015 = `async` blocks are only allowed in Rust 2018 or later\n+\n+parse_self_argument_pointer = cannot pass `self` by raw pointer\n+    .label = cannot pass `self` by raw pointer\n+\n+parse_visibility_not_followed_by_item = visibility `{$vis}` is not followed by an item\n+    .label = the visibility\n+    .help = you likely meant to define an item, e.g., `{$vis} fn foo() {\"{}\"}`\n+\n+parse_default_not_followed_by_item = `default` is not followed by an item\n+    .label = the `default` qualifier\n+    .note = only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n+\n+parse_missing_struct_for_struct_definition = missing `struct` for struct definition\n+    .suggestion = add `struct` here to parse `{$ident}` as a public struct\n+\n+parse_missing_fn_for_function_definition = missing `fn` for function definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public function\n+\n+parse_missing_fn_for_method_definition = missing `fn` for method definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public method\n+\n+parse_ambiguous_missing_keyword_for_item_definition = missing `fn` or `struct` for function or struct definition\n+    .suggestion = if you meant to call a macro, try\n+    .help = if you meant to call a macro, remove the `pub` and add a trailing `!` after the identifier\n+\n+parse_missing_trait_in_trait_impl = missing trait in a trait impl\n+    .suggestion_add_trait = add a trait here\n+    .suggestion_remove_for = for an inherent impl, drop this `for`\n+\n+parse_missing_for_in_trait_impl = missing `for` in a trait impl\n+    .suggestion = add `for` here\n+\n+parse_expected_trait_in_trait_impl_found_type = expected a trait, found type\n+\n+parse_non_item_in_item_list = non-item in item list\n+    .suggestion_use_const_not_let = consider using `const` instead of `let` for associated const\n+    .label_list_start = item list starts here\n+    .label_non_item = non-item starts here\n+    .label_list_end = item list ends here\n+    .suggestion_remove_semicolon = consider removing this semicolon\n+\n+parse_bounds_not_allowed_on_trait_aliases = bounds are not allowed on trait aliases\n+\n+parse_trait_alias_cannot_be_auto = trait aliases cannot be `auto`\n+parse_trait_alias_cannot_be_unsafe = trait aliases cannot be `unsafe`\n+\n+parse_associated_static_item_not_allowed = associated `static` items are not allowed\n+\n+parse_extern_crate_name_with_dashes = crate name using dashes are not valid in `extern crate` statements\n+    .label = dash-separated idents are not valid\n+    .suggestion = if the original crate name uses dashes you need to use underscores in the code\n+\n+parse_extern_item_cannot_be_const = extern items cannot be `const`\n+    .suggestion = try using a static value\n+    .note = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+parse_const_global_cannot_be_mutable = const globals cannot be mutable\n+    .label = cannot be mutable\n+    .suggestion = you might want to declare a static instead\n+\n+parse_missing_const_type = missing type for `{$kind}` item\n+    .suggestion = provide a type for the item\n+\n+parse_enum_struct_mutually_exclusive = `enum` and `struct` are mutually exclusive\n+    .suggestion = replace `enum struct` with\n+\n+parse_unexpected_token_after_struct_name = expected `where`, `{\"{\"}`, `(`, or `;` after struct name\n+parse_unexpected_token_after_struct_name_found_reserved_identifier = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved identifier `{$token}`\n+parse_unexpected_token_after_struct_name_found_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found keyword `{$token}`\n+parse_unexpected_token_after_struct_name_found_reserved_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved keyword `{$token}`\n+parse_unexpected_token_after_struct_name_found_doc_comment = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found doc comment `{$token}`\n+parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found `{$token}`\n+\n+parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n+    .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n+\n+parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n+    .label = previous `where` clause starts here\n+    .suggestion = consider joining the two `where` clauses into one\n+\n+parse_nonterminal_expected_item_keyword = expected an item keyword\n+parse_nonterminal_expected_statement = expected a statement\n+parse_nonterminal_expected_ident = expected ident, found `{$token}`\n+parse_nonterminal_expected_lifetime = expected a lifetime, found `{$token}`\n+\n+parse_or_pattern_not_allowed_in_let_binding = top-level or-patterns are not allowed in `let` bindings\n+parse_or_pattern_not_allowed_in_fn_parameters = top-level or-patterns are not allowed in function parameters\n+parse_sugg_remove_leading_vert_in_pattern = remove the `|`\n+parse_sugg_wrap_pattern_in_parens = wrap the pattern in parentheses\n+\n+parse_note_pattern_alternatives_use_single_vert = alternatives in or-patterns are separated with `|`, not `||`\n+\n+parse_unexpected_vert_vert_before_function_parameter = unexpected `||` before function parameter\n+    .suggestion = remove the `||`\n+\n+parse_label_while_parsing_or_pattern_here = while parsing this or-pattern starting here\n+\n+parse_unexpected_vert_vert_in_pattern = unexpected token `||` in pattern\n+    .suggestion = use a single `|` to separate multiple alternative patterns\n+\n+parse_trailing_vert_not_allowed = a trailing `|` is not allowed in an or-pattern\n+    .suggestion = remove the `{$token}`\n+\n+parse_dotdotdot_rest_pattern = unexpected `...`\n+    .label = not a valid pattern\n+    .suggestion = for a rest pattern, use `..` instead of `...`\n+\n+parse_pattern_on_wrong_side_of_at = pattern on wrong side of `@`\n+    .label_pattern = pattern on the left, should be on the right\n+    .label_binding = binding on the right, should be on the left\n+    .suggestion = switch the order\n+\n+parse_expected_binding_left_of_at = left-hand side of `@` must be a binding\n+    .label_lhs = interpreted as a pattern, not a binding\n+    .label_rhs = also a pattern\n+    .note = bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+\n+parse_ambiguous_range_pattern = the range pattern here has ambiguous interpretation\n+    .suggestion = add parentheses to clarify the precedence\n+\n+parse_unexpected_lifetime_in_pattern = unexpected lifetime `{$symbol}` in pattern\n+    .suggestion = remove the lifetime\n+\n+parse_ref_mut_order_incorrect = the order of `mut` and `ref` is incorrect\n+    .suggestion = try switching the order\n+\n+parse_mut_on_nested_ident_pattern = `mut` must be attached to each individual binding\n+    .suggestion = add `mut` to each binding\n+parse_mut_on_non_ident_pattern = `mut` must be followed by a named binding\n+    .suggestion = remove the `mut` prefix\n+parse_note_mut_pattern_usage = `mut` may be followed by `variable` and `variable @ pattern`\n+\n+parse_repeated_mut_in_pattern = `mut` on a binding may not be repeated\n+    .suggestion = remove the additional `mut`s\n+\n+parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` are not allowed\n+    .suggestion = use `..=` instead\n+\n+parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n+\n+parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `...`\n+    .suggestion = to omit remaining fields, use one fewer `.`\n+\n+parse_expected_comma_after_pattern_field = expected `,`"}, {"sha": "4dfa25eccd5d2274f30e346af55339afc5696d82", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 517, "deletions": 2, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -1,6 +1,8 @@\n use rustc_ast::token::Token;\n-use rustc_ast::Path;\n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, EmissionGuarantee, IntoDiagnostic};\n+use rustc_ast::{Path, Visibility};\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, EmissionGuarantee, HelpUseLatestEdition, IntoDiagnostic,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::Ident;\n@@ -1330,3 +1332,516 @@ pub(crate) struct WhereClauseBeforeTupleStructBodySugg {\n     #[suggestion_part(code = \"\")]\n     pub right: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_async_fn_in_2015, code = \"E0670\")]\n+pub(crate) struct AsyncFnIn2015 {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub help: HelpUseLatestEdition,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(parse_async_block_in_2015)]\n+pub(crate) struct AsyncBlockIn2015 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_self_argument_pointer)]\n+pub(crate) struct SelfArgumentPointer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_visibility_not_followed_by_item)]\n+#[help]\n+pub(crate) struct VisibilityNotFollowedByItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub vis: Visibility,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_default_not_followed_by_item)]\n+#[note]\n+pub(crate) struct DefaultNotFollowedByItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum MissingKeywordForItemDefinition {\n+    #[diag(parse_missing_struct_for_struct_definition)]\n+    Struct {\n+        #[primary_span]\n+        #[suggestion(style = \"short\", applicability = \"maybe-incorrect\", code = \" struct \")]\n+        span: Span,\n+        ident: Ident,\n+    },\n+    #[diag(parse_missing_fn_for_function_definition)]\n+    Function {\n+        #[primary_span]\n+        #[suggestion(style = \"short\", applicability = \"maybe-incorrect\", code = \" fn \")]\n+        span: Span,\n+        ident: Ident,\n+    },\n+    #[diag(parse_missing_fn_for_method_definition)]\n+    Method {\n+        #[primary_span]\n+        #[suggestion(style = \"short\", applicability = \"maybe-incorrect\", code = \" fn \")]\n+        span: Span,\n+        ident: Ident,\n+    },\n+    #[diag(parse_ambiguous_missing_keyword_for_item_definition)]\n+    Ambiguous {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiag: Option<AmbiguousMissingKwForItemSub>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum AmbiguousMissingKwForItemSub {\n+    #[suggestion(suggestion, applicability = \"maybe-incorrect\", code = \"{snippet}!\")]\n+    SuggestMacro {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[help(help)]\n+    HelpMacro,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_trait_in_trait_impl)]\n+pub(crate) struct MissingTraitInTraitImpl {\n+    #[primary_span]\n+    #[suggestion(suggestion_add_trait, code = \" Trait \", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+    #[suggestion(suggestion_remove_for, code = \"\", applicability = \"maybe-incorrect\")]\n+    pub for_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_for_in_trait_impl)]\n+pub(crate) struct MissingForInTraitImpl {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \" for \", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_trait_in_trait_impl_found_type)]\n+pub(crate) struct ExpectedTraitInTraitImplFoundType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_non_item_in_item_list)]\n+pub(crate) struct NonItemInItemList {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: NonItemInItemListSub,\n+    #[suggestion(suggestion_remove_semicolon, code = \"\", applicability = \"maybe-incorrect\")]\n+    pub remove_semicolon: Option<Span>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum NonItemInItemListSub {\n+    #[suggestion(\n+        suggestion_use_const_not_let,\n+        code = \"const\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Let {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    Other {\n+        #[label(label_list_start)]\n+        list_start: Span,\n+        #[label(label_non_item)]\n+        non_item: Span,\n+        #[label(label_list_end)]\n+        list_end: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bounds_not_allowed_on_trait_aliases)]\n+pub(crate) struct BoundsNotAllowedOnTraitAliases {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_trait_alias_cannot_be_auto)]\n+pub(crate) struct TraitAliasCannotBeAuto {\n+    #[primary_span]\n+    #[label(parse_trait_alias_cannot_be_auto)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_trait_alias_cannot_be_unsafe)]\n+pub(crate) struct TraitAliasCannotBeUnsafe {\n+    #[primary_span]\n+    #[label(parse_trait_alias_cannot_be_unsafe)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_associated_static_item_not_allowed)]\n+pub(crate) struct AssociatedStaticItemNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_extern_crate_name_with_dashes)]\n+pub(crate) struct ExternCrateNameWithDashes {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: ExternCrateNameWithDashesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ExternCrateNameWithDashesSugg {\n+    #[suggestion_part(code = \"_\")]\n+    pub dashes: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_extern_item_cannot_be_const)]\n+#[note]\n+pub(crate) struct ExternItemCannotBeConst {\n+    #[primary_span]\n+    pub ident_span: Span,\n+    #[suggestion(code = \"static \", applicability = \"machine-applicable\")]\n+    pub const_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_const_global_cannot_be_mutable)]\n+pub(crate) struct ConstGlobalCannotBeMutable {\n+    #[primary_span]\n+    #[label]\n+    pub ident_span: Span,\n+    #[suggestion(code = \"static\", applicability = \"maybe-incorrect\")]\n+    pub const_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_const_type)]\n+pub(crate) struct MissingConstType {\n+    #[primary_span]\n+    #[suggestion(code = \"{colon} <type>\", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+\n+    pub kind: &'static str,\n+    pub colon: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_enum_struct_mutually_exclusive)]\n+pub(crate) struct EnumStructMutuallyExclusive {\n+    #[primary_span]\n+    #[suggestion(code = \"enum\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum UnexpectedTokenAfterStructName {\n+    #[diag(parse_unexpected_token_after_struct_name_found_reserved_identifier)]\n+    ReservedIdentifier {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_keyword)]\n+    Keyword {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_reserved_keyword)]\n+    ReservedKeyword {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_doc_comment)]\n+    DocComment {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_other)]\n+    Other {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+}\n+\n+impl UnexpectedTokenAfterStructName {\n+    pub fn new(span: Span, token: Token) -> Self {\n+        match TokenDescription::from_token(&token) {\n+            Some(TokenDescription::ReservedIdentifier) => Self::ReservedIdentifier { span, token },\n+            Some(TokenDescription::Keyword) => Self::Keyword { span, token },\n+            Some(TokenDescription::ReservedKeyword) => Self::ReservedKeyword { span, token },\n+            Some(TokenDescription::DocComment) => Self::DocComment { span, token },\n+            None => Self::Other { span, token },\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_self_in_generic_parameters)]\n+#[note]\n+pub(crate) struct UnexpectedSelfInGenericParameters {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_multiple_where_clauses)]\n+pub(crate) struct MultipleWhereClauses {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub previous: Span,\n+    #[suggestion(style = \"verbose\", code = \",\", applicability = \"maybe-incorrect\")]\n+    pub between: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum UnexpectedNonterminal {\n+    #[diag(parse_nonterminal_expected_item_keyword)]\n+    Item(#[primary_span] Span),\n+    #[diag(parse_nonterminal_expected_statement)]\n+    Statement(#[primary_span] Span),\n+    #[diag(parse_nonterminal_expected_ident)]\n+    Ident {\n+        #[primary_span]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_nonterminal_expected_lifetime)]\n+    Lifetime {\n+        #[primary_span]\n+        span: Span,\n+        token: Token,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum TopLevelOrPatternNotAllowed {\n+    #[diag(parse_or_pattern_not_allowed_in_let_binding)]\n+    LetBinding {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        sub: Option<TopLevelOrPatternNotAllowedSugg>,\n+    },\n+    #[diag(parse_or_pattern_not_allowed_in_fn_parameters)]\n+    FunctionParameter {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        sub: Option<TopLevelOrPatternNotAllowedSugg>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum TopLevelOrPatternNotAllowedSugg {\n+    #[suggestion(\n+        parse_sugg_remove_leading_vert_in_pattern,\n+        code = \"{pat}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    RemoveLeadingVert {\n+        #[primary_span]\n+        span: Span,\n+        pat: String,\n+    },\n+    #[suggestion(\n+        parse_sugg_wrap_pattern_in_parens,\n+        code = \"({pat})\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    WrapInParens {\n+        #[primary_span]\n+        span: Span,\n+        pat: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_vert_vert_before_function_parameter)]\n+#[note(parse_note_pattern_alternatives_use_single_vert)]\n+pub(crate) struct UnexpectedVertVertBeforeFunctionParam {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_vert_vert_in_pattern)]\n+pub(crate) struct UnexpectedVertVertInPattern {\n+    #[primary_span]\n+    #[suggestion(code = \"|\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label(parse_label_while_parsing_or_pattern_here)]\n+    pub start: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_trailing_vert_not_allowed)]\n+pub(crate) struct TrailingVertNotAllowed {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label(parse_label_while_parsing_or_pattern_here)]\n+    pub start: Option<Span>,\n+    pub token: Token,\n+    #[note(parse_note_pattern_alternatives_use_single_vert)]\n+    pub note_double_vert: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dotdotdot_rest_pattern)]\n+pub(crate) struct DotDotDotRestPattern {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"..\", applicability = \"machine-applicable\")]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_pattern_on_wrong_side_of_at)]\n+pub(crate) struct PatternOnWrongSideOfAt {\n+    #[primary_span]\n+    #[suggestion(code = \"{whole_pat}\", applicability = \"machine-applicable\")]\n+    pub whole_span: Span,\n+    pub whole_pat: String,\n+    #[label(label_pattern)]\n+    pub pattern: Span,\n+    #[label(label_binding)]\n+    pub binding: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_binding_left_of_at)]\n+#[note]\n+pub(crate) struct ExpectedBindingLeftOfAt {\n+    #[primary_span]\n+    pub whole_span: Span,\n+    #[label(label_lhs)]\n+    pub lhs: Span,\n+    #[label(label_rhs)]\n+    pub rhs: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_ambiguous_range_pattern)]\n+pub(crate) struct AmbiguousRangePattern {\n+    #[primary_span]\n+    #[suggestion(code = \"({pat})\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub pat: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_lifetime_in_pattern)]\n+pub(crate) struct UnexpectedLifetimeInPattern {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub symbol: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_ref_mut_order_incorrect)]\n+pub(crate) struct RefMutOrderIncorrect {\n+    #[primary_span]\n+    #[suggestion(code = \"ref mut\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum InvalidMutInPattern {\n+    #[diag(parse_mut_on_nested_ident_pattern)]\n+    #[note(parse_note_mut_pattern_usage)]\n+    NestedIdent {\n+        #[primary_span]\n+        #[suggestion(code = \"{pat}\", applicability = \"machine-applicable\")]\n+        span: Span,\n+        pat: String,\n+    },\n+    #[diag(parse_mut_on_non_ident_pattern)]\n+    #[note(parse_note_mut_pattern_usage)]\n+    NonIdent {\n+        #[primary_span]\n+        #[suggestion(code = \"{pat}\", applicability = \"machine-applicable\")]\n+        span: Span,\n+        pat: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_repeated_mut_in_pattern)]\n+pub(crate) struct RepeatedMutInPattern {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dot_dot_dot_range_to_pattern_not_allowed)]\n+pub(crate) struct DotDotDotRangeToPatternNotAllowed {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"..=\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_enum_pattern_instead_of_identifier)]\n+pub(crate) struct EnumPatternInsteadOfIdentifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dot_dot_dot_for_remaining_fields)]\n+pub(crate) struct DotDotDotForRemainingFields {\n+    #[primary_span]\n+    #[suggestion(code = \"..\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_comma_after_pattern_field)]\n+pub(crate) struct ExpectedCommaAfterPatternField {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "5f112b3cefc20e71399a7d17ec5efd4436dbf37f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -6,19 +6,19 @@ use super::{\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n use crate::errors::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncMoveOrderIncorrect,\n-    BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n-    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n-    ExpectedElseBlock, ExpectedEqForLetExpr, ExpectedExpressionFoundLet,\n-    FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n-    IfExpressionLetSomeSub, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n-    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n-    InvalidComparisonOperatorSub, InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex,\n-    InvalidLogicalOperator, InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported,\n-    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n-    MalformedLoopLabel, MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg,\n-    MissingCommaAfterMatchArm, MissingDotDot, MissingInInForLoop, MissingInInForLoopSub,\n-    MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n+    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncBlockIn2015,\n+    AsyncMoveOrderIncorrect, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n+    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n+    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n+    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n+    FoundExprWouldBeStmt, IfExpressionLetSomeSub, IfExpressionMissingCondition,\n+    IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment,\n+    InvalidComparisonOperator, InvalidComparisonOperatorSub, InvalidInterpolatedExpression,\n+    InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n+    LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator, LifetimeInBorrowExpression,\n+    MacroInvocationWithQualifiedPath, MalformedLoopLabel, MatchArmBodyWithoutBraces,\n+    MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm, MissingDotDot, MissingInInForLoop,\n+    MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n     NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n     RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n     StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n@@ -2926,7 +2926,7 @@ impl<'a> Parser<'a> {\n \n         let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n-            e.span_label(span, \"`async` blocks are only allowed in Rust 2018 or later\");\n+            AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n             HelpUseLatestEdition::new().add_to_diagnostic(e);\n         };\n "}, {"sha": "585dfc518b325c1735f89e1dec201179d0840d25", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -1,4 +1,7 @@\n-use crate::errors::{WhereClauseBeforeTupleStructBody, WhereClauseBeforeTupleStructBodySugg};\n+use crate::errors::{\n+    MultipleWhereClauses, UnexpectedSelfInGenericParameters, WhereClauseBeforeTupleStructBody,\n+    WhereClauseBeforeTupleStructBodySugg,\n+};\n \n use super::{ForceCollect, Parser, TrailingToken};\n \n@@ -127,12 +130,9 @@ impl<'a> Parser<'a> {\n                     if this.eat_keyword_noexpect(kw::SelfUpper) {\n                         // `Self` as a generic param is invalid. Here we emit the diagnostic and continue parsing\n                         // as if `Self` never existed.\n-                        this.struct_span_err(\n-                            this.prev_token.span,\n-                            \"unexpected keyword `Self` in generic parameters\",\n-                        )\n-                        .note(\"you cannot use `Self` as a generic parameter because it is reserved for associated items\")\n-                        .emit();\n+                        this.sess.emit_err(UnexpectedSelfInGenericParameters {\n+                            span: this.prev_token.span,\n+                        });\n \n                         this.eat(&token::Comma);\n                     }\n@@ -329,16 +329,11 @@ impl<'a> Parser<'a> {\n             let ate_comma = self.eat(&token::Comma);\n \n             if self.eat_keyword_noexpect(kw::Where) {\n-                let msg = \"cannot define duplicate `where` clauses on an item\";\n-                let mut err = self.struct_span_err(self.token.span, msg);\n-                err.span_label(pred_lo, \"previous `where` clause starts here\");\n-                err.span_suggestion_verbose(\n-                    prev_token.shrink_to_hi().to(self.prev_token.span),\n-                    \"consider joining the two `where` clauses into one\",\n-                    \",\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n+                self.sess.emit_err(MultipleWhereClauses {\n+                    span: self.token.span,\n+                    previous: pred_lo,\n+                    between: prev_token.shrink_to_hi().to(self.prev_token.span),\n+                });\n             } else if !ate_comma {\n                 break;\n             }"}, {"sha": "5d6202509a13e084515bb8072ecc862ac9cc4c84", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 153, "deletions": 260, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -1,4 +1,13 @@\n-use crate::errors::{DocCommentDoesNotDocumentAnything, UseEmptyBlockNotSemi};\n+use crate::errors::{\n+    AmbiguousMissingKwForItemSub, AssociatedStaticItemNotAllowed, AsyncFnIn2015,\n+    BoundsNotAllowedOnTraitAliases, ConstGlobalCannotBeMutable, ConstLetMutuallyExclusive,\n+    DefaultNotFollowedByItem, DocCommentDoesNotDocumentAnything, EnumStructMutuallyExclusive,\n+    ExpectedTraitInTraitImplFoundType, ExternCrateNameWithDashes, ExternCrateNameWithDashesSugg,\n+    ExternItemCannotBeConst, MissingConstType, MissingForInTraitImpl,\n+    MissingKeywordForItemDefinition, MissingTraitInTraitImpl, NonItemInItemList,\n+    NonItemInItemListSub, SelfArgumentPointer, TraitAliasCannotBeAuto, TraitAliasCannotBeUnsafe,\n+    UnexpectedTokenAfterStructName, UseEmptyBlockNotSemi, VisibilityNotFollowedByItem,\n+};\n \n use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n@@ -17,8 +26,8 @@ use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, Visibility\n use rustc_ast::{MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{\n-    struct_span_err, AddToDiagnostic, Applicability, HelpUseLatestEdition, IntoDiagnostic, PResult,\n-    StashKey,\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, HelpUseLatestEdition,\n+    IntoDiagnostic, PResult, StashKey,\n };\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::lev_distance;\n@@ -167,35 +176,18 @@ impl<'a> Parser<'a> {\n         }\n \n         // At this point, we have failed to parse an item.\n-        self.error_on_unmatched_vis(&vis);\n-        self.error_on_unmatched_defaultness(def);\n-        if !attrs_allowed {\n-            self.recover_attrs_no_item(&attrs)?;\n+        if !matches!(vis.kind, VisibilityKind::Inherited) {\n+            self.sess.emit_err(VisibilityNotFollowedByItem { span: vis.span, vis });\n         }\n-        Ok(None)\n-    }\n \n-    /// Error in-case a non-inherited visibility was parsed but no item followed.\n-    fn error_on_unmatched_vis(&self, vis: &Visibility) {\n-        if let VisibilityKind::Inherited = vis.kind {\n-            return;\n+        if let Defaultness::Default(span) = def {\n+            self.sess.emit_err(DefaultNotFollowedByItem { span });\n         }\n-        let vs = pprust::vis_to_string(&vis);\n-        let vs = vs.trim_end();\n-        self.struct_span_err(vis.span, &format!(\"visibility `{vs}` is not followed by an item\"))\n-            .span_label(vis.span, \"the visibility\")\n-            .help(&format!(\"you likely meant to define an item, e.g., `{vs} fn foo() {{}}`\"))\n-            .emit();\n-    }\n \n-    /// Error in-case a `default` was parsed but no item followed.\n-    fn error_on_unmatched_defaultness(&self, def: Defaultness) {\n-        if let Defaultness::Default(sp) = def {\n-            self.struct_span_err(sp, \"`default` is not followed by an item\")\n-                .span_label(sp, \"the `default` qualifier\")\n-                .note(\"only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\")\n-                .emit();\n+        if !attrs_allowed {\n+            self.recover_attrs_no_item(&attrs)?;\n         }\n+        Ok(None)\n     }\n \n     /// Error in-case `default` was parsed in an in-appropriate context.\n@@ -388,86 +380,72 @@ impl<'a> Parser<'a> {\n         let sp = self.prev_token.span.between(self.token.span);\n         let full_sp = self.prev_token.span.to(self.token.span);\n         let ident_sp = self.token.span;\n-        if self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Brace)) {\n+\n+        let ident = if self.look_ahead(1, |t| {\n+            [\n+                token::Lt,\n+                token::OpenDelim(Delimiter::Brace),\n+                token::OpenDelim(Delimiter::Parenthesis),\n+            ]\n+            .contains(&t.kind)\n+        }) {\n+            self.parse_ident().unwrap()\n+        } else {\n+            return Ok(());\n+        };\n+\n+        let mut found_generics = false;\n+        if self.check(&token::Lt) {\n+            found_generics = true;\n+            self.eat_to_tokens(&[&token::Gt]);\n+            self.bump(); // `>`\n+        }\n+\n+        let err = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n-            let ident = self.parse_ident().unwrap();\n-            let msg = format!(\"add `struct` here to parse `{ident}` as a public struct\");\n-            let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n-            err.span_suggestion_short(\n-                sp,\n-                &msg,\n-                \" struct \",\n-                Applicability::MaybeIncorrect, // speculative\n-            );\n-            Err(err)\n-        } else if self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Parenthesis)) {\n-            let ident = self.parse_ident().unwrap();\n+            Some(MissingKeywordForItemDefinition::Struct { span: sp, ident })\n+        } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n+            // possible public function or tuple struct definition where `fn`/`struct` was\n+            // forgotten\n             self.bump(); // `(`\n-            let kw_name = self.recover_first_param();\n+            let is_method = self.recover_self_param();\n+\n             self.consume_block(Delimiter::Parenthesis, ConsumeClosingDelim::Yes);\n-            let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+\n+            let err = if self.check(&token::RArrow)\n+                || self.check(&token::OpenDelim(Delimiter::Brace))\n+            {\n                 self.eat_to_tokens(&[&token::OpenDelim(Delimiter::Brace)]);\n                 self.bump(); // `{`\n-                (\"fn\", kw_name, false)\n-            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-                self.bump(); // `{`\n-                (\"fn\", kw_name, false)\n+                self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n+                if is_method {\n+                    MissingKeywordForItemDefinition::Method { span: sp, ident }\n+                } else {\n+                    MissingKeywordForItemDefinition::Function { span: sp, ident }\n+                }\n             } else if self.check(&token::Semi) {\n-                let kw = \"struct\";\n-                (kw, kw, false)\n+                MissingKeywordForItemDefinition::Struct { span: sp, ident }\n             } else {\n-                (\"fn` or `struct\", \"function or struct\", true)\n+                MissingKeywordForItemDefinition::Ambiguous {\n+                    span: sp,\n+                    subdiag: if found_generics {\n+                        None\n+                    } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                        Some(AmbiguousMissingKwForItemSub::SuggestMacro { span: full_sp, snippet })\n+                    } else {\n+                        Some(AmbiguousMissingKwForItemSub::HelpMacro)\n+                    },\n+                }\n             };\n+            Some(err)\n+        } else if found_generics {\n+            Some(MissingKeywordForItemDefinition::Ambiguous { span: sp, subdiag: None })\n+        } else {\n+            None\n+        };\n \n-            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n-            let mut err = self.struct_span_err(sp, &msg);\n-            if !ambiguous {\n-                self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n-                let suggestion =\n-                    format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\");\n-                err.span_suggestion_short(\n-                    sp,\n-                    &suggestion,\n-                    format!(\" {kw} \"),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                err.span_suggestion(\n-                    full_sp,\n-                    \"if you meant to call a macro, try\",\n-                    format!(\"{}!\", snippet),\n-                    // this is the `ambiguous` conditional branch\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.help(\n-                    \"if you meant to call a macro, remove the `pub` \\\n-                              and add a trailing `!` after the identifier\",\n-                );\n-            }\n-            Err(err)\n-        } else if self.look_ahead(1, |t| *t == token::Lt) {\n-            let ident = self.parse_ident().unwrap();\n-            self.eat_to_tokens(&[&token::Gt]);\n-            self.bump(); // `>`\n-            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(Delimiter::Parenthesis)) {\n-                (\"fn\", self.recover_first_param(), false)\n-            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-                (\"struct\", \"struct\", false)\n-            } else {\n-                (\"fn` or `struct\", \"function or struct\", true)\n-            };\n-            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n-            let mut err = self.struct_span_err(sp, &msg);\n-            if !ambiguous {\n-                err.span_suggestion_short(\n-                    sp,\n-                    &format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\"),\n-                    format!(\" {} \", kw),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            Err(err)\n+        if let Some(err) = err {\n+            Err(err.into_diagnostic(&self.sess.span_diagnostic))\n         } else {\n             Ok(())\n         }\n@@ -516,16 +494,13 @@ impl<'a> Parser<'a> {\n         let mut err = self.struct_span_err(end.span, msg);\n         if end.is_doc_comment() {\n             err.span_label(end.span, \"this doc comment doesn't document anything\");\n-        }\n-        if end.meta_kind().is_some() {\n-            if self.token.kind == TokenKind::Semi {\n-                err.span_suggestion_verbose(\n-                    self.token.span,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n+        } else if self.token.kind == TokenKind::Semi {\n+            err.span_suggestion_verbose(\n+                self.token.span,\n+                \"consider removing this semicolon\",\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            );\n         }\n         if let [.., penultimate, _] = attrs {\n             err.span_label(start.span.to(penultimate.span), \"other attributes here\");\n@@ -592,20 +567,9 @@ impl<'a> Parser<'a> {\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n             let span = self.prev_token.span.between(self.token.span);\n-            self.struct_span_err(span, \"missing trait in a trait impl\")\n-                .span_suggestion(\n-                    span,\n-                    \"add a trait here\",\n-                    \" Trait \",\n-                    Applicability::HasPlaceholders,\n-                )\n-                .span_suggestion(\n-                    span.to(self.token.span),\n-                    \"for an inherent impl, drop this `for`\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess\n+                .emit_err(MissingTraitInTraitImpl { span, for_span: span.to(self.token.span) });\n+\n             P(Ty {\n                 kind: TyKind::Path(None, err_path(span)),\n                 span,\n@@ -638,22 +602,16 @@ impl<'a> Parser<'a> {\n             Some(ty_second) => {\n                 // impl Trait for Type\n                 if !has_for {\n-                    self.struct_span_err(missing_for_span, \"missing `for` in a trait impl\")\n-                        .span_suggestion_short(\n-                            missing_for_span,\n-                            \"add `for` here\",\n-                            \" for \",\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(MissingForInTraitImpl { span: missing_for_span });\n                 }\n \n                 let ty_first = ty_first.into_inner();\n                 let path = match ty_first.kind {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n-                        self.struct_span_err(ty_first.span, \"expected a trait, found type\").emit();\n+                        self.sess\n+                            .emit_err(ExpectedTraitInTraitImplFoundType { span: ty_first.span });\n                         err_path(ty_first.span)\n                     }\n                 };\n@@ -745,29 +703,22 @@ impl<'a> Parser<'a> {\n                     let non_item_span = self.token.span;\n                     let is_let = self.token.is_keyword(kw::Let);\n \n-                    let mut err = self.struct_span_err(non_item_span, \"non-item in item list\");\n                     self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n-                    if is_let {\n-                        err.span_suggestion(\n-                            non_item_span,\n-                            \"consider using `const` instead of `let` for associated const\",\n-                            \"const\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_label(open_brace_span, \"item list starts here\")\n-                            .span_label(non_item_span, \"non-item starts here\")\n-                            .span_label(self.prev_token.span, \"item list ends here\");\n-                    }\n-                    if is_unnecessary_semicolon {\n-                        err.span_suggestion(\n-                            semicolon_span,\n-                            \"consider removing this semicolon\",\n-                            \"\",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    err.emit();\n+\n+                    self.sess.emit_err(NonItemInItemList {\n+                        span: non_item_span,\n+                        sub: if is_let {\n+                            NonItemInItemListSub::Let { span: non_item_span }\n+                        } else {\n+                            NonItemInItemListSub::Other {\n+                                list_start: open_brace_span,\n+                                non_item: non_item_span,\n+                                list_end: self.prev_token.span,\n+                            }\n+                        },\n+                        remove_semicolon: is_unnecessary_semicolon.then_some(semicolon_span),\n+                    });\n+\n                     break;\n                 }\n                 Ok(Some(item)) => items.extend(item),\n@@ -787,6 +738,7 @@ impl<'a> Parser<'a> {\n     fn recover_doc_comment_before_brace(&mut self) -> bool {\n         if let token::DocComment(..) = self.token.kind {\n             if self.look_ahead(1, |tok| tok == &token::CloseDelim(Delimiter::Brace)) {\n+                // FIXME: merge with `DocCommentDoesNotDocumentAnything` (E0585)\n                 struct_span_err!(\n                     self.diagnostic(),\n                     self.token.span,\n@@ -853,7 +805,7 @@ impl<'a> Parser<'a> {\n             // It's a trait alias.\n             if had_colon {\n                 let span = span_at_colon.to(span_before_eq);\n-                self.struct_span_err(span, \"bounds are not allowed on trait aliases\").emit();\n+                self.sess.emit_err(BoundsNotAllowedOnTraitAliases { span });\n             }\n \n             let bounds = self.parse_generic_bounds(None)?;\n@@ -862,12 +814,10 @@ impl<'a> Parser<'a> {\n \n             let whole_span = lo.to(self.prev_token.span);\n             if is_auto == IsAuto::Yes {\n-                let msg = \"trait aliases cannot be `auto`\";\n-                self.struct_span_err(whole_span, msg).span_label(whole_span, msg).emit();\n+                self.sess.emit_err(TraitAliasCannotBeAuto { span: whole_span });\n             }\n             if let Unsafe::Yes(_) = unsafety {\n-                let msg = \"trait aliases cannot be `unsafe`\";\n-                self.struct_span_err(whole_span, msg).span_label(whole_span, msg).emit();\n+                self.sess.emit_err(TraitAliasCannotBeUnsafe { span: whole_span });\n             }\n \n             self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n@@ -913,8 +863,7 @@ impl<'a> Parser<'a> {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n                         ItemKind::Static(a, _, b) => {\n-                            self.struct_span_err(span, \"associated `static` items are not allowed\")\n-                                .emit();\n+                            self.sess.emit_err(AssociatedStaticItemNotAllowed { span });\n                             AssocItemKind::Const(Defaultness::Final, a, b)\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`trait`s or `impl`s\"),\n@@ -1088,41 +1037,37 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, Ident> {\n-        let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n-        let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n-                              in the code\";\n-        let mut ident = if self.token.is_keyword(kw::SelfLower) {\n+        let ident = if self.token.is_keyword(kw::SelfLower) {\n             self.parse_path_segment_ident()\n         } else {\n             self.parse_ident()\n         }?;\n-        let mut idents = vec![];\n-        let mut replacement = vec![];\n-        let mut fixed_crate_name = false;\n-        // Accept `extern crate name-like-this` for better diagnostics.\n+\n         let dash = token::BinOp(token::BinOpToken::Minus);\n-        if self.token == dash {\n-            // Do not include `-` as part of the expected tokens list.\n-            while self.eat(&dash) {\n-                fixed_crate_name = true;\n-                replacement.push((self.prev_token.span, \"_\".to_string()));\n-                idents.push(self.parse_ident()?);\n-            }\n+        if self.token != dash {\n+            return Ok(ident);\n         }\n-        if fixed_crate_name {\n-            let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n-            let mut fixed_name = ident.name.to_string();\n-            for part in idents {\n-                write!(fixed_name, \"_{}\", part.name).unwrap();\n-            }\n-            ident = Ident::from_str_and_span(&fixed_name, fixed_name_sp);\n \n-            self.struct_span_err(fixed_name_sp, error_msg)\n-                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n-                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n-                .emit();\n+        // Accept `extern crate name-like-this` for better diagnostics.\n+        let mut dashes = vec![];\n+        let mut idents = vec![];\n+        while self.eat(&dash) {\n+            dashes.push(self.prev_token.span);\n+            idents.push(self.parse_ident()?);\n         }\n-        Ok(ident)\n+\n+        let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n+        let mut fixed_name = ident.name.to_string();\n+        for part in idents {\n+            write!(fixed_name, \"_{}\", part.name).unwrap();\n+        }\n+\n+        self.sess.emit_err(ExternCrateNameWithDashes {\n+            span: fixed_name_sp,\n+            sugg: ExternCrateNameWithDashesSugg { dashes },\n+        });\n+\n+        Ok(Ident::from_str_and_span(&fixed_name, fixed_name_sp))\n     }\n \n     /// Parses `extern` for foreign ABIs modules.\n@@ -1170,7 +1115,10 @@ impl<'a> Parser<'a> {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n                         ItemKind::Const(_, a, b) => {\n-                            self.error_on_foreign_const(span, ident);\n+                            self.sess.emit_err(ExternItemCannotBeConst {\n+                                ident_span: ident.span,\n+                                const_span: span.with_hi(ident.span.lo()),\n+                            });\n                             ForeignItemKind::Static(a, Mutability::Not, b)\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`extern` blocks\"),\n@@ -1182,6 +1130,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n+        // FIXME(#100717): needs variant for each `ItemKind` (instead of using `ItemKind::descr()`)\n         let span = self.sess.source_map().guess_head_span(span);\n         let descr = kind.descr();\n         self.struct_span_err(span, &format!(\"{descr} is not supported in {ctx}\"))\n@@ -1190,18 +1139,6 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n-    fn error_on_foreign_const(&self, span: Span, ident: Ident) {\n-        self.struct_span_err(ident.span, \"extern items cannot be `const`\")\n-            .span_suggestion(\n-                span.with_hi(ident.span.lo()),\n-                \"try using a static value\",\n-                \"static \",\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\")\n-            .emit();\n-    }\n-\n     fn is_unsafe_foreign_mod(&self) -> bool {\n         self.token.is_keyword(kw::Unsafe)\n             && self.is_keyword_ahead(1, &[kw::Extern])\n@@ -1229,25 +1166,10 @@ impl<'a> Parser<'a> {\n     fn recover_const_mut(&mut self, const_span: Span) {\n         if self.eat_keyword(kw::Mut) {\n             let span = self.prev_token.span;\n-            self.struct_span_err(span, \"const globals cannot be mutable\")\n-                .span_label(span, \"cannot be mutable\")\n-                .span_suggestion(\n-                    const_span,\n-                    \"you might want to declare a static instead\",\n-                    \"static\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(ConstGlobalCannotBeMutable { ident_span: span, const_span });\n         } else if self.eat_keyword(kw::Let) {\n             let span = self.prev_token.span;\n-            self.struct_span_err(const_span.to(span), \"`const` and `let` are mutually exclusive\")\n-                .span_suggestion(\n-                    const_span.to(span),\n-                    \"remove `let`\",\n-                    \"const\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(ConstLetMutuallyExclusive { span: const_span.to(span) });\n         }\n     }\n \n@@ -1332,13 +1254,8 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = self.prev_token.span.shrink_to_hi();\n-        let mut err = self.struct_span_err(span, &format!(\"missing type for `{kind}` item\"));\n-        err.span_suggestion(\n-            span,\n-            \"provide a type for the item\",\n-            format!(\"{colon} <type>\"),\n-            Applicability::HasPlaceholders,\n-        );\n+        let err: DiagnosticBuilder<'_, ErrorGuaranteed> =\n+            MissingConstType { span, colon, kind }.into_diagnostic(&self.sess.span_diagnostic);\n         err.stash(span, StashKey::ItemNoType);\n \n         // The user intended that the type be inferred,\n@@ -1350,18 +1267,12 @@ impl<'a> Parser<'a> {\n     fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n         if self.token.is_keyword(kw::Struct) {\n             let span = self.prev_token.span.to(self.token.span);\n-            let mut err = self.struct_span_err(span, \"`enum` and `struct` are mutually exclusive\");\n-            err.span_suggestion(\n-                span,\n-                \"replace `enum struct` with\",\n-                \"enum\",\n-                Applicability::MachineApplicable,\n-            );\n+            let err = EnumStructMutuallyExclusive { span };\n             if self.look_ahead(1, |t| t.is_ident()) {\n                 self.bump();\n-                err.emit();\n+                self.sess.emit_err(err);\n             } else {\n-                return Err(err);\n+                return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n             }\n         }\n \n@@ -1497,13 +1408,8 @@ impl<'a> Parser<'a> {\n             self.expect_semi()?;\n             body\n         } else {\n-            let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\n-                \"expected `where`, `{{`, `(`, or `;` after struct name, found {token_str}\"\n-            );\n-            let mut err = self.struct_span_err(self.token.span, msg);\n-            err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n-            return Err(err);\n+            let err = UnexpectedTokenAfterStructName::new(self.token.span, self.token.clone());\n+            return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n         };\n \n         Ok((class_name, ItemKind::Struct(vdata, generics)))\n@@ -2334,7 +2240,9 @@ impl<'a> Parser<'a> {\n         let ext = self.parse_extern(case);\n \n         if let Async::Yes { span, .. } = asyncness {\n-            self.ban_async_in_2015(span);\n+            if span.rust_2015() {\n+                self.sess.emit_err(AsyncFnIn2015 { span, help: HelpUseLatestEdition::new() });\n+            }\n         }\n \n         if !self.eat_keyword_case(kw::Fn, case) {\n@@ -2444,19 +2352,6 @@ impl<'a> Parser<'a> {\n         Ok(FnHeader { constness, unsafety, asyncness, ext })\n     }\n \n-    /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n-    fn ban_async_in_2015(&self, span: Span) {\n-        if span.rust_2015() {\n-            let diag = self.diagnostic();\n-\n-            let mut e =\n-                struct_span_err!(diag, span, E0670, \"`async fn` is not permitted in Rust 2015\");\n-            e.span_label(span, \"to use `async fn`, switch to Rust 2018 or later\");\n-            HelpUseLatestEdition::new().add_to_diagnostic(&mut e);\n-            e.emit();\n-        }\n-    }\n-\n     /// Parses the parameter list and result type of a function declaration.\n     pub(super) fn parse_fn_decl(\n         &mut self,\n@@ -2599,9 +2494,7 @@ impl<'a> Parser<'a> {\n         };\n         // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n         let recover_self_ptr = |this: &mut Self| {\n-            let msg = \"cannot pass `self` by raw pointer\";\n-            let span = this.token.span;\n-            this.struct_span_err(span, msg).span_label(span, msg).emit();\n+            self.sess.emit_err(SelfArgumentPointer { span: this.token.span });\n \n             Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_token.span))\n         };\n@@ -2682,14 +2575,14 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(offset + 1, |t| t == &token::Colon)\n     }\n \n-    fn recover_first_param(&mut self) -> &'static str {\n+    fn recover_self_param(&mut self) -> bool {\n         match self\n             .parse_outer_attributes()\n             .and_then(|_| self.parse_self_param())\n             .map_err(|e| e.cancel())\n         {\n-            Ok(Some(_)) => \"method\",\n-            _ => \"function\",\n+            Ok(Some(_)) => true,\n+            _ => false,\n         }\n     }\n }"}, {"sha": "7a4d53ed8bbe04d87983124b01a2586ee00ba8cb", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -2,9 +2,11 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, NonterminalKind, Token};\n use rustc_ast::HasTokens;\n use rustc_ast_pretty::pprust;\n+use rustc_errors::IntoDiagnostic;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n+use crate::errors::UnexpectedNonterminal;\n use crate::parser::pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n use crate::parser::{FollowedByType, ForceCollect, NtOrTt, Parser, PathStyle};\n \n@@ -113,7 +115,8 @@ impl<'a> Parser<'a> {\n             NonterminalKind::Item => match self.parse_item(ForceCollect::Yes)? {\n                 Some(item) => token::NtItem(item),\n                 None => {\n-                    return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n+                    return Err(UnexpectedNonterminal::Item(self.token.span)\n+                               .into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             },\n             NonterminalKind::Block => {\n@@ -124,7 +127,8 @@ impl<'a> Parser<'a> {\n             NonterminalKind::Stmt => match self.parse_stmt(ForceCollect::Yes)? {\n                 Some(s) => token::NtStmt(P(s)),\n                 None => {\n-                    return Err(self.struct_span_err(self.token.span, \"expected a statement\"));\n+                    return Err(UnexpectedNonterminal::Statement(self.token.span)\n+                               .into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             },\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n@@ -160,9 +164,10 @@ impl<'a> Parser<'a> {\n                 token::NtIdent(ident, is_raw)\n             }\n             NonterminalKind::Ident => {\n-                let token_str = pprust::token_to_string(&self.token);\n-                let msg = &format!(\"expected ident, found {}\", &token_str);\n-                return Err(self.struct_span_err(self.token.span, msg));\n+                return Err(UnexpectedNonterminal::Ident {\n+                    span: self.token.span,\n+                    token: self.token.clone(),\n+                }.into_diagnostic(&self.sess.span_diagnostic));\n             }\n             NonterminalKind::Path => token::NtPath(\n                 P(self.collect_tokens_no_attrs(|this| this.parse_path(PathStyle::Type))?),\n@@ -175,9 +180,10 @@ impl<'a> Parser<'a> {\n                 if self.check_lifetime() {\n                     token::NtLifetime(self.expect_lifetime().ident)\n                 } else {\n-                    let token_str = pprust::token_to_string(&self.token);\n-                    let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n-                    return Err(self.struct_span_err(self.token.span, msg));\n+                    return Err(UnexpectedNonterminal::Lifetime {\n+                        span: self.token.span,\n+                        token: self.token.clone(),\n+                    }.into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             }\n         };"}, {"sha": "29bd6cd1fd04949e2291d72c354a221ba9949042", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 104, "deletions": 177, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -1,6 +1,12 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n use crate::errors::{\n-    InclusiveRangeExtraEquals, InclusiveRangeMatchArrow, InclusiveRangeNoEnd, RemoveLet,\n+    AmbiguousRangePattern, DotDotDotForRemainingFields, DotDotDotRangeToPatternNotAllowed,\n+    DotDotDotRestPattern, EnumPatternInsteadOfIdentifier, ExpectedBindingLeftOfAt,\n+    ExpectedCommaAfterPatternField, InclusiveRangeExtraEquals, InclusiveRangeMatchArrow,\n+    InclusiveRangeNoEnd, InvalidMutInPattern, PatternOnWrongSideOfAt, RefMutOrderIncorrect,\n+    RemoveLet, RepeatedMutInPattern, TopLevelOrPatternNotAllowed, TopLevelOrPatternNotAllowedSugg,\n+    TrailingVertNotAllowed, UnexpectedLifetimeInPattern, UnexpectedVertVertBeforeFunctionParam,\n+    UnexpectedVertVertInPattern,\n };\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n@@ -11,7 +17,9 @@ use rustc_ast::{\n     PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{\n+    fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -56,6 +64,12 @@ enum EatOrResult {\n     None,\n }\n \n+/// The syntax location of a given pattern. Used for diagnostics.\n+pub(super) enum PatternLocation {\n+    LetBinding,\n+    FunctionParameter,\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n     ///\n@@ -170,7 +184,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         expected: Expected,\n         rc: RecoverComma,\n-        syntax_loc: &str,\n+        syntax_loc: PatternLocation,\n     ) -> PResult<'a, (P<Pat>, bool)> {\n         // We use `parse_pat_allow_top_alt` regardless of whether we actually want top-level\n         // or-patterns so that we can detect when a user tries to use it. This allows us to print a\n@@ -184,27 +198,41 @@ impl<'a> Parser<'a> {\n         let colon = self.eat(&token::Colon);\n \n         if let PatKind::Or(pats) = &pat.kind {\n-            let msg = format!(\"top-level or-patterns are not allowed in {}\", syntax_loc);\n-            let (help, fix) = if pats.len() == 1 {\n-                // If all we have is a leading vert, then print a special message. This is the case\n-                // if `parse_pat_allow_top_alt` returns an or-pattern with one variant.\n-                let msg = \"remove the `|`\";\n-                let fix = pprust::pat_to_string(&pat);\n-                (msg, fix)\n-            } else {\n-                let msg = \"wrap the pattern in parentheses\";\n-                let fix = format!(\"({})\", pprust::pat_to_string(&pat));\n-                (msg, fix)\n-            };\n+            let span = pat.span;\n \n             if trailing_vert {\n                 // We already emitted an error and suggestion to remove the trailing vert. Don't\n                 // emit again.\n-                self.sess.span_diagnostic.delay_span_bug(pat.span, &msg);\n+\n+                // FIXME(#100717): pass `TopLevelOrPatternNotAllowed::* { sub: None }` to\n+                // `delay_span_bug()` instead of fluent message\n+                self.sess.span_diagnostic.delay_span_bug(\n+                    span,\n+                    match syntax_loc {\n+                        PatternLocation::LetBinding => {\n+                            fluent::parse_or_pattern_not_allowed_in_let_binding\n+                        }\n+                        PatternLocation::FunctionParameter => {\n+                            fluent::parse_or_pattern_not_allowed_in_fn_parameters\n+                        }\n+                    },\n+                );\n             } else {\n-                self.struct_span_err(pat.span, &msg)\n-                    .span_suggestion(pat.span, help, fix, Applicability::MachineApplicable)\n-                    .emit();\n+                let pat = pprust::pat_to_string(&pat);\n+                let sub = if pats.len() == 1 {\n+                    Some(TopLevelOrPatternNotAllowedSugg::RemoveLeadingVert { span, pat })\n+                } else {\n+                    Some(TopLevelOrPatternNotAllowedSugg::WrapInParens { span, pat })\n+                };\n+\n+                self.sess.emit_err(match syntax_loc {\n+                    PatternLocation::LetBinding => {\n+                        TopLevelOrPatternNotAllowed::LetBinding { span, sub }\n+                    }\n+                    PatternLocation::FunctionParameter => {\n+                        TopLevelOrPatternNotAllowed::FunctionParameter { span, sub }\n+                    }\n+                });\n             }\n         }\n \n@@ -221,15 +249,15 @@ impl<'a> Parser<'a> {\n         // a leading `||` probably doesn't indicate an or-pattern attempt, so we handle that\n         // separately.\n         if let token::OrOr = self.token.kind {\n-            let span = self.token.span;\n-            let mut err = self.struct_span_err(span, \"unexpected `||` before function parameter\");\n-            err.span_suggestion(span, \"remove the `||`\", \"\", Applicability::MachineApplicable);\n-            err.note(\"alternatives in or-patterns are separated with `|`, not `||`\");\n-            err.emit();\n+            self.sess.emit_err(UnexpectedVertVertBeforeFunctionParam { span: self.token.span });\n             self.bump();\n         }\n \n-        self.parse_pat_before_ty(PARAM_EXPECTED, RecoverComma::No, \"function parameters\")\n+        self.parse_pat_before_ty(\n+            PARAM_EXPECTED,\n+            RecoverComma::No,\n+            PatternLocation::FunctionParameter,\n+        )\n     }\n \n     /// Eat the or-pattern `|` separator.\n@@ -239,7 +267,7 @@ impl<'a> Parser<'a> {\n             EatOrResult::TrailingVert\n         } else if matches!(self.token.kind, token::OrOr) {\n             // Found `||`; Recover and pretend we parsed `|`.\n-            self.ban_unexpected_or_or(lo);\n+            self.sess.emit_err(UnexpectedVertVertInPattern { span: self.token.span, start: lo });\n             self.bump();\n             EatOrResult::AteOr\n         } else if self.eat(&token::BinOp(token::Or)) {\n@@ -273,48 +301,20 @@ impl<'a> Parser<'a> {\n         });\n         match (is_end_ahead, &self.token.kind) {\n             (true, token::BinOp(token::Or) | token::OrOr) => {\n-                self.ban_illegal_vert(lo, \"trailing\", \"not allowed in an or-pattern\");\n+                // A `|` or possibly `||` token shouldn't be here. Ban it.\n+                self.sess.emit_err(TrailingVertNotAllowed {\n+                    span: self.token.span,\n+                    start: lo,\n+                    token: self.token.clone(),\n+                    note_double_vert: matches!(self.token.kind, token::OrOr).then_some(()),\n+                });\n                 self.bump();\n                 true\n             }\n             _ => false,\n         }\n     }\n \n-    /// We have parsed `||` instead of `|`. Error and suggest `|` instead.\n-    fn ban_unexpected_or_or(&mut self, lo: Option<Span>) {\n-        let mut err = self.struct_span_err(self.token.span, \"unexpected token `||` in pattern\");\n-        err.span_suggestion(\n-            self.token.span,\n-            \"use a single `|` to separate multiple alternative patterns\",\n-            \"|\",\n-            Applicability::MachineApplicable,\n-        );\n-        if let Some(lo) = lo {\n-            err.span_label(lo, WHILE_PARSING_OR_MSG);\n-        }\n-        err.emit();\n-    }\n-\n-    /// A `|` or possibly `||` token shouldn't be here. Ban it.\n-    fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n-        let span = self.token.span;\n-        let mut err = self.struct_span_err(span, &format!(\"a {} `|` is {}\", pos, ctx));\n-        err.span_suggestion(\n-            span,\n-            &format!(\"remove the `{}`\", pprust::token_to_string(&self.token)),\n-            \"\",\n-            Applicability::MachineApplicable,\n-        );\n-        if let Some(lo) = lo {\n-            err.span_label(lo, WHILE_PARSING_OR_MSG);\n-        }\n-        if let token::OrOr = self.token.kind {\n-            err.note(\"alternatives in or-patterns are separated with `|`, not `||`\");\n-        }\n-        err.emit();\n-    }\n-\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -457,15 +457,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `...`\n \n         // The user probably mistook `...` for a rest pattern `..`.\n-        self.struct_span_err(lo, \"unexpected `...`\")\n-            .span_label(lo, \"not a valid pattern\")\n-            .span_suggestion_short(\n-                lo,\n-                \"for a rest pattern, use `..` instead of `...`\",\n-                \"..\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(DotDotDotRestPattern { span: lo });\n         PatKind::Rest\n     }\n \n@@ -490,7 +482,7 @@ impl<'a> Parser<'a> {\n         // At this point we attempt to parse `@ $pat_rhs` and emit an error.\n         self.bump(); // `@`\n         let mut rhs = self.parse_pat_no_top_alt(None)?;\n-        let sp = lhs.span.to(rhs.span);\n+        let whole_span = lhs.span.to(rhs.span);\n \n         if let PatKind::Ident(_, _, sub @ None) = &mut rhs.kind {\n             // The user inverted the order, so help them fix that.\n@@ -499,27 +491,23 @@ impl<'a> Parser<'a> {\n             // The RHS is now the full pattern.\n             *sub = Some(lhs);\n \n-            self.struct_span_err(sp, \"pattern on wrong side of `@`\")\n-                .span_label(lhs_span, \"pattern on the left, should be on the right\")\n-                .span_label(rhs.span, \"binding on the right, should be on the left\")\n-                .span_suggestion(\n-                    sp,\n-                    \"switch the order\",\n-                    pprust::pat_to_string(&rhs),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(PatternOnWrongSideOfAt {\n+                whole_span,\n+                whole_pat: pprust::pat_to_string(&rhs),\n+                pattern: lhs_span,\n+                binding: rhs.span,\n+            });\n         } else {\n             // The special case above doesn't apply so we may have e.g. `A(x) @ B(y)`.\n             rhs.kind = PatKind::Wild;\n-            self.struct_span_err(sp, \"left-hand side of `@` must be a binding\")\n-                .span_label(lhs.span, \"interpreted as a pattern, not a binding\")\n-                .span_label(rhs.span, \"also a pattern\")\n-                .note(\"bindings are `x`, `mut x`, `ref x`, and `ref mut x`\")\n-                .emit();\n+            self.sess.emit_err(ExpectedBindingLeftOfAt {\n+                whole_span,\n+                lhs: lhs.span,\n+                rhs: rhs.span,\n+            });\n         }\n \n-        rhs.span = sp;\n+        rhs.span = whole_span;\n         Ok(rhs)\n     }\n \n@@ -534,35 +522,23 @@ impl<'a> Parser<'a> {\n             _ => return,\n         }\n \n-        self.struct_span_err(pat.span, \"the range pattern here has ambiguous interpretation\")\n-            .span_suggestion(\n-                pat.span,\n-                \"add parentheses to clarify the precedence\",\n-                format!(\"({})\", pprust::pat_to_string(&pat)),\n-                // \"ambiguous interpretation\" implies that we have to be guessing\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess\n+            .emit_err(AmbiguousRangePattern { span: pat.span, pat: pprust::pat_to_string(&pat) });\n     }\n \n     /// Parse `&pat` / `&mut pat`.\n     fn parse_pat_deref(&mut self, expected: Expected) -> PResult<'a, PatKind> {\n         self.expect_and()?;\n-        self.recover_lifetime_in_deref_pat();\n-        let mutbl = self.parse_mutability();\n-        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-        Ok(PatKind::Ref(subpat, mutbl))\n-    }\n-\n-    fn recover_lifetime_in_deref_pat(&mut self) {\n         if let token::Lifetime(name) = self.token.kind {\n             self.bump(); // `'a`\n \n-            let span = self.prev_token.span;\n-            self.struct_span_err(span, &format!(\"unexpected lifetime `{}` in pattern\", name))\n-                .span_suggestion(span, \"remove the lifetime\", \"\", Applicability::MachineApplicable)\n-                .emit();\n+            self.sess\n+                .emit_err(UnexpectedLifetimeInPattern { span: self.prev_token.span, symbol: name });\n         }\n+\n+        let mutbl = self.parse_mutability();\n+        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+        Ok(PatKind::Ref(subpat, mutbl))\n     }\n \n     /// Parse a tuple or parenthesis pattern.\n@@ -590,7 +566,8 @@ impl<'a> Parser<'a> {\n         let mut_span = self.prev_token.span;\n \n         if self.eat_keyword(kw::Ref) {\n-            return self.recover_mut_ref_ident(mut_span);\n+            self.sess.emit_err(RefMutOrderIncorrect { span: mut_span.to(self.prev_token.span) });\n+            return self.parse_pat_ident(BindingAnnotation::REF_MUT);\n         }\n \n         self.recover_additional_muts();\n@@ -620,22 +597,6 @@ impl<'a> Parser<'a> {\n         Ok(pat.into_inner().kind)\n     }\n \n-    /// Recover on `mut ref? ident @ pat` and suggest\n-    /// that the order of `mut` and `ref` is incorrect.\n-    fn recover_mut_ref_ident(&mut self, lo: Span) -> PResult<'a, PatKind> {\n-        let mutref_span = lo.to(self.prev_token.span);\n-        self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-            .span_suggestion(\n-                mutref_span,\n-                \"try switching the order\",\n-                \"ref mut\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-\n-        self.parse_pat_ident(BindingAnnotation::REF_MUT)\n-    }\n-\n     /// Turn all by-value immutable bindings in a pattern into mutable bindings.\n     /// Returns `true` if any change was made.\n     fn make_all_value_bindings_mutable(pat: &mut P<Pat>) -> bool {\n@@ -660,16 +621,13 @@ impl<'a> Parser<'a> {\n     /// Error on `mut $pat` where `$pat` is not an ident.\n     fn ban_mut_general_pat(&self, lo: Span, pat: &Pat, changed_any_binding: bool) {\n         let span = lo.to(pat.span);\n-        let fix = pprust::pat_to_string(&pat);\n-        let (problem, suggestion) = if changed_any_binding {\n-            (\"`mut` must be attached to each individual binding\", \"add `mut` to each binding\")\n+        let pat = pprust::pat_to_string(&pat);\n+\n+        self.sess.emit_err(if changed_any_binding {\n+            InvalidMutInPattern::NestedIdent { span, pat }\n         } else {\n-            (\"`mut` must be followed by a named binding\", \"remove the `mut` prefix\")\n-        };\n-        self.struct_span_err(span, problem)\n-            .span_suggestion(span, suggestion, fix, Applicability::MachineApplicable)\n-            .note(\"`mut` may be followed by `variable` and `variable @ pattern`\")\n-            .emit();\n+            InvalidMutInPattern::NonIdent { span, pat }\n+        });\n     }\n \n     /// Eat any extraneous `mut`s and error + recover if we ate any.\n@@ -680,15 +638,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        let span = lo.to(self.prev_token.span);\n-        self.struct_span_err(span, \"`mut` on a binding may not be repeated\")\n-            .span_suggestion(\n-                span,\n-                \"remove the additional `mut`s\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(RepeatedMutInPattern { span: lo.to(self.prev_token.span) });\n     }\n \n     /// Parse macro invocation\n@@ -774,28 +724,18 @@ impl<'a> Parser<'a> {\n                     let _ = self.parse_pat_range_end().map_err(|e| e.cancel());\n                 }\n \n-                self.error_inclusive_range_with_extra_equals(span_with_eq);\n+                self.sess.emit_err(InclusiveRangeExtraEquals { span: span_with_eq });\n             }\n             token::Gt if no_space => {\n-                self.error_inclusive_range_match_arrow(span);\n+                let after_pat = span.with_hi(span.hi() - rustc_span::BytePos(1)).shrink_to_hi();\n+                self.sess.emit_err(InclusiveRangeMatchArrow { span, after_pat });\n+            }\n+            _ => {\n+                self.sess.emit_err(InclusiveRangeNoEnd { span });\n             }\n-            _ => self.error_inclusive_range_with_no_end(span),\n         }\n     }\n \n-    fn error_inclusive_range_with_extra_equals(&self, span: Span) {\n-        self.sess.emit_err(InclusiveRangeExtraEquals { span });\n-    }\n-\n-    fn error_inclusive_range_match_arrow(&self, span: Span) {\n-        let after_pat = span.with_hi(span.hi() - rustc_span::BytePos(1)).shrink_to_hi();\n-        self.sess.emit_err(InclusiveRangeMatchArrow { span, after_pat });\n-    }\n-\n-    fn error_inclusive_range_with_no_end(&self, span: Span) {\n-        self.sess.emit_err(InclusiveRangeNoEnd { span });\n-    }\n-\n     /// Parse a range-to pattern, `..X` or `..=X` where `X` remains to be parsed.\n     ///\n     /// The form `...X` is prohibited to reduce confusion with the potential\n@@ -804,14 +744,7 @@ impl<'a> Parser<'a> {\n         let end = self.parse_pat_range_end()?;\n         if let RangeEnd::Included(syn @ RangeSyntax::DotDotDot) = &mut re.node {\n             *syn = RangeSyntax::DotDotEq;\n-            self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n-                .span_suggestion_short(\n-                    re.span,\n-                    \"use `..=` instead\",\n-                    \"..=\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(DotDotDotRangeToPatternNotAllowed { span: re.span });\n         }\n         Ok(PatKind::Range(None, Some(end), re))\n     }\n@@ -887,8 +820,8 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(Delimiter::Parenthesis) {\n-            return Err(self\n-                .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n+            return Err(EnumPatternInsteadOfIdentifier { span: self.prev_token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic));\n         }\n \n         Ok(PatKind::Ident(binding_annotation, ident, sub))\n@@ -1005,7 +938,8 @@ impl<'a> Parser<'a> {\n \n             // check that a comma comes after every field\n             if !ate_comma {\n-                let err = self.struct_span_err(self.token.span, \"expected `,`\");\n+                let err = ExpectedCommaAfterPatternField { span: self.token.span }\n+                    .into_diagnostic(&self.sess.span_diagnostic);\n                 if let Some(mut delayed) = delayed_err {\n                     delayed.emit();\n                 }\n@@ -1118,14 +1052,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n-            .span_suggestion(\n-                self.token.span,\n-                \"to omit remaining fields, use one fewer `.`\",\n-                \"..\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(DotDotDotForRemainingFields { span: self.token.span });\n     }\n \n     fn parse_pat_field(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, PatField> {"}, {"sha": "647639b9b62b4244b5918205448b01f7ba8ef94d", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -1,7 +1,7 @@\n use super::attr::InnerAttrForbiddenReason;\n use super::diagnostics::AttemptLocalParseRecovery;\n use super::expr::LhsExpr;\n-use super::pat::RecoverComma;\n+use super::pat::{PatternLocation, RecoverComma};\n use super::path::PathStyle;\n use super::TrailingToken;\n use super::{\n@@ -275,7 +275,8 @@ impl<'a> Parser<'a> {\n         }\n \n         self.report_invalid_identifier_error()?;\n-        let (pat, colon) = self.parse_pat_before_ty(None, RecoverComma::Yes, \"`let` bindings\")?;\n+        let (pat, colon) =\n+            self.parse_pat_before_ty(None, RecoverComma::Yes, PatternLocation::LetBinding)?;\n \n         let (err, ty) = if colon {\n             // Save the state of the parser before parsing type normally, in case there is a `:`"}, {"sha": "9ebf222ee342fe6f5607c182e9bb6055e3f88c37", "filename": "tests/ui/track-diagnostics/track4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/tests%2Fui%2Ftrack-diagnostics%2Ftrack4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87ef37dbd7d26a40bb299aa151b5effdfcc1cec9/tests%2Fui%2Ftrack-diagnostics%2Ftrack4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrack-diagnostics%2Ftrack4.stderr?ref=87ef37dbd7d26a40bb299aa151b5effdfcc1cec9", "patch": "@@ -3,7 +3,7 @@ error: missing `struct` for struct definition\n    |\n LL | pub onion {\n    |    ^\n--Ztrack-diagnostics: created at compiler/rustc_parse/src/parser/diagnostics.rs:LL:CC\n+-Ztrack-diagnostics: created at compiler/rustc_parse/src/parser/item.rs:LL:CC\n    |\n help: add `struct` here to parse `onion` as a public struct\n    |"}]}