{"sha": "6a3e26aa4062019629e144196a7852ef039f8b0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhM2UyNmFhNDA2MjAxOTYyOWUxNDQxOTZhNzg1MmVmMDM5ZjhiMGE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-23T00:54:54Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-25T00:51:30Z"}, "message": "rustpkg: Make path searching work as described in the rustpkg doc\n\nrustpkg now searches for package directories in ./src rather than\nin . . I also added a rudimentary RUST_PATH that's currently\nhard-wired to the current directory. rustpkg now uses src/, lib/,\nand build/ directories as described in the manual.\n\nMost of the existing test scenarios build now; the README file\n(in a separate commit) explains which ones.", "tree": {"sha": "47fdbee5268417865977956dd690b9418aa61c7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47fdbee5268417865977956dd690b9418aa61c7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a3e26aa4062019629e144196a7852ef039f8b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3e26aa4062019629e144196a7852ef039f8b0a", "html_url": "https://github.com/rust-lang/rust/commit/6a3e26aa4062019629e144196a7852ef039f8b0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a3e26aa4062019629e144196a7852ef039f8b0a/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2af1de95b65a0cc2225565f47aa9c08fd072371", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2af1de95b65a0cc2225565f47aa9c08fd072371", "html_url": "https://github.com/rust-lang/rust/commit/c2af1de95b65a0cc2225565f47aa9c08fd072371"}], "stats": {"total": 341, "additions": 190, "deletions": 151}, "files": [{"sha": "a8931e52747d943b209e9e3b12dc2b78ffb0468a", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 116, "deletions": 52, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e26aa4062019629e144196a7852ef039f8b0a/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e26aa4062019629e144196a7852ef039f8b0a/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=6a3e26aa4062019629e144196a7852ef039f8b0a", "patch": "@@ -15,39 +15,43 @@ use core::{os, str};\n use core::option::*;\n use util::PkgId;\n \n-/// Returns the output directory to use.\n-/// Right now is always the default, should\n-/// support changing it.\n-pub fn dest_dir(pkgid: PkgId) -> Path {\n-    default_dest_dir(&pkgid.path)\n+#[deriving(Eq)]\n+pub enum OutputType { Main, Lib, Bench, Test }\n+\n+/// Returns the value of RUST_PATH, as a list\n+/// of Paths. In general this should be read from the\n+/// environment; for now, it's hard-wired to just be \".\"\n+pub fn rust_path() -> ~[Path] {\n+    ~[Path(\".\")]\n }\n \n-/// Returns the default output directory for compilation.\n-/// Creates that directory if it doesn't exist.\n-pub fn default_dest_dir(pkg_dir: &Path) -> Path {\n+/// Creates a directory that is readable, writeable,\n+/// and executable by the user. Returns true iff creation\n+/// succeeded.\n+pub fn make_dir_rwx(p: &Path) -> bool {\n     use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-    use conditions::bad_path::cond;\n \n-    // For now: assumes that pkg_dir exists and is relative\n-    // to the CWD. Change this later when we do path searching.\n-    let rslt = pkg_dir.push(\"build\");\n-    let is_dir = os::path_is_dir(&rslt);\n-    if os::path_exists(&rslt) {\n-        if is_dir {\n-            rslt\n-        }\n-        else {\n-            cond.raise((rslt, ~\"Path names a file that isn't a directory\"))\n-        }\n+    os::make_dir(p, (S_IRUSR | S_IWUSR | S_IXUSR) as i32)\n+}\n+\n+/// Creates a directory that is readable, writeable,\n+/// and executable by the user. Returns true iff creation\n+/// succeeded. Also creates all intermediate subdirectories\n+/// if they don't already exist.\n+pub fn mkdir_recursive(p: &Path) -> bool {\n+    if os::path_is_dir(p) {\n+        return true;\n+    }\n+    let parent = p.dir_path();\n+    debug!(\"mkdir_recursive: parent = %s\",\n+           parent.to_str());\n+    if parent.to_str() == ~\".\"\n+        || parent.to_str() == ~\"/\" { // !!!\n+        // No parent directories to create\n+        os::path_is_dir(&parent) && make_dir_rwx(p)\n     }\n     else {\n-        // Create it\n-        if os::make_dir(&rslt, (S_IRUSR | S_IWUSR | S_IXUSR) as i32) {\n-            rslt\n-        }\n-        else {\n-            cond.raise((rslt, ~\"Could not create directory\"))\n-        }\n+        mkdir_recursive(&parent) && make_dir_rwx(p)\n     }\n }\n \n@@ -69,34 +73,94 @@ pub fn normalize(p: ~Path) -> ~Path {\n     }\n }\n \n+// n.b. So far this only handles local workspaces\n+// n.b. The next three functions ignore the package version right\n+// now. Should fix that.\n+\n+/// True if there's a directory in <workspace> with\n+/// pkgid's short name\n+pub fn workspace_contains_package_id(pkgid: PkgId, workspace: &Path) -> bool {\n+    let pkgpath = workspace.push(\"src\").push(pkgid.path.to_str());\n+    os::path_is_dir(&pkgpath)\n+}\n+\n+/// Return the directory for <pkgid>'s source files in <workspace>.\n+/// Doesn't check that it exists.\n+pub fn pkgid_src_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"src\");\n+    result.push(pkgid.path.to_str())\n+}\n+\n+/// Returns the executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"bin\");\n+    // should use a target-specific subdirectory\n+    mk_output_path(Main, pkgid.path.to_str(), result)\n+}\n+\n+\n+/// Returns the executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"lib\");\n+    mk_output_path(Lib, pkgid.path.to_str(), result)\n+}\n+\n+/// Returns the test executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"build\");\n+    mk_output_path(Test, pkgid.path.to_str(), result)\n+}\n+\n+/// Returns the bench executable that would be installed for <pkgid>\n+/// in <workspace>\n+pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    let result = workspace.push(\"build\");\n+    mk_output_path(Bench, pkgid.path.to_str(), result)\n+}\n+\n+/// Return the directory for <pkgid>'s build artifacts in <workspace>.\n+/// Creates it if it doesn't exist.\n+pub fn build_pkg_id_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+    use conditions::bad_path::cond;\n+\n+    let mut result = workspace.push(\"build\");\n+    // n.b. Should actually use a target-specific\n+    // subdirectory of build/\n+    result = result.push(normalize(~pkgid.path).to_str());\n+    if os::path_exists(&result) || mkdir_recursive(&result) {\n+        result\n+    }\n+    else {\n+        cond.raise((result, fmt!(\"Could not create directory for package %s\", pkgid.to_str())))\n+    }\n+}\n+\n+/// Return the output file for a given directory name,\n+/// given whether we're building a library and whether we're building tests\n+pub fn mk_output_path(what: OutputType, short_name: ~str, dir: Path) -> Path {\n+    match what {\n+        Lib => dir.push(os::dll_filename(short_name)),\n+        _ => dir.push(fmt!(\"%s%s%s\", short_name,\n+                           if what == Test { ~\"test\" } else { ~\"\" },\n+                           os::EXE_SUFFIX))\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use core::{os, rand};\n-    use core::path::Path;\n-    use path_util::*;\n-    use core::rand::RngUtil;\n-\n-    // Helper function to create a directory name that doesn't exist\n-    pub fn mk_nonexistent(tmpdir: &Path, suffix: &str) -> Path {\n-        let r = rand::rng();\n-        for 1000.times {\n-            let p = tmpdir.push(r.gen_str(16) + suffix);\n-            if !os::path_exists(&p) {\n-                return p;\n-            }\n-        }\n-        fail!(~\"Couldn't compute a non-existent path name; this is worrisome\")\n-    }\n+    use core::os;\n \n     #[test]\n-    fn default_dir_ok() {\n-        let the_path = os::tmpdir();\n-        let substitute_path = Path(\"xyzzy\");\n-        assert!(default_dest_dir(&the_path) == the_path.push(~\"build\"));\n-        let nonexistent_path = mk_nonexistent(&the_path, \"quux\");\n-        let bogus = do ::conditions::bad_path::cond.trap(|_| {\n-            substitute_path\n-        }).in { default_dest_dir(&nonexistent_path) };\n-        assert!(bogus == substitute_path);\n+    fn recursive_mkdir_ok() {\n+        let root = os::tmpdir();\n+        let path = \"xy/z/zy\";\n+        let nested = root.push(path);\n+        assert!(super::mkdir_recursive(&nested));\n+        assert!(os::path_is_dir(&root.push(\"xy\")));\n+        assert!(os::path_is_dir(&root.push(\"xy/z\")));\n+        assert!(os::path_is_dir(&nested));\n     }\n }"}, {"sha": "8381e6ad816a884bca19e6b0f26cfbb60b9d91ec", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 62, "deletions": 96, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e26aa4062019629e144196a7852ef039f8b0a/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e26aa4062019629e144196a7852ef039f8b0a/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=6a3e26aa4062019629e144196a7852ef039f8b0a", "patch": "@@ -36,7 +36,8 @@ use rustc::metadata::filesearch;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n-use path_util::{dest_dir, normalize};\n+use path_util::{normalize, workspace_contains_package_id};\n+use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace, rust_path};\n use rustc::driver::session::{lib_crate, bin_crate, crate_type};\n \n mod conditions;\n@@ -70,7 +71,7 @@ impl PkgScript {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse(script: Path, id: PkgId) -> PkgScript {\n+    fn parse(script: Path, workspace: &Path, id: PkgId) -> PkgScript {\n         // Get the executable name that was invoked\n         let binary = os::args()[0];\n         // Build the rustc session data structures to pass\n@@ -85,7 +86,7 @@ impl PkgScript {\n         let cfg = driver::build_configuration(sess, @binary, &input);\n         let (crate, _) = driver::compile_upto(sess, cfg, &input,\n                                               driver::cu_parse, None);\n-        let work_dir = dest_dir(id);\n+        let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id %?\", id);\n \n@@ -193,54 +194,60 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-                // Should allow the build directory to be configured.\n-                // Right now it's always the \"build\" subdirectory in\n-                // the package directory\n-                let dst_dir = dest_dir(pkgid);\n-                debug!(\"Destination dir = %s\", dst_dir.to_str());\n-                // Right now, we assume the pkgid path is a valid dir\n-                // relative to the CWD. In the future, we should search\n-                // paths\n-                let cwd = os::getcwd().normalize();\n-                debug!(\"Current working directory = %s\", cwd.to_str());\n-\n-                // Create the package source\n-                let mut src = PkgSrc::new(&cwd, &dst_dir, &pkgid);\n-                debug!(\"Package src = %?\", src);\n-\n-                // Is there custom build logic? If so, use it\n-                let pkg_src_dir = cwd.push_rel(&pkgid.path);\n-                let mut custom = false;;\n-                debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n-                let cfgs = match src.package_script_option(&pkg_src_dir) {\n-                    Some(package_script_path) => {\n-                        let pscript = PkgScript::parse(package_script_path,\n-                                                       pkgid);\n-                        // Limited right now -- we're only running the post_build\n-                        // hook and probably fail otherwise\n-                        // also post_build should be called pre_build\n-                        let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n-                        debug!(\"Command return code = %?\", hook_result);\n-                        if hook_result != 0 {\n-                            fail!(fmt!(\"Error running custom build command\"))\n+                // Using the RUST_PATH, find workspaces that contain\n+                // this package ID\n+                let workspaces = rust_path().filtered(|ws|\n+                    workspace_contains_package_id(pkgid, ws));\n+                if workspaces.is_empty() {\n+                    fail!(fmt!(\"Package %s not found in any of \\\n+                        the following workspaces: %s\",\n+                               pkgid.path.to_str(),\n+                               rust_path().to_str()));\n+                }\n+                for workspaces.each |workspace| {\n+                    let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n+                    let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n+                    debug!(\"Destination dir = %s\", build_dir.to_str());\n+\n+                    // Create the package source\n+                    let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, &pkgid);\n+                    debug!(\"Package src = %?\", src);\n+\n+                    // Is there custom build logic? If so, use it\n+                    let pkg_src_dir = src_dir;\n+                    let mut custom = false;\n+                    debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n+                    let cfgs = match src.package_script_option(&pkg_src_dir) {\n+                        Some(package_script_path) => {\n+                            let pscript = PkgScript::parse(package_script_path,\n+                                                           workspace,\n+                                                           pkgid);\n+                            // Limited right now -- we're only running the post_build\n+                            // hook and probably fail otherwise\n+                            // also post_build should be called pre_build\n+                            let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n+                            debug!(\"Command return code = %?\", hook_result);\n+                            if hook_result != 0 {\n+                                fail!(fmt!(\"Error running custom build command\"))\n+                            }\n+                            custom = true;\n+                            // otherwise, the package script succeeded\n+                            cfgs\n                         }\n-                        custom = true;\n-                        // otherwise, the package script succeeded\n-                        cfgs\n-                    }\n-                    None => {\n-                        debug!(\"No package script, continuing\");\n-                        ~[]\n+                        None => {\n+                            debug!(\"No package script, continuing\");\n+                            ~[]\n+                        }\n+                    };\n+\n+                    // If there was a package script, it should have finished\n+                    // the build already. Otherwise...\n+                    if !custom {\n+                        // Find crates inside the workspace\n+                        src.find_crates();\n+                        // Build it!\n+                        src.build(&build_dir, cfgs);\n                     }\n-                };\n-\n-                // If there was a package script, it should have finished\n-                // the build already. Otherwise...\n-                if !custom {\n-                    // Find crates inside the workspace\n-                    src.find_crates();\n-                    // Build it!\n-                    src.build(&dst_dir, cfgs);\n                 }\n             }\n             ~\"clean\" => {\n@@ -250,8 +257,8 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-\n-                self.clean(pkgid);\n+                let cwd = os::getcwd();\n+                self.clean(&cwd, pkgid); // tjc: should use workspace, not cwd\n             }\n             ~\"do\" => {\n                 if args.len() < 2 {\n@@ -304,57 +311,16 @@ impl Ctx {\n     }\n \n     fn do_cmd(&self, cmd: ~str, pkgname: ~str)  {\n-        match cmd {\n-            ~\"build\" | ~\"test\" => {\n-                util::error(~\"that command cannot be manually called\");\n-                fail!(~\"do_cmd\");\n-            }\n-            _ => {}\n-        }\n-\n-        let cwd = &os::getcwd();\n-        let pkgid = PkgId::new(pkgname);\n-        // Always use the \"build\" subdirectory of the package dir,\n-        // but we should allow this to be configured\n-        let dst_dir = dest_dir(pkgid);\n-\n-        let mut src = PkgSrc::new(cwd, &dst_dir, &pkgid);\n-        match src.package_script_option(cwd) {\n-            Some(script_path) => {\n-                let script = PkgScript::parse(script_path, pkgid);\n-                let (_, status) = script.run_custom(cmd); // Ignore cfgs?\n-                if status == 42 {\n-                    util::error(~\"no fns are listening for that cmd\");\n-                    fail!(~\"do_cmd\");\n-                }\n-            }\n-            None => {\n-                util::error(fmt!(\"invoked `do`, but there is no package script in %s\",\n-                                 cwd.to_str()));\n-                fail!(~\"do_cmd\");\n-            }\n-        }\n-    }\n-\n-    fn build(&self, _dir: &Path, _verbose: bool, _opt: bool,\n-             _test: bool) -> Option<PkgScript> {\n- // either not needed anymore,\n- // or needed only when we don't have a package script. Not sure which one.\n-        fail!();\n-    }\n-\n-    fn compile(&self, _crate: &Path, _dir: &Path, _flags: ~[~str],\n-               _cfgs: ~[~str], _opt: bool, _test: bool)  {\n-        // What's the difference between build and compile?\n-        fail!(~\"compile not yet implemented\");\n+        // stub\n+        fail!(\"`do` not yet implemented\");\n     }\n \n-    fn clean(&self, id: PkgId)  {\n+    fn clean(&self, workspace: &Path, id: PkgId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n         // Do something reasonable for now\n \n-        let dir = dest_dir(id);\n+        let dir = build_pkg_id_in_workspace(id, workspace);\n         util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {"}, {"sha": "36d409adcd29c28730d9ef4082bf36d4fa9212bd", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e26aa4062019629e144196a7852ef039f8b0a/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e26aa4062019629e144196a7852ef039f8b0a/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=6a3e26aa4062019629e144196a7852ef039f8b0a", "patch": "@@ -116,7 +116,14 @@ pub impl PkgId {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n+        fmt!(\"%s-%s\", self.path.to_str(),\n+             // Replace dots with -s in the version\n+             // this is because otherwise rustc will think\n+             // that foo-0.1 has .1 as its extension\n+             // (Temporary hack until I figure out how to\n+             // get rustc to not name the object file\n+             // foo-0.o if I pass in foo-0.1 to build_output_filenames)\n+             str::replace(self.version.to_str(), \".\", \"-\"))\n     }\n }\n \n@@ -438,7 +445,9 @@ pub fn compile_input(sysroot: Option<Path>,\n                      test: bool,\n                      crate_type: session::crate_type) -> bool {\n \n-    let short_name = pkg_id.to_str();\n+    // Want just the directory component here\n+    let pkg_filename = pkg_id.path.filename().expect(~\"Weird pkg id\");\n+    let short_name = fmt!(\"%s-%s\", pkg_filename, pkg_id.version.to_str());\n \n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n@@ -515,7 +524,7 @@ pub fn compile_crate_from_input(input: driver::input,\n                                 out_file: Path,\n                                 binary: ~str,\n                                 what: driver::compile_upto) -> @ast::crate {\n-    debug!(\"Calling build_output_filenames with %?\", build_dir_opt);\n+    debug!(\"Calling build_output_filenames with %? and %s\", build_dir_opt, out_file.to_str());\n     let outputs = driver::build_output_filenames(&input, &build_dir_opt, &Some(out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     let cfg = driver::build_configuration(sess, @binary, &input);"}]}