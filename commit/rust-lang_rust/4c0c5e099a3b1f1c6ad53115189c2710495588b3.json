{"sha": "4c0c5e099a3b1f1c6ad53115189c2710495588b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMGM1ZTA5OWEzYjFmMWM2YWQ1MzExNTE4OWMyNzEwNDk1NTg4YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-03T00:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-03T00:58:24Z"}, "message": "Auto merge of #77271 - petrochenkov:notokenexp, r=Aaron1011\n\nExpand `NtExpr` tokens only in key-value attributes\n\nImplement the experiment described in https://github.com/rust-lang/rust/issues/55414#issuecomment-554005412\n\nThis PR also removes some customization points and token visiting functionality from AST visitors.\nRead-only visitor no longer visits tokens, mutable visitor visits tokens only when specifically enabled, mutable token visiting is restricted to its single intended use case.\n\nI haven't changed the representation of `MacArgs::Eq` yet, but it potentially can use a `TokenTree` or a `Token` instead of `TokenStream`.\nIt's hard to get rid of `Nonterminal::NtExpr` there (and e.g. replace it with `ast::Expr`) due to the dual nature of key-value attributes (the value is both an expression and a token stream, depending on context), and `Nonterminal` has all the machinery for maintaining both representations in sync.\n\nFixes https://github.com/rust-lang/rust/issues/55414\nFixes https://github.com/rust-lang/rust/issues/43860", "tree": {"sha": "1d0f77ee3917bc7c01c656a405338ad1f9b85576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d0f77ee3917bc7c01c656a405338ad1f9b85576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c0c5e099a3b1f1c6ad53115189c2710495588b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0c5e099a3b1f1c6ad53115189c2710495588b3", "html_url": "https://github.com/rust-lang/rust/commit/4c0c5e099a3b1f1c6ad53115189c2710495588b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c0c5e099a3b1f1c6ad53115189c2710495588b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "338f939a8d77061896cd0a1ca87a2c6d1f4ec359", "url": "https://api.github.com/repos/rust-lang/rust/commits/338f939a8d77061896cd0a1ca87a2c6d1f4ec359", "html_url": "https://github.com/rust-lang/rust/commit/338f939a8d77061896cd0a1ca87a2c6d1f4ec359"}, {"sha": "19dbb02a8923c5ffd969d4d7ac3008c4df7326e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/19dbb02a8923c5ffd969d4d7ac3008c4df7326e9", "html_url": "https://github.com/rust-lang/rust/commit/19dbb02a8923c5ffd969d4d7ac3008c4df7326e9"}], "stats": {"total": 536, "additions": 402, "deletions": 134}, "files": [{"sha": "fe9ad58c9ac84d151b8a56cbfab60a6530af4e4a", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -34,6 +34,13 @@ impl<A: Array> ExpectOne<A> for SmallVec<A> {\n }\n \n pub trait MutVisitor: Sized {\n+    /// Mutable token visiting only exists for the `macro_rules` token marker and should not be\n+    /// used otherwise. Token visitor would be entirely separate from the regular visitor if\n+    /// the marker didn't have to visit AST fragments in nonterminal tokens.\n+    fn token_visiting_enabled(&self) -> bool {\n+        false\n+    }\n+\n     // Methods in this trait have one of three forms:\n     //\n     //   fn visit_t(&mut self, t: &mut T);                      // common\n@@ -246,22 +253,6 @@ pub trait MutVisitor: Sized {\n         noop_flat_map_generic_param(param, self)\n     }\n \n-    fn visit_tt(&mut self, tt: &mut TokenTree) {\n-        noop_visit_tt(tt, self);\n-    }\n-\n-    fn visit_tts(&mut self, tts: &mut TokenStream) {\n-        noop_visit_tts(tts, self);\n-    }\n-\n-    fn visit_token(&mut self, t: &mut Token) {\n-        noop_visit_token(t, self);\n-    }\n-\n-    fn visit_interpolated(&mut self, nt: &mut token::Nonterminal) {\n-        noop_visit_interpolated(nt, self);\n-    }\n-\n     fn visit_param_bound(&mut self, tpb: &mut GenericBound) {\n         noop_visit_param_bound(tpb, self);\n     }\n@@ -375,11 +366,30 @@ pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n         MacArgs::Empty => {}\n         MacArgs::Delimited(dspan, _delim, tokens) => {\n             visit_delim_span(dspan, vis);\n-            vis.visit_tts(tokens);\n+            visit_tts(tokens, vis);\n         }\n         MacArgs::Eq(eq_span, tokens) => {\n             vis.visit_span(eq_span);\n-            vis.visit_tts(tokens);\n+            visit_tts(tokens, vis);\n+            // The value in `#[key = VALUE]` must be visited as an expression for backward\n+            // compatibility, so that macros can be expanded in that position.\n+            if !vis.token_visiting_enabled() {\n+                if let Some(TokenTree::Token(token)) = tokens.trees_ref().next() {\n+                    if let token::Interpolated(..) = token.kind {\n+                        // ^^ Do not `make_mut` unless we have to.\n+                        match Lrc::make_mut(&mut tokens.0).get_mut(0) {\n+                            Some((TokenTree::Token(token), _spacing)) => match &mut token.kind {\n+                                token::Interpolated(nt) => match Lrc::make_mut(nt) {\n+                                    token::NtExpr(expr) => vis.visit_expr(expr),\n+                                    t => panic!(\"unexpected token in key-value attribute: {:?}\", t),\n+                                },\n+                                t => panic!(\"unexpected token in key-value attribute: {:?}\", t),\n+                            },\n+                            t => panic!(\"unexpected token in key-value attribute: {:?}\", t),\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n }\n@@ -626,28 +636,33 @@ pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> Smal\n     smallvec![param]\n }\n \n-pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n     match tt {\n         TokenTree::Token(token) => {\n-            vis.visit_token(token);\n+            visit_token(token, vis);\n         }\n         TokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n             vis.visit_span(open);\n             vis.visit_span(close);\n-            vis.visit_tts(tts);\n+            visit_tts(tts, vis);\n         }\n     }\n }\n \n-pub fn noop_visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T) {\n-    let tts = Lrc::make_mut(tts);\n-    visit_vec(tts, |(tree, _is_joint)| vis.visit_tt(tree));\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T) {\n+    if vis.token_visiting_enabled() {\n+        let tts = Lrc::make_mut(tts);\n+        visit_vec(tts, |(tree, _is_joint)| visit_tt(tree, vis));\n+    }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n // Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n // In practice the ident part is not actually used by specific visitors right now,\n // but there's a test below checking that it works.\n-pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n+pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n     let Token { kind, span } = t;\n     match kind {\n         token::Ident(name, _) | token::Lifetime(name) => {\n@@ -659,13 +674,14 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n         }\n         token::Interpolated(nt) => {\n             let mut nt = Lrc::make_mut(nt);\n-            vis.visit_interpolated(&mut nt);\n+            visit_interpolated(&mut nt, vis);\n         }\n         _ => {}\n     }\n     vis.visit_span(span);\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n /// Applies the visitor to elements of interpolated nodes.\n //\n // N.B., this can occur only when applying a visitor to partially expanded\n@@ -689,7 +705,7 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n // contain multiple items, but decided against it when I looked at\n // `parse_item_or_view_item` and tried to figure out what I would do with\n // multiple items there....\n-pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T) {\n+pub fn visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T) {\n     match nt {\n         token::NtItem(item) => visit_clobber(item, |item| {\n             // This is probably okay, because the only visitors likely to\n@@ -714,7 +730,7 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n             visit_mac_args(args, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n-        token::NtTT(tt) => vis.visit_tt(tt),\n+        token::NtTT(tt) => visit_tt(tt, vis),\n         token::NtVis(visib) => vis.visit_vis(visib),\n     }\n }"}, {"sha": "1e7001c2b2353e1c1fa90b1854e8079f454c0737", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -318,6 +318,10 @@ impl TokenStream {\n         }\n     }\n \n+    pub fn trees_ref(&self) -> CursorRef<'_> {\n+        CursorRef::new(self)\n+    }\n+\n     pub fn trees(&self) -> Cursor {\n         self.clone().into_trees()\n     }\n@@ -408,6 +412,36 @@ impl TokenStreamBuilder {\n     }\n }\n \n+/// By-reference iterator over a `TokenStream`.\n+#[derive(Clone)]\n+pub struct CursorRef<'t> {\n+    stream: &'t TokenStream,\n+    index: usize,\n+}\n+\n+impl<'t> CursorRef<'t> {\n+    fn new(stream: &TokenStream) -> CursorRef<'_> {\n+        CursorRef { stream, index: 0 }\n+    }\n+\n+    fn next_with_spacing(&mut self) -> Option<&'t TreeAndSpacing> {\n+        self.stream.0.get(self.index).map(|tree| {\n+            self.index += 1;\n+            tree\n+        })\n+    }\n+}\n+\n+impl<'t> Iterator for CursorRef<'t> {\n+    type Item = &'t TokenTree;\n+\n+    fn next(&mut self) -> Option<&'t TokenTree> {\n+        self.next_with_spacing().map(|(tree, _)| tree)\n+    }\n+}\n+\n+/// Owning by-value iterator over a `TokenStream`.\n+/// FIXME: Many uses of this can be replaced with by-reference iterator to avoid clones.\n #[derive(Clone)]\n pub struct Cursor {\n     pub stream: TokenStream,"}, {"sha": "2ab6667ac3cf1210e8725aa8ec6e3d783b555c37", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -14,8 +14,8 @@\n //! those that are created by the expansion of a macro.\n \n use crate::ast::*;\n-use crate::token::Token;\n-use crate::tokenstream::{TokenStream, TokenTree};\n+use crate::token;\n+use crate::tokenstream::TokenTree;\n \n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -208,14 +208,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_attribute(&mut self, attr: &'ast Attribute) {\n         walk_attribute(self, attr)\n     }\n-    fn visit_tt(&mut self, tt: TokenTree) {\n-        walk_tt(self, tt)\n-    }\n-    fn visit_tts(&mut self, tts: TokenStream) {\n-        walk_tts(self, tts)\n-    }\n-    fn visit_token(&mut self, _t: Token) {}\n-    // FIXME: add `visit_interpolated` and `walk_interpolated`\n     fn visit_vis(&mut self, vis: &'ast Visibility) {\n         walk_vis(self, vis)\n     }\n@@ -902,20 +894,19 @@ pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute)\n pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n     match args {\n         MacArgs::Empty => {}\n-        MacArgs::Delimited(_dspan, _delim, tokens) => visitor.visit_tts(tokens.clone()),\n-        MacArgs::Eq(_eq_span, tokens) => visitor.visit_tts(tokens.clone()),\n-    }\n-}\n-\n-pub fn walk_tt<'a, V: Visitor<'a>>(visitor: &mut V, tt: TokenTree) {\n-    match tt {\n-        TokenTree::Token(token) => visitor.visit_token(token),\n-        TokenTree::Delimited(_, _, tts) => visitor.visit_tts(tts),\n-    }\n-}\n-\n-pub fn walk_tts<'a, V: Visitor<'a>>(visitor: &mut V, tts: TokenStream) {\n-    for tt in tts.trees() {\n-        visitor.visit_tt(tt);\n+        MacArgs::Delimited(_dspan, _delim, _tokens) => {}\n+        // The value in `#[key = VALUE]` must be visited as an expression for backward\n+        // compatibility, so that macros can be expanded in that position.\n+        MacArgs::Eq(_eq_span, tokens) => match tokens.trees_ref().next() {\n+            Some(TokenTree::Token(token)) => match &token.kind {\n+                token::Interpolated(nt) => match &**nt {\n+                    token::NtExpr(expr) => visitor.visit_expr(expr),\n+                    t => panic!(\"unexpected token in key-value attribute: {:?}\", t),\n+                },\n+                token::Literal(..) | token::Ident(..) => {}\n+                t => panic!(\"unexpected token in key-value attribute: {:?}\", t),\n+            },\n+            t => panic!(\"unexpected token in key-value attribute: {:?}\", t),\n+        },\n     }\n }"}, {"sha": "629e0e702b6541366a2d088921d35ac89c3913ef", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -20,6 +20,10 @@ use std::mem;\n struct Marker(ExpnId, Transparency);\n \n impl MutVisitor for Marker {\n+    fn token_visiting_enabled(&self) -> bool {\n+        true\n+    }\n+\n     fn visit_span(&mut self, span: &mut Span) {\n         *span = span.apply_mark(self.0, self.1)\n     }\n@@ -277,7 +281,7 @@ pub(super) fn transcribe<'a>(\n             // preserve syntax context.\n             mbe::TokenTree::Token(token) => {\n                 let mut tt = TokenTree::Token(token);\n-                marker.visit_tt(&mut tt);\n+                mut_visit::visit_tt(&mut tt, &mut marker);\n                 result.push(tt.into());\n             }\n "}, {"sha": "9e65fc2eca7397efd6f49d8853007df63777c90a", "filename": "compiler/rustc_expand/src/mut_visit/tests.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -15,6 +15,9 @@ fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {\n struct ToZzIdentMutVisitor;\n \n impl MutVisitor for ToZzIdentMutVisitor {\n+    fn token_visiting_enabled(&self) -> bool {\n+        true\n+    }\n     fn visit_ident(&mut self, ident: &mut Ident) {\n         *ident = Ident::from_str(\"zz\");\n     }"}, {"sha": "83016ed36a7293ead6e8f0f163998371db29fcbc", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -15,7 +15,6 @@ use crate::{\n };\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n \n-use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use rustc_ast::{AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n@@ -1395,16 +1394,6 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         visit::walk_assoc_item(self, item, ctxt);\n     }\n \n-    fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt) = t.kind {\n-            if let token::NtExpr(ref expr) = *nt {\n-                if let ast::ExprKind::MacCall(..) = expr.kind {\n-                    self.visit_invoc(expr.id);\n-                }\n-            }\n-        }\n-    }\n-\n     fn visit_attribute(&mut self, attr: &'b ast::Attribute) {\n         if !attr.is_doc_comment() && attr::is_builtin_attr(attr) {\n             self.r"}, {"sha": "69773ba1d72215b1139483c81a436ad840412524", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -1,5 +1,4 @@\n use crate::Resolver;\n-use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, FnKind};\n use rustc_ast::walk_list;\n use rustc_ast::*;\n@@ -256,16 +255,6 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n         }\n     }\n \n-    fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt) = t.kind {\n-            if let token::NtExpr(ref expr) = *nt {\n-                if let ExprKind::MacCall(..) = expr.kind {\n-                    self.visit_macro_invoc(expr.id);\n-                }\n-            }\n-        }\n-    }\n-\n     fn visit_arm(&mut self, arm: &'a Arm) {\n         if arm.is_placeholder { self.visit_macro_invoc(arm.id) } else { visit::walk_arm(self, arm) }\n     }"}, {"sha": "2edeb81011af9fb78597b4d92e4a24bab286745c", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 49, "deletions": 57, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -2275,64 +2275,56 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[cfg(target_pointer_width = \"16\")]\n-macro_rules! ptr_width {\n-    () => {\n-        2\n-    };\n-}\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[cfg(target_pointer_width = \"32\")]\n-macro_rules! ptr_width {\n-    () => {\n-        4\n-    };\n-}\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[cfg(target_pointer_width = \"64\")]\n-macro_rules! ptr_width {\n-    () => {\n-        8\n-    };\n-}\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-atomic_int! {\n-    cfg(target_has_atomic = \"ptr\"),\n-    cfg(target_has_atomic_equal_alignment = \"ptr\"),\n-    stable(feature = \"rust1\", since = \"1.0.0\"),\n-    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n-    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n-    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n-    stable(feature = \"atomic_from\", since = \"1.23.0\"),\n-    stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    stable(feature = \"rust1\", since = \"1.0.0\"),\n-    \"isize\", \"../../../std/primitive.isize.html\",\n-    \"\",\n-    atomic_min, atomic_max,\n-    ptr_width!(),\n-    \"AtomicIsize::new(0)\",\n-    isize AtomicIsize ATOMIC_ISIZE_INIT\n+\n+macro_rules! atomic_int_ptr_sized {\n+    ( $($target_pointer_width:literal $align:literal)* ) => { $(\n+        #[cfg(target_has_atomic_load_store = \"ptr\")]\n+        #[cfg(target_pointer_width = $target_pointer_width)]\n+        atomic_int! {\n+            cfg(target_has_atomic = \"ptr\"),\n+            cfg(target_has_atomic_equal_alignment = \"ptr\"),\n+            stable(feature = \"rust1\", since = \"1.0.0\"),\n+            stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n+            stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n+            stable(feature = \"atomic_access\", since = \"1.15.0\"),\n+            stable(feature = \"atomic_from\", since = \"1.23.0\"),\n+            stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n+            rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+            stable(feature = \"rust1\", since = \"1.0.0\"),\n+            \"isize\", \"../../../std/primitive.isize.html\",\n+            \"\",\n+            atomic_min, atomic_max,\n+            $align,\n+            \"AtomicIsize::new(0)\",\n+            isize AtomicIsize ATOMIC_ISIZE_INIT\n+        }\n+        #[cfg(target_has_atomic_load_store = \"ptr\")]\n+        #[cfg(target_pointer_width = $target_pointer_width)]\n+        atomic_int! {\n+            cfg(target_has_atomic = \"ptr\"),\n+            cfg(target_has_atomic_equal_alignment = \"ptr\"),\n+            stable(feature = \"rust1\", since = \"1.0.0\"),\n+            stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n+            stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n+            stable(feature = \"atomic_access\", since = \"1.15.0\"),\n+            stable(feature = \"atomic_from\", since = \"1.23.0\"),\n+            stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n+            rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+            stable(feature = \"rust1\", since = \"1.0.0\"),\n+            \"usize\", \"../../../std/primitive.usize.html\",\n+            \"\",\n+            atomic_umin, atomic_umax,\n+            $align,\n+            \"AtomicUsize::new(0)\",\n+            usize AtomicUsize ATOMIC_USIZE_INIT\n+        }\n+    )* };\n }\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-atomic_int! {\n-    cfg(target_has_atomic = \"ptr\"),\n-    cfg(target_has_atomic_equal_alignment = \"ptr\"),\n-    stable(feature = \"rust1\", since = \"1.0.0\"),\n-    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n-    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n-    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n-    stable(feature = \"atomic_from\", since = \"1.23.0\"),\n-    stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    stable(feature = \"rust1\", since = \"1.0.0\"),\n-    \"usize\", \"../../../std/primitive.usize.html\",\n-    \"\",\n-    atomic_umin, atomic_umax,\n-    ptr_width!(),\n-    \"AtomicUsize::new(0)\",\n-    usize AtomicUsize ATOMIC_USIZE_INIT\n+\n+atomic_int_ptr_sized! {\n+    \"16\" 2\n+    \"32\" 4\n+    \"64\" 8\n }\n \n #[inline]"}, {"sha": "b4eb80bb51649a1fccb2e9396b8a127ea3b88a05", "filename": "src/test/ui/attributes/auxiliary/key-value-expansion.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fauxiliary%2Fkey-value-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fauxiliary%2Fkey-value-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fauxiliary%2Fkey-value-expansion.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_derive(EthabiContract, attributes(ethabi_contract_options))]\n+pub fn ethabi_derive(input: TokenStream) -> TokenStream {\n+    Default::default()\n+}"}, {"sha": "831c8091f32f1511db13097f67dbf79ee84a7d55", "filename": "src/test/ui/attributes/key-value-expansion.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,55 @@\n+// Regression tests for issue #55414, expansion happens in the value of a key-value attribute,\n+// and the expanded expression is more complex than simply a macro call.\n+\n+// aux-build:key-value-expansion.rs\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate key_value_expansion;\n+\n+// Minimized test case.\n+\n+macro_rules! bug {\n+    ($expr:expr) => {\n+        #[rustc_dummy = $expr] // Any key-value attribute, not necessarily `doc`\n+        //~^ ERROR unexpected token: `(7u32)`\n+        struct S;\n+    };\n+}\n+\n+// Any expressions containing macro call `X` that's more complex than `X` itself.\n+// Parentheses will work.\n+bug!((column!()));\n+\n+// Original test case.\n+\n+macro_rules! bug {\n+    () => {\n+        bug!(\"bug\" + stringify!(found));\n+    };\n+    ($test:expr) => {\n+        #[doc = $test] //~ ERROR unexpected token: `\"bug\" + \"found\"`\n+        struct Test {}\n+    };\n+}\n+\n+bug!();\n+\n+// Test case from #66804.\n+\n+macro_rules! doc_comment {\n+    ($x:expr) => {\n+        #[doc = $x] //~ ERROR unexpected token: `{\n+        extern {}\n+    };\n+}\n+\n+macro_rules! some_macro {\n+    ($t1: ty) => {\n+        doc_comment! {format!(\"{coor}\", coor = stringify!($t1)).as_str()}\n+    };\n+}\n+\n+some_macro!(u8);\n+\n+fn main() {}"}, {"sha": "5da4557f0ae015382e131fcf6c453f3f4256835b", "filename": "src/test/ui/attributes/key-value-expansion.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,44 @@\n+error: unexpected token: `(7u32)`\n+  --> $DIR/key-value-expansion.rs:14:25\n+   |\n+LL |         #[rustc_dummy = $expr] // Any key-value attribute, not necessarily `doc`\n+   |                         ^^^^^\n+...\n+LL | bug!((column!()));\n+   | ------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unexpected token: `\"bug\" + \"found\"`\n+  --> $DIR/key-value-expansion.rs:31:17\n+   |\n+LL |         #[doc = $test]\n+   |                 ^^^^^\n+...\n+LL | bug!();\n+   | ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unexpected token: `{\n+    let res =\n+        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[\"\"],\n+                                                            &match (&\"u8\",) {\n+                                                                 (arg0,) =>\n+                                                                 [::core::fmt::ArgumentV1::new(arg0,\n+                                                                                               ::core::fmt::Display::fmt)],\n+                                                             }));\n+    res\n+}.as_str()`\n+  --> $DIR/key-value-expansion.rs:42:17\n+   |\n+LL |         #[doc = $x]\n+   |                 ^^\n+...\n+LL | some_macro!(u8);\n+   | ---------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b4f523936a0b0a9ccf4f36555a9a1a200ac57706", "filename": "src/test/ui/attributes/nonterminal-expansion.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fnonterminal-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fnonterminal-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fnonterminal-expansion.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,17 @@\n+// Macros were previously expanded in `Expr` nonterminal tokens, now they are not.\n+\n+macro_rules! pass_nonterminal {\n+    ($n:expr) => {\n+        #[repr(align($n))] //~ ERROR expected unsuffixed literal or identifier, found `n!()`\n+                           //~| ERROR unrecognized representation hint\n+        struct S;\n+    };\n+}\n+\n+macro_rules! n {\n+    () => { 32 };\n+}\n+\n+pass_nonterminal!(n!());\n+\n+fn main() {}"}, {"sha": "9f7f185f94752820aaff5e29c0af40bdb075d452", "filename": "src/test/ui/attributes/nonterminal-expansion.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fnonterminal-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fattributes%2Fnonterminal-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fnonterminal-expansion.stderr?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,25 @@\n+error: expected unsuffixed literal or identifier, found `n!()`\n+  --> $DIR/nonterminal-expansion.rs:5:22\n+   |\n+LL |         #[repr(align($n))]\n+   |                      ^^\n+...\n+LL | pass_nonterminal!(n!());\n+   | ------------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0552]: unrecognized representation hint\n+  --> $DIR/nonterminal-expansion.rs:5:16\n+   |\n+LL |         #[repr(align($n))]\n+   |                ^^^^^^^^^\n+...\n+LL | pass_nonterminal!(n!());\n+   | ------------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0552`."}, {"sha": "408eaffccf7d9e403525a561c85af2c6fe330483", "filename": "src/test/ui/conditional-compilation/cfg-attr-syntax-validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -29,6 +29,7 @@ macro_rules! generate_s10 {\n     ($expr: expr) => {\n         #[cfg(feature = $expr)]\n         //~^ ERROR expected unsuffixed literal or identifier, found `concat!(\"nonexistent\")`\n+        //~| ERROR expected unsuffixed literal or identifier, found `concat!(\"nonexistent\")`\n         struct S10;\n     }\n }"}, {"sha": "8ae2ff16a2b4fcd829221de41257599b69021228", "filename": "src/test/ui/conditional-compilation/cfg-attr-syntax-validation.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -63,7 +63,18 @@ LL | generate_s10!(concat!(\"nonexistent\"));\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 10 previous errors\n+error: expected unsuffixed literal or identifier, found `concat!(\"nonexistent\")`\n+  --> $DIR/cfg-attr-syntax-validation.rs:30:25\n+   |\n+LL |         #[cfg(feature = $expr)]\n+   |                         ^^^^^\n+...\n+LL | generate_s10!(concat!(\"nonexistent\"));\n+   | -------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 11 previous errors\n \n Some errors have detailed explanations: E0537, E0565.\n For more information about an error, try `rustc --explain E0537`."}, {"sha": "57a7ffa39ef006ce96316355ece52b3882c01341", "filename": "src/test/ui/proc-macro/auxiliary/test-macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -112,6 +112,12 @@ pub fn print_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n     print_helper(input, \"ATTR\")\n }\n \n+#[proc_macro_attribute]\n+pub fn print_attr_args(args: TokenStream, input: TokenStream) -> TokenStream {\n+    print_helper(args, \"ATTR_ARGS\");\n+    input\n+}\n+\n #[proc_macro_derive(Print, attributes(print_helper))]\n pub fn print_derive(input: TokenStream) -> TokenStream {\n     print_helper(input, \"DERIVE\");"}, {"sha": "e6215587153c4ce79135c8f80473dbe538f73871", "filename": "src/test/ui/proc-macro/nonterminal-expansion.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.rs?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// compile-flags: -Z span-debug\n+// aux-build:test-macros.rs\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+macro_rules! pass_nonterminal {\n+    ($line:expr) => {\n+        #[print_attr_args(a, $line, b)]\n+        struct S;\n+    };\n+}\n+\n+// `line!()` is not expanded before it's passed to the proc macro.\n+pass_nonterminal!(line!());\n+\n+// Test case from #43860.\n+\n+#[macro_export]\n+macro_rules! use_contract {\n+    ($name: ident, $path: expr) => {\n+        #[derive(Empty)]\n+        #[empty_helper(path = $path)] // OK\n+        pub struct $name<T, C> {\n+            api: T,\n+            contract: C,\n+        }\n+    };\n+}\n+\n+use_contract!(ContractName, file!());\n+\n+fn main() {}"}, {"sha": "4522dc14b9f2d024b41a9ed6e5413448d3577953", "filename": "src/test/ui/proc-macro/nonterminal-expansion.stdout", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c5e099a3b1f1c6ad53115189c2710495588b3/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-expansion.stdout?ref=4c0c5e099a3b1f1c6ad53115189c2710495588b3", "patch": "@@ -0,0 +1,42 @@\n+PRINT-ATTR_ARGS INPUT (DISPLAY): a, line!(), b\n+PRINT-ATTR_ARGS RE-COLLECTED (DISPLAY): a, line ! (), b\n+PRINT-ATTR_ARGS INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"a\",\n+        span: $DIR/nonterminal-expansion.rs:13:27: 13:28 (#4),\n+    },\n+    Punct {\n+        ch: ',',\n+        spacing: Alone,\n+        span: $DIR/nonterminal-expansion.rs:13:28: 13:29 (#4),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"line\",\n+                span: $DIR/nonterminal-expansion.rs:19:19: 19:23 (#0),\n+            },\n+            Punct {\n+                ch: '!',\n+                spacing: Alone,\n+                span: $DIR/nonterminal-expansion.rs:19:23: 19:24 (#0),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [],\n+                span: $DIR/nonterminal-expansion.rs:19:24: 19:26 (#0),\n+            },\n+        ],\n+        span: $DIR/nonterminal-expansion.rs:13:30: 13:35 (#4),\n+    },\n+    Punct {\n+        ch: ',',\n+        spacing: Alone,\n+        span: $DIR/nonterminal-expansion.rs:13:35: 13:36 (#4),\n+    },\n+    Ident {\n+        ident: \"b\",\n+        span: $DIR/nonterminal-expansion.rs:13:37: 13:38 (#4),\n+    },\n+]"}]}