{"sha": "a833fba98aaa728b16d23db3da04c624601b0751", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MzNmYmE5OGFhYTcyOGIxNmQyM2RiM2RhMDRjNjI0NjAxYjA3NTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-30T07:53:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-30T07:58:39Z"}, "message": "internal: don't shut up the compiler when it says the code's buggy\n\nWrapping state-modifying functions into a `catch_unwind` is wrong -- to\ndo retry after failure, you need to have transactional semantics!", "tree": {"sha": "d559169a9cd6cf3987c49286dfd301a3802d902f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d559169a9cd6cf3987c49286dfd301a3802d902f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a833fba98aaa728b16d23db3da04c624601b0751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a833fba98aaa728b16d23db3da04c624601b0751", "html_url": "https://github.com/rust-lang/rust/commit/a833fba98aaa728b16d23db3da04c624601b0751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a833fba98aaa728b16d23db3da04c624601b0751/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a055a6b1fc44602ab346a0f2f984674931a8456", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a055a6b1fc44602ab346a0f2f984674931a8456", "html_url": "https://github.com/rust-lang/rust/commit/3a055a6b1fc44602ab346a0f2f984674931a8456"}], "stats": {"total": 153, "additions": 96, "deletions": 57}, "files": [{"sha": "58950c2d30cefd7cfc7c68e0f95a932f2fae54d7", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 89, "deletions": 46, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/a833fba98aaa728b16d23db3da04c624601b0751/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a833fba98aaa728b16d23db3da04c624601b0751/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=a833fba98aaa728b16d23db3da04c624601b0751", "patch": "@@ -1,4 +1,4 @@\n-//! A visitor for downcasting arbitrary request (JSON) into a specific type.\n+//! See [RequestDispatcher].\n use std::{fmt, panic, thread};\n \n use serde::{de::DeserializeOwned, Serialize};\n@@ -10,14 +10,30 @@ use crate::{\n     LspError, Result,\n };\n \n+/// A visitor for routing a raw JSON request to an appropriate handler function.\n+///\n+/// Most requests are read-only and async and are handled on the threadpool\n+/// (`on` method).\n+///\n+/// Some read-only requests are latency sensitive, and are immediately handled\n+/// on the main loop thread (`on_sync`). These are typically typing-related\n+/// requests.\n+///\n+/// Some requests modify the state, and are run on the main thread to get\n+/// `&mut` (`on_sync_mut`).\n+///\n+/// Read-only requests are wrapped into `catch_unwind` -- they don't modify the\n+/// state, so it's OK to recover from their failures.\n pub(crate) struct RequestDispatcher<'a> {\n     pub(crate) req: Option<lsp_server::Request>,\n     pub(crate) global_state: &'a mut GlobalState,\n }\n \n impl<'a> RequestDispatcher<'a> {\n-    /// Dispatches the request onto the current thread\n-    pub(crate) fn on_sync<R>(\n+    /// Dispatches the request onto the current thread, given full access to\n+    /// mutable global state. Unlike all other methods here, this one isn't\n+    /// guarded by `catch_unwind`, so, please, don't make bugs :-)\n+    pub(crate) fn on_sync_mut<R>(\n         &mut self,\n         f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n     ) -> Result<&mut Self>\n@@ -26,26 +42,40 @@ impl<'a> RequestDispatcher<'a> {\n         R::Params: DeserializeOwned + panic::UnwindSafe + fmt::Debug + 'static,\n         R::Result: Serialize + 'static,\n     {\n-        let (id, params) = match self.parse::<R>() {\n+        let (id, params, panic_context) = match self.parse::<R>() {\n             Some(it) => it,\n             None => return Ok(self),\n         };\n-        let global_state = panic::AssertUnwindSafe(&mut *self.global_state);\n+        let _pctx = stdx::panic_context::enter(panic_context);\n+\n+        let result = f(&mut self.global_state, params);\n+        let response = result_to_response::<R>(id, result);\n+\n+        self.global_state.respond(response);\n+        Ok(self)\n+    }\n+\n+    /// Dispatches the request onto the current thread.\n+    pub(crate) fn on_sync<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + fmt::Debug + 'static,\n+        R::Result: Serialize + 'static,\n+    {\n+        let (id, params, panic_context) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => return Ok(self),\n+        };\n+        let global_state_snapshot = self.global_state.snapshot();\n \n         let result = panic::catch_unwind(move || {\n-            // Make sure that the whole AssertUnwindSafe is moved into the\n-            // closure, and not just its field.\n-            let panic::AssertUnwindSafe(global_state) = { global_state };\n-\n-            let _pctx = stdx::panic_context::enter(format!(\n-                \"\\nversion: {}\\nrequest: {} {:#?}\",\n-                env!(\"REV\"),\n-                R::METHOD,\n-                params\n-            ));\n-            f(global_state, params)\n+            let _pctx = stdx::panic_context::enter(panic_context);\n+            f(global_state_snapshot, params)\n         });\n-        let response = result_to_response::<R>(id, result);\n+        let response = thread_result_to_response::<R>(id, result);\n \n         self.global_state.respond(response);\n         Ok(self)\n@@ -61,7 +91,7 @@ impl<'a> RequestDispatcher<'a> {\n         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug + 'static,\n         R::Result: Serialize + 'static,\n     {\n-        let (id, params) = match self.parse::<R>() {\n+        let (id, params, panic_context) = match self.parse::<R>() {\n             Some(it) => it,\n             None => return self,\n         };\n@@ -70,15 +100,10 @@ impl<'a> RequestDispatcher<'a> {\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = panic::catch_unwind(move || {\n-                    let _pctx = stdx::panic_context::enter(format!(\n-                        \"\\nversion: {}\\nrequest: {} {:#?}\",\n-                        env!(\"REV\"),\n-                        R::METHOD,\n-                        params\n-                    ));\n+                    let _pctx = stdx::panic_context::enter(panic_context);\n                     f(world, params)\n                 });\n-                let response = result_to_response::<R>(id, result);\n+                let response = thread_result_to_response::<R>(id, result);\n                 Task::Response(response)\n             }\n         });\n@@ -98,10 +123,10 @@ impl<'a> RequestDispatcher<'a> {\n         }\n     }\n \n-    fn parse<R>(&mut self) -> Option<(lsp_server::RequestId, R::Params)>\n+    fn parse<R>(&mut self) -> Option<(lsp_server::RequestId, R::Params, String)>\n     where\n         R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + 'static,\n+        R::Params: DeserializeOwned + fmt::Debug + 'static,\n     {\n         let req = match &self.req {\n             Some(req) if req.method == R::METHOD => self.req.take().unwrap(),\n@@ -110,7 +135,11 @@ impl<'a> RequestDispatcher<'a> {\n \n         let res = crate::from_json(R::METHOD, req.params);\n         match res {\n-            Ok(params) => Some((req.id, params)),\n+            Ok(params) => {\n+                let panic_context =\n+                    format!(\"\\nversion: {}\\nrequest: {} {:#?}\", env!(\"REV\"), R::METHOD, params);\n+                Some((req.id, params, panic_context))\n+            }\n             Err(err) => {\n                 let response = lsp_server::Response::new_err(\n                     req.id,\n@@ -124,7 +153,7 @@ impl<'a> RequestDispatcher<'a> {\n     }\n }\n \n-fn result_to_response<R>(\n+fn thread_result_to_response<R>(\n     id: lsp_server::RequestId,\n     result: thread::Result<Result<R::Result>>,\n ) -> lsp_server::Response\n@@ -134,8 +163,37 @@ where\n     R::Result: Serialize + 'static,\n {\n     match result {\n-        Ok(Ok(resp)) => lsp_server::Response::new_ok(id, &resp),\n-        Ok(Err(e)) => match e.downcast::<LspError>() {\n+        Ok(result) => result_to_response::<R>(id, result),\n+        Err(panic) => {\n+            let mut message = \"server panicked\".to_string();\n+\n+            let panic_message = panic\n+                .downcast_ref::<String>()\n+                .map(String::as_str)\n+                .or_else(|| panic.downcast_ref::<&str>().copied());\n+\n+            if let Some(panic_message) = panic_message {\n+                message.push_str(\": \");\n+                message.push_str(panic_message)\n+            };\n+\n+            lsp_server::Response::new_err(id, lsp_server::ErrorCode::InternalError as i32, message)\n+        }\n+    }\n+}\n+\n+fn result_to_response<R>(\n+    id: lsp_server::RequestId,\n+    result: Result<R::Result>,\n+) -> lsp_server::Response\n+where\n+    R: lsp_types::request::Request + 'static,\n+    R::Params: DeserializeOwned + 'static,\n+    R::Result: Serialize + 'static,\n+{\n+    match result {\n+        Ok(resp) => lsp_server::Response::new_ok(id, &resp),\n+        Err(e) => match e.downcast::<LspError>() {\n             Ok(lsp_error) => lsp_server::Response::new_err(id, lsp_error.code, lsp_error.message),\n             Err(e) => {\n                 if is_cancelled(&*e) {\n@@ -153,21 +211,6 @@ where\n                 }\n             }\n         },\n-        Err(panic) => {\n-            let mut message = \"server panicked\".to_string();\n-\n-            let panic_message = panic\n-                .downcast_ref::<String>()\n-                .map(String::as_str)\n-                .or_else(|| panic.downcast_ref::<&str>().copied());\n-\n-            if let Some(panic_message) = panic_message {\n-                message.push_str(\": \");\n-                message.push_str(panic_message)\n-            };\n-\n-            lsp_server::Response::new_err(id, lsp_server::ErrorCode::InternalError as i32, message)\n-        }\n     }\n }\n "}, {"sha": "be9db7f766cfa3d14d50e56abc01e10be521f12b", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a833fba98aaa728b16d23db3da04c624601b0751/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a833fba98aaa728b16d23db3da04c624601b0751/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a833fba98aaa728b16d23db3da04c624601b0751", "patch": "@@ -520,24 +520,20 @@ impl GlobalState {\n         }\n \n         RequestDispatcher { req: Some(req), global_state: self }\n-            .on_sync::<lsp_ext::ReloadWorkspace>(|s, ()| {\n+            .on_sync_mut::<lsp_ext::ReloadWorkspace>(|s, ()| {\n                 s.fetch_workspaces_request();\n                 s.fetch_workspaces_if_needed();\n                 Ok(())\n             })?\n-            .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n-            .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n-            .on_sync::<lsp_types::request::Shutdown>(|s, ()| {\n+            .on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {\n                 s.shutdown_requested = true;\n                 Ok(())\n             })?\n-            .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n-                handlers::handle_selection_range(s.snapshot(), p)\n-            })?\n-            .on_sync::<lsp_ext::MatchingBrace>(|s, p| {\n-                handlers::handle_matching_brace(s.snapshot(), p)\n-            })?\n-            .on_sync::<lsp_ext::MemoryUsage>(|s, p| handlers::handle_memory_usage(s, p))?\n+            .on_sync_mut::<lsp_ext::MemoryUsage>(|s, p| handlers::handle_memory_usage(s, p))?\n+            .on_sync::<lsp_ext::JoinLines>(handlers::handle_join_lines)?\n+            .on_sync::<lsp_ext::OnEnter>(handlers::handle_on_enter)?\n+            .on_sync::<lsp_types::request::SelectionRangeRequest>(handlers::handle_selection_range)?\n+            .on_sync::<lsp_ext::MatchingBrace>(handlers::handle_matching_brace)?\n             .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n             .on::<lsp_ext::ViewHir>(handlers::handle_view_hir)"}]}