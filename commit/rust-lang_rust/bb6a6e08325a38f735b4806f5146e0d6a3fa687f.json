{"sha": "bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNmE2ZTA4MzI1YTM4ZjczNWI0ODA2ZjUxNDZlMGQ2YTNmYTY4N2Y=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-09T19:02:13Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-09T19:06:48Z"}, "message": "move `ty::List` into a new submodule", "tree": {"sha": "edff8dabccade69e5ac9d0f22d1535ef2b7d5717", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edff8dabccade69e5ac9d0f22d1535ef2b7d5717"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "html_url": "https://github.com/rust-lang/rust/commit/bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb6a6e08325a38f735b4806f5146e0d6a3fa687f/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3", "html_url": "https://github.com/rust-lang/rust/commit/7c59a81a5fcbaaca311f744cd7c68d99bfbb05d3"}], "stats": {"total": 300, "additions": 155, "deletions": 145}, "files": [{"sha": "6427c547a8f295afbed58035d186a354237dab4e", "filename": "src/librustc_middle/ty/list.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/bb6a6e08325a38f735b4806f5146e0d6a3fa687f/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb6a6e08325a38f735b4806f5146e0d6a3fa687f/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "patch": "@@ -0,0 +1,149 @@\n+use crate::arena::Arena;\n+\n+use rustc_serialize::{Encodable, Encoder};\n+\n+use std::cmp::{self, Ordering};\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::mem;\n+use std::ops::Deref;\n+use std::ptr;\n+use std::slice;\n+\n+extern \"C\" {\n+    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n+    /// pointers.\n+    type OpaqueListContents;\n+}\n+\n+/// A wrapper for slices with the additional invariant\n+/// that the slice is interned and no other slice with\n+/// the same contents can exist in the same context.\n+/// This means we can use pointer for both\n+/// equality comparisons and hashing.\n+/// Note: `Slice` was already taken by the `Ty`.\n+#[repr(C)]\n+pub struct List<T> {\n+    len: usize,\n+    data: [T; 0],\n+    opaque: OpaqueListContents,\n+}\n+\n+unsafe impl<T: Sync> Sync for List<T> {}\n+\n+impl<T: Copy> List<T> {\n+    #[inline]\n+    pub(super) fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n+        assert!(!mem::needs_drop::<T>());\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!slice.is_empty());\n+\n+        // Align up the size of the len (usize) field\n+        let align = mem::align_of::<T>();\n+        let align_mask = align - 1;\n+        let offset = mem::size_of::<usize>();\n+        let offset = (offset + align_mask) & !align_mask;\n+\n+        let size = offset + slice.len() * mem::size_of::<T>();\n+\n+        let mem = arena\n+            .dropless\n+            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        unsafe {\n+            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n+            // Write the length\n+            result.len = slice.len();\n+\n+            // Write the elements\n+            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n+            arena_slice.copy_from_slice(slice);\n+\n+            result\n+        }\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for List<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for List<T> {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<T> Ord for List<T>\n+where\n+    T: Ord,\n+{\n+    fn cmp(&self, other: &List<T>) -> Ordering {\n+        if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n+    }\n+}\n+\n+impl<T> PartialOrd for List<T>\n+where\n+    T: PartialOrd,\n+{\n+    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n+        if self == other {\n+            Some(Ordering::Equal)\n+        } else {\n+            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n+        }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for List<T> {\n+    #[inline]\n+    fn eq(&self, other: &List<T>) -> bool {\n+        ptr::eq(self, other)\n+    }\n+}\n+impl<T: Eq> Eq for List<T> {}\n+\n+impl<T> Hash for List<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const List<T>).hash(s)\n+    }\n+}\n+\n+impl<T> Deref for List<T> {\n+    type Target = [T];\n+    #[inline(always)]\n+    fn deref(&self) -> &[T] {\n+        self.as_ref()\n+    }\n+}\n+\n+impl<T> AsRef<[T]> for List<T> {\n+    #[inline(always)]\n+    fn as_ref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a List<T> {\n+    type Item = &'a T;\n+    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    #[inline(always)]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self[..].iter()\n+    }\n+}\n+\n+impl<T> List<T> {\n+    #[inline(always)]\n+    pub fn empty<'a>() -> &'a List<T> {\n+        #[repr(align(64), C)]\n+        struct EmptySlice([u8; 64]);\n+        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n+        assert!(mem::align_of::<T>() <= 64);\n+        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n+    }\n+}"}, {"sha": "ae0951842995d8cf9b34ec40b183246b3a89dc8f", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 145, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bb6a6e08325a38f735b4806f5146e0d6a3fa687f/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb6a6e08325a38f735b4806f5146e0d6a3fa687f/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=bb6a6e08325a38f735b4806f5146e0d6a3fa687f", "patch": "@@ -4,7 +4,6 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n-use crate::arena::Arena;\n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n@@ -43,13 +42,11 @@ use rustc_span::Span;\n use rustc_target::abi::{Align, VariantIdx};\n \n use std::cell::RefCell;\n-use std::cmp::{self, Ordering};\n+use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::ops::Deref;\n use std::ops::Range;\n-use std::slice;\n-use std::{mem, ptr};\n+use std::ptr;\n \n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n@@ -81,6 +78,8 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n+pub use self::list::List;\n+\n pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n@@ -112,6 +111,7 @@ pub mod walk;\n mod context;\n mod diagnostics;\n mod instance;\n+mod list;\n mod structural_impls;\n mod sty;\n \n@@ -663,148 +663,9 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n-\n-pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n-\n-extern \"C\" {\n-    /// A dummy type used to force `List` to be unsized while not requiring references to it be wide\n-    /// pointers.\n-    type OpaqueListContents;\n-}\n-\n-/// A wrapper for slices with the additional invariant\n-/// that the slice is interned and no other slice with\n-/// the same contents can exist in the same context.\n-/// This means we can use pointer for both\n-/// equality comparisons and hashing.\n-/// Note: `Slice` was already taken by the `Ty`.\n-#[repr(C)]\n-pub struct List<T> {\n-    len: usize,\n-    data: [T; 0],\n-    opaque: OpaqueListContents,\n-}\n-\n-unsafe impl<T: Sync> Sync for List<T> {}\n-\n-impl<T: Copy> List<T> {\n-    #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n-        assert!(!mem::needs_drop::<T>());\n-        assert!(mem::size_of::<T>() != 0);\n-        assert!(!slice.is_empty());\n-\n-        // Align up the size of the len (usize) field\n-        let align = mem::align_of::<T>();\n-        let align_mask = align - 1;\n-        let offset = mem::size_of::<usize>();\n-        let offset = (offset + align_mask) & !align_mask;\n-\n-        let size = offset + slice.len() * mem::size_of::<T>();\n-\n-        let mem = arena\n-            .dropless\n-            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n-        unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n-            // Write the length\n-            result.len = slice.len();\n-\n-            // Write the elements\n-            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n-            arena_slice.copy_from_slice(slice);\n-\n-            result\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for List<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (**self).fmt(f)\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for List<T> {\n-    #[inline]\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T> Ord for List<T>\n-where\n-    T: Ord,\n-{\n-    fn cmp(&self, other: &List<T>) -> Ordering {\n-        if self == other { Ordering::Equal } else { <[T] as Ord>::cmp(&**self, &**other) }\n-    }\n-}\n-\n-impl<T> PartialOrd for List<T>\n-where\n-    T: PartialOrd,\n-{\n-    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n-        if self == other {\n-            Some(Ordering::Equal)\n-        } else {\n-            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n-        }\n-    }\n-}\n-\n-impl<T: PartialEq> PartialEq for List<T> {\n-    #[inline]\n-    fn eq(&self, other: &List<T>) -> bool {\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<T: Eq> Eq for List<T> {}\n-\n-impl<T> Hash for List<T> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const List<T>).hash(s)\n-    }\n-}\n-\n-impl<T> Deref for List<T> {\n-    type Target = [T];\n-    #[inline(always)]\n-    fn deref(&self) -> &[T] {\n-        self.as_ref()\n-    }\n-}\n-\n-impl<T> AsRef<[T]> for List<T> {\n-    #[inline(always)]\n-    fn as_ref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a List<T> {\n-    type Item = &'a T;\n-    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n-    #[inline(always)]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self[..].iter()\n-    }\n-}\n-\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n \n-impl<T> List<T> {\n-    #[inline(always)]\n-    pub fn empty<'a>() -> &'a List<T> {\n-        #[repr(align(64), C)]\n-        struct EmptySlice([u8; 64]);\n-        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n-        assert!(mem::align_of::<T>() <= 64);\n-        unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n-    }\n-}\n+pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarPath {"}]}