{"sha": "5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZGI2ZGIxMzYzNzgyZWUyZmE3YWVlODJhM2NmNTY0YzFiM2VjYWY=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-09-21T22:09:11Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-09-21T22:09:11Z"}, "message": "Prevent right-shifting of block comments with bare lines.\n\nLines that didn't start with a comment sigil were returned unchanged in\ncomment::rewrite_comment. Then these unchanged lines were indented in\nMacroBranch::rewrite.", "tree": {"sha": "de17c311297053321a64f7a013b249bc89574353", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de17c311297053321a64f7a013b249bc89574353"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlulbWgACgkQbVYg2Qgh\nATOP/Qf/QkTnl8Q/Re9h+zu5iFLO0CTzwS2dfzTMAB0wmULVIZ5oQpdAXaMuFh6D\nSbLRkM+hyEdK54KC9vwhsDAaaNg2PIaYGHjah0qlUnDhBG8IGOVtdAxPioyiXijB\nHIFU56o+0yiThOIgKCHmd7AIbFZ7FCB5Na6Ae5N5Gogcc0RWyqGDCF4/+vnBU5cO\nhl1oa3eKPIvYvx7Tt2v90QU/9iPRTuZm1k0mtYGFKDpAIuHphKRbEvZDbBa3moPf\nUKbOUYYy8mL71pSiM/o+bXoFLAZL8TXem9dG54prXQBzwQVq/Nh7LxEm/iX31IKb\n3OPi3uySPtlW2fnLm6znx7xNsg2KRA==\n=oU7D\n-----END PGP SIGNATURE-----", "payload": "tree de17c311297053321a64f7a013b249bc89574353\nparent 4568c1a70f64d4ab77f9fd9553d532f0bcbe0d84\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1537567751 +0200\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1537567751 +0200\n\nPrevent right-shifting of block comments with bare lines.\n\nLines that didn't start with a comment sigil were returned unchanged in\ncomment::rewrite_comment. Then these unchanged lines were indented in\nMacroBranch::rewrite.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "html_url": "https://github.com/rust-lang/rust/commit/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4568c1a70f64d4ab77f9fd9553d532f0bcbe0d84", "url": "https://api.github.com/repos/rust-lang/rust/commits/4568c1a70f64d4ab77f9fd9553d532f0bcbe0d84", "html_url": "https://github.com/rust-lang/rust/commit/4568c1a70f64d4ab77f9fd9553d532f0bcbe0d84"}], "stats": {"total": 433, "additions": 345, "deletions": 88}, "files": [{"sha": "60fa7e891f7962455fda94d1e3531054c52904f2", "filename": "src/comment.rs", "status": "modified", "additions": 194, "deletions": 71, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "patch": "@@ -52,6 +52,27 @@ fn custom_opener(s: &str) -> &str {\n }\n \n impl<'a> CommentStyle<'a> {\n+    /// Returns true if the commenting style covers a line only.\n+    pub fn is_line_comment(&self) -> bool {\n+        match *self {\n+            CommentStyle::DoubleSlash\n+            | CommentStyle::TripleSlash\n+            | CommentStyle::Doc\n+            | CommentStyle::Custom(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the commenting style can span over multiple lines.\n+    pub fn is_block_comment(&self) -> bool {\n+        match *self {\n+            CommentStyle::SingleBullet | CommentStyle::DoubleBullet | CommentStyle::Exclamation => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_doc_comment(&self) -> bool {\n         match *self {\n             CommentStyle::TripleSlash | CommentStyle::Doc => true,\n@@ -213,7 +234,7 @@ pub fn combine_strs_with_missing_comments(\n }\n \n pub fn rewrite_doc_comment(orig: &str, shape: Shape, config: &Config) -> Option<String> {\n-    _rewrite_comment(orig, false, shape, config, true)\n+    identify_comment(orig, false, shape, config, true)\n }\n \n pub fn rewrite_comment(\n@@ -222,32 +243,7 @@ pub fn rewrite_comment(\n     shape: Shape,\n     config: &Config,\n ) -> Option<String> {\n-    _rewrite_comment(orig, block_style, shape, config, false)\n-}\n-\n-fn _rewrite_comment(\n-    orig: &str,\n-    block_style: bool,\n-    shape: Shape,\n-    config: &Config,\n-    is_doc_comment: bool,\n-) -> Option<String> {\n-    // If there are lines without a starting sigil, we won't format them correctly\n-    // so in that case we won't even re-align (if !config.normalize_comments()) and\n-    // we should stop now.\n-    let num_bare_lines = orig\n-        .lines()\n-        .map(|line| line.trim())\n-        .filter(|l| !(l.starts_with('*') || l.starts_with(\"//\") || l.starts_with(\"/*\")))\n-        .count();\n-    if num_bare_lines > 0 && !config.normalize_comments() {\n-        return Some(orig.to_owned());\n-    }\n-    if !config.normalize_comments() && !config.wrap_comments() {\n-        return light_rewrite_comment(orig, shape.indent, config, is_doc_comment);\n-    }\n-\n-    identify_comment(orig, block_style, shape, config, is_doc_comment)\n+    identify_comment(orig, block_style, shape, config, false)\n }\n \n fn identify_comment(\n@@ -258,8 +254,8 @@ fn identify_comment(\n     is_doc_comment: bool,\n ) -> Option<String> {\n     let style = comment_style(orig, false);\n-    let mut first_group_ending = 0;\n \n+    // Computes the len of line taking into account a newline if the line is part of a paragraph.\n     fn compute_len(orig: &str, line: &str) -> usize {\n         if orig.len() > line.len() {\n             if orig.as_bytes()[line.len()] == b'\\r' {\n@@ -272,62 +268,145 @@ fn identify_comment(\n         }\n     }\n \n-    match style {\n+    // Get the first group of line comments having the same commenting style.\n+    //\n+    // Returns a tuple with:\n+    // - a boolean indicating if there is a blank line\n+    // - a number indicating the size of the first group of comments\n+    fn consume_same_line_comments(\n+        style: CommentStyle,\n+        orig: &str,\n+        line_start: &str,\n+    ) -> (bool, usize) {\n+        let mut first_group_ending = 0;\n+        let mut hbl = false;\n+\n+        for line in orig.lines() {\n+            let trimmed_line = line.trim_left();\n+            if trimmed_line.is_empty() {\n+                hbl = true;\n+                break;\n+            } else if trimmed_line.starts_with(line_start)\n+                || comment_style(trimmed_line, false) == style\n+            {\n+                first_group_ending += compute_len(&orig[first_group_ending..], line);\n+            } else {\n+                break;\n+            }\n+        }\n+        (hbl, first_group_ending)\n+    }\n+\n+    let (has_bare_lines, first_group_ending) = match style {\n         CommentStyle::DoubleSlash | CommentStyle::TripleSlash | CommentStyle::Doc => {\n             let line_start = style.line_start().trim_left();\n-            for line in orig.lines() {\n-                if line.trim_left().starts_with(line_start) || comment_style(line, false) == style {\n-                    first_group_ending += compute_len(&orig[first_group_ending..], line);\n-                } else {\n-                    break;\n-                }\n-            }\n+            consume_same_line_comments(style, orig, line_start)\n         }\n         CommentStyle::Custom(opener) => {\n             let trimmed_opener = opener.trim_right();\n-            for line in orig.lines() {\n-                if line.trim_left().starts_with(trimmed_opener) {\n-                    first_group_ending += compute_len(&orig[first_group_ending..], line);\n-                } else {\n-                    break;\n-                }\n-            }\n+            consume_same_line_comments(style, orig, trimmed_opener)\n         }\n         // for a block comment, search for the closing symbol\n         CommentStyle::DoubleBullet | CommentStyle::SingleBullet | CommentStyle::Exclamation => {\n             let closer = style.closer().trim_left();\n+            let mut closing_symbol_offset = 0;\n+            let mut hbl = false;\n             for line in orig.lines() {\n-                first_group_ending += compute_len(&orig[first_group_ending..], line);\n-                if line.trim_left().ends_with(closer) {\n+                closing_symbol_offset += compute_len(&orig[closing_symbol_offset..], line);\n+                let trimmed_line = line.trim_left();\n+                if !trimmed_line.starts_with('*')\n+                    && !trimmed_line.starts_with(\"//\")\n+                    && !trimmed_line.starts_with(\"/*\")\n+                {\n+                    hbl = true;\n+                }\n+                if trimmed_line.ends_with(closer) {\n                     break;\n                 }\n             }\n+            (hbl, closing_symbol_offset)\n         }\n-    }\n+    };\n \n     let (first_group, rest) = orig.split_at(first_group_ending);\n-    let first_group_str = rewrite_comment_inner(\n-        first_group,\n-        block_style,\n-        style,\n-        shape,\n-        config,\n-        is_doc_comment || style.is_doc_comment(),\n-    )?;\n+    let rewritten_first_group =\n+        if !config.normalize_comments() && has_bare_lines && style.is_block_comment() {\n+            light_rewrite_block_comment_with_bare_lines(first_group, shape, config)?\n+        } else if !config.normalize_comments() && !config.wrap_comments() {\n+            light_rewrite_comment(first_group, shape.indent, config, is_doc_comment)?\n+        } else {\n+            rewrite_comment_inner(\n+                first_group,\n+                block_style,\n+                style,\n+                shape,\n+                config,\n+                is_doc_comment || style.is_doc_comment(),\n+            )?\n+        };\n     if rest.is_empty() {\n-        Some(first_group_str)\n+        Some(rewritten_first_group)\n     } else {\n-        identify_comment(rest, block_style, shape, config, is_doc_comment).map(|rest_str| {\n-            format!(\n-                \"{}\\n{}{}\",\n-                first_group_str,\n-                shape.indent.to_string(config),\n-                rest_str\n-            )\n-        })\n+        identify_comment(rest.trim_left(), block_style, shape, config, is_doc_comment).map(\n+            |rest_str| {\n+                format!(\n+                    \"{}\\n{}{}{}\",\n+                    rewritten_first_group,\n+                    // insert back the blank line\n+                    if has_bare_lines && style.is_line_comment() {\n+                        \"\\n\"\n+                    } else {\n+                        \"\"\n+                    },\n+                    shape.indent.to_string(config),\n+                    rest_str\n+                )\n+            },\n+        )\n     }\n }\n \n+/// Trims a minimum of leading whitespaces so that the content layout is kept and aligns to indent.\n+fn light_rewrite_block_comment_with_bare_lines(\n+    orig: &str,\n+    shape: Shape,\n+    config: &Config,\n+) -> Option<String> {\n+    let prefix_whitespace_min = orig\n+        .lines()\n+        // skip the line with the starting sigil since the leading whitespace is removed\n+        // otherwise, the minimum would always be zero\n+        .skip(1)\n+        .filter(|line| !line.is_empty())\n+        .map(|line| {\n+            let mut width = 0;\n+            for c in line.chars() {\n+                match c {\n+                    ' ' => width += 1,\n+                    '\\t' => width += config.tab_spaces(),\n+                    _ => break,\n+                }\n+            }\n+            width\n+        })\n+        .min()?;\n+\n+    let indent_str = shape.indent.to_string(config);\n+    let mut lines = orig.lines();\n+    let first_line = lines.next()?;\n+    let rest = lines\n+        .map(|line| {\n+            if line.is_empty() {\n+                line\n+            } else {\n+                &line[prefix_whitespace_min..]\n+            }\n+        })\n+        .collect::<Vec<&str>>()\n+        .join(&format!(\"\\n{}\", indent_str));\n+    Some(format!(\"{}\\n{}{}\", first_line, indent_str, rest))\n+}\n+\n fn rewrite_comment_inner(\n     orig: &str,\n     block_style: bool,\n@@ -1413,26 +1492,29 @@ mod test {\n     #[test]\n     #[rustfmt::skip]\n     fn format_comments() {\n-        let mut config: ::config::Config = Default::default();\n-        config.set().wrap_comments(true);\n-        config.set().normalize_comments(true);\n+        let mut wrap_normalize_config: ::config::Config = Default::default();\n+        wrap_normalize_config.set().wrap_comments(true);\n+        wrap_normalize_config.set().normalize_comments(true);\n+\n+        let mut wrap_config: ::config::Config = Default::default();\n+        wrap_config.set().wrap_comments(true);\n \n         let comment = rewrite_comment(\" //test\",\n                                       true,\n                                       Shape::legacy(100, Indent::new(0, 100)),\n-                                      &config).unwrap();\n+                                      &wrap_normalize_config).unwrap();\n         assert_eq!(\"/* test */\", comment);\n \n         let comment = rewrite_comment(\"// comment on a\",\n                                       false,\n                                       Shape::legacy(10, Indent::empty()),\n-                                      &config).unwrap();\n+                                      &wrap_normalize_config).unwrap();\n         assert_eq!(\"// comment\\n// on a\", comment);\n \n         let comment = rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n                                       false,\n                                       Shape::legacy(60, Indent::new(0, 12)),\n-                                      &config).unwrap();\n+                                      &wrap_normalize_config).unwrap();\n         assert_eq!(\"//  A multi line comment\\n            // between args.\", comment);\n \n         let input = \"// comment\";\n@@ -1441,14 +1523,55 @@ mod test {\n         let comment = rewrite_comment(input,\n                                       true,\n                                       Shape::legacy(9, Indent::new(0, 69)),\n-                                      &config).unwrap();\n+                                      &wrap_normalize_config).unwrap();\n         assert_eq!(expected, comment);\n \n         let comment = rewrite_comment(\"/*   trimmed    */\",\n                                       true,\n                                       Shape::legacy(100, Indent::new(0, 100)),\n-                                      &config).unwrap();\n+                                      &wrap_normalize_config).unwrap();\n         assert_eq!(\"/* trimmed */\", comment);\n+\n+        // check that different comment style are properly recognised\n+        let comment = rewrite_comment(r#\"/// test1\n+                                         /// test2\n+                                         /*\n+                                          * test3\n+                                          */\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"/// test1\\n/// test2\\n// test3\", comment);\n+\n+        // check that the blank line marks the end of a commented paragraph\n+        let comment = rewrite_comment(r#\"// test1\n+\n+                                         // test2\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"// test1\\n\\n// test2\", comment);\n+\n+        // check that the blank line marks the end of a custom-commented paragraph\n+        let comment = rewrite_comment(r#\"//@ test1\n+\n+                                         //@ test2\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"//@ test1\\n\\n//@ test2\", comment);\n+\n+        // check that bare lines are just indented but left unchanged otherwise\n+        let comment = rewrite_comment(r#\"// test1\n+                                         /*\n+                                           a bare line!\n+\n+                                                another bare line!\n+                                          */\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_config).unwrap();\n+        assert_eq!(\"// test1\\n/*\\n a bare line!\\n\\n      another bare line!\\n*/\", comment);\n     }\n \n     // This is probably intended to be a non-test fn, but it is not used. I'm"}, {"sha": "afa9e67c8ab61c32590c8e09ad17dd2b2e9cce69", "filename": "tests/source/issue-2917/packed_simd.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Fsource%2Fissue-2917%2Fpacked_simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Fsource%2Fissue-2917%2Fpacked_simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-2917%2Fpacked_simd.rs?ref=5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "patch": "@@ -0,0 +1,63 @@\n+// rustfmt-wrap_comments: true\n+//! Implements `From` and `Into` for vector types.\n+\n+macro_rules! impl_from_vector {\n+    ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt | $source:ident) => {\n+        impl From<$source> for $id {\n+            #[inline]\n+            fn from(source: $source) -> Self {\n+                fn static_assert_same_number_of_lanes<T, U>()\n+                where\n+                    T: crate::sealed::Simd,\n+                    U: crate::sealed::Simd<LanesType = T::LanesType>,\n+                {\n+                }\n+                use llvm::simd_cast;\n+                static_assert_same_number_of_lanes::<$id, $source>();\n+                Simd(unsafe { simd_cast(source.0) })\n+            }\n+        }\n+\n+        // FIXME: `Into::into` is not inline, but due to\n+                // the blanket impl in `std`, which is not\n+                // marked `default`, we cannot override it here with\n+                // specialization.\n+                /*\n+                impl Into<$id> for $source {\n+                    #[inline]\n+                    fn into(self) -> $id {\n+                        unsafe { simd_cast(self) }\n+                    }\n+                }\n+                */\n+\n+        test_if!{\n+            $test_tt:\n+            interpolate_idents! {\n+                mod [$id _from_ $source] {\n+                    use super::*;\n+                    #[test]\n+                    fn from() {\n+                        assert_eq!($id::lanes(), $source::lanes());\n+                        let source: $source = Default::default();\n+                        let vec: $id = Default::default();\n+\n+                        let e = $id::from(source);\n+                        assert_eq!(e, vec);\n+\n+                        let e: $id = source.into();\n+                        assert_eq!(e, vec);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! impl_from_vectors {\n+    ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt | $($source:ident),*) => {\n+        $(\n+            impl_from_vector!([$elem_ty; $elem_count]: $id | $test_tt | $source);\n+        )*\n+    }\n+}"}, {"sha": "6fb6b12ed31d9c92b483edf6472e65c7b7d8924f", "filename": "tests/target/issue-2896.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Ftarget%2Fissue-2896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Ftarget%2Fissue-2896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2896.rs?ref=5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "patch": "@@ -91,23 +91,23 @@ fn main() {\n \n             let probe = cooccurrences_with_row_sums.probe();\n             /*\n-      // produce the (item, item) collection\n-      let cooccurrences = occurrences\n-        .join_map(&occurrences, |_user, &item_a, &item_b| (item_a, item_b));\n-      // count the occurrences of each item.\n-      let counts = cooccurrences\n-        .map(|(item_a,_)| item_a)\n-        .count();\n-      // produce ((item1, item2), count1, count2, count12) tuples\n-      let cooccurrences_with_counts = cooccurrences\n-        .join_map(&counts, |&item_a, &item_b, &count_item_a| (item_b, (item_a, count_item_a)))\n-        .join_map(&counts, |&item_b, &(item_a, count_item_a), &count_item_b| {\n-          ((item_a, item_b), count_item_a, count_item_b)\n-        });\n-      let probe = cooccurrences_with_counts\n-        .inspect(|x| println!(\"change: {:?}\", x))\n-        .probe();\n-*/\n+                  // produce the (item, item) collection\n+                  let cooccurrences = occurrences\n+                    .join_map(&occurrences, |_user, &item_a, &item_b| (item_a, item_b));\n+                  // count the occurrences of each item.\n+                  let counts = cooccurrences\n+                    .map(|(item_a,_)| item_a)\n+                    .count();\n+                  // produce ((item1, item2), count1, count2, count12) tuples\n+                  let cooccurrences_with_counts = cooccurrences\n+                    .join_map(&counts, |&item_a, &item_b, &count_item_a| (item_b, (item_a, count_item_a)))\n+                    .join_map(&counts, |&item_b, &(item_a, count_item_a), &count_item_b| {\n+                      ((item_a, item_b), count_item_a, count_item_b)\n+                    });\n+                  let probe = cooccurrences_with_counts\n+                    .inspect(|x| println!(\"change: {:?}\", x))\n+                    .probe();\n+            */\n             (input, probe)\n         });\n "}, {"sha": "e81e1e6a5a800a6956fee3416ba78e9f1d9e3a1f", "filename": "tests/target/issue-2917/minimal.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Ftarget%2Fissue-2917%2Fminimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Ftarget%2Fissue-2917%2Fminimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2917%2Fminimal.rs?ref=5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! foo {\n+    () => {\n+        // comment\n+        /*\n+\n+        */\n+    };\n+}"}, {"sha": "59a7090505e8ab6d04ae9a9f74bdafb8eab8af39", "filename": "tests/target/issue-2917/packed_simd.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Ftarget%2Fissue-2917%2Fpacked_simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf/tests%2Ftarget%2Fissue-2917%2Fpacked_simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2917%2Fpacked_simd.rs?ref=5fdb6db1363782ee2fa7aee82a3cf564c1b3ecaf", "patch": "@@ -0,0 +1,63 @@\n+// rustfmt-wrap_comments: true\n+//! Implements `From` and `Into` for vector types.\n+\n+macro_rules! impl_from_vector {\n+    ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt | $source:ident) => {\n+        impl From<$source> for $id {\n+            #[inline]\n+            fn from(source: $source) -> Self {\n+                fn static_assert_same_number_of_lanes<T, U>()\n+                where\n+                    T: crate::sealed::Simd,\n+                    U: crate::sealed::Simd<LanesType = T::LanesType>,\n+                {\n+                }\n+                use llvm::simd_cast;\n+                static_assert_same_number_of_lanes::<$id, $source>();\n+                Simd(unsafe { simd_cast(source.0) })\n+            }\n+        }\n+\n+        // FIXME: `Into::into` is not inline, but due to\n+        // the blanket impl in `std`, which is not\n+        // marked `default`, we cannot override it here with\n+        // specialization.\n+        /*\n+        impl Into<$id> for $source {\n+            #[inline]\n+            fn into(self) -> $id {\n+                unsafe { simd_cast(self) }\n+            }\n+        }\n+        */\n+\n+        test_if!{\n+            $test_tt:\n+            interpolate_idents! {\n+                mod [$id _from_ $source] {\n+                    use super::*;\n+                    #[test]\n+                    fn from() {\n+                        assert_eq!($id::lanes(), $source::lanes());\n+                        let source: $source = Default::default();\n+                        let vec: $id = Default::default();\n+\n+                        let e = $id::from(source);\n+                        assert_eq!(e, vec);\n+\n+                        let e: $id = source.into();\n+                        assert_eq!(e, vec);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! impl_from_vectors {\n+    ([$elem_ty:ident; $elem_count:expr]: $id:ident | $test_tt:tt | $($source:ident),*) => {\n+        $(\n+            impl_from_vector!([$elem_ty; $elem_count]: $id | $test_tt | $source);\n+        )*\n+    }\n+}"}]}