{"sha": "e7485a04169f79c63333f2b0d39e159d10b92cee", "node_id": "C_kwDOAAsO6NoAKGU3NDg1YTA0MTY5Zjc5YzYzMzMzZjJiMGQzOWUxNTlkMTBiOTJjZWU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T19:41:17Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T19:43:13Z"}, "message": "Diagnose unresolved method calls", "tree": {"sha": "76d910205d8b11fe51a7eaa27926c3d1d7c68edb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76d910205d8b11fe51a7eaa27926c3d1d7c68edb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7485a04169f79c63333f2b0d39e159d10b92cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7485a04169f79c63333f2b0d39e159d10b92cee", "html_url": "https://github.com/rust-lang/rust/commit/e7485a04169f79c63333f2b0d39e159d10b92cee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7485a04169f79c63333f2b0d39e159d10b92cee/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78b2dd813a927012328bf870d680fe952c8157b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b2dd813a927012328bf870d680fe952c8157b9", "html_url": "https://github.com/rust-lang/rust/commit/78b2dd813a927012328bf870d680fe952c8157b9"}], "stats": {"total": 368, "additions": 320, "deletions": 48}, "files": [{"sha": "22dcea8fcd4518f001adfd8b68270b882d0a499e", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -164,14 +164,45 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n-    NoSuchField { expr: ExprId },\n-    PrivateField { expr: ExprId, field: FieldId },\n-    PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n-    UnresolvedField { expr: ExprId, receiver: Ty, name: Name, method_with_same_name_exists: bool },\n+    NoSuchField {\n+        expr: ExprId,\n+    },\n+    PrivateField {\n+        expr: ExprId,\n+        field: FieldId,\n+    },\n+    PrivateAssocItem {\n+        id: ExprOrPatId,\n+        item: AssocItemId,\n+    },\n+    UnresolvedField {\n+        expr: ExprId,\n+        receiver: Ty,\n+        name: Name,\n+        method_with_same_name_exists: bool,\n+    },\n+    UnresolvedMethodCall {\n+        expr: ExprId,\n+        receiver: Ty,\n+        name: Name,\n+        /// Contains the type the field resolves to\n+        field_with_same_name: Option<Ty>,\n+    },\n     // FIXME: Make this proper\n-    BreakOutsideOfLoop { expr: ExprId, is_break: bool, bad_value_break: bool },\n-    MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n-    ExpectedFunction { call_expr: ExprId, found: Ty },\n+    BreakOutsideOfLoop {\n+        expr: ExprId,\n+        is_break: bool,\n+        bad_value_break: bool,\n+    },\n+    MismatchedArgCount {\n+        call_expr: ExprId,\n+        expected: usize,\n+        found: usize,\n+    },\n+    ExpectedFunction {\n+        call_expr: ExprId,\n+        found: Ty,\n+    },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -509,12 +540,28 @@ impl<'a> InferenceContext<'a> {\n         }\n         result.diagnostics.retain_mut(|diagnostic| {\n             if let InferenceDiagnostic::ExpectedFunction { found: ty, .. }\n-            | InferenceDiagnostic::UnresolvedField { receiver: ty, .. } = diagnostic\n+            | InferenceDiagnostic::UnresolvedField { receiver: ty, .. }\n+            | InferenceDiagnostic::UnresolvedMethodCall { receiver: ty, .. } = diagnostic\n             {\n                 *ty = table.resolve_completely(ty.clone());\n+                // FIXME: Remove this when we are on par with rustc in terms of inference\n                 if ty.is_unknown() {\n                     return false;\n                 }\n+\n+                if let InferenceDiagnostic::UnresolvedMethodCall { field_with_same_name, .. } =\n+                    diagnostic\n+                {\n+                    let clear = if let Some(ty) = field_with_same_name {\n+                        *ty = table.resolve_completely(ty.clone());\n+                        ty.is_unknown()\n+                    } else {\n+                        false\n+                    };\n+                    if clear {\n+                        *field_with_same_name = None;\n+                    }\n+                }\n             }\n             true\n         });"}, {"sha": "02024e1ea780e8c0c48f05f9f7bc97aa99b630e1", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 83, "deletions": 38, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -1212,12 +1212,14 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn infer_field_access(&mut self, tgt_expr: ExprId, expr: ExprId, name: &Name) -> Ty {\n-        let receiver_ty = self.infer_expr_inner(expr, &Expectation::none());\n-\n+    fn lookup_field(\n+        &mut self,\n+        receiver_ty: &Ty,\n+        name: &Name,\n+    ) -> Option<(Ty, Option<FieldId>, Vec<Adjustment>, bool)> {\n         let mut autoderef = Autoderef::new(&mut self.table, receiver_ty.clone());\n         let mut private_field = None;\n-        let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n+        let res = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n             let (field_id, parameters) = match derefed_ty.kind(Interner) {\n                 TyKind::Tuple(_, substs) => {\n                     return name.as_tuple_index().and_then(|idx| {\n@@ -1226,6 +1228,7 @@ impl<'a> InferenceContext<'a> {\n                             .get(idx)\n                             .map(|a| a.assert_ty_ref(Interner))\n                             .cloned()\n+                            .map(|ty| (None, ty))\n                     });\n                 }\n                 TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n@@ -1244,58 +1247,81 @@ impl<'a> InferenceContext<'a> {\n                 .is_visible_from(self.db.upcast(), self.resolver.module());\n             if !is_visible {\n                 if private_field.is_none() {\n-                    private_field = Some(field_id);\n+                    private_field = Some((field_id, parameters));\n                 }\n                 return None;\n             }\n-            // can't have `write_field_resolution` here because `self.table` is borrowed :(\n-            self.result.field_resolutions.insert(tgt_expr, field_id);\n             let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n                 .clone()\n                 .substitute(Interner, &parameters);\n-            Some(ty)\n+            Some((Some(field_id), ty))\n         });\n-        let ty = match ty {\n-            Some(ty) => {\n+\n+        Some(match res {\n+            Some((field_id, ty)) => {\n+                let adjustments = auto_deref_adjust_steps(&autoderef);\n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+\n+                (ty, field_id, adjustments, true)\n+            }\n+            None => {\n+                let (field_id, subst) = private_field?;\n                 let adjustments = auto_deref_adjust_steps(&autoderef);\n-                self.write_expr_adj(expr, adjustments);\n+                let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                    .clone()\n+                    .substitute(Interner, &subst);\n                 let ty = self.insert_type_vars(ty);\n                 let ty = self.normalize_associated_types_in(ty);\n+\n+                (ty, Some(field_id), adjustments, false)\n+            }\n+        })\n+    }\n+\n+    fn infer_field_access(&mut self, tgt_expr: ExprId, receiver: ExprId, name: &Name) -> Ty {\n+        let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none());\n+        match self.lookup_field(&receiver_ty, name) {\n+            Some((ty, field_id, adjustments, is_public)) => {\n+                self.write_expr_adj(receiver, adjustments);\n+                if let Some(field_id) = field_id {\n+                    self.result.field_resolutions.insert(tgt_expr, field_id);\n+                }\n+                if !is_public {\n+                    if let Some(field) = field_id {\n+                        // FIXME: Merge this diagnostic into UnresolvedField?\n+                        self.result\n+                            .diagnostics\n+                            .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n+                    }\n+                }\n                 ty\n             }\n-            _ => {\n-                // Write down the first private field resolution if we found no field\n-                // This aids IDE features for private fields like goto def\n-                if let Some(field) = private_field {\n-                    self.result.field_resolutions.insert(tgt_expr, field);\n-                    // FIXME: Merge this diagnostic into UnresolvedField\n-                    self.result\n-                        .diagnostics\n-                        .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n-                } else {\n-                    // no field found, try looking for a method of the same name\n+            None => {\n+                // no field found,\n+                let method_with_same_name_exists = {\n                     let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n                     let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n-                    let resolved = method_resolution::lookup_method(\n+                    method_resolution::lookup_method(\n                         self.db,\n                         &canonicalized_receiver.value,\n                         self.trait_env.clone(),\n                         &traits_in_scope,\n                         VisibleFromModule::Filter(self.resolver.module()),\n                         name,\n-                    );\n-                    self.result.diagnostics.push(InferenceDiagnostic::UnresolvedField {\n-                        expr: tgt_expr,\n-                        receiver: receiver_ty,\n-                        name: name.clone(),\n-                        method_with_same_name_exists: resolved.is_some(),\n-                    });\n-                }\n+                    )\n+                    .is_some()\n+                };\n+                self.result.diagnostics.push(InferenceDiagnostic::UnresolvedField {\n+                    expr: tgt_expr,\n+                    receiver: receiver_ty,\n+                    name: name.clone(),\n+                    method_with_same_name_exists,\n+                });\n                 self.err_ty()\n             }\n-        };\n-        ty\n+        }\n     }\n \n     fn infer_method_call(\n@@ -1335,11 +1361,30 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 (ty, self.db.value_ty(func.into()), substs)\n             }\n-            None => (\n-                receiver_ty,\n-                Binders::empty(Interner, self.err_ty()),\n-                Substitution::empty(Interner),\n-            ),\n+            None => {\n+                let field_with_same_name_exists = match self.lookup_field(&receiver_ty, method_name)\n+                {\n+                    Some((ty, field_id, adjustments, _public)) => {\n+                        self.write_expr_adj(receiver, adjustments);\n+                        if let Some(field_id) = field_id {\n+                            self.result.field_resolutions.insert(tgt_expr, field_id);\n+                        }\n+                        Some(ty)\n+                    }\n+                    None => None,\n+                };\n+                self.result.diagnostics.push(InferenceDiagnostic::UnresolvedMethodCall {\n+                    expr: tgt_expr,\n+                    receiver: receiver_ty.clone(),\n+                    name: method_name.clone(),\n+                    field_with_same_name: field_with_same_name_exists,\n+                });\n+                (\n+                    receiver_ty,\n+                    Binders::empty(Interner, self.err_ty()),\n+                    Substitution::empty(Interner),\n+                )\n+            }\n         };\n         let method_ty = method_ty.substitute(Interner, &substs);\n         self.register_obligations_for_call(&method_ty);"}, {"sha": "b30c664e24f17ceb7b79676f3c68b74abef2783c", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -51,6 +51,7 @@ diagnostics![\n     UnresolvedField,\n     UnresolvedImport,\n     UnresolvedMacroCall,\n+    UnresolvedMethodCall,\n     UnresolvedModule,\n     UnresolvedProcMacro,\n ];\n@@ -146,6 +147,14 @@ pub struct UnresolvedField {\n     pub method_with_same_name_exists: bool,\n }\n \n+#[derive(Debug)]\n+pub struct UnresolvedMethodCall {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub receiver: Type,\n+    pub name: Name,\n+    pub field_with_same_name: Option<Type>,\n+}\n+\n #[derive(Debug)]\n pub struct PrivateField {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "269c45943e51a0ba96f8b55be4fb02b168a814b1", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -89,7 +89,7 @@ pub use crate::{\n         MissingMatchArms, MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n         UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedModule, UnresolvedProcMacro,\n+        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1441,6 +1441,26 @@ impl DefWithBody {\n                         .into(),\n                     )\n                 }\n+                hir_ty::InferenceDiagnostic::UnresolvedMethodCall {\n+                    expr,\n+                    receiver,\n+                    name,\n+                    field_with_same_name,\n+                } => {\n+                    let expr = expr_syntax(*expr);\n+\n+                    acc.push(\n+                        UnresolvedMethodCall {\n+                            expr,\n+                            name: name.clone(),\n+                            receiver: Type::new(db, DefWithBodyId::from(self), receiver.clone()),\n+                            field_with_same_name: field_with_same_name\n+                                .clone()\n+                                .map(|ty| Type::new(db, DefWithBodyId::from(self), ty)),\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n         for (pat_or_expr, mismatch) in infer.type_mismatches() {"}, {"sha": "936354f296134c81fef7282fc82e62f4638580ef", "filename": "crates/ide-db/src/source_change.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -83,6 +83,14 @@ impl From<NoHashHashMap<FileId, TextEdit>> for SourceChange {\n     }\n }\n \n+impl FromIterator<(FileId, TextEdit)> for SourceChange {\n+    fn from_iter<T: IntoIterator<Item = (FileId, TextEdit)>>(iter: T) -> Self {\n+        let mut this = SourceChange::default();\n+        this.extend(iter);\n+        this\n+    }\n+}\n+\n pub struct SourceChangeBuilder {\n     pub edit: TextEditBuilder,\n     pub file_id: FileId,"}, {"sha": "a0c276cc3328b94bc32c313211f087b2581a836b", "filename": "crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -55,7 +55,18 @@ fn fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n+    use crate::{\n+        tests::{check_diagnostics_with_config, check_fix},\n+        DiagnosticsConfig,\n+    };\n+\n+    #[track_caller]\n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let mut config = DiagnosticsConfig::test_sample();\n+        config.disabled.insert(\"inactive-code\".to_string());\n+        config.disabled.insert(\"unresolved-method\".to_string());\n+        check_diagnostics_with_config(config, ra_fixture)\n+    }\n \n     #[test]\n     fn replace_filter_map_next_with_find_map2() {"}, {"sha": "0d1f91f02c3b3837a7961c90ecc9ae921b95ecd3", "filename": "crates/ide-diagnostics/src/handlers/unresolved_method.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -0,0 +1,130 @@\n+use hir::{db::AstDatabase, HirDisplay};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind},\n+    base_db::FileRange,\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::{ast, AstNode, TextRange};\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-method\n+//\n+// This diagnostic is triggered if a method does not exist on a given type.\n+pub(crate) fn unresolved_method(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMethodCall,\n+) -> Diagnostic {\n+    let field_suffix = if d.field_with_same_name.is_some() {\n+        \", but a field with a similar name exists\"\n+    } else {\n+        \"\"\n+    };\n+    Diagnostic::new(\n+        \"unresolved-method\",\n+        format!(\n+            \"no method `{}` on type `{}`{field_suffix}\",\n+            d.name,\n+            d.receiver.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedMethodCall) -> Option<Vec<Assist>> {\n+    if let Some(ty) = &d.field_with_same_name {\n+        field_fix(ctx, d, ty)\n+    } else {\n+        // FIXME: add quickfix\n+        None\n+    }\n+}\n+\n+fn field_fix(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMethodCall,\n+    ty: &hir::Type,\n+) -> Option<Vec<Assist>> {\n+    if !ty.impls_fnonce(ctx.sema.db) {\n+        return None;\n+    }\n+    let expr_ptr = &d.expr;\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n+    let (file_id, range) = match expr {\n+        ast::Expr::MethodCallExpr(mcall) => {\n+            let FileRange { range, file_id } =\n+                ctx.sema.original_range_opt(mcall.receiver()?.syntax())?;\n+            let FileRange { range: range2, file_id: file_id2 } =\n+                ctx.sema.original_range_opt(mcall.name_ref()?.syntax())?;\n+            if file_id != file_id2 {\n+                return None;\n+            }\n+            (file_id, TextRange::new(range.start(), range2.end()))\n+        }\n+        _ => return None,\n+    };\n+    Some(vec![Assist {\n+        id: AssistId(\"expected-method-found-field-fix\", AssistKind::QuickFix),\n+        label: Label::new(\"Use parentheses to call the value of the field\".to_string()),\n+        group: None,\n+        target: range,\n+        source_change: Some(SourceChange::from_iter([\n+            (file_id, TextEdit::insert(range.start(), \"(\".to_owned())),\n+            (file_id, TextEdit::insert(range.end(), \")\".to_owned())),\n+        ])),\n+        trigger_signature_help: false,\n+    }])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    ().foo();\n+ // ^^^^^^^^ error: no method `foo` on type `()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { bar: i32 }\n+fn foo() {\n+    Foo { bar: i32 }.bar();\n+ // ^^^^^^^^^^^^^^^^^^^^^^ error: no method `bar` on type `Foo`, but a field with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn callable_field() {\n+        check_fix(\n+            r#\"\n+//- minicore: fn\n+struct Foo { bar: fn() }\n+fn foo() {\n+    Foo { bar: foo }.b$0ar();\n+}\n+\"#,\n+            r#\"\n+struct Foo { bar: fn() }\n+fn foo() {\n+    (Foo { bar: foo }.bar)();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "c8635ff801102e841b4f41640f03f5390604778b", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7485a04169f79c63333f2b0d39e159d10b92cee/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=e7485a04169f79c63333f2b0d39e159d10b92cee", "patch": "@@ -45,6 +45,7 @@ mod handlers {\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n     pub(crate) mod unresolved_field;\n+    pub(crate) mod unresolved_method;\n     pub(crate) mod unresolved_import;\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n@@ -271,6 +272,7 @@ pub fn diagnostics(\n             AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d, config.proc_macros_enabled, config.proc_attr_macros_enabled),\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n             AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n \n             AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,"}]}