{"sha": "b342f0017931180097f17905da8640f674165255", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNDJmMDAxNzkzMTE4MDA5N2YxNzkwNWRhODY0MGY2NzQxNjUyNTU=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-19T00:48:47Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T12:18:35Z"}, "message": "Only annotate if borrow is returned.\n\nError now correctly checks whether the borrow that does not live\nlong enough is being returned before annotating the error with the\narguments and return type from the signature - as this would not be\nrelevant if the borrow was not being returned.", "tree": {"sha": "d1e89e3ef3d08a1628e80011e8cc783a4f1b0aeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1e89e3ef3d08a1628e80011e8cc783a4f1b0aeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b342f0017931180097f17905da8640f674165255", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunhJsACgkQAXYLT59T\n8VSFEw//VelIBPJRJ0JRKsNBc7YTJkeleCka04fP6XHvdHdcYZvcmUtHfmaSOJL0\nWQm08jTM18m7S3E3Zq2Xyo4elppZfEvU5xkyAgKN/KSMHdph1FegW6SYWy0A8NcZ\nXGUPCiiAgO4FNzjQJKo7tpUrNHum6zsUjd0XQVn28x+tfx1b5PddxbBo7wExsq0v\nA051jpAeiZnR83lT0iM2A7uFJf3Mpa+gkyS3SwCMwy3iIFQf2QvvXfUFXJ9fKiva\ntELWQXFcqOUHaWW/VmCq5k8e/d0Md6unUQnl/dUaeSqTAQ2NwGMgAGkgxMeI5m56\nHOEXTSB7Vs2jpY7/ERWTlir1YR2YKSBjJl/Wesr0x2KjuGdc6JGo2I9WGzd6PTUz\nCCEj/P6+xInqhoIlftVDjaH+mxwnw5kbzglplahH69rtQ4NGVLOgWT+hnU2uK8uN\nFHe2lm62fWygSgr+K7xAA3oo62kaeTG+Xx308bdcPCafWJQ6cuCRxlSlvznDEzaY\nok+iVbycNKQrLcprerTTxnHeql8M69eIzi3jsXTZk5K5R80RM9F440fOLAasYWkk\nys8ASXaBPpcbQVv3bxbkk/AqvQlmPczSxxdVf8qvAc/sQ7iD0bFfeTJseh6ffROh\njglfB+9hl3PjzPIC0/laC53KfUrQ6mYGYEBIir/NWA7UGsEbVoI=\n=XWgc\n-----END PGP SIGNATURE-----", "payload": "tree d1e89e3ef3d08a1628e80011e8cc783a4f1b0aeb\nparent ef10e94993f6e4b04b283e414b04ed02ec9f6c99\nauthor David Wood <david@davidtw.co> 1537318127 +0200\ncommitter David Wood <david@davidtw.co> 1537705115 +0200\n\nOnly annotate if borrow is returned.\n\nError now correctly checks whether the borrow that does not live\nlong enough is being returned before annotating the error with the\narguments and return type from the signature - as this would not be\nrelevant if the borrow was not being returned.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b342f0017931180097f17905da8640f674165255", "html_url": "https://github.com/rust-lang/rust/commit/b342f0017931180097f17905da8640f674165255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b342f0017931180097f17905da8640f674165255/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef10e94993f6e4b04b283e414b04ed02ec9f6c99", "html_url": "https://github.com/rust-lang/rust/commit/ef10e94993f6e4b04b283e414b04ed02ec9f6c99"}], "stats": {"total": 343, "additions": 276, "deletions": 67}, "files": [{"sha": "98d9a0a7c6f5e3b376a4fb87d3783311fc1802bd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -1883,6 +1883,18 @@ impl<'tcx> Place<'tcx> {\n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n         Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n+\n+    /// Find the innermost `Local` from this `Place`.\n+    pub fn local(&self) -> Option<Local> {\n+        match self {\n+            Place::Local(local) |\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) => Some(*local),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> Debug for Place<'tcx> {"}, {"sha": "3fdb7d7f27d7ed623d87c523a6b788c792041255", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 198, "deletions": 40, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -13,9 +13,9 @@ use borrow_check::prefixes::IsPrefixOf;\n use borrow_check::nll::explain_borrow::BorrowExplanation;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n-    AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n+    self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n     LocalDecl, LocalKind, Location, Operand, Place, ProjectionElem, Rvalue, Statement,\n-    StatementKind, VarBindingForm,\n+    StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -518,14 +518,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             err.span_label(\n                 borrow_span,\n-                format!(\"`{}` would have to be valid for `{}`\", name, region_name)\n+                format!(\"`{}` would have to be valid for `{}`...\", name, region_name)\n             );\n \n             if let Some(fn_node_id) = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id) {\n                 err.span_label(\n                     drop_span,\n                     format!(\n-                        \"but `{}` will be dropped here, when the function `{}` returns\",\n+                        \"...but `{}` will be dropped here, when the function `{}` returns\",\n                         name, self.infcx.tcx.hir.name(fn_node_id),\n                     )\n                 );\n@@ -1173,54 +1173,211 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &self,\n         borrow: &BorrowData<'tcx>,\n     ) -> Option<AnnotatedBorrowFnSignature> {\n-        // There are two cases that need handled: when a closure is involved and\n-        // when a closure is not involved.\n-        let location = borrow.reserve_location;\n-        let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+        // Define a fallback for when we can't match a closure.\n+        let fallback = || {\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+            if is_closure {\n+                None\n+            } else {\n+                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+                 match ty.sty {\n+                     ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) =>\n+                        self.annotate_fn_sig(\n+                            self.mir_def_id,\n+                            self.infcx.tcx.fn_sig(self.mir_def_id)\n+                        ),\n+                    _ => None,\n+                }\n+            }\n+        };\n \n-        match self.mir[location.block].statements.get(location.statement_index) {\n-            // When a closure is involved, we expect the reserve location to be an assignment\n-            // to a temporary local, which will be followed by a closure.\n+        // In order to determine whether we need to annotate, we need to check whether the reserve\n+        // place was an assignment into a temporary.\n+        //\n+        // If it was, we check whether or not that temporary is eventually assigned into the return\n+        // place. If it was, we can add annotations about the function's return type and arguments\n+        // and it'll make sense.\n+        let location = borrow.reserve_location;\n+        debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n+        match &self.mir[location.block].statements.get(location.statement_index) {\n             Some(&Statement {\n-                kind: StatementKind::Assign(Place::Local(local), _),\n+                kind: StatementKind::Assign(ref reservation, _),\n                 ..\n-            }) if self.mir.local_kind(local) == LocalKind::Temp => {\n-                // Look for the statements within this block after assigning to a local to see\n-                // if we have a closure. If we do, then annotate it.\n+            }) => {\n+                debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n+                // Check that the initial assignment of the reserve location is into a temporary.\n+                let mut target = *match reservation {\n+                    Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                    _ => return None,\n+                };\n+\n+                // Next, look through the rest of the block, checking if we are assigning the\n+                // `target` (that is, the place that contains our borrow) to anything.\n+                let mut annotated_closure = None;\n                 for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n+                        target, stmt\n+                    );\n                     if let StatementKind::Assign(\n-                        _,\n-                        Rvalue::Aggregate(\n-                            box AggregateKind::Closure(def_id, substs),\n-                            _\n-                        )\n-                    ) = stmt.kind {\n-                        return self.annotate_fn_sig(\n-                            def_id,\n-                            self.infcx.closure_sig(def_id, substs)\n+                        Place::Local(assigned_to),\n+                        rvalue,\n+                    ) = &stmt.kind {\n+                        debug!(\"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                               rvalue={:?}\", assigned_to, rvalue);\n+                        // Check if our `target` was captured by a closure.\n+                        if let Rvalue::Aggregate(\n+                                box AggregateKind::Closure(def_id, substs),\n+                                operands,\n+                        ) = rvalue {\n+                            for operand in operands {\n+                                let assigned_from = match operand {\n+                                    Operand::Copy(assigned_from) |\n+                                    Operand::Move(assigned_from) => assigned_from,\n+                                    _ => continue,\n+                                };\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                                    assigned_from\n+                                );\n+\n+                                // Find the local from the operand.\n+                                let assigned_from_local = match assigned_from.local() {\n+                                    Some(local) => local,\n+                                    None => continue,\n+                                };\n+\n+                                if assigned_from_local != target {\n+                                    continue;\n+                                }\n+\n+                                // If a closure captured our `target` and then assigned\n+                                // into a place then we should annotate the closure in\n+                                // case it ends up being assigned into the return place.\n+                                annotated_closure = self.annotate_fn_sig(\n+                                    *def_id,\n+                                    self.infcx.closure_sig(*def_id, *substs)\n+                                );\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: \\\n+                                     annotated_closure={:?} assigned_from_local={:?} \\\n+                                     assigned_to={:?}\",\n+                                     annotated_closure, assigned_from_local, assigned_to\n+                                );\n+\n+                                if *assigned_to == mir::RETURN_PLACE {\n+                                    // If it was assigned directly into the return place, then\n+                                    // return now.\n+                                    return annotated_closure;\n+                                } else {\n+                                    // Otherwise, update the target.\n+                                    target = *assigned_to;\n+                                }\n+                            }\n+\n+                            // If none of our closure's operands matched, then skip to the next\n+                            // statement.\n+                            continue;\n+                        }\n+\n+                        // Otherwise, look at other types of assignment.\n+                        let assigned_from = match rvalue {\n+                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                            Rvalue::Use(operand) => match operand {\n+                                Operand::Copy(assigned_from) |\n+                                Operand::Move(assigned_from) => assigned_from,\n+                                _ => continue,\n+                            },\n+                            _ => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from={:?}\", assigned_from,\n+                        );\n+\n+                        // Find the local from the rvalue.\n+                        let assigned_from_local = match assigned_from.local() {\n+                            Some(local) => local,\n+                            None => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?}\", assigned_from_local,\n                         );\n+\n+                        // Check if our local matches the target - if so, we've assigned our\n+                        // borrow to a new place.\n+                        if assigned_from_local != target {\n+                            continue;\n+                        }\n+\n+                        // If we assigned our `target` into a new place, then we should\n+                        // check if it was the return place.\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?} assigned_to={:?}\",\n+                             assigned_from_local, assigned_to\n+                        );\n+                        if *assigned_to == mir::RETURN_PLACE {\n+                            // If it was then return the annotated closure if there was one,\n+                            // else, annotate this function.\n+                            return annotated_closure.or_else(fallback);\n+                        }\n+\n+                        // If we didn't assign into the return place, then we just update\n+                        // the target.\n+                        target = *assigned_to;\n+                    }\n+                }\n+\n+                // Check the terminator if we didn't find anything in the statements.\n+                let terminator = &self.mir[location.block].terminator();\n+                debug!(\n+                    \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n+                    target, terminator\n+                );\n+                if let TerminatorKind::Call {\n+                    destination: Some((Place::Local(assigned_to), _)),\n+                    args,\n+                    ..\n+                } = &terminator.kind {\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                        assigned_to, args\n+                    );\n+                    for operand in args {\n+                        let assigned_from = match operand {\n+                            Operand::Copy(assigned_from) |\n+                            Operand::Move(assigned_from) => assigned_from,\n+                            _ => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                            assigned_from,\n+                        );\n+\n+                        if let Some(assigned_from_local) = assigned_from.local() {\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                                assigned_from_local,\n+                            );\n+\n+                            if *assigned_to == mir::RETURN_PLACE &&\n+                                assigned_from_local == target\n+                            {\n+                                return annotated_closure.or_else(fallback);\n+                            }\n+                        }\n                     }\n                 }\n             }\n             _ => {}\n         }\n \n-        // If this is not the case, then return if we're currently on a closure (as we\n-        // don't have a substs to get the PolyFnSig) or attempt to get the arguments\n-        // and return type of the function.\n-        if is_closure {\n-            None\n-        } else {\n-            let ty = self.infcx.tcx.type_of(self.mir_def_id);\n-            match ty.sty {\n-                ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) =>\n-                    self.annotate_fn_sig(\n-                        self.mir_def_id,\n-                        self.infcx.tcx.fn_sig(self.mir_def_id)\n-                    ),\n-                _ => None,\n-            }\n-        }\n+        // If we haven't found an assignment into the return place, then we need not add\n+        // any annotations.\n+        debug!(\"annotate_argument_and_return_for_borrow: none found\");\n+        None\n     }\n \n     /// Annotate the first argument and return type of a function signature if they are\n@@ -1230,6 +1387,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         did: DefId,\n         sig: ty::PolyFnSig<'tcx>,\n     ) -> Option<AnnotatedBorrowFnSignature> {\n+        debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n         let fn_node_id = self.infcx.tcx.hir.as_local_node_id(did)?;\n         let fn_decl = self.infcx.tcx.hir.fn_decl(fn_node_id)?;"}, {"sha": "3d2c95013ab0fba127fc513c6beed6eea3d10372", "filename": "src/test/ui/issues/issue-30438-c.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30438-c.nll.stderr?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -7,10 +7,10 @@ LL | fn silly<'y, 'z>(_s: &'y Test<'z>) -> &'y <Test<'z> as Trait>::Out where 'z\n    |                       has lifetime `'y`\n LL |     let x = Test { s: \"this cannot last\" };\n LL |     &x\n-   |     ^^ `x` would have to be valid for `'y`\n+   |     ^^ `x` would have to be valid for `'y`...\n LL |     //~^ ERROR: `x` does not live long enough\n LL | }\n-   | - but `x` will be dropped here, when the function `silly` returns\n+   | - ...but `x` will be dropped here, when the function `silly` returns\n    |\n    = help: use data from the highlighted arguments which match the `'y` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments"}, {"sha": "c35a14ca70443a97a8ad07e1ae3b34cbadd08d49", "filename": "src/test/ui/nll/borrowed-universal-error-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -7,10 +7,10 @@ LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n    |                has lifetime `'a`\n LL |     let v = 22;\n LL |     &v\n-   |     ^^ `v` would have to be valid for `'a`\n+   |     ^^ `v` would have to be valid for `'a`...\n LL |     //~^ ERROR `v` does not live long enough [E0597]\n LL | }\n-   | - but `v` will be dropped here, when the function `foo` returns\n+   | - ...but `v` will be dropped here, when the function `foo` returns\n    |\n    = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments"}, {"sha": "e2f8134e3be0e055312ca38b506b806f26c44144", "filename": "src/test/ui/nll/issue-52534-1.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-1.stderr?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -7,9 +7,9 @@ LL |     fn bar(&self, x: &u32) -> &u32 {\n    |            has type `&'0 Test`\n LL |         let x = 22;\n LL |         &x\n-   |         ^^ `x` would have to be valid for `'0`\n+   |         ^^ `x` would have to be valid for `'0`...\n LL |     }\n-   |     - but `x` will be dropped here, when the function `bar` returns\n+   |     - ...but `x` will be dropped here, when the function `bar` returns\n    |\n    = note: argument and return type have the same lifetime due to lifetime elision rules\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n@@ -25,9 +25,9 @@ LL | fn foo(x: &u32) -> &u32 {\n    |           has type `&'0 u32`\n LL |     let x = 22;\n LL |     &x\n-   |     ^^ `x` would have to be valid for `'0`\n+   |     ^^ `x` would have to be valid for `'0`...\n LL | }\n-   | - but `x` will be dropped here, when the function `foo` returns\n+   | - ...but `x` will be dropped here, when the function `foo` returns\n    |\n    = note: argument and return type have the same lifetime due to lifetime elision rules\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n@@ -43,9 +43,9 @@ LL | fn baz(x: &u32) -> &&u32 {\n    |           has type `&'0 u32`\n LL |     let x = 22;\n LL |     &&x\n-   |      ^^ `x` would have to be valid for `'0`\n+   |      ^^ `x` would have to be valid for `'0`...\n LL | }\n-   | - but `x` will be dropped here, when the function `baz` returns\n+   | - ...but `x` will be dropped here, when the function `baz` returns\n    |\n    = note: argument and return type have the same lifetime due to lifetime elision rules\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision>\n@@ -78,9 +78,9 @@ LL | fn foobazbar<'a>(x: u32, y: &'a u32) -> &'a u32 {\n    |                              has lifetime `'a`\n LL |     let x = 22;\n LL |     &x\n-   |     ^^ `x` would have to be valid for `'a`\n+   |     ^^ `x` would have to be valid for `'a`...\n LL | }\n-   | - but `x` will be dropped here, when the function `foobazbar` returns\n+   | - ...but `x` will be dropped here, when the function `foobazbar` returns\n    |\n    = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n@@ -95,9 +95,9 @@ LL | fn foobar<'a>(x: &'a u32) -> &'a u32 {\n    |                   has lifetime `'a`\n LL |     let x = 22;\n LL |     &x\n-   |     ^^ `x` would have to be valid for `'a`\n+   |     ^^ `x` would have to be valid for `'a`...\n LL | }\n-   | - but `x` will be dropped here, when the function `foobar` returns\n+   | - ...but `x` will be dropped here, when the function `foobar` returns\n    |\n    = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n@@ -110,9 +110,9 @@ LL | fn foobaz<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n    |                       -- has lifetime `'a`    -- also has lifetime `'a`\n LL |     let x = 22;\n LL |     &x\n-   |     ^^ `x` would have to be valid for `'a`\n+   |     ^^ `x` would have to be valid for `'a`...\n LL | }\n-   | - but `x` will be dropped here, when the function `foobaz` returns\n+   | - ...but `x` will be dropped here, when the function `foobaz` returns\n    |\n    = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n@@ -127,9 +127,9 @@ LL | fn foobarbaz<'a, 'b>(x: &'a u32, y: &'b u32, z: &'a u32) -> &'a u32 {\n    |                          has lifetime `'a`       has lifetime `'a`\n LL |     let x = 22;\n LL |     &x\n-   |     ^^ `x` would have to be valid for `'a`\n+   |     ^^ `x` would have to be valid for `'a`...\n LL | }\n-   | - but `x` will be dropped here, when the function `foobarbaz` returns\n+   | - ...but `x` will be dropped here, when the function `foobarbaz` returns\n    |\n    = help: use data from the highlighted arguments which match the `'a` lifetime of the return type\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments"}, {"sha": "4eac6feac0d9cea7fa2d09e2f98bd04af87010af", "filename": "src/test/ui/nll/issue-52534-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.rs?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo(x: &u32) -> &u32 {\n+    let y;\n+\n+    {\n+        let x = 32;\n+        y = &x\n+    }\n+\n+    println!(\"{}\", y);\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "51cd7c7bf3b40a46a21671e6bdcdbca2c5e5c790", "filename": "src/test/ui/nll/issue-52534-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-52534-2.rs:19:9\n+   |\n+LL |         y = &x\n+   |         ^^^^^^ borrowed value does not live long enough\n+LL |     }\n+   |     - `x` dropped here while still borrowed\n+LL | \n+LL |     println!(\"{}\", y);\n+   |                    - borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "00d72546ebc4c66fa94d1426ed8c4732cb652122", "filename": "src/test/ui/nll/issue-52534.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534.stderr?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -2,11 +2,11 @@ error[E0597]: `x` does not live long enough\n   --> $DIR/issue-52534.rs:22:14\n    |\n LL |     foo(|a| &x)\n-   |          -   ^ `x` would have to be valid for `'0`\n+   |          -   ^ `x` would have to be valid for `'0`...\n    |          |\n    |          has type `&'0 u32`\n LL | }\n-   | - but `x` will be dropped here, when the function `bar` returns\n+   | - ...but `x` will be dropped here, when the function `bar` returns\n    |\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n@@ -15,11 +15,11 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/issue-52534.rs:27:26\n    |\n LL |     baz(|first, second| &y)\n-   |          -----           ^ `y` would have to be valid for `'0`\n+   |          -----           ^ `y` would have to be valid for `'0`...\n    |          |\n    |          has type `&'0 u32`\n LL | }\n-   | - but `y` will be dropped here, when the function `foobar` returns\n+   | - ...but `y` will be dropped here, when the function `foobar` returns\n    |\n    = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n    = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>"}, {"sha": "1b5bb7d5007798038855dcb2287971fb8a05df2b", "filename": "src/test/ui/regions/regions-nested-fns-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b342f0017931180097f17905da8640f674165255/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns-2.nll.stderr?ref=b342f0017931180097f17905da8640f674165255", "patch": "@@ -2,16 +2,15 @@ error[E0597]: `y` does not live long enough\n   --> $DIR/regions-nested-fns-2.rs:18:25\n    |\n LL |         |z| {\n-   |          - has type `&'0 isize`\n+   |         --- value captured here\n LL |             //~^ ERROR E0373\n LL |             if false { &y } else { z }\n-   |                         ^ `y` would have to be valid for `'0`\n+   |                         ^ borrowed value does not live long enough\n LL |         });\n LL | }\n-   | - but `y` will be dropped here, when the function `nested` returns\n+   | - `y` dropped here while still borrowed\n    |\n-   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#dangling-references>\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to previous error\n "}]}