{"sha": "43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZDQ0NWM4ZDFhZTljNmVjYjgyMDNkZDk3ZDk2ZjBlMjQ1YjA0MmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-20T14:29:42Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Pass `Matrix` explicitly instead of via `PatCtxt`", "tree": {"sha": "0e0c268f81a0603e0f10a468011b7bf7eccd1492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e0c268f81a0603e0f10a468011b7bf7eccd1492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "html_url": "https://github.com/rust-lang/rust/commit/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b38b6859a5395520e4f466133db4ec4bfd0317d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b38b6859a5395520e4f466133db4ec4bfd0317d", "html_url": "https://github.com/rust-lang/rust/commit/8b38b6859a5395520e4f466133db4ec4bfd0317d"}], "stats": {"total": 75, "additions": 48, "deletions": 27}, "files": [{"sha": "4860bb0fe8768da24b5201451f2e93a6324dc1a2", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::lint;\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n@@ -184,12 +184,18 @@ impl IntRange {\n     }\n \n     /// Lint on likely incorrect range patterns (#63987)\n-    pub(super) fn lint_overlapping_range_endpoints(&self, pcx: PatCtxt<'_, '_, '_>, hir_id: HirId) {\n+    pub(super) fn lint_overlapping_range_endpoints<'a, 'tcx: 'a>(\n+        &self,\n+        pcx: PatCtxt<'_, '_, 'tcx>,\n+        ctors: impl Iterator<Item = (&'a Constructor<'tcx>, Span)>,\n+        column_count: usize,\n+        hir_id: HirId,\n+    ) {\n         if self.is_singleton() {\n             return;\n         }\n \n-        if pcx.matrix.column_count().unwrap_or(0) != 1 {\n+        if column_count != 1 {\n             // FIXME: for now, only check for overlapping ranges on simple range\n             // patterns. Otherwise with the current logic the following is detected\n             // as overlapping:\n@@ -203,9 +209,7 @@ impl IntRange {\n             return;\n         }\n \n-        let overlaps: Vec<_> = pcx\n-            .matrix\n-            .head_ctors_and_spans(pcx.cx)\n+        let overlaps: Vec<_> = ctors\n             .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n             .filter(|(range, _)| self.suspicious_intersection(range))\n             .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n@@ -655,28 +659,33 @@ impl<'tcx> Constructor<'tcx> {\n     /// This function may discard some irrelevant constructors if this preserves behavior and\n     /// diagnostics. Eg. for the `_` case, we ignore the constructors already present in the\n     /// matrix, unless all of them are.\n-    pub(super) fn split<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Self; 1]> {\n-        debug!(\"Constructor::split({:#?}, {:#?})\", self, pcx.matrix);\n+    pub(super) fn split<'a>(\n+        &self,\n+        pcx: PatCtxt<'_, '_, 'tcx>,\n+        ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n+    ) -> SmallVec<[Self; 1]>\n+    where\n+        'tcx: 'a,\n+    {\n+        debug!(\"Constructor::split({:#?})\", self);\n \n         match self {\n             Wildcard => {\n                 let mut split_wildcard = SplitWildcard::new(pcx);\n-                split_wildcard.split(pcx);\n+                split_wildcard.split(pcx, ctors);\n                 split_wildcard.into_ctors(pcx)\n             }\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n             IntRange(ctor_range) if !ctor_range.is_singleton() => {\n                 let mut split_range = SplitIntRange::new(ctor_range.clone());\n-                let intranges =\n-                    pcx.matrix.head_ctors(pcx.cx).filter_map(|ctor| ctor.as_int_range());\n+                let intranges = ctors.filter_map(|ctor| ctor.as_int_range());\n                 split_range.split(intranges.cloned());\n                 split_range.iter().map(IntRange).collect()\n             }\n             &Slice(Slice { kind: VarLen(self_prefix, self_suffix), array_len }) => {\n                 let mut split_self = SplitVarLenSlice::new(self_prefix, self_suffix, array_len);\n-                let slices =\n-                    pcx.matrix.head_ctors(pcx.cx).filter_map(|c| c.as_slice()).map(|s| s.kind);\n+                let slices = ctors.filter_map(|c| c.as_slice()).map(|s| s.kind);\n                 split_self.split(slices);\n                 split_self.iter().map(Slice).collect()\n             }\n@@ -912,11 +921,17 @@ impl<'tcx> SplitWildcard<'tcx> {\n \n     /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't\n     /// do what you want.\n-    pub(super) fn split(&mut self, pcx: PatCtxt<'_, '_, 'tcx>) {\n-        self.matrix_ctors =\n-            pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n+    pub(super) fn split<'a>(\n+        &mut self,\n+        pcx: PatCtxt<'_, '_, 'tcx>,\n+        ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n+    ) where\n+        'tcx: 'a,\n+    {\n         // Since `all_ctors` never contains wildcards, this won't recurse further.\n-        self.all_ctors = self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx)).collect();\n+        self.all_ctors =\n+            self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx, ctors.clone())).collect();\n+        self.matrix_ctors = ctors.filter(|c| !c.is_wildcard()).cloned().collect();\n     }\n \n     /// Whether there are any value constructors for this type that are not present in the matrix."}, {"sha": "ad672b59ba4f0cb32d313dd939baff713e68c1f4", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "patch": "@@ -358,8 +358,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n #[derive(Copy, Clone)]\n pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n     pub(super) cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    /// Current state of the matrix.\n-    pub(super) matrix: &'a Matrix<'p, 'tcx>,\n     /// Type of the current column under investigation.\n     pub(super) ty: Ty<'tcx>,\n     /// Span of the current pattern under investigation.\n@@ -538,7 +536,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub(super) fn head_ctors<'a>(\n         &'a self,\n         cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n+    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> + Clone {\n         self.patterns.iter().map(move |r| r.head_ctor(cx))\n     }\n \n@@ -804,14 +802,15 @@ impl<'tcx> Usefulness<'tcx> {\n     fn apply_constructor<'p>(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n+        matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n                 let new_witnesses = if ctor.is_wildcard() {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n-                    split_wildcard.split(pcx);\n+                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n                     let new_patterns = split_wildcard.report_missing_patterns(pcx);\n                     witnesses\n                         .into_iter()\n@@ -968,7 +967,7 @@ fn is_useful<'p, 'tcx>(\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n-    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n+    let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n \n     debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n \n@@ -995,20 +994,27 @@ fn is_useful<'p, 'tcx>(\n         let v_ctor = v.head_ctor(cx);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n             // Lint on likely incorrect range patterns (#63987)\n-            ctor_range.lint_overlapping_range_endpoints(pcx, hir_id)\n+            ctor_range.lint_overlapping_range_endpoints(\n+                pcx,\n+                matrix.head_ctors_and_spans(cx),\n+                matrix.column_count().unwrap_or(0),\n+                hir_id,\n+            )\n         }\n         // We split the head constructor of `v`.\n-        let split_ctors = v_ctor.split(pcx);\n+        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n+        let start_matrix = &matrix;\n         let usefulnesses = split_ctors.into_iter().map(|ctor| {\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n-            let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n+            let spec_matrix =\n+                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n-                is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n+                is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n         });\n         Usefulness::merge(usefulnesses)\n     };"}]}