{"sha": "bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZDI3ZWI3ZDUwOTc4ZTgyM2U2MWU0NzdmMmE0YzIyMDFjYTM0YmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-08T10:04:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-08T10:04:12Z"}, "message": "Auto merge of #28891 - cristicbz:new-nbody, r=alexcrichton\n\nThis new version takes inspiration from the C implementation of the benchmark, but instead of explicitly using SIMD operations which can't be done on stable, it instead arranges everything the same way and leaves the actual vectorization up to LLVM.\r\n\r\nIn addition to the ~20% speed gains (see below), this PR also adds some general niceties which showcase the language a little bit: a `Vec3` type to cut down on `(x, y, z)` repetition,  using `while let` instead of `loop-if-break`, iterator adapters instead of for loops etc.\r\n\r\nHere are the times in seconds of 10 runs each on my workstation:\r\n\r\n```\r\nbefore: 6.254, 6.260, 6.263, 6.264, 6.265, 6.267, 6.334, 6.341, 6.441, 6.509\r\nbefore-min: 6.254\r\nbefore-median: 6.266\r\nbefore-max: 6.509\r\n\r\nafter: 4.823, 4.824, 4.826, 4.827, 4.837, 4.839, 4.881, 4.959, 4.990, 5.377\r\nafter-min: 4.823\r\nafter-median: 4.838\r\nafter-max: 5.377\r\n\r\ngcc: 4.674, 4.676, 4.680, 4.682, 4.695, 4.696, 4.701, 4.708, 4.794, 5.297\r\ngcc-min: 4.674\r\ngcc-median: 4.696\r\ngcc-max: 5.297\r\n```\r\n\r\nOn my i7 laptop the speed up is less impressive, from ~5.4s to ~4.7s, but still significant. On my Vultr VPS the numbers look closer to the workstation results. Surprisingly my laptop beats both office workstation and VPS...", "tree": {"sha": "80c3966bacd3d0f944d1c8b54136c152e2b32db3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80c3966bacd3d0f944d1c8b54136c152e2b32db3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "html_url": "https://github.com/rust-lang/rust/commit/bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcd27eb7d50978e823e61e477f2a4c2201ca34bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88898e6ca72d46a237ad6dd65e21889cdb4558a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/88898e6ca72d46a237ad6dd65e21889cdb4558a2", "html_url": "https://github.com/rust-lang/rust/commit/88898e6ca72d46a237ad6dd65e21889cdb4558a2"}, {"sha": "49d2441b056719ba4c47f1fab0d864199616d3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d2441b056719ba4c47f1fab0d864199616d3da", "html_url": "https://github.com/rust-lang/rust/commit/49d2441b056719ba4c47f1fab0d864199616d3da"}], "stats": {"total": 219, "additions": 132, "deletions": 87}, "files": [{"sha": "64d6a8109888eb50c5cf33882310644609beaab1", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 132, "deletions": 87, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/bcd27eb7d50978e823e61e477f2a4c2201ca34bf/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd27eb7d50978e823e61e477f2a4c2201ca34bf/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=bcd27eb7d50978e823e61e477f2a4c2201ca34bf", "patch": "@@ -39,134 +39,175 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::mem;\n+use std::ops::{Add, Sub, Mul};\n \n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;\n const YEAR: f64 = 365.24;\n const N_BODIES: usize = 5;\n+const N_PAIRS: usize = N_BODIES * (N_BODIES - 1) / 2;\n \n-static BODIES: [Planet;N_BODIES] = [\n+const BODIES: [Planet; N_BODIES] = [\n     // Sun\n     Planet {\n-        x: 0.0, y: 0.0, z: 0.0,\n-        vx: 0.0, vy: 0.0, vz: 0.0,\n+        pos: Vec3(0.0, 0.0, 0.0),\n+        vel: Vec3(0.0, 0.0, 0.0),\n         mass: SOLAR_MASS,\n     },\n     // Jupiter\n     Planet {\n-        x: 4.84143144246472090e+00,\n-        y: -1.16032004402742839e+00,\n-        z: -1.03622044471123109e-01,\n-        vx: 1.66007664274403694e-03 * YEAR,\n-        vy: 7.69901118419740425e-03 * YEAR,\n-        vz: -6.90460016972063023e-05 * YEAR,\n+        pos: Vec3(4.84143144246472090e+00,\n+                  -1.16032004402742839e+00,\n+                  -1.03622044471123109e-01),\n+        vel: Vec3(1.66007664274403694e-03 * YEAR,\n+                  7.69901118419740425e-03 * YEAR,\n+                  -6.90460016972063023e-05 * YEAR),\n         mass: 9.54791938424326609e-04 * SOLAR_MASS,\n     },\n     // Saturn\n     Planet {\n-        x: 8.34336671824457987e+00,\n-        y: 4.12479856412430479e+00,\n-        z: -4.03523417114321381e-01,\n-        vx: -2.76742510726862411e-03 * YEAR,\n-        vy: 4.99852801234917238e-03 * YEAR,\n-        vz: 2.30417297573763929e-05 * YEAR,\n+        pos: Vec3(8.34336671824457987e+00,\n+                  4.12479856412430479e+00,\n+                  -4.03523417114321381e-01),\n+        vel: Vec3(-2.76742510726862411e-03 * YEAR,\n+                  4.99852801234917238e-03 * YEAR,\n+                  2.30417297573763929e-05 * YEAR),\n         mass: 2.85885980666130812e-04 * SOLAR_MASS,\n     },\n     // Uranus\n     Planet {\n-        x: 1.28943695621391310e+01,\n-        y: -1.51111514016986312e+01,\n-        z: -2.23307578892655734e-01,\n-        vx: 2.96460137564761618e-03 * YEAR,\n-        vy: 2.37847173959480950e-03 * YEAR,\n-        vz: -2.96589568540237556e-05 * YEAR,\n+        pos: Vec3(1.28943695621391310e+01,\n+                  -1.51111514016986312e+01,\n+                  -2.23307578892655734e-01),\n+        vel: Vec3(2.96460137564761618e-03 * YEAR,\n+                  2.37847173959480950e-03 * YEAR,\n+                  -2.96589568540237556e-05 * YEAR),\n         mass: 4.36624404335156298e-05 * SOLAR_MASS,\n     },\n     // Neptune\n     Planet {\n-        x: 1.53796971148509165e+01,\n-        y: -2.59193146099879641e+01,\n-        z: 1.79258772950371181e-01,\n-        vx: 2.68067772490389322e-03 * YEAR,\n-        vy: 1.62824170038242295e-03 * YEAR,\n-        vz: -9.51592254519715870e-05 * YEAR,\n+        pos: Vec3(1.53796971148509165e+01,\n+                  -2.59193146099879641e+01,\n+                  1.79258772950371181e-01),\n+        vel: Vec3(2.68067772490389322e-03 * YEAR,\n+                  1.62824170038242295e-03 * YEAR,\n+                  -9.51592254519715870e-05 * YEAR),\n         mass: 5.15138902046611451e-05 * SOLAR_MASS,\n     },\n ];\n \n-#[derive(Copy, Clone)]\n+/// A 3d Vector type with oveloaded operators to improve readability.\n+#[derive(Clone, Copy)]\n+struct Vec3(pub f64, pub f64, pub f64);\n+\n+impl Vec3 {\n+    fn zero() -> Self { Vec3(0.0, 0.0, 0.0) }\n+\n+    fn norm(&self) -> f64 { self.squared_norm().sqrt() }\n+\n+    fn squared_norm(&self) -> f64 {\n+        self.0 * self.0 + self.1 * self.1 + self.2 * self.2\n+    }\n+}\n+\n+impl Add for Vec3 {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self {\n+        Vec3(self.0 + rhs.0, self.1 + rhs.1, self.2 + rhs.2)\n+    }\n+}\n+\n+impl Sub for Vec3 {\n+    type Output = Self;\n+    fn sub(self, rhs: Self) -> Self {\n+        Vec3(self.0 - rhs.0, self.1 - rhs.1, self.2 - rhs.2)\n+    }\n+}\n+\n+impl Mul<f64> for Vec3 {\n+    type Output = Self;\n+    fn mul(self, rhs: f64) -> Self {\n+        Vec3(self.0 * rhs, self.1 * rhs, self.2 * rhs)\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n struct Planet {\n-    x: f64, y: f64, z: f64,\n-    vx: f64, vy: f64, vz: f64,\n+    pos: Vec3,\n+    vel: Vec3,\n     mass: f64,\n }\n \n-fn advance(bodies: &mut [Planet;N_BODIES], dt: f64, steps: isize) {\n-    for _ in 0..steps {\n-        let mut b_slice: &mut [_] = bodies;\n-        loop {\n-            let bi = match shift_mut_ref(&mut b_slice) {\n-                Some(bi) => bi,\n-                None => break\n-            };\n-            for bj in &mut *b_slice {\n-                let dx = bi.x - bj.x;\n-                let dy = bi.y - bj.y;\n-                let dz = bi.z - bj.z;\n-\n-                let d2 = dx * dx + dy * dy + dz * dz;\n-                let mag = dt / (d2 * d2.sqrt());\n-\n-                let massj_mag = bj.mass * mag;\n-                bi.vx -= dx * massj_mag;\n-                bi.vy -= dy * massj_mag;\n-                bi.vz -= dz * massj_mag;\n-\n-                let massi_mag = bi.mass * mag;\n-                bj.vx += dx * massi_mag;\n-                bj.vy += dy * massi_mag;\n-                bj.vz += dz * massi_mag;\n-            }\n-            bi.x += dt * bi.vx;\n-            bi.y += dt * bi.vy;\n-            bi.z += dt * bi.vz;\n+/// Computes all pairwise position differences between the planets.\n+fn pairwise_diffs(bodies: &[Planet; N_BODIES], diff: &mut [Vec3; N_PAIRS]) {\n+    let mut bodies = bodies.iter();\n+    let mut diff = diff.iter_mut();\n+    while let Some(bi) = bodies.next() {\n+        for bj in bodies.clone() {\n+            *diff.next().unwrap() = bi.pos - bj.pos;\n+        }\n+    }\n+}\n+\n+/// Computes the magnitude of the force between each pair of planets.\n+fn magnitudes(diff: &[Vec3; N_PAIRS], dt: f64, mag: &mut [f64; N_PAIRS]) {\n+    for (mag, diff) in mag.iter_mut().zip(diff.iter()) {\n+        let d2 = diff.squared_norm();\n+        *mag = dt / (d2 * d2.sqrt());\n+    }\n+}\n+\n+/// Updates the velocities of the planets by computing their gravitational\n+/// accelerations and performing one step of Euler integration.\n+fn update_velocities(bodies: &mut [Planet; N_BODIES], dt: f64,\n+                     diff: &mut [Vec3; N_PAIRS], mag: &mut [f64; N_PAIRS]) {\n+    pairwise_diffs(bodies, diff);\n+    magnitudes(&diff, dt, mag);\n+\n+    let mut bodies = &mut bodies[..];\n+    let mut mag = mag.iter();\n+    let mut diff = diff.iter();\n+    while let Some(bi) = shift_mut_ref(&mut bodies) {\n+        for bj in bodies.iter_mut() {\n+            let diff = *diff.next().unwrap();\n+            let mag = *mag.next().unwrap();\n+            bi.vel = bi.vel - diff * (bj.mass * mag);\n+            bj.vel = bj.vel + diff * (bi.mass * mag);\n         }\n     }\n }\n \n-fn energy(bodies: &[Planet;N_BODIES]) -> f64 {\n+/// Advances the solar system by one timestep by first updating the\n+/// velocities and then integrating the positions using the updated velocities.\n+///\n+/// Note: the `diff` & `mag` arrays are effectively scratch space. They're\n+/// provided as arguments to avoid re-zeroing them every time `advance` is\n+/// called.\n+fn advance(mut bodies: &mut [Planet; N_BODIES], dt: f64,\n+           diff: &mut [Vec3; N_PAIRS], mag: &mut [f64; N_PAIRS]) {\n+    update_velocities(bodies, dt, diff, mag);\n+    for body in bodies.iter_mut() {\n+        body.pos = body.pos + body.vel * dt;\n+    }\n+}\n+\n+/// Computes the total energy of the solar system.\n+fn energy(bodies: &[Planet; N_BODIES]) -> f64 {\n     let mut e = 0.0;\n     let mut bodies = bodies.iter();\n-    loop {\n-        let bi = match bodies.next() {\n-            Some(bi) => bi,\n-            None => break\n-        };\n-        e += (bi.vx * bi.vx + bi.vy * bi.vy + bi.vz * bi.vz) * bi.mass / 2.0;\n-        for bj in bodies.clone() {\n-            let dx = bi.x - bj.x;\n-            let dy = bi.y - bj.y;\n-            let dz = bi.z - bj.z;\n-            let dist = (dx * dx + dy * dy + dz * dz).sqrt();\n-            e -= bi.mass * bj.mass / dist;\n-        }\n+    while let Some(bi) = bodies.next() {\n+        e += bi.vel.squared_norm() * bi.mass / 2.0\n+           - bi.mass * bodies.clone()\n+                             .map(|bj| bj.mass / (bi.pos - bj.pos).norm())\n+                             .fold(0.0, |a, b| a + b);\n     }\n     e\n }\n \n-fn offset_momentum(bodies: &mut [Planet;N_BODIES]) {\n-    let mut px = 0.0;\n-    let mut py = 0.0;\n-    let mut pz = 0.0;\n-    for bi in bodies.iter() {\n-        px += bi.vx * bi.mass;\n-        py += bi.vy * bi.mass;\n-        pz += bi.vz * bi.mass;\n-    }\n-    let sun = &mut bodies[0];\n-    sun.vx = - px / SOLAR_MASS;\n-    sun.vy = - py / SOLAR_MASS;\n-    sun.vz = - pz / SOLAR_MASS;\n+/// Offsets the sun's velocity to make the overall momentum of the system zero.\n+fn offset_momentum(bodies: &mut [Planet; N_BODIES]) {\n+    let p = bodies.iter().fold(Vec3::zero(), |v, b| v + b.vel * b.mass);\n+    bodies[0].vel = p * (-1.0 / bodies[0].mass);\n }\n \n fn main() {\n@@ -178,11 +219,15 @@ fn main() {\n             .unwrap_or(1000)\n     };\n     let mut bodies = BODIES;\n+    let mut diff = [Vec3::zero(); N_PAIRS];\n+    let mut mag = [0.0f64; N_PAIRS];\n \n     offset_momentum(&mut bodies);\n     println!(\"{:.9}\", energy(&bodies));\n \n-    advance(&mut bodies, 0.01, n);\n+    for _ in (0..n) {\n+        advance(&mut bodies, 0.01, &mut diff, &mut mag);\n+    }\n \n     println!(\"{:.9}\", energy(&bodies));\n }"}]}