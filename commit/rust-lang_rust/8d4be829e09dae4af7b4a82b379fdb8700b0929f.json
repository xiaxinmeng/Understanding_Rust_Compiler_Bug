{"sha": "8d4be829e09dae4af7b4a82b379fdb8700b0929f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNGJlODI5ZTA5ZGFlNGFmN2I0YTgyYjM3OWZkYjg3MDBiMDkyOWY=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2021-04-03T21:04:31Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2021-04-04T17:52:43Z"}, "message": "Add convert tuple struct to named struct assist", "tree": {"sha": "860e45f32fc34b5f443addd04583658118ad2daa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/860e45f32fc34b5f443addd04583658118ad2daa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d4be829e09dae4af7b4a82b379fdb8700b0929f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4be829e09dae4af7b4a82b379fdb8700b0929f", "html_url": "https://github.com/rust-lang/rust/commit/8d4be829e09dae4af7b4a82b379fdb8700b0929f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d4be829e09dae4af7b4a82b379fdb8700b0929f/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3a112d68c74cbd02630f6c909071c94872c193f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a112d68c74cbd02630f6c909071c94872c193f", "html_url": "https://github.com/rust-lang/rust/commit/d3a112d68c74cbd02630f6c909071c94872c193f"}], "stats": {"total": 406, "additions": 397, "deletions": 9}, "files": [{"sha": "b2f7be011ed2ead30caac30ce5cd3e7861fc8f3b", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=8d4be829e09dae4af7b4a82b379fdb8700b0929f", "patch": "@@ -0,0 +1,345 @@\n+use hir::{Adt, ModuleDef};\n+use ide_db::defs::Definition;\n+use syntax::{\n+    ast::{self, AstNode, GenericParamsOwner, VisibilityOwner},\n+    match_ast,\n+};\n+\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_tuple_struct_to_named_struct\n+//\n+// Converts tuple struct to struct with named fields.\n+//\n+// ```\n+// struct Inner;\n+// struct A$0(Inner);\n+// ```\n+// ->\n+// ```\n+// struct Inner;\n+// struct A { field1: Inner }\n+// ```\n+pub(crate) fn convert_tuple_struct_to_named_struct(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n+    let tuple_fields = match strukt.field_list()? {\n+        ast::FieldList::TupleFieldList(it) => it,\n+        ast::FieldList::RecordFieldList(_) => return None,\n+    };\n+\n+    let target = strukt.syntax().text_range();\n+    acc.add(\n+        AssistId(\"convert_tuple_struct_to_named_struct\", AssistKind::RefactorRewrite),\n+        \"Convert to named struct\",\n+        target,\n+        |edit| {\n+            let names = generate_names(tuple_fields.fields());\n+            edit_field_references(ctx, edit, tuple_fields.fields(), &names);\n+            edit_struct_references(ctx, edit, &strukt, &names);\n+            edit_struct_def(ctx, edit, &strukt, tuple_fields, names);\n+        },\n+    )\n+}\n+\n+fn edit_struct_def(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    strukt: &ast::Struct,\n+    tuple_fields: ast::TupleFieldList,\n+    names: Vec<ast::Name>,\n+) {\n+    let record_fields = tuple_fields\n+        .fields()\n+        .zip(names)\n+        .map(|(f, name)| ast::make::record_field(f.visibility(), name, f.ty().unwrap()));\n+    let record_fields = ast::make::record_field_list(record_fields);\n+    let tuple_fields_text_range = tuple_fields.syntax().text_range();\n+\n+    edit.edit_file(ctx.frange.file_id);\n+\n+    if let Some(w) = strukt.where_clause() {\n+        edit.delete(w.syntax().text_range());\n+        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+        edit.insert(tuple_fields_text_range.start(), w.syntax().text());\n+        edit.insert(tuple_fields_text_range.start(), \",\");\n+        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+    } else {\n+        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n+    }\n+\n+    edit.replace(tuple_fields_text_range, record_fields.to_string());\n+    strukt.semicolon_token().map(|t| edit.delete(t.text_range()));\n+}\n+\n+fn edit_struct_references(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    strukt: &ast::Struct,\n+    names: &[ast::Name],\n+) {\n+    let strukt_def = ctx.sema.to_def(strukt).unwrap();\n+    let usages = Definition::ModuleDef(ModuleDef::Adt(Adt::Struct(strukt_def)))\n+        .usages(&ctx.sema)\n+        .include_self_kw_refs(true)\n+        .all();\n+\n+    for (file_id, refs) in usages {\n+        edit.edit_file(file_id);\n+        for r in refs {\n+            for node in r.name.syntax().ancestors() {\n+                match_ast! {\n+                    match node {\n+                        ast::TupleStructPat(tuple_struct_pat) => {\n+                            edit.replace(\n+                                tuple_struct_pat.syntax().text_range(),\n+                                ast::make::record_pat_with_fields(\n+                                    tuple_struct_pat.path().unwrap(),\n+                                    ast::make::record_pat_field_list(tuple_struct_pat.fields().zip(names).map(\n+                                        |(pat, name)| {\n+                                            ast::make::record_pat_field(\n+                                                ast::make::name_ref(&name.to_string()),\n+                                                pat,\n+                                            )\n+                                        },\n+                                    )),\n+                                )\n+                                .to_string(),\n+                            );\n+                        },\n+                        // for tuple struct creations like: Foo(42)\n+                        ast::CallExpr(call_expr) => {\n+                            let path = call_expr.syntax().descendants().find_map(ast::PathExpr::cast).unwrap();\n+                            let arg_list =\n+                                call_expr.syntax().descendants().find_map(ast::ArgList::cast).unwrap();\n+\n+                            edit.replace(\n+                                call_expr.syntax().text_range(),\n+                                ast::make::record_expr(\n+                                    path.path().unwrap(),\n+                                    ast::make::record_expr_field_list(arg_list.args().zip(names).map(\n+                                        |(expr, name)| {\n+                                            ast::make::record_expr_field(\n+                                                ast::make::name_ref(&name.to_string()),\n+                                                Some(expr),\n+                                            )\n+                                        },\n+                                    )),\n+                                )\n+                                .to_string(),\n+                            );\n+                        },\n+                        _ => ()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn edit_field_references(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    fields: impl Iterator<Item = ast::TupleField>,\n+    names: &[ast::Name],\n+) {\n+    for (field, name) in fields.zip(names) {\n+        let field = match ctx.sema.to_def(&field) {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        let def = Definition::Field(field);\n+        let usages = def.usages(&ctx.sema).all();\n+        for (file_id, refs) in usages {\n+            edit.edit_file(file_id);\n+            for r in refs {\n+                if let Some(name_ref) = r.name.as_name_ref() {\n+                    edit.replace(name_ref.syntax().text_range(), name.text());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn generate_names(fields: impl Iterator<Item = ast::TupleField>) -> Vec<ast::Name> {\n+    fields.enumerate().map(|(i, _)| ast::make::name(&format!(\"field{}\", i + 1))).collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_other_than_tuple_struct() {\n+        check_assist_not_applicable(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"struct Foo$0 { bar: u32 };\"#,\n+        );\n+        check_assist_not_applicable(convert_tuple_struct_to_named_struct, r#\"struct Foo$0;\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_struct() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner;\n+struct A$0(Inner);\n+\n+impl A {\n+    fn new() -> A {\n+        A(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A { field1: Inner }\n+\n+impl A {\n+    fn new() -> A {\n+        A { field1: Inner }\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.field1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_referenced_via_self_kw() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner;\n+struct A$0(Inner);\n+\n+impl A {\n+    fn new() -> Self {\n+        Self(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A { field1: Inner }\n+\n+impl A {\n+    fn new() -> Self {\n+        Self { field1: Inner }\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.field1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_struct() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner;\n+struct A$0(Inner);\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self(first) = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A { field1: Inner }\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_visibility() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct A$0(pub u32, pub(crate) u64);\n+\n+impl A {\n+    fn new() -> A {\n+        A(42, 42)\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.0\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.1\n+    }\n+}\"#,\n+            r#\"\n+struct A { pub field1: u32, pub(crate) field2: u64 }\n+\n+impl A {\n+    fn new() -> A {\n+        A { field1: 42, field2: 42 }\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.field1\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.field2\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_where_clause() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Wrap$0<T>(T)\n+where\n+    T: Display;\n+\"#,\n+            r#\"\n+struct Wrap<T>\n+where\n+    T: Display,\n+{ field1: T }\n+\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "1c55b9fbf967928278049501213454fd68bb2df5", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=8d4be829e09dae4af7b4a82b379fdb8700b0929f", "patch": "@@ -118,6 +118,7 @@ mod handlers {\n     mod convert_comment_block;\n     mod convert_iter_for_each_to_for;\n     mod convert_into_to_from;\n+    mod convert_tuple_struct_to_named_struct;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_function;\n@@ -187,6 +188,7 @@ mod handlers {\n             convert_comment_block::convert_comment_block,\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_into_to_from::convert_into_to_from,\n+            convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,"}, {"sha": "53f455adf9def6ef1846c6c9bdaadde0cd409a8c", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=8d4be829e09dae4af7b4a82b379fdb8700b0929f", "patch": "@@ -291,6 +291,21 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_tuple_struct_to_named_struct() {\n+    check_doc_test(\n+        \"convert_tuple_struct_to_named_struct\",\n+        r#####\"\n+struct Inner;\n+struct A$0(Inner);\n+\"#####,\n+        r#####\"\n+struct Inner;\n+struct A { field1: Inner }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_expand_glob_import() {\n     check_doc_test("}, {"sha": "90e4e7b03735772bc4d92b5b97b8767ecfceac57", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=8d4be829e09dae4af7b4a82b379fdb8700b0929f", "patch": "@@ -430,6 +430,15 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, &name_ref) {\n+            Some(NameRefClass::Definition(def)) if &def == self.def => {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    access: reference_access(&def, &name_ref),\n+                };\n+                sink(file_id, reference)\n+            }\n             Some(NameRefClass::Definition(Definition::SelfType(impl_))) => {\n                 let ty = impl_.self_ty(self.sema.db);\n \n@@ -448,15 +457,6 @@ impl<'a> FindUsages<'a> {\n \n                 false\n             }\n-            Some(NameRefClass::Definition(def)) if &def == self.def => {\n-                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference = FileReference {\n-                    range,\n-                    name: ast::NameLike::NameRef(name_ref.clone()),\n-                    access: reference_access(&def, &name_ref),\n-                };\n-                sink(file_id, reference)\n-            }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = match self.def {"}, {"sha": "3a588e540033a5fbc5c191b0cae4b3e2348c2815", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4be829e09dae4af7b4a82b379fdb8700b0929f/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=8d4be829e09dae4af7b4a82b379fdb8700b0929f", "patch": "@@ -133,6 +133,17 @@ pub fn use_(visibility: Option<ast::Visibility>, use_tree: ast::UseTree) -> ast:\n     ast_from_text(&format!(\"{}use {};\", visibility, use_tree))\n }\n \n+pub fn record_expr(path: ast::Path, fields: ast::RecordExprFieldList) -> ast::RecordExpr {\n+    ast_from_text(&format!(\"fn f() {{ {} {} }}\", path, fields))\n+}\n+\n+pub fn record_expr_field_list(\n+    fields: impl IntoIterator<Item = ast::RecordExprField>,\n+) -> ast::RecordExprFieldList {\n+    let fields = fields.into_iter().join(\", \");\n+    ast_from_text(&format!(\"fn f() {{ S {{ {} }} }}\", fields))\n+}\n+\n pub fn record_expr_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordExprField {\n     return match expr {\n         Some(expr) => from_text(&format!(\"{}: {}\", name, expr)),\n@@ -325,6 +336,21 @@ pub fn record_pat(path: ast::Path, pats: impl IntoIterator<Item = ast::Pat>) ->\n     }\n }\n \n+pub fn record_pat_with_fields(path: ast::Path, fields: ast::RecordPatFieldList) -> ast::RecordPat {\n+    ast_from_text(&format!(\"fn f({} {}: ()))\", path, fields))\n+}\n+\n+pub fn record_pat_field_list(\n+    fields: impl IntoIterator<Item = ast::RecordPatField>,\n+) -> ast::RecordPatFieldList {\n+    let fields = fields.into_iter().join(\", \");\n+    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", fields))\n+}\n+\n+pub fn record_pat_field(name_ref: ast::NameRef, pat: ast::Pat) -> ast::RecordPatField {\n+    ast_from_text(&format!(\"fn f(S {{ {}: {} }}: ()))\", name_ref, pat))\n+}\n+\n /// Returns a `BindPat` if the path has just one segment, a `PathPat` otherwise.\n pub fn path_pat(path: ast::Path) -> ast::Pat {\n     return from_text(&path.to_string());"}]}