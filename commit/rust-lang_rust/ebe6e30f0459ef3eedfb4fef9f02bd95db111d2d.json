{"sha": "ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d", "node_id": "C_kwDOAAsO6NoAKGViZTZlMzBmMDQ1OWVmM2VlZGZiNGZlZjlmMDJiZDk1ZGIxMTFkMmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T15:22:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T15:22:49Z"}, "message": "Auto merge of #12054 - HKalbasi:const_generic, r=flodiebold\n\nFix const generic panic in dyn trait\n\nfix #12048", "tree": {"sha": "308b79e67996543a4eb492eee863e231547dd5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/308b79e67996543a4eb492eee863e231547dd5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d", "html_url": "https://github.com/rust-lang/rust/commit/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6b5214c666b64cf9125bebc39d6a8ad08262870", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6b5214c666b64cf9125bebc39d6a8ad08262870", "html_url": "https://github.com/rust-lang/rust/commit/b6b5214c666b64cf9125bebc39d6a8ad08262870"}, {"sha": "785ae4dfa8816028cd75dc71ae7cc2ff4f7ff7b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/785ae4dfa8816028cd75dc71ae7cc2ff4f7ff7b8", "html_url": "https://github.com/rust-lang/rust/commit/785ae4dfa8816028cd75dc71ae7cc2ff4f7ff7b8"}], "stats": {"total": 107, "additions": 71, "deletions": 36}, "files": [{"sha": "a3787728eac08835b4dab7af96e4704ea52111db", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d", "patch": "@@ -681,23 +681,31 @@ impl<'a> TyLoweringContext<'a> {\n \n         let ty_error = GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner);\n \n-        for eid in def_generics.iter_id().take(parent_params) {\n-            match eid {\n-                Either::Left(_) => substs.push(ty_error.clone()),\n-                Either::Right(x) => {\n-                    substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n+        let mut def_generic_iter = def_generics.iter_id();\n+\n+        for _ in 0..parent_params {\n+            if let Some(eid) = def_generic_iter.next() {\n+                match eid {\n+                    Either::Left(_) => substs.push(ty_error.clone()),\n+                    Either::Right(x) => {\n+                        substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n+                    }\n                 }\n             }\n         }\n \n         let fill_self_params = || {\n-            substs.extend(\n-                explicit_self_ty\n-                    .into_iter()\n-                    .map(|x| GenericArgData::Ty(x).intern(Interner))\n-                    .chain(iter::repeat(ty_error.clone()))\n-                    .take(self_params),\n-            )\n+            for x in explicit_self_ty\n+                .into_iter()\n+                .map(|x| GenericArgData::Ty(x).intern(Interner))\n+                .chain(iter::repeat(ty_error.clone()))\n+                .take(self_params)\n+            {\n+                if let Some(id) = def_generic_iter.next() {\n+                    assert!(id.is_left());\n+                    substs.push(x);\n+                }\n+            }\n         };\n         let mut had_explicit_args = false;\n \n@@ -712,34 +720,38 @@ impl<'a> TyLoweringContext<'a> {\n             };\n             let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for (arg, id) in generic_args\n+            for arg in generic_args\n                 .args\n                 .iter()\n                 .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n                 .skip(skip)\n                 .take(expected_num)\n-                .zip(def_generics.iter_id().skip(parent_params + skip))\n             {\n-                if let Some(x) = generic_arg_to_chalk(\n-                    self.db,\n-                    id,\n-                    arg,\n-                    &mut (),\n-                    |_, type_ref| self.lower_ty(type_ref),\n-                    |_, c, ty| {\n-                        const_or_path_to_chalk(\n-                            self.db,\n-                            &self.resolver,\n-                            ty,\n-                            c,\n-                            self.type_param_mode,\n-                            || self.generics(),\n-                            self.in_binders,\n-                        )\n-                    },\n-                ) {\n-                    had_explicit_args = true;\n-                    substs.push(x);\n+                if let Some(id) = def_generic_iter.next() {\n+                    if let Some(x) = generic_arg_to_chalk(\n+                        self.db,\n+                        id,\n+                        arg,\n+                        &mut (),\n+                        |_, type_ref| self.lower_ty(type_ref),\n+                        |_, c, ty| {\n+                            const_or_path_to_chalk(\n+                                self.db,\n+                                &self.resolver,\n+                                ty,\n+                                c,\n+                                self.type_param_mode,\n+                                || self.generics(),\n+                                self.in_binders,\n+                            )\n+                        },\n+                    ) {\n+                        had_explicit_args = true;\n+                        substs.push(x);\n+                    } else {\n+                        // we just filtered them out\n+                        never!(\"Unexpected lifetime argument\");\n+                    }\n                 }\n             }\n         } else {\n@@ -757,21 +769,24 @@ impl<'a> TyLoweringContext<'a> {\n                 for default_ty in defaults.iter().skip(substs.len()) {\n                     // each default can depend on the previous parameters\n                     let substs_so_far = Substitution::from_iter(Interner, substs.clone());\n-                    substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n+                    if let Some(_id) = def_generic_iter.next() {\n+                        substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n+                    }\n                 }\n             }\n         }\n \n         // add placeholders for args that were not provided\n         // FIXME: emit diagnostics in contexts where this is not allowed\n-        for eid in def_generics.iter_id().skip(substs.len()) {\n+        for eid in def_generic_iter {\n             match eid {\n                 Either::Left(_) => substs.push(ty_error.clone()),\n                 Either::Right(x) => {\n                     substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n                 }\n             }\n         }\n+        // If this assert fails, it means you pushed into subst but didn't call .next() of def_generic_iter\n         assert_eq!(substs.len(), total_len);\n \n         Substitution::from_iter(Interner, substs)\n@@ -1659,6 +1674,10 @@ pub(crate) fn lower_to_chalk_mutability(m: hir_def::type_ref::Mutability) -> Mut\n     }\n }\n \n+/// Checks if the provided generic arg matches its expected kind, then lower them via\n+/// provided closures. Use unknown if there was kind mismatch.\n+///\n+/// Returns `Some` of the lowered generic arg. `None` if the provided arg is a lifetime.\n pub(crate) fn generic_arg_to_chalk<'a, T>(\n     db: &dyn HirDatabase,\n     kind_id: Either<TypeParamId, ConstParamId>,"}, {"sha": "ef27667ffa5729ee2c242a501ce17497afe0eadb", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=ebe6e30f0459ef3eedfb4fef9f02bd95db111d2d", "patch": "@@ -1470,6 +1470,22 @@ fn regression_11688_3() {\n     );\n }\n \n+#[test]\n+fn regression_11688_4() {\n+    check_types(\n+        r#\"\n+        trait Bar<const C: usize> {\n+            fn baz(&self) -> [i32; C];\n+        }\n+\n+        fn foo(x: &dyn Bar<2>) {\n+            x.baz();\n+          //^^^^^^^ [i32; 2]\n+        }\n+        \"#,\n+    )\n+}\n+\n #[test]\n fn gat_crash_1() {\n     cov_mark::check!(ignore_gats);"}]}