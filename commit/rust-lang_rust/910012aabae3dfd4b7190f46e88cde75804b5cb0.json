{"sha": "910012aabae3dfd4b7190f46e88cde75804b5cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMDAxMmFhYmFlM2RmZDRiNzE5MGY0NmU4OGNkZTc1ODA0YjVjYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-02T16:31:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-02T16:31:33Z"}, "message": "auto merge of #12637 : pcwalton/rust/devecing, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "ac07696b5bb7a8ba6dacd1b2abd3926b59621058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac07696b5bb7a8ba6dacd1b2abd3926b59621058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/910012aabae3dfd4b7190f46e88cde75804b5cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/910012aabae3dfd4b7190f46e88cde75804b5cb0", "html_url": "https://github.com/rust-lang/rust/commit/910012aabae3dfd4b7190f46e88cde75804b5cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/910012aabae3dfd4b7190f46e88cde75804b5cb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baf79083aedb8ae64efddbcf28b358841cfd1157", "url": "https://api.github.com/repos/rust-lang/rust/commits/baf79083aedb8ae64efddbcf28b358841cfd1157", "html_url": "https://github.com/rust-lang/rust/commit/baf79083aedb8ae64efddbcf28b358841cfd1157"}, {"sha": "355932407ba324d33cd9353a69203f7f76c059a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/355932407ba324d33cd9353a69203f7f76c059a6", "html_url": "https://github.com/rust-lang/rust/commit/355932407ba324d33cd9353a69203f7f76c059a6"}], "stats": {"total": 3751, "additions": 2144, "deletions": 1607}, "files": [{"sha": "c465c8f1e1608a7ec8801917fc1645687c26c76a", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -131,7 +131,11 @@ struct Ident {\n }\n \n fn parse_tts(cx: &ExtCtxt, tts: &[ast::TokenTree]) -> (@ast::Expr, Option<Ident>) {\n-    let p = &mut parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_owned());\n+    let p = &mut parse::new_parser_from_tts(cx.parse_sess(),\n+                                            cx.cfg(),\n+                                            tts.iter()\n+                                               .map(|x| (*x).clone())\n+                                               .collect());\n     let ex = p.parse_expr();\n     let id = if p.token == token::EOF {\n         None\n@@ -151,7 +155,7 @@ fn parse_tts(cx: &ExtCtxt, tts: &[ast::TokenTree]) -> (@ast::Expr, Option<Ident>\n fn target_endian_little(cx: &ExtCtxt, sp: Span) -> bool {\n     let meta = cx.meta_name_value(sp, InternedString::new(\"target_endian\"),\n         ast::LitStr(InternedString::new(\"little\"), ast::CookedStr));\n-    contains(cx.cfg(), meta)\n+    contains(cx.cfg().as_slice(), meta)\n }\n \n // FIXME (10872): This is required to prevent an LLVM assert on Windows"}, {"sha": "4d86848482e8d0f18d55d849d4b5828d1dce4ad7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -519,7 +519,7 @@ pub fn crate_id_hash(crate_id: &CrateId) -> ~str {\n pub fn build_link_meta(krate: &ast::Crate,\n                        output: &OutputFilenames) -> LinkMeta {\n     let r = LinkMeta {\n-        crateid: find_crate_id(krate.attrs, output),\n+        crateid: find_crate_id(krate.attrs.as_slice(), output),\n         crate_hash: Svh::calculate(krate),\n     };\n     info!(\"{}\", r);"}, {"sha": "88526dd15a9138737b0f56e68cc603cf198c1f3c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -35,6 +35,8 @@ use std::io::fs;\n use std::io::MemReader;\n use std::os;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use collections::{HashMap, HashSet};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n@@ -101,15 +103,15 @@ pub fn default_configuration(sess: Session) ->\n     };\n \n     let mk = attr::mk_name_value_item_str;\n-    return ~[ // Target bindings.\n+    return vec!(// Target bindings.\n          attr::mk_word_item(fam.clone()),\n          mk(InternedString::new(\"target_os\"), tos),\n          mk(InternedString::new(\"target_family\"), fam),\n          mk(InternedString::new(\"target_arch\"), InternedString::new(arch)),\n          mk(InternedString::new(\"target_endian\"), InternedString::new(end)),\n          mk(InternedString::new(\"target_word_size\"),\n-            InternedString::new(wordsz)),\n-    ];\n+            InternedString::new(wordsz))\n+    );\n }\n \n pub fn append_configuration(cfg: &mut ast::CrateConfig,\n@@ -119,8 +121,7 @@ pub fn append_configuration(cfg: &mut ast::CrateConfig,\n     }\n }\n \n-pub fn build_configuration(sess: Session) ->\n-   ast::CrateConfig {\n+pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess);\n@@ -135,15 +136,19 @@ pub fn build_configuration(sess: Session) ->\n     } else {\n         InternedString::new(\"nogc\")\n     });\n-    return vec::append(user_cfg, default_cfg);\n+    return vec_ng::append(user_cfg.move_iter().collect(),\n+                          default_cfg.as_slice());\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str])\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess();\n-        parse::parse_meta_from_source_str(\"cfgspec\".to_str(), s, ~[], sess)\n+        parse::parse_meta_from_source_str(\"cfgspec\".to_str(),\n+                                          s,\n+                                          Vec::new(),\n+                                          sess)\n     }).collect::<ast::CrateConfig>()\n }\n \n@@ -193,7 +198,9 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(sess.opts, &krate));\n-    sess.crate_types.set(session::collect_crate_types(&sess, krate.attrs));\n+    sess.crate_types.set(session::collect_crate_types(&sess,\n+                                                      krate.attrs\n+                                                           .as_slice()));\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &krate));\n@@ -472,7 +479,7 @@ fn write_out_deps(sess: Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n-    let id = link::find_crate_id(krate.attrs, outputs);\n+    let id = link::find_crate_id(krate.attrs.as_slice(), outputs);\n \n     let mut out_filenames = ~[];\n     for output_type in sess.opts.output_types.iter() {\n@@ -546,8 +553,11 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n             let loader = &mut Loader::new(sess);\n             phase_2_configure_and_expand(sess, loader, krate)\n         };\n-        let outputs = build_output_filenames(input, outdir, output,\n-                                             expanded_crate.attrs, sess);\n+        let outputs = build_output_filenames(input,\n+                                             outdir,\n+                                             output,\n+                                             expanded_crate.attrs.as_slice(),\n+                                             sess);\n \n         write_out_deps(sess, input, &outputs, &expanded_crate).unwrap();\n \n@@ -1180,7 +1190,7 @@ mod test {\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None);\n         let cfg = build_configuration(sess);\n-        assert!((attr::contains_name(cfg, \"test\")));\n+        assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add"}, {"sha": "d404360bf1499445c4b2b48b644c878df377acbc", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -27,6 +27,7 @@ use syntax::{abi, ast, codemap};\n use syntax;\n \n use std::cell::{Cell, RefCell};\n+use std::vec_ng::Vec;\n use collections::{HashMap,HashSet};\n \n pub struct Config {\n@@ -319,7 +320,7 @@ pub fn basic_options() -> @Options {\n         addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n-        cfg: ~[],\n+        cfg: Vec::new(),\n         test: false,\n         parse_only: false,\n         no_trans: false,\n@@ -451,7 +452,8 @@ pub fn building_library(options: &Options, krate: &ast::Crate) -> bool {\n             CrateTypeStaticlib | CrateTypeDylib | CrateTypeRlib => return true\n         }\n     }\n-    match syntax::attr::first_attr_value_str_by_name(krate.attrs, \"crate_type\") {\n+    match syntax::attr::first_attr_value_str_by_name(krate.attrs.as_slice(),\n+                                                     \"crate_type\") {\n         Some(s) => {\n             s.equiv(&(\"lib\")) ||\n             s.equiv(&(\"rlib\")) ||"}, {"sha": "26d72f843515e76e192110936a99b064e5033d8c", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,7 +21,7 @@ struct Context<'a> {\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(krate: ast::Crate) -> ast::Crate {\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(config, attrs))\n+    strip_items(krate, |attrs| in_cfg(config.as_slice(), attrs))\n }\n \n impl<'a> fold::Folder for Context<'a> {\n@@ -117,7 +117,7 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n         ast::ItemEnum(ref def, ref generics) => {\n             let mut variants = def.variants.iter().map(|c| c.clone()).\n             filter_map(|v| {\n-                if !(cx.in_cfg)(v.node.attrs) {\n+                if !(cx.in_cfg)(v.node.attrs.as_slice()) {\n                     None\n                 } else {\n                     Some(match v.node.kind {\n@@ -147,7 +147,7 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n \n fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n-        (cx.in_cfg)(m.node.attrs)\n+        (cx.in_cfg)(m.node.attrs.as_slice())\n     });\n     @ast::StructDef {\n         fields: fields.collect(),\n@@ -189,25 +189,25 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n }\n \n fn item_in_cfg(cx: &Context, item: &ast::Item) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n fn foreign_item_in_cfg(cx: &Context, item: &ast::ForeignItem) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n fn view_item_in_cfg(cx: &Context, item: &ast::ViewItem) -> bool {\n-    return (cx.in_cfg)(item.attrs);\n+    return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n fn method_in_cfg(cx: &Context, meth: &ast::Method) -> bool {\n-    return (cx.in_cfg)(meth.attrs);\n+    return (cx.in_cfg)(meth.attrs.as_slice());\n }\n \n fn trait_method_in_cfg(cx: &Context, meth: &ast::TraitMethod) -> bool {\n     match *meth {\n-        ast::Required(ref meth) => (cx.in_cfg)(meth.attrs),\n-        ast::Provided(meth) => (cx.in_cfg)(meth.attrs)\n+        ast::Required(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::Provided(meth) => (cx.in_cfg)(meth.attrs.as_slice())\n     }\n }\n "}, {"sha": "b0a901f30be650907b42d9de0711ece35b26cd43", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -171,7 +171,7 @@ impl Visitor<()> for Context {\n             }\n \n             ast::ItemForeignMod(..) => {\n-                if attr::contains_name(i.attrs, \"link_args\") {\n+                if attr::contains_name(i.attrs.as_slice(), \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n@@ -180,15 +180,15 @@ impl Visitor<()> for Context {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(i.attrs, \"macro_registrar\") {\n+                if attr::contains_name(i.attrs.as_slice(), \"macro_registrar\") {\n                     self.gate_feature(\"macro_registrar\", i.span,\n                                       \"cross-crate macro exports are \\\n                                        experimental and possibly buggy\");\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                if attr::contains_name(i.attrs, \"simd\") {\n+                if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }"}, {"sha": "eec44cc31b1a3fbff25b33af0953d2cfcfd756e4", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -11,7 +11,8 @@\n \n use driver::session::Session;\n \n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n@@ -43,11 +44,11 @@ pub fn maybe_inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n }\n \n fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs, \"no_std\")\n+    !attr::contains_name(krate.attrs.as_slice(), \"no_std\")\n }\n \n fn use_uv(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs, \"no_uv\")\n+    !attr::contains_name(krate.attrs.as_slice(), \"no_uv\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -72,42 +73,41 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n \n impl fold::Folder for StandardLibraryInjector {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n-        let mut vis = ~[ast::ViewItem {\n+        let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternMod(token::str_to_ident(\"std\"),\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n-            attrs: ~[\n+            attrs: vec!(\n                 attr::mk_attr(attr::mk_list_item(\n                         InternedString::new(\"phase\"),\n-                        ~[\n+                        vec!(\n                             attr::mk_word_item(InternedString::new(\"syntax\")),\n                             attr::mk_word_item(InternedString::new(\"link\")\n-                        )]))\n-            ],\n+                        ))))),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n-        }];\n+        });\n \n         if use_uv(&krate) && !self.sess.building_library.get() {\n             vis.push(ast::ViewItem {\n                 node: ast::ViewItemExternMod(token::str_to_ident(\"green\"),\n                                              with_version(\"green\"),\n                                              ast::DUMMY_NODE_ID),\n-                attrs: ~[],\n+                attrs: Vec::new(),\n                 vis: ast::Inherited,\n                 span: DUMMY_SP\n             });\n             vis.push(ast::ViewItem {\n                 node: ast::ViewItemExternMod(token::str_to_ident(\"rustuv\"),\n                                              with_version(\"rustuv\"),\n                                              ast::DUMMY_NODE_ID),\n-                attrs: ~[],\n+                attrs: Vec::new(),\n                 vis: ast::Inherited,\n                 span: DUMMY_SP\n             });\n         }\n \n-        vis.push_all(krate.module.view_items);\n+        vis.push_all_move(krate.module.view_items.clone());\n         let new_module = ast::Mod {\n             view_items: vis,\n             ..krate.module.clone()\n@@ -134,7 +134,7 @@ struct PreludeInjector {\n \n impl fold::Folder for PreludeInjector {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n-        if !no_prelude(krate.attrs) {\n+        if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#[no_implicit_prelude];` at the crate level.\n             ast::Crate {\n@@ -147,7 +147,7 @@ impl fold::Folder for PreludeInjector {\n     }\n \n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n-        if !no_prelude(item.attrs) {\n+        if !no_prelude(item.attrs.as_slice()) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n@@ -161,7 +161,7 @@ impl fold::Folder for PreludeInjector {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n-            segments: ~[\n+            segments: vec!(\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n                     lifetimes: opt_vec::Empty,\n@@ -171,19 +171,18 @@ impl fold::Folder for PreludeInjector {\n                     identifier: token::str_to_ident(\"prelude\"),\n                     lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n-                },\n-            ],\n+                }),\n         };\n \n         let vp = @codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n         let vi2 = ast::ViewItem {\n-            node: ast::ViewItemUse(~[vp]),\n-            attrs: ~[],\n+            node: ast::ViewItemUse(vec!(vp)),\n+            attrs: Vec::new(),\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n         };\n \n-        let vis = vec::append(~[vi2], module.view_items);\n+        let vis = vec_ng::append(vec!(vi2), module.view_items.as_slice());\n \n         // FIXME #2543: Bad copy.\n         let new_module = ast::Mod {"}, {"sha": "333504b7e8247314a2eb8beb853581f5a8e56f4e", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -10,6 +10,8 @@\n \n // Code that generates a test runner to run all the tests in a crate\n \n+#[allow(dead_code)];\n+#[allow(unused_imports)];\n \n use driver::session;\n use front::config;\n@@ -18,6 +20,8 @@ use metadata::creader::Loader;\n \n use std::cell::RefCell;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -57,7 +61,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(krate.config, \"test\");\n+    let should_test = attr::contains_name(krate.config.as_slice(), \"test\");\n \n     if should_test {\n         generate_test_harness(sess, krate)\n@@ -189,13 +193,13 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     config::strip_items(krate, |attrs| {\n-        !attr::contains_name(attrs, \"test\") &&\n-        !attr::contains_name(attrs, \"bench\")\n+        !attr::contains_name(attrs.as_slice(), \"test\") &&\n+        !attr::contains_name(attrs.as_slice(), \"bench\")\n     })\n }\n \n fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(i.attrs, \"test\");\n+    let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n \n     fn has_test_signature(i: @ast::Item) -> bool {\n         match &i.node {\n@@ -224,7 +228,7 @@ fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n }\n \n fn is_bench_fn(i: @ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(i.attrs, \"bench\");\n+    let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n     fn has_test_signature(i: @ast::Item) -> bool {\n         match i.node {\n@@ -251,20 +255,22 @@ fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         attr.name().equiv(&(\"ignore\")) && match attr.meta_item_list() {\n-            Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n+            Some(ref cfgs) => {\n+                attr::test_cfg(cx.config.as_slice(), cfgs.iter().map(|x| *x))\n+            }\n             None => true\n         }\n     })\n }\n \n fn should_fail(i: @ast::Item) -> bool {\n-    attr::contains_name(i.attrs, \"should_fail\")\n+    attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n fn add_test_module(cx: &TestCtxt, m: &ast::Mod) -> ast::Mod {\n     let testmod = mk_test_module(cx);\n     ast::Mod {\n-        items: vec::append_one(m.items.clone(), testmod),\n+        items: vec_ng::append_one(m.items.clone(), testmod),\n         ..(*m).clone()\n     }\n }\n@@ -291,26 +297,31 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n     let vi = if cx.is_test_crate {\n         ast::ViewItemUse(\n-            ~[@nospan(ast::ViewPathSimple(id_test,\n-                                          path_node(~[id_test]),\n-                                          ast::DUMMY_NODE_ID))])\n+            vec!(@nospan(ast::ViewPathSimple(id_test,\n+                                             path_node(~[id_test]),\n+                                             ast::DUMMY_NODE_ID))))\n     } else {\n         ast::ViewItemExternMod(id_test,\n                                with_version(\"test\"),\n                                ast::DUMMY_NODE_ID)\n     };\n     ast::ViewItem {\n         node: vi,\n-        attrs: ~[],\n+        attrs: Vec::new(),\n         vis: ast::Inherited,\n         span: DUMMY_SP\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n+#[cfg(stage0)]\n+fn mk_test_module(_: &TestCtxt) -> @ast::Item {\n+    fail!(\"test disabled in this stage due to quasiquoter\")\n+}\n \n+#[cfg(not(stage0))]\n+fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     // Link to test crate\n-    let view_items = ~[mk_std(cx)];\n+    let view_items = vec!(mk_std(cx));\n \n     // A constant vector of test descriptors.\n     let tests = mk_tests(cx);\n@@ -326,7 +337,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     let testmod = ast::Mod {\n         view_items: view_items,\n-        items: ~[mainfn, tests],\n+        items: vec!(mainfn, tests),\n     };\n     let item_ = ast::ItemMod(testmod);\n \n@@ -337,7 +348,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     let item = ast::Item {\n         ident: token::str_to_ident(\"__test\"),\n-        attrs: ~[resolve_unexported_attr],\n+        attrs: vec!(resolve_unexported_attr),\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n@@ -377,6 +388,12 @@ fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n     }\n }\n \n+#[cfg(stage0)]\n+fn mk_tests(_: &TestCtxt) -> @ast::Item {\n+    fail!(\"tests disabled in this stage due to quasiquoter\")\n+}\n+\n+#[cfg(not(stage0))]\n fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n@@ -389,14 +406,14 @@ fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crateid(krate.attrs) {\n+    match attr::find_crateid(krate.attrs.as_slice()) {\n         Some(ref s) if \"test\" == s.name => true,\n         _ => false\n     }\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n-    let mut descs = ~[];\n+    let mut descs = Vec::new();\n     {\n         let testfns = cx.testfns.borrow();\n         debug!(\"building test vector from {} tests\", testfns.get().len());\n@@ -418,6 +435,12 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     }\n }\n \n+#[cfg(stage0)]\n+fn mk_test_desc_and_fn_rec(_: &TestCtxt, _: &Test) -> @ast::Expr {\n+    fail!(\"tests disabled in this stage due to quasiquoter\")\n+}\n+\n+#[cfg(not(stage0))]\n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();"}, {"sha": "235e1c72455c2693552bfde44000b858821d4108", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -54,6 +54,7 @@ use std::os;\n use std::str;\n use std::task;\n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n@@ -334,19 +335,22 @@ pub fn run_compiler(args: &[~str]) {\n     d::compile_input(sess, cfg, &input, &odir, &ofile);\n }\n \n-fn parse_crate_attrs(sess: session::Session,\n-                     input: &d::Input) -> ~[ast::Attribute] {\n-    match *input {\n+fn parse_crate_attrs(sess: session::Session, input: &d::Input) ->\n+                     ~[ast::Attribute] {\n+    let result = match *input {\n         d::FileInput(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile, ~[], sess.parse_sess)\n+            parse::parse_crate_attrs_from_file(ifile,\n+                                               Vec::new(),\n+                                               sess.parse_sess)\n         }\n         d::StrInput(ref src) => {\n             parse::parse_crate_attrs_from_source_str(d::anon_src(),\n                                                      (*src).clone(),\n-                                                     ~[],\n+                                                     Vec::new(),\n                                                      sess.parse_sess)\n         }\n-    }\n+    };\n+    result.move_iter().collect()\n }\n \n /// Run a procedure which will detect failures in the compiler and print nicer"}, {"sha": "58268d1169b2ffae7ed6533de3e3d9672af1471f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -23,6 +23,7 @@ use metadata::loader;\n use metadata::loader::Os;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n use syntax::ast;\n use syntax::abi;\n@@ -140,7 +141,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n     let should_load = i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n-                attr::contains_name(phases, \"link\")\n+                attr::contains_name(phases.as_slice(), \"link\")\n             })\n     });\n \n@@ -420,8 +421,9 @@ impl CrateLoader for Loader {\n         }\n     }\n \n-    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> ~[~str] {\n-        csearch::get_exported_macros(self.env.sess.cstore, cnum)\n+    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> Vec<~str> {\n+        csearch::get_exported_macros(self.env.sess.cstore, cnum).move_iter()\n+                                                                .collect()\n     }\n \n     fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {"}, {"sha": "1e90748158fd84342f32b625f21bbaa8d88ed5b4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -1057,7 +1057,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(n, subitems));\n+        items.push(attr::mk_list_item(n, subitems.move_iter().collect()));\n         true\n     });\n     return items;"}, {"sha": "3a490845c60989bc32170262d7bdf3aa6f963cc7", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -349,15 +349,18 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(ebml_w, variant.node.name.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n-        encode_attributes(ebml_w, variant.node.attrs);\n+        encode_attributes(ebml_w, variant.node.attrs.as_slice());\n         match variant.node.kind {\n             ast::TupleVariantKind(ref args)\n                     if args.len() > 0 && generics.ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(def) => {\n-                let idx = encode_info_for_struct(ecx, ebml_w, def.fields, index);\n+                let idx = encode_info_for_struct(ecx,\n+                                                 ebml_w,\n+                                                 def.fields.as_slice(),\n+                                                 index);\n                 encode_struct_fields(ebml_w, def);\n                 let bkts = create_index(idx);\n                 encode_index(ebml_w, bkts, write_i64);\n@@ -516,7 +519,7 @@ fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n-                        struct_def.fields[0].node.kind ==\n+                        struct_def.fields.get(0).node.kind ==\n                         ast::UnnamedField => {\n                     continue_ = callback(ctor_id);\n                 }\n@@ -799,13 +802,17 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     let elem = ast_map::PathName(m.ident.name);\n     encode_path(ebml_w, impl_path.chain(Some(elem).move_iter()));\n     match ast_method_opt {\n-        Some(ast_method) => encode_attributes(ebml_w, ast_method.attrs),\n+        Some(ast_method) => {\n+            encode_attributes(ebml_w, ast_method.attrs.as_slice())\n+        }\n         None => ()\n     }\n \n     for &ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs().len();\n-        if num_params > 0u || is_default_impl || should_inline(ast_method.attrs) {\n+        if num_params > 0u ||\n+                is_default_impl ||\n+                should_inline(ast_method.attrs.as_slice()) {\n             (ecx.encode_inlined_item)(\n                 ecx, ebml_w, IIMethodRef(local_def(parent_id), false, ast_method));\n         } else {\n@@ -930,8 +937,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n         encode_path(ebml_w, path);\n-        encode_attributes(ebml_w, item.attrs);\n-        if tps_len > 0u || should_inline(item.attrs) {\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n+        if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n             (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n@@ -986,7 +993,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(ebml_w, ecx, item.id);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n@@ -1002,7 +1009,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  ebml_w,\n                                  item.id,\n-                                 (*enum_definition).variants,\n+                                 (*enum_definition).variants.as_slice(),\n                                  index,\n                                  generics);\n       }\n@@ -1012,7 +1019,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_struct(ecx, ebml_w,\n-                                         struct_def.fields, index);\n+                                         struct_def.fields.as_slice(), index);\n \n         /* Index the class*/\n         add_to_index(item, ebml_w, index);\n@@ -1025,7 +1032,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(ebml_w, ecx, item.id);\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         encode_path(ebml_w, path.clone());\n         encode_visibility(ebml_w, vis);\n \n@@ -1065,7 +1072,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 'i');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n@@ -1097,7 +1104,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_methods.len();\n         for (i, m) in imp.methods.iter().enumerate() {\n             let ast_method = if i < num_implemented_methods {\n-                Some(ast_methods[i])\n+                Some(*ast_methods.get(i))\n             } else { None };\n \n             {\n@@ -1129,7 +1136,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_region_param_defs(ebml_w, trait_def.generics.region_param_defs());\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ebml_w, item.ident.name);\n-        encode_attributes(ebml_w, item.attrs);\n+        encode_attributes(ebml_w, item.attrs.as_slice());\n         encode_visibility(ebml_w, vis);\n         for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n             ebml_w.start_tag(tag_item_trait_method);\n@@ -1195,14 +1202,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 }\n             }\n \n-            match ms[i] {\n-                Required(ref tm) => {\n-                    encode_attributes(ebml_w, tm.attrs);\n+            match ms.get(i) {\n+                &Required(ref tm) => {\n+                    encode_attributes(ebml_w, tm.attrs.as_slice());\n                     encode_method_sort(ebml_w, 'r');\n                 }\n \n-                Provided(m) => {\n-                    encode_attributes(ebml_w, m.attrs);\n+                &Provided(m) => {\n+                    encode_attributes(ebml_w, m.attrs.as_slice());\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != SelfStatic {"}, {"sha": "3fb127f470e972785ba5499395fc53b5cb74c6e5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -36,6 +36,7 @@ use std::libc;\n use std::cast;\n use std::io::Seek;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -334,8 +335,8 @@ impl Folder for NestedItemsDropper {\n             }\n         }).collect();\n         let blk_sans_items = ast::P(ast::Block {\n-            view_items: ~[], // I don't know if we need the view_items here,\n-                             // but it doesn't break tests!\n+            view_items: Vec::new(), // I don't know if we need the view_items\n+                                    // here, but it doesn't break tests!\n             stmts: stmts_sans_items,\n             expr: blk.expr,\n             id: blk.id,\n@@ -396,7 +397,10 @@ fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n                         map: &ast_map::Map,\n                         path: ~[ast_map::PathElem],\n                         ii: ast::InlinedItem) -> ast::InlinedItem {\n-    ast_map::map_decoded_item(map, path, AstRenumberer { xcx: xcx }, |fld| {\n+    ast_map::map_decoded_item(map,\n+                              path.move_iter().collect(),\n+                              AstRenumberer { xcx: xcx },\n+                              |fld| {\n         match ii {\n             ast::IIItem(i) => {\n                 ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n@@ -1436,7 +1440,9 @@ trait fake_ext_ctxt {\n \n #[cfg(test)]\n impl fake_ext_ctxt for @parse::ParseSess {\n-    fn cfg(&self) -> ast::CrateConfig { ~[] }\n+    fn cfg(&self) -> ast::CrateConfig {\n+        Vec::new()\n+    }\n     fn parse_sess(&self) -> @parse::ParseSess { *self }\n     fn call_site(&self) -> Span {\n         codemap::Span {"}, {"sha": "3a500a82664dd83df6630e2a786c9b4ed39fa72b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -831,10 +831,10 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n         this.check_assignment(dest);\n       }\n       ast::ExprCall(f, ref args) => {\n-        this.check_call(expr, Some(f), f.span, *args);\n+        this.check_call(expr, Some(f), f.span, args.as_slice());\n       }\n       ast::ExprMethodCall(_, _, ref args) => {\n-        this.check_call(expr, None, expr.span, *args);\n+        this.check_call(expr, None, expr.span, args.as_slice());\n       }\n       ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n       if method_map.get().contains_key(&expr.id) => {"}, {"sha": "b76d4cb85890356b1f0b058368c1e37551f7353b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -298,7 +298,8 @@ impl CFGBuilder {\n                 let mut guard_exit = discr_exit;\n                 for arm in arms.iter() {\n                     guard_exit = self.opt_expr(arm.guard, guard_exit); // 2\n-                    let pats_exit = self.pats_any(arm.pats, guard_exit); // 3\n+                    let pats_exit = self.pats_any(arm.pats.as_slice(),\n+                                                  guard_exit); // 3\n                     let body_exit = self.block(arm.body, pats_exit);    // 4\n                     self.add_contained_edge(body_exit, expr_exit);       // 5\n                 }\n@@ -348,15 +349,15 @@ impl CFGBuilder {\n             }\n \n             ast::ExprVec(ref elems, _) => {\n-                self.straightline(expr, pred, *elems)\n+                self.straightline(expr, pred, elems.as_slice())\n             }\n \n             ast::ExprCall(func, ref args) => {\n-                self.call(expr, pred, func, *args)\n+                self.call(expr, pred, func, args.as_slice())\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, args[0], args.slice_from(1))\n+                self.call(expr, pred, *args.get(0), args.slice_from(1))\n             }\n \n             ast::ExprIndex(l, r) |\n@@ -369,7 +370,7 @@ impl CFGBuilder {\n             }\n \n             ast::ExprTup(ref exprs) => {\n-                self.straightline(expr, pred, *exprs)\n+                self.straightline(expr, pred, exprs.as_slice())\n             }\n \n             ast::ExprStruct(_, ref fields, base) => {"}, {"sha": "0ca5ad8b44c5ab0d5979db40b6e65765075ad41c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -76,10 +76,10 @@ fn check_expr(v: &mut CheckMatchVisitor,\n         for arm in arms.iter() {\n             check_legality_of_move_bindings(cx,\n                                             arm.guard.is_some(),\n-                                            arm.pats);\n+                                            arm.pats.as_slice());\n         }\n \n-        check_arms(cx, *arms);\n+        check_arms(cx, arms.as_slice());\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n          // types.\n@@ -104,11 +104,15 @@ fn check_expr(v: &mut CheckMatchVisitor,\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@Pat]]>().concat_vec();\n-       if arms.is_empty() {\n+\n+       let pats: ~[@Pat] = arms.iter()\n+                               .filter_map(unguarded_pat)\n+                               .flat_map(|pats| pats.move_iter())\n+                               .collect();\n+       if pats.is_empty() {\n            cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n-           check_exhaustive(cx, ex.span, arms);\n+           check_exhaustive(cx, ex.span, pats);\n        }\n      }\n      _ => ()\n@@ -671,7 +675,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     DefVariant(_, id, _) if variant(id) == *ctor_id => {\n                         let args = match args {\n-                            Some(args) => args,\n+                            Some(args) => args.iter().map(|x| *x).collect(),\n                             None => vec::from_elem(arity, wild())\n                         };\n                         Some(vec::append(args, r.tail()))\n@@ -682,7 +686,9 @@ fn specialize(cx: &MatchCheckCtxt,\n                     DefStruct(..) => {\n                         let new_args;\n                         match args {\n-                            Some(args) => new_args = args,\n+                            Some(args) => {\n+                                new_args = args.iter().map(|x| *x).collect()\n+                            }\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n                         Some(vec::append(new_args, r.tail()))\n@@ -741,7 +747,9 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-            PatTup(args) => Some(vec::append(args, r.tail())),\n+            PatTup(args) => {\n+                Some(vec::append(args.iter().map(|x| *x).collect(), r.tail()))\n+            }\n             PatUniq(a) | PatRegion(a) => {\n                 Some(vec::append(~[a], r.tail()))\n             }\n@@ -804,20 +812,32 @@ fn specialize(cx: &MatchCheckCtxt,\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n-                            Some(vec::append(\n-                                [\n-                                    before,\n-                                    vec::from_elem(\n-                                        arity - num_elements, wild()),\n-                                    after\n-                                ].concat_vec(),\n-                                r.tail()\n-                            ))\n+                            let mut result = ~[];\n+                            for pat in before.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for _ in iter::range(0, arity - num_elements) {\n+                                result.push(wild())\n+                            }\n+                            for pat in after.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for pat in r.tail().iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            Some(result)\n                         } else if num_elements == arity {\n-                            Some(vec::append(\n-                                vec::append(before, after),\n-                                r.tail()\n-                            ))\n+                            let mut result = ~[];\n+                            for pat in before.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for pat in after.iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            for pat in r.tail().iter() {\n+                                result.push((*pat).clone());\n+                            }\n+                            Some(result)\n                         } else {\n                             None\n                         }"}, {"sha": "cd52f24b8eaeeacfb0b5fa0e46dec0fa280be94b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -117,7 +117,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                 None => None,\n                 Some(ast_map::NodeItem(it)) => match it.node {\n                     ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                        variant_expr(*variants, variant_def.node)\n+                        variant_expr(variants.as_slice(), variant_def.node)\n                     }\n                     _ => None\n                 },\n@@ -144,7 +144,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                                                         c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                    variant_expr(*variants, variant_def.node)\n+                    variant_expr(variants.as_slice(), variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -509,7 +509,9 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n pub fn lit_to_const(lit: &Lit) -> const_val {\n     match lit.node {\n         LitStr(ref s, _) => const_str((*s).clone()),\n-        LitBinary(ref data) => const_binary(data.clone()),\n+        LitBinary(ref data) => {\n+            const_binary(Rc::new(data.borrow().iter().map(|x| *x).collect()))\n+        }\n         LitChar(n) => const_uint(n as u64),\n         LitInt(n, _) => const_int(n),\n         LitUint(n, _) => const_uint(n),"}, {"sha": "1e38f5d9bd7f5861c09a36c5411ca3a15203f767", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -531,7 +531,9 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n                     let mut body = guards.to_owned();\n-                    self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n+                    self.walk_pat_alternatives(arm.pats.as_slice(),\n+                                               body,\n+                                               loop_scopes);\n                     self.walk_block(arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n                 }\n@@ -562,7 +564,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             ast::ExprVec(ref exprs, _) => {\n-                self.walk_exprs(*exprs, in_out, loop_scopes)\n+                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes)\n             }\n \n             ast::ExprRepeat(l, r, _) => {\n@@ -579,11 +581,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprCall(f, ref args) => {\n                 self.walk_expr(f, in_out, loop_scopes);\n-                self.walk_call(expr.id, *args, in_out, loop_scopes);\n+                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.walk_call(expr.id, *args, in_out, loop_scopes);\n+                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n             }\n \n             ast::ExprIndex(l, r) |\n@@ -596,7 +598,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n \n             ast::ExprTup(ref exprs) => {\n-                self.walk_exprs(*exprs, in_out, loop_scopes);\n+                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes);\n             }\n \n             ast::ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {"}, {"sha": "a0a34ff4f32b53ce0203e0ebb5d3dcde9d9c44b9", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -198,7 +198,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     contains_lint(attrs, allow, DEAD_CODE_LINT_STR)\n-    || attr::contains_name(attrs, \"lang\")\n+    || attr::contains_name(attrs.as_slice(), \"lang\")\n }\n \n // This visitor seeds items that\n@@ -220,7 +220,7 @@ struct LifeSeeder {\n \n impl Visitor<()> for LifeSeeder {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n-        if has_allow_dead_code_or_lang_attr(item.attrs) {\n+        if has_allow_dead_code_or_lang_attr(item.attrs.as_slice()) {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n@@ -240,7 +240,7 @@ impl Visitor<()> for LifeSeeder {\n         // Check for method here because methods are not ast::Item\n         match *fk {\n             visit::FkMethod(_, _, method) => {\n-                if has_allow_dead_code_or_lang_attr(method.attrs) {\n+                if has_allow_dead_code_or_lang_attr(method.attrs.as_slice()) {\n                     self.worklist.push(id);\n                 }\n             }"}, {"sha": "2623ddb15297e0672514acc372150dd1ffacbfec", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -54,7 +54,7 @@ pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map)\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(krate.attrs, \"no_main\") {\n+    if attr::contains_name(krate.attrs.as_slice(), \"no_main\") {\n         session.entry_type.set(Some(session::EntryNone));\n         return\n     }\n@@ -95,7 +95,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 });\n             }\n \n-            if attr::contains_name(item.attrs, \"main\") {\n+            if attr::contains_name(item.attrs.as_slice(), \"main\") {\n                 if ctxt.attr_main_fn.is_none() {\n                     ctxt.attr_main_fn = Some((item.id, item.span));\n                 } else {\n@@ -105,7 +105,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 }\n             }\n \n-            if attr::contains_name(item.attrs, \"start\") {\n+            if attr::contains_name(item.attrs.as_slice(), \"start\") {\n                 if ctxt.start_fn.is_none() {\n                     ctxt.start_fn = Some((item.id, item.span));\n                 } else {"}, {"sha": "5b7ac704e2a228cec546a39a7eb242197de7426c", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -160,7 +160,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n }\n \n fn check_item(cx: &mut Context, item: &Item) {\n-    if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n+    if !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\") {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), self_type, _) => {\n                 check_impl_of_trait(cx, item, trait_ref, self_type);"}, {"sha": "bedf8ed05290b35f93ddebf9b84505c58f84b16c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -114,7 +114,7 @@ struct LanguageItemVisitor<'a> {\n \n impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n-        match extract(item.attrs) {\n+        match extract(item.attrs.as_slice()) {\n             Some(value) => {\n                 let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);\n "}, {"sha": "cef32797ca268dca6483bceea88600aa73a43e3c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -548,7 +548,9 @@ impl<'a> Context<'a> {\n                      attr.name().equiv(&(\"doc\")) &&\n                      match attr.meta_item_list() {\n                          None => false,\n-                         Some(l) => attr::contains_name(l, \"hidden\")\n+                         Some(l) => {\n+                             attr::contains_name(l.as_slice(), \"hidden\")\n+                         }\n                      }\n                  });\n \n@@ -1070,7 +1072,8 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n             if ast_util::is_local(did) {\n                 match cx.tcx.map.get(did.node) {\n                     ast_map::NodeItem(it) => {\n-                        if attr::contains_name(it.attrs, \"must_use\") {\n+                        if attr::contains_name(it.attrs.as_slice(),\n+                                               \"must_use\") {\n                             cx.span_lint(UnusedMustUse, s.span,\n                                          \"unused result which must be used\");\n                             warned = true;\n@@ -1234,8 +1237,9 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n                       ref path, _) if pat_util::pat_is_binding(cx.tcx.def_map, p)=> {\n             // `let mut _a = 1;` doesn't need a warning.\n             let initial_underscore = if path.segments.len() == 1 {\n-                token::get_ident(path.segments[0].identifier).get()\n-                                                             .starts_with(\"_\")\n+                token::get_ident(path.segments\n+                                     .get(0)\n+                                     .identifier).get().starts_with(\"_\")\n             } else {\n                 cx.tcx.sess.span_bug(p.span,\n                                      \"mutable binding that doesn't consist \\\n@@ -1353,7 +1357,11 @@ fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n         ast::ItemTrait(..) => \"a trait\",\n         _ => return\n     };\n-    check_missing_doc_attrs(cx, Some(it.id), it.attrs, it.span, desc);\n+    check_missing_doc_attrs(cx,\n+                            Some(it.id),\n+                            it.attrs.as_slice(),\n+                            it.span,\n+                            desc);\n }\n \n fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n@@ -1386,24 +1394,39 @@ fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n             }\n         }\n     }\n-    check_missing_doc_attrs(cx, Some(m.id), m.attrs, m.span, \"a method\");\n+    check_missing_doc_attrs(cx,\n+                            Some(m.id),\n+                            m.attrs.as_slice(),\n+                            m.span,\n+                            \"a method\");\n }\n \n fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n-    check_missing_doc_attrs(cx, Some(tm.id), tm.attrs, tm.span, \"a type method\");\n+    check_missing_doc_attrs(cx,\n+                            Some(tm.id),\n+                            tm.attrs.as_slice(),\n+                            tm.span,\n+                            \"a type method\");\n }\n \n fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n     match sf.node.kind {\n         ast::NamedField(_, vis) if vis != ast::Private =>\n-            check_missing_doc_attrs(cx, Some(cx.cur_struct_def_id), sf.node.attrs,\n-                                    sf.span, \"a struct field\"),\n+            check_missing_doc_attrs(cx,\n+                                    Some(cx.cur_struct_def_id),\n+                                    sf.node.attrs.as_slice(),\n+                                    sf.span,\n+                                    \"a struct field\"),\n         _ => {}\n     }\n }\n \n fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n-    check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs, v.span, \"a variant\");\n+    check_missing_doc_attrs(cx,\n+                            Some(v.node.id),\n+                            v.node.attrs.as_slice(),\n+                            v.span,\n+                            \"a variant\");\n }\n \n /// Checks for use of items with #[deprecated], #[experimental] and\n@@ -1500,13 +1523,13 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n impl<'a> Visitor<()> for Context<'a> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n-        self.with_lint_attrs(it.attrs, |cx| {\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n             check_item_non_uppercase_statics(cx, it);\n             check_heap_item(cx, it);\n             check_missing_doc_item(cx, it);\n-            check_attrs_usage(cx, it.attrs);\n+            check_attrs_usage(cx, it.attrs.as_slice());\n \n             cx.visit_ids(|v| v.visit_item(it, ()));\n \n@@ -1515,15 +1538,15 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n-        self.with_lint_attrs(it.attrs, |cx| {\n-            check_attrs_usage(cx, it.attrs);\n+        self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n+            check_attrs_usage(cx, it.attrs.as_slice());\n             visit::walk_foreign_item(cx, it, ());\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n-        self.with_lint_attrs(i.attrs, |cx| {\n-            check_attrs_usage(cx, i.attrs);\n+        self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n+            check_attrs_usage(cx, i.attrs.as_slice());\n             visit::walk_view_item(cx, i, ());\n         })\n     }\n@@ -1579,9 +1602,9 @@ impl<'a> Visitor<()> for Context<'a> {\n \n         match *fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs, |cx| {\n+                self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n                     check_missing_doc_method(cx, m);\n-                    check_attrs_usage(cx, m.attrs);\n+                    check_attrs_usage(cx, m.attrs.as_slice());\n \n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n@@ -1595,9 +1618,9 @@ impl<'a> Visitor<()> for Context<'a> {\n \n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n-        self.with_lint_attrs(t.attrs, |cx| {\n+        self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n             check_missing_doc_ty_method(cx, t);\n-            check_attrs_usage(cx, t.attrs);\n+            check_attrs_usage(cx, t.attrs.as_slice());\n \n             visit::walk_ty_method(cx, t, ());\n         })\n@@ -1616,18 +1639,18 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n-        self.with_lint_attrs(s.node.attrs, |cx| {\n+        self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n             check_missing_doc_struct_field(cx, s);\n-            check_attrs_usage(cx, s.node.attrs);\n+            check_attrs_usage(cx, s.node.attrs.as_slice());\n \n             visit::walk_struct_field(cx, s, ());\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n-        self.with_lint_attrs(v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n             check_missing_doc_variant(cx, v);\n-            check_attrs_usage(cx, v.node.attrs);\n+            check_attrs_usage(cx, v.node.attrs.as_slice());\n \n             visit::walk_variant(cx, v, g, ());\n         })\n@@ -1675,17 +1698,21 @@ pub fn check_crate(tcx: ty::ctxt,\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n-    cx.with_lint_attrs(krate.attrs, |cx| {\n+    cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n             visit::walk_crate(v, krate, ());\n         });\n \n-        check_crate_attrs_usage(cx, krate.attrs);\n+        check_crate_attrs_usage(cx, krate.attrs.as_slice());\n         // since the root module isn't visited as an item (because it isn't an item), warn for it\n         // here.\n-        check_missing_doc_attrs(cx, None, krate.attrs, krate.span, \"crate\");\n+        check_missing_doc_attrs(cx,\n+                                None,\n+                                krate.attrs.as_slice(),\n+                                krate.span,\n+                                \"crate\");\n \n         visit::walk_crate(cx, krate, ());\n     });"}, {"sha": "ab4de1ed71d7977721d1ed7bb18f04e089621a46", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -1129,7 +1129,8 @@ impl Liveness {\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats, guard_succ);\n+                    self.define_bindings_in_arm_pats(arm.pats.as_slice(),\n+                                                     guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n@@ -1194,7 +1195,7 @@ impl Liveness {\n           }\n \n           ExprVec(ref exprs, _) => {\n-            self.propagate_through_exprs(*exprs, succ)\n+            self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n           ExprRepeat(element, count, _) => {\n@@ -1215,7 +1216,7 @@ impl Liveness {\n             let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            let succ = self.propagate_through_exprs(*args, succ);\n+            let succ = self.propagate_through_exprs(args.as_slice(), succ);\n             self.propagate_through_expr(f, succ)\n           }\n \n@@ -1225,11 +1226,11 @@ impl Liveness {\n             let t_ret = ty::node_id_to_type(self.tcx, expr.id);\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n-            self.propagate_through_exprs(*args, succ)\n+            self.propagate_through_exprs(args.as_slice(), succ)\n           }\n \n           ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(*exprs, succ)\n+            self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n           ExprBinary(op, l, r) if ast_util::lazy_binop(op) => {\n@@ -1493,7 +1494,7 @@ fn check_local(this: &mut Liveness, local: &Local) {\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    this.arm_pats_bindings(arm.pats, |ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.as_slice(), |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm, ());"}, {"sha": "b96a4e4c1606497df4d2dabc6a20426c896d45c5", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -409,11 +409,11 @@ impl VisitContext {\n                     }\n                 }\n                 self.use_expr(callee, mode);\n-                self.use_fn_args(*args);\n+                self.use_fn_args(args.as_slice());\n             }\n \n             ExprMethodCall(_, _, ref args) => { // callee.m(args)\n-                self.use_fn_args(*args);\n+                self.use_fn_args(args.as_slice());\n             }\n \n             ExprStruct(_, ref fields, opt_with) => {\n@@ -468,7 +468,7 @@ impl VisitContext {\n             }\n \n             ExprTup(ref exprs) => {\n-                self.consume_exprs(*exprs);\n+                self.consume_exprs(exprs.as_slice());\n             }\n \n             ExprIf(cond_expr, then_blk, opt_else_expr) => {\n@@ -497,7 +497,7 @@ impl VisitContext {\n             }\n \n             ExprVec(ref exprs, _) => {\n-                self.consume_exprs(*exprs);\n+                self.consume_exprs(exprs.as_slice());\n             }\n \n             ExprAddrOf(_, base) => {   // &base"}, {"sha": "3d90566ee7931f08c73827f26dad211abe02b355", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -759,7 +759,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         // Do not check privacy inside items with the resolve_unexported\n         // attribute. This is used for the test runner.\n-        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n+        if attr::contains_name(item.attrs.as_slice(), \"!resolve_unexported\") {\n             return;\n         }\n \n@@ -788,7 +788,8 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             }\n             ast::ExprMethodCall(ident, _, ref args) => {\n                 // see above\n-                let t = ty::type_autoderef(ty::expr_ty(self.tcx, args[0]));\n+                let t = ty::type_autoderef(ty::expr_ty(self.tcx,\n+                                                       *args.get(0)));\n                 match ty::get(t).sty {\n                     ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n                         match self.method_map.borrow().get().find(&expr.id) {\n@@ -857,7 +858,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 };\n-                                let segs = ~[seg];\n+                                let segs = vec!(seg);\n                                 let path = ast::Path {\n                                     global: false,\n                                     span: pid.span,"}, {"sha": "305c60d8215c9f5cfa35e2305f5b9331da44db28", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -44,7 +44,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs) {\n+    if attributes_specify_inlining(item.attrs.as_slice()) {\n         return true\n     }\n \n@@ -59,7 +59,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs) ||\n+    if attributes_specify_inlining(method.attrs.as_slice()) ||\n         generics_require_inlining(&method.generics) {\n         return true\n     }\n@@ -217,7 +217,7 @@ impl ReachableContext {\n             }\n             Some(ast_map::NodeMethod(method)) => {\n                 if generics_require_inlining(&method.generics) ||\n-                        attributes_specify_inlining(method.attrs) {\n+                        attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n                     let impl_did = tcx.map.get_parent_did(node_id);\n@@ -324,7 +324,7 @@ impl ReachableContext {\n                     // Statics with insignificant addresses are not reachable\n                     // because they're inlined specially into all other crates.\n                     ast::ItemStatic(..) => {\n-                        if attr::contains_name(item.attrs,\n+                        if attr::contains_name(item.attrs.as_slice(),\n                                                \"address_insignificant\") {\n                             let mut reachable_symbols =\n                                 self.reachable_symbols.borrow_mut();"}, {"sha": "58de36a796825f0bc361526327b8a22c0074bd8d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -3690,7 +3690,7 @@ impl Resolver {\n                                             generics,\n                                             implemented_traits,\n                                             self_type,\n-                                            *methods);\n+                                            methods.as_slice());\n             }\n \n             ItemTrait(ref generics, ref traits, ref methods) => {\n@@ -3764,7 +3764,7 @@ impl Resolver {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields);\n+                                    struct_def.fields.as_slice());\n             }\n \n             ItemMod(ref module_) => {\n@@ -4187,8 +4187,10 @@ impl Resolver {\n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, arm: &Arm) {\n-        if arm.pats.len() == 0 { return; }\n-        let map_0 = self.binding_mode_map(arm.pats[0]);\n+        if arm.pats.len() == 0 {\n+            return\n+        }\n+        let map_0 = self.binding_mode_map(*arm.pats.get(0));\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(*p);\n \n@@ -4408,7 +4410,7 @@ impl Resolver {\n                     // such a value is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    let ident = path.segments[0].identifier;\n+                    let ident = path.segments.get(0).identifier;\n                     let renamed = mtwt_resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {"}, {"sha": "d57557c5f1be36a5c3a35cca214fd3c254cd4a57", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -652,7 +652,9 @@ fn enter_opt<'r,'b>(\n                     // FIXME: Must we clone?\n                     match *subpats {\n                         None => Some(vec::from_elem(variant_size, dummy)),\n-                        _ => (*subpats).clone(),\n+                        Some(ref subpats) => {\n+                            Some((*subpats).iter().map(|x| *x).collect())\n+                        }\n                     }\n                 } else {\n                     None\n@@ -719,16 +721,27 @@ fn enter_opt<'r,'b>(\n                         let this_opt = vec_len(n, vec_len_ge(before.len()),\n                                                (lo, hi));\n                         if opt_eq(tcx, &this_opt, opt) {\n-                            Some(vec::append_one((*before).clone(), slice) +\n-                                    *after)\n+                            let mut new_before = ~[];\n+                            for pat in before.iter() {\n+                                new_before.push(*pat);\n+                            }\n+                            new_before.push(slice);\n+                            for pat in after.iter() {\n+                                new_before.push(*pat);\n+                            }\n+                            Some(new_before)\n                         } else {\n                             None\n                         }\n                     }\n                     None if i >= lo && i <= hi => {\n                         let n = before.len();\n                         if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n-                            Some((*before).clone())\n+                            let mut new_before = ~[];\n+                            for pat in before.iter() {\n+                                new_before.push(*pat);\n+                            }\n+                            Some(new_before)\n                         } else {\n                             None\n                         }\n@@ -811,7 +824,13 @@ fn enter_tup<'r,'b>(\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-            ast::PatTup(ref elts) => Some((*elts).clone()),\n+            ast::PatTup(ref elts) => {\n+                let mut new_elts = ~[];\n+                for elt in elts.iter() {\n+                    new_elts.push((*elt).clone())\n+                }\n+                Some(new_elts)\n+            }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -838,7 +857,9 @@ fn enter_tuple_struct<'r,'b>(\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-            ast::PatEnum(_, Some(ref elts)) => Some((*elts).clone()),\n+            ast::PatEnum(_, Some(ref elts)) => {\n+                Some(elts.iter().map(|x| (*x)).collect())\n+            }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n@@ -1094,7 +1115,7 @@ fn collect_record_or_struct_fields<'a>(\n           ast::PatStruct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n               ty::ty_struct(..) => {\n-                   extend(&mut fields, *fs);\n+                   extend(&mut fields, fs.as_slice());\n                    found = true;\n               }\n               _ => ()\n@@ -1866,7 +1887,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     let mut matches = ~[];\n     for arm in arms.iter() {\n         let body = fcx.new_id_block(\"case_body\", arm.body.id);\n-        let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n+        let bindings_map = create_bindings_map(bcx, *arm.pats.get(0));\n         let arm_data = ArmData {\n             bodycx: body,\n             arm: arm,\n@@ -2172,7 +2193,7 @@ fn bind_irrefutable_pat<'a>(\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n                         for (i, argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n+                            bcx = bind_irrefutable_pat(bcx, *sub_pat.get(i),\n                                                        *argval, binding_mode,\n                                                        cleanup_scope);\n                         }"}, {"sha": "130bcb419022478a6e1eb8078c8606929f5a30ac", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -100,13 +100,20 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     let r = ia.asm.get().with_c_str(|a| {\n         constraints.with_c_str(|c| {\n-            InlineAsmCall(bcx, a, c, inputs, output_type, ia.volatile, ia.alignstack, dialect)\n+            InlineAsmCall(bcx,\n+                          a,\n+                          c,\n+                          inputs.as_slice(),\n+                          output_type,\n+                          ia.volatile,\n+                          ia.alignstack,\n+                          dialect)\n         })\n     });\n \n     // Again, based on how many outputs we have\n     if numOutputs == 1 {\n-        Store(bcx, r, outputs[0]);\n+        Store(bcx, r, *outputs.get(0));\n     } else {\n         for (i, o) in outputs.iter().enumerate() {\n             let v = ExtractValue(bcx, r, i);"}, {"sha": "b8301cbc33abfeb5453206686d1dbf4bbae61cdb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -1473,7 +1473,11 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n \n-    bcx = copy_args_to_allocas(&fcx, arg_scope, bcx, decl.inputs, arg_datums);\n+    bcx = copy_args_to_allocas(&fcx,\n+                               arg_scope,\n+                               bcx,\n+                               decl.inputs.as_slice(),\n+                               arg_datums);\n \n     bcx = maybe_load_env(bcx);\n \n@@ -1637,7 +1641,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n         match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, variant, *args,\n+                trans_enum_variant(ccx, id, variant, args.as_slice(),\n                                    disr_val, None, llfn);\n             }\n             ast::TupleVariantKind(_) => {\n@@ -1667,10 +1671,16 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n         if purity == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n-                ccx, decl, body, item.attrs, llfndecl, item.id);\n+                ccx, decl, body, item.attrs.as_slice(), llfndecl, item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfn = get_item_val(ccx, item.id);\n-            trans_fn(ccx, decl, body, llfn, None, item.id, item.attrs);\n+            trans_fn(ccx,\n+                     decl,\n+                     body,\n+                     llfn,\n+                     None,\n+                     item.id,\n+                     item.attrs.as_slice());\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n             // items in blocks and such.\n@@ -1679,7 +1689,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n         }\n       }\n       ast::ItemImpl(ref generics, _, _, ref ms) => {\n-        meth::trans_impl(ccx, item.ident, *ms, generics, item.id);\n+        meth::trans_impl(ccx, item.ident, ms.as_slice(), generics, item.id);\n       }\n       ast::ItemMod(ref m) => {\n         trans_mod(ccx, m);\n@@ -1695,7 +1705,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs, \"static_assert\") {\n+          if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess.span_fatal(expr.span,\n                                       \"cannot have static_assert on a mutable \\\n@@ -1738,7 +1748,7 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::StructDef) {\n         // otherwise this is a unit-like struct.\n         Some(ctor_id) if struct_def.fields.len() > 0 => {\n             let llfndecl = get_item_val(ccx, ctor_id);\n-            trans_tuple_struct(ccx, struct_def.fields,\n+            trans_tuple_struct(ccx, struct_def.fields.as_slice(),\n                                ctor_id, None, llfndecl);\n         }\n         Some(_) | None => {}\n@@ -1925,7 +1935,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n             let val = match item {\n                 ast_map::NodeItem(i) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, i.id);\n-                    let sym = exported_name(ccx, id, ty, i.attrs);\n+                    let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n \n                     let v = match i.node {\n                         ast::ItemStatic(_, _, expr) => {\n@@ -1974,7 +1984,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                                 // Apply the `unnamed_addr` attribute if\n                                 // requested\n-                                if attr::contains_name(i.attrs,\n+                                if attr::contains_name(i.attrs.as_slice(),\n                                                        \"address_insignificant\"){\n                                     {\n                                         let reachable =\n@@ -2006,7 +2016,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                     inlineable = true;\n                                 }\n \n-                                if attr::contains_name(i.attrs, \"thread_local\") {\n+                                if attr::contains_name(i.attrs.as_slice(),\n+                                                       \"thread_local\") {\n                                     lib::llvm::set_thread_local(g, true);\n                                 }\n \n@@ -2034,14 +2045,16 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                            sym,\n                                                                            i.id)\n                             };\n-                            set_llvm_fn_attrs(i.attrs, llfn);\n+                            set_llvm_fn_attrs(i.attrs.as_slice(), llfn);\n                             llfn\n                         }\n \n                         _ => fail!(\"get_item_val: weird result in table\")\n                     };\n \n-                    match attr::first_attr_value_str_by_name(i.attrs, \"link_section\") {\n+                    match attr::first_attr_value_str_by_name(i.attrs\n+                                                              .as_slice(),\n+                                                             \"link_section\") {\n                         Some(sect) => unsafe {\n                             sect.get().with_c_str(|buf| {\n                                 llvm::LLVMSetSection(v, buf);\n@@ -2087,7 +2100,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             // with weak linkage, but if we're building a\n                             // library then we've already declared the crate map\n                             // so use that instead.\n-                            if attr::contains_name(ni.attrs, \"crate_map\") {\n+                            if attr::contains_name(ni.attrs.as_slice(),\n+                                                   \"crate_map\") {\n                                 if ccx.sess.building_library.get() {\n                                     let s = \"_rust_crate_map_toplevel\";\n                                     let g = unsafe {\n@@ -2126,7 +2140,10 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let ty = ty::node_id_to_type(ccx.tcx, id);\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let enm = ccx.tcx.map.expect_item(parent);\n-                            let sym = exported_name(ccx, id, ty, enm.attrs);\n+                            let sym = exported_name(ccx,\n+                                                    id,\n+                                                    ty,\n+                                                    enm.attrs.as_slice());\n \n                             llfn = match enm.node {\n                                 ast::ItemEnum(_, _) => {\n@@ -2154,7 +2171,11 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let struct_item = ccx.tcx.map.expect_item(parent);\n                             let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n-                            let sym = exported_name(ccx, id, ty, struct_item.attrs);\n+                            let sym = exported_name(ccx,\n+                                                    id,\n+                                                    ty,\n+                                                    struct_item.attrs\n+                                                               .as_slice());\n                             let llfn = register_fn(ccx, struct_item.span,\n                                                    sym, ctor_id, ty);\n                             set_inline_hint(llfn);\n@@ -2190,10 +2211,10 @@ fn register_method(ccx: @CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs);\n+    let sym = exported_name(ccx, id, mty, m.attrs.as_slice());\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(m.attrs, llfn);\n+    set_llvm_fn_attrs(m.attrs.as_slice(), llfn);\n     llfn\n }\n "}, {"sha": "793c70770a932207f32667b2945c5de6a69e8310", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -75,7 +75,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, *data.borrow()),\n+        ast::LitBinary(ref data) => {\n+            C_binary_slice(cx, data.borrow().as_slice())\n+        }\n     }\n }\n \n@@ -529,7 +531,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n-              let (vals, inlineable) = map_list(*es);\n+              let (vals, inlineable) = map_list(es.as_slice());\n               (adt::trans_const(cx, repr, 0, vals), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n@@ -564,7 +566,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               })\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n-            let (v, _, inlineable) = const_vec(cx, e, *es, is_local);\n+            let (v, _, inlineable) = const_vec(cx,\n+                                               e,\n+                                               es.as_slice(),\n+                                               is_local);\n             (v, inlineable)\n           }\n           ast::ExprVstore(sub, ast::ExprVstoreSlice) => {\n@@ -576,7 +581,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n-                let (cv, llunitty, _) = const_vec(cx, e, *es, is_local);\n+                let (cv, llunitty, _) = const_vec(cx,\n+                                                  e,\n+                                                  es.as_slice(),\n+                                                  is_local);\n                 let llty = val_ty(cv);\n                 let gv = \"const\".with_c_str(|name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n@@ -657,7 +665,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                   Some(ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let (arg_vals, inlineable) = map_list(*args);\n+                      let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n@@ -666,7 +674,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                       let vinfo = ty::enum_variant_with_id(cx.tcx,\n                                                            enum_did,\n                                                            variant_did);\n-                      let (arg_vals, inlineable) = map_list(*args);\n+                      let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, repr, vinfo.disr_val, arg_vals),\n                        inlineable)\n                   }"}, {"sha": "44e6bbf91cf7c975acfc423024f653d04aa69d44", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -690,7 +690,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     {\n         let mut scope_map = fn_debug_context.scope_map.borrow_mut();\n         populate_scope_map(cx,\n-                           arg_pats,\n+                           arg_pats.as_slice(),\n                            top_level_block,\n                            fn_metadata,\n                            scope_map.get());\n@@ -2650,7 +2650,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 // they all must contain the same binding names\n \n                 for arm_ref in arms.iter() {\n-                    let arm_span = arm_ref.pats[0].span;\n+                    let arm_span = arm_ref.pats.get(0).span;\n \n                     with_new_scope(cx,\n                                    arm_span,"}, {"sha": "b033086125deca3325e29089d894bd98ff3b72a0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -731,13 +731,18 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             controlflow::trans_if(bcx, expr.id, cond, thn, els, dest)\n         }\n         ast::ExprMatch(discr, ref arms) => {\n-            _match::trans_match(bcx, expr, discr, *arms, dest)\n+            _match::trans_match(bcx, expr, discr, arms.as_slice(), dest)\n         }\n         ast::ExprBlock(blk) => {\n             controlflow::trans_block(bcx, blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n-            trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest)\n+            trans_rec_or_struct(bcx,\n+                                fields.as_slice(),\n+                                base,\n+                                expr.span,\n+                                expr.id,\n+                                dest)\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n@@ -777,10 +782,19 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n-            callee::trans_call(bcx, expr, f, callee::ArgExprs(*args), expr.id, dest)\n+            callee::trans_call(bcx,\n+                               expr,\n+                               f,\n+                               callee::ArgExprs(args.as_slice()),\n+                               expr.id,\n+                               dest)\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n-            callee::trans_method_call(bcx, expr, args[0], callee::ArgExprs(*args), dest)\n+            callee::trans_method_call(bcx,\n+                                      expr,\n+                                      *args.get(0),\n+                                      callee::ArgExprs(args.as_slice()),\n+                                      dest)\n         }\n         ast::ExprBinary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr"}, {"sha": "7f90810bae48eb66b2bcf2a1adc0f589d18f540c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -713,7 +713,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: @ast::ForeignItem) -> InternedString {\n-     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n+     match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+                                              \"link_name\") {\n         None => token::get_ident(i.ident),\n         Some(ln) => ln.clone(),\n     }"}, {"sha": "896d97f037405525b63813f7a5a51eec216f0b85", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -74,7 +74,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                     let g = get_item_val(ccx, item.id);\n                     // see the comment in get_item_val() as to why this check is\n                     // performed here.\n-                    if !attr::contains_name(item.attrs,\n+                    if !attr::contains_name(item.attrs.as_slice(),\n                                             \"address_insignificant\") {\n                         SetLinkage(g, AvailableExternallyLinkage);\n                     }"}, {"sha": "c76d1cbcd20a4a9c97752862420eae64c99fcc52", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -201,7 +201,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                   ..\n               } => {\n                   let d = mk_lldecl();\n-                  set_llvm_fn_attrs(i.attrs, d);\n+                  set_llvm_fn_attrs(i.attrs.as_slice(), d);\n                   trans_fn(ccx, decl, body, d, Some(psubsts), fn_id.node, []);\n                   d\n               }\n@@ -232,7 +232,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        v,\n-                                       (*args).clone(),\n+                                       args.as_slice(),\n                                        this_tv.disr_val,\n                                        Some(psubsts),\n                                        d);\n@@ -244,15 +244,15 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         }\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n-            set_llvm_fn_attrs(mth.attrs, d);\n+            set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n             trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n-                    set_llvm_fn_attrs(mth.attrs, d);\n+                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n                     trans_fn(ccx, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n                     d\n                 }\n@@ -266,7 +266,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             let d = mk_lldecl();\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields,\n+                                     struct_def.fields.as_slice(),\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      Some(psubsts),"}, {"sha": "210adc1d0a5ec60c9f67773a7ba06b19baa3da09", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -3730,8 +3730,11 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n                         ItemTrait(_, _, ref ms) => {\n-                            let (_, p) = ast_util::split_trait_methods(*ms);\n-                            p.map(|m| method(cx, ast_util::local_def(m.id)))\n+                            let (_, p) =\n+                                ast_util::split_trait_methods(ms.as_slice());\n+                            p.iter()\n+                             .map(|m| method(cx, ast_util::local_def(m.id)))\n+                             .collect()\n                         }\n                         _ => {\n                             cx.sess.bug(format!(\"provided_trait_methods: \\\n@@ -3947,7 +3950,7 @@ impl VariantInfo {\n             },\n             ast::StructVariantKind(ref struct_def) => {\n \n-                let fields: &[StructField] = struct_def.fields;\n+                let fields: &[StructField] = struct_def.fields.as_slice();\n \n                 assert!(fields.len() > 0);\n \n@@ -4280,15 +4283,15 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n            Some(ast_map::NodeItem(i)) => {\n              match i.node {\n                 ast::ItemStruct(struct_def, _) => {\n-                   struct_field_tys(struct_def.fields)\n+                   struct_field_tys(struct_def.fields.as_slice())\n                 }\n                 _ => cx.sess.bug(\"struct ID bound to non-struct\")\n              }\n            }\n            Some(ast_map::NodeVariant(ref variant)) => {\n               match (*variant).node.kind {\n                 ast::StructVariantKind(struct_def) => {\n-                  struct_field_tys(struct_def.fields)\n+                  struct_field_tys(struct_def.fields.as_slice())\n                 }\n                 _ => {\n                   cx.sess.bug(\"struct ID bound to enum variant that isn't \\"}, {"sha": "e1157d29d9d82d1e7f0d052862aef9bf87bbf640", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -60,7 +60,7 @@ use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use util::ppaux::Repr;\n \n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n@@ -186,8 +186,8 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         }\n \n         match anon_regions {\n-            Ok(v) => opt_vec::from(v),\n-            Err(()) => opt_vec::from(vec::from_fn(expected_num_region_params,\n+            Ok(v) => opt_vec::from(v.move_iter().collect()),\n+            Err(()) => opt_vec::from(Vec::from_fn(expected_num_region_params,\n                                                   |_| ty::ReStatic)) // hokey\n         }\n     };\n@@ -519,7 +519,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                            |tmt| ty::mk_rptr(tcx, r, tmt))\n             }\n             ast::TyTup(ref fields) => {\n-                let flds = fields.map(|&t| ast_ty_to_ty(this, rscope, t));\n+                let flds = fields.iter()\n+                                 .map(|&t| ast_ty_to_ty(this, rscope, t))\n+                                 .collect();\n                 ty::mk_tup(tcx, flds)\n             }\n             ast::TyBareFn(ref bf) => {"}, {"sha": "def80e39821ee7bcfb41c425764ee429e74a2306", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::infer;\n use middle::typeck::require_same_types;\n \n use collections::{HashMap, HashSet};\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -40,7 +41,7 @@ pub fn check_match(fcx: @FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(tcx.def_map, arm.pats[0]),\n+            map: pat_id_map(tcx.def_map, *arm.pats.get(0)),\n         };\n \n         for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n@@ -108,13 +109,13 @@ pub struct pat_ctxt {\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<~[@ast::Pat]>, expected: ty::t) {\n+                         subpats: &Option<Vec<@ast::Pat>>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let arg_types;\n+    let arg_types: ~[ty::t];\n     let kind_name;\n \n     // structure_of requires type variables to be resolved.\n@@ -174,8 +175,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n                     arg_types = subpats.clone()\n-                                          .unwrap_or_default()\n-                                          .map(|_| ty::mk_err());\n+                                       .unwrap_or_default()\n+                                       .move_iter()\n+                                       .map(|_| ty::mk_err())\n+                                       .collect();\n                 }\n             }\n         }\n@@ -223,8 +226,10 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n             arg_types = subpats.clone()\n-                                  .unwrap_or_default()\n-                                  .map(|_| ty::mk_err());\n+                               .unwrap_or_default()\n+                               .iter()\n+                               .map(|_| ty::mk_err())\n+                               .collect();\n         }\n     }\n \n@@ -509,7 +514,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         }\n       }\n       ast::PatIdent(_, ref path, _) => {\n-        check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n+        check_pat_variant(pcx, pat, path, &Some(Vec::new()), expected);\n       }\n       ast::PatEnum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n@@ -521,12 +526,18 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *structure {\n             ty::ty_struct(cid, ref substs) => {\n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n-                                 *fields, etc, cid, substs);\n+                                 fields.as_slice(), etc, cid, substs);\n             }\n             ty::ty_enum(eid, ref substs) => {\n-                check_struct_like_enum_variant_pat(\n-                    pcx, pat.id, pat.span, expected, path, *fields, etc, eid,\n-                    substs);\n+                check_struct_like_enum_variant_pat(pcx,\n+                                                   pat.id,\n+                                                   pat.span,\n+                                                   expected,\n+                                                   path,\n+                                                   fields.as_slice(),\n+                                                   etc,\n+                                                   eid,\n+                                                   substs);\n             }\n             _ => {\n                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n@@ -540,9 +551,19 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.get().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n-                         check_struct_pat(pcx, pat.id, pat.span, ty::mk_err(), path, *fields, etc,\n-                         supplied_def_id,\n-                         &ty::substs { self_ty: None, tps: ~[], regions: ty::ErasedRegions} );\n+                         check_struct_pat(pcx,\n+                                          pat.id,\n+                                          pat.span,\n+                                          ty::mk_err(),\n+                                          path,\n+                                          fields.as_slice(),\n+                                          etc,\n+                                          supplied_def_id,\n+                                          &ty::substs {\n+                                              self_ty: None,\n+                                              tps: ~[],\n+                                              regions: ty::ErasedRegions,\n+                                          });\n                     }\n                     _ => () // Error, but we're already in an error case\n                 }"}, {"sha": "6e9cfc9d0d2b0f3b51f58ac1c0c7ff5d02b267cb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -387,7 +387,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n                 {\n                     let locals = self.fcx.inh.locals.borrow();\n                     debug!(\"Pattern binding {} is assigned to {}\",\n-                           token::get_ident(path.segments[0].identifier),\n+                           token::get_ident(path.segments.get(0).identifier),\n                            self.fcx.infcx().ty_to_str(\n                                locals.get().get_copy(&p.id)));\n                 }\n@@ -554,7 +554,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants,\n+                            enum_definition.variants.as_slice(),\n                             it.id);\n       }\n       ast::ItemFn(decl, _, _, _, body) => {\n@@ -588,7 +588,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n                                              &impl_tpt.generics,\n                                              ast_trait_ref,\n                                              impl_trait_ref,\n-                                             *ms);\n+                                             ms.as_slice());\n                 vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, impl_trait_ref);\n             }\n             None => { }\n@@ -1397,9 +1397,12 @@ pub fn impl_self_ty(vcx: &VtableContext,\n             n_rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n-    let substs = substs {regions: ty::NonerasedRegions(opt_vec::from(rps)),\n-                         self_ty: None,\n-                         tps: tps};\n+    let substs = substs {\n+        regions: ty::NonerasedRegions(opt_vec::from(rps.move_iter()\n+                                                       .collect())),\n+        self_ty: None,\n+        tps: tps,\n+    };\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n \n     ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n@@ -1453,7 +1456,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n     // Verify that no lifetimes or type parameters are present anywhere\n     // except the final two elements of the path.\n     for i in range(0, path.segments.len() - 2) {\n-        for lifetime in path.segments[i].lifetimes.iter() {\n+        for lifetime in path.segments.get(i).lifetimes.iter() {\n             function_context.tcx()\n                 .sess\n                 .span_err(lifetime.span,\n@@ -1462,7 +1465,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n             break;\n         }\n \n-        for typ in path.segments[i].types.iter() {\n+        for typ in path.segments.get(i).types.iter() {\n             function_context.tcx()\n                             .sess\n                             .span_err(typ.span,\n@@ -1493,7 +1496,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                 ast::FromImpl(_) => \"impl\",\n             };\n \n-            let trait_segment = &path.segments[path.segments.len() - 2];\n+            let trait_segment = &path.segments.get(path.segments.len() - 2);\n \n             // Make sure lifetime parameterization agrees with the trait or\n             // implementation type.\n@@ -1567,7 +1570,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n         _ => {\n             // Verify that no lifetimes or type parameters are present on\n             // the penultimate segment of the path.\n-            let segment = &path.segments[path.segments.len() - 2];\n+            let segment = &path.segments.get(path.segments.len() - 2);\n             for lifetime in segment.lifetimes.iter() {\n                 function_context.tcx()\n                     .sess\n@@ -2415,7 +2418,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Generate the struct type.\n         let regions = fcx.infcx().next_region_vars(\n             infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count);\n+            region_parameter_count).move_iter().collect();\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             regions: ty::NonerasedRegions(opt_vec::from(regions)),\n@@ -2473,7 +2476,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Generate the enum type.\n         let regions = fcx.infcx().next_region_vars(\n             infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count);\n+            region_parameter_count).move_iter().collect();\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n             regions: ty::NonerasedRegions(opt_vec::from(regions)),\n@@ -2866,7 +2869,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprMatch(discrim, ref arms) => {\n-        _match::check_match(fcx, expr, discrim, *arms);\n+        _match::check_match(fcx, expr, discrim, arms.as_slice());\n       }\n       ast::ExprFnBlock(decl, body) => {\n         check_expr_fn(fcx,\n@@ -2891,7 +2894,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(f, ref args) => {\n-          check_call(fcx, expr, f, *args);\n+          check_call(fcx, expr, f, args.as_slice());\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -2907,7 +2910,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, *args, *tps);\n+        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n         let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -3093,11 +3096,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         match def_map.get().find(&id) {\n             Some(&ast::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n-                                         *fields, base_expr);\n+                                         fields.as_slice(), base_expr);\n             }\n             Some(&ast::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, *fields);\n+                                          variant_id, fields.as_slice());\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span,\n@@ -3106,7 +3109,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, base, field.name, *tys);\n+        check_field(fcx, expr, base, field.name, tys.as_slice());\n       }\n       ast::ExprIndex(base, idx) => {\n           check_expr(fcx, base);\n@@ -3670,7 +3673,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         opt_vec::from(fcx.infcx().next_region_vars(\n                 infer::BoundRegionInTypeOrImpl(span),\n-                num_expected_regions))\n+                num_expected_regions).move_iter().collect())\n     };\n     let regions = ty::NonerasedRegions(regions);\n "}, {"sha": "ed03ced5ca066635fdadbfe074246ef0ed365ba1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -437,13 +437,18 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprCall(callee, ref args) => {\n             constrain_callee(rcx, callee.id, expr, callee);\n-            constrain_call(rcx, Some(callee.id), expr, None, *args, false);\n+            constrain_call(rcx,\n+                           Some(callee.id),\n+                           expr,\n+                           None,\n+                           args.as_slice(),\n+                           false);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, None, expr, Some(args[0]),\n+            constrain_call(rcx, None, expr, Some(*args.get(0)),\n                            args.slice_from(1), false);\n \n             visit::walk_expr(rcx, expr, ());\n@@ -545,7 +550,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(discr, ref arms) => {\n-            link_match(rcx, discr, *arms);\n+            link_match(rcx, discr, arms.as_slice());\n \n             visit::walk_expr(rcx, expr, ());\n         }"}, {"sha": "e47b6e722f386ecd17844cdc2f67777389798fe8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -524,7 +524,8 @@ impl CoherenceChecker {\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(region_parameters)),\n+            regions: ty::NonerasedRegions(opt_vec::from(\n+                             region_parameters.move_iter().collect())),\n             self_ty: None,\n             tps: type_parameters\n         };"}, {"sha": "f7733335c91773c050848dc6a59d982663f8c350", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -149,7 +149,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n-                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n+                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -166,7 +166,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n                 let input_tys = struct_def.fields.map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n-                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n+                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n             }\n         };\n \n@@ -235,8 +235,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     let trait_def_id = local_def(trait_id);\n                     let mut trait_method_def_ids = tcx.trait_method_def_ids\n                                                       .borrow_mut();\n-                    trait_method_def_ids.get().insert(trait_def_id,\n-                                                      method_def_ids);\n+                    trait_method_def_ids.get()\n+                                        .insert(trait_def_id,\n+                                                @method_def_ids.iter()\n+                                                               .map(|x| *x)\n+                                                               .collect());\n                 }\n                 _ => {} // Ignore things that aren't traits.\n             }\n@@ -575,7 +578,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n             get_enum_variant_types(ccx,\n                                    tpt.ty,\n-                                   enum_definition.variants,\n+                                   enum_definition.variants.as_slice(),\n                                    generics);\n         },\n         ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n@@ -604,7 +607,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            *ms,\n+                            ms.as_slice(),\n                             selfty,\n                             &i_ty_generics,\n                             generics,\n@@ -626,11 +629,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             // Run convert_methods on the provided methods.\n             let (_, provided_methods) =\n-                split_trait_methods(*trait_methods);\n+                split_trait_methods(trait_methods.as_slice());\n             let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            provided_methods,\n+                            provided_methods.as_slice(),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n                             generics,\n@@ -701,15 +704,19 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                     let mut tcache = tcx.tcache.borrow_mut();\n                     tcache.get().insert(local_def(ctor_id), tpt);\n                 }\n-            } else if struct_def.fields[0].node.kind == ast::UnnamedField {\n+            } else if struct_def.fields.get(0).node.kind ==\n+                    ast::UnnamedField {\n                 // Tuple-like.\n                 let inputs = {\n                     let tcache = tcx.tcache.borrow();\n                     struct_def.fields.map(\n                         |field| tcache.get().get(\n                             &local_def(field.node.id)).ty)\n                 };\n-                let ctor_fn_ty = ty::mk_ctor_fn(tcx, ctor_id, inputs, selfty);\n+                let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n+                                                ctor_id,\n+                                                inputs.as_slice(),\n+                                                selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 {\n                     let mut tcache = tcx.tcache.borrow_mut();\n@@ -802,7 +809,10 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n             let self_ty = ty::mk_self(tcx, def_id);\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n-            let bounds = ensure_supertraits(ccx, it.id, it.span, *supertraits);\n+            let bounds = ensure_supertraits(ccx,\n+                                            it.id,\n+                                            it.span,\n+                                            supertraits.as_slice());\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n@@ -980,7 +990,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     def\n                 }\n             }\n-        }))\n+        }).move_iter().collect())\n     };\n \n     fn compute_bounds(\n@@ -1032,7 +1042,10 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                           -> ty::ty_param_bounds_and_ty {\n     let ty_generics = ty_generics(ccx, ast_generics, 0);\n     let rb = BindingRscope::new(def_id.node);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n+    let input_tys = decl.inputs\n+                        .iter()\n+                        .map(|a| ty_of_arg(ccx, &rb, a, None))\n+                        .collect();\n     let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n \n     let t_fn = ty::mk_bare_fn("}, {"sha": "1384bf182a76229dec1d27176272756cfb6cd9d5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -603,7 +603,7 @@ impl<T:Repr> Repr for OptVec<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n             opt_vec::Empty => ~\"[]\",\n-            opt_vec::Vec(ref v) => repr_vec(tcx, *v)\n+            opt_vec::Vec(ref v) => repr_vec(tcx, v.as_slice())\n         }\n     }\n }"}, {"sha": "ce922e7d6951f2507f17fbbb97572662cb77c278", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -29,6 +29,7 @@ use std;\n use doctree;\n use visit_ast;\n use std::local_data;\n+use std::vec_ng::Vec;\n \n pub trait Clean<T> {\n     fn clean(&self) -> T;\n@@ -39,6 +40,13 @@ impl<T: Clean<U>, U> Clean<~[U]> for ~[T] {\n         self.iter().map(|x| x.clean()).collect()\n     }\n }\n+\n+impl<T: Clean<U>, U> Clean<Vec<U>> for Vec<T> {\n+    fn clean(&self) -> Vec<U> {\n+        self.iter().map(|x| x.clean()).collect()\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<U> for @T {\n     fn clean(&self) -> U {\n         (**self).clean()\n@@ -54,10 +62,10 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<~[U]> for syntax::opt_vec::OptVec<T> {\n-    fn clean(&self) -> ~[U] {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::opt_vec::OptVec<T> {\n+    fn clean(&self) -> Vec<U> {\n         match self {\n-            &syntax::opt_vec::Empty => ~[],\n+            &syntax::opt_vec::Empty => Vec::new(),\n             &syntax::opt_vec::Vec(ref v) => v.clean()\n         }\n     }\n@@ -196,6 +204,25 @@ impl Clean<Item> for doctree::Module {\n         } else {\n             ~\"\"\n         };\n+        let mut foreigns = ~[];\n+        for subforeigns in self.foreigns.clean().move_iter() {\n+            for foreign in subforeigns.move_iter() {\n+                foreigns.push(foreign)\n+            }\n+        }\n+        let items: ~[~[Item]] = ~[\n+            self.structs.clean().move_iter().collect(),\n+            self.enums.clean().move_iter().collect(),\n+            self.fns.clean().move_iter().collect(),\n+            foreigns,\n+            self.mods.clean().move_iter().collect(),\n+            self.typedefs.clean().move_iter().collect(),\n+            self.statics.clean().move_iter().collect(),\n+            self.traits.clean().move_iter().collect(),\n+            self.impls.clean().move_iter().collect(),\n+            self.view_items.clean().move_iter().collect(),\n+            self.macros.clean().move_iter().collect()\n+        ];\n         Item {\n             name: Some(name),\n             attrs: self.attrs.clean(),\n@@ -204,12 +231,7 @@ impl Clean<Item> for doctree::Module {\n             id: self.id,\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n-               items: [self.structs.clean(), self.enums.clean(),\n-                       self.fns.clean(), self.foreigns.clean().concat_vec(),\n-                       self.mods.clean(), self.typedefs.clean(),\n-                       self.statics.clean(), self.traits.clean(),\n-                       self.impls.clean(), self.view_items.clean(),\n-                       self.macros.clean()].concat_vec()\n+               items: items.concat_vec(),\n             })\n         }\n     }\n@@ -227,7 +249,7 @@ impl Clean<Attribute> for ast::MetaItem {\n         match self.node {\n             ast::MetaWord(ref s) => Word(s.get().to_owned()),\n             ast::MetaList(ref s, ref l) => {\n-                List(s.get().to_owned(), l.clean())\n+                List(s.get().to_owned(), l.clean().move_iter().collect())\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n                 NameValue(s.get().to_owned(), lit_to_str(v))\n@@ -276,7 +298,7 @@ impl Clean<TyParam> for ast::TyParam {\n         TyParam {\n             name: self.ident.clean(),\n             id: self.id,\n-            bounds: self.bounds.clean(),\n+            bounds: self.bounds.clean().move_iter().collect(),\n         }\n     }\n }\n@@ -323,8 +345,8 @@ pub struct Generics {\n impl Clean<Generics> for ast::Generics {\n     fn clean(&self) -> Generics {\n         Generics {\n-            lifetimes: self.lifetimes.clean(),\n-            type_params: self.ty_params.clean(),\n+            lifetimes: self.lifetimes.clean().move_iter().collect(),\n+            type_params: self.ty_params.clean().move_iter().collect(),\n         }\n     }\n }\n@@ -353,7 +375,7 @@ impl Clean<Item> for ast::Method {\n         };\n         Item {\n             name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n+            attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             id: self.id.clone(),\n             visibility: self.vis.clean(),\n@@ -391,7 +413,7 @@ impl Clean<Item> for ast::TypeMethod {\n         };\n         Item {\n             name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n+            attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             id: self.id,\n             visibility: None,\n@@ -464,12 +486,12 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n         ClosureDecl {\n             sigil: self.sigil,\n             region: self.region.clean(),\n-            lifetimes: self.lifetimes.clean(),\n+            lifetimes: self.lifetimes.clean().move_iter().collect(),\n             decl: self.decl.clean(),\n             onceness: self.onceness,\n             purity: self.purity,\n             bounds: match self.bounds {\n-                Some(ref x) => x.clean(),\n+                Some(ref x) => x.clean().move_iter().collect(),\n                 None        => ~[]\n             },\n         }\n@@ -673,8 +695,11 @@ impl Clean<Type> for ast::Ty {\n             TyFixedLengthVec(ty, ref e) => FixedVector(~ty.clean(),\n                                                        e.span.to_src()),\n             TyTup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n-            TyPath(ref p, ref tpbs, id) =>\n-                resolve_type(p.clean(), tpbs.clean(), id),\n+            TyPath(ref p, ref tpbs, id) => {\n+                resolve_type(p.clean(),\n+                             tpbs.clean().map(|x| x.move_iter().collect()),\n+                             id)\n+            }\n             TyClosure(ref c) => Closure(~c.clean()),\n             TyBareFn(ref barefn) => BareFunction(~barefn.clean()),\n             TyBot => Bottom,\n@@ -696,7 +721,7 @@ impl Clean<Item> for ast::StructField {\n         };\n         Item {\n             name: name.clean(),\n-            attrs: self.node.attrs.clean(),\n+            attrs: self.node.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             visibility: vis,\n             id: self.node.id,\n@@ -755,7 +780,7 @@ impl Clean<VariantStruct> for syntax::ast::StructDef {\n     fn clean(&self) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n-            fields: self.fields.clean(),\n+            fields: self.fields.clean().move_iter().collect(),\n             fields_stripped: false,\n         }\n     }\n@@ -862,7 +887,7 @@ impl Clean<Path> for ast::Path {\n     fn clean(&self) -> Path {\n         Path {\n             global: self.global,\n-            segments: self.segments.clean()\n+            segments: self.segments.clean().move_iter().collect(),\n         }\n     }\n }\n@@ -878,8 +903,8 @@ impl Clean<PathSegment> for ast::PathSegment {\n     fn clean(&self) -> PathSegment {\n         PathSegment {\n             name: self.identifier.clean(),\n-            lifetimes: self.lifetimes.clean(),\n-            types: self.types.clean()\n+            lifetimes: self.lifetimes.clean().move_iter().collect(),\n+            types: self.types.clean().move_iter().collect()\n         }\n     }\n }\n@@ -941,7 +966,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n         BareFunctionDecl {\n             purity: self.purity,\n             generics: Generics {\n-                lifetimes: self.lifetimes.clean(),\n+                lifetimes: self.lifetimes.clean().move_iter().collect(),\n                 type_params: ~[],\n             },\n             decl: self.decl.clean(),\n@@ -1028,7 +1053,7 @@ impl Clean<Item> for ast::ViewItem {\n     fn clean(&self) -> Item {\n         Item {\n             name: None,\n-            attrs: self.attrs.clean(),\n+            attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             id: 0,\n             visibility: self.vis.clean(),\n@@ -1055,7 +1080,9 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n                 };\n                 ExternMod(i.clean(), string, *id)\n             }\n-            &ast::ViewItemUse(ref vp) => Import(vp.clean())\n+            &ast::ViewItemUse(ref vp) => {\n+                Import(vp.clean().move_iter().collect())\n+            }\n         }\n     }\n }\n@@ -1083,8 +1110,10 @@ impl Clean<ViewPath> for ast::ViewPath {\n                 SimpleImport(i.clean(), resolve_use_source(p.clean(), id)),\n             ast::ViewPathGlob(ref p, id) =>\n                 GlobImport(resolve_use_source(p.clean(), id)),\n-            ast::ViewPathList(ref p, ref pl, id) =>\n-                ImportList(resolve_use_source(p.clean(), id), pl.clean()),\n+            ast::ViewPathList(ref p, ref pl, id) => {\n+                ImportList(resolve_use_source(p.clean(), id),\n+                           pl.clean().move_iter().collect())\n+            }\n         }\n     }\n }\n@@ -1104,8 +1133,8 @@ impl Clean<ViewListIdent> for ast::PathListIdent {\n     }\n }\n \n-impl Clean<~[Item]> for ast::ForeignMod {\n-    fn clean(&self) -> ~[Item] {\n+impl Clean<Vec<Item>> for ast::ForeignMod {\n+    fn clean(&self) -> Vec<Item> {\n         self.items.clean()\n     }\n }\n@@ -1130,7 +1159,7 @@ impl Clean<Item> for ast::ForeignItem {\n         };\n         Item {\n             name: Some(self.ident.clean()),\n-            attrs: self.attrs.clean(),\n+            attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             id: self.id,\n             visibility: self.vis.clean(),"}, {"sha": "dc15b7f73a9bafb9b8a6e3c494f9c8f9b77470e9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -11,6 +11,7 @@\n //! Rust AST Visitor. Extracts useful information and massages it into a form\n //! usable for clean\n \n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast_util;\n@@ -39,11 +40,17 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {\n-        self.attrs = krate.attrs.clone();\n+        self.attrs = krate.attrs.iter().map(|x| (*x).clone()).collect();\n \n-        self.module = self.visit_mod_contents(krate.span, krate.attrs.clone(),\n-                                              ast::Public, ast::CRATE_NODE_ID,\n-                                              &krate.module, None);\n+        self.module = self.visit_mod_contents(krate.span,\n+                                              krate.attrs\n+                                                   .iter()\n+                                                   .map(|x| *x)\n+                                                   .collect(),\n+                                              ast::Public,\n+                                              ast::CRATE_NODE_ID,\n+                                              &krate.module,\n+                                              None);\n         self.module.is_crate = true;\n     }\n \n@@ -56,9 +63,9 @@ impl<'a> RustdocVisitor<'a> {\n             struct_type: struct_type,\n             name: item.ident,\n             vis: item.vis,\n-            attrs: item.attrs.clone(),\n+            attrs: item.attrs.iter().map(|x| *x).collect(),\n             generics: generics.clone(),\n-            fields: sd.fields.clone(),\n+            fields: sd.fields.iter().map(|x| (*x).clone()).collect(),\n             where: item.span\n         }\n     }\n@@ -70,7 +77,7 @@ impl<'a> RustdocVisitor<'a> {\n         for x in def.variants.iter() {\n             vars.push(Variant {\n                 name: x.node.name,\n-                attrs: x.node.attrs.clone(),\n+                attrs: x.node.attrs.iter().map(|x| *x).collect(),\n                 vis: x.node.vis,\n                 id: x.node.id,\n                 kind: x.node.kind.clone(),\n@@ -82,7 +89,7 @@ impl<'a> RustdocVisitor<'a> {\n             variants: vars,\n             vis: it.vis,\n             generics: params.clone(),\n-            attrs: it.attrs.clone(),\n+            attrs: it.attrs.iter().map(|x| *x).collect(),\n             id: it.id,\n             where: it.span,\n         }\n@@ -95,7 +102,7 @@ impl<'a> RustdocVisitor<'a> {\n         Function {\n             id: item.id,\n             vis: item.vis,\n-            attrs: item.attrs.clone(),\n+            attrs: item.attrs.iter().map(|x| *x).collect(),\n             decl: fd.clone(),\n             name: item.ident,\n             where: item.span,\n@@ -130,11 +137,11 @@ impl<'a> RustdocVisitor<'a> {\n             ast::ViewItemUse(ref paths) => {\n                 // rustc no longer supports \"use foo, bar;\"\n                 assert_eq!(paths.len(), 1);\n-                match self.visit_view_path(paths[0], om) {\n+                match self.visit_view_path(*paths.get(0), om) {\n                     None => return,\n                     Some(path) => {\n                         ast::ViewItem {\n-                            node: ast::ViewItemUse(~[path]),\n+                            node: ast::ViewItemUse(vec!(path)),\n                             .. item.clone()\n                         }\n                     }\n@@ -152,7 +159,7 @@ impl<'a> RustdocVisitor<'a> {\n                 if self.resolve_id(id, false, om) { return None }\n             }\n             ast::ViewPathList(ref p, ref paths, ref b) => {\n-                let mut mine = ~[];\n+                let mut mine = Vec::new();\n                 for path in paths.iter() {\n                     if !self.resolve_id(path.node.id, false, om) {\n                         mine.push(path.clone());\n@@ -217,9 +224,15 @@ impl<'a> RustdocVisitor<'a> {\n         debug!(\"Visiting item {:?}\", item);\n         match item.node {\n             ast::ItemMod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.span, item.attrs.clone(),\n-                                                item.vis, item.id, m,\n-                                                Some(item.ident)));\n+                om.mods.push(self.visit_mod_contents(item.span,\n+                                                     item.attrs\n+                                                         .iter()\n+                                                         .map(|x| *x)\n+                                                         .collect(),\n+                                                     item.vis,\n+                                                     item.id,\n+                                                     m,\n+                                                     Some(item.ident)));\n             },\n             ast::ItemEnum(ref ed, ref gen) =>\n                 om.enums.push(self.visit_enum_def(item, ed, gen)),\n@@ -233,7 +246,7 @@ impl<'a> RustdocVisitor<'a> {\n                     gen: gen.clone(),\n                     name: item.ident,\n                     id: item.id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n                 };\n@@ -246,7 +259,7 @@ impl<'a> RustdocVisitor<'a> {\n                     expr: exp.clone(),\n                     id: item.id,\n                     name: item.ident,\n-                    attrs: item.attrs.clone(),\n+                    attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n                 };\n@@ -255,11 +268,11 @@ impl<'a> RustdocVisitor<'a> {\n             ast::ItemTrait(ref gen, ref tr, ref met) => {\n                 let t = Trait {\n                     name: item.ident,\n-                    methods: met.clone(),\n+                    methods: met.iter().map(|x| (*x).clone()).collect(),\n                     generics: gen.clone(),\n-                    parents: tr.clone(),\n+                    parents: tr.iter().map(|x| (*x).clone()).collect(),\n                     id: item.id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n                 };\n@@ -270,8 +283,8 @@ impl<'a> RustdocVisitor<'a> {\n                     generics: gen.clone(),\n                     trait_: tr.clone(),\n                     for_: ty,\n-                    methods: meths.clone(),\n-                    attrs: item.attrs.clone(),\n+                    methods: meths.iter().map(|x| *x).collect(),\n+                    attrs: item.attrs.iter().map(|x| *x).collect(),\n                     id: item.id,\n                     where: item.span,\n                     vis: item.vis,\n@@ -284,7 +297,7 @@ impl<'a> RustdocVisitor<'a> {\n             ast::ItemMac(ref _m) => {\n                 om.macros.push(Macro {\n                     id: item.id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: item.attrs.iter().map(|x| *x).collect(),\n                     name: item.ident,\n                     where: item.span,\n                 })"}, {"sha": "0d319c5d74ef996957ec67943fccb21e87c2059b", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -70,6 +70,7 @@ use option::{Option, Some, None};\n use rc::Rc;\n use str::{Str, StrSlice};\n use vec::{Vector, ImmutableVector};\n+use vec_ng::Vec;\n \n /// Reexport the `sip::hash` function as our default hasher.\n pub use hash = self::sip::hash;\n@@ -207,6 +208,13 @@ impl<S: Writer, T: Hash<S>> Hash<S> for ~[T] {\n     }\n }\n \n+impl<S: Writer, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n+\n impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a T {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "9b6acdd9b9ee554d670f02e5682ec7c12bc30e67", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -15,6 +15,8 @@ use cast::{forget, transmute};\n use clone::Clone;\n use cmp::{Eq, Ordering, TotalEq, TotalOrd};\n use container::Container;\n+use default::Default;\n+use fmt;\n use iter::{DoubleEndedIterator, FromIterator, Iterator};\n use libc::{free, c_void};\n use mem::{size_of, move_val_init};\n@@ -26,7 +28,8 @@ use ptr::RawPtr;\n use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n-use vec::{ImmutableVector, Items, MutItems, MutableVector, RevItems};\n+use vec::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n+use vec::{RevItems};\n \n pub struct Vec<T> {\n     priv len: uint,\n@@ -80,6 +83,26 @@ impl<T: Clone> Vec<T> {\n             self.push((*element).clone())\n         }\n     }\n+\n+\n+    pub fn grow(&mut self, n: uint, initval: &T) {\n+        let new_len = self.len() + n;\n+        self.reserve(new_len);\n+        let mut i: uint = 0u;\n+\n+        while i < n {\n+            self.push((*initval).clone());\n+            i += 1u;\n+        }\n+    }\n+\n+    pub fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n+        let l = self.len();\n+        if index >= l {\n+            self.grow(index - l + 1u, initval);\n+        }\n+        *self.get_mut(index) = val;\n+    }\n }\n \n impl<T:Clone> Clone for Vec<T> {\n@@ -340,6 +363,18 @@ impl<T> Vec<T> {\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n         self.as_slice().slice_from(start)\n     }\n+\n+    #[inline]\n+    pub fn init<'a>(&'a self) -> &'a [T] {\n+        self.slice(0, self.len() - 1)\n+    }\n+}\n+\n+impl<T:Eq> Vec<T> {\n+    /// Return true if a vector contains an element with the given value\n+    pub fn contains(&self, x: &T) -> bool {\n+        self.as_slice().contains(x)\n+    }\n }\n \n #[inline]\n@@ -348,6 +383,14 @@ pub fn append<T:Clone>(mut first: Vec<T>, second: &[T]) -> Vec<T> {\n     first\n }\n \n+/// Appends one element to the vector provided. The vector itself is then\n+/// returned for use again.\n+#[inline]\n+pub fn append_one<T>(mut lhs: Vec<T>, x: T) -> Vec<T> {\n+    lhs.push(x);\n+    lhs\n+}\n+\n #[unsafe_destructor]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n@@ -360,6 +403,18 @@ impl<T> Drop for Vec<T> {\n     }\n }\n \n+impl<T> Default for Vec<T> {\n+    fn default() -> Vec<T> {\n+        Vec::new()\n+    }\n+}\n+\n+impl<T:fmt::Show> fmt::Show for Vec<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.as_slice().fmt(f)\n+    }\n+}\n+\n pub struct MoveItems<T> {\n     priv allocation: *mut c_void, // the block of memory allocated for the vector\n     priv iter: Items<'static, T>"}, {"sha": "a06415bc083a8ab33e992f62a6f2f8093e94f932", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::fmt;\n+use std::vec_ng::Vec;\n use std::fmt::Show;\n \n #[deriving(Eq)]\n@@ -117,8 +118,8 @@ pub fn lookup(name: &str) -> Option<Abi> {\n     res\n }\n \n-pub fn all_names() -> ~[&'static str] {\n-    AbiDatas.map(|d| d.name)\n+pub fn all_names() -> Vec<&'static str> {\n+    AbiDatas.iter().map(|d| d.name).collect()\n }\n \n impl Abi {\n@@ -232,7 +233,7 @@ impl AbiSet {\n     }\n \n     pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n-        let mut abis = ~[];\n+        let mut abis = Vec::new();\n         self.each(|abi| { abis.push(abi); true });\n \n         for (i, abi) in abis.iter().enumerate() {"}, {"sha": "947463d8f47b116ba93de9f6ff26859690068ba2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -23,6 +23,7 @@ use std::cell::RefCell;\n use collections::HashMap;\n use std::option::Option;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A pointer abstraction. FIXME(eddyb) #10676 use Rc<T> in the future.\n@@ -98,7 +99,7 @@ pub type SyntaxContext = u32;\n // it should cut down on memory use *a lot*; applying a mark\n // to a tree containing 50 identifiers would otherwise generate\n pub struct SCTable {\n-    table: RefCell<~[SyntaxContext_]>,\n+    table: RefCell<Vec<SyntaxContext_> >,\n     mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n     rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n }\n@@ -164,7 +165,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    segments: ~[PathSegment],\n+    segments: Vec<PathSegment> ,\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n@@ -288,12 +289,12 @@ pub enum DefRegion {\n \n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n-pub type CrateConfig = ~[@MetaItem];\n+pub type CrateConfig = Vec<@MetaItem> ;\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Crate {\n     module: Mod,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     config: CrateConfig,\n     span: Span,\n }\n@@ -303,7 +304,7 @@ pub type MetaItem = Spanned<MetaItem_>;\n #[deriving(Clone, Encodable, Decodable, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n-    MetaList(InternedString, ~[@MetaItem]),\n+    MetaList(InternedString, Vec<@MetaItem> ),\n     MetaNameValue(InternedString, Lit),\n }\n \n@@ -334,8 +335,8 @@ impl Eq for MetaItem_ {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Block {\n-    view_items: ~[ViewItem],\n-    stmts: ~[@Stmt],\n+    view_items: Vec<ViewItem> ,\n+    stmts: Vec<@Stmt> ,\n     expr: Option<@Expr>,\n     id: NodeId,\n     rules: BlockCheckMode,\n@@ -373,17 +374,17 @@ pub enum Pat_ {\n     // records this pattern's NodeId in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     PatIdent(BindingMode, Path, Option<@Pat>),\n-    PatEnum(Path, Option<~[@Pat]>), /* \"none\" means a * pattern where\n+    PatEnum(Path, Option<Vec<@Pat> >), /* \"none\" means a * pattern where\n                                      * we don't bind the fields to names */\n-    PatStruct(Path, ~[FieldPat], bool),\n-    PatTup(~[@Pat]),\n+    PatStruct(Path, Vec<FieldPat> , bool),\n+    PatTup(Vec<@Pat> ),\n     PatUniq(@Pat),\n     PatRegion(@Pat), // reference pattern\n     PatLit(@Expr),\n     PatRange(@Expr, @Expr),\n     // [a, b, ..i, y, z] is represented as\n     // PatVec(~[a, b], Some(i), ~[y, z])\n-    PatVec(~[@Pat], Option<@Pat>, ~[@Pat])\n+    PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> )\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n@@ -488,7 +489,7 @@ pub enum Decl_ {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n-    pats: ~[@Pat],\n+    pats: Vec<@Pat> ,\n     guard: Option<@Expr>,\n     body: P<Block>,\n }\n@@ -526,10 +527,10 @@ pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n     ExprBox(@Expr, @Expr),\n-    ExprVec(~[@Expr], Mutability),\n-    ExprCall(@Expr, ~[@Expr]),\n-    ExprMethodCall(Ident, ~[P<Ty>], ~[@Expr]),\n-    ExprTup(~[@Expr]),\n+    ExprVec(Vec<@Expr> , Mutability),\n+    ExprCall(@Expr, Vec<@Expr> ),\n+    ExprMethodCall(Ident, Vec<P<Ty>> , Vec<@Expr> ),\n+    ExprTup(Vec<@Expr> ),\n     ExprBinary(BinOp, @Expr, @Expr),\n     ExprUnary(UnOp, @Expr),\n     ExprLit(@Lit),\n@@ -541,14 +542,14 @@ pub enum Expr_ {\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(@Expr, ~[Arm]),\n+    ExprMatch(@Expr, Vec<Arm> ),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),\n     ExprAssignOp(BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, ~[P<Ty>]),\n+    ExprField(@Expr, Ident, Vec<P<Ty>> ),\n     ExprIndex(@Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,\n@@ -569,7 +570,7 @@ pub enum Expr_ {\n     ExprMac(Mac),\n \n     // A struct literal expression.\n-    ExprStruct(Path, ~[Field], Option<@Expr> /* base */),\n+    ExprStruct(Path, Vec<Field> , Option<@Expr> /* base */),\n \n     // A vector literal constructed from one repeated element.\n     ExprRepeat(@Expr /* element */, @Expr /* count */, Mutability),\n@@ -600,14 +601,14 @@ pub enum TokenTree {\n     TTTok(Span, ::parse::token::Token),\n     // a delimited sequence (the delimiters appear as the first\n     // and last elements of the vector)\n-    TTDelim(@~[TokenTree]),\n+    TTDelim(@Vec<TokenTree> ),\n \n     // These only make sense for right-hand-sides of MBE macros:\n \n     // a kleene-style repetition sequence with a span, a TTForest,\n     // an optional separator, and a boolean where true indicates\n     // zero or more (..), and false indicates one or more (+).\n-    TTSeq(Span, @~[TokenTree], Option<::parse::token::Token>, bool),\n+    TTSeq(Span, @Vec<TokenTree> , Option<::parse::token::Token>, bool),\n \n     // a syntactic variable that will be filled in by macro expansion.\n     TTNonterminal(Span, Ident)\n@@ -673,7 +674,7 @@ pub enum Matcher_ {\n     MatchTok(::parse::token::Token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n     // lo, hi position-in-match-array used:\n-    MatchSeq(~[Matcher], Option<::parse::token::Token>, bool, uint, uint),\n+    MatchSeq(Vec<Matcher> , Option<::parse::token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n     MatchNonterminal(Ident, Ident, uint)\n }\n@@ -686,7 +687,7 @@ pub type Mac = Spanned<Mac_>;\n // There's only one flavor, now, so this could presumably be simplified.\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n-    MacInvocTT(Path, ~[TokenTree], SyntaxContext),   // new macro-invocation\n+    MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n@@ -700,7 +701,7 @@ pub type Lit = Spanned<Lit_>;\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n-    LitBinary(Rc<~[u8]>),\n+    LitBinary(Rc<Vec<u8> >),\n     LitChar(u32),\n     LitInt(i64, IntTy),\n     LitUint(u64, UintTy),\n@@ -729,7 +730,7 @@ pub struct TypeField {\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     purity: Purity,\n     decl: P<FnDecl>,\n     generics: Generics,\n@@ -858,7 +859,7 @@ pub enum Ty_ {\n     TyRptr(Option<Lifetime>, MutTy),\n     TyClosure(@ClosureTy),\n     TyBareFn(@BareFnTy),\n-    TyTup(~[P<Ty>]),\n+    TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n     TyTypeof(@Expr),\n     // TyInfer means the type should be inferred instead of it having been\n@@ -878,8 +879,8 @@ pub struct InlineAsm {\n     asm: InternedString,\n     asm_str_style: StrStyle,\n     clobbers: InternedString,\n-    inputs: ~[(InternedString, @Expr)],\n-    outputs: ~[(InternedString, @Expr)],\n+    inputs: Vec<(InternedString, @Expr)> ,\n+    outputs: Vec<(InternedString, @Expr)> ,\n     volatile: bool,\n     alignstack: bool,\n     dialect: AsmDialect\n@@ -914,7 +915,7 @@ impl Arg {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n-    inputs: ~[Arg],\n+    inputs: Vec<Arg> ,\n     output: P<Ty>,\n     cf: RetStyle,\n     variadic: bool\n@@ -957,7 +958,7 @@ pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n #[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     generics: Generics,\n     explicit_self: ExplicitSelf,\n     purity: Purity,\n@@ -970,15 +971,15 @@ pub struct Method {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Mod {\n-    view_items: ~[ViewItem],\n-    items: ~[@Item],\n+    view_items: Vec<ViewItem> ,\n+    items: Vec<@Item> ,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     abis: AbiSet,\n-    view_items: ~[ViewItem],\n-    items: ~[@ForeignItem],\n+    view_items: Vec<ViewItem> ,\n+    items: Vec<@ForeignItem> ,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n@@ -989,19 +990,19 @@ pub struct VariantArg {\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n-    TupleVariantKind(~[VariantArg]),\n+    TupleVariantKind(Vec<VariantArg> ),\n     StructVariantKind(@StructDef),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct EnumDef {\n-    variants: ~[P<Variant>],\n+    variants: Vec<P<Variant>> ,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Variant_ {\n     name: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     kind: VariantKind,\n     id: NodeId,\n     disr_expr: Option<@Expr>,\n@@ -1034,13 +1035,13 @@ pub enum ViewPath_ {\n     ViewPathGlob(Path, NodeId),\n \n     // foo::bar::{a,b,c}\n-    ViewPathList(Path, ~[PathListIdent], NodeId)\n+    ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct ViewItem {\n     node: ViewItem_,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     vis: Visibility,\n     span: Span,\n }\n@@ -1052,7 +1053,7 @@ pub enum ViewItem_ {\n     // (containing arbitrary characters) from which to fetch the crate sources\n     // For example, extern crate whatever = \"github.com/mozilla/rust\"\n     ViewItemExternMod(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(~[@ViewPath]),\n+    ViewItemUse(Vec<@ViewPath> ),\n }\n \n // Meta-data associated with an item\n@@ -1109,7 +1110,7 @@ pub struct StructField_ {\n     kind: StructFieldKind,\n     id: NodeId,\n     ty: P<Ty>,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n }\n \n pub type StructField = Spanned<StructField_>;\n@@ -1122,7 +1123,7 @@ pub enum StructFieldKind {\n \n #[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct StructDef {\n-    fields: ~[StructField], /* fields, not including ctor */\n+    fields: Vec<StructField> , /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n     ctor_id: Option<NodeId>\n@@ -1135,7 +1136,7 @@ pub struct StructDef {\n #[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Item {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     id: NodeId,\n     node: Item_,\n     vis: Visibility,\n@@ -1151,19 +1152,19 @@ pub enum Item_ {\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n     ItemStruct(@StructDef, Generics),\n-    ItemTrait(Generics, ~[TraitRef], ~[TraitMethod]),\n+    ItemTrait(Generics, Vec<TraitRef> , Vec<TraitMethod> ),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             ~[@Method]),\n+             Vec<@Method> ),\n     // a macro invocation (which includes macro definition)\n     ItemMac(Mac),\n }\n \n #[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct ForeignItem {\n     ident: Ident,\n-    attrs: ~[Attribute],\n+    attrs: Vec<Attribute> ,\n     node: ForeignItem_,\n     id: NodeId,\n     span: Span,\n@@ -1193,6 +1194,8 @@ mod test {\n     use codemap::*;\n     use super::*;\n \n+    use std::vec_ng::Vec;\n+\n     fn is_freeze<T: Freeze>() {}\n \n     // Assert that the AST remains Freeze (#10693).\n@@ -1205,9 +1208,9 @@ mod test {\n     #[test]\n     fn check_asts_encodable() {\n         let e = Crate {\n-            module: Mod {view_items: ~[], items: ~[]},\n-            attrs: ~[],\n-            config: ~[],\n+            module: Mod {view_items: Vec::new(), items: Vec::new()},\n+            attrs: Vec::new(),\n+            config: Vec::new(),\n             span: Span {\n                 lo: BytePos(10),\n                 hi: BytePos(20),"}, {"sha": "56a99736866f6a037fdc48413c36ad3ac702d48a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -23,6 +23,7 @@ use std::cell::RefCell;\n use std::iter;\n use std::vec;\n use std::fmt;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Eq)]\n pub enum PathElem {\n@@ -134,7 +135,7 @@ enum MapEntry {\n }\n \n struct InlinedParent {\n-    path: ~[PathElem],\n+    path: Vec<PathElem> ,\n     // Required by NodeTraitMethod and NodeMethod.\n     def_id: DefId\n }\n@@ -185,13 +186,17 @@ pub struct Map {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    priv map: RefCell<~[MapEntry]>\n+    priv map: RefCell<Vec<MapEntry> >\n }\n \n impl Map {\n     fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n         let map = self.map.borrow();\n-        map.get().get(id as uint).map(|x| *x)\n+        if map.get().len() > id as uint {\n+            Some(*map.get().get(id as uint))\n+        } else {\n+            None\n+        }\n     }\n \n     /// Retrieve the Node corresponding to `id`, failing if it cannot\n@@ -522,7 +527,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n }\n \n pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n-    let map = Map { map: RefCell::new(~[]) };\n+    let map = Map { map: RefCell::new(Vec::new()) };\n     let krate = {\n         let mut cx = Ctx {\n             map: &map,\n@@ -557,7 +562,7 @@ pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n pub fn map_decoded_item<F: FoldOps>(map: &Map,\n-                                    path: ~[PathElem],\n+                                    path: Vec<PathElem> ,\n                                     fold_ops: F,\n                                     fold: |&mut Ctx<F>| -> InlinedItem)\n                                     -> InlinedItem {"}, {"sha": "db9ea480e96206fb877393f2566bacab40a3d1b5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 68, "deletions": 65, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -23,6 +23,7 @@ use std::cmp;\n use collections::HashMap;\n use std::u32;\n use std::local_data;\n+use std::vec_ng::Vec;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n@@ -180,8 +181,8 @@ pub fn is_call_expr(e: @Expr) -> bool {\n \n pub fn block_from_expr(e: @Expr) -> P<Block> {\n     P(Block {\n-        view_items: ~[],\n-        stmts: ~[],\n+        view_items: Vec::new(),\n+        stmts: Vec::new(),\n         expr: Some(e),\n         id: e.id,\n         rules: DefaultBlock,\n@@ -193,13 +194,13 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     ast::Path {\n         span: s,\n         global: false,\n-        segments: ~[\n+        segments: vec!(\n             ast::PathSegment {\n                 identifier: identifier,\n                 lifetimes: opt_vec::Empty,\n                 types: opt_vec::Empty,\n             }\n-        ],\n+        ),\n     }\n }\n \n@@ -216,7 +217,7 @@ pub fn is_unguarded(a: &Arm) -> bool {\n     }\n }\n \n-pub fn unguarded_pat(a: &Arm) -> Option<~[@Pat]> {\n+pub fn unguarded_pat(a: &Arm) -> Option<Vec<@Pat> > {\n     if is_unguarded(a) {\n         Some(/* FIXME (#2543) */ a.pats.clone())\n     } else {\n@@ -241,7 +242,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty)\n }\n \n-pub fn public_methods(ms: ~[@Method]) -> ~[@Method] {\n+pub fn public_methods(ms: Vec<@Method> ) -> Vec<@Method> {\n     ms.move_iter().filter(|m| {\n         match m.vis {\n             Public => true,\n@@ -271,9 +272,9 @@ pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n }\n \n pub fn split_trait_methods(trait_methods: &[TraitMethod])\n-    -> (~[TypeMethod], ~[@Method]) {\n-    let mut reqd = ~[];\n-    let mut provd = ~[];\n+    -> (Vec<TypeMethod> , Vec<@Method> ) {\n+    let mut reqd = Vec::new();\n+    let mut provd = Vec::new();\n     for trt_method in trait_methods.iter() {\n         match *trt_method {\n             Required(ref tm) => reqd.push((*tm).clone()),\n@@ -724,7 +725,7 @@ pub fn new_rename_internal(id: Ident,\n // FIXME #8215 : currently pub to allow testing\n pub fn new_sctable_internal() -> SCTable {\n     SCTable {\n-        table: RefCell::new(~[EmptyCtxt,IllegalCtxt]),\n+        table: RefCell::new(vec!(EmptyCtxt,IllegalCtxt)),\n         mark_memo: RefCell::new(HashMap::new()),\n         rename_memo: RefCell::new(HashMap::new()),\n     }\n@@ -754,7 +755,7 @@ pub fn display_sctable(table : &SCTable) {\n \n \n /// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut ~[T], val: T) -> u32 {\n+fn idx_push<T>(vec: &mut Vec<T> , val: T) -> u32 {\n     vec.push(val);\n     (vec.len() - 1) as u32\n }\n@@ -795,7 +796,7 @@ pub fn resolve_internal(id : Ident,\n             let resolved = {\n                 let result = {\n                     let table = table.table.borrow();\n-                    table.get()[id.ctxt]\n+                    *table.get().get(id.ctxt as uint)\n                 };\n                 match result {\n                     EmptyCtxt => id.name,\n@@ -831,20 +832,20 @@ pub fn resolve_internal(id : Ident,\n }\n \n /// Compute the marks associated with a syntax context.\n-pub fn mtwt_marksof(ctxt: SyntaxContext, stopname: Name) -> ~[Mrk] {\n+pub fn mtwt_marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n     marksof(ctxt, stopname, get_sctable())\n }\n \n // the internal function for computing marks\n // it's not clear to me whether it's better to use a [] mutable\n // vector or a cons-list for this.\n-pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n-    let mut result = ~[];\n+pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> Vec<Mrk> {\n+    let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n         let table_entry = {\n             let table = table.table.borrow();\n-            table.get()[loopvar]\n+            *table.get().get(loopvar as uint)\n         };\n         match table_entry {\n             EmptyCtxt => {\n@@ -873,15 +874,15 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n     let sctable = get_sctable();\n     let table = sctable.table.borrow();\n-    match table.get()[ctxt] {\n+    match *table.get().get(ctxt as uint) {\n         ast::Mark(mrk,_) => mrk,\n         _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n     }\n }\n \n /// Push a name... unless it matches the one on top, in which\n /// case pop and discard (so two of the same marks cancel)\n-pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n+pub fn xorPush(marks: &mut Vec<Mrk> , mark: Mrk) {\n     if (marks.len() > 0) && (getLast(marks) == mark) {\n         marks.pop().unwrap();\n     } else {\n@@ -891,7 +892,7 @@ pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n \n // get the last element of a mutable array.\n // FIXME #4903: , must be a separate procedure for now.\n-pub fn getLast(arr: &~[Mrk]) -> Mrk {\n+pub fn getLast(arr: &Vec<Mrk> ) -> Mrk {\n     *arr.last().unwrap()\n }\n \n@@ -901,7 +902,7 @@ pub fn getLast(arr: &~[Mrk]) -> Mrk {\n pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n     (a.span == b.span)\n     && (a.global == b.global)\n-    && (segments_name_eq(a.segments, b.segments))\n+    && (segments_name_eq(a.segments.as_slice(), b.segments.as_slice()))\n }\n \n // are two arrays of segments equal when compared unhygienically?\n@@ -938,6 +939,8 @@ mod test {\n     use opt_vec;\n     use collections::HashMap;\n \n+    use std::vec_ng::Vec;\n+\n     fn ident_to_segment(id : &Ident) -> PathSegment {\n         PathSegment {identifier:id.clone(),\n                      lifetimes: opt_vec::Empty,\n@@ -956,21 +959,21 @@ mod test {\n     }\n \n     #[test] fn xorpush_test () {\n-        let mut s = ~[];\n+        let mut s = Vec::new();\n         xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), ~[14]);\n+        assert_eq!(s.clone(), vec!(14));\n         xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), ~[]);\n+        assert_eq!(s.clone(), Vec::new());\n         xorPush(&mut s, 14);\n-        assert_eq!(s.clone(), ~[14]);\n+        assert_eq!(s.clone(), vec!(14));\n         xorPush(&mut s, 15);\n-        assert_eq!(s.clone(), ~[14, 15]);\n+        assert_eq!(s.clone(), vec!(14, 15));\n         xorPush(&mut s, 16);\n-        assert_eq!(s.clone(), ~[14, 15, 16]);\n+        assert_eq!(s.clone(), vec!(14, 15, 16));\n         xorPush(&mut s, 16);\n-        assert_eq!(s.clone(), ~[14, 15]);\n+        assert_eq!(s.clone(), vec!(14, 15));\n         xorPush(&mut s, 15);\n-        assert_eq!(s.clone(), ~[14]);\n+        assert_eq!(s.clone(), vec!(14));\n     }\n \n     fn id(n: Name, s: SyntaxContext) -> Ident {\n@@ -987,7 +990,7 @@ mod test {\n \n     // unfold a vector of TestSC values into a SCTable,\n     // returning the resulting index\n-    fn unfold_test_sc(tscs : ~[TestSC], tail: SyntaxContext, table: &SCTable)\n+    fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n         -> SyntaxContext {\n         tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n@@ -996,11 +999,11 @@ mod test {\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n-    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> ~[TestSC] {\n-        let mut result = ~[];\n+    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> Vec<TestSC> {\n+        let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match table.get()[sc] {\n+            match *table.get().get(sc as uint) {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -1020,20 +1023,20 @@ mod test {\n     #[test] fn test_unfold_refold(){\n         let mut t = new_sctable_internal();\n \n-        let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n+        let test_sc = vec!(M(3),R(id(101,0),14),M(9));\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n-            assert!(table.get()[2] == Mark(9,0));\n-            assert!(table.get()[3] == Rename(id(101,0),14,2));\n-            assert!(table.get()[4] == Mark(3,3));\n+            assert!(*table.get().get(2) == Mark(9,0));\n+            assert!(*table.get().get(3) == Rename(id(101,0),14,2));\n+            assert!(*table.get().get(4) == Mark(3,3));\n         }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n-    fn unfold_marks(mrks: ~[Mrk], tail: SyntaxContext, table: &SCTable)\n+    fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n                     -> SyntaxContext {\n         mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n                    {new_mark_internal(*mrk,tail,table)})\n@@ -1042,44 +1045,44 @@ mod test {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(~[3,7],EMPTY_CTXT,&mut t),3);\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n         {\n             let table = t.table.borrow();\n-            assert!(table.get()[2] == Mark(7,0));\n-            assert!(table.get()[3] == Mark(3,2));\n+            assert!(*table.get().get(2) == Mark(7,0));\n+            assert!(*table.get().get(3) == Mark(3,2));\n         }\n     }\n \n     #[test] fn test_marksof () {\n         let stopname = 242;\n         let name1 = 243;\n         let mut t = new_sctable_internal();\n-        assert_eq!(marksof (EMPTY_CTXT,stopname,&t),~[]);\n+        assert_eq!(marksof (EMPTY_CTXT,stopname,&t),Vec::new());\n         // FIXME #5074: ANF'd to dodge nested calls\n-        { let ans = unfold_marks(~[4,98],EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans,stopname,&t),~[4,98]);}\n+        { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof (ans,stopname,&t),vec!(4,98));}\n         // does xoring work?\n-        { let ans = unfold_marks(~[5,5,16],EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans,stopname,&t), ~[16]);}\n+        { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof (ans,stopname,&t), vec!(16));}\n         // does nested xoring work?\n-        { let ans = unfold_marks(~[5,10,10,5,16],EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname,&t), ~[16]);}\n+        { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n+         assert_eq! (marksof (ans, stopname,&t), vec!(16));}\n         // rename where stop doesn't match:\n-        { let chain = ~[M(9),\n+        { let chain = vec!(M(9),\n                         R(id(name1,\n                              new_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           100101102),\n-                        M(14)];\n+                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n+         assert_eq! (marksof (ans, stopname, &t), vec!(9,14));}\n         // rename where stop does match\n         { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n-         let chain = ~[M(9),\n+         let chain = vec!(M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n-                       M(14)];\n+                       M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof (ans, stopname, &t), ~[9]); }\n+         assert_eq! (marksof (ans, stopname, &t), vec!(9)); }\n     }\n \n \n@@ -1090,32 +1093,32 @@ mod test {\n         // - ctxt is MT\n         assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n         // - simple ignored marks\n-        { let sc = unfold_marks(~[1,2,3],EMPTY_CTXT,&mut t);\n+        { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(~[R(id(50,EMPTY_CTXT),51),M(12)],EMPTY_CTXT,&mut t);\n+        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - rename where names do match, but marks don't\n         { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50),\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n                                    M(1),\n-                                   M(2)],\n+                                   M(2)),\n                                  EMPTY_CTXT,&mut t);\n         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n         // - rename where names and marks match\n-        { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],EMPTY_CTXT,&mut t);\n+        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50),M(1),M(2)),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - rename where names and marks match by literal sharing\n-        { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n+        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n+         let sc = unfold_test_sc(vec!(R(id(a,sc1),50)),sc1,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         println!(\"about to run bad test\");\n-        { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n-                                    R(id(a,EMPTY_CTXT),51)],\n+        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),50),\n+                                    R(id(a,EMPTY_CTXT),51)),\n                                   EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n         // the simplest double-rename:\n@@ -1126,8 +1129,8 @@ mod test {\n          let sc = new_mark_internal(9,a50_to_a51,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n          // but mark on the inside does:\n-         let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n-                                              M(9)],\n+         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n+                                              M(9)),\n                                            a_to_a50,\n                                            &mut t);\n          assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}"}, {"sha": "ed56ef15a1c8b7ceee5846d4c275189924ff6208", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,6 +21,7 @@ use parse::token;\n use crateid::CrateId;\n \n use collections::HashSet;\n+use std::vec_ng::Vec;\n \n pub trait AttrMetaMethods {\n     // This could be changed to `fn check_name(&self, name: InternedString) ->\n@@ -146,7 +147,7 @@ pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n     @dummy_spanned(MetaNameValue(name, value))\n }\n \n-pub fn mk_list_item(name: InternedString, items: ~[@MetaItem]) -> @MetaItem {\n+pub fn mk_list_item(name: InternedString, items: Vec<@MetaItem> ) -> @MetaItem {\n     @dummy_spanned(MetaList(name, items))\n }\n \n@@ -212,12 +213,12 @@ pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n+pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n     let mut v = items.iter()\n         .map(|&mi| (mi.name(), mi))\n-        .collect::<~[(InternedString, @MetaItem)]>();\n+        .collect::<Vec<(InternedString, @MetaItem)> >();\n \n     v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n \n@@ -226,7 +227,8 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n         match m.node {\n             MetaList(ref n, ref mis) => {\n                 @Spanned {\n-                    node: MetaList((*n).clone(), sort_meta_items(*mis)),\n+                    node: MetaList((*n).clone(),\n+                                   sort_meta_items(mis.as_slice())),\n                     .. /*bad*/ (*m).clone()\n                 }\n             }\n@@ -239,11 +241,11 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n-    let mut result = ~[];\n+pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<@MetaItem> {\n+    let mut result = Vec::new();\n     for attr in attrs.iter().filter(|at| at.name().equiv(&(\"link\"))) {\n         match attr.meta().node {\n-            MetaList(_, ref items) => result.push_all(*items),\n+            MetaList(_, ref items) => result.push_all(items.as_slice()),\n             _ => ()\n         }\n     }\n@@ -272,9 +274,9 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n         match attr.node.value.node {\n           MetaWord(ref n) if n.equiv(&(\"inline\")) => InlineHint,\n           MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n-            if contains_name(*items, \"always\") {\n+            if contains_name(items.as_slice(), \"always\") {\n                 InlineAlways\n-            } else if contains_name(*items, \"never\") {\n+            } else if contains_name(items.as_slice(), \"never\") {\n                 InlineNever\n             } else {\n                 InlineHint"}, {"sha": "6f17505c902279ee302d0bb241e7d180f10a81c1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -23,6 +23,7 @@ source code snippets, etc.\n \n use std::cell::RefCell;\n use std::cmp;\n+use std::vec_ng::Vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n pub trait Pos {\n@@ -188,8 +189,7 @@ pub type FileName = ~str;\n pub struct FileLines\n {\n     file: @FileMap,\n-    lines: ~[uint]\n-}\n+    lines: Vec<uint> }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n pub struct MultiByteChar {\n@@ -210,9 +210,9 @@ pub struct FileMap {\n     /// The start position of this source in the CodeMap\n     start_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    lines: RefCell<~[BytePos]>,\n+    lines: RefCell<Vec<BytePos> >,\n     /// Locations of multi-byte characters in the source code\n-    multibyte_chars: RefCell<~[MultiByteChar]>,\n+    multibyte_chars: RefCell<Vec<MultiByteChar> >,\n }\n \n impl FileMap {\n@@ -225,14 +225,14 @@ impl FileMap {\n         // the new charpos must be > the last one (or it's the first one).\n         let mut lines = self.lines.borrow_mut();;\n         let line_len = lines.get().len();\n-        assert!(line_len == 0 || (lines.get()[line_len - 1] < pos))\n+        assert!(line_len == 0 || (*lines.get().get(line_len - 1) < pos))\n         lines.get().push(pos);\n     }\n \n     // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n         let mut lines = self.lines.borrow_mut();\n-        let begin: BytePos = lines.get()[line] - self.start_pos;\n+        let begin: BytePos = *lines.get().get(line as uint) - self.start_pos;\n         let begin = begin.to_uint();\n         let slice = self.src.slice_from(begin);\n         match slice.find('\\n') {\n@@ -257,13 +257,13 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: RefCell<~[@FileMap]>\n+    files: RefCell<Vec<@FileMap> >\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n-            files: RefCell::new(~[]),\n+            files: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -278,8 +278,8 @@ impl CodeMap {\n             name: filename,\n             src: src,\n             start_pos: Pos::from_uint(start_pos),\n-            lines: RefCell::new(~[]),\n-            multibyte_chars: RefCell::new(~[]),\n+            lines: RefCell::new(Vec::new()),\n+            multibyte_chars: RefCell::new(Vec::new()),\n         };\n \n         files.get().push(filemap);\n@@ -330,7 +330,7 @@ impl CodeMap {\n     pub fn span_to_lines(&self, sp: Span) -> @FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n-        let mut lines = ~[];\n+        let mut lines = Vec::new();\n         for i in range(lo.line - 1u, hi.line as uint) {\n             lines.push(i);\n         };\n@@ -374,7 +374,7 @@ impl CodeMap {\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if files[m].start_pos > pos {\n+            if files.get(m).start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n@@ -384,7 +384,7 @@ impl CodeMap {\n         // filemap, but are not the filemaps we want (because they are length 0, they cannot\n         // contain what we are looking for). So, rewind until we find a useful filemap.\n         loop {\n-            let lines = files[a].lines.borrow();\n+            let lines = files.get(a).lines.borrow();\n             let lines = lines.get();\n             if lines.len() > 0 {\n                 break;\n@@ -406,13 +406,13 @@ impl CodeMap {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n-        let f = files.get()[idx];\n+        let f = *files.get().get(idx);\n         let mut a = 0u;\n         let mut lines = f.lines.borrow_mut();\n         let mut b = lines.get().len();\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if lines.get()[m] > pos { b = m; } else { a = m; }\n+            if *lines.get().get(m) > pos { b = m; } else { a = m; }\n         }\n         return FileMapAndLine {fm: f, line: a};\n     }\n@@ -422,7 +422,7 @@ impl CodeMap {\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n         let lines = f.lines.borrow();\n-        let linebpos = lines.get()[a];\n+        let linebpos = *lines.get().get(a);\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n@@ -441,7 +441,7 @@ impl CodeMap {\n         -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n-        let fm = files.get()[idx];\n+        let fm = *files.get().get(idx);\n         let offset = bpos - fm.start_pos;\n         return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n@@ -451,7 +451,7 @@ impl CodeMap {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n-        let map = files.get()[idx];\n+        let map = files.get().get(idx);\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;"}, {"sha": "e5136b7081b336e940bc1b1c02fd3cac2b096c0d", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -19,6 +19,7 @@ use std::fmt;\n /// to be `0.0`.\n \n use std::from_str::FromStr;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Eq)]\n pub struct CrateId {\n@@ -48,25 +49,27 @@ impl fmt::Show for CrateId {\n \n impl FromStr for CrateId {\n     fn from_str(s: &str) -> Option<CrateId> {\n-        let pieces: ~[&str] = s.splitn('#', 1).collect();\n-        let path = pieces[0].to_owned();\n+        let pieces: Vec<&str> = s.splitn('#', 1).collect();\n+        let path = pieces.get(0).to_owned();\n \n         if path.starts_with(\"/\") || path.ends_with(\"/\") ||\n             path.starts_with(\".\") || path.is_empty() {\n             return None;\n         }\n \n-        let path_pieces: ~[&str] = path.rsplitn('/', 1).collect();\n-        let inferred_name = path_pieces[0];\n+        let path_pieces: Vec<&str> = path.rsplitn('/', 1).collect();\n+        let inferred_name = *path_pieces.get(0);\n \n         let (name, version) = if pieces.len() == 1 {\n             (inferred_name.to_owned(), None)\n         } else {\n-            let hash_pieces: ~[&str] = pieces[1].splitn(':', 1).collect();\n+            let hash_pieces: Vec<&str> = pieces.get(1)\n+                                               .splitn(':', 1)\n+                                               .collect();\n             let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n-                (\"\", hash_pieces[0])\n+                (\"\", *hash_pieces.get(0))\n             } else {\n-                (hash_pieces[0], hash_pieces[1])\n+                (*hash_pieces.get(0), *hash_pieces.get(1))\n             };\n \n             let name = if !hash_name.is_empty() {\n@@ -89,7 +92,7 @@ impl FromStr for CrateId {\n         };\n \n         Some(CrateId {\n-            path: path,\n+            path: path.clone(),\n             name: name,\n             version: version,\n         })"}, {"sha": "c0c64d6fd60b293770670a3479ac3ee3a0d56dfa", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -325,7 +325,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     if lines.lines.len() == 1u {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0u;\n-        let mut num = (lines.lines[0] + 1u) / 10u;\n+        let mut num = (*lines.lines.get(0) + 1u) / 10u;\n \n         // how many digits must be indent past?\n         while num > 0u { num /= 10u; digits += 1u; }\n@@ -337,7 +337,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n         for _ in range(0, skip) { s.push_char(' '); }\n-        let orig = fm.get_line(lines.lines[0] as int);\n+        let orig = fm.get_line(*lines.lines.get(0) as int);\n         for pos in range(0u, left-skip) {\n             let curChar = orig[pos] as char;\n             // Whenever a tab occurs on the previous line, we insert one on"}, {"sha": "6080613460da219c0e3976de88bb1df44677bfd3", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -20,6 +20,8 @@ use parse;\n use parse::token::InternedString;\n use parse::token;\n \n+use std::vec_ng::Vec;\n+\n enum State {\n     Asm,\n     Outputs,\n@@ -42,12 +44,14 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n-                                           tts.to_owned());\n+                                           tts.iter()\n+                                              .map(|x| (*x).clone())\n+                                              .collect());\n \n     let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;\n-    let mut outputs = ~[];\n-    let mut inputs = ~[];\n+    let mut outputs = Vec::new();\n+    let mut inputs = Vec::new();\n     let mut cons = ~\"\";\n     let mut volatile = false;\n     let mut alignstack = false;\n@@ -119,7 +123,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             }\n             Clobbers => {\n-                let mut clobs = ~[];\n+                let mut clobs = Vec::new();\n                 while p.token != token::EOF &&\n                       p.token != token::COLON &&\n                       p.token != token::MOD_SEP {"}, {"sha": "e9fe21eded60c87ab17f43a55c42eea7cd1b9d31", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -20,6 +20,7 @@ use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n \n use collections::HashMap;\n+use std::vec_ng::Vec;\n \n // new-style macro! tt code:\n //\n@@ -74,7 +75,7 @@ pub trait IdentMacroExpander {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n-              token_tree: ~[ast::TokenTree])\n+              token_tree: Vec<ast::TokenTree> )\n               -> MacResult;\n }\n \n@@ -83,14 +84,14 @@ impl IdentMacroExpander for BasicIdentMacroExpander {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n-              token_tree: ~[ast::TokenTree])\n+              token_tree: Vec<ast::TokenTree> )\n               -> MacResult {\n         (self.expander)(cx, sp, ident, token_tree)\n     }\n }\n \n pub type IdentMacroExpanderFn =\n-    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::TokenTree]) -> MacResult;\n+    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree> ) -> MacResult;\n \n pub type MacroCrateRegistrationFun =\n     fn(|ast::Name, SyntaxExtension|);\n@@ -154,13 +155,13 @@ impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n-            pending_renames: ~[],\n+            pending_renames: Vec::new(),\n         }\n     }\n }\n \n // a list of ident->name renamings\n-pub type RenameList = ~[(ast::Ident,Name)];\n+pub type RenameList = Vec<(ast::Ident,Name)> ;\n \n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n@@ -271,7 +272,7 @@ pub struct MacroCrate {\n \n pub trait CrateLoader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate;\n-    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> ~[~str];\n+    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> Vec<~str> ;\n     fn get_registrar_symbol(&mut self, crate_num: ast::CrateNum) -> Option<~str>;\n }\n \n@@ -284,7 +285,7 @@ pub struct ExtCtxt<'a> {\n     backtrace: Option<@ExpnInfo>,\n     loader: &'a mut CrateLoader,\n \n-    mod_path: ~[ast::Ident],\n+    mod_path: Vec<ast::Ident> ,\n     trace_mac: bool\n }\n \n@@ -296,7 +297,7 @@ impl<'a> ExtCtxt<'a> {\n             cfg: cfg,\n             backtrace: None,\n             loader: loader,\n-            mod_path: ~[],\n+            mod_path: Vec::new(),\n             trace_mac: false\n         }\n     }\n@@ -329,7 +330,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n-    pub fn mod_path(&self) -> ~[ast::Ident] { self.mod_path.clone() }\n+    pub fn mod_path(&self) -> Vec<ast::Ident> { self.mod_path.clone() }\n     pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n@@ -458,11 +459,13 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n /// parsing error, emit a non-fatal error and return None.\n pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::TokenTree]) -> Option<~[@ast::Expr]> {\n+                          tts: &[ast::TokenTree]) -> Option<Vec<@ast::Expr> > {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n-                                           tts.to_owned());\n-    let mut es = ~[];\n+                                           tts.iter()\n+                                              .map(|x| (*x).clone())\n+                                              .collect());\n+    let mut es = Vec::new();\n     while p.token != token::EOF {\n         if es.len() != 0 && !p.eat(&token::COMMA) {\n             cx.span_err(sp, \"expected token: `,`\");\n@@ -507,12 +510,12 @@ impl Drop for MapChainFrame {\n \n // Only generic to make it easy to test\n pub struct SyntaxEnv {\n-    priv chain: ~[MapChainFrame],\n+    priv chain: Vec<MapChainFrame> ,\n }\n \n impl SyntaxEnv {\n     pub fn new() -> SyntaxEnv {\n-        let mut map = SyntaxEnv { chain: ~[] };\n+        let mut map = SyntaxEnv { chain: Vec::new() };\n         map.push_frame();\n         map\n     }\n@@ -553,6 +556,7 @@ impl SyntaxEnv {\n     }\n \n     pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n-        &mut self.chain[self.chain.len()-1].info\n+        let last_chain_index = self.chain.len() - 1;\n+        &mut self.chain.get_mut(last_chain_index).info\n     }\n }"}, {"sha": "34625923ea1f6fb4ba0c4b1d37d8f38e1e6c4db4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 132, "deletions": 125, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,6 +21,8 @@ use opt_vec::OptVec;\n use parse::token::special_idents;\n use parse::token;\n \n+use std::vec_ng::Vec;\n+\n pub struct Field {\n     ident: ast::Ident,\n     ex: @ast::Expr\n@@ -34,14 +36,14 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path;\n+    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;\n-    fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path;\n+    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;\n     fn path_all(&self, sp: Span,\n                 global: bool,\n-                idents: ~[ast::Ident],\n+                idents: Vec<ast::Ident> ,\n                 lifetimes: OptVec<ast::Lifetime>,\n-                types: ~[P<ast::Ty>])\n+                types: Vec<P<ast::Ty>> )\n         -> ast::Path;\n \n     // types\n@@ -61,8 +63,8 @@ pub trait AstBuilder {\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n     fn ty_nil(&self) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>];\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n@@ -87,11 +89,11 @@ pub trait AstBuilder {\n                       -> @ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@ast::Expr>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@ast::Expr>) -> P<ast::Block>;\n     fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: ~[ast::ViewItem],\n-                 stmts: ~[@ast::Stmt],\n+                 view_items: Vec<ast::ViewItem> ,\n+                 stmts: Vec<@ast::Stmt> ,\n                  expr: Option<@ast::Expr>) -> P<ast::Block>;\n \n     // expressions\n@@ -109,19 +111,19 @@ pub trait AstBuilder {\n     fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n     fn expr_mut_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr;\n     fn expr_field_access(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n-                        args: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n+                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::Expr, ident: ast::Ident,\n-                        args: ~[@ast::Expr]) -> @ast::Expr;\n+                        args: Vec<@ast::Expr> ) -> @ast::Expr;\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr;\n     fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: P<ast::Ty>) -> @ast::Expr;\n \n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n-    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr;\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr;\n+    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr;\n \n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr;\n \n@@ -131,9 +133,9 @@ pub trait AstBuilder {\n     fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr;\n \n     fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr;\n-    fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n-    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr;\n+    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n+    fn expr_vec_ng(&self, sp: Span) -> @ast::Expr;\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr;\n     fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr;\n     fn expr_str_uniq(&self, sp: Span, s: InternedString) -> @ast::Expr;\n \n@@ -152,55 +154,55 @@ pub trait AstBuilder {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> @ast::Pat;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::Pat]) -> @ast::Pat;\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat;\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: ~[ast::FieldPat]) -> @ast::Pat;\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat;\n \n-    fn arm(&self, span: Span, pats: ~[@ast::Pat], expr: @ast::Expr) -> ast::Arm;\n+    fn arm(&self, span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: ~[ast::Arm]) -> @ast::Expr;\n+    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @ast::Expr;\n     fn expr_if(&self, span: Span,\n                cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr;\n \n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr;\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr;\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr;\n     fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr;\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], blk: @ast::Expr) -> @ast::Expr;\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , blk: @ast::Expr) -> @ast::Expr;\n     fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n     fn lambda_expr_1(&self, span: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr;\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], blk: ~[@ast::Stmt]) -> @ast::Expr;\n-    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::Stmt]) -> @ast::Expr;\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::Stmt], ident: ast::Ident) -> @ast::Expr;\n+    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident> , blk: Vec<@ast::Stmt> ) -> @ast::Expr;\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr;\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr;\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: ~[ast::Attribute], node: ast::Item_) -> @ast::Item;\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n-    fn fn_decl(&self, inputs: ~[ast::Arg], output: P<ast::Ty>) -> P<ast::FnDecl>;\n+    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl>;\n \n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: ~[ast::Arg],\n+                    inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n                     body: P<ast::Block>) -> @ast::Item;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: ~[ast::Arg],\n+               inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>) -> @ast::Item;\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::Variant;\n+    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n@@ -216,8 +218,8 @@ pub trait AstBuilder {\n     fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> @ast::Item;\n \n     fn item_mod(&self, span: Span,\n-                name: Ident, attrs: ~[ast::Attribute],\n-                vi: ~[ast::ViewItem], items: ~[@ast::Item]) -> @ast::Item;\n+                name: Ident, attrs: Vec<ast::Attribute> ,\n+                vi: Vec<ast::ViewItem> , items: Vec<@ast::Item> ) -> @ast::Item;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n@@ -232,7 +234,7 @@ pub trait AstBuilder {\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: ~[@ast::MetaItem])\n+                 mis: Vec<@ast::MetaItem> )\n                  -> @ast::MetaItem;\n     fn meta_name_value(&self,\n                        sp: Span,\n@@ -241,35 +243,35 @@ pub trait AstBuilder {\n                        -> @ast::MetaItem;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem;\n+                vis: ast::Visibility, vp: Vec<@ast::ViewPath> ) -> ast::ViewItem;\n     fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::ViewItem;\n+                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem;\n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem;\n+                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem;\n }\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n-    fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, false, strs, opt_vec::Empty, ~[])\n+    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n+        self.path_all(span, false, strs, opt_vec::Empty, Vec::new())\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n-        self.path(span, ~[id])\n+        self.path(span, vec!(id))\n     }\n-    fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, true, strs, opt_vec::Empty, ~[])\n+    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n+        self.path_all(span, true, strs, opt_vec::Empty, Vec::new())\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n-                mut idents: ~[ast::Ident],\n+                mut idents: Vec<ast::Ident> ,\n                 lifetimes: OptVec<ast::Lifetime>,\n-                types: ~[P<ast::Ty>])\n+                types: Vec<P<ast::Ty>> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: ~[ast::PathSegment] = idents.move_iter()\n+        let mut segments: Vec<ast::PathSegment> = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n@@ -335,13 +337,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty_path(\n             self.path_all(DUMMY_SP,\n                           true,\n-                          ~[\n+                          vec!(\n                               self.ident_of(\"std\"),\n                               self.ident_of(\"option\"),\n                               self.ident_of(\"Option\")\n-                          ],\n+                          ),\n                           opt_vec::Empty,\n-                          ~[ ty ]), None)\n+                          vec!( ty )), None)\n     }\n \n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n@@ -379,15 +381,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_ident(DUMMY_SP, p.ident)))\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> Vec<P<ast::Ty>> {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(DUMMY_SP, ~[p.ident]), None)))\n+                self.path_global(DUMMY_SP, vec!(p.ident)), None)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n@@ -459,17 +461,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n     }\n \n-    fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@Expr>) -> P<ast::Block> {\n-        self.block_all(span, ~[], stmts, expr)\n+    fn block(&self, span: Span, stmts: Vec<@ast::Stmt> , expr: Option<@Expr>) -> P<ast::Block> {\n+        self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n     fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block> {\n-        self.block_all(expr.span, ~[], ~[], Some(expr))\n+        self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: ~[ast::ViewItem],\n-                 stmts: ~[@ast::Stmt],\n+                 view_items: Vec<ast::ViewItem> ,\n+                 stmts: Vec<@ast::Stmt> ,\n                  expr: Option<@ast::Expr>) -> P<ast::Block> {\n             P(ast::Block {\n                view_items: view_items,\n@@ -517,7 +519,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: @ast::Expr, ident: ast::Ident) -> @ast::Expr {\n-        self.expr(sp, ast::ExprField(expr, ident, ~[]))\n+        self.expr(sp, ast::ExprField(expr, ident, Vec::new()))\n     }\n     fn expr_addr_of(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n@@ -526,35 +528,35 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n     }\n \n-    fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_call(&self, span: Span, expr: @ast::Expr, args: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr(span, ast::ExprCall(expr, args))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n-    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n-                      args: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n+                      args: Vec<@ast::Expr> ) -> @ast::Expr {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::Expr,\n                         ident: ast::Ident,\n-                        mut args: ~[@ast::Expr]) -> @ast::Expr {\n+                        mut args: Vec<@ast::Expr> ) -> @ast::Expr {\n         args.unshift(expr);\n-        self.expr(span, ast::ExprMethodCall(ident, ~[], args))\n+        self.expr(span, ast::ExprMethodCall(ident, Vec::new(), args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))\n     }\n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field> ) -> @ast::Expr {\n         self.expr(span, ast::ExprStruct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr {\n+                         id: ast::Ident, fields: Vec<ast::Field> ) -> @ast::Expr {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n@@ -577,13 +579,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr {\n         self.expr(sp, ast::ExprVstore(expr, vst))\n     }\n-    fn expr_vec(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_vec(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr(sp, ast::ExprVec(exprs, ast::MutImmutable))\n     }\n-    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n-        self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreUniq)\n+    fn expr_vec_ng(&self, sp: Span) -> @ast::Expr {\n+        self.expr_call_global(sp,\n+                              vec!(self.ident_of(\"std\"),\n+                                   self.ident_of(\"vec_ng\"),\n+                                   self.ident_of(\"Vec\"),\n+                                   self.ident_of(\"new\")),\n+                              Vec::new())\n     }\n-    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::Expr]) -> @ast::Expr {\n+    fn expr_vec_slice(&self, sp: Span, exprs: Vec<@ast::Expr> ) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n     fn expr_str(&self, sp: Span, s: InternedString) -> @ast::Expr {\n@@ -600,38 +607,34 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n-        let some = ~[\n+        let some = vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n-            self.ident_of(\"Some\"),\n-        ];\n-        self.expr_call_global(sp, some, ~[expr])\n+            self.ident_of(\"Some\"));\n+        self.expr_call_global(sp, some, vec!(expr))\n     }\n \n     fn expr_none(&self, sp: Span) -> @ast::Expr {\n-        let none = self.path_global(sp, ~[\n+        let none = self.path_global(sp, vec!(\n             self.ident_of(\"std\"),\n             self.ident_of(\"option\"),\n-            self.ident_of(\"None\"),\n-        ]);\n+            self.ident_of(\"None\")));\n         self.expr_path(none)\n     }\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n-            ~[\n+            vec!(\n                 self.ident_of(\"std\"),\n                 self.ident_of(\"rt\"),\n-                self.ident_of(\"begin_unwind\"),\n-            ],\n-            ~[\n+                self.ident_of(\"begin_unwind\")),\n+            vec!(\n                 self.expr_str(span, msg),\n                 self.expr_str(span,\n                               token::intern_and_get_ident(loc.file.name)),\n-                self.expr_uint(span, loc.line),\n-            ])\n+                self.expr_uint(span, loc.line)))\n     }\n \n     fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n@@ -662,17 +665,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = ast::PatIdent(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::Pat]) -> @ast::Pat {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<@ast::Pat> ) -> @ast::Pat {\n         let pat = ast::PatEnum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: ~[ast::FieldPat]) -> @ast::Pat {\n+                  path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> @ast::Pat {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n \n-    fn arm(&self, _span: Span, pats: ~[@ast::Pat], expr: @ast::Expr) -> ast::Arm {\n+    fn arm(&self, _span: Span, pats: Vec<@ast::Pat> , expr: @ast::Expr) -> ast::Arm {\n         ast::Arm {\n             pats: pats,\n             guard: None,\n@@ -681,10 +684,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn arm_unreachable(&self, span: Span) -> ast::Arm {\n-        self.arm(span, ~[self.pat_wild(span)], self.expr_unreachable(span))\n+        self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: ~[ast::Arm]) -> @Expr {\n+    fn expr_match(&self, span: Span, arg: @ast::Expr, arms: Vec<ast::Arm> ) -> @Expr {\n         self.expr(span, ast::ExprMatch(arg, arms))\n     }\n \n@@ -698,24 +701,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr {\n+    fn lambda(&self, span: Span, ids: Vec<ast::Ident> , blk: P<ast::Block>) -> @ast::Expr {\n         let fn_decl = self.fn_decl(\n             ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n             self.ty_infer(span));\n \n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    fn lambda0(&self, _span: Span, blk: P<ast::Block>) -> @ast::Expr {\n-        let blk_e = self.expr(blk.span, ast::ExprBlock(blk));\n-        quote_expr!(self, || $blk_e )\n+    fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr {\n+        self.lambda(span, Vec::new(), blk)\n     }\n \n-    fn lambda1(&self, _span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr {\n-        let blk_e = self.expr(blk.span, ast::ExprBlock(blk));\n-        quote_expr!(self, |$ident| $blk_e )\n+    fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> @ast::Expr {\n+        self.lambda(span, vec!(ident), blk)\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], expr: @ast::Expr) -> @ast::Expr {\n+    fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident> , expr: @ast::Expr) -> @ast::Expr {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n     fn lambda_expr_0(&self, span: Span, expr: @ast::Expr) -> @ast::Expr {\n@@ -725,13 +726,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], stmts: ~[@ast::Stmt]) -> @ast::Expr {\n+    fn lambda_stmts(&self,\n+                    span: Span,\n+                    ids: Vec<ast::Ident>,\n+                    stmts: Vec<@ast::Stmt>)\n+                    -> @ast::Expr {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::Stmt]) -> @ast::Expr {\n+    fn lambda_stmts_0(&self, span: Span, stmts: Vec<@ast::Stmt> ) -> @ast::Expr {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::Stmt], ident: ast::Ident) -> @ast::Expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: Vec<@ast::Stmt> , ident: ast::Ident) -> @ast::Expr {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n@@ -745,7 +750,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     // FIXME unused self\n-    fn fn_decl(&self, inputs: ~[ast::Arg], output: P<ast::Ty>) -> P<ast::FnDecl> {\n+    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs: inputs,\n             output: output,\n@@ -755,7 +760,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item(&self, span: Span,\n-            name: Ident, attrs: ~[ast::Attribute], node: ast::Item_) -> @ast::Item {\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> @ast::Item {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         @ast::Item { ident: name,\n@@ -769,13 +774,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: ~[ast::Arg],\n+                    inputs: Vec<ast::Arg> ,\n                     output: P<ast::Ty>,\n                     generics: Generics,\n                     body: P<ast::Block>) -> @ast::Item {\n         self.item(span,\n                   name,\n-                  ~[],\n+                  Vec::new(),\n                   ast::ItemFn(self.fn_decl(inputs, output),\n                               ast::ImpureFn,\n                               AbiSet::Rust(),\n@@ -786,7 +791,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: ~[ast::Arg],\n+               inputs: Vec<ast::Arg> ,\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n               ) -> @ast::Item {\n@@ -799,15 +804,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             body)\n     }\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::Variant {\n+    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let args = tys.move_iter().map(|ty| {\n             ast::VariantArg { ty: ty, id: ast::DUMMY_NODE_ID }\n         }).collect();\n \n         respan(span,\n                ast::Variant_ {\n                    name: name,\n-                   attrs: ~[],\n+                   attrs: Vec::new(),\n                    kind: ast::TupleVariantKind(args),\n                    id: ast::DUMMY_NODE_ID,\n                    disr_expr: None,\n@@ -818,7 +823,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n                       generics: Generics) -> @ast::Item {\n-        self.item(span, name, ~[], ast::ItemEnum(enum_definition, generics))\n+        self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n@@ -839,13 +844,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n         struct_def: ast::StructDef, generics: Generics) -> @ast::Item {\n-        self.item(span, name, ~[], ast::ItemStruct(@struct_def, generics))\n+        self.item(span, name, Vec::new(), ast::ItemStruct(@struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, name: Ident,\n-                attrs: ~[ast::Attribute],\n-                vi: ~[ast::ViewItem],\n-                items: ~[@ast::Item]) -> @ast::Item {\n+                attrs: Vec<ast::Attribute> ,\n+                vi: Vec<ast::ViewItem> ,\n+                items: Vec<@ast::Item> ) -> @ast::Item {\n         self.item(\n             span,\n             name,\n@@ -859,7 +864,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> @ast::Item {\n-        self.item(span, name, ~[], ast::ItemTy(ty, generics))\n+        self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n     }\n \n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item {\n@@ -880,7 +885,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n-                 mis: ~[@ast::MetaItem])\n+                 mis: Vec<@ast::MetaItem> )\n                  -> @ast::MetaItem {\n         @respan(sp, ast::MetaList(name, mis))\n     }\n@@ -893,10 +898,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem {\n+                vis: ast::Visibility, vp: Vec<@ast::ViewPath> ) -> ast::ViewItem {\n         ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n-            attrs: ~[],\n+            attrs: Vec::new(),\n             vis: vis,\n             span: sp\n         }\n@@ -910,30 +915,32 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n                         ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      ~[@respan(sp,\n+                      vec!(@respan(sp,\n                                 ast::ViewPathSimple(ident,\n                                                     path,\n-                                                    ast::DUMMY_NODE_ID))])\n+                                                    ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::ViewItem {\n+                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem {\n         let imports = imports.map(|id| {\n             respan(sp, ast::PathListIdent_ { name: *id, id: ast::DUMMY_NODE_ID })\n         });\n \n         self.view_use(sp, vis,\n-                      ~[@respan(sp,\n+                      vec!(@respan(sp,\n                                 ast::ViewPathList(self.path(sp, path),\n-                                                  imports,\n-                                                  ast::DUMMY_NODE_ID))])\n+                                                  imports.iter()\n+                                                         .map(|x| *x)\n+                                                         .collect(),\n+                                                  ast::DUMMY_NODE_ID))))\n     }\n \n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem {\n+                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n         self.view_use(sp, vis,\n-                      ~[@respan(sp,\n-                                ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n+                      vec!(@respan(sp,\n+                                ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n     }\n }\n "}, {"sha": "6123fd4d3d4907d1ca516e2ce49886d268889f30", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -17,14 +17,15 @@ use ext::base;\n use ext::build::AstBuilder;\n \n use std::char;\n+use std::vec_ng::Vec;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         None => return MacResult::dummy_expr(sp),\n         Some(e) => e,\n     };\n-    let mut bytes = ~[];\n+    let mut bytes = Vec::new();\n \n     for expr in exprs.iter() {\n         match expr.node {"}, {"sha": "5d11a0d1e2ff23d8dbe2d843f1dd866bdd5b91f0", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -26,12 +26,16 @@ use parse::token::InternedString;\n use parse::token;\n use parse;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n-                                           tts.to_owned());\n+                                           tts.iter()\n+                                              .map(|x| (*x).clone())\n+                                              .collect());\n \n-    let mut cfgs = ~[];\n+    let mut cfgs = Vec::new();\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`\n     while p.token != token::EOF {\n         cfgs.push(p.parse_meta_item());\n@@ -42,7 +46,8 @@ pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::M\n     // test_cfg searches for meta items looking like `cfg(foo, ...)`\n     let in_cfg = &[cx.meta_list(sp, InternedString::new(\"cfg\"), cfgs)];\n \n-    let matches_cfg = attr::test_cfg(cx.cfg(), in_cfg.iter().map(|&x| x));\n+    let matches_cfg = attr::test_cfg(cx.cfg().as_slice(),\n+                                     in_cfg.iter().map(|&x| x));\n     let e = cx.expr_bool(sp, matches_cfg);\n     MRExpr(e)\n }"}, {"sha": "2552586939811515626d2bacec8c141ba35cf3a1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -48,13 +48,13 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             ast::Path {\n                  span: sp,\n                  global: false,\n-                 segments: ~[\n+                 segments: vec!(\n                     ast::PathSegment {\n                         identifier: res,\n                         lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     }\n-                ]\n+                )\n             }\n         ),\n         span: sp,"}, {"sha": "feda1694ff1936eb359928a3b801ea10d30e65ad", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,29 +14,31 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: @MetaItem,\n                              item: @Item,\n                              push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"clone\", \"Clone\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"clone\", \"Clone\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"clone\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |c, s, sub| cs_clone(\"Clone\", c, s, sub)\n             }\n-        ]\n+        )\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -49,24 +51,24 @@ pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n                                   push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"clone\", \"DeepClone\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"clone\", \"DeepClone\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"deep_clone\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n                 // cs_clone uses the ident passed to it, i.e. it will\n                 // call deep_clone (not clone) here.\n                 combine_substructure: |c, s, sub| cs_clone(\"DeepClone\", c, s, sub)\n             }\n-        ]\n+        )\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -80,7 +82,7 @@ fn cs_clone(\n     let ctor_ident;\n     let all_fields;\n     let subcall = |field: &FieldInfo|\n-        cx.expr_method_call(field.span, field.self_, clone_ident, ~[]);\n+        cx.expr_method_call(field.span, field.self_, clone_ident, Vec::new());\n \n     match *substr.fields {\n         Struct(ref af) => {\n@@ -99,7 +101,7 @@ fn cs_clone(\n                                                                  name))\n     }\n \n-    if all_fields.len() >= 1 && all_fields[0].name.is_none() {\n+    if all_fields.len() >= 1 && all_fields.get(0).name.is_none() {\n         // enum-like\n         let subcalls = all_fields.map(subcall);\n         cx.expr_call_ident(trait_span, ctor_ident, subcalls)"}, {"sha": "1e7199ccc9557ef7428138e9489853c0f58fa3f6", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,6 +14,8 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: @MetaItem,\n@@ -36,8 +38,8 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: true,\n                 combine_substructure: $f\n@@ -47,14 +49,14 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"Eq\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"Eq\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             md!(\"eq\", cs_eq),\n             md!(\"ne\", cs_ne)\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "66f459882397c929a1cf888f7ddbfc95e2359d3f", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -15,6 +15,8 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: @MetaItem,\n@@ -26,8 +28,8 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |cx, span, substr| cs_op($op, $equal, cx, span, substr)\n@@ -37,16 +39,16 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"Ord\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             md!(\"lt\", true, false),\n             md!(\"le\", true, true),\n             md!(\"gt\", false, false),\n             md!(\"ge\", false, true)\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "2b3c0b9ea69153b1e0f8f81300329608e329a200", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,6 +14,8 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: @MetaItem,\n@@ -26,22 +28,22 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"TotalEq\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"TotalEq\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"equals\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: true,\n                 combine_substructure: cs_equals\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "89a344bdb7b3c13d62d657dc95f1e215fc009663", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,7 +14,9 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n+\n use std::cmp::{Ordering, Equal, Less, Greater};\n+use std::vec_ng::Vec;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 span: Span,\n@@ -23,22 +25,22 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"cmp\", \"TotalOrd\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"cmp\", \"TotalOrd\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"cmp\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[borrowed_self()],\n-                ret_ty: Literal(Path::new(~[\"std\", \"cmp\", \"Ordering\"])),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: cs_cmp\n             }\n-        ]\n+        )\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -52,9 +54,9 @@ pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path\n         Greater => \"Greater\"\n     };\n     cx.path_global(span,\n-                   ~[cx.ident_of(\"std\"),\n+                   vec!(cx.ident_of(\"std\"),\n                      cx.ident_of(\"cmp\"),\n-                     cx.ident_of(cnst)])\n+                     cx.ident_of(cnst)))\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n@@ -99,7 +101,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n             let if_ = cx.expr_if(span,\n                                  cond,\n                                  old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, ~[assign], Some(if_)))\n+            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n         cx.expr_path(equals_path.clone()),\n         |cx, span, list, _| {"}, {"sha": "bc6d69c7ccabe8b4570b7391b9570fb39c414912", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,34 +21,35 @@ use ext::deriving::generic::*;\n use parse::token::InternedString;\n use parse::token;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n                                  item: @Item,\n                                  push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new_(~[\"serialize\", \"Decodable\"], None,\n-                         ~[~Literal(Path::new_local(\"__D\"))], true),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new_(vec!(\"serialize\", \"Decodable\"), None,\n+                         vec!(~Literal(Path::new_local(\"__D\"))), true),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n-            lifetimes: ~[],\n-            bounds: ~[(\"__D\", ~[Path::new(~[\"serialize\", \"Decoder\"])])],\n+            lifetimes: Vec::new(),\n+            bounds: vec!((\"__D\", vec!(Path::new(vec!(\"serialize\", \"Decoder\"))))),\n         },\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"decode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[Ptr(~Literal(Path::new_local(\"__D\")),\n-                            Borrowed(None, MutMutable))],\n+                args: vec!(Ptr(~Literal(Path::new_local(\"__D\")),\n+                            Borrowed(None, MutMutable))),\n                 ret_ty: Self,\n                 inline: false,\n                 const_nonmatching: true,\n                 combine_substructure: decodable_substructure,\n-            },\n-        ]\n+            })\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -57,13 +58,13 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n-    let recurse = ~[cx.ident_of(\"serialize\"),\n+    let recurse = vec!(cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n-                    cx.ident_of(\"decode\")];\n+                    cx.ident_of(\"decode\"));\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n-    let calldecode = cx.expr_call_global(trait_span, recurse, ~[blkdecoder]);\n+    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder));\n     let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n@@ -80,24 +81,24 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                               summary,\n                                               |cx, span, name, field| {\n                 cx.expr_method_call(span, blkdecoder, read_struct_field,\n-                                    ~[cx.expr_str(span, name),\n+                                    vec!(cx.expr_str(span, name),\n                                       cx.expr_uint(span, field),\n-                                      lambdadecode])\n+                                      lambdadecode))\n             });\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n-                                ~[\n+                                vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.expr_uint(trait_span, nfields),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n-            ])\n+            ))\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n \n-            let mut arms = ~[];\n-            let mut variants = ~[];\n+            let mut arms = Vec::new();\n+            let mut variants = Vec::new();\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n@@ -110,29 +111,29 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                    |cx, span, _, field| {\n                     let idx = cx.expr_uint(span, field);\n                     cx.expr_method_call(span, blkdecoder, rvariant_arg,\n-                                        ~[idx, lambdadecode])\n+                                        vec!(idx, lambdadecode))\n                 });\n \n                 arms.push(cx.arm(v_span,\n-                                 ~[cx.pat_lit(v_span, cx.expr_uint(v_span, i))],\n+                                 vec!(cx.pat_lit(v_span, cx.expr_uint(v_span, i))),\n                                  decoded));\n             }\n \n             arms.push(cx.arm_unreachable(trait_span));\n \n             let result = cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms);\n-            let lambda = cx.lambda_expr(trait_span, ~[blkarg, variant], result);\n+            let lambda = cx.lambda_expr(trait_span, vec!(blkarg, variant), result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n-                                             ~[variant_vec, lambda]);\n+                                             vec!(variant_vec, lambda));\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n-                                ~[\n+                                vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n-            ])\n+            ))\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };"}, {"sha": "8259459f57ab60305d8a17e322d2f5f1c4b61952", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,41 +14,42 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             item: @Item,\n                             push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"default\", \"Default\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"default\", \"Default\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"default\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: default_substructure\n-            },\n-        ]\n+            })\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n-    let default_ident = ~[\n+    let default_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),\n         cx.ident_of(\"Default\"),\n         cx.ident_of(\"default\")\n-    ];\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), ~[]);\n+    );\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "091ff7b9c90bd360f1e4ddfdd9d5bae934591ebe", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -89,34 +89,35 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use parse::token;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n                                  item: @Item,\n                                  push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new_(~[\"serialize\", \"Encodable\"], None,\n-                         ~[~Literal(Path::new_local(\"__E\"))], true),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new_(vec!(\"serialize\", \"Encodable\"), None,\n+                         vec!(~Literal(Path::new_local(\"__E\"))), true),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n-            lifetimes: ~[],\n-            bounds: ~[(\"__E\", ~[Path::new(~[\"serialize\", \"Encoder\"])])],\n+            lifetimes: Vec::new(),\n+            bounds: vec!((\"__E\", vec!(Path::new(vec!(\"serialize\", \"Encoder\"))))),\n         },\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[Ptr(~Literal(Path::new_local(\"__E\")),\n-                            Borrowed(None, MutMutable))],\n+                args: vec!(Ptr(~Literal(Path::new_local(\"__E\")),\n+                            Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 inline: false,\n                 const_nonmatching: true,\n                 combine_substructure: encodable_substructure,\n-            },\n-        ]\n+            })\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -133,7 +134,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     return match *substr.fields {\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n-            let mut stmts = ~[];\n+            let mut stmts = Vec::new();\n             for (i, &FieldInfo {\n                     name,\n                     self_,\n@@ -146,25 +147,25 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                         token::intern_and_get_ident(format!(\"_field{}\", i))\n                     }\n                 };\n-                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_struct_field,\n-                                               ~[cx.expr_str(span, name),\n+                                               vec!(cx.expr_str(span, name),\n                                                  cx.expr_uint(span, i),\n-                                                 lambda]);\n+                                                 lambda));\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             cx.expr_method_call(trait_span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n-                                ~[\n+                                vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 cx.expr_uint(trait_span, fields.len()),\n                 blk\n-            ])\n+            ))\n         }\n \n         EnumMatching(idx, variant, ref fields) => {\n@@ -175,34 +176,34 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n-            let mut stmts = ~[];\n+            let mut stmts = Vec::new();\n             for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_variant_arg,\n-                                               ~[cx.expr_uint(span, i),\n-                                                 lambda]);\n+                                               vec!(cx.expr_uint(span, i),\n+                                                 lambda));\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span, token::get_ident(variant.node.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n-                                           ~[name,\n+                                           vec!(name,\n                                              cx.expr_uint(trait_span, idx),\n                                              cx.expr_uint(trait_span, fields.len()),\n-                                             blk]);\n+                                             blk));\n             let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          ~[\n+                                          vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n                 blk\n-            ]);\n-            cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))\n+            ));\n+            cx.expr_block(cx.block(trait_span, vec!(me), Some(ret)))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in deriving(Encodable)\")"}, {"sha": "1dc474551cf7c03127c73dbdd8740fa6f2e8dd19", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 80, "deletions": 68, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -188,7 +188,8 @@ use opt_vec;\n use parse::token::InternedString;\n use parse::token;\n \n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n \n pub use self::ty::*;\n mod ty;\n@@ -197,20 +198,19 @@ pub struct TraitDef<'a> {\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n-    attributes: ~[ast::Attribute],\n+    attributes: Vec<ast::Attribute> ,\n \n     /// Path of the trait, including any type parameters\n     path: Path<'a>,\n \n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    additional_bounds: ~[Ty<'a>],\n+    additional_bounds: Vec<Ty<'a>> ,\n \n     /// Any extra lifetimes and/or bounds, e.g. `D: serialize::Decoder`\n     generics: LifetimeBounds<'a>,\n \n-    methods: ~[MethodDef<'a>]\n-}\n+    methods: Vec<MethodDef<'a>> }\n \n \n pub struct MethodDef<'a> {\n@@ -225,7 +225,7 @@ pub struct MethodDef<'a> {\n     explicit_self: Option<Option<PtrTy<'a>>>,\n \n     /// Arguments other than the self argument\n-    args: ~[Ty<'a>],\n+    args: Vec<Ty<'a>> ,\n \n     /// Return type\n     ret_ty: Ty<'a>,\n@@ -264,39 +264,38 @@ pub struct FieldInfo {\n     self_: @Expr,\n     /// The expressions corresponding to references to this field in\n     /// the other Self arguments.\n-    other: ~[@Expr]\n-}\n+    other: Vec<@Expr> }\n \n /// Fields for a static method\n pub enum StaticFields {\n     /// Tuple structs/enum variants like this\n-    Unnamed(~[Span]),\n+    Unnamed(Vec<Span> ),\n     /// Normal structs/struct variants.\n-    Named(~[(Ident, Span)])\n+    Named(Vec<(Ident, Span)> )\n }\n \n /// A summary of the possible sets of fields. See above for details\n /// and examples\n pub enum SubstructureFields<'a> {\n-    Struct(~[FieldInfo]),\n+    Struct(Vec<FieldInfo> ),\n     /**\n     Matching variants of the enum: variant index, ast::Variant,\n     fields: the field name is only non-`None` in the case of a struct\n     variant.\n     */\n-    EnumMatching(uint, &'a ast::Variant, ~[FieldInfo]),\n+    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo> ),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::Variant,\n     [field span, field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'a [(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])]),\n+    EnumNonMatching(&'a [(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::EnumDef, ~[(Ident, Span, StaticFields)])\n+    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)> )\n }\n \n \n@@ -316,7 +315,7 @@ representing each variant: (variant index, ast::Variant instance,\n pub type EnumNonMatchFunc<'a> =\n     'a |&mut ExtCtxt,\n            Span,\n-           &[(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])],\n+           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, @Expr)> )],\n            &[@Expr]|\n            -> @Expr;\n \n@@ -360,7 +359,7 @@ impl<'a> TraitDef<'a> {\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n                            generics: &Generics,\n-                           methods: ~[@ast::Method]) -> @ast::Item {\n+                           methods: Vec<@ast::Method> ) -> @ast::Item {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let mut trait_generics = self.generics.to_generics(cx, self.span,\n@@ -397,7 +396,7 @@ impl<'a> TraitDef<'a> {\n \n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n-            cx.path_all(self.span, false, ~[ type_ident ], self_lifetimes,\n+            cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n                         opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n@@ -412,7 +411,7 @@ impl<'a> TraitDef<'a> {\n         cx.item(\n             self.span,\n             ident,\n-            vec::append(~[doc_attr], self.attributes),\n+            vec_ng::append(vec!(doc_attr), self.attributes.as_slice()),\n             ast::ItemImpl(trait_generics, opt_trait_ref,\n                           self_type, methods.map(|x| *x)))\n     }\n@@ -433,13 +432,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     struct_def,\n                     type_ident,\n-                    self_args, nonself_args)\n+                    self_args.as_slice(),\n+                    nonself_args.as_slice())\n             } else {\n                 method_def.expand_struct_method_body(cx,\n                                                      self,\n                                                      struct_def,\n                                                      type_ident,\n-                                                     self_args, nonself_args)\n+                                                     self_args.as_slice(),\n+                                                     nonself_args.as_slice())\n             };\n \n             method_def.create_method(cx, self,\n@@ -467,13 +468,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     enum_def,\n                     type_ident,\n-                    self_args, nonself_args)\n+                    self_args.as_slice(),\n+                    nonself_args.as_slice())\n             } else {\n                 method_def.expand_enum_method_body(cx,\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n-                                                   self_args, nonself_args)\n+                                                   self_args.as_slice(),\n+                                                   nonself_args.as_slice())\n             };\n \n             method_def.create_method(cx, self,\n@@ -524,11 +527,11 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n+        -> (ast::ExplicitSelf, Vec<@Expr> , Vec<@Expr> , Vec<(Ident, P<ast::Ty>)> ) {\n \n-        let mut self_args = ~[];\n-        let mut nonself_args = ~[];\n-        let mut arg_tys = ~[];\n+        let mut self_args = Vec::new();\n+        let mut nonself_args = Vec::new();\n+        let mut arg_tys = Vec::new();\n         let mut nonstatic = false;\n \n         let ast_explicit_self = match self.explicit_self {\n@@ -575,7 +578,7 @@ impl<'a> MethodDef<'a> {\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::ExplicitSelf,\n-                     arg_types: ~[(Ident, P<ast::Ty>)],\n+                     arg_types: Vec<(Ident, P<ast::Ty>)> ,\n                      body: @Expr) -> @ast::Method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n@@ -598,16 +601,16 @@ impl<'a> MethodDef<'a> {\n         let body_block = cx.block_expr(body);\n \n         let attrs = if self.inline {\n-            ~[\n+            vec!(\n                 cx\n                       .attribute(trait_.span,\n                                  cx\n                                        .meta_word(trait_.span,\n                                                   InternedString::new(\n                                                       \"inline\")))\n-            ]\n+            )\n         } else {\n-            ~[]\n+            Vec::new()\n         };\n \n         // Create the method.\n@@ -655,9 +658,9 @@ impl<'a> MethodDef<'a> {\n                                  nonself_args: &[@Expr])\n         -> @Expr {\n \n-        let mut raw_fields = ~[]; // ~[[fields of self],\n+        let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n-        let mut patterns = ~[];\n+        let mut patterns = Vec::new();\n         for i in range(0u, self_args.len()) {\n             let (pat, ident_expr) = trait_.create_struct_pattern(cx, type_ident, struct_def,\n                                                                  format!(\"__self_{}\", i),\n@@ -668,14 +671,15 @@ impl<'a> MethodDef<'a> {\n \n         // transpose raw_fields\n         let fields = if raw_fields.len() > 0 {\n-            raw_fields[0].iter()\n-                         .enumerate()\n-                         .map(|(i, &(span, opt_id, field))| {\n-                let other_fields = raw_fields.tail().map(|l| {\n-                    match &l[i] {\n+            raw_fields.get(0)\n+                      .iter()\n+                      .enumerate()\n+                      .map(|(i, &(span, opt_id, field))| {\n+                let other_fields = raw_fields.tail().iter().map(|l| {\n+                    match l.get(i) {\n                         &(_, _, ex) => ex\n                     }\n-                });\n+                }).collect();\n                 FieldInfo {\n                     span: span,\n                     name: opt_id,\n@@ -703,7 +707,7 @@ impl<'a> MethodDef<'a> {\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n             body = cx.expr_match(trait_.span, arg_expr,\n-                                     ~[ cx.arm(trait_.span, ~[pat], body) ])\n+                                     vec!( cx.arm(trait_.span, vec!(pat), body) ))\n         }\n         body\n     }\n@@ -759,7 +763,7 @@ impl<'a> MethodDef<'a> {\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n                                -> @Expr {\n-        let mut matches = ~[];\n+        let mut matches = Vec::new();\n         self.build_enum_match(cx, trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n                               None, &mut matches, 0)\n@@ -795,8 +799,8 @@ impl<'a> MethodDef<'a> {\n                         self_args: &[@Expr],\n                         nonself_args: &[@Expr],\n                         matching: Option<uint>,\n-                        matches_so_far: &mut ~[(uint, P<ast::Variant>,\n-                                              ~[(Span, Option<Ident>, @Expr)])],\n+                        matches_so_far: &mut Vec<(uint, P<ast::Variant>,\n+                                              Vec<(Span, Option<Ident>, @Expr)> )> ,\n                         match_count: uint) -> @Expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n@@ -822,17 +826,17 @@ impl<'a> MethodDef<'a> {\n                 Some(variant_index) => {\n                     // `ref` inside let matches is buggy. Causes havoc wih rusc.\n                     // let (variant_index, ref self_vec) = matches_so_far[0];\n-                    let (variant, self_vec) = match matches_so_far[0] {\n-                        (_, v, ref s) => (v, s)\n+                    let (variant, self_vec) = match matches_so_far.get(0) {\n+                        &(_, v, ref s) => (v, s)\n                     };\n \n-                    let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+                    let mut enum_matching_fields = Vec::from_elem(self_vec.len(), Vec::new());\n \n                     for triple in matches_so_far.tail().iter() {\n                         match triple {\n                             &(_, _, ref other_fields) => {\n                                 for (i, &(_, _, e)) in other_fields.iter().enumerate() {\n-                                    enum_matching_fields[i].push(e);\n+                                    enum_matching_fields.get_mut(i).push(e);\n                                 }\n                             }\n                         }\n@@ -851,7 +855,7 @@ impl<'a> MethodDef<'a> {\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n                 None => {\n-                    substructure = EnumNonMatching(*matches_so_far);\n+                    substructure = EnumNonMatching(matches_so_far.as_slice());\n                 }\n             }\n             self.call_substructure_method(cx, trait_, type_ident,\n@@ -865,7 +869,7 @@ impl<'a> MethodDef<'a> {\n                 format!(\"__arg_{}\", match_count)\n             };\n \n-            let mut arms = ~[];\n+            let mut arms = Vec::new();\n \n             // the code for nonmatching variants only matters when\n             // we've seen at least one other variant already\n@@ -879,7 +883,7 @@ impl<'a> MethodDef<'a> {\n                 };\n \n                 // matching-variant match\n-                let variant = enum_def.variants[index];\n+                let variant = *enum_def.variants.get(index);\n                 let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n                                                                            variant,\n                                                                            current_match_str,\n@@ -895,7 +899,7 @@ impl<'a> MethodDef<'a> {\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop().unwrap();\n-                arms.push(cx.arm(trait_.span, ~[ pattern ], arm_expr));\n+                arms.push(cx.arm(trait_.span, vec!( pattern ), arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n@@ -904,7 +908,7 @@ impl<'a> MethodDef<'a> {\n                                                                   e);\n                     let wild_arm = cx.arm(\n                         trait_.span,\n-                        ~[ cx.pat_wild(trait_.span) ],\n+                        vec!( cx.pat_wild(trait_.span) ),\n                         wild_expr);\n                     arms.push(wild_arm);\n                 }\n@@ -933,7 +937,7 @@ impl<'a> MethodDef<'a> {\n                                                          match_count + 1);\n                     matches_so_far.pop().unwrap();\n \n-                    let arm = cx.arm(trait_.span, ~[ pattern ], arm_expr);\n+                    let arm = cx.arm(trait_.span, vec!( pattern ), arm_expr);\n                     arms.push(arm);\n                 }\n             }\n@@ -997,8 +1001,8 @@ impl<'a> TraitDef<'a> {\n     fn summarise_struct(&self,\n                         cx: &mut ExtCtxt,\n                         struct_def: &StructDef) -> StaticFields {\n-        let mut named_idents = ~[];\n-        let mut just_spans = ~[];\n+        let mut named_idents = Vec::new();\n+        let mut just_spans = Vec::new();\n         for field in struct_def.fields.iter(){\n             let sp = self.set_expn_info(cx, field.span);\n             match field.node.kind {\n@@ -1020,9 +1024,9 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: ~[ast::Path],\n+                          field_paths: Vec<ast::Path> ,\n                           mutbl: ast::Mutability)\n-                          -> ~[@ast::Pat] {\n+                          -> Vec<@ast::Pat> {\n         field_paths.map(|path| {\n             cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n@@ -1035,18 +1039,18 @@ impl<'a> TraitDef<'a> {\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n+                             -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n                     self.span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n-                ~[]);\n+                Vec::new());\n         }\n \n-        let matching_path = cx.path(self.span, ~[ struct_ident ]);\n+        let matching_path = cx.path(self.span, vec!( struct_ident ));\n \n-        let mut paths = ~[];\n-        let mut ident_expr = ~[];\n+        let mut paths = Vec::new();\n+        let mut ident_expr = Vec::new();\n         let mut struct_type = Unknown;\n \n         for (i, struct_field) in struct_def.fields.iter().enumerate() {\n@@ -1096,20 +1100,20 @@ impl<'a> TraitDef<'a> {\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n+        -> (@ast::Pat, Vec<(Span, Option<Ident>, @Expr)> ) {\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n                 if variant_args.is_empty() {\n                     return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n                                                           ast::BindByValue(ast::MutImmutable)),\n-                            ~[]);\n+                            Vec::new());\n                 }\n \n                 let matching_path = cx.path_ident(variant.span, variant_ident);\n \n-                let mut paths = ~[];\n-                let mut ident_expr = ~[];\n+                let mut paths = Vec::new();\n+                let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n                     let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n@@ -1151,11 +1155,19 @@ pub fn cs_fold(use_foldl: bool,\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n                 all_fields.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_, field.other)\n+                    f(cx,\n+                      field.span,\n+                      old,\n+                      field.self_,\n+                      field.other.as_slice())\n                 })\n             } else {\n                 all_fields.rev_iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_, field.other)\n+                    f(cx,\n+                      field.span,\n+                      old,\n+                      field.self_,\n+                      field.other.as_slice())\n                 })\n             }\n         },\n@@ -1179,7 +1191,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, ~[@Expr]| -> @Expr,\n+pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<@Expr> | -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,"}, {"sha": "1d6cfab120d2de2087a1ef8909518950fd924b31", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,6 +14,8 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n@@ -22,23 +24,23 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n \n     let hash_trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"hash\", \"Hash\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"hash\", \"Hash\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"hash\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[Ptr(~Literal(Path::new(~[\"std\", \"hash\", \"sip\", \"SipState\"])),\n-                            Borrowed(None, MutMutable))],\n+                args: vec!(Ptr(~Literal(Path::new(vec!(\"std\", \"hash\", \"sip\", \"SipState\"))),\n+                            Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: hash_substructure\n             }\n-        ]\n+        )\n     };\n \n     hash_trait_def.expand(cx, mitem, item, push);\n@@ -51,10 +53,10 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n     };\n     let hash_ident = substr.method_ident;\n     let call_hash = |span, thing_expr| {\n-        let expr = cx.expr_method_call(span, thing_expr, hash_ident, ~[state_expr]);\n+        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr));\n         cx.stmt_expr(expr)\n     };\n-    let mut stmts = ~[];\n+    let mut stmts = Vec::new();\n \n     let fields = match *substr.fields {\n         Struct(ref fs) => fs,"}, {"sha": "ecd042eb172ef251fefb239e1dcf60a0c031e6eb", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -16,28 +16,29 @@ use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use parse::token::InternedString;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n                                       mitem: @MetaItem,\n                                       item: @Item,\n                                       push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"num\", \"FromPrimitive\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"from_i64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[\n-                    Literal(Path::new(~[\"i64\"])),\n-                ],\n-                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                args: vec!(\n+                    Literal(Path::new(vec!(\"i64\")))),\n+                ret_ty: Literal(Path::new_(vec!(\"std\", \"option\", \"Option\"),\n                                            None,\n-                                           ~[~Self],\n+                                           vec!(~Self),\n                                            true)),\n                 // liable to cause code-bloat\n                 inline: true,\n@@ -48,19 +49,17 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 name: \"from_u64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[\n-                    Literal(Path::new(~[\"u64\"])),\n-                ],\n-                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                args: vec!(\n+                    Literal(Path::new(vec!(\"u64\")))),\n+                ret_ty: Literal(Path::new_(vec!(\"std\", \"option\", \"Option\"),\n                                            None,\n-                                           ~[~Self],\n+                                           vec!(~Self),\n                                            true)),\n                 // liable to cause code-bloat\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |c, s, sub| cs_from(\"u64\", c, s, sub),\n-            },\n-        ]\n+            })\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n@@ -84,7 +83,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n                 return cx.expr_fail(trait_span, InternedString::new(\"\"));\n             }\n \n-            let mut arms = ~[];\n+            let mut arms = Vec::new();\n \n             for variant in enum_def.variants.iter() {\n                 match variant.node.kind {\n@@ -109,7 +108,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n                         // arm for `_ if $guard => $body`\n                         let arm = ast::Arm {\n-                            pats: ~[cx.pat_wild(span)],\n+                            pats: vec!(cx.pat_wild(span)),\n                             guard: Some(guard),\n                             body: cx.block_expr(body),\n                         };\n@@ -128,7 +127,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n             // arm for `_ => None`\n             let arm = ast::Arm {\n-                pats: ~[cx.pat_wild(trait_span)],\n+                pats: vec!(cx.pat_wild(trait_span)),\n                 guard: None,\n                 body: cx.block_expr(cx.expr_none(trait_span)),\n             };"}, {"sha": "da9679eb65578a1aef250e66b5d9970f9f65be38", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -16,55 +16,57 @@ use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n use opt_vec;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             item: @Item,\n                             push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"rand\", \"Rand\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"rand\", \"Rand\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"rand\",\n                 generics: LifetimeBounds {\n-                    lifetimes: ~[],\n-                    bounds: ~[(\"R\",\n-                               ~[ Path::new(~[\"std\", \"rand\", \"Rng\"]) ])]\n+                    lifetimes: Vec::new(),\n+                    bounds: vec!((\"R\",\n+                               vec!( Path::new(vec!(\"std\", \"rand\", \"Rng\")) )))\n                 },\n                 explicit_self: None,\n-                args: ~[\n+                args: vec!(\n                     Ptr(~Literal(Path::new_local(\"R\")),\n                         Borrowed(None, ast::MutMutable))\n-                ],\n+                ),\n                 ret_ty: Self,\n                 inline: false,\n                 const_nonmatching: false,\n                 combine_substructure: rand_substructure\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n-        [rng] => ~[ rng ],\n+        [rng] => vec!( rng ),\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n     };\n-    let rand_ident = ~[\n+    let rand_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"rand\"),\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n-    ];\n+    );\n     let rand_call = |cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n-                            ~[ rng[0] ])\n+                            vec!( *rng.get(0) ))\n     };\n \n     return match *substr.fields {\n@@ -84,13 +86,13 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                         true,\n                                         rand_ident.clone(),\n                                         opt_vec::Empty,\n-                                        ~[]);\n+                                        Vec::new());\n             let rand_name = cx.expr_path(rand_name);\n \n             // ::std::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(trait_span,\n                                        rand_name,\n-                                       ~[ rng[0] ]);\n+                                       vec!( *rng.get(0) ));\n \n             // need to specify the uint-ness of the random number\n             let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n@@ -113,15 +115,15 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                 let pat = cx.pat_lit(v_span, i_expr);\n \n                 let thing = rand_thing(cx, v_span, ident, summary, |cx, sp| rand_call(cx, sp));\n-                cx.arm(v_span, ~[ pat ], thing)\n-            }).collect::<~[ast::Arm]>();\n+                cx.arm(v_span, vec!( pat ), thing)\n+            }).collect::<Vec<ast::Arm> >();\n \n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(trait_span));\n \n             let match_expr = cx.expr_match(trait_span, rand_variant, arms);\n \n-            let block = cx.block(trait_span, ~[ let_statement ], Some(match_expr));\n+            let block = cx.block(trait_span, vec!( let_statement ), Some(match_expr));\n             cx.expr_block(block)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")"}, {"sha": "51399d8efabe97c2a0df4c73a713a32cce7b4f4c", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -19,34 +19,35 @@ use ext::deriving::generic::*;\n use parse::token;\n \n use collections::HashMap;\n+use std::vec_ng::Vec;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             item: @Item,\n                             push: |@Item|) {\n     // &mut ::std::fmt::Formatter\n-    let fmtr = Ptr(~Literal(Path::new(~[\"std\", \"fmt\", \"Formatter\"])),\n+    let fmtr = Ptr(~Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"fmt\", \"Show\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"fmt\", \"Show\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"fmt\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[fmtr],\n-                ret_ty: Literal(Path::new(~[\"std\", \"fmt\", \"Result\"])),\n+                args: vec!(fmtr),\n+                ret_ty: Literal(Path::new(vec!(\"std\", \"fmt\", \"Result\"))),\n                 inline: false,\n                 const_nonmatching: false,\n                 combine_substructure: show_substructure\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n@@ -70,7 +71,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     let mut format_string = token::get_ident(name).get().to_owned();\n     // the internal fields we're actually formatting\n-    let mut exprs = ~[];\n+    let mut exprs = Vec::new();\n \n     // Getting harder... making the format string:\n     match *substr.fields {\n@@ -79,7 +80,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         EnumMatching(_, _, ref fields) if fields.len() == 0 => {}\n \n         Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n-            if fields[0].name.is_none() {\n+            if fields.get(0).name.is_none() {\n                 // tuple struct/\"normal\" variant\n \n                 format_string.push_str(\"(\");\n@@ -124,17 +125,17 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let formatter = substr.nonself_args[0];\n     let buf = cx.expr_field_access(span, formatter, cx.ident_of(\"buf\"));\n \n-    let std_write = ~[cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\")];\n+    let std_write = vec!(cx.ident_of(\"std\"), cx.ident_of(\"fmt\"), cx.ident_of(\"write\"));\n     let args = cx.ident_of(\"__args\");\n-    let write_call = cx.expr_call_global(span, std_write, ~[buf, cx.expr_ident(span, args)]);\n-    let format_closure = cx.lambda_expr(span, ~[args], write_call);\n+    let write_call = cx.expr_call_global(span, std_write, vec!(buf, cx.expr_ident(span, args)));\n+    let format_closure = cx.lambda_expr(span, vec!(args), write_call);\n \n     let s = token::intern_and_get_ident(format_string);\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!\n     format::expand_preparsed_format_args(cx, span,\n                                          format_closure,\n-                                         format_string, exprs, ~[],\n+                                         format_string, exprs, Vec::new(),\n                                          HashMap::new())\n }"}, {"sha": "b88cd117911c70896d08bbb2e1f9fc8ab858d52a", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,6 +21,8 @@ use codemap::{Span,respan};\n use opt_vec;\n use opt_vec::OptVec;\n \n+use std::vec_ng::Vec;\n+\n /// The types of pointers\n pub enum PtrTy<'a> {\n     Send, // ~\n@@ -30,22 +32,22 @@ pub enum PtrTy<'a> {\n /// A path, e.g. `::std::option::Option::<int>` (global). Has support\n /// for type parameters and a lifetime.\n pub struct Path<'a> {\n-    path: ~[&'a str],\n+    path: Vec<&'a str> ,\n     lifetime: Option<&'a str>,\n-    params: ~[~Ty<'a>],\n+    params: Vec<~Ty<'a>> ,\n     global: bool\n }\n \n impl<'a> Path<'a> {\n-    pub fn new<'r>(path: ~[&'r str]) -> Path<'r> {\n-        Path::new_(path, None, ~[], true)\n+    pub fn new<'r>(path: Vec<&'r str> ) -> Path<'r> {\n+        Path::new_(path, None, Vec::new(), true)\n     }\n     pub fn new_local<'r>(path: &'r str) -> Path<'r> {\n-        Path::new_(~[ path ], None, ~[], false)\n+        Path::new_(vec!( path ), None, Vec::new(), false)\n     }\n-    pub fn new_<'r>(path: ~[&'r str],\n+    pub fn new_<'r>(path: Vec<&'r str> ,\n                     lifetime: Option<&'r str>,\n-                    params: ~[~Ty<'r>],\n+                    params: Vec<~Ty<'r>> ,\n                     global: bool)\n                     -> Path<'r> {\n         Path {\n@@ -87,7 +89,7 @@ pub enum Ty<'a> {\n     // parameter, and things like `int`\n     Literal(Path<'a>),\n     // includes nil\n-    Tuple(~[Ty<'a>])\n+    Tuple(Vec<Ty<'a>> )\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n@@ -106,7 +108,7 @@ pub fn borrowed_self<'r>() -> Ty<'r> {\n }\n \n pub fn nil_ty() -> Ty<'static> {\n-    Tuple(~[])\n+    Tuple(Vec::new())\n }\n \n fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n@@ -172,7 +174,7 @@ impl<'a> Ty<'a> {\n                 });\n                 let lifetimes = self_generics.lifetimes.clone();\n \n-                cx.path_all(span, false, ~[self_ty], lifetimes,\n+                cx.path_all(span, false, vec!(self_ty), lifetimes,\n                             opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {\n@@ -188,14 +190,14 @@ impl<'a> Ty<'a> {\n fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, bounds: &[Path],\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n-        bounds.map(|b| {\n+        bounds.iter().map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n-        }));\n+        }).collect());\n     cx.typaram(cx.ident_of(name), bounds, None)\n }\n \n-fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n+fn mk_generics(lifetimes: Vec<ast::Lifetime> ,  ty_params: Vec<ast::TyParam> ) -> Generics {\n     Generics {\n         lifetimes: opt_vec::from(lifetimes),\n         ty_params: opt_vec::from(ty_params)\n@@ -204,14 +206,14 @@ fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Gene\n \n /// Lifetimes and bounds on type parameters\n pub struct LifetimeBounds<'a> {\n-    lifetimes: ~[&'a str],\n-    bounds: ~[(&'a str, ~[Path<'a>])]\n+    lifetimes: Vec<&'a str>,\n+    bounds: Vec<(&'a str, Vec<Path<'a>>)>,\n }\n \n impl<'a> LifetimeBounds<'a> {\n     pub fn empty() -> LifetimeBounds<'static> {\n         LifetimeBounds {\n-            lifetimes: ~[], bounds: ~[]\n+            lifetimes: Vec::new(), bounds: Vec::new()\n         }\n     }\n     pub fn to_generics(&self,\n@@ -226,7 +228,12 @@ impl<'a> LifetimeBounds<'a> {\n         let ty_params = self.bounds.map(|t| {\n             match t {\n                 &(ref name, ref bounds) => {\n-                    mk_ty_param(cx, span, *name, *bounds, self_ty, self_generics)\n+                    mk_ty_param(cx,\n+                                span,\n+                                *name,\n+                                bounds.as_slice(),\n+                                self_ty,\n+                                self_generics)\n                 }\n             }\n         });"}, {"sha": "98c0ec9d07238502ce8c6b7d31b7a75eaf785564", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -14,23 +14,25 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n+use std::vec_ng::Vec;\n+\n pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             item: @Item,\n                             push: |@Item|) {\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n-        additional_bounds: ~[],\n+        attributes: Vec::new(),\n+        path: Path::new(vec!(\"std\", \"num\", \"Zero\")),\n+        additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n-        methods: ~[\n+        methods: vec!(\n             MethodDef {\n                 name: \"zero\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: ~[],\n+                args: Vec::new(),\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n@@ -40,8 +42,8 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 name: \"is_zero\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                args: Vec::new(),\n+                ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n                 combine_substructure: |cx, span, substr| {\n@@ -52,19 +54,19 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                            cx, span, substr)\n                 }\n             }\n-        ]\n+        )\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n-    let zero_ident = ~[\n+    let zero_ident = vec!(\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),\n         cx.ident_of(\"Zero\"),\n         cx.ident_of(\"zero\")\n-    ];\n-    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), ~[]);\n+    );\n+    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "b0b5fa26015ccd6f5ee124ba75e44e93d7f500fb", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -19,6 +19,7 @@ use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n+use opt_vec;\n use parse::token;\n \n use std::os;\n@@ -31,8 +32,30 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     };\n \n     let e = match os::getenv(var) {\n-      None => quote_expr!(cx, ::std::option::None::<&'static str>),\n-      Some(s) => quote_expr!(cx, ::std::option::Some($s))\n+      None => {\n+          cx.expr_path(cx.path_all(sp,\n+                                   true,\n+                                   vec!(cx.ident_of(\"std\"),\n+                                        cx.ident_of(\"option\"),\n+                                        cx.ident_of(\"None\")),\n+                                   opt_vec::Empty,\n+                                   vec!(cx.ty_rptr(sp,\n+                                                   cx.ty_ident(sp,\n+                                                        cx.ident_of(\"str\")),\n+                                                   Some(cx.lifetime(sp,\n+                                                        cx.ident_of(\n+                                                            \"static\").name)),\n+                                                   ast::MutImmutable))))\n+      }\n+      Some(s) => {\n+          cx.expr_call_global(sp,\n+                              vec!(cx.ident_of(\"std\"),\n+                                   cx.ident_of(\"option\"),\n+                                   cx.ident_of(\"Some\")),\n+                              vec!(cx.expr_str(sp,\n+                                               token::intern_and_get_ident(\n+                                          s))))\n+      }\n     };\n     MRExpr(e)\n }\n@@ -48,7 +71,9 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Some(exprs) => exprs\n     };\n \n-    let var = match expr_to_str(cx, exprs[0], \"expected string literal\") {\n+    let var = match expr_to_str(cx,\n+                                *exprs.get(0),\n+                                \"expected string literal\") {\n         None => return MacResult::dummy_expr(sp),\n         Some((v, _style)) => v\n     };\n@@ -59,7 +84,7 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                 var))\n         }\n         2 => {\n-            match expr_to_str(cx, exprs[1], \"expected string literal\") {\n+            match expr_to_str(cx, *exprs.get(1), \"expected string literal\") {\n                 None => return MacResult::dummy_expr(sp),\n                 Some((s, _style)) => s\n             }"}, {"sha": "b162e17f53de1d55223129a031208b7cd2b43469", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -31,6 +31,7 @@ use util::small_vector::SmallVector;\n use std::cast;\n use std::unstable::dynamic_lib::DynamicLibrary;\n use std::os;\n+use std::vec_ng::Vec;\n \n pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     match e.node {\n@@ -53,7 +54,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                         // let compilation continue\n                         return MacResult::raw_dummy_expr(e.span);\n                     }\n-                    let extname = pth.segments[0].identifier;\n+                    let extname = pth.segments.get(0).identifier;\n                     let extnamestr = token::get_ident(extname);\n                     // leaving explicit deref here to highlight unbox op:\n                     let marked_after = match fld.extsbox.find(&extname.name) {\n@@ -77,7 +78,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             });\n                             let fm = fresh_mark();\n                             // mark before:\n-                            let marked_before = mark_tts(*tts,fm);\n+                            let marked_before = mark_tts(tts.as_slice(), fm);\n \n                             // The span that we pass to the expanders we want to\n                             // be the root of the call stack. That's the most\n@@ -87,7 +88,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n \n                             let expanded = match expandfun.expand(fld.cx,\n                                                    mac_span.call_site,\n-                                                   marked_before) {\n+                                                   marked_before.as_slice()) {\n                                 MRExpr(e) => e,\n                                 MRAny(any_macro) => any_macro.make_expr(),\n                                 _ => {\n@@ -169,21 +170,24 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             let none_arm = {\n                 let break_expr = fld.cx.expr(span, ast::ExprBreak(opt_ident));\n                 let none_pat = fld.cx.pat_ident(span, none_ident);\n-                fld.cx.arm(span, ~[none_pat], break_expr)\n+                fld.cx.arm(span, vec!(none_pat), break_expr)\n             };\n \n             // `Some(<src_pat>) => <src_loop_block>`\n             let some_arm =\n                 fld.cx.arm(span,\n-                           ~[fld.cx.pat_enum(span, some_path, ~[src_pat])],\n+                           vec!(fld.cx.pat_enum(span, some_path, vec!(src_pat))),\n                            fld.cx.expr_block(src_loop_block));\n \n             // `match i.next() { ... }`\n             let match_expr = {\n                 let next_call_expr =\n-                    fld.cx.expr_method_call(span, fld.cx.expr_path(local_path), next_ident, ~[]);\n+                    fld.cx.expr_method_call(span,\n+                                            fld.cx.expr_path(local_path),\n+                                            next_ident,\n+                                            Vec::new());\n \n-                fld.cx.expr_match(span, next_call_expr, ~[none_arm, some_arm])\n+                fld.cx.expr_match(span, next_call_expr, vec!(none_arm, some_arm))\n             };\n \n             // ['ident:] loop { ... }\n@@ -196,8 +200,8 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n             // `match &mut <src_expr> { i => loop { ... } }`\n             let discrim = fld.cx.expr_mut_addr_of(span, src_expr);\n             let i_pattern = fld.cx.pat_ident(span, local_ident);\n-            let arm = fld.cx.arm(span, ~[i_pattern], loop_expr);\n-            fld.cx.expr_match(span, discrim, ~[arm])\n+            let arm = fld.cx.arm(span, vec!(i_pattern), loop_expr);\n+            fld.cx.expr_match(span, discrim, vec!(arm))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n@@ -221,7 +225,7 @@ fn rename_loop_label(opt_ident: Option<Ident>,\n             let new_label = fresh_name(&label);\n             let rename = (label, new_label);\n             fld.extsbox.info().pending_renames.push(rename);\n-            let mut pending_renames = ~[rename];\n+            let mut pending_renames = vec!(rename);\n             let mut rename_fld = renames_to_fold(&mut pending_renames);\n             (Some(rename_fld.fold_ident(label)),\n              rename_fld.fold_block(loop_block))\n@@ -276,7 +280,7 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n         ast::ItemMac(..) => expand_item_mac(it, fld),\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             fld.cx.mod_push(it.ident);\n-            let macro_escape = contains_macro_escape(it.attrs);\n+            let macro_escape = contains_macro_escape(it.attrs.as_slice());\n             let result = with_exts_frame!(fld.extsbox,\n                                           macro_escape,\n                                           noop_fold_item(it, fld));\n@@ -309,7 +313,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = pth.segments[0].identifier;\n+    let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n     let expanded = match fld.extsbox.find(&extname.name) {\n@@ -339,8 +343,8 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 }\n             });\n             // mark before expansion:\n-            let marked_before = mark_tts(tts,fm);\n-            expander.expand(fld.cx, it.span, marked_before)\n+            let marked_before = mark_tts(tts.as_slice(), fm);\n+            expander.expand(fld.cx, it.span, marked_before.as_slice())\n         }\n         Some(&IdentTT(ref expander, span)) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n@@ -358,7 +362,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 }\n             });\n             // mark before expansion:\n-            let marked_tts = mark_tts(tts,fm);\n+            let marked_tts = mark_tts(tts.as_slice(), fm);\n             expander.expand(fld.cx, it.span, it.ident, marked_tts)\n         }\n         _ => {\n@@ -391,7 +395,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n             fld.extsbox.insert(intern(name), ext);\n-            if attr::contains_name(it.attrs, \"macro_export\") {\n+            if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n                 SmallVector::one(it)\n             } else {\n                 SmallVector::zero()\n@@ -504,7 +508,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n         fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n         return SmallVector::zero();\n     }\n-    let extname = pth.segments[0].identifier;\n+    let extname = pth.segments.get(0).identifier;\n     let extnamestr = token::get_ident(extname);\n     let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n@@ -523,15 +527,15 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n             });\n             let fm = fresh_mark();\n             // mark before expansion:\n-            let marked_tts = mark_tts(tts,fm);\n+            let marked_tts = mark_tts(tts.as_slice(), fm);\n \n             // See the comment in expand_expr for why we want the original span,\n             // not the current mac.span.\n             let mac_span = original_span(fld.cx);\n \n             let expanded = match expandfun.expand(fld.cx,\n                                                   mac_span.call_site,\n-                                                  marked_tts) {\n+                                                  marked_tts.as_slice()) {\n                 MRExpr(e) => {\n                     @codemap::Spanned {\n                         node: StmtExpr(e, ast::DUMMY_NODE_ID),\n@@ -607,10 +611,10 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     // oh dear heaven... this is going to include the enum\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n-                    let mut name_finder = new_name_finder(~[]);\n+                    let mut name_finder = new_name_finder(Vec::new());\n                     name_finder.visit_pat(expanded_pat,());\n                     // generate fresh names, push them to a new pending list\n-                    let mut new_pending_renames = ~[];\n+                    let mut new_pending_renames = Vec::new();\n                     for ident in name_finder.ident_accumulator.iter() {\n                         let new_name = fresh_name(ident);\n                         new_pending_renames.push((*ident,new_name));\n@@ -657,7 +661,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n // array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewNameFinderContext {\n-    ident_accumulator: ~[ast::Ident],\n+    ident_accumulator: Vec<ast::Ident> ,\n }\n \n impl Visitor<()> for NewNameFinderContext {\n@@ -676,7 +680,8 @@ impl Visitor<()> for NewNameFinderContext {\n                         span: _,\n                         segments: ref segments\n                     } if segments.len() == 1 => {\n-                        self.ident_accumulator.push(segments[0].identifier)\n+                        self.ident_accumulator.push(segments.get(0)\n+                                                            .identifier)\n                     }\n                     // I believe these must be enums...\n                     _ => ()\n@@ -700,7 +705,7 @@ impl Visitor<()> for NewNameFinderContext {\n // return a visitor that extracts the pat_ident paths\n // from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n-pub fn new_name_finder(idents: ~[ast::Ident]) -> NewNameFinderContext {\n+pub fn new_name_finder(idents: Vec<ast::Ident> ) -> NewNameFinderContext {\n     NewNameFinderContext {\n         ident_accumulator: idents,\n     }\n@@ -843,7 +848,7 @@ impl Folder for Marker {\n         let macro = match m.node {\n             MacInvocTT(ref path, ref tts, ctxt) => {\n                 MacInvocTT(self.fold_path(path),\n-                           fold_tts(*tts, self),\n+                           fold_tts(tts.as_slice(), self),\n                            new_mark(self.mark, ctxt))\n             }\n         };\n@@ -860,7 +865,7 @@ fn new_mark_folder(m: Mrk) -> Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mrk) -> ~[TokenTree] {\n+fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n     fold_tts(tts, &mut new_mark_folder(m))\n }\n \n@@ -912,12 +917,14 @@ mod test {\n     use visit;\n     use visit::Visitor;\n \n+    use std::vec_ng::Vec;\n+\n     // a visitor that extracts the paths\n     // from a given thingy and puts them in a mutable\n     // array (passed in to the traversal)\n     #[deriving(Clone)]\n     struct NewPathExprFinderContext {\n-        path_accumulator: ~[ast::Path],\n+        path_accumulator: Vec<ast::Path> ,\n     }\n \n     impl Visitor<()> for NewPathExprFinderContext {\n@@ -941,7 +948,7 @@ mod test {\n     // return a visitor that extracts the paths\n     // from a given pattern and puts them in a mutable\n     // array (passed in to the traversal)\n-    pub fn new_path_finder(paths: ~[ast::Path]) -> NewPathExprFinderContext {\n+    pub fn new_path_finder(paths: Vec<ast::Path> ) -> NewPathExprFinderContext {\n         NewPathExprFinderContext {\n             path_accumulator: paths\n         }\n@@ -954,7 +961,7 @@ mod test {\n             fail!(\"lolwut\")\n         }\n \n-        fn get_exported_macros(&mut self, _: ast::CrateNum) -> ~[~str] {\n+        fn get_exported_macros(&mut self, _: ast::CrateNum) -> Vec<~str> {\n             fail!(\"lolwut\")\n         }\n \n@@ -975,7 +982,7 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            ~[],sess);\n+            Vec::new(),sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         expand_crate(sess,&mut loader,crate_ast);\n@@ -990,7 +997,7 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            ~[],sess);\n+            Vec::new(),sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         expand_crate(sess,&mut loader,crate_ast);\n@@ -1004,7 +1011,7 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            ~[], sess);\n+            Vec::new(), sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         expand_crate(sess, &mut loader, crate_ast);\n@@ -1014,10 +1021,10 @@ mod test {\n         let attr1 = make_dummy_attr (\"foo\");\n         let attr2 = make_dummy_attr (\"bar\");\n         let escape_attr = make_dummy_attr (\"macro_escape\");\n-        let attrs1 = ~[attr1, escape_attr, attr2];\n-        assert_eq!(contains_macro_escape (attrs1),true);\n-        let attrs2 = ~[attr1,attr2];\n-        assert_eq!(contains_macro_escape (attrs2),false);\n+        let attrs1 = vec!(attr1, escape_attr, attr2);\n+        assert_eq!(contains_macro_escape(attrs1.as_slice()),true);\n+        let attrs2 = vec!(attr1,attr2);\n+        assert_eq!(contains_macro_escape(attrs2.as_slice()),false);\n     }\n \n     // make a MetaWord outer attribute with the given name\n@@ -1082,48 +1089,30 @@ mod test {\n     // in principle, you might want to control this boolean on a per-varref basis,\n     // but that would make things even harder to understand, and might not be\n     // necessary for thorough testing.\n-    type RenamingTest = (&'static str, ~[~[uint]], bool);\n+    type RenamingTest = (&'static str, Vec<Vec<uint>>, bool);\n \n     #[test]\n     fn automatic_renaming () {\n-        let tests: ~[RenamingTest] =\n-            ~[// b & c should get new names throughout, in the expr too:\n+        let tests: Vec<RenamingTest> =\n+            vec!(// b & c should get new names throughout, in the expr too:\n                 (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n-                 ~[~[0,1],~[2]], false),\n+                 vec!(vec!(0,1),vec!(2)), false),\n                 // both x's should be renamed (how is this causing a bug?)\n                 (\"fn main () {let x: int = 13;x;}\",\n-                 ~[~[0]], false),\n+                 vec!(vec!(0)), false),\n                 // the use of b after the + should be renamed, the other one not:\n                 (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n-                 ~[~[1]], false),\n+                 vec!(vec!(1)), false),\n                 // the b before the plus should not be renamed (requires marks)\n                 (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n-                 ~[~[1]], false),\n+                 vec!(vec!(1)), false),\n                 // the marks going in and out of letty should cancel, allowing that $x to\n                 // capture the one following the semicolon.\n                 // this was an awesome test case, and caught a *lot* of bugs.\n                 (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n                   macro_rules! user(($x:ident) => ({letty!($x); $x}))\n                   fn main() -> int {user!(z)}\",\n-                 ~[~[0]], false),\n-                // no longer a fixme #8062: this test exposes a *potential* bug; our system does\n-                // not behave exactly like MTWT, but a conversation with Matthew Flatt\n-                // suggests that this can only occur in the presence of local-expand, which\n-                // we have no plans to support.\n-                // (\"fn main() {let hrcoo = 19; macro_rules! getx(()=>(hrcoo)); getx!();}\",\n-                // ~[~[0]], true)\n-                // FIXME #6994: the next string exposes the bug referred to in issue 6994, so I'm\n-                // commenting it out.\n-                // the z flows into and out of two macros (g & f) along one path, and one\n-                // (just g) along the other, so the result of the whole thing should\n-                // be \"let z_123 = 3; z_123\"\n-                //\"macro_rules! g (($x:ident) =>\n-                //   ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n-                //   fn a(){g!(z)}\"\n-                // create a really evil test case where a $x appears inside a binding of $x\n-                // but *shouldnt* bind because it was inserted by a different macro....\n-                // can't write this test case until we have macro-generating macros.\n-            ];\n+                 vec!(vec!(0)), false));\n         for (idx,s) in tests.iter().enumerate() {\n             run_renaming_test(s,idx);\n         }\n@@ -1137,20 +1126,20 @@ mod test {\n         };\n         let cr = expand_crate_str(teststr.to_owned());\n         // find the bindings:\n-        let mut name_finder = new_name_finder(~[]);\n+        let mut name_finder = new_name_finder(Vec::new());\n         visit::walk_crate(&mut name_finder,&cr,());\n         let bindings = name_finder.ident_accumulator;\n \n         // find the varrefs:\n-        let mut path_finder = new_path_finder(~[]);\n+        let mut path_finder = new_path_finder(Vec::new());\n         visit::walk_crate(&mut path_finder,&cr,());\n         let varrefs = path_finder.path_accumulator;\n \n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n-            let binding_name = mtwt_resolve(bindings[binding_idx]);\n-            let binding_marks = mtwt_marksof(bindings[binding_idx].ctxt,invalid_name);\n+            let binding_name = mtwt_resolve(*bindings.get(binding_idx));\n+            let binding_marks = mtwt_marksof(bindings.get(binding_idx).ctxt,invalid_name);\n             // shouldmatch can't name varrefs that don't exist:\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n@@ -1159,13 +1148,18 @@ mod test {\n                     // it should be a path of length 1, and it should\n                     // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt_resolve(varref.segments[0].identifier);\n-                    let varref_marks = mtwt_marksof(varref.segments[0].identifier.ctxt,\n+                    let varref_name = mtwt_resolve(varref.segments\n+                                                         .get(0)\n+                                                         .identifier);\n+                    let varref_marks = mtwt_marksof(varref.segments\n+                                                          .get(0)\n+                                                          .identifier\n+                                                          .ctxt,\n                                                     invalid_name);\n                     if !(varref_name==binding_name) {\n                         println!(\"uh oh, should match but doesn't:\");\n                         println!(\"varref: {:?}\",varref);\n-                        println!(\"binding: {:?}\", bindings[binding_idx]);\n+                        println!(\"binding: {:?}\", *bindings.get(binding_idx));\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert_eq!(varref_name,binding_name);\n@@ -1176,7 +1170,8 @@ mod test {\n                     }\n                 } else {\n                     let fail = (varref.segments.len() == 1)\n-                        && (mtwt_resolve(varref.segments[0].identifier) == binding_name);\n+                        && (mtwt_resolve(varref.segments.get(0).identifier) ==\n+                                         binding_name);\n                     // temp debugging:\n                     if fail {\n                         println!(\"failure on test {}\",test_idx);\n@@ -1185,11 +1180,13 @@ mod test {\n                         println!(\"uh oh, matches but shouldn't:\");\n                         println!(\"varref: {:?}\",varref);\n                         // good lord, you can't make a path with 0 segments, can you?\n-                        let string = token::get_ident(varref.segments[0].identifier);\n+                        let string = token::get_ident(varref.segments\n+                                                            .get(0)\n+                                                            .identifier);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n-                                 varref.segments[0].identifier.name,\n+                                 varref.segments.get(0).identifier.name,\n                                  string.get());\n-                        println!(\"binding: {:?}\", bindings[binding_idx]);\n+                        println!(\"binding: {:?}\", *bindings.get(binding_idx));\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert!(!fail);\n@@ -1205,40 +1202,41 @@ foo_module!()\n \";\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n-        let mut name_finder = new_name_finder(~[]);\n+        let mut name_finder = new_name_finder(Vec::new());\n         visit::walk_crate(&mut name_finder, &cr, ());\n         let bindings = name_finder.ident_accumulator;\n \n-        let cxbinds: ~[&ast::Ident] =\n+        let cxbinds: Vec<&ast::Ident> =\n             bindings.iter().filter(|b| {\n                 let ident = token::get_ident(**b);\n                 let string = ident.get();\n                 \"xx\" == string\n             }).collect();\n-        let cxbinds: &[&ast::Ident] = cxbinds;\n+        let cxbinds: &[&ast::Ident] = cxbinds.as_slice();\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => fail!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt_resolve(*cxbind);\n         // find all the xx varrefs:\n-        let mut path_finder = new_path_finder(~[]);\n+        let mut path_finder = new_path_finder(Vec::new());\n         visit::walk_crate(&mut path_finder, &cr, ());\n         let varrefs = path_finder.path_accumulator;\n \n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == token::get_ident(p.segments[0].identifier).get()\n+            && \"xx\" == token::get_ident(p.segments.get(0).identifier).get()\n         }).enumerate() {\n-            if mtwt_resolve(v.segments[0].identifier) != resolved_binding {\n+            if mtwt_resolve(v.segments.get(0).identifier) !=\n+                    resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n                 println!(\"this is xx varref \\\\# {:?}\",idx);\n                 println!(\"binding: {:?}\",cxbind);\n                 println!(\"resolves to: {:?}\",resolved_binding);\n-                println!(\"varref: {:?}\",v.segments[0].identifier);\n+                println!(\"varref: {:?}\",v.segments.get(0).identifier);\n                 println!(\"resolves to: {:?}\",\n-                         mtwt_resolve(v.segments[0].identifier));\n+                         mtwt_resolve(v.segments.get(0).identifier));\n                 let table = get_sctable();\n                 println!(\"SC table:\");\n \n@@ -1249,17 +1247,18 @@ foo_module!()\n                     }\n                 }\n             }\n-            assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);\n+            assert_eq!(mtwt_resolve(v.segments.get(0).identifier),\n+                       resolved_binding);\n         };\n     }\n \n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n-        let mut pat_idents = new_name_finder(~[]);\n+        let mut pat_idents = new_name_finder(Vec::new());\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(pat_idents.ident_accumulator,\n-                   strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n+                   strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n \n }"}, {"sha": "7752d88596820bd5d66dee1d3da13217d9e0e6d8", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 92, "deletions": 100, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -22,6 +22,7 @@ use rsparse = parse;\n use std::fmt::parse;\n use collections::{HashMap, HashSet};\n use std::vec;\n+use std::vec_ng::Vec;\n \n #[deriving(Eq)]\n enum ArgumentType {\n@@ -41,20 +42,20 @@ struct Context<'a> {\n \n     // Parsed argument expressions and the types that we've found so far for\n     // them.\n-    args: ~[@ast::Expr],\n-    arg_types: ~[Option<ArgumentType>],\n+    args: Vec<@ast::Expr>,\n+    arg_types: Vec<Option<ArgumentType>>,\n     // Parsed named expressions and the types that we've found for them so far.\n     // Note that we keep a side-array of the ordering of the named arguments\n     // found to be sure that we can translate them in the same order that they\n     // were declared in.\n     names: HashMap<~str, @ast::Expr>,\n     name_types: HashMap<~str, ArgumentType>,\n-    name_ordering: ~[~str],\n+    name_ordering: Vec<~str>,\n \n     // Collection of the compiled `rt::Piece` structures\n-    pieces: ~[@ast::Expr],\n+    pieces: Vec<@ast::Expr> ,\n     name_positions: HashMap<~str, uint>,\n-    method_statics: ~[@ast::Item],\n+    method_statics: Vec<@ast::Item> ,\n \n     // Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n@@ -70,16 +71,17 @@ struct Context<'a> {\n ///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> (@ast::Expr, Option<(@ast::Expr, ~[@ast::Expr], ~[~str],\n-                            HashMap<~str, @ast::Expr>)>)\n-{\n-    let mut args = ~[];\n+    -> (@ast::Expr, Option<(@ast::Expr, Vec<@ast::Expr>, Vec<~str>,\n+                            HashMap<~str, @ast::Expr>)>) {\n+    let mut args = Vec::new();\n     let mut names = HashMap::<~str, @ast::Expr>::new();\n-    let mut order = ~[];\n+    let mut order = Vec::new();\n \n     let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n                                              ecx.cfg(),\n-                                             tts.to_owned());\n+                                             tts.iter()\n+                                                .map(|x| (*x).clone())\n+                                                .collect());\n     // Parse the leading function expression (maybe a block, maybe a path)\n     let extra = p.parse_expr();\n     if !p.eat(&token::COMMA) {\n@@ -276,14 +278,14 @@ impl<'a> Context<'a> {\n                     return;\n                 }\n                 {\n-                    let arg_type = match self.arg_types[arg] {\n-                        None => None,\n-                        Some(ref x) => Some(x)\n+                    let arg_type = match self.arg_types.get(arg) {\n+                        &None => None,\n+                        &Some(ref x) => Some(x)\n                     };\n-                    self.verify_same(self.args[arg].span, &ty, arg_type);\n+                    self.verify_same(self.args.get(arg).span, &ty, arg_type);\n                 }\n-                if self.arg_types[arg].is_none() {\n-                    self.arg_types[arg] = Some(ty);\n+                if self.arg_types.get(arg).is_none() {\n+                    *self.arg_types.get_mut(arg) = Some(ty);\n                 }\n             }\n \n@@ -357,7 +359,7 @@ impl<'a> Context<'a> {\n \n     /// These attributes are applied to all statics that this syntax extension\n     /// will generate.\n-    fn static_attrs(&self) -> ~[ast::Attribute] {\n+    fn static_attrs(&self) -> Vec<ast::Attribute> {\n         // Flag statics as `address_insignificant` so LLVM can merge duplicate\n         // globals as much as possible (which we're generating a whole lot of).\n         let unnamed = self.ecx\n@@ -371,53 +373,53 @@ impl<'a> Context<'a> {\n                                            InternedString::new(\"dead_code\"));\n         let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n                                                  InternedString::new(\"allow\"),\n-                                                 ~[dead_code]);\n+                                                 vec!(dead_code));\n         let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n-        return ~[unnamed, allow_dead_code];\n+        return vec!(unnamed, allow_dead_code);\n     }\n \n-    fn parsepath(&self, s: &str) -> ~[ast::Ident] {\n-        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+    fn parsepath(&self, s: &str) -> Vec<ast::Ident> {\n+        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s))\n     }\n \n-    fn rtpath(&self, s: &str) -> ~[ast::Ident] {\n-        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n+    fn rtpath(&self, s: &str) -> Vec<ast::Ident> {\n+        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s))\n     }\n \n-    fn ctpath(&self, s: &str) -> ~[ast::Ident] {\n-        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+    fn ctpath(&self, s: &str) -> Vec<ast::Ident> {\n+        vec!(self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s))\n     }\n \n     fn none(&self) -> @ast::Expr {\n-        let none = self.ecx.path_global(self.fmtsp, ~[\n+        let none = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n-                self.ecx.ident_of(\"None\")]);\n+                self.ecx.ident_of(\"None\")));\n         self.ecx.expr_path(none)\n     }\n \n     fn some(&self, e: @ast::Expr) -> @ast::Expr {\n-        let p = self.ecx.path_global(self.fmtsp, ~[\n+        let p = self.ecx.path_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n-                self.ecx.ident_of(\"Some\")]);\n+                self.ecx.ident_of(\"Some\")));\n         let p = self.ecx.expr_path(p);\n-        self.ecx.expr_call(self.fmtsp, p, ~[e])\n+        self.ecx.expr_call(self.fmtsp, p, vec!(e))\n     }\n \n     fn trans_count(&self, c: parse::Count) -> @ast::Expr {\n         let sp = self.fmtsp;\n         match c {\n             parse::CountIs(i) => {\n                 self.ecx.expr_call_global(sp, self.rtpath(\"CountIs\"),\n-                                          ~[self.ecx.expr_uint(sp, i)])\n+                                          vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountIsParam(i) => {\n                 self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n-                                          ~[self.ecx.expr_uint(sp, i)])\n+                                          vec!(self.ecx.expr_uint(sp, i)))\n             }\n             parse::CountImplied => {\n                 let path = self.ecx.path_global(sp, self.rtpath(\"CountImplied\"));\n@@ -434,7 +436,7 @@ impl<'a> Context<'a> {\n                 };\n                 let i = i + self.args.len();\n                 self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n-                                          ~[self.ecx.expr_uint(sp, i)])\n+                                          vec!(self.ecx.expr_uint(sp, i)))\n             }\n         }\n     }\n@@ -450,21 +452,19 @@ impl<'a> Context<'a> {\n                         }).collect();\n                         let s = token::intern_and_get_ident(arm.selector);\n                         let selector = self.ecx.expr_str(sp, s);\n-                        self.ecx.expr_struct(sp, p, ~[\n+                        self.ecx.expr_struct(sp, p, vec!(\n                                 self.ecx.field_imm(sp,\n                                                    self.ecx.ident_of(\"selector\"),\n                                                    selector),\n                                 self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                                   self.ecx.expr_vec_slice(sp, result)),\n-                                ])\n+                                                   self.ecx.expr_vec_slice(sp, result))))\n                     }).collect();\n                 let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Select\"), ~[\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Select\"), vec!(\n                         self.ecx.expr_vec_slice(sp, arms),\n-                        self.ecx.expr_vec_slice(sp, default),\n-                        ])\n+                        self.ecx.expr_vec_slice(sp, default)))\n             }\n             parse::Plural(offset, ref arms, ref default) => {\n                 let offset = match offset {\n@@ -487,23 +487,21 @@ impl<'a> Context<'a> {\n                             }\n                         };\n                         let selector = self.ecx.expr_call_global(sp,\n-                                                                 lr, ~[selarg]);\n-                        self.ecx.expr_struct(sp, p, ~[\n+                                                                 lr, vec!(selarg));\n+                        self.ecx.expr_struct(sp, p, vec!(\n                                 self.ecx.field_imm(sp,\n                                                    self.ecx.ident_of(\"selector\"),\n                                                    selector),\n                                 self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                                   self.ecx.expr_vec_slice(sp, result)),\n-                                ])\n+                                                   self.ecx.expr_vec_slice(sp, result))))\n                     }).collect();\n                 let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Plural\"), ~[\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Plural\"), vec!(\n                         offset,\n                         self.ecx.expr_vec_slice(sp, arms),\n-                        self.ecx.expr_vec_slice(sp, default),\n-                        ])\n+                        self.ecx.expr_vec_slice(sp, default)))\n             }\n         };\n         let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\").name);\n@@ -512,7 +510,7 @@ impl<'a> Context<'a> {\n                 true,\n                 self.rtpath(\"Method\"),\n                 opt_vec::with(life),\n-                ~[]\n+                Vec::new()\n                     ), None);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n         let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n@@ -530,13 +528,13 @@ impl<'a> Context<'a> {\n                 let s = token::intern_and_get_ident(s);\n                 self.ecx.expr_call_global(sp,\n                                           self.rtpath(\"String\"),\n-                                          ~[\n+                                          vec!(\n                     self.ecx.expr_str(sp, s)\n-                ])\n+                ))\n             }\n             parse::CurrentArgument => {\n                 let nil = self.ecx.expr_lit(sp, ast::LitNil);\n-                self.ecx.expr_call_global(sp, self.rtpath(\"CurrentArgument\"), ~[nil])\n+                self.ecx.expr_call_global(sp, self.rtpath(\"CurrentArgument\"), vec!(nil))\n             }\n             parse::Argument(ref arg) => {\n                 // Translate the position\n@@ -549,7 +547,7 @@ impl<'a> Context<'a> {\n                     }\n                     parse::ArgumentIs(i) => {\n                         self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n-                                                  ~[self.ecx.expr_uint(sp, i)])\n+                                                  vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n@@ -560,7 +558,7 @@ impl<'a> Context<'a> {\n                         };\n                         let i = i + self.args.len();\n                         self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n-                                                  ~[self.ecx.expr_uint(sp, i)])\n+                                                  vec!(self.ecx.expr_uint(sp, i)))\n                     }\n                 };\n \n@@ -583,13 +581,12 @@ impl<'a> Context<'a> {\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, self.rtpath(\"FormatSpec\"));\n-                let fmt = self.ecx.expr_struct(sp, path, ~[\n+                let fmt = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n-                ]);\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n \n                 // Translate the method (if any)\n                 let method = match arg.method {\n@@ -600,24 +597,23 @@ impl<'a> Context<'a> {\n                     }\n                 };\n                 let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n-                let s = self.ecx.expr_struct(sp, path, ~[\n+                let s = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method),\n-                ]);\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), ~[s])\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method)));\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s))\n             }\n         }\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n     fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n-        let mut lets = ~[];\n-        let mut locals = ~[];\n+        let mut lets = Vec::new();\n+        let mut locals = Vec::new();\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n-        let mut pats = ~[];\n-        let mut heads = ~[];\n+        let mut pats = Vec::new();\n+        let mut heads = Vec::new();\n \n         // First, declare all of our methods that are statics\n         for &method in self.method_statics.iter() {\n@@ -631,15 +627,14 @@ impl<'a> Context<'a> {\n         let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n         let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n                 self.fmtsp,\n-                true, ~[\n+                true, vec!(\n                     self.ecx.ident_of(\"std\"),\n                     self.ecx.ident_of(\"fmt\"),\n                     self.ecx.ident_of(\"rt\"),\n-                    self.ecx.ident_of(\"Piece\"),\n-                ],\n+                    self.ecx.ident_of(\"Piece\")),\n                 opt_vec::with(\n                     self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\").name)),\n-                ~[]\n+                Vec::new()\n             ), None);\n         let ty = ast::TyFixedLengthVec(\n             piece_ty,\n@@ -661,7 +656,9 @@ impl<'a> Context<'a> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, &e) in self.args.iter().enumerate() {\n-            if self.arg_types[i].is_none() { continue } // error already generated\n+            if self.arg_types.get(i).is_none() {\n+                continue // error already generated\n+            }\n \n             let name = self.ecx.ident_of(format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(e.span, name));\n@@ -696,18 +693,17 @@ impl<'a> Context<'a> {\n         // Now create the fmt::Arguments struct with all our locals we created.\n         let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n         let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n-        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+        let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n                 self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(\"new\"),\n-            ], ~[fmt, args_slice]);\n+                self.ecx.ident_of(\"new\")), vec!(fmt, args_slice));\n \n         // We did all the work of making sure that the arguments\n         // structure is safe, so we can safely have an unsafe block.\n         let result = self.ecx.expr_block(P(ast::Block {\n-           view_items: ~[],\n-           stmts: ~[],\n+           view_items: Vec::new(),\n+           stmts: Vec::new(),\n            expr: Some(result),\n            id: ast::DUMMY_NODE_ID,\n            rules: ast::UnsafeBlock(ast::CompilerGenerated),\n@@ -716,8 +712,8 @@ impl<'a> Context<'a> {\n         let resname = self.ecx.ident_of(\"__args\");\n         lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n         let res = self.ecx.expr_ident(self.fmtsp, resname);\n-        let result = self.ecx.expr_call(extra.span, extra, ~[\n-                            self.ecx.expr_addr_of(extra.span, res)]);\n+        let result = self.ecx.expr_call(extra.span, extra, vec!(\n+                            self.ecx.expr_addr_of(extra.span, res)));\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n                                                       Some(result)));\n \n@@ -749,15 +745,15 @@ impl<'a> Context<'a> {\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat(self.fmtsp, ast::PatTup(pats));\n-        let arm = self.ecx.arm(self.fmtsp, ~[pat], body);\n+        let arm = self.ecx.arm(self.fmtsp, vec!(pat), body);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n-        self.ecx.expr_match(self.fmtsp, head, ~[arm])\n+        self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n     }\n \n     fn format_arg(&self, sp: Span, argno: Position, arg: @ast::Expr)\n                   -> @ast::Expr {\n         let ty = match argno {\n-            Exact(ref i) => self.arg_types[*i].get_ref(),\n+            Exact(ref i) => self.arg_types.get(*i).get_ref(),\n             Named(ref s) => self.name_types.get(s)\n         };\n \n@@ -787,31 +783,27 @@ impl<'a> Context<'a> {\n                 }\n             }\n             String => {\n-                return self.ecx.expr_call_global(sp, ~[\n+                return self.ecx.expr_call_global(sp, vec!(\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentstr\"),\n-                    ], ~[arg])\n+                        self.ecx.ident_of(\"argumentstr\")), vec!(arg))\n             }\n             Unsigned => {\n-                return self.ecx.expr_call_global(sp, ~[\n+                return self.ecx.expr_call_global(sp, vec!(\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argumentuint\"),\n-                    ], ~[arg])\n+                        self.ecx.ident_of(\"argumentuint\")), vec!(arg))\n             }\n         };\n \n-        let format_fn = self.ecx.path_global(sp, ~[\n+        let format_fn = self.ecx.path_global(sp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(fmt_fn),\n-            ]);\n-        self.ecx.expr_call_global(sp, ~[\n+                self.ecx.ident_of(fmt_fn)));\n+        self.ecx.expr_call_global(sp, vec!(\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"argument\"),\n-            ], ~[self.ecx.expr_path(format_fn), arg])\n+                self.ecx.ident_of(\"argument\")), vec!(self.ecx.expr_path(format_fn), arg))\n     }\n }\n \n@@ -832,10 +824,10 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n /// expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     extra: @ast::Expr,\n-                                    efmt: @ast::Expr, args: ~[@ast::Expr],\n-                                    name_ordering: ~[~str],\n+                                    efmt: @ast::Expr, args: Vec<@ast::Expr>,\n+                                    name_ordering: Vec<~str>,\n                                     names: HashMap<~str, @ast::Expr>) -> @ast::Expr {\n-    let arg_types = vec::from_fn(args.len(), |_| None);\n+    let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -846,8 +838,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        pieces: ~[],\n-        method_statics: ~[],\n+        pieces: Vec::new(),\n+        method_statics: Vec::new(),\n         fmtsp: sp,\n     };\n     cx.fmtsp = efmt.span;\n@@ -884,7 +876,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.is_none() {\n-            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n+            cx.ecx.span_err(cx.args.get(i).span, \"argument never used\");\n         }\n     }\n     for (name, e) in cx.names.iter() {"}, {"sha": "b94928238e9bb215540349e5f60d61bf75c40f6f", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -20,7 +20,8 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt,\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n-    println!(\"{}\", print::pprust::tt_to_str(&ast::TTDelim(@tt.to_owned())));\n+    println!(\"{}\", print::pprust::tt_to_str(&ast::TTDelim(\n+                @tt.iter().map(|x| (*x).clone()).collect())));\n \n     //trivial expression\n     MRExpr(@ast::Expr {"}, {"sha": "e96597d41594b94d423c674e5991f15b66806b23", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -17,6 +17,8 @@ use parse::token::*;\n use parse::token;\n use parse;\n \n+use std::vec_ng::Vec;\n+\n /**\n *\n * Quasiquoting works via token trees.\n@@ -35,17 +37,19 @@ pub mod rt {\n     use parse;\n     use print::pprust;\n \n+    use std::vec_ng::Vec;\n+\n     pub use ast::*;\n     pub use parse::token::*;\n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n     pub trait ToTokens {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[TokenTree];\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> ;\n     }\n \n-    impl ToTokens for ~[TokenTree] {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[TokenTree] {\n+    impl ToTokens for Vec<TokenTree> {\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             (*self).clone()\n         }\n     }\n@@ -201,7 +205,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens(\n         ($t:ty) => (\n             impl ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> ~[TokenTree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -211,7 +215,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens_self(\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> ~[TokenTree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -242,7 +246,7 @@ pub mod rt {\n         fn parse_item(&self, s: ~str) -> @ast::Item;\n         fn parse_expr(&self, s: ~str) -> @ast::Expr;\n         fn parse_stmt(&self, s: ~str) -> @ast::Stmt;\n-        fn parse_tts(&self, s: ~str) -> ~[ast::TokenTree];\n+        fn parse_tts(&self, s: ~str) -> Vec<ast::TokenTree> ;\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n@@ -266,7 +270,7 @@ pub mod rt {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_str(),\n                                               s,\n                                               self.cfg(),\n-                                              ~[],\n+                                              Vec::new(),\n                                               self.parse_sess())\n         }\n \n@@ -277,7 +281,7 @@ pub mod rt {\n                                               self.parse_sess())\n         }\n \n-        fn parse_tts(&self, s: ~str) -> ~[ast::TokenTree] {\n+        fn parse_tts(&self, s: ~str) -> Vec<ast::TokenTree> {\n             parse::parse_tts_from_source_str(\"<quote expansion>\".to_str(),\n                                              s,\n                                              self.cfg(),\n@@ -298,16 +302,16 @@ pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n pub fn expand_quote_expr(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr\", Vec::new(), tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n+    let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_item\",\n-                                    ~[e_attrs], tts);\n+                                    vec!(e_attrs), tts);\n     base::MRExpr(expanded)\n }\n \n@@ -316,7 +320,7 @@ pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         tts: &[ast::TokenTree]) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::LitBool(true));\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n-                                    ~[e_refutable], tts);\n+                                    vec!(e_refutable), tts);\n     base::MRExpr(expanded)\n }\n \n@@ -325,20 +329,20 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        tts: &[ast::TokenTree]) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n-                                     ~[e_param_colons], tts);\n+                                     vec!(e_param_colons), tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n-    let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n+    let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n-                                    ~[e_attrs], tts);\n+                                    vec!(e_attrs), tts);\n     base::MRExpr(expanded)\n }\n \n-fn ids_ext(strs: ~[~str]) -> ~[ast::Ident] {\n+fn ids_ext(strs: Vec<~str> ) -> Vec<ast::Ident> {\n     strs.map(|str| str_to_ident(*str))\n }\n \n@@ -352,7 +356,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n-                        ~[e_str])\n+                        vec!(e_str))\n }\n \n fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n@@ -377,18 +381,18 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n         BINOP(binop) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"BINOP\"),\n-                                      ~[mk_binop(cx, sp, binop)]);\n+                                      vec!(mk_binop(cx, sp, binop)));\n         }\n         BINOPEQ(binop) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"BINOPEQ\"),\n-                                      ~[mk_binop(cx, sp, binop)]);\n+                                      vec!(mk_binop(cx, sp, binop)));\n         }\n \n         LIT_CHAR(i) => {\n             let e_char = cx.expr_lit(sp, ast::LitChar(i));\n \n-            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), ~[e_char]);\n+            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), vec!(e_char));\n         }\n \n         LIT_INT(i, ity) => {\n@@ -405,7 +409,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_INT\"),\n-                                      ~[e_i64, e_ity]);\n+                                      vec!(e_i64, e_ity));\n         }\n \n         LIT_UINT(u, uty) => {\n@@ -422,15 +426,15 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_UINT\"),\n-                                      ~[e_u64, e_uty]);\n+                                      vec!(e_u64, e_uty));\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n             let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_INT_UNSUFFIXED\"),\n-                                      ~[e_i64]);\n+                                      vec!(e_i64));\n         }\n \n         LIT_FLOAT(fident, fty) => {\n@@ -444,39 +448,39 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_FLOAT\"),\n-                                      ~[e_fident, e_fty]);\n+                                      vec!(e_fident, e_fty));\n         }\n \n         LIT_STR(ident) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_STR\"),\n-                                      ~[mk_ident(cx, sp, ident)]);\n+                                      vec!(mk_ident(cx, sp, ident)));\n         }\n \n         LIT_STR_RAW(ident, n) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_STR_RAW\"),\n-                                      ~[mk_ident(cx, sp, ident),\n-                                        cx.expr_uint(sp, n)]);\n+                                      vec!(mk_ident(cx, sp, ident),\n+                                        cx.expr_uint(sp, n)));\n         }\n \n         IDENT(ident, b) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"IDENT\"),\n-                                      ~[mk_ident(cx, sp, ident),\n-                                        cx.expr_bool(sp, b)]);\n+                                      vec!(mk_ident(cx, sp, ident),\n+                                        cx.expr_bool(sp, b)));\n         }\n \n         LIFETIME(ident) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIFETIME\"),\n-                                      ~[mk_ident(cx, sp, ident)]);\n+                                      vec!(mk_ident(cx, sp, ident)));\n         }\n \n         DOC_COMMENT(ident) => {\n             return cx.expr_call_ident(sp,\n                                       id_ext(\"DOC_COMMENT\"),\n-                                      ~[mk_ident(cx, sp, ident)]);\n+                                      vec!(mk_ident(cx, sp, ident)));\n         }\n \n         INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),\n@@ -523,24 +527,24 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n }\n \n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> ~[@ast::Stmt] {\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<@ast::Stmt> {\n \n     match *tt {\n \n         ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n             let e_tok = cx.expr_call_ident(sp,\n                                            id_ext(\"TTTok\"),\n-                                           ~[e_sp, mk_token(cx, sp, tok)]);\n+                                           vec!(e_sp, mk_token(cx, sp, tok)));\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push\"),\n-                                    ~[e_tok]);\n-            ~[cx.stmt_expr(e_push)]\n+                                    vec!(e_tok));\n+            vec!(cx.stmt_expr(e_push))\n         }\n \n-        ast::TTDelim(ref tts) => mk_tts(cx, sp, **tts),\n+        ast::TTDelim(ref tts) => mk_tts(cx, sp, tts.as_slice()),\n         ast::TTSeq(..) => fail!(\"TTSeq in quote!\"),\n \n         ast::TTNonterminal(sp, ident) => {\n@@ -551,22 +555,22 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> ~[@ast::Stmt] {\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n                                     id_ext(\"to_tokens\"),\n-                                    ~[cx.expr_ident(sp, id_ext(\"ext_cx\"))]);\n+                                    vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n \n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push_all_move\"),\n-                                    ~[e_to_toks]);\n+                                    vec!(e_to_toks));\n \n-            ~[cx.stmt_expr(e_push)]\n+            vec!(cx.stmt_expr(e_push))\n         }\n     }\n }\n \n fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> ~[@ast::Stmt] {\n-    let mut ss = ~[];\n+    -> Vec<@ast::Stmt> {\n+    let mut ss = Vec::new();\n     for tt in tts.iter() {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n     }\n@@ -583,7 +587,9 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n-                                           tts.to_owned());\n+                                           tts.iter()\n+                                              .map(|x| (*x).clone())\n+                                              .collect());\n     p.quote_depth += 1u;\n \n     let cx_expr = p.parse_expr();\n@@ -623,20 +629,20 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let e_sp = cx.expr_method_call(sp,\n                                    cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                                    id_ext(\"call_site\"),\n-                                   ~[]);\n+                                   Vec::new());\n \n     let stmt_let_sp = cx.stmt_let(sp, false,\n                                   id_ext(\"_sp\"),\n                                   e_sp);\n \n-    let stmt_let_tt = cx.stmt_let(sp, true,\n-                                  id_ext(\"tt\"),\n-                                  cx.expr_vec_uniq(sp, ~[]));\n+    let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n+    let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n+    vector.push_all_move(mk_tts(cx, sp, tts.as_slice()));\n     let block = cx.expr_block(\n         cx.block_all(sp,\n-                     ~[],\n-                     ~[stmt_let_sp, stmt_let_tt] + mk_tts(cx, sp, tts),\n+                     Vec::new(),\n+                     vector,\n                      Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n \n     (cx_expr, block)\n@@ -646,36 +652,36 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: @ast::Expr,\n                   expr: @ast::Expr) -> @ast::Expr {\n-    let uses = ~[ cx.view_use_glob(sp, ast::Inherited,\n-                                   ids_ext(~[~\"syntax\",\n+    let uses = vec!( cx.view_use_glob(sp, ast::Inherited,\n+                                   ids_ext(vec!(~\"syntax\",\n                                              ~\"ext\",\n                                              ~\"quote\",\n-                                             ~\"rt\"])) ];\n+                                             ~\"rt\"))) );\n \n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr);\n \n-    cx.expr_block(cx.block_all(sp, uses, ~[stmt_let_ext_cx], Some(expr)))\n+    cx.expr_block(cx.block_all(sp, uses, vec!(stmt_let_ext_cx), Some(expr)))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n-                     arg_exprs: ~[@ast::Expr],\n+                     arg_exprs: Vec<@ast::Expr> ,\n                      tts: &[ast::TokenTree]) -> @ast::Expr {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"cfg\"), ~[]);\n+        id_ext(\"cfg\"), Vec::new());\n \n     let parse_sess_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"parse_sess\"), ~[]);\n+        id_ext(\"parse_sess\"), Vec::new());\n \n     let new_parser_call =\n         cx.expr_call(sp,\n                      cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     ~[parse_sess_call(), cfg_call(), tts_expr]);\n+                     vec!(parse_sess_call(), cfg_call(), tts_expr));\n \n     let expr = cx.expr_method_call(sp, new_parser_call, id_ext(parse_method),\n                                    arg_exprs);"}, {"sha": "4c18eb83afceec6e1cd162840ac1a9cda1dfbfac", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -15,15 +15,18 @@ use diagnostic;\n use visit;\n use visit::Visitor;\n \n+use std::vec_ng::Vec;\n+\n struct MacroRegistrarContext {\n-    registrars: ~[(ast::NodeId, Span)],\n+    registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n impl Visitor<()> for MacroRegistrarContext {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match item.node {\n             ast::ItemFn(..) => {\n-                if attr::contains_name(item.attrs, \"macro_registrar\") {\n+                if attr::contains_name(item.attrs.as_slice(),\n+                                       \"macro_registrar\") {\n                     self.registrars.push((item.id, item.span));\n                 }\n             }\n@@ -36,7 +39,7 @@ impl Visitor<()> for MacroRegistrarContext {\n \n pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n                             krate: &ast::Crate) -> Option<ast::DefId> {\n-    let mut ctx = MacroRegistrarContext { registrars: ~[] };\n+    let mut ctx = MacroRegistrarContext { registrars: Vec::new() };\n     visit::walk_crate(&mut ctx, krate, ());\n \n     match ctx.registrars.len() {"}, {"sha": "b31388f58eb9fdc653529d9d904706227afdea1e", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -142,6 +142,7 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             return MacResult::dummy_expr(sp);\n         }\n         Ok(bytes) => {\n+            let bytes = bytes.iter().map(|x| *x).collect();\n             base::MRExpr(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n         }\n     }"}, {"sha": "183cccde18e86c487b2fc39824ead710ca6fcea9", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -24,7 +24,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n-                               tt.to_owned());\n+                               tt.iter().map(|x| (*x).clone()).collect());\n     let mut rust_parser = Parser(sess, cfg.clone(), tt_rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {"}, {"sha": "c9d3150c2cd417b630bd6b45e0a3b07060b960db", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -22,7 +22,7 @@ use parse::token::{Token, EOF, Nonterminal};\n use parse::token;\n \n use collections::HashMap;\n-use std::vec;\n+use std::vec_ng::Vec;\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n only by calling out to the main rust parser for named nonterminals (which it\n@@ -99,11 +99,11 @@ nonempty body. */\n \n #[deriving(Clone)]\n pub struct MatcherPos {\n-    elts: ~[ast::Matcher], // maybe should be <'>? Need to understand regions.\n+    elts: Vec<ast::Matcher> , // maybe should be <'>? Need to understand regions.\n     sep: Option<Token>,\n     idx: uint,\n     up: Option<~MatcherPos>,\n-    matches: ~[~[@NamedMatch]],\n+    matches: Vec<Vec<@NamedMatch>>,\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n }\n@@ -112,12 +112,14 @@ pub fn count_names(ms: &[Matcher]) -> uint {\n     ms.iter().fold(0, |ct, m| {\n         ct + match m.node {\n             MatchTok(_) => 0u,\n-            MatchSeq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n+            MatchSeq(ref more_ms, _, _, _, _) => {\n+                count_names(more_ms.as_slice())\n+            }\n             MatchNonterminal(_, _, _) => 1u\n         }})\n }\n \n-pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n     for elt in ms.iter() {\n@@ -131,7 +133,7 @@ pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n             }\n         }\n     }\n-    let matches = vec::from_fn(count_names(ms), |_i| ~[]);\n+    let matches = Vec::from_fn(count_names(ms.as_slice()), |_i| Vec::new());\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n@@ -164,7 +166,7 @@ pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n // ast::Matcher it was derived from.\n \n pub enum NamedMatch {\n-    MatchedSeq(~[@NamedMatch], codemap::Span),\n+    MatchedSeq(Vec<@NamedMatch> , codemap::Span),\n     MatchedNonterminal(Nonterminal)\n }\n \n@@ -206,9 +208,9 @@ pub enum ParseResult {\n pub fn parse_or_else<R: Reader>(sess: @ParseSess,\n                                 cfg: ast::CrateConfig,\n                                 rdr: R,\n-                                ms: ~[Matcher])\n+                                ms: Vec<Matcher> )\n                                 -> HashMap<Ident, @NamedMatch> {\n-    match parse(sess, cfg, rdr, ms) {\n+    match parse(sess, cfg, rdr, ms.as_slice()) {\n         Success(m) => m,\n         Failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n         Error(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n@@ -230,13 +232,17 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                         rdr: R,\n                         ms: &[Matcher])\n                         -> ParseResult {\n-    let mut cur_eis = ~[];\n-    cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n+    let mut cur_eis = Vec::new();\n+    cur_eis.push(initial_matcher_pos(ms.iter()\n+                                       .map(|x| (*x).clone())\n+                                       .collect(),\n+                                     None,\n+                                     rdr.peek().sp.lo));\n \n     loop {\n-        let mut bb_eis = ~[]; // black-box parsed by parser.rs\n-        let mut next_eis = ~[]; // or proceed normally\n-        let mut eof_eis = ~[];\n+        let mut bb_eis = Vec::new(); // black-box parsed by parser.rs\n+        let mut next_eis = Vec::new(); // or proceed normally\n+        let mut eof_eis = Vec::new();\n \n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n \n@@ -274,8 +280,9 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n \n                         // Only touch the binders we have actually bound\n                         for idx in range(ei.match_lo, ei.match_hi) {\n-                            let sub = ei.matches[idx].clone();\n-                            new_pos.matches[idx]\n+                            let sub = (*ei.matches.get(idx)).clone();\n+                            new_pos.matches\n+                                   .get_mut(idx)\n                                    .push(@MatchedSeq(sub, mk_sp(ei.sp_lo,\n                                                                 sp.hi)));\n                         }\n@@ -308,7 +315,7 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                     eof_eis.push(ei);\n                 }\n             } else {\n-                match ei.elts[idx].node.clone() {\n+                match ei.elts.get(idx).node.clone() {\n                   /* need to descend into sequence */\n                   MatchSeq(ref matchers, ref sep, zero_ok,\n                            match_idx_lo, match_idx_hi) => {\n@@ -317,13 +324,15 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for idx in range(match_idx_lo, match_idx_hi) {\n-                            new_ei.matches[idx].push(@MatchedSeq(~[], sp));\n+                            new_ei.matches\n+                                  .get_mut(idx)\n+                                  .push(@MatchedSeq(Vec::new(), sp));\n                         }\n \n                         cur_eis.push(new_ei);\n                     }\n \n-                    let matches = vec::from_elem(ei.matches.len(), ~[]);\n+                    let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n                         elts: (*matchers).clone(),\n@@ -351,11 +360,11 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&tok, &EOF) {\n             if eof_eis.len() == 1u {\n-                let mut v = ~[];\n-                for dv in eof_eis[0u].matches.mut_iter() {\n+                let mut v = Vec::new();\n+                for dv in eof_eis.get_mut(0).matches.mut_iter() {\n                     v.push(dv.pop().unwrap());\n                 }\n-                return Success(nameize(sess, ms, v));\n+                return Success(nameize(sess, ms, v.as_slice()));\n             } else if eof_eis.len() > 1u {\n                 return Error(sp, ~\"ambiguity: multiple successful parses\");\n             } else {\n@@ -365,7 +374,7 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = bb_eis.map(|ei| {\n-                    match ei.elts[ei.idx].node {\n+                    match ei.elts.get(ei.idx).node {\n                       MatchNonterminal(bind, name, _) => {\n                         format!(\"{} ('{}')\",\n                                 token::get_ident(name),\n@@ -390,10 +399,10 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n                 let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n                 let mut ei = bb_eis.pop().unwrap();\n-                match ei.elts[ei.idx].node {\n+                match ei.elts.get(ei.idx).node {\n                   MatchNonterminal(_, name, idx) => {\n                     let name_string = token::get_ident(name);\n-                    ei.matches[idx].push(@MatchedNonterminal(\n+                    ei.matches.get_mut(idx).push(@MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get())));\n                     ei.idx += 1u;\n                   }\n@@ -413,12 +422,12 @@ pub fn parse<R: Reader>(sess: @ParseSess,\n \n pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n     match name {\n-      \"item\" => match p.parse_item(~[]) {\n+      \"item\" => match p.parse_item(Vec::new()) {\n         Some(i) => token::NtItem(i),\n         None => p.fatal(\"expected an item keyword\")\n       },\n       \"block\" => token::NtBlock(p.parse_block()),\n-      \"stmt\" => token::NtStmt(p.parse_stmt(~[])),\n+      \"stmt\" => token::NtStmt(p.parse_stmt(Vec::new())),\n       \"pat\" => token::NtPat(p.parse_pat()),\n       \"expr\" => token::NtExpr(p.parse_expr()),\n       \"ty\" => token::NtTy(p.parse_ty(false /* no need to disambiguate*/)),"}, {"sha": "712d5f6bd27dac80b4a8ed525883f13bc47e482f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -25,9 +25,11 @@ use parse::token::{special_idents, gensym_ident};\n use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n use parse::token;\n use print;\n-use std::cell::RefCell;\n use util::small_vector::SmallVector;\n \n+use std::cell::RefCell;\n+use std::vec_ng::Vec;\n+\n struct ParserAnyMacro {\n     parser: RefCell<Parser>,\n }\n@@ -90,8 +92,8 @@ impl AnyMacro for ParserAnyMacro {\n \n struct MacroRulesMacroExpander {\n     name: Ident,\n-    lhses: @~[@NamedMatch],\n-    rhses: @~[@NamedMatch],\n+    lhses: @Vec<@NamedMatch> ,\n+    rhses: @Vec<@NamedMatch> ,\n }\n \n impl MacroExpander for MacroRulesMacroExpander {\n@@ -100,7 +102,12 @@ impl MacroExpander for MacroRulesMacroExpander {\n               sp: Span,\n               arg: &[ast::TokenTree])\n               -> MacResult {\n-        generic_extension(cx, sp, self.name, arg, *self.lhses, *self.rhses)\n+        generic_extension(cx,\n+                          sp,\n+                          self.name,\n+                          arg,\n+                          self.lhses.as_slice(),\n+                          self.rhses.as_slice())\n     }\n }\n \n@@ -115,7 +122,9 @@ fn generic_extension(cx: &ExtCtxt,\n     if cx.trace_macros() {\n         println!(\"{}! \\\\{ {} \\\\}\",\n                  token::get_ident(name),\n-                 print::pprust::tt_to_str(&TTDelim(@arg.to_owned())));\n+                 print::pprust::tt_to_str(&TTDelim(@arg.iter()\n+                                                       .map(|x| (*x).clone())\n+                                                       .collect())));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n@@ -128,16 +137,23 @@ fn generic_extension(cx: &ExtCtxt,\n         match **lhs {\n           MatchedNonterminal(NtMatchers(ref mtcs)) => {\n             // `None` is because we're not interpolating\n-            let arg_rdr = new_tt_reader(s_d, None, arg.to_owned());\n-            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n+            let arg_rdr = new_tt_reader(s_d,\n+                                        None,\n+                                        arg.iter()\n+                                           .map(|x| (*x).clone())\n+                                           .collect());\n+            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs.as_slice()) {\n               Success(named_matches) => {\n                 let rhs = match *rhses[i] {\n                     // okay, what's your transcriber?\n                     MatchedNonterminal(NtTT(tt)) => {\n                         match *tt {\n                             // cut off delimiters; don't parse 'em\n                             TTDelim(ref tts) => {\n-                                (*tts).slice(1u,(*tts).len()-1u).to_owned()\n+                                (*tts).slice(1u,(*tts).len()-1u)\n+                                      .iter()\n+                                      .map(|x| (*x).clone())\n+                                      .collect()\n                             }\n                             _ => cx.span_fatal(\n                                 sp, \"macro rhs must be delimited\")\n@@ -174,7 +190,7 @@ fn generic_extension(cx: &ExtCtxt,\n pub fn add_new_extension(cx: &mut ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n-                         arg: ~[ast::TokenTree])\n+                         arg: Vec<ast::TokenTree> )\n                          -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: Matcher_) -> Matcher {\n@@ -191,15 +207,14 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n-    let argument_gram = ~[\n-        ms(MatchSeq(~[\n+    let argument_gram = vec!(\n+        ms(MatchSeq(vec!(\n             ms(MatchNonterminal(lhs_nm, special_idents::matchers, 0u)),\n             ms(MatchTok(FAT_ARROW)),\n-            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u)),\n-        ], Some(SEMI), false, 0u, 2u)),\n+            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u))), Some(SEMI), false, 0u, 2u)),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n-        ms(MatchSeq(~[ms(MatchTok(SEMI))], None, true, 2u, 2u))];\n+        ms(MatchSeq(vec!(ms(MatchTok(SEMI))), None, true, 2u, 2u)));\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):"}, {"sha": "a3f179e851ad321127f9e95c130d803b8ded428e", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -18,11 +18,12 @@ use parse::token;\n use parse::lexer::TokenAndSpan;\n \n use std::cell::{Cell, RefCell};\n+use std::vec_ng::Vec;\n use collections::HashMap;\n \n ///an unzipping of `TokenTree`s\n struct TtFrame {\n-    forest: @~[ast::TokenTree],\n+    forest: @Vec<ast::TokenTree> ,\n     idx: Cell<uint>,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n@@ -35,8 +36,8 @@ pub struct TtReader {\n     priv stack: RefCell<@TtFrame>,\n     /* for MBE-style macro transcription */\n     priv interpolations: RefCell<HashMap<Ident, @NamedMatch>>,\n-    priv repeat_idx: RefCell<~[uint]>,\n-    priv repeat_len: RefCell<~[uint]>,\n+    priv repeat_idx: RefCell<Vec<uint> >,\n+    priv repeat_len: RefCell<Vec<uint> >,\n     /* cached: */\n     cur_tok: RefCell<Token>,\n     cur_span: RefCell<Span>,\n@@ -47,7 +48,7 @@ pub struct TtReader {\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @SpanHandler,\n                      interp: Option<HashMap<Ident, @NamedMatch>>,\n-                     src: ~[ast::TokenTree])\n+                     src: Vec<ast::TokenTree> )\n                      -> TtReader {\n     let r = TtReader {\n         sp_diag: sp_diag,\n@@ -62,8 +63,8 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n             None => RefCell::new(HashMap::new()),\n             Some(x) => RefCell::new(x),\n         },\n-        repeat_idx: RefCell::new(~[]),\n-        repeat_len: RefCell::new(~[]),\n+        repeat_idx: RefCell::new(Vec::new()),\n+        repeat_len: RefCell::new(Vec::new()),\n         /* dummy values, never read: */\n         cur_tok: RefCell::new(EOF),\n         cur_span: RefCell::new(DUMMY_SP),\n@@ -106,7 +107,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: @NamedMatch)\n                 // end of the line; duplicate henceforth\n                 ad\n             }\n-            MatchedSeq(ref ads, _) => ads[*idx]\n+            MatchedSeq(ref ads, _) => *ads.get(*idx)\n         }\n     }\n     let repeat_idx = r.repeat_idx.borrow();\n@@ -217,7 +218,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n             r.stack.get().idx.set(0u);\n             {\n                 let mut repeat_idx = r.repeat_idx.borrow_mut();\n-                repeat_idx.get()[repeat_idx.get().len() - 1u] += 1u;\n+                let last_repeat_idx = repeat_idx.get().len() - 1u;\n+                *repeat_idx.get().get_mut(last_repeat_idx) += 1u;\n             }\n             match r.stack.get().sep.clone() {\n               Some(tk) => {\n@@ -231,7 +233,7 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `TTDelim` not starting\n     with a `TTTok`, even though it won't happen */\n         // FIXME(pcwalton): Bad copy.\n-        match r.stack.get().forest[r.stack.get().idx.get()].clone() {\n+        match (*r.stack.get().forest.get(r.stack.get().idx.get())).clone() {\n           TTDelim(tts) => {\n             r.stack.set(@TtFrame {\n                 forest: tts,"}, {"sha": "b01ba7718ba58b4013634048adf396ffd4d410a9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -16,18 +16,20 @@ use parse::token;\n use opt_vec::OptVec;\n use util::small_vector::SmallVector;\n \n+use std::vec_ng::Vec;\n+\n // We may eventually want to be able to fold over type parameters, too.\n pub trait Folder {\n     fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n-        meta_items.map(|x| fold_meta_item_(*x, self))\n+    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> Vec<@MetaItem> {\n+        meta_items.iter().map(|x| fold_meta_item_(*x, self)).collect()\n     }\n \n-    fn fold_view_paths(&mut self, view_paths: &[@ViewPath]) -> ~[@ViewPath] {\n-        view_paths.map(|view_path| {\n+    fn fold_view_paths(&mut self, view_paths: &[@ViewPath]) -> Vec<@ViewPath> {\n+        view_paths.iter().map(|view_path| {\n             let inner_view_path = match view_path.node {\n                 ViewPathSimple(ref ident, ref path, node_id) => {\n                     ViewPathSimple(ident.clone(),\n@@ -60,7 +62,7 @@ pub trait Folder {\n                 node: inner_view_path,\n                 span: self.new_span(view_path.span),\n             }\n-        })\n+        }).collect()\n     }\n \n     fn fold_view_item(&mut self, vi: &ViewItem) -> ViewItem {\n@@ -275,16 +277,16 @@ pub trait Folder {\n             node: match macro.node {\n                 MacInvocTT(ref p, ref tts, ctxt) => {\n                     MacInvocTT(self.fold_path(p),\n-                               fold_tts(*tts, self),\n+                               fold_tts(tts.as_slice(), self),\n                                ctxt)\n                 }\n             },\n             span: self.new_span(macro.span)\n         }\n     }\n \n-    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n-        es.map(|x| f(*x))\n+    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> Vec<@Expr> {\n+        es.iter().map(|x| f(*x)).collect()\n     }\n \n     fn new_id(&mut self, i: NodeId) -> NodeId {\n@@ -370,21 +372,21 @@ fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n // since many token::IDENT are not necessary part of let bindings and most\n // token::LIFETIME are certainly not loop labels. But we can't tell in their\n // token form. So this is less ideal and hacky but it works.\n-pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> ~[TokenTree] {\n-    tts.map(|tt| {\n+pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n+    tts.iter().map(|tt| {\n         match *tt {\n             TTTok(span, ref tok) =>\n             TTTok(span,maybe_fold_ident(tok,fld)),\n-            TTDelim(tts) => TTDelim(@fold_tts(*tts, fld)),\n+            TTDelim(tts) => TTDelim(@fold_tts(tts.as_slice(), fld)),\n             TTSeq(span, pattern, ref sep, is_optional) =>\n             TTSeq(span,\n-                  @fold_tts(*pattern, fld),\n+                  @fold_tts(pattern.as_slice(), fld),\n                   sep.as_ref().map(|tok|maybe_fold_ident(tok,fld)),\n                   is_optional),\n             TTNonterminal(sp,ref ident) =>\n             TTNonterminal(sp,fld.fold_ident(*ident))\n         }\n-    })\n+    }).collect()\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n@@ -518,7 +520,7 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n                               folder.new_id(node_id))\n         }\n         ViewItemUse(ref view_paths) => {\n-            ViewItemUse(folder.fold_view_paths(*view_paths))\n+            ViewItemUse(folder.fold_view_paths(view_paths.as_slice()))\n         }\n     };\n     ViewItem {\n@@ -881,7 +883,7 @@ mod test {\n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State,\n                         krate: &ast::Crate) -> io::IoResult<()> {\n-        pprust::print_mod(s, &krate.module, krate.attrs)\n+        pprust::print_mod(s, &krate.module, krate.attrs.as_slice())\n     }\n \n     // change every identifier to \"zz\""}, {"sha": "ec81fff51c791ae7f82bc88047ad80e909c67bf9", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -15,20 +15,21 @@\n  * other useful things like `push()` and `len()`.\n  */\n \n-use std::vec;\n use std::default::Default;\n+use std::vec;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Encodable, Decodable, Hash)]\n pub enum OptVec<T> {\n     Empty,\n-    Vec(~[T])\n+    Vec(Vec<T> )\n }\n \n pub fn with<T>(t: T) -> OptVec<T> {\n-    Vec(~[t])\n+    Vec(vec!(t))\n }\n \n-pub fn from<T>(t: ~[T]) -> OptVec<T> {\n+pub fn from<T>(t: Vec<T> ) -> OptVec<T> {\n     if t.len() == 0 {\n         Empty\n     } else {\n@@ -44,7 +45,7 @@ impl<T> OptVec<T> {\n                 return;\n             }\n             Empty => {\n-                *self = Vec(~[t]);\n+                *self = Vec(vec!(t));\n             }\n         }\n     }\n@@ -87,7 +88,7 @@ impl<T> OptVec<T> {\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(\"invalid index {}\", i),\n-            Vec(ref v) => &v[i]\n+            Vec(ref v) => v.get(i)\n         }\n     }\n \n@@ -121,11 +122,11 @@ impl<T> OptVec<T> {\n     }\n \n     #[inline]\n-    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> ~[B] {\n+    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> Vec<B> {\n         self.iter().map(op).collect()\n     }\n \n-    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> ~[B] {\n+    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> Vec<B> {\n         let mut index = 0;\n         self.map_to_vec(|a| {\n             let i = index;\n@@ -135,19 +136,19 @@ impl<T> OptVec<T> {\n     }\n }\n \n-pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n+pub fn take_vec<T>(v: OptVec<T>) -> Vec<T> {\n     match v {\n-        Empty => ~[],\n+        Empty => Vec::new(),\n         Vec(v) => v\n     }\n }\n \n impl<T:Clone> OptVec<T> {\n     pub fn prepend(&self, t: T) -> OptVec<T> {\n-        let mut v0 = ~[t];\n+        let mut v0 = vec!(t);\n         match *self {\n             Empty => {}\n-            Vec(ref v1) => { v0.push_all(*v1); }\n+            Vec(ref v1) => { v0.push_all(v1.as_slice()); }\n         }\n         return Vec(v0);\n     }"}, {"sha": "0a74c7ca8212464cf5f7ca08066a15b7060c1e89", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -15,21 +15,23 @@ use parse::token;\n use parse::parser::Parser;\n use parse::token::INTERPOLATED;\n \n+use std::vec_ng::Vec;\n+\n // a parser that can parse attributes.\n pub trait ParserAttr {\n-    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute];\n+    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> ;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (~[ast::Attribute], ~[ast::Attribute]);\n+                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> );\n     fn parse_meta_item(&mut self) -> @ast::MetaItem;\n-    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem];\n-    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem];\n+    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> ;\n+    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> ;\n }\n \n impl ParserAttr for Parser {\n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute] {\n-        let mut attrs: ~[ast::Attribute] = ~[];\n+    fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n+        let mut attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n@@ -116,9 +118,9 @@ impl ParserAttr for Parser {\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n     fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (~[ast::Attribute], ~[ast::Attribute]) {\n-        let mut inner_attrs: ~[ast::Attribute] = ~[];\n-        let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n+                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> ) {\n+        let mut inner_attrs: Vec<ast::Attribute> = Vec::new();\n+        let mut next_outer_attrs: Vec<ast::Attribute> = Vec::new();\n         loop {\n             let attr = match self.token {\n                 token::INTERPOLATED(token::NtAttr(..)) => {\n@@ -188,17 +190,17 @@ impl ParserAttr for Parser {\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem] {\n+    fn parse_meta_seq(&mut self) -> Vec<@ast::MetaItem> {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem] {\n+    fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> {\n         match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n-            _ => ~[]\n+            _ => Vec::new()\n         }\n     }\n }"}, {"sha": "c2a2097de2442cd3a708cf9ceaedd75e49d1e6bb", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -20,6 +20,7 @@ use parse::token;\n use std::io;\n use std::str;\n use std::uint;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Eq)]\n pub enum CommentStyle {\n@@ -32,7 +33,7 @@ pub enum CommentStyle {\n #[deriving(Clone)]\n pub struct Comment {\n     style: CommentStyle,\n-    lines: ~[~str],\n+    lines: Vec<~str> ,\n     pos: BytePos\n }\n \n@@ -54,28 +55,28 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n \n pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     /// remove whitespace-only lines from the start/end of lines\n-    fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n+    fn vertical_trim(lines: Vec<~str> ) -> Vec<~str> {\n         let mut i = 0u;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n-        if lines.len() > 0 && lines[0].chars().all(|c| c == '*') {\n+        if lines.len() > 0 && lines.get(0).chars().all(|c| c == '*') {\n             i += 1;\n         }\n-        while i < j && lines[i].trim().is_empty() {\n+        while i < j && lines.get(i).trim().is_empty() {\n             i += 1;\n         }\n         // like the first, a last line of all stars should be omitted\n-        if j > i && lines[j - 1].chars().skip(1).all(|c| c == '*') {\n+        if j > i && lines.get(j - 1).chars().skip(1).all(|c| c == '*') {\n             j -= 1;\n         }\n-        while j > i && lines[j - 1].trim().is_empty() {\n+        while j > i && lines.get(j - 1).trim().is_empty() {\n             j -= 1;\n         }\n-        return lines.slice(i, j).to_owned();\n+        return lines.slice(i, j).iter().map(|x| (*x).clone()).collect();\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n-    fn horizontal_trim(lines: ~[~str]) -> ~[~str] {\n+    fn horizontal_trim(lines: Vec<~str> ) -> Vec<~str> {\n         let mut i = uint::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n@@ -122,7 +123,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .lines_any()\n             .map(|s| s.to_owned())\n-            .collect::<~[~str]>();\n+            .collect::<Vec<~str> >();\n \n         let lines = vertical_trim(lines);\n         let lines = horizontal_trim(lines);\n@@ -157,9 +158,9 @@ fn consume_non_eol_whitespace(rdr: &StringReader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n+fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment> ) {\n     debug!(\">>> blank-line comment\");\n-    let v: ~[~str] = ~[];\n+    let v: Vec<~str> = Vec::new();\n     comments.push(Comment {\n         style: BlankLine,\n         lines: v,\n@@ -168,7 +169,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n-                                           comments: &mut ~[Comment]) {\n+                                           comments: &mut Vec<Comment> ) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n         if rdr.col.get() == CharPos(0u) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n@@ -179,22 +180,22 @@ fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n \n \n fn read_shebang_comment(rdr: &StringReader, code_to_the_left: bool,\n-                                            comments: &mut ~[Comment]) {\n+                                            comments: &mut Vec<Comment> ) {\n     debug!(\">>> shebang comment\");\n     let p = rdr.last_pos.get();\n     debug!(\"<<< shebang comment\");\n     comments.push(Comment {\n         style: if code_to_the_left { Trailing } else { Isolated },\n-        lines: ~[read_one_line_comment(rdr)],\n+        lines: vec!(read_one_line_comment(rdr)),\n         pos: p\n     });\n }\n \n fn read_line_comments(rdr: &StringReader, code_to_the_left: bool,\n-                                          comments: &mut ~[Comment]) {\n+                                          comments: &mut Vec<Comment> ) {\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n-    let mut lines: ~[~str] = ~[];\n+    let mut lines: Vec<~str> = Vec::new();\n     while rdr.curr_is('/') && nextch_is(rdr, '/') {\n         let line = read_one_line_comment(rdr);\n         debug!(\"{}\", line);\n@@ -232,7 +233,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n     return Some(cursor);\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n+fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<~str> ,\n                                         s: ~str, col: CharPos) {\n     let len = s.len();\n     let s1 = match all_whitespace(s, col) {\n@@ -249,10 +250,10 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n \n fn read_block_comment(rdr: &StringReader,\n                       code_to_the_left: bool,\n-                      comments: &mut ~[Comment]) {\n+                      comments: &mut Vec<Comment> ) {\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos.get();\n-    let mut lines: ~[~str] = ~[];\n+    let mut lines: Vec<~str> = Vec::new();\n     let col: CharPos = rdr.col.get();\n     bump(rdr);\n     bump(rdr);\n@@ -324,7 +325,7 @@ fn peeking_at_comment(rdr: &StringReader) -> bool {\n \n fn consume_comment(rdr: &StringReader,\n                    code_to_the_left: bool,\n-                   comments: &mut ~[Comment]) {\n+                   comments: &mut Vec<Comment> ) {\n     debug!(\">>> consume comment\");\n     if rdr.curr_is('/') && nextch_is(rdr, '/') {\n         read_line_comments(rdr, code_to_the_left, comments);\n@@ -348,15 +349,15 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                         @diagnostic::SpanHandler,\n                                     path: ~str,\n                                     srdr: &mut io::Reader)\n-                                 -> (~[Comment], ~[Literal]) {\n+                                 -> (Vec<Comment> , Vec<Literal> ) {\n     let src = srdr.read_to_end().unwrap();\n     let src = str::from_utf8_owned(src).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);\n \n-    let mut comments: ~[Comment] = ~[];\n-    let mut literals: ~[Literal] = ~[];\n+    let mut comments: Vec<Comment> = Vec::new();\n+    let mut literals: Vec<Literal> = Vec::new();\n     let mut first_read: bool = true;\n     while !is_eof(&rdr) {\n         loop {"}, {"sha": "884fc306f22ea6684c461378b1e206d751adbe17", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -1005,6 +1005,7 @@ mod test {\n     use parse::token;\n     use parse::token::{str_to_ident};\n     use std::io::util;\n+    use std::vec_ng::Vec;\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n@@ -1048,7 +1049,7 @@ mod test {\n \n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n-    fn check_tokenization (env: Env, expected: ~[token::Token]) {\n+    fn check_tokenization (env: Env, expected: Vec<token::Token> ) {\n         for expected_tok in expected.iter() {\n             let TokenAndSpan {tok:actual_tok, sp: _} =\n                 env.string_reader.next_token();\n@@ -1064,32 +1065,32 @@ mod test {\n     #[test] fn doublecolonparsing () {\n         let env = setup (~\"a b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",false),\n-                             mk_ident(\"b\",false)]);\n+                           vec!(mk_ident(\"a\",false),\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_2 () {\n         let env = setup (~\"a::b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",true),\n+                           vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident(\"b\",false)]);\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_3 () {\n         let env = setup (~\"a ::b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",false),\n+                           vec!(mk_ident(\"a\",false),\n                              token::MOD_SEP,\n-                             mk_ident(\"b\",false)]);\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_4 () {\n         let env = setup (~\"a:: b\");\n         check_tokenization (env,\n-                           ~[mk_ident(\"a\",true),\n+                           vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident(\"b\",false)]);\n+                             mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {"}, {"sha": "9e5db1770bf311ecd0c875ec4b806050fdd2f1d4", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,6 +21,7 @@ use parse::parser::Parser;\n use std::cell::RefCell;\n use std::io::File;\n use std::str;\n+use std::vec_ng::Vec;\n \n pub mod lexer;\n pub mod parser;\n@@ -42,15 +43,15 @@ pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n     span_diagnostic: @SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n-    included_mod_stack: RefCell<~[Path]>,\n+    included_mod_stack: RefCell<Vec<Path> >,\n }\n \n pub fn new_parse_sess() -> @ParseSess {\n     let cm = @CodeMap::new();\n     @ParseSess {\n         cm: cm,\n         span_diagnostic: mk_span_handler(default_handler(), cm),\n-        included_mod_stack: RefCell::new(~[]),\n+        included_mod_stack: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -60,7 +61,7 @@ pub fn new_parse_sess_special_handler(sh: @SpanHandler,\n     @ParseSess {\n         cm: cm,\n         span_diagnostic: sh,\n-        included_mod_stack: RefCell::new(~[]),\n+        included_mod_stack: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -82,7 +83,7 @@ pub fn parse_crate_attrs_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n     sess: @ParseSess\n-) -> ~[ast::Attribute] {\n+) -> Vec<ast::Attribute> {\n     let mut parser = new_parser_from_file(sess, cfg, input);\n     let (inner, _) = parser.parse_inner_attrs_and_next();\n     return inner;\n@@ -104,7 +105,7 @@ pub fn parse_crate_attrs_from_source_str(name: ~str,\n                                          source: ~str,\n                                          cfg: ast::CrateConfig,\n                                          sess: @ParseSess)\n-                                         -> ~[ast::Attribute] {\n+                                         -> Vec<ast::Attribute> {\n     let mut p = new_parser_from_source_str(sess,\n                                            cfg,\n                                            name,\n@@ -144,7 +145,7 @@ pub fn parse_meta_from_source_str(name: ~str,\n pub fn parse_stmt_from_source_str(name: ~str,\n                                   source: ~str,\n                                   cfg: ast::CrateConfig,\n-                                  attrs: ~[ast::Attribute],\n+                                  attrs: Vec<ast::Attribute> ,\n                                   sess: @ParseSess)\n                                   -> @ast::Stmt {\n     let mut p = new_parser_from_source_str(\n@@ -160,7 +161,7 @@ pub fn parse_tts_from_source_str(name: ~str,\n                                  source: ~str,\n                                  cfg: ast::CrateConfig,\n                                  sess: @ParseSess)\n-                                 -> ~[ast::TokenTree] {\n+                                 -> Vec<ast::TokenTree> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -214,7 +215,7 @@ pub fn filemap_to_parser(sess: @ParseSess,\n // compiler expands into it\n pub fn new_parser_from_tts(sess: @ParseSess,\n                      cfg: ast::CrateConfig,\n-                     tts: ~[ast::TokenTree]) -> Parser {\n+                     tts: Vec<ast::TokenTree> ) -> Parser {\n     tts_to_parser(sess,tts,cfg)\n }\n \n@@ -256,18 +257,18 @@ pub fn string_to_filemap(sess: @ParseSess, source: ~str, path: ~str)\n \n // given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n-    -> ~[ast::TokenTree] {\n+    -> Vec<ast::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n-    let cfg = ~[];\n+    let cfg = Vec::new();\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n     let mut p1 = Parser(sess, cfg, ~srdr);\n     p1.parse_all_token_trees()\n }\n \n // given tts and cfg, produce a parser\n pub fn tts_to_parser(sess: @ParseSess,\n-                     tts: ~[ast::TokenTree],\n+                     tts: Vec<ast::TokenTree> ,\n                      cfg: ast::CrateConfig) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n     Parser(sess, cfg, ~trdr)\n@@ -288,6 +289,7 @@ mod test {\n     use std::io;\n     use std::io::MemWriter;\n     use std::str;\n+    use std::vec_ng::Vec;\n     use codemap::{Span, BytePos, Spanned};\n     use opt_vec;\n     use ast;\n@@ -318,13 +320,13 @@ mod test {\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n-                        segments: ~[\n+                        segments: vec!(\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n                                 lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n-                        ],\n+                        ),\n                     }),\n                     span: sp(0, 1)\n                    })\n@@ -337,7 +339,7 @@ mod test {\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n-                            segments: ~[\n+                            segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n                                     lifetimes: opt_vec::Empty,\n@@ -348,7 +350,7 @@ mod test {\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n-                            ]\n+                            )\n                         }),\n                     span: sp(0, 6)\n                    })\n@@ -362,27 +364,28 @@ mod test {\n     // check the token-tree-ization of macros\n     #[test] fn string_to_tts_macro () {\n         let tts = string_to_tts(~\"macro_rules! zip (($a)=>($a))\");\n-        let tts: &[ast::TokenTree] = tts;\n+        let tts: &[ast::TokenTree] = tts.as_slice();\n         match tts {\n             [ast::TTTok(_,_),\n              ast::TTTok(_,token::NOT),\n              ast::TTTok(_,_),\n              ast::TTDelim(delim_elts)] => {\n-                let delim_elts: &[ast::TokenTree] = *delim_elts;\n+                let delim_elts: &[ast::TokenTree] = delim_elts.as_slice();\n                 match delim_elts {\n                     [ast::TTTok(_,token::LPAREN),\n                      ast::TTDelim(first_set),\n                      ast::TTTok(_,token::FAT_ARROW),\n                      ast::TTDelim(second_set),\n                      ast::TTTok(_,token::RPAREN)] => {\n-                        let first_set: &[ast::TokenTree] = *first_set;\n+                        let first_set: &[ast::TokenTree] =\n+                            first_set.as_slice();\n                         match first_set {\n                             [ast::TTTok(_,token::LPAREN),\n                              ast::TTTok(_,token::DOLLAR),\n                              ast::TTTok(_,_),\n                              ast::TTTok(_,token::RPAREN)] => {\n                                 let second_set: &[ast::TokenTree] =\n-                                    *second_set;\n+                                    second_set.as_slice();\n                                 match second_set {\n                                     [ast::TTTok(_,token::LPAREN),\n                                      ast::TTTok(_,token::DOLLAR),\n@@ -550,13 +553,13 @@ mod test {\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n-                            segments: ~[\n+                            segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n-                            ],\n+                            ),\n                         }),\n                         span:sp(7,8)\n                     })),\n@@ -572,13 +575,13 @@ mod test {\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n                                global:false,\n-                               segments: ~[\n+                               segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n                                     lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n-                               ],\n+                               ),\n                             }),\n                            span: sp(0,1)},\n                                            ast::DUMMY_NODE_ID),\n@@ -599,13 +602,13 @@ mod test {\n                                 ast::Path {\n                                     span:sp(0,1),\n                                     global:false,\n-                                    segments: ~[\n+                                    segments: vec!(\n                                         ast::PathSegment {\n                                             identifier: str_to_ident(\"b\"),\n                                             lifetimes: opt_vec::Empty,\n                                             types: opt_vec::Empty,\n                                         }\n-                                    ],\n+                                    ),\n                                 },\n                                 None /* no idea */),\n                              span: sp(0,1)});\n@@ -618,22 +621,22 @@ mod test {\n         assert!(string_to_item(~\"fn a (b : int) { b; }\") ==\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n-                            attrs:~[],\n+                            attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemFn(ast::P(ast::FnDecl {\n-                                inputs: ~[ast::Arg{\n+                                inputs: vec!(ast::Arg{\n                                     ty: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                        node: ast::TyPath(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        segments: ~[\n+                                        segments: vec!(\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n                                                 lifetimes: opt_vec::Empty,\n                                                 types: opt_vec::Empty,\n                                             }\n-                                        ],\n+                                        ),\n                                         }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n@@ -644,21 +647,21 @@ mod test {\n                                             ast::Path {\n                                                 span:sp(6,7),\n                                                 global:false,\n-                                                segments: ~[\n+                                                segments: vec!(\n                                                     ast::PathSegment {\n                                                         identifier:\n                                                             str_to_ident(\"b\"),\n                                                         lifetimes: opt_vec::Empty,\n                                                         types: opt_vec::Empty,\n                                                     }\n-                                                ],\n+                                                ),\n                                             },\n                                             None // no idea\n                                         ),\n                                         span: sp(6,7)\n                                     },\n                                     id: ast::DUMMY_NODE_ID\n-                                }],\n+                                }),\n                                 output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                        node: ast::TyNil,\n                                                        span:sp(15,15)}), // not sure\n@@ -672,15 +675,15 @@ mod test {\n                                         ty_params: opt_vec::Empty,\n                                     },\n                                     ast::P(ast::Block {\n-                                        view_items: ~[],\n-                                        stmts: ~[@Spanned{\n+                                        view_items: Vec::new(),\n+                                        stmts: vec!(@Spanned{\n                                             node: ast::StmtSemi(@ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        segments: ~[\n+                                                        segments: vec!(\n                                                             ast::PathSegment {\n                                                                 identifier:\n                                                                 str_to_ident(\n@@ -690,11 +693,11 @@ mod test {\n                                                                 types:\n                                                                 opt_vec::Empty\n                                                             }\n-                                                        ],\n+                                                        ),\n                                                       }),\n                                                 span: sp(17,18)},\n                                                 ast::DUMMY_NODE_ID),\n-                                            span: sp(17,18)}],\n+                                            span: sp(17,18)}),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::DefaultBlock, // no idea"}, {"sha": "9b209aadf19e50b91b61f6d8817980f461e3db5c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 155, "deletions": 138, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -82,7 +82,8 @@ use std::cell::Cell;\n use collections::HashSet;\n use std::kinds::marker;\n use std::mem::replace;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n \n #[allow(non_camel_case_types)]\n #[deriving(Eq)]\n@@ -93,7 +94,7 @@ enum restriction {\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n-type ItemInfo = (Ident, Item_, Option<~[Attribute]>);\n+type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n@@ -129,7 +130,7 @@ pub struct PathAndBounds {\n enum ItemOrViewItem {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n-    IoviNone(~[Attribute]),\n+    IoviNone(Vec<Attribute> ),\n     IoviItem(@Item),\n     IoviForeignItem(@ForeignItem),\n     IoviViewItem(ViewItem)\n@@ -257,7 +258,7 @@ macro_rules! maybe_whole (\n             };\n             match __found__ {\n                 Some(INTERPOLATED(token::$constructor(x))) => {\n-                    return (~[], x)\n+                    return (Vec::new(), x)\n                 }\n                 _ => {}\n             }\n@@ -266,21 +267,20 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(lhs: ~[Attribute], rhs: Option<~[Attribute]>)\n-             -> ~[Attribute] {\n+fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n+             -> Vec<Attribute> {\n     match rhs {\n         None => lhs,\n-        Some(ref attrs) => vec::append(lhs, (*attrs))\n+        Some(ref attrs) => vec_ng::append(lhs, attrs.as_slice())\n     }\n }\n \n \n struct ParsedItemsAndViewItems {\n-    attrs_remaining: ~[Attribute],\n-    view_items: ~[ViewItem],\n-    items: ~[@Item],\n-    foreign_items: ~[@ForeignItem]\n-}\n+    attrs_remaining: Vec<Attribute> ,\n+    view_items: Vec<ViewItem> ,\n+    items: Vec<@Item> ,\n+    foreign_items: Vec<@ForeignItem> }\n \n /* ident is handled by common.rs */\n \n@@ -314,8 +314,8 @@ pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n         restriction: UNRESTRICTED,\n         quote_depth: 0,\n         obsolete_set: HashSet::new(),\n-        mod_path_stack: ~[],\n-        open_braces: ~[],\n+        mod_path_stack: Vec::new(),\n+        open_braces: Vec::new(),\n         nopod: marker::NoPod\n     }\n }\n@@ -343,9 +343,9 @@ pub struct Parser {\n     /// extra detail when the same error is seen twice\n     obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    mod_path_stack: ~[InternedString],\n+    mod_path_stack: Vec<InternedString> ,\n     /// Stack of spans of open delimiters. Used for error message.\n-    open_braces: ~[Span],\n+    open_braces: Vec<Span> ,\n     /* do not copy the parser; its state is tied to outside state */\n     priv nopod: marker::NoPod\n }\n@@ -407,8 +407,11 @@ impl Parser {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n-            let expected = vec::append(edible.to_owned(), inedible);\n-            let expect = tokens_to_str(expected);\n+            let expected = vec_ng::append(edible.iter()\n+                                                .map(|x| (*x).clone())\n+                                                .collect(),\n+                                          inedible);\n+            let expect = tokens_to_str(expected.as_slice());\n             let actual = self.this_token_to_str();\n             self.fatal(\n                 if expected.len() != 1 {\n@@ -446,8 +449,12 @@ impl Parser {\n         match e.node {\n             ExprPath(..) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n-                let expected = vec::append(edible.to_owned(), inedible);\n-                self.check_for_erroneous_unit_struct_expecting(expected);\n+                let expected = vec_ng::append(edible.iter()\n+                                                    .map(|x| (*x).clone())\n+                                                    .collect(),\n+                                              inedible);\n+                self.check_for_erroneous_unit_struct_expecting(\n+                    expected.as_slice());\n             }\n             _ => {}\n         }\n@@ -465,8 +472,12 @@ impl Parser {\n         debug!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.as_ref().map_or(false, |t| is_ident_or_path(*t)) {\n-            let expected = vec::append(edible.to_owned(), inedible);\n-            self.check_for_erroneous_unit_struct_expecting(expected);\n+            let expected = vec_ng::append(edible.iter()\n+                                                .map(|x| (*x).clone())\n+                                                .collect(),\n+                                          inedible.as_slice());\n+            self.check_for_erroneous_unit_struct_expecting(\n+                expected.as_slice());\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -578,9 +589,9 @@ impl Parser {\n                               &mut self,\n                               sep: &token::Token,\n                               f: |&mut Parser| -> T)\n-                              -> ~[T] {\n+                              -> Vec<T> {\n         let mut first = true;\n-        let mut vector = ~[];\n+        let mut vector = Vec::new();\n         while self.token != token::BINOP(token::OR) &&\n                 self.token != token::OROR {\n             if first {\n@@ -655,7 +666,7 @@ impl Parser {\n                             ket: &token::Token,\n                             sep: SeqSep,\n                             f: |&mut Parser| -> T)\n-                            -> ~[T] {\n+                            -> Vec<T> {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -669,9 +680,9 @@ impl Parser {\n                                    ket: &token::Token,\n                                    sep: SeqSep,\n                                    f: |&mut Parser| -> T)\n-                                   -> ~[T] {\n+                                   -> Vec<T> {\n         let mut first: bool = true;\n-        let mut v: ~[T] = ~[];\n+        let mut v: Vec<T> = Vec::new();\n         while self.token != *ket {\n             match sep.sep {\n               Some(ref t) => {\n@@ -695,7 +706,7 @@ impl Parser {\n                                ket: &token::Token,\n                                sep: SeqSep,\n                                f: |&mut Parser| -> T)\n-                               -> ~[T] {\n+                               -> Vec<T> {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -710,7 +721,7 @@ impl Parser {\n                      ket: &token::Token,\n                      sep: SeqSep,\n                      f: |&mut Parser| -> T)\n-                     -> Spanned<~[T]> {\n+                     -> Spanned<Vec<T> > {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -950,7 +961,7 @@ impl Parser {\n                 };\n \n                 let inputs = if self.eat(&token::OROR) {\n-                    ~[]\n+                    Vec::new()\n                 } else {\n                     self.expect_or();\n                     let inputs = self.parse_seq_to_before_or(\n@@ -1034,7 +1045,7 @@ impl Parser {\n     }\n \n     // parse the methods in a trait declaration\n-    pub fn parse_trait_methods(&mut self) -> ~[TraitMethod] {\n+    pub fn parse_trait_methods(&mut self) -> Vec<TraitMethod> {\n         self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -1083,7 +1094,7 @@ impl Parser {\n                 debug!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n-                let attrs = vec::append(attrs, inner_attrs);\n+                let attrs = vec_ng::append(attrs, inner_attrs.as_slice());\n                 Provided(@ast::Method {\n                     ident: ident,\n                     attrs: attrs,\n@@ -1176,7 +1187,7 @@ impl Parser {\n                 // (t) is a parenthesized ty\n                 // (t,) is the type of a tuple with only one field,\n                 // of type t\n-                let mut ts = ~[self.parse_ty(false)];\n+                let mut ts = vec!(self.parse_ty(false));\n                 let mut one_tuple = false;\n                 while self.token == token::COMMA {\n                     self.bump();\n@@ -1190,7 +1201,7 @@ impl Parser {\n \n                 if ts.len() == 1 && !one_tuple {\n                     self.expect(&token::RPAREN);\n-                    return ts[0]\n+                    return *ts.get(0)\n                 }\n \n                 let t = TyTup(ts);\n@@ -1479,7 +1490,7 @@ impl Parser {\n         // Parse any number of segments and bound sets. A segment is an\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n-        let mut segments = ~[];\n+        let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_ident();\n@@ -1541,7 +1552,7 @@ impl Parser {\n         let span = mk_sp(lo, self.last_span.hi);\n \n         // Assemble the path segments.\n-        let mut path_segments = ~[];\n+        let mut path_segments = Vec::new();\n         let mut bounds = None;\n         let last_segment_index = segments.len() - 1;\n         for (i, segment_and_bounds) in segments.move_iter().enumerate() {\n@@ -1690,19 +1701,19 @@ impl Parser {\n         ExprBinary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: @Expr, args: ~[@Expr]) -> ast::Expr_ {\n+    pub fn mk_call(&mut self, f: @Expr, args: Vec<@Expr> ) -> ast::Expr_ {\n         ExprCall(f, args)\n     }\n \n-    fn mk_method_call(&mut self, ident: Ident, tps: ~[P<Ty>], args: ~[@Expr]) -> ast::Expr_ {\n+    fn mk_method_call(&mut self, ident: Ident, tps: Vec<P<Ty>> , args: Vec<@Expr> ) -> ast::Expr_ {\n         ExprMethodCall(ident, tps, args)\n     }\n \n     pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: ~[P<Ty>]) -> ast::Expr_ {\n+    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: Vec<P<Ty>> ) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n@@ -1754,7 +1765,7 @@ impl Parser {\n                 let lit = @spanned(lo, hi, LitNil);\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n-            let mut es = ~[self.parse_expr()];\n+            let mut es = vec!(self.parse_expr());\n             self.commit_expr(*es.last().unwrap(), &[], &[token::COMMA, token::RPAREN]);\n             while self.token == token::COMMA {\n                 self.bump();\n@@ -1770,7 +1781,7 @@ impl Parser {\n             self.commit_expr_expecting(*es.last().unwrap(), token::RPAREN);\n \n             return if es.len() == 1 && !trailing_comma {\n-                self.mk_expr(lo, hi, ExprParen(es[0]))\n+                self.mk_expr(lo, hi, ExprParen(*es.get(0)))\n             }\n             else {\n                 self.mk_expr(lo, hi, ExprTup(es))\n@@ -1786,8 +1797,8 @@ impl Parser {\n             let decl = self.parse_proc_decl();\n             let body = self.parse_expr();\n             let fakeblock = P(ast::Block {\n-                view_items: ~[],\n-                stmts: ~[],\n+                view_items: Vec::new(),\n+                stmts: Vec::new(),\n                 expr: Some(body),\n                 id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n@@ -1840,7 +1851,7 @@ impl Parser {\n             if self.token == token::RBRACKET {\n                 // Empty vector.\n                 self.bump();\n-                ex = ExprVec(~[], mutbl);\n+                ex = ExprVec(Vec::new(), mutbl);\n             } else {\n                 // Nonempty vector.\n                 let first_expr = self.parse_expr();\n@@ -1860,11 +1871,13 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_expr()\n                     );\n-                    ex = ExprVec(~[first_expr] + remaining_exprs, mutbl);\n+                    let mut exprs = vec!(first_expr);\n+                    exprs.push_all_move(remaining_exprs);\n+                    ex = ExprVec(exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n                     self.expect(&token::RBRACKET);\n-                    ex = ExprVec(~[first_expr], mutbl);\n+                    ex = ExprVec(vec!(first_expr), mutbl);\n                 }\n             }\n             hi = self.last_span.hi;\n@@ -1919,7 +1932,7 @@ impl Parser {\n                 if self.looking_at_struct_literal() {\n                     // It's a struct literal.\n                     self.bump();\n-                    let mut fields = ~[];\n+                    let mut fields = Vec::new();\n                     let mut base = None;\n \n                     while self.token != token::RBRACE {\n@@ -1981,7 +1994,7 @@ impl Parser {\n                         self.expect(&token::LT);\n                         self.parse_generic_values_after_lt()\n                     } else {\n-                        (opt_vec::Empty, ~[])\n+                        (opt_vec::Empty, Vec::new())\n                     };\n \n                     // expr.f() method call\n@@ -2143,7 +2156,7 @@ impl Parser {\n \n                 // Parse the open delimiter.\n                 self.open_braces.push(self.span);\n-                let mut result = ~[parse_any_tt_tok(self)];\n+                let mut result = vec!(parse_any_tt_tok(self));\n \n                 let trees =\n                     self.parse_seq_to_before_end(&close_delim,\n@@ -2163,15 +2176,15 @@ impl Parser {\n \n     // parse a stream of tokens into a list of TokenTree's,\n     // up to EOF.\n-    pub fn parse_all_token_trees(&mut self) -> ~[TokenTree] {\n-        let mut tts = ~[];\n+    pub fn parse_all_token_trees(&mut self) -> Vec<TokenTree> {\n+        let mut tts = Vec::new();\n         while self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n     }\n \n-    pub fn parse_matchers(&mut self) -> ~[Matcher] {\n+    pub fn parse_matchers(&mut self) -> Vec<Matcher> {\n         // unification of Matcher's and TokenTree's would vastly improve\n         // the interpolation of Matcher's\n         maybe_whole!(self, NtMatchers);\n@@ -2192,8 +2205,8 @@ impl Parser {\n     pub fn parse_matcher_subseq_upto(&mut self,\n                                      name_idx: @Cell<uint>,\n                                      ket: &token::Token)\n-                                     -> ~[Matcher] {\n-        let mut ret_val = ~[];\n+                                     -> Vec<Matcher> {\n+        let mut ret_val = Vec::new();\n         let mut lparens = 0u;\n \n         while self.token != *ket || lparens > 0u {\n@@ -2478,7 +2491,7 @@ impl Parser {\n                     _ => {\n                         // No argument list - `do foo {`\n                         P(FnDecl {\n-                            inputs: ~[],\n+                            inputs: Vec::new(),\n                             output: P(Ty {\n                                 id: ast::DUMMY_NODE_ID,\n                                 node: TyInfer,\n@@ -2513,8 +2526,8 @@ impl Parser {\n         let decl = parse_decl(self);\n         let body = parse_body(self);\n         let fakeblock = P(ast::Block {\n-            view_items: ~[],\n-            stmts: ~[],\n+            view_items: Vec::new(),\n+            stmts: Vec::new(),\n             expr: Some(body),\n             id: ast::DUMMY_NODE_ID,\n             rules: DefaultBlock,\n@@ -2601,7 +2614,7 @@ impl Parser {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n-        let mut arms: ~[Arm] = ~[];\n+        let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n@@ -2622,8 +2635,8 @@ impl Parser {\n             }\n \n             let blk = P(ast::Block {\n-                view_items: ~[],\n-                stmts: ~[],\n+                view_items: Vec::new(),\n+                stmts: Vec::new(),\n                 expr: Some(expr),\n                 id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n@@ -2662,8 +2675,8 @@ impl Parser {\n     }\n \n     // parse patterns, separated by '|' s\n-    fn parse_pats(&mut self) -> ~[@Pat] {\n-        let mut pats = ~[];\n+    fn parse_pats(&mut self) -> Vec<@Pat> {\n+        let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n@@ -2673,10 +2686,10 @@ impl Parser {\n \n     fn parse_pat_vec_elements(\n         &mut self,\n-    ) -> (~[@Pat], Option<@Pat>, ~[@Pat]) {\n-        let mut before = ~[];\n+    ) -> (Vec<@Pat> , Option<@Pat>, Vec<@Pat> ) {\n+        let mut before = Vec::new();\n         let mut slice = None;\n-        let mut after = ~[];\n+        let mut after = Vec::new();\n         let mut first = true;\n         let mut before_slice = true;\n \n@@ -2733,8 +2746,8 @@ impl Parser {\n     }\n \n     // parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&mut self) -> (~[ast::FieldPat], bool) {\n-        let mut fields = ~[];\n+    fn parse_pat_fields(&mut self) -> (Vec<ast::FieldPat> , bool) {\n+        let mut fields = Vec::new();\n         let mut etc = false;\n         let mut first = true;\n         while self.token != token::RBRACE {\n@@ -2900,7 +2913,7 @@ impl Parser {\n                 let expr = self.mk_expr(lo, hi, ExprLit(lit));\n                 pat = PatLit(expr);\n             } else {\n-                let mut fields = ~[self.parse_pat()];\n+                let mut fields = vec!(self.parse_pat());\n                 if self.look_ahead(1, |t| *t != token::RPAREN) {\n                     while self.token == token::COMMA {\n                         self.bump();\n@@ -3002,7 +3015,7 @@ impl Parser {\n                         pat = PatStruct(enum_path, fields, etc);\n                     }\n                     _ => {\n-                        let mut args: ~[@Pat] = ~[];\n+                        let mut args: Vec<@Pat> = Vec::new();\n                         match self.token {\n                           token::LPAREN => {\n                             let is_star = self.look_ahead(1, |t| {\n@@ -3128,7 +3141,7 @@ impl Parser {\n \n     // parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n-                         attrs: ~[Attribute]) -> StructField {\n+                         attrs: Vec<Attribute> ) -> StructField {\n         let lo = self.span.lo;\n         if !is_plain_ident(&self.token) {\n             self.fatal(\"expected ident\");\n@@ -3146,7 +3159,7 @@ impl Parser {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&mut self, item_attrs: ~[Attribute]) -> @Stmt {\n+    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute> ) -> @Stmt {\n         maybe_whole!(self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n@@ -3229,7 +3242,7 @@ impl Parser {\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n-                            Inherited, ~[/*no attrs*/]))),\n+                            Inherited, Vec::new(/*no attrs*/)))),\n                     ast::DUMMY_NODE_ID));\n             }\n \n@@ -3275,12 +3288,12 @@ impl Parser {\n         }\n         self.expect(&token::LBRACE);\n \n-        return self.parse_block_tail_(lo, DefaultBlock, ~[]);\n+        return self.parse_block_tail_(lo, DefaultBlock, Vec::new());\n     }\n \n     // parse a block. Inner attrs are allowed.\n     fn parse_inner_attrs_and_block(&mut self)\n-        -> (~[Attribute], P<Block>) {\n+        -> (Vec<Attribute> , P<Block>) {\n \n         maybe_whole!(pair_empty self, NtBlock);\n \n@@ -3299,13 +3312,13 @@ impl Parser {\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n-        self.parse_block_tail_(lo, s, ~[])\n+        self.parse_block_tail_(lo, s, Vec::new())\n     }\n \n     // parse the rest of a block expression or function body\n     fn parse_block_tail_(&mut self, lo: BytePos, s: BlockCheckMode,\n-                         first_item_attrs: ~[Attribute]) -> P<Block> {\n-        let mut stmts = ~[];\n+                         first_item_attrs: Vec<Attribute> ) -> P<Block> {\n+        let mut stmts = Vec::new();\n         let mut expr = None;\n \n         // wouldn't it be more uniform to parse view items only, here?\n@@ -3328,12 +3341,12 @@ impl Parser {\n         while self.token != token::RBRACE {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n-            attributes_box.push_all(self.parse_outer_attributes());\n+            attributes_box.push_all(self.parse_outer_attributes().as_slice());\n             match self.token {\n                 token::SEMI => {\n                     if !attributes_box.is_empty() {\n                         self.span_err(self.last_span, \"expected item after attributes\");\n-                        attributes_box = ~[];\n+                        attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n                 }\n@@ -3342,7 +3355,7 @@ impl Parser {\n                 }\n                 _ => {\n                     let stmt = self.parse_stmt(attributes_box);\n-                    attributes_box = ~[];\n+                    attributes_box = Vec::new();\n                     match stmt.node {\n                         StmtExpr(e, stmt_id) => {\n                             // expression without semicolon\n@@ -3510,7 +3523,7 @@ impl Parser {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n+    fn parse_generic_values_after_lt(&mut self) -> (OptVec<ast::Lifetime>, Vec<P<Ty>> ) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n@@ -3519,9 +3532,9 @@ impl Parser {\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n-                     -> (~[Arg], bool) {\n+                     -> (Vec<Arg> , bool) {\n         let sp = self.span;\n-        let mut args: ~[Option<Arg>] =\n+        let mut args: Vec<Option<Arg>> =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n@@ -3716,7 +3729,7 @@ impl Parser {\n                     fn_inputs\n                 }\n                 token::RPAREN => {\n-                    ~[Arg::new_self(explicit_self_sp, mutbl_self)]\n+                    vec!(Arg::new_self(explicit_self_sp, mutbl_self))\n                 }\n                 _ => {\n                     let token_str = self.this_token_to_str();\n@@ -3749,7 +3762,7 @@ impl Parser {\n     fn parse_fn_block_decl(&mut self) -> P<FnDecl> {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n-                ~[]\n+                Vec::new()\n             } else {\n                 self.parse_unspanned_seq(\n                     &token::BINOP(token::OR),\n@@ -3812,7 +3825,7 @@ impl Parser {\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: Item_, vis: Visibility,\n-               attrs: ~[Attribute]) -> @Item {\n+               attrs: Vec<Attribute> ) -> @Item {\n         @Item {\n             ident: ident,\n             attrs: attrs,\n@@ -3832,7 +3845,7 @@ impl Parser {\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self, already_parsed_attrs: Option<~[Attribute]>) -> @Method {\n+    fn parse_method(&mut self, already_parsed_attrs: Option<Vec<Attribute> >) -> @Method {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -3851,7 +3864,7 @@ impl Parser {\n \n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n-        let attrs = vec::append(attrs, inner_attrs);\n+        let attrs = vec_ng::append(attrs, inner_attrs.as_slice());\n         @ast::Method {\n             ident: ident,\n             attrs: attrs,\n@@ -3877,7 +3890,7 @@ impl Parser {\n             self.bump();\n             traits = self.parse_trait_ref_list(&token::LBRACE);\n         } else {\n-            traits = ~[];\n+            traits = Vec::new();\n         }\n \n         let meths = self.parse_trait_methods();\n@@ -3925,7 +3938,7 @@ impl Parser {\n             None\n         };\n \n-        let mut meths = ~[];\n+        let mut meths = Vec::new();\n         self.expect(&token::LBRACE);\n         let (inner_attrs, next) = self.parse_inner_attrs_and_next();\n         let mut method_attrs = Some(next);\n@@ -3948,7 +3961,7 @@ impl Parser {\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> ~[TraitRef] {\n+    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> Vec<TraitRef> {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n@@ -3961,13 +3974,13 @@ impl Parser {\n         let class_name = self.parse_ident();\n         let generics = self.parse_generics();\n \n-        let mut fields: ~[StructField];\n+        let mut fields: Vec<StructField> ;\n         let is_tuple_like;\n \n         if self.eat(&token::LBRACE) {\n             // It's a record-like struct.\n             is_tuple_like = false;\n-            fields = ~[];\n+            fields = Vec::new();\n             while self.token != token::RBRACE {\n                 fields.push(self.parse_struct_decl_field());\n             }\n@@ -3998,7 +4011,7 @@ impl Parser {\n         } else if self.eat(&token::SEMI) {\n             // It's a unit-like struct.\n             is_tuple_like = true;\n-            fields = ~[];\n+            fields = Vec::new();\n         } else {\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `\\\\{`, `(`, or `;` after struct \\\n@@ -4019,7 +4032,7 @@ impl Parser {\n     // parse a structure field declaration\n     pub fn parse_single_struct_field(&mut self,\n                                      vis: Visibility,\n-                                     attrs: ~[Attribute])\n+                                     attrs: Vec<Attribute> )\n                                      -> StructField {\n         let a_var = self.parse_name_and_ty(vis, attrs);\n         match self.token {\n@@ -4064,7 +4077,7 @@ impl Parser {\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&mut self,\n                        term: token::Token,\n-                       first_item_attrs: ~[Attribute])\n+                       first_item_attrs: Vec<Attribute> )\n                        -> Mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n@@ -4074,7 +4087,7 @@ impl Parser {\n             items: starting_items,\n             ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: ~[@Item] = starting_items;\n+        let mut items: Vec<@Item> = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n         // don't think this other loop is even necessary....\n@@ -4083,7 +4096,8 @@ impl Parser {\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n-                attrs = attrs_remaining + attrs;\n+                attrs = vec_ng::append(attrs_remaining.clone(),\n+                                       attrs.as_slice());\n                 first = false;\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n@@ -4162,10 +4176,10 @@ impl Parser {\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n-                    -> (ast::Item_, ~[ast::Attribute]) {\n+                    -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.cm.span_to_filename(self.span));\n         prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(self.mod_path_stack);\n+        let mod_path = Path::new(\".\").join_many(self.mod_path_stack.as_slice());\n         let dir_path = prefix.join(&mod_path);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {\n@@ -4195,14 +4209,14 @@ impl Parser {\n         };\n \n         self.eval_src_mod_from_path(file_path,\n-                                    outer_attrs.to_owned(),\n+                                    outer_attrs.iter().map(|x| *x).collect(),\n                                     id_sp)\n     }\n \n     fn eval_src_mod_from_path(&mut self,\n                               path: Path,\n-                              outer_attrs: ~[ast::Attribute],\n-                              id_sp: Span) -> (ast::Item_, ~[ast::Attribute]) {\n+                              outer_attrs: Vec<ast::Attribute> ,\n+                              id_sp: Span) -> (ast::Item_, Vec<ast::Attribute> ) {\n         {\n             let mut included_mod_stack = self.sess\n                                              .included_mod_stack\n@@ -4232,7 +4246,7 @@ impl Parser {\n                                      &path,\n                                      id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = vec::append(outer_attrs, inner);\n+        let mod_attrs = vec_ng::append(outer_attrs, inner.as_slice());\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         {\n@@ -4246,7 +4260,7 @@ impl Parser {\n \n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&mut self, vis: ast::Visibility,\n-                             attrs: ~[Attribute]) -> @ForeignItem {\n+                             attrs: Vec<Attribute> ) -> @ForeignItem {\n         let lo = self.span.lo;\n \n         // Parse obsolete purity.\n@@ -4269,7 +4283,7 @@ impl Parser {\n \n     // parse a static item from a foreign module\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility,\n-                                 attrs: ~[Attribute]) -> @ForeignItem {\n+                                 attrs: Vec<Attribute> ) -> @ForeignItem {\n         let lo = self.span.lo;\n \n         self.expect_keyword(keywords::Static);\n@@ -4303,7 +4317,7 @@ impl Parser {\n     // parse_foreign_items.\n     fn parse_foreign_mod_items(&mut self,\n                                abis: AbiSet,\n-                               first_item_attrs: ~[Attribute])\n+                               first_item_attrs: Vec<Attribute> )\n                                -> ForeignMod {\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n@@ -4332,7 +4346,7 @@ impl Parser {\n     fn parse_item_extern_crate(&mut self,\n                                 lo: BytePos,\n                                 visibility: Visibility,\n-                                attrs: ~[Attribute])\n+                                attrs: Vec<Attribute> )\n                                 -> ItemOrViewItem {\n \n         let (maybe_path, ident) = match self.token {\n@@ -4377,7 +4391,7 @@ impl Parser {\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n                               visibility: Visibility,\n-                              attrs: ~[Attribute])\n+                              attrs: Vec<Attribute> )\n                               -> ItemOrViewItem {\n \n         self.expect(&token::LBRACE);\n@@ -4410,7 +4424,7 @@ impl Parser {\n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n     fn parse_struct_def(&mut self) -> @StructDef {\n-        let mut fields: ~[StructField] = ~[];\n+        let mut fields: Vec<StructField> = Vec::new();\n         while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n@@ -4424,7 +4438,7 @@ impl Parser {\n \n     // parse the part of an \"enum\" decl following the '{'\n     fn parse_enum_def(&mut self, _generics: &ast::Generics) -> EnumDef {\n-        let mut variants = ~[];\n+        let mut variants = Vec::new();\n         let mut all_nullary = true;\n         let mut have_disr = false;\n         while self.token != token::RBRACE {\n@@ -4435,7 +4449,7 @@ impl Parser {\n \n             let ident;\n             let kind;\n-            let mut args = ~[];\n+            let mut args = Vec::new();\n             let mut disr_expr = None;\n             ident = self.parse_ident();\n             if self.eat(&token::LBRACE) {\n@@ -4462,7 +4476,7 @@ impl Parser {\n                 disr_expr = Some(self.parse_expr());\n                 kind = TupleVariantKind(args);\n             } else {\n-                kind = TupleVariantKind(~[]);\n+                kind = TupleVariantKind(Vec::new());\n             }\n \n             let vr = ast::Variant_ {\n@@ -4551,13 +4565,13 @@ impl Parser {\n     // NB: this function no longer parses the items inside an\n     // extern crate.\n     fn parse_item_or_view_item(&mut self,\n-                               attrs: ~[Attribute],\n+                               attrs: Vec<Attribute> ,\n                                macros_allowed: bool)\n                                -> ItemOrViewItem {\n         match self.token {\n             INTERPOLATED(token::NtItem(item)) => {\n                 self.bump();\n-                let new_attrs = vec::append(attrs, item.attrs);\n+                let new_attrs = vec_ng::append(attrs, item.attrs.as_slice());\n                 return IoviItem(@Item {\n                     attrs: new_attrs,\n                     ..(*item).clone()\n@@ -4663,7 +4677,8 @@ impl Parser {\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_mod(attrs.as_slice());\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,\n@@ -4732,7 +4747,7 @@ impl Parser {\n \n     // parse a foreign item; on failure, return IoviNone.\n     fn parse_foreign_item(&mut self,\n-                          attrs: ~[Attribute],\n+                          attrs: Vec<Attribute> ,\n                           macros_allowed: bool)\n                           -> ItemOrViewItem {\n         maybe_whole!(iovi self, NtItem);\n@@ -4756,7 +4771,7 @@ impl Parser {\n     // this is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n         &mut self,\n-        attrs: ~[Attribute],\n+        attrs: Vec<Attribute> ,\n         macros_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n@@ -4820,7 +4835,7 @@ impl Parser {\n         return IoviNone(attrs);\n     }\n \n-    pub fn parse_item(&mut self, attrs: ~[Attribute]) -> Option<@Item> {\n+    pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<@Item> {\n         match self.parse_item_or_view_item(attrs, true) {\n             IoviNone(_) => None,\n             IoviViewItem(_) =>\n@@ -4854,20 +4869,20 @@ impl Parser {\n             let path = ast::Path {\n                 span: mk_sp(lo, self.span.hi),\n                 global: false,\n-                segments: ~[]\n+                segments: Vec::new()\n             };\n             return @spanned(lo, self.span.hi,\n                             ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n         }\n \n         let first_ident = self.parse_ident();\n-        let mut path = ~[first_ident];\n+        let mut path = vec!(first_ident);\n         match self.token {\n           token::EQ => {\n             // x = foo::bar\n             self.bump();\n             let path_lo = self.span.lo;\n-            path = ~[self.parse_ident()];\n+            path = vec!(self.parse_ident());\n             while self.token == token::MOD_SEP {\n                 self.bump();\n                 let id = self.parse_ident();\n@@ -4947,7 +4962,7 @@ impl Parser {\n           }\n           _ => ()\n         }\n-        let last = path[path.len() - 1u];\n+        let last = *path.get(path.len() - 1u);\n         let path = ast::Path {\n             span: mk_sp(lo, self.span.hi),\n             global: false,\n@@ -4965,8 +4980,8 @@ impl Parser {\n     }\n \n     // matches view_paths = view_path | view_path , view_paths\n-    fn parse_view_paths(&mut self) -> ~[@ViewPath] {\n-        let mut vp = ~[self.parse_view_path()];\n+    fn parse_view_paths(&mut self) -> Vec<@ViewPath> {\n+        let mut vp = vec!(self.parse_view_path());\n         while self.token == token::COMMA {\n             self.bump();\n             self.obsolete(self.last_span, ObsoleteMultipleImport);\n@@ -4980,15 +4995,16 @@ impl Parser {\n     // - mod_items uses extern_mod_allowed = true\n     // - block_tail_ uses extern_mod_allowed = false\n     fn parse_items_and_view_items(&mut self,\n-                                  first_item_attrs: ~[Attribute],\n+                                  first_item_attrs: Vec<Attribute> ,\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n-        let mut attrs = vec::append(first_item_attrs,\n-                                    self.parse_outer_attributes());\n+        let mut attrs = vec_ng::append(first_item_attrs,\n+                                       self.parse_outer_attributes()\n+                                           .as_slice());\n         // First, parse view items.\n-        let mut view_items : ~[ast::ViewItem] = ~[];\n-        let mut items = ~[];\n+        let mut view_items : Vec<ast::ViewItem> = Vec::new();\n+        let mut items = Vec::new();\n \n         // I think this code would probably read better as a single\n         // loop with a mutable three-state-variable (for extern crates,\n@@ -5001,7 +5017,7 @@ impl Parser {\n                         attrs_remaining: attrs,\n                         view_items: view_items,\n                         items: items,\n-                        foreign_items: ~[]\n+                        foreign_items: Vec::new()\n                     }\n                 }\n                 IoviViewItem(view_item) => {\n@@ -5056,18 +5072,19 @@ impl Parser {\n             attrs_remaining: attrs,\n             view_items: view_items,\n             items: items,\n-            foreign_items: ~[]\n+            foreign_items: Vec::new()\n         }\n     }\n \n     // Parses a sequence of foreign items. Stops when it finds program\n     // text that can't be parsed as an item\n-    fn parse_foreign_items(&mut self, first_item_attrs: ~[Attribute],\n+    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute> ,\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n-        let mut attrs = vec::append(first_item_attrs,\n-                                    self.parse_outer_attributes());\n-        let mut foreign_items = ~[];\n+        let mut attrs = vec_ng::append(first_item_attrs,\n+                                       self.parse_outer_attributes()\n+                                           .as_slice());\n+        let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n                 IoviNone(returned_attrs) => {\n@@ -5095,8 +5112,8 @@ impl Parser {\n \n         ParsedItemsAndViewItems {\n             attrs_remaining: attrs,\n-            view_items: ~[],\n-            items: ~[],\n+            view_items: Vec::new(),\n+            items: Vec::new(),\n             foreign_items: foreign_items\n         }\n     }"}, {"sha": "1499a1b4c19be37efb990b1af9b7c0b0d81d36b4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,6 +21,7 @@ use std::char;\n use std::fmt;\n use std::local_data;\n use std::path::BytesContainer;\n+use std::vec_ng::Vec;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n@@ -115,7 +116,7 @@ pub enum Nonterminal {\n     NtAttr(@ast::Attribute), // #[foo]\n     NtPath(~ast::Path),\n     NtTT(  @ast::TokenTree), // needs @ed to break a circularity\n-    NtMatchers(~[ast::Matcher])\n+    NtMatchers(Vec<ast::Matcher> )\n }\n \n impl fmt::Show for Nonterminal {\n@@ -412,13 +413,11 @@ macro_rules! declare_special_idents_and_keywords {(\n         // The indices here must correspond to the numbers in\n         // special_idents, in Keyword to_ident(), and in static\n         // constants below.\n-        let init_vec = ~[\n-            $( $si_str, )*\n-            $( $sk_str, )*\n-            $( $rk_str, )*\n-        ];\n-\n-        interner::StrInterner::prefill(init_vec)\n+        let mut init_vec = Vec::new();\n+        $(init_vec.push($si_str);)*\n+        $(init_vec.push($sk_str);)*\n+        $(init_vec.push($rk_str);)*\n+        interner::StrInterner::prefill(init_vec.as_slice())\n     }\n }}\n "}, {"sha": "e9e0e4835933bd8785749573299bd6f778929b1b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -62,7 +62,7 @@\n  */\n \n use std::io;\n-use std::vec;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Eq)]\n pub enum Breaks {\n@@ -119,7 +119,7 @@ pub fn tok_str(t: Token) -> ~str {\n     }\n }\n \n-pub fn buf_str(toks: ~[Token], szs: ~[int], left: uint, right: uint,\n+pub fn buf_str(toks: Vec<Token> , szs: Vec<int> , left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n@@ -131,7 +131,7 @@ pub fn buf_str(toks: ~[Token], szs: ~[int], left: uint, right: uint,\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(format!(\"{}={}\", szs[i], tok_str(toks[i].clone())));\n+        s.push_str(format!(\"{}={}\", szs.get(i), tok_str(toks.get(i).clone())));\n         i += 1u;\n         i %= n;\n     }\n@@ -156,9 +156,9 @@ pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: ~[Token] = vec::from_elem(n, Eof);\n-    let size: ~[int] = vec::from_elem(n, 0);\n-    let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n+    let token: Vec<Token> = Vec::from_elem(n, Eof);\n+    let size: Vec<int> = Vec::from_elem(n, 0);\n+    let scan_stack: Vec<uint> = Vec::from_elem(n, 0u);\n     Printer {\n         out: out,\n         buf_len: n,\n@@ -174,7 +174,7 @@ pub fn mk_printer(out: ~io::Writer, linewidth: uint) -> Printer {\n         scan_stack_empty: true,\n         top: 0,\n         bottom: 0,\n-        print_stack: ~[],\n+        print_stack: Vec::new(),\n         pending_indentation: 0\n     }\n }\n@@ -264,8 +264,8 @@ pub struct Printer {\n     space: int, // number of spaces left on line\n     left: uint, // index of left side of input stream\n     right: uint, // index of right side of input stream\n-    token: ~[Token], // ring-buffr stream goes through\n-    size: ~[int], // ring-buffer of calculated sizes\n+    token: Vec<Token> , // ring-buffr stream goes through\n+    size: Vec<int> , // ring-buffer of calculated sizes\n     left_total: int, // running size of stream \"...left\"\n     right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -274,32 +274,33 @@ pub struct Printer {\n     // Begin (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    scan_stack: ~[uint],\n+    scan_stack: Vec<uint> ,\n     scan_stack_empty: bool, // top==bottom disambiguator\n     top: uint, // index of top of scan_stack\n     bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    print_stack: ~[PrintStackElem],\n+    print_stack: Vec<PrintStackElem> ,\n     // buffered indentation to avoid writing trailing whitespace\n     pending_indentation: int,\n }\n \n impl Printer {\n     pub fn last_token(&mut self) -> Token {\n-        self.token[self.right].clone()\n+        (*self.token.get(self.right)).clone()\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n-        self.token[self.right] = t;\n+        *self.token.get_mut(self.right) = t;\n     }\n     pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n         match t {\n           Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                let left = self.token[self.left].clone();\n-                try!(self.advance_left(left, self.size[self.left]));\n+                let left = (*self.token.get(self.left)).clone();\n+                let left_size = *self.size.get(self.left);\n+                try!(self.advance_left(left, left_size));\n             }\n             self.indent(0);\n             Ok(())\n@@ -313,8 +314,8 @@ impl Printer {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n-            self.token[self.right] = t;\n-            self.size[self.right] = -self.right_total;\n+            *self.token.get_mut(self.right) = t;\n+            *self.size.get_mut(self.right) = -self.right_total;\n             self.scan_push(self.right);\n             Ok(())\n           }\n@@ -325,8 +326,8 @@ impl Printer {\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t;\n-                self.size[self.right] = -1;\n+                *self.token.get_mut(self.right) = t;\n+                *self.size.get_mut(self.right) = -1;\n                 self.scan_push(self.right);\n                 Ok(())\n             }\n@@ -342,8 +343,8 @@ impl Printer {\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n             self.scan_push(self.right);\n-            self.token[self.right] = t;\n-            self.size[self.right] = -self.right_total;\n+            *self.token.get_mut(self.right) = t;\n+            *self.size.get_mut(self.right) = -self.right_total;\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n@@ -356,8 +357,8 @@ impl Printer {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n                        *s, self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t.clone();\n-                self.size[self.right] = len;\n+                *self.token.get_mut(self.right) = t.clone();\n+                *self.size.get_mut(self.right) = len;\n                 self.right_total += len;\n                 self.check_stream()\n             }\n@@ -371,13 +372,15 @@ impl Printer {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n             if !self.scan_stack_empty {\n-                if self.left == self.scan_stack[self.bottom] {\n+                if self.left == *self.scan_stack.get(self.bottom) {\n                     debug!(\"setting {} to infinity and popping\", self.left);\n-                    self.size[self.scan_pop_bottom()] = SIZE_INFINITY;\n+                    let scanned = self.scan_pop_bottom();\n+                    *self.size.get_mut(scanned) = SIZE_INFINITY;\n                 }\n             }\n-            let left = self.token[self.left].clone();\n-            try!(self.advance_left(left, self.size[self.left]));\n+            let left = (*self.token.get(self.left)).clone();\n+            let left_size = *self.size.get(self.left);\n+            try!(self.advance_left(left, left_size));\n             if self.left != self.right {\n                 try!(self.check_stream());\n             }\n@@ -393,26 +396,30 @@ impl Printer {\n             self.top %= self.buf_len;\n             assert!((self.top != self.bottom));\n         }\n-        self.scan_stack[self.top] = x;\n+        *self.scan_stack.get_mut(self.top) = x;\n     }\n     pub fn scan_pop(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.top];\n+        let x = *self.scan_stack.get(self.top);\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n-        } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n+        } else {\n+            self.top += self.buf_len - 1u; self.top %= self.buf_len;\n+        }\n         return x;\n     }\n     pub fn scan_top(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        return self.scan_stack[self.top];\n+        return *self.scan_stack.get(self.top);\n     }\n     pub fn scan_pop_bottom(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.bottom];\n+        let x = *self.scan_stack.get(self.bottom);\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n-        } else { self.bottom += 1u; self.bottom %= self.buf_len; }\n+        } else {\n+            self.bottom += 1u; self.bottom %= self.buf_len;\n+        }\n         return x;\n     }\n     pub fn advance_right(&mut self) {\n@@ -435,8 +442,9 @@ impl Printer {\n             if self.left != self.right {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n-                let left = self.token[self.left].clone();\n-                try!(self.advance_left(left, self.size[self.left]));\n+                let left = (*self.token.get(self.left)).clone();\n+                let left_size = *self.size.get(self.left);\n+                try!(self.advance_left(left, left_size));\n             }\n             ret\n         } else {\n@@ -446,22 +454,28 @@ impl Printer {\n     pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            match self.token[x] {\n-              Begin(_) => {\n+            match self.token.get(x) {\n+              &Begin(_) => {\n                 if k > 0 {\n-                    self.size[self.scan_pop()] = self.size[x] +\n+                    let popped = self.scan_pop();\n+                    *self.size.get_mut(popped) = *self.size.get(x) +\n                         self.right_total;\n                     self.check_stack(k - 1);\n                 }\n               }\n-              End => {\n+              &End => {\n                 // paper says + not =, but that makes no sense.\n-                self.size[self.scan_pop()] = 1;\n+                let popped = self.scan_pop();\n+                *self.size.get_mut(popped) = 1;\n                 self.check_stack(k + 1);\n               }\n               _ => {\n-                self.size[self.scan_pop()] = self.size[x] + self.right_total;\n-                if k > 0 { self.check_stack(k); }\n+                let popped = self.scan_pop();\n+                *self.size.get_mut(popped) = *self.size.get(x) +\n+                    self.right_total;\n+                if k > 0 {\n+                    self.check_stack(k);\n+                }\n               }\n             }\n         }\n@@ -481,7 +495,7 @@ impl Printer {\n         let print_stack = &mut self.print_stack;\n         let n = print_stack.len();\n         if n != 0u {\n-            print_stack[n - 1u]\n+            *print_stack.get(n - 1u)\n         } else {\n             PrintStackElem {\n                 offset: 0,"}, {"sha": "d027efc1d42f6247735b78b611590d6bf2d327c6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -33,6 +33,7 @@ use std::char;\n use std::str;\n use std::io;\n use std::io::MemWriter;\n+use std::vec_ng::Vec;\n \n // The &mut State is stored here to prevent recursive type.\n pub enum AnnNode<'a, 'b> {\n@@ -60,10 +61,10 @@ pub struct State<'a> {\n     s: pp::Printer,\n     cm: Option<@CodeMap>,\n     intr: @token::IdentInterner,\n-    comments: Option<~[comments::Comment]>,\n-    literals: Option<~[comments::Literal]>,\n+    comments: Option<Vec<comments::Comment> >,\n+    literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n-    boxes: RefCell<~[pp::Breaks]>,\n+    boxes: RefCell<Vec<pp::Breaks> >,\n     ann: &'a PpAnn\n }\n \n@@ -98,7 +99,7 @@ pub fn rust_printer_annotated<'a>(writer: ~io::Writer, ann: &'a PpAnn) -> State<\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: RefCell::new(~[]),\n+        boxes: RefCell::new(Vec::new()),\n         ann: ann\n     }\n }\n@@ -140,14 +141,14 @@ pub fn print_crate(cm: @CodeMap,\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: RefCell::new(~[]),\n+        boxes: RefCell::new(Vec::new()),\n         ann: ann\n     };\n     print_crate_(&mut s, krate)\n }\n \n pub fn print_crate_(s: &mut State, krate: &ast::Crate) -> io::IoResult<()> {\n-    try!(print_mod(s, &krate.module, krate.attrs));\n+    try!(print_mod(s, &krate.module, krate.attrs.as_slice()));\n     try!(print_remaining_comments(s));\n     try!(eof(&mut s.s));\n     Ok(())\n@@ -319,7 +320,7 @@ pub fn in_cbox(s: &mut State) -> bool {\n     let boxes = s.boxes.borrow();\n     let len = boxes.get().len();\n     if len == 0u { return false; }\n-    return boxes.get()[len - 1u] == pp::Consistent;\n+    return *boxes.get().get(len - 1u) == pp::Consistent;\n }\n \n pub fn hardbreak_if_not_bol(s: &mut State) -> io::IoResult<()> {\n@@ -463,7 +464,7 @@ pub fn print_type(s: &mut State, ty: &ast::Ty) -> io::IoResult<()> {\n         }\n         ast::TyTup(ref elts) => {\n             try!(popen(s));\n-            try!(commasep(s, Inconsistent, *elts, print_type_ref));\n+            try!(commasep(s, Inconsistent, elts.as_slice(), print_type_ref));\n             if elts.len() == 1 {\n                 try!(word(&mut s.s, \",\"));\n             }\n@@ -517,7 +518,7 @@ pub fn print_foreign_item(s: &mut State,\n                           item: &ast::ForeignItem) -> io::IoResult<()> {\n     try!(hardbreak_if_not_bol(s));\n     try!(maybe_print_comment(s, item.span.lo));\n-    try!(print_outer_attributes(s, item.attrs));\n+    try!(print_outer_attributes(s, item.attrs.as_slice()));\n     match item.node {\n         ast::ForeignItemFn(decl, ref generics) => {\n             try!(print_fn(s, decl, None, AbiSet::Rust(), item.ident, generics,\n@@ -545,7 +546,7 @@ pub fn print_foreign_item(s: &mut State,\n pub fn print_item(s: &mut State, item: &ast::Item) -> io::IoResult<()> {\n     try!(hardbreak_if_not_bol(s));\n     try!(maybe_print_comment(s, item.span.lo));\n-    try!(print_outer_attributes(s, item.attrs));\n+    try!(print_outer_attributes(s, item.attrs.as_slice()));\n     {\n         let ann_node = NodeItem(s, item);\n         try!(s.ann.pre(ann_node));\n@@ -580,21 +581,21 @@ pub fn print_item(s: &mut State, item: &ast::Item) -> io::IoResult<()> {\n             item.vis\n         ));\n         try!(word(&mut s.s, \" \"));\n-        try!(print_block_with_attrs(s, body, item.attrs));\n+        try!(print_block_with_attrs(s, body, item.attrs.as_slice()));\n       }\n       ast::ItemMod(ref _mod) => {\n         try!(head(s, visibility_qualified(item.vis, \"mod\")));\n         try!(print_ident(s, item.ident));\n         try!(nbsp(s));\n         try!(bopen(s));\n-        try!(print_mod(s, _mod, item.attrs));\n+        try!(print_mod(s, _mod, item.attrs.as_slice()));\n         try!(bclose(s, item.span));\n       }\n       ast::ItemForeignMod(ref nmod) => {\n         try!(head(s, \"extern\"));\n         try!(word_nbsp(s, nmod.abis.to_str()));\n         try!(bopen(s));\n-        try!(print_foreign_mod(s, nmod, item.attrs));\n+        try!(print_foreign_mod(s, nmod, item.attrs.as_slice()));\n         try!(bclose(s, item.span));\n       }\n       ast::ItemTy(ty, ref params) => {\n@@ -646,7 +647,7 @@ pub fn print_item(s: &mut State, item: &ast::Item) -> io::IoResult<()> {\n \n         try!(space(&mut s.s));\n         try!(bopen(s));\n-        try!(print_inner_attributes(s, item.attrs));\n+        try!(print_inner_attributes(s, item.attrs.as_slice()));\n         for meth in methods.iter() {\n            try!(print_method(s, *meth));\n         }\n@@ -706,7 +707,7 @@ pub fn print_enum_def(s: &mut State, enum_definition: &ast::EnumDef,\n     try!(print_ident(s, ident));\n     try!(print_generics(s, generics));\n     try!(space(&mut s.s));\n-    try!(print_variants(s, enum_definition.variants, span));\n+    try!(print_variants(s, enum_definition.variants.as_slice(), span));\n     Ok(())\n }\n \n@@ -717,7 +718,7 @@ pub fn print_variants(s: &mut State,\n     for &v in variants.iter() {\n         try!(space_if_not_bol(s));\n         try!(maybe_print_comment(s, v.span.lo));\n-        try!(print_outer_attributes(s, v.node.attrs));\n+        try!(print_outer_attributes(s, v.node.attrs.as_slice()));\n         try!(ibox(s, indent_unit));\n         try!(print_variant(s, v));\n         try!(word(&mut s.s, \",\"));\n@@ -761,7 +762,10 @@ pub fn print_struct(s: &mut State,\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n         if !struct_def.fields.is_empty() {\n             try!(popen(s));\n-            try!(commasep(s, Inconsistent, struct_def.fields, |s, field| {\n+            try!(commasep(s,\n+                          Inconsistent,\n+                          struct_def.fields.as_slice(),\n+                          |s, field| {\n                 match field.node.kind {\n                     ast::NamedField(..) => fail!(\"unexpected named field\"),\n                     ast::UnnamedField => {\n@@ -787,7 +791,8 @@ pub fn print_struct(s: &mut State,\n                 ast::NamedField(ident, visibility) => {\n                     try!(hardbreak_if_not_bol(s));\n                     try!(maybe_print_comment(s, field.span.lo));\n-                    try!(print_outer_attributes(s, field.node.attrs));\n+                    try!(print_outer_attributes(s,\n+                                                field.node.attrs.as_slice()));\n                     try!(print_visibility(s, visibility));\n                     try!(print_ident(s, ident));\n                     try!(word_nbsp(s, \":\"));\n@@ -857,7 +862,10 @@ pub fn print_variant(s: &mut State, v: &ast::Variant) -> io::IoResult<()> {\n                                      arg: &ast::VariantArg) -> io::IoResult<()> {\n                     print_type(s, arg.ty)\n                 }\n-                try!(commasep(s, Consistent, *args, print_variant_arg));\n+                try!(commasep(s,\n+                              Consistent,\n+                              args.as_slice(),\n+                              print_variant_arg));\n                 try!(pclose(s));\n             }\n         }\n@@ -881,7 +889,7 @@ pub fn print_variant(s: &mut State, v: &ast::Variant) -> io::IoResult<()> {\n pub fn print_ty_method(s: &mut State, m: &ast::TypeMethod) -> io::IoResult<()> {\n     try!(hardbreak_if_not_bol(s));\n     try!(maybe_print_comment(s, m.span.lo));\n-    try!(print_outer_attributes(s, m.attrs));\n+    try!(print_outer_attributes(s, m.attrs.as_slice()));\n     try!(print_ty_fn(s,\n                        None,\n                        None,\n@@ -907,12 +915,12 @@ pub fn print_trait_method(s: &mut State,\n pub fn print_method(s: &mut State, meth: &ast::Method) -> io::IoResult<()> {\n     try!(hardbreak_if_not_bol(s));\n     try!(maybe_print_comment(s, meth.span.lo));\n-    try!(print_outer_attributes(s, meth.attrs));\n+    try!(print_outer_attributes(s, meth.attrs.as_slice()));\n     try!(print_fn(s, meth.decl, Some(meth.purity), AbiSet::Rust(),\n                     meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                     meth.vis));\n     try!(word(&mut s.s, \" \"));\n-    print_block_with_attrs(s, meth.body, meth.attrs)\n+    print_block_with_attrs(s, meth.body, meth.attrs.as_slice())\n }\n \n pub fn print_outer_attributes(s: &mut State,\n@@ -1184,7 +1192,7 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n             try!(word(&mut s.s, \"mut\"));\n             if exprs.len() > 0u { try!(nbsp(s)); }\n         }\n-        try!(commasep_exprs(s, Inconsistent, *exprs));\n+        try!(commasep_exprs(s, Inconsistent, exprs.as_slice()));\n         try!(word(&mut s.s, \"]\"));\n         try!(end(s));\n       }\n@@ -1207,7 +1215,11 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n       ast::ExprStruct(ref path, ref fields, wth) => {\n         try!(print_path(s, path, true));\n         try!(word(&mut s.s, \"{\"));\n-        try!(commasep_cmnt(s, Consistent, (*fields), print_field, get_span));\n+        try!(commasep_cmnt(s,\n+                           Consistent,\n+                           fields.as_slice(),\n+                           print_field,\n+                           get_span));\n         match wth {\n             Some(expr) => {\n                 try!(ibox(s, indent_unit));\n@@ -1225,24 +1237,24 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n       }\n       ast::ExprTup(ref exprs) => {\n         try!(popen(s));\n-        try!(commasep_exprs(s, Inconsistent, *exprs));\n+        try!(commasep_exprs(s, Inconsistent, exprs.as_slice()));\n         if exprs.len() == 1 {\n             try!(word(&mut s.s, \",\"));\n         }\n         try!(pclose(s));\n       }\n       ast::ExprCall(func, ref args) => {\n         try!(print_expr(s, func));\n-        try!(print_call_post(s, *args));\n+        try!(print_call_post(s, args.as_slice()));\n       }\n       ast::ExprMethodCall(ident, ref tys, ref args) => {\n         let base_args = args.slice_from(1);\n-        try!(print_expr(s, args[0]));\n+        try!(print_expr(s, *args.get(0)));\n         try!(word(&mut s.s, \".\"));\n         try!(print_ident(s, ident));\n         if tys.len() > 0u {\n             try!(word(&mut s.s, \"::<\"));\n-            try!(commasep(s, Inconsistent, *tys, print_type_ref));\n+            try!(commasep(s, Inconsistent, tys.as_slice(), print_type_ref));\n             try!(word(&mut s.s, \">\"));\n         }\n         try!(print_call_post(s, base_args));\n@@ -1455,7 +1467,7 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n         try!(print_ident(s, id));\n         if tys.len() > 0u {\n             try!(word(&mut s.s, \"::<\"));\n-            try!(commasep(s, Inconsistent, *tys, print_type_ref));\n+            try!(commasep(s, Inconsistent, tys.as_slice(), print_type_ref));\n             try!(word(&mut s.s, \">\"));\n         }\n       }\n@@ -1649,7 +1661,7 @@ fn print_path_(s: &mut State,\n                 }\n                 try!(commasep(s,\n                                 Inconsistent,\n-                                segment.types.map_to_vec(|&t| t),\n+                                segment.types.map_to_vec(|&t| t).as_slice(),\n                                 print_type_ref));\n             }\n \n@@ -1708,7 +1720,7 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n           Some(ref args) => {\n             if !args.is_empty() {\n               try!(popen(s));\n-              try!(commasep(s, Inconsistent, *args,\n+              try!(commasep(s, Inconsistent, args.as_slice(),\n                               |s, &p| print_pat(s, p)));\n               try!(pclose(s));\n             } else { }\n@@ -1727,7 +1739,7 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n             Ok(())\n         }\n         fn get_span(f: &ast::FieldPat) -> codemap::Span { return f.pat.span; }\n-        try!(commasep_cmnt(s, Consistent, *fields,\n+        try!(commasep_cmnt(s, Consistent, fields.as_slice(),\n                              |s, f| print_field(s,f),\n                              get_span));\n         if etc {\n@@ -1738,7 +1750,10 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n       }\n       ast::PatTup(ref elts) => {\n         try!(popen(s));\n-        try!(commasep(s, Inconsistent, *elts, |s, &p| print_pat(s, p)));\n+        try!(commasep(s,\n+                      Inconsistent,\n+                      elts.as_slice(),\n+                      |s, &p| print_pat(s, p)));\n         if elts.len() == 1 {\n             try!(word(&mut s.s, \",\"));\n         }\n@@ -1761,7 +1776,10 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n         try!(word(&mut s.s, \"[\"));\n-        try!(commasep(s, Inconsistent, *before, |s, &p| print_pat(s, p)));\n+        try!(commasep(s,\n+                      Inconsistent,\n+                      before.as_slice(),\n+                      |s, &p| print_pat(s, p)));\n         for &p in slice.iter() {\n             if !before.is_empty() { try!(word_space(s, \",\")); }\n             match *p {\n@@ -1773,7 +1791,10 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) -> io::IoResult<()> {\n             try!(print_pat(s, p));\n             if !after.is_empty() { try!(word_space(s, \",\")); }\n         }\n-        try!(commasep(s, Inconsistent, *after, |s, &p| print_pat(s, p)));\n+        try!(commasep(s,\n+                      Inconsistent,\n+                      after.as_slice(),\n+                      |s, &p| print_pat(s, p)));\n         try!(word(&mut s.s, \"]\"));\n       }\n     }\n@@ -1842,7 +1863,7 @@ pub fn print_fn_args(s: &mut State, decl: &ast::FnDecl,\n     for &explicit_self in opt_explicit_self.iter() {\n         let m = match explicit_self {\n             ast::SelfStatic => ast::MutImmutable,\n-            _ => match decl.inputs[0].pat.node {\n+            _ => match decl.inputs.get(0).pat.node {\n                 ast::PatIdent(ast::BindByValue(m), _, _) => m,\n                 _ => ast::MutImmutable\n             }\n@@ -1981,12 +2002,12 @@ pub fn print_generics(s: &mut State,\n             }\n         }\n \n-        let mut ints = ~[];\n+        let mut ints = Vec::new();\n         for i in range(0u, total) {\n             ints.push(i);\n         }\n \n-        try!(commasep(s, Inconsistent, ints,\n+        try!(commasep(s, Inconsistent, ints.as_slice(),\n                         |s, &i| print_item(s, generics, i)));\n         try!(word(&mut s.s, \">\"));\n     }\n@@ -2041,7 +2062,7 @@ pub fn print_view_path(s: &mut State, vp: &ast::ViewPath) -> io::IoResult<()> {\n             try!(print_path(s, path, false));\n             try!(word(&mut s.s, \"::{\"));\n         }\n-        try!(commasep(s, Inconsistent, (*idents), |s, w| {\n+        try!(commasep(s, Inconsistent, idents.as_slice(), |s, w| {\n             print_ident(s, w.node.name)\n         }));\n         word(&mut s.s, \"}\")\n@@ -2057,7 +2078,7 @@ pub fn print_view_paths(s: &mut State,\n pub fn print_view_item(s: &mut State, item: &ast::ViewItem) -> io::IoResult<()> {\n     try!(hardbreak_if_not_bol(s));\n     try!(maybe_print_comment(s, item.span.lo));\n-    try!(print_outer_attributes(s, item.attrs));\n+    try!(print_outer_attributes(s, item.attrs.as_slice()));\n     try!(print_visibility(s, item.vis));\n     match item.node {\n         ast::ViewItemExternMod(id, ref optional_path, _) => {\n@@ -2073,7 +2094,7 @@ pub fn print_view_item(s: &mut State, item: &ast::ViewItem) -> io::IoResult<()>\n \n         ast::ViewItemUse(ref vps) => {\n             try!(head(s, \"use\"));\n-            try!(print_view_paths(s, *vps));\n+            try!(print_view_paths(s, vps.as_slice()));\n         }\n     }\n     try!(word(&mut s.s, \";\"));\n@@ -2103,7 +2124,7 @@ pub fn print_arg(s: &mut State, input: &ast::Arg) -> io::IoResult<()> {\n             match input.pat.node {\n                 ast::PatIdent(_, ref path, _) if\n                     path.segments.len() == 1 &&\n-                    path.segments[0].identifier.name ==\n+                    path.segments.get(0).identifier.name ==\n                         parse::token::special_idents::invalid.name => {\n                     // Do nothing.\n                 }\n@@ -2286,7 +2307,7 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n       ast::LitBinary(ref arr) => {\n         try!(ibox(s, indent_unit));\n         try!(word(&mut s.s, \"[\"));\n-        try!(commasep_cmnt(s, Inconsistent, *arr.borrow(),\n+        try!(commasep_cmnt(s, Inconsistent, arr.borrow().as_slice(),\n                              |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                              |_| lit.span));\n         try!(word(&mut s.s, \"]\"));\n@@ -2303,7 +2324,7 @@ pub fn next_lit(s: &mut State, pos: BytePos) -> Option<comments::Literal> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_cmnt_and_lit.cur_lit < lits.len() {\n-            let ltrl = (*lits)[s.cur_cmnt_and_lit.cur_lit].clone();\n+            let ltrl = (*(*lits).get(s.cur_cmnt_and_lit.cur_lit)).clone();\n             if ltrl.pos > pos { return None; }\n             s.cur_cmnt_and_lit.cur_lit += 1u;\n             if ltrl.pos == pos { return Some(ltrl); }\n@@ -2335,7 +2356,7 @@ pub fn print_comment(s: &mut State,\n         comments::Mixed => {\n             assert_eq!(cmnt.lines.len(), 1u);\n             try!(zerobreak(&mut s.s));\n-            try!(word(&mut s.s, cmnt.lines[0]));\n+            try!(word(&mut s.s, *cmnt.lines.get(0)));\n             try!(zerobreak(&mut s.s));\n         }\n         comments::Isolated => {\n@@ -2352,7 +2373,7 @@ pub fn print_comment(s: &mut State,\n         comments::Trailing => {\n             try!(word(&mut s.s, \" \"));\n             if cmnt.lines.len() == 1u {\n-                try!(word(&mut s.s, cmnt.lines[0]));\n+                try!(word(&mut s.s, *cmnt.lines.get(0)));\n                 try!(hardbreak(&mut s.s));\n             } else {\n                 try!(ibox(s, 0u));\n@@ -2414,7 +2435,7 @@ pub fn next_comment(s: &mut State) -> Option<comments::Comment> {\n     match s.comments {\n         Some(ref cmnts) => {\n             if s.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n-                Some(cmnts[s.cur_cmnt_and_lit.cur_cmnt].clone())\n+                Some((*cmnts.get(s.cur_cmnt_and_lit.cur_cmnt)).clone())\n             } else {\n                 None\n             }\n@@ -2535,12 +2556,14 @@ mod test {\n     use codemap;\n     use parse::token;\n \n+    use std::vec_ng::Vec;\n+\n     #[test]\n     fn test_fun_to_str() {\n         let abba_ident = token::str_to_ident(\"abba\");\n \n         let decl = ast::FnDecl {\n-            inputs: ~[],\n+            inputs: Vec::new(),\n             output: ast::P(ast::Ty {id: 0,\n                                     node: ast::TyNil,\n                                     span: codemap::DUMMY_SP}),\n@@ -2559,9 +2582,9 @@ mod test {\n \n         let var = codemap::respan(codemap::DUMMY_SP, ast::Variant_ {\n             name: ident,\n-            attrs: ~[],\n+            attrs: Vec::new(),\n             // making this up as I go.... ?\n-            kind: ast::TupleVariantKind(~[]),\n+            kind: ast::TupleVariantKind(Vec::new()),\n             id: 0,\n             disr_expr: None,\n             vis: ast::Public,"}, {"sha": "ba154a8d8923c12138a9e72a219e72f98913e22e", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -21,18 +21,19 @@ use std::cmp::Equiv;\n use std::fmt;\n use std::hash::Hash;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n pub struct Interner<T> {\n     priv map: RefCell<HashMap<T, Name>>,\n-    priv vect: RefCell<~[T]>,\n+    priv vect: RefCell<Vec<T> >,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl<T:Eq + Hash + Freeze + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(~[]),\n+            vect: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -68,7 +69,7 @@ impl<T:Eq + Hash + Freeze + Clone + 'static> Interner<T> {\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        vect.get()[idx].clone()\n+        (*vect.get().get(idx as uint)).clone()\n     }\n \n     pub fn len(&self) -> uint {\n@@ -134,15 +135,15 @@ impl RcStr {\n // &str rather than RcStr, resulting in less allocation.\n pub struct StrInterner {\n     priv map: RefCell<HashMap<RcStr, Name>>,\n-    priv vect: RefCell<~[RcStr]>,\n+    priv vect: RefCell<Vec<RcStr> >,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {\n             map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(~[]),\n+            vect: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -189,21 +190,21 @@ impl StrInterner {\n         let new_idx = self.len() as Name;\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = vect.get()[idx].clone();\n+        let existing = (*vect.get().get(idx as uint)).clone();\n         vect.get().push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n         let vect = self.vect.borrow();\n-        vect.get()[idx].clone()\n+        (*vect.get().get(idx as uint)).clone()\n     }\n \n     /// Returns this string with lifetime tied to the interner. Since\n     /// strings may never be removed from the interner, this is safe.\n     pub fn get_ref<'a>(&'a self, idx: Name) -> &'a str {\n         let vect = self.vect.borrow();\n-        let s: &str = vect.get()[idx].as_slice();\n+        let s: &str = vect.get().get(idx as uint).as_slice();\n         unsafe {\n             cast::transmute(s)\n         }"}, {"sha": "03fc30e2fd771dcca105928d87b21c5b152315aa", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -15,22 +15,24 @@ use parse::{new_parser_from_source_str};\n use parse::parser::Parser;\n use parse::token;\n \n+use std::vec_ng::Vec;\n+\n // map a string to tts, using a made-up filename: return both the TokenTree's\n // and the ParseSess\n-pub fn string_to_tts_and_sess (source_str : ~str) -> (~[ast::TokenTree], @ParseSess) {\n+pub fn string_to_tts_and_sess (source_str : ~str) -> (Vec<ast::TokenTree> , @ParseSess) {\n     let ps = new_parse_sess();\n     (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n }\n \n // map a string to tts, using a made-up filename:\n-pub fn string_to_tts(source_str : ~str) -> ~[ast::TokenTree] {\n+pub fn string_to_tts(source_str : ~str) -> Vec<ast::TokenTree> {\n     let (tts,_) = string_to_tts_and_sess(source_str);\n     tts\n }\n \n pub fn string_to_parser_and_sess(source_str: ~str) -> (Parser,@ParseSess) {\n     let ps = new_parse_sess();\n-    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n+    (new_parser_from_source_str(ps,Vec::new(),~\"bogofile\",source_str),ps)\n }\n \n // map string to parser (via tts)\n@@ -69,14 +71,14 @@ pub fn string_to_expr (source_str : ~str) -> @ast::Expr {\n // parse a string, return an item\n pub fn string_to_item (source_str : ~str) -> Option<@ast::Item> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_item(~[])\n+        p.parse_item(Vec::new())\n     })\n }\n \n // parse a string, return a stmt\n pub fn string_to_stmt(source_str : ~str) -> @ast::Stmt {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_stmt(~[])\n+        p.parse_stmt(Vec::new())\n     })\n }\n \n@@ -87,7 +89,7 @@ pub fn string_to_pat(source_str : ~str) -> @ast::Pat {\n }\n \n // convert a vector of strings to a vector of ast::Ident's\n-pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::Ident] {\n+pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n     ids.map(|u| token::str_to_ident(*u))\n }\n "}, {"sha": "9eb9871bb21414206e4ba7cdbd4c071e9d21fc37", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -7,14 +7,16 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use std::mem;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n pub enum SmallVector<T> {\n     priv Zero,\n     priv One(T),\n-    priv Many(~[T]),\n+    priv Many(Vec<T> ),\n }\n \n impl<T> Container for SmallVector<T> {\n@@ -46,7 +48,7 @@ impl<T> SmallVector<T> {\n         One(v)\n     }\n \n-    pub fn many(vs: ~[T]) -> SmallVector<T> {\n+    pub fn many(vs: Vec<T> ) -> SmallVector<T> {\n         Many(vs)\n     }\n \n@@ -56,7 +58,7 @@ impl<T> SmallVector<T> {\n             One(..) => {\n                 let one = mem::replace(self, Zero);\n                 match one {\n-                    One(v1) => mem::replace(self, Many(~[v1, v])),\n+                    One(v1) => mem::replace(self, Many(vec!(v1, v))),\n                     _ => unreachable!()\n                 };\n             }\n@@ -73,7 +75,7 @@ impl<T> SmallVector<T> {\n     pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match *self {\n             One(ref v) if idx == 0 => v,\n-            Many(ref vs) => &vs[idx],\n+            Many(ref vs) => vs.get(idx),\n             _ => fail!(\"out of bounds access\")\n         }\n     }\n@@ -104,7 +106,7 @@ impl<T> SmallVector<T> {\n pub enum MoveItems<T> {\n     priv ZeroIterator,\n     priv OneIterator(T),\n-    priv ManyIterator(vec::MoveItems<T>),\n+    priv ManyIterator(vec_ng::MoveItems<T>),\n }\n \n impl<T> Iterator<T> for MoveItems<T> {\n@@ -136,13 +138,15 @@ impl<T> Iterator<T> for MoveItems<T> {\n mod test {\n     use super::*;\n \n+    use std::vec_ng::Vec;\n+\n     #[test]\n     fn test_len() {\n         let v: SmallVector<int> = SmallVector::zero();\n         assert_eq!(0, v.len());\n \n         assert_eq!(1, SmallVector::one(1).len());\n-        assert_eq!(5, SmallVector::many(~[1, 2, 3, 4, 5]).len());\n+        assert_eq!(5, SmallVector::many(vec!(1, 2, 3, 4, 5)).len());\n     }\n \n     #[test]\n@@ -161,7 +165,7 @@ mod test {\n \n     #[test]\n     fn test_from_iterator() {\n-        let v: SmallVector<int> = (~[1, 2, 3]).move_iter().collect();\n+        let v: SmallVector<int> = (vec!(1, 2, 3)).move_iter().collect();\n         assert_eq!(3, v.len());\n         assert_eq!(&1, v.get(0));\n         assert_eq!(&2, v.get(1));\n@@ -171,14 +175,14 @@ mod test {\n     #[test]\n     fn test_move_iter() {\n         let v = SmallVector::zero();\n-        let v: ~[int] = v.move_iter().collect();\n-        assert_eq!(~[], v);\n+        let v: Vec<int> = v.move_iter().collect();\n+        assert_eq!(Vec::new(), v);\n \n         let v = SmallVector::one(1);\n-        assert_eq!(~[1], v.move_iter().collect());\n+        assert_eq!(vec!(1), v.move_iter().collect());\n \n-        let v = SmallVector::many(~[1, 2, 3]);\n-        assert_eq!(~[1, 2, 3], v.move_iter().collect());\n+        let v = SmallVector::many(vec!(1, 2, 3));\n+        assert_eq!(vec!(1, 2, 3), v.move_iter().collect());\n     }\n \n     #[test]\n@@ -190,12 +194,12 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_expect_one_many() {\n-        SmallVector::many(~[1, 2]).expect_one(\"\");\n+        SmallVector::many(vec!(1, 2)).expect_one(\"\");\n     }\n \n     #[test]\n     fn test_expect_one_one() {\n         assert_eq!(1, SmallVector::one(1).expect_one(\"\"));\n-        assert_eq!(1, SmallVector::many(~[1]).expect_one(\"\"));\n+        assert_eq!(1, SmallVector::many(vec!(1)).expect_one(\"\"));\n     }\n }"}, {"sha": "2edfd367f4ef2712442920a25ed42d24bae74d1f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910012aabae3dfd4b7190f46e88cde75804b5cb0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=910012aabae3dfd4b7190f46e88cde75804b5cb0", "patch": "@@ -637,7 +637,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             visitor.visit_expr(subexpression, env.clone())\n         }\n         ExprVec(ref subexpressions, _) => {\n-            walk_exprs(visitor, *subexpressions, env.clone())\n+            walk_exprs(visitor, subexpressions.as_slice(), env.clone())\n         }\n         ExprRepeat(element, count, _) => {\n             visitor.visit_expr(element, env.clone());\n@@ -662,7 +662,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             visitor.visit_expr(callee_expression, env.clone())\n         }\n         ExprMethodCall(_, ref types, ref arguments) => {\n-            walk_exprs(visitor, *arguments, env.clone());\n+            walk_exprs(visitor, arguments.as_slice(), env.clone());\n             for &typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())\n             }"}]}