{"sha": "c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0Nzk3ZmE0ZjRhNjk2YjE4M2IzYWExNTE3ZWUyMmM3OGQwZjVkN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-12T04:57:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-12T04:57:35Z"}, "message": "Auto merge of #61758 - Centril:rollup-ew2uxng, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #60187 (Generator optimization: Overlap locals that never have storage live at the same time)\n - #61348 (Implement Clone::clone_from for Option and Result)\n - #61568 (Use Symbol, Span in libfmt_macros)\n - #61632 (ci: Collect CPU usage statistics on Azure)\n - #61654 (use pattern matching for slices destructuring)\n - #61671 (implement nth_back for Range(Inclusive))\n - #61688 (is_fp and is_floating_point do the same thing, remove the former)\n - #61705 (Pass cflags rather than cxxflags to LLVM as CMAKE_C_FLAGS)\n - #61734 (Migrate rust-by-example to MdBook2)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ef1c489591c61e99cb24e2a6e8a7b47a6163236c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef1c489591c61e99cb24e2a6e8a7b47a6163236c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "html_url": "https://github.com/rust-lang/rust/commit/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05083c2dee278f79988fc4367c29f1a9b5a2d275", "url": "https://api.github.com/repos/rust-lang/rust/commits/05083c2dee278f79988fc4367c29f1a9b5a2d275", "html_url": "https://github.com/rust-lang/rust/commit/05083c2dee278f79988fc4367c29f1a9b5a2d275"}, {"sha": "4748b5b13dddd9a4c1e8f31a8765bb66fbdc88df", "url": "https://api.github.com/repos/rust-lang/rust/commits/4748b5b13dddd9a4c1e8f31a8765bb66fbdc88df", "html_url": "https://github.com/rust-lang/rust/commit/4748b5b13dddd9a4c1e8f31a8765bb66fbdc88df"}], "stats": {"total": 813, "additions": 579, "deletions": 234}, "files": [{"sha": "4875e2c6754a4724938cc590bb023946c43f75a9", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -11,6 +11,12 @@ steps:\n - checkout: self\n   fetchDepth: 2\n \n+# Spawn a background process to collect CPU usage statistics which we'll upload\n+# at the end of the build. See the comments in the script here for more\n+# information.\n+- bash: python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n+  displayName: \"Collect CPU-usage statistics in the background\"\n+\n - bash: printenv | sort\n   displayName: Show environment variables\n \n@@ -142,3 +148,13 @@ steps:\n     AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n   condition: and(succeeded(), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n   displayName: Upload artifacts\n+\n+# Upload CPU usage statistics that we've been gathering this whole time. Always\n+# execute this step in case we want to inspect failed builds, but don't let\n+# errors here ever fail the build since this is just informational.\n+- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$SYSTEM_JOBNAME.csv\n+  env:\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+  condition: contains(variables, 'AWS_SECRET_ACCESS_KEY')\n+  continueOnError: true\n+  displayName: Upload CPU usage statistics"}, {"sha": "10beb3af6ea40c7b5c6f60d5b7e22e573d4c9bc9", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -910,6 +910,9 @@ dependencies = [\n [[package]]\n name = \"fmt_macros\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"syntax_pos 0.0.0\",\n+]\n \n [[package]]\n name = \"fnv\""}, {"sha": "278ae8a9addcc15e049f3fc0c812ec67282c73c4", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -64,7 +64,7 @@ book!(\n     EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", RustbookVersion::MdBook2;\n     Nomicon, \"src/doc/nomicon\", \"nomicon\", RustbookVersion::MdBook2;\n     Reference, \"src/doc/reference\", \"reference\", RustbookVersion::MdBook1;\n-    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", RustbookVersion::MdBook1;\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", RustbookVersion::MdBook2;\n     RustcBook, \"src/doc/rustc\", \"rustc\", RustbookVersion::MdBook1;\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", RustbookVersion::MdBook2;\n );"}, {"sha": "8b6e856a8aba8702292c5f8bda5f671958e8b070", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -416,7 +416,7 @@ fn configure_cmake(builder: &Builder<'_>,\n \n     cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n     let mut cflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n-    if let Some(ref s) = builder.config.llvm_cxxflags {\n+    if let Some(ref s) = builder.config.llvm_cflags {\n         cflags.push_str(&format!(\" {}\", s));\n     }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);"}, {"sha": "78427a6360a9f7c6546745a4f1b0a646799b6fbb", "filename": "src/ci/cpu-usage-over-time.py", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python\n+# ignore-tidy-linelength\n+\n+# This is a small script that we use on CI to collect CPU usage statistics of\n+# our builders. By seeing graphs of CPU usage over time we hope to correlate\n+# that with possible improvements to Rust's own build system, ideally diagnosing\n+# that either builders are always fully using their CPU resources or they're\n+# idle for long stretches of time.\n+#\n+# This script is relatively simple, but it's platform specific. Each platform\n+# (OSX/Windows/Linux) has a different way of calculating the current state of\n+# CPU at a point in time. We then compare two captured states to determine the\n+# percentage of time spent in one state versus another. The state capturing is\n+# all platform-specific but the loop at the bottom is the cross platform part\n+# that executes everywhere.\n+#\n+# # Viewing statistics\n+#\n+# All builders will upload their CPU statistics as CSV files to our S3 buckets.\n+# These URLS look like:\n+#\n+#   https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+#\n+# for example\n+#\n+#   https://rust-lang-ci2.s3.amazonaws.com/rustc-builds/68baada19cd5340f05f0db15a3e16d6671609bcc/cpu-x86_64-apple.csv\n+#\n+# Each CSV file has two columns. The first is the timestamp of the measurement\n+# and the second column is the % of idle cpu time in that time slice. Ideally\n+# the second column is always zero.\n+#\n+# Once you've downloaded a file there's various ways to plot it and visualize\n+# it. For command line usage you can use a script like so:\n+#\n+#      set timefmt '%Y-%m-%dT%H:%M:%S'\n+#      set xdata time\n+#      set ylabel \"Idle CPU %\"\n+#      set xlabel \"Time\"\n+#      set datafile sep ','\n+#      set term png\n+#      set output \"printme.png\"\n+#      set grid\n+#      builder = \"i686-apple\"\n+#      plot \"cpu-\".builder.\".csv\" using 1:2 with lines title builder\n+#\n+# Executed as `gnuplot < ./foo.plot` it will generate a graph called\n+# `printme.png` which you can then open up. If you know how to improve this\n+# script or the viewing process that would be much appreciated :) (or even if\n+# you know how to automate it!)\n+\n+import datetime\n+import sys\n+import time\n+\n+if sys.platform == 'linux2':\n+    class State:\n+        def __init__(self):\n+            with open('/proc/stat', 'r') as file:\n+                data = file.readline().split()\n+            if data[0] != 'cpu':\n+                raise Exception('did not start with \"cpu\"')\n+            self.user = int(data[1])\n+            self.nice = int(data[2])\n+            self.system = int(data[3])\n+            self.idle = int(data[4])\n+            self.iowait = int(data[5])\n+            self.irq = int(data[6])\n+            self.softirq = int(data[7])\n+            self.steal = int(data[8])\n+            self.guest = int(data[9])\n+            self.guest_nice = int(data[10])\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            nice = self.nice - prev.nice\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            iowait = self.iowait - prev.iowait\n+            irq = self.irq - prev.irq\n+            softirq = self.softirq - prev.softirq\n+            steal = self.steal - prev.steal\n+            guest = self.guest - prev.guest\n+            guest_nice = self.guest_nice - prev.guest_nice\n+            total = user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice\n+            return float(idle) / float(total) * 100\n+\n+elif sys.platform == 'win32':\n+    from ctypes.wintypes import DWORD\n+    from ctypes import Structure, windll, WinError, GetLastError, byref\n+\n+    class FILETIME(Structure):\n+        _fields_ = [\n+            (\"dwLowDateTime\", DWORD),\n+            (\"dwHighDateTime\", DWORD),\n+        ]\n+\n+    class State:\n+        def __init__(self):\n+            idle, kernel, user = FILETIME(), FILETIME(), FILETIME()\n+\n+            success = windll.kernel32.GetSystemTimes(\n+                byref(idle),\n+                byref(kernel),\n+                byref(user),\n+            )\n+\n+            assert success, WinError(GetLastError())[1]\n+\n+            self.idle = (idle.dwHighDateTime << 32) | idle.dwLowDateTime\n+            self.kernel = (kernel.dwHighDateTime << 32) | kernel.dwLowDateTime\n+            self.user = (user.dwHighDateTime << 32) | user.dwLowDateTime\n+\n+        def idle_since(self, prev):\n+            idle = self.idle - prev.idle\n+            user = self.user - prev.user\n+            kernel = self.kernel - prev.kernel\n+            return float(idle) / float(user + kernel) * 100\n+\n+elif sys.platform == 'darwin':\n+    from ctypes import *\n+    libc = cdll.LoadLibrary('/usr/lib/libc.dylib')\n+\n+    PROESSOR_CPU_LOAD_INFO = c_int(2)\n+    CPU_STATE_USER = 0\n+    CPU_STATE_SYSTEM = 1\n+    CPU_STATE_IDLE = 2\n+    CPU_STATE_NICE = 3\n+    c_int_p = POINTER(c_int)\n+\n+    class State:\n+        def __init__(self):\n+            num_cpus_u = c_uint(0)\n+            cpu_info = c_int_p()\n+            cpu_info_cnt = c_int(0)\n+            err = libc.host_processor_info(\n+                libc.mach_host_self(),\n+                PROESSOR_CPU_LOAD_INFO,\n+                byref(num_cpus_u),\n+                byref(cpu_info),\n+                byref(cpu_info_cnt),\n+            )\n+            assert err == 0\n+            self.user = 0\n+            self.system = 0\n+            self.idle = 0\n+            self.nice = 0\n+            cur = 0\n+            while cur < cpu_info_cnt.value:\n+                self.user += cpu_info[cur + CPU_STATE_USER]\n+                self.system += cpu_info[cur + CPU_STATE_SYSTEM]\n+                self.idle += cpu_info[cur + CPU_STATE_IDLE]\n+                self.nice += cpu_info[cur + CPU_STATE_NICE]\n+                cur += num_cpus_u.value\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            nice = self.nice - prev.nice\n+            return float(idle) / float(user + system + idle + nice) * 100.0\n+\n+else:\n+    print('unknown platform', sys.platform)\n+    sys.exit(1)\n+\n+cur_state = State();\n+print(\"Time,Idle\")\n+while True:\n+    time.sleep(1);\n+    next_state = State();\n+    now = datetime.datetime.utcnow().isoformat()\n+    idle = next_state.idle_since(cur_state)\n+    print(\"%s,%s\" % (now, idle))\n+    sys.stdout.flush()\n+    cur_state = next_state"}, {"sha": "d8eec1dd65470b9a68e80ac1cba8fad0daac4916", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -1 +1 @@\n-Subproject commit 18566f4dedc3ef5bf61f5f85685d5966db99cc11\n+Subproject commit d8eec1dd65470b9a68e80ac1cba8fad0daac4916"}, {"sha": "efda3b263cc97fae94f08fb2dda1522424763779", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -281,6 +281,19 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n             None\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<A> {\n+        if let Some(minus_n) = self.end.sub_usize(n) {\n+            if minus_n > self.start {\n+                self.end = minus_n.sub_one();\n+                return Some(self.end.clone())\n+            }\n+        }\n+\n+        self.end = self.start.clone();\n+        None\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -438,6 +451,34 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         })\n     }\n \n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<A> {\n+        self.compute_is_empty();\n+        if self.is_empty.unwrap_or_default() {\n+            return None;\n+        }\n+\n+        if let Some(minus_n) = self.end.sub_usize(n) {\n+            use crate::cmp::Ordering::*;\n+\n+            match minus_n.partial_cmp(&self.start) {\n+                Some(Greater) => {\n+                    self.is_empty = Some(false);\n+                    self.end = minus_n.sub_one();\n+                    return Some(minus_n);\n+                }\n+                Some(Equal) => {\n+                    self.is_empty = Some(true);\n+                    return Some(minus_n);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.is_empty = Some(true);\n+        None\n+    }\n+\n     #[inline]\n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>"}, {"sha": "c75ecb059e8137c2c2552c85fccb04968bec4ad3", "filename": "src/libcore/option.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -145,7 +145,7 @@ use crate::pin::Pin;\n // which basically means it must be `Option`.\n \n /// The `Option` type. See [the module level documentation](index.html) for more.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n@@ -1040,6 +1040,25 @@ fn expect_failed(msg: &str) -> ! {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone> Clone for Option<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        match self {\n+            Some(x) => Some(x.clone()),\n+            None => None,\n+        }\n+    }\n+\n+    #[inline]\n+    fn clone_from(&mut self, source: &Self) {\n+        match (self, source) {\n+            (Some(to), Some(from)) => to.clone_from(from),\n+            (to, from) => *to = from.clone(),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     /// Returns [`None`][Option::None]."}, {"sha": "8a09877ce1f4be591140be8f90e75a4d2773cad5", "filename": "src/libcore/result.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -240,7 +240,7 @@ use crate::ops::{self, Deref};\n ///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Err`]: enum.Result.html#variant.Err\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[must_use = \"this `Result` may be an `Err` variant, which should be handled\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n@@ -1003,6 +1003,27 @@ fn unwrap_failed<E: fmt::Debug>(msg: &str, error: E) -> ! {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone, E: Clone> Clone for Result<T, E> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        match self {\n+            Ok(x) => Ok(x.clone()),\n+            Err(x) => Err(x.clone()),\n+        }\n+    }\n+\n+    #[inline]\n+    fn clone_from(&mut self, source: &Self) {\n+        match (self, source) {\n+            (Ok(to), Ok(from)) => to.clone_from(from),\n+            (Err(to), Err(from)) => to.clone_from(from),\n+            (to, from) => *to = from.clone(),\n+        }\n+    }\n+}\n+\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E> IntoIterator for Result<T, E> {\n     type Item = T;"}, {"sha": "020618ae7aeedb04a7898b3bed2ad28ebb6d41c4", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -1657,6 +1657,23 @@ fn test_range_nth() {\n     assert_eq!(r, 20..20);\n }\n \n+#[test]\n+fn test_range_nth_back() {\n+    assert_eq!((10..15).nth_back(0), Some(14));\n+    assert_eq!((10..15).nth_back(1), Some(13));\n+    assert_eq!((10..15).nth_back(4), Some(10));\n+    assert_eq!((10..15).nth_back(5), None);\n+    assert_eq!((-120..80_i8).nth_back(199), Some(-120));\n+\n+    let mut r = 10..20;\n+    assert_eq!(r.nth_back(2), Some(17));\n+    assert_eq!(r, 10..17);\n+    assert_eq!(r.nth_back(2), Some(14));\n+    assert_eq!(r, 10..14);\n+    assert_eq!(r.nth_back(10), None);\n+    assert_eq!(r, 10..10);\n+}\n+\n #[test]\n fn test_range_from_nth() {\n     assert_eq!((10..).nth(0), Some(10));\n@@ -1714,6 +1731,26 @@ fn test_range_inclusive_nth() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n+#[test]\n+fn test_range_inclusive_nth_back() {\n+    assert_eq!((10..=15).nth_back(0), Some(15));\n+    assert_eq!((10..=15).nth_back(1), Some(14));\n+    assert_eq!((10..=15).nth_back(5), Some(10));\n+    assert_eq!((10..=15).nth_back(6), None);\n+    assert_eq!((-120..=80_i8).nth_back(200), Some(-120));\n+\n+    let mut r = 10_u8..=20;\n+    assert_eq!(r.nth_back(2), Some(18));\n+    assert_eq!(r, 10..=17);\n+    assert_eq!(r.nth_back(2), Some(15));\n+    assert_eq!(r, 10..=14);\n+    assert_eq!(r.is_empty(), false);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n+    assert_eq!(r.nth_back(10), None);\n+    assert_eq!(r.is_empty(), true);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n+}\n+\n #[test]\n fn test_range_step() {\n     #![allow(deprecated)]"}, {"sha": "fc32f21ec4e0a8b5816489b2f22e6786168e94bc", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -8,3 +8,6 @@ edition = \"2018\"\n name = \"fmt_macros\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n+\n+[dependencies]\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "7d0a0035dc846cda8ef330867a9503f97d66410e", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -25,6 +25,17 @@ use std::str;\n use std::string;\n use std::iter;\n \n+use syntax_pos::{InnerSpan, Symbol};\n+\n+#[derive(Copy, Clone)]\n+struct InnerOffset(usize);\n+\n+impl InnerOffset {\n+    fn to(self, end: InnerOffset) -> InnerSpan {\n+        InnerSpan::new(self.0, end.0)\n+    }\n+}\n+\n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n #[derive(Copy, Clone, PartialEq)]\n@@ -40,7 +51,7 @@ pub enum Piece<'a> {\n #[derive(Copy, Clone, PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n-    pub position: Position<'a>,\n+    pub position: Position,\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n }\n@@ -55,9 +66,9 @@ pub struct FormatSpec<'a> {\n     /// Packed version of various flags provided\n     pub flags: u32,\n     /// The integer precision to use\n-    pub precision: Count<'a>,\n+    pub precision: Count,\n     /// The string width requested for the resulting format\n-    pub width: Count<'a>,\n+    pub width: Count,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n@@ -66,16 +77,16 @@ pub struct FormatSpec<'a> {\n \n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum Position<'a> {\n+pub enum Position {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n     /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),\n     /// The argument has a name.\n-    ArgumentNamed(&'a str),\n+    ArgumentNamed(Symbol),\n }\n \n-impl Position<'_> {\n+impl Position {\n     pub fn index(&self) -> Option<usize> {\n         match self {\n             ArgumentIs(i) | ArgumentImplicitlyIs(i) => Some(*i),\n@@ -120,11 +131,11 @@ pub enum Flag {\n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum Count<'a> {\n+pub enum Count {\n     /// The count is specified explicitly.\n     CountIs(usize),\n     /// The count is specified by the argument with the given name.\n-    CountIsName(&'a str),\n+    CountIsName(Symbol),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n     /// The count is implied and cannot be explicitly specified.\n@@ -135,9 +146,8 @@ pub struct ParseError {\n     pub description: string::String,\n     pub note: Option<string::String>,\n     pub label: string::String,\n-    pub start: SpanIndex,\n-    pub end: SpanIndex,\n-    pub secondary_label: Option<(string::String, SpanIndex, SpanIndex)>,\n+    pub span: InnerSpan,\n+    pub secondary_label: Option<(string::String, InnerSpan)>,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -156,44 +166,36 @@ pub struct Parser<'a> {\n     /// `Some(raw count)` when the string is \"raw\", used to position spans correctly\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n-    pub arg_places: Vec<(SpanIndex, SpanIndex)>,\n+    pub arg_places: Vec<InnerSpan>,\n     /// Characters that need to be shifted\n     skips: Vec<usize>,\n-    /// Span offset of the last opening brace seen, used for error reporting\n-    last_opening_brace_pos: Option<SpanIndex>,\n+    /// Span of the last opening brace seen, used for error reporting\n+    last_opening_brace: Option<InnerSpan>,\n     /// Wether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct SpanIndex(pub usize);\n-\n-impl SpanIndex {\n-    pub fn unwrap(self) -> usize {\n-        self.0\n-    }\n-}\n-\n impl<'a> Iterator for Parser<'a> {\n     type Item = Piece<'a>;\n \n     fn next(&mut self) -> Option<Piece<'a>> {\n         if let Some(&(pos, c)) = self.cur.peek() {\n             match c {\n                 '{' => {\n-                    let curr_last_brace = self.last_opening_brace_pos;\n-                    self.last_opening_brace_pos = Some(self.to_span_index(pos));\n+                    let curr_last_brace = self.last_opening_brace;\n+                    let byte_pos = self.to_span_index(pos);\n+                    self.last_opening_brace = Some(byte_pos.to(InnerOffset(byte_pos.0 + 1)));\n                     self.cur.next();\n                     if self.consume('{') {\n-                        self.last_opening_brace_pos = curr_last_brace;\n+                        self.last_opening_brace = curr_last_brace;\n \n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument();\n-                        if let Some(arg_pos) = self.must_consume('}').map(|end| {\n-                            (self.to_span_index(pos), self.to_span_index(end + 1))\n-                        }) {\n-                            self.arg_places.push(arg_pos);\n+                        if let Some(end) = self.must_consume('}') {\n+                            let start = self.to_span_index(pos);\n+                            let end = self.to_span_index(end + 1);\n+                            self.arg_places.push(start.to(end));\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -208,8 +210,7 @@ impl<'a> Iterator for Parser<'a> {\n                             \"unmatched `}` found\",\n                             \"unmatched `}`\",\n                             \"if you intended to print `}`, you can escape it using `}}`\",\n-                            err_pos,\n-                            err_pos,\n+                            err_pos.to(err_pos),\n                         );\n                         None\n                     }\n@@ -241,7 +242,7 @@ impl<'a> Parser<'a> {\n             style,\n             arg_places: vec![],\n             skips,\n-            last_opening_brace_pos: None,\n+            last_opening_brace: None,\n             append_newline,\n         }\n     }\n@@ -253,15 +254,13 @@ impl<'a> Parser<'a> {\n         &mut self,\n         description: S1,\n         label: S2,\n-        start: SpanIndex,\n-        end: SpanIndex,\n+        span: InnerSpan,\n     ) {\n         self.errors.push(ParseError {\n             description: description.into(),\n             note: None,\n             label: label.into(),\n-            start,\n-            end,\n+            span,\n             secondary_label: None,\n         });\n     }\n@@ -274,15 +273,13 @@ impl<'a> Parser<'a> {\n         description: S1,\n         label: S2,\n         note: S3,\n-        start: SpanIndex,\n-        end: SpanIndex,\n+        span: InnerSpan,\n     ) {\n         self.errors.push(ParseError {\n             description: description.into(),\n             note: Some(note.into()),\n             label: label.into(),\n-            start,\n-            end,\n+            span,\n             secondary_label: None,\n         });\n     }\n@@ -303,22 +300,21 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn raw(&self) -> usize {\n-        self.style.map(|raw| raw + 1).unwrap_or(0)\n-    }\n-\n-    fn to_span_index(&self, pos: usize) -> SpanIndex {\n+    fn to_span_index(&self, pos: usize) -> InnerOffset {\n         let mut pos = pos;\n+        // This handles the raw string case, the raw argument is the number of #\n+        // in r###\"...\"### (we need to add one because of the `r`).\n+        let raw = self.style.map(|raw| raw + 1).unwrap_or(0);\n         for skip in &self.skips {\n             if pos > *skip {\n                 pos += 1;\n-            } else if pos == *skip && self.raw() == 0 {\n+            } else if pos == *skip && raw == 0 {\n                 pos += 1;\n             } else {\n                 break;\n             }\n         }\n-        SpanIndex(self.raw() + pos + 1)\n+        InnerOffset(raw + pos + 1)\n     }\n \n     /// Forces consumption of the specified character. If the character is not\n@@ -336,8 +332,8 @@ impl<'a> Parser<'a> {\n                 let label = \"expected `}`\".to_owned();\n                 let (note, secondary_label) = if c == '}' {\n                     (Some(\"if you intended to print `{`, you can escape it using `{{`\".to_owned()),\n-                     self.last_opening_brace_pos.map(|pos| {\n-                        (\"because of this opening brace\".to_owned(), pos, pos)\n+                     self.last_opening_brace.map(|sp| {\n+                        (\"because of this opening brace\".to_owned(), sp)\n                      }))\n                 } else {\n                     (None, None)\n@@ -346,8 +342,7 @@ impl<'a> Parser<'a> {\n                     description,\n                     note,\n                     label,\n-                    start: pos,\n-                    end: pos,\n+                    span: pos.to(pos),\n                     secondary_label,\n                 });\n                 None\n@@ -361,8 +356,8 @@ impl<'a> Parser<'a> {\n                 let label = format!(\"expected `{:?}`\", c);\n                 let (note, secondary_label) = if c == '}' {\n                     (Some(\"if you intended to print `{`, you can escape it using `{{`\".to_owned()),\n-                     self.last_opening_brace_pos.map(|pos| {\n-                        (\"because of this opening brace\".to_owned(), pos, pos)\n+                     self.last_opening_brace.map(|sp| {\n+                        (\"because of this opening brace\".to_owned(), sp)\n                      }))\n                 } else {\n                     (None, None)\n@@ -371,12 +366,11 @@ impl<'a> Parser<'a> {\n                     description,\n                     note,\n                     label,\n-                    start: pos,\n-                    end: pos,\n+                    span: pos.to(pos),\n                     secondary_label,\n                 });\n             } else {\n-                self.err(description, format!(\"expected `{:?}`\", c), pos, pos);\n+                self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n             }\n             None\n         }\n@@ -435,20 +429,24 @@ impl<'a> Parser<'a> {\n     /// integer index of an argument, a named argument, or a blank string.\n     /// Returns `Some(parsed_position)` if the position is not implicitly\n     /// consuming a macro argument, `None` if it's the case.\n-    fn position(&mut self) -> Option<Position<'a>> {\n+    fn position(&mut self) -> Option<Position> {\n         if let Some(i) = self.integer() {\n             Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+                Some(&(_, c)) if c.is_alphabetic() => {\n+                    Some(ArgumentNamed(Symbol::intern(self.word())))\n+                }\n                 Some(&(pos, c)) if c == '_' => {\n                     let invalid_name = self.string(pos);\n                     self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n                                        \"invalid argument name\",\n                                        \"argument names cannot start with an underscore\",\n-                                       self.to_span_index(pos),\n-                                       self.to_span_index(pos + invalid_name.len()));\n-                    Some(ArgumentNamed(invalid_name))\n+                                        self.to_span_index(pos).to(\n+                                            self.to_span_index(pos + invalid_name.len())\n+                                        ),\n+                                        );\n+                    Some(ArgumentNamed(Symbol::intern(invalid_name)))\n                 },\n \n                 // This is an `ArgumentNext`.\n@@ -556,7 +554,7 @@ impl<'a> Parser<'a> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count<'a> {\n+    fn count(&mut self) -> Count {\n         if let Some(i) = self.integer() {\n             if self.consume('$') {\n                 CountIsParam(i)\n@@ -570,7 +568,7 @@ impl<'a> Parser<'a> {\n                 self.cur = tmp;\n                 CountImplied\n             } else if self.consume('$') {\n-                CountIsName(word)\n+                CountIsName(Symbol::intern(word))\n             } else {\n                 self.cur = tmp;\n                 CountImplied\n@@ -760,6 +758,8 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n+        use syntax_pos::{GLOBALS, Globals, edition};\n+        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n                    position: ArgumentImplicitlyIs(0),\n@@ -815,11 +815,12 @@ mod tests {\n                        fill: None,\n                        align: AlignUnknown,\n                        flags: 0,\n-                       precision: CountIsName(\"b\"),\n-                       width: CountIsName(\"a\"),\n+                       precision: CountIsName(Symbol::intern(\"b\")),\n+                       width: CountIsName(Symbol::intern(\"a\")),\n                        ty: \"s\",\n                    },\n                })]);\n+        });\n     }\n     #[test]\n     fn format_flags() {"}, {"sha": "50d2eeef421c13d767e6a4e50196dddeb8ebd2d0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 // this is a \"direct\", user-specified, rather than derived,\n                 // obligation.\n-                flags.push((\"direct\".to_owned(), None));\n+                flags.push((sym::direct, None));\n             }\n         }\n \n@@ -365,27 +365,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // Currently I'm leaving it for what I need for `try`.\n             if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n                 let method = self.tcx.item_name(item);\n-                flags.push((\"from_method\".to_owned(), None));\n-                flags.push((\"from_method\".to_owned(), Some(method.to_string())));\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n             }\n         }\n         if let Some(t) = self.get_parent_trait_ref(&obligation.cause.code) {\n-            flags.push((\"parent_trait\".to_owned(), Some(t)));\n+            flags.push((sym::parent_trait, Some(t)));\n         }\n \n         if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n-            flags.push((\"from_desugaring\".to_owned(), None));\n-            flags.push((\"from_desugaring\".to_owned(), Some(k.name().to_string())));\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(k.name().to_string())));\n         }\n         let generics = self.tcx.generics_of(def_id);\n         let self_ty = trait_ref.self_ty();\n         // This is also included through the generics list as `Self`,\n         // but the parser won't allow you to use it\n-        flags.push((\"_Self\".to_owned(), Some(self_ty.to_string())));\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n         if let Some(def) = self_ty.ty_adt_def() {\n             // We also want to be able to select self's original\n             // signature with no type arguments resolved\n-            flags.push((\"_Self\".to_owned(), Some(self.tcx.type_of(def.did).to_string())));\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n         }\n \n         for param in generics.params.iter() {\n@@ -396,38 +396,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n             };\n-            let name = param.name.to_string();\n+            let name = param.name.as_symbol();\n             flags.push((name, Some(value)));\n         }\n \n         if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((\"crate_local\".to_owned(), None));\n+            flags.push((sym::crate_local, None));\n         }\n \n         // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n         if self_ty.is_integral() {\n-            flags.push((\"_Self\".to_owned(), Some(\"{integral}\".to_owned())));\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n         }\n \n         if let ty::Array(aty, len) = self_ty.sty {\n-            flags.push((\"_Self\".to_owned(), Some(\"[]\".to_owned())));\n-            flags.push((\"_Self\".to_owned(), Some(format!(\"[{}]\", aty))));\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n             if let Some(def) = aty.ty_adt_def() {\n                 // We also want to be able to select the array's type's original\n                 // signature with no type arguments resolved\n                 flags.push((\n-                    \"_Self\".to_owned(),\n+                    sym::_Self,\n                     Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n                 ));\n                 let tcx = self.tcx;\n                 if let Some(len) = len.assert_usize(tcx) {\n                     flags.push((\n-                        \"_Self\".to_owned(),\n+                        sym::_Self,\n                         Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n                     ));\n                 } else {\n                     flags.push((\n-                        \"_Self\".to_owned(),\n+                        sym::_Self,\n                         Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n                     ));\n                 }"}, {"sha": "b78396c90dc657f2a70aba7c37922ac30048891d", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -7,7 +7,7 @@ use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n-use syntax::symbol::sym;\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n \n@@ -52,7 +52,7 @@ fn parse_error(tcx: TyCtxt<'_, '_, '_>, span: Span,\n }\n \n impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n-    pub fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                  trait_def_id: DefId,\n                  items: &[NestedMetaItem],\n                  span: Span,\n@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     pub fn evaluate(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     trait_ref: ty::TraitRef<'tcx>,\n-                    options: &[(String, Option<String>)])\n+                    options: &[(Symbol, Option<String>)])\n                     -> OnUnimplementedNote\n     {\n         let mut message = None;\n@@ -180,7 +180,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n                     c.ident().map_or(false, |ident| {\n                         options.contains(&(\n-                            ident.to_string(),\n+                            ident.name,\n                             c.value_str().map(|s| s.as_str().to_string())\n                         ))\n                     })\n@@ -203,8 +203,8 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             }\n         }\n \n-        let options: FxHashMap<String, String> = options.into_iter()\n-            .filter_map(|(k, v)| v.as_ref().map(|v| (k.to_owned(), v.to_owned())))\n+        let options: FxHashMap<Symbol, String> = options.into_iter()\n+            .filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned())))\n             .collect();\n         OnUnimplementedNote {\n             label: label.map(|l| l.format(tcx, trait_ref, &options)),\n@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n }\n \n impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n-    pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      trait_def_id: DefId,\n                      from: LocalInternedString,\n                      err_sp: Span)\n@@ -241,16 +241,16 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 Piece::String(_) => (), // Normal string, no need to check it\n                 Piece::NextArgument(a) => match a.position {\n                     // `{Self}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                    Position::ArgumentNamed(s) if s == kw::SelfUpper => (),\n                     // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s) if s == name.as_str() => (),\n+                    Position::ArgumentNamed(s) if s == name => (),\n                     // `{from_method}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"from_method\" => (),\n+                    Position::ArgumentNamed(s) if s == sym::from_method => (),\n                     // `{from_desugaring}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"from_desugaring\" => (),\n+                    Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n-                        param.name.as_str() == s\n+                        param.name.as_symbol() == s\n                     }) {\n                         Some(_) => (),\n                         None => {\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n-        options: &FxHashMap<String, String>,\n+        options: &FxHashMap<Symbol, String>,\n     ) -> String {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.def_path_str(trait_ref.def_id);\n@@ -289,25 +289,25 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 },\n                 GenericParamDefKind::Lifetime => return None\n             };\n-            let name = param.name.to_string();\n+            let name = param.name.as_symbol();\n             Some((name, value))\n-        }).collect::<FxHashMap<String, String>>();\n+        }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();\n \n         let parser = Parser::new(&self.0, None, vec![], false);\n         parser.map(|p|\n             match p {\n                 Piece::String(s) => s,\n                 Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                    Position::ArgumentNamed(s) => match generic_map.get(&s) {\n                         Some(val) => val,\n-                        None if s == name.as_str() => {\n+                        None if s == name => {\n                             &trait_str\n                         }\n                         None => {\n-                            if let Some(val) = options.get(s) {\n+                            if let Some(val) = options.get(&s) {\n                                 val\n-                            } else if s == \"from_desugaring\" || s == \"from_method\" {\n+                            } else if s == sym::from_desugaring || s == sym::from_method {\n                                 // don't break messages using these two arguments incorrectly\n                                 &empty_string\n                             } else {"}, {"sha": "0e5c906024c3fd8f781ed683d1fe6ed54e3eb24b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -1665,13 +1665,15 @@ impl RegionKind {\n \n /// Type utilities\n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n+    #[inline]\n     pub fn is_unit(&self) -> bool {\n         match self.sty {\n             Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_never(&self) -> bool {\n         match self.sty {\n             Never => true,\n@@ -1726,6 +1728,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n             Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n@@ -1741,13 +1744,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n         match self.sty {\n             Infer(_) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         if let Adt(def, _) = self.sty {\n             def.is_phantom_data()\n@@ -1756,22 +1761,26 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_bool(&self) -> bool { self.sty == Bool }\n \n+    #[inline]\n     pub fn is_param(&self, index: u32) -> bool {\n         match self.sty {\n             ty::Param(ref data) => data.index == index,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_self(&self) -> bool {\n         match self.sty {\n             Param(ref p) => p.is_self(),\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.sty {\n             RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.sty {\n@@ -1814,13 +1823,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_region_ptr(&self) -> bool {\n         match self.sty {\n             Ref(..) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_mutable_pointer(&self) -> bool {\n         match self.sty {\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n@@ -1829,6 +1840,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_unsafe_ptr(&self) -> bool {\n         match self.sty {\n             RawPtr(_) => return true,\n@@ -1837,6 +1849,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     /// Returns `true` if this type is an `Arc<T>`.\n+    #[inline]\n     pub fn is_arc(&self) -> bool {\n         match self.sty {\n             Adt(def, _) => def.is_arc(),\n@@ -1845,13 +1858,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     /// Returns `true` if this type is an `Rc<T>`.\n+    #[inline]\n     pub fn is_rc(&self) -> bool {\n         match self.sty {\n             Adt(def, _) => def.is_rc(),\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_box(&self) -> bool {\n         match self.sty {\n             Adt(def, _) => def.is_box(),\n@@ -1870,6 +1885,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// A scalar type is one that denotes an atomic datum, with no sub-components.\n     /// (A RawPtr is scalar because it represents a non-managed pointer, so its\n     /// contents are abstract to rustc.)\n+    #[inline]\n     pub fn is_scalar(&self) -> bool {\n         match self.sty {\n             Bool | Char | Int(_) | Float(_) | Uint(_) |\n@@ -1880,6 +1896,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     /// Returns `true` if this type is a floating point type.\n+    #[inline]\n     pub fn is_floating_point(&self) -> bool {\n         match self.sty {\n             Float(_) |\n@@ -1888,13 +1905,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_trait(&self) -> bool {\n         match self.sty {\n             Dynamic(..) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_enum(&self) -> bool {\n         match self.sty {\n             Adt(adt_def, _) => {\n@@ -1904,13 +1923,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_closure(&self) -> bool {\n         match self.sty {\n             Closure(..) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_generator(&self) -> bool {\n         match self.sty {\n             Generator(..) => true,\n@@ -1926,13 +1947,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_fresh_ty(&self) -> bool {\n         match self.sty {\n             Infer(FreshTy(_)) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_fresh(&self) -> bool {\n         match self.sty {\n             Infer(FreshTy(_)) => true,\n@@ -1942,6 +1965,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_char(&self) -> bool {\n         match self.sty {\n             Char => true,\n@@ -1950,38 +1974,35 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_fp(&self) -> bool {\n-        match self.sty {\n-            Infer(FloatVar(_)) | Float(_) => true,\n-            _ => false\n-        }\n-    }\n-\n     pub fn is_numeric(&self) -> bool {\n-        self.is_integral() || self.is_fp()\n+        self.is_integral() || self.is_floating_point()\n     }\n \n+    #[inline]\n     pub fn is_signed(&self) -> bool {\n         match self.sty {\n             Int(_) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_pointer_sized(&self) -> bool {\n         match self.sty {\n             Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n             Int(..) | Uint(..) | Float(..) => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n         match self.sty {\n             Param(_) | Infer(_) | Error => false,\n@@ -2028,6 +2049,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_fn(&self) -> bool {\n         match self.sty {\n             FnDef(..) | FnPtr(_) => true,\n@@ -2043,6 +2065,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n     pub fn is_impl_trait(&self) -> bool {\n         match self.sty {\n             Opaque(..) => true,"}, {"sha": "87e15ba6aac5e414e7d519a3f7e7d905fb9599de", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -429,7 +429,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.codegen_operand(&mut bx, operand);\n                 let lloperand = operand.immediate();\n-                let is_float = operand.layout.ty.is_fp();\n+                let is_float = operand.layout.ty.is_floating_point();\n                 let llval = match op {\n                     mir::UnOp::Not => bx.not(lloperand),\n                     mir::UnOp::Neg => if is_float {\n@@ -536,7 +536,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         rhs: Bx::Value,\n         input_ty: Ty<'tcx>,\n     ) -> Bx::Value {\n-        let is_float = input_ty.is_fp();\n+        let is_float = input_ty.is_floating_point();\n         let is_signed = input_ty.is_signed();\n         let is_unit = input_ty.is_unit();\n         match op {"}, {"sha": "2ab8d14ed32e250691525cf5865717a9b99f7e50", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -4094,7 +4094,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         hir::UnNeg => {\n                             let result = self.check_user_unop(expr, oprnd_t, unop);\n                             // If it's builtin, we can reuse the type, this helps inference.\n-                            if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n+                            if !oprnd_t.is_numeric() {\n                                 oprnd_t = result;\n                             }\n                         }"}, {"sha": "6d51278b4e5e88315e74c52248e1499aa8bdd6c2", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -2,7 +2,7 @@ use errors::Applicability;\n use syntax::parse::lexer::{StringReader as Lexer};\n use syntax::parse::{ParseSess, token};\n use syntax::source_map::FilePathMapping;\n-use syntax_pos::FileName;\n+use syntax_pos::{InnerSpan, FileName};\n \n use crate::clean;\n use crate::core::DocContext;\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n                 }\n \n                 if code_block.syntax.is_none() && code_block.is_fenced {\n-                    let sp = sp.from_inner_byte_pos(0, 3);\n+                    let sp = sp.from_inner(InnerSpan::new(0, 3));\n                     diag.span_suggestion(\n                         sp,\n                         \"mark blocks that do not contain Rust code as text\","}, {"sha": "8fc6b9fdbe6b93d9b4f99636d6f1e7f01375b2b6", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -6,7 +6,7 @@ use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::{DUMMY_SP, InnerSpan, Span};\n use std::ops::Range;\n \n use crate::clean::{self, GetDefId, Item};\n@@ -440,10 +440,10 @@ crate fn source_span_for_markdown_range(\n         }\n     }\n \n-    let sp = span_of_attrs(attrs).from_inner_byte_pos(\n+    let sp = span_of_attrs(attrs).from_inner(InnerSpan::new(\n         md_range.start + start_bytes,\n         md_range.end + start_bytes + end_bytes,\n-    );\n+    ));\n \n     Some(sp)\n }"}, {"sha": "98351048c35266c85707d10d7b17dc49fbc3862c", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -33,8 +33,10 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n                                    -> Box<dyn MacResult+'cx> {\n-    let code = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. }))) => code,\n+    let code = match token_tree {\n+        [\n+            TokenTree::Token(Token { kind: token::Ident(code, _), .. })\n+        ] => code,\n         _ => unreachable!()\n     };\n \n@@ -66,22 +68,19 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n                                        -> Box<dyn MacResult+'cx> {\n-    let (code, description) = match (\n-        token_tree.len(),\n-        token_tree.get(0),\n-        token_tree.get(1),\n-        token_tree.get(2)\n-    ) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })), None, None) => {\n-            (code, None)\n+    let (code, description) = match  token_tree {\n+        [\n+            TokenTree::Token(Token { kind: token::Ident(code, _), .. })\n+        ] => {\n+            (*code, None)\n+        },\n+        [\n+            TokenTree::Token(Token { kind: token::Ident(code, _), .. }),\n+            TokenTree::Token(Token { kind: token::Comma, .. }),\n+            TokenTree::Token(Token { kind: token::Literal(token::Lit { symbol, .. }), ..})\n+        ] => {\n+            (*code, Some(*symbol))\n         },\n-        (3, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })),\n-            Some(&TokenTree::Token(Token { kind: token::Comma, .. })),\n-            Some(&TokenTree::Token(Token {\n-                kind: token::Literal(token::Lit { symbol, .. }), ..\n-            }))) => {\n-            (code, Some(symbol))\n-        }\n         _ => unreachable!()\n     };\n "}, {"sha": "dd96c63ab0ed66a1f895319259d22982559d9623", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -424,48 +424,38 @@ mod tests {\n                 string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n             let tts: &[TokenTree] = &tts[..];\n \n-            match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n-                (\n-                    4,\n-                    Some(&TokenTree::Token(Token {\n-                        kind: token::Ident(name_macro_rules, false), ..\n-                    })),\n-                    Some(&TokenTree::Token(Token { kind: token::Not, .. })),\n-                    Some(&TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. })),\n-                    Some(&TokenTree::Delimited(_, macro_delim, ref macro_tts)),\n-                )\n-                if name_macro_rules == sym::macro_rules && name_zip.as_str() == \"zip\" => {\n+            match tts {\n+                [\n+                    TokenTree::Token(Token { kind: token::Ident(name_macro_rules, false), .. }),\n+                    TokenTree::Token(Token { kind: token::Not, .. }),\n+                    TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. }),\n+                    TokenTree::Delimited(_, macro_delim,  macro_tts)\n+                ]\n+                if name_macro_rules == &sym::macro_rules && name_zip.as_str() == \"zip\" => {\n                     let tts = &macro_tts.trees().collect::<Vec<_>>();\n-                    match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n-                        (\n-                            3,\n-                            Some(&TokenTree::Delimited(_, first_delim, ref first_tts)),\n-                            Some(&TokenTree::Token(Token { kind: token::FatArrow, .. })),\n-                            Some(&TokenTree::Delimited(_, second_delim, ref second_tts)),\n-                        )\n-                        if macro_delim == token::Paren => {\n+                    match &tts[..] {\n+                        [\n+                            TokenTree::Delimited(_, first_delim, first_tts),\n+                            TokenTree::Token(Token { kind: token::FatArrow, .. }),\n+                            TokenTree::Delimited(_, second_delim, second_tts),\n+                        ]\n+                        if macro_delim == &token::Paren => {\n                             let tts = &first_tts.trees().collect::<Vec<_>>();\n-                            match (tts.len(), tts.get(0), tts.get(1)) {\n-                                (\n-                                    2,\n-                                    Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token {\n-                                        kind: token::Ident(name, false), ..\n-                                    })),\n-                                )\n-                                if first_delim == token::Paren && name.as_str() == \"a\" => {},\n+                            match &tts[..] {\n+                                [\n+                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                    TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n+                                ]\n+                                if first_delim == &token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n                             let tts = &second_tts.trees().collect::<Vec<_>>();\n-                            match (tts.len(), tts.get(0), tts.get(1)) {\n-                                (\n-                                    2,\n-                                    Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token {\n-                                        kind: token::Ident(name, false), ..\n-                                    })),\n-                                )\n-                                if second_delim == token::Paren && name.as_str() == \"a\" => {},\n+                            match &tts[..] {\n+                                [\n+                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                    TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n+                                ]\n+                                if second_delim == &token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                             }\n                         },"}, {"sha": "844865d57c7ad04102534e86736abd736c2fabe2", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -82,8 +82,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n         // }\n \n         let new = {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n             };\n "}, {"sha": "732bb234389a0aedd1ccf474f36d27ec3621d8b2", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -25,8 +25,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n              -> P<Expr>\n     {\n         let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n             };\n "}, {"sha": "a30a7d78222f47202e348f5a53b6ee694e67c242", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -143,8 +143,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 // }\n \n                 let new = {\n-                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                        (1, Some(o_f)) => o_f,\n+                    let other_f = match other_fs {\n+                        [o_f] => o_f,\n                                 _ => {\n                                     cx.span_bug(span,\n                                         \"not exactly 2 arguments in `derive(PartialOrd)`\")\n@@ -193,8 +193,8 @@ fn cs_op(less: bool,\n     };\n \n     let par_cmp = |cx: &mut ExtCtxt<'_>, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n-        let other_f = match (other_fs.len(), other_fs.get(0)) {\n-            (1, Some(o_f)) => o_f,\n+        let other_f = match other_fs {\n+            [o_f] => o_f,\n             _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n         };\n "}, {"sha": "7ad04aebf6e2ea6e4d5bfc2c5c49b0d3f5165216", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -52,8 +52,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n }\n \n fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n-        (1, Some(o_f)) => o_f,\n+    let state_expr = match &substr.nonself_args {\n+        &[o_f] => o_f,\n         _ => {\n             cx.span_bug(trait_span,\n                         \"incorrect number of arguments in `derive(Hash)`\")"}, {"sha": "85b524786b2f5d8eb572acabcaa0eac8c392d61a", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -28,7 +28,7 @@ enum ArgumentType {\n \n enum Position {\n     Exact(usize),\n-    Named(String),\n+    Named(Symbol),\n }\n \n struct Context<'a, 'b: 'a> {\n@@ -57,7 +57,7 @@ struct Context<'a, 'b: 'a> {\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<String, usize>,\n+    names: FxHashMap<Symbol, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -127,9 +127,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: &[tokenstream::TokenTree]\n-) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<String, usize>), DiagnosticBuilder<'a>> {\n+) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>), DiagnosticBuilder<'a>> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n-    let mut names = FxHashMap::<String, usize>::default();\n+    let mut names = FxHashMap::<Symbol, usize>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -158,11 +158,10 @@ fn parse_args<'a>(\n                     \"expected ident, positional arguments cannot follow named arguments\",\n                 ));\n             };\n-            let name: &str = &name.as_str();\n \n             p.expect(&token::Eq)?;\n             let e = p.parse_expr()?;\n-            if let Some(prev) = names.get(name) {\n+            if let Some(prev) = names.get(&name) {\n                 ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n@@ -174,7 +173,7 @@ fn parse_args<'a>(\n             // if the input is valid, we can simply append to the positional\n             // args. And remember the names.\n             let slot = args.len();\n-            names.insert(name.to_string(), slot);\n+            names.insert(name, slot);\n             args.push(e);\n         } else {\n             let e = p.parse_expr()?;\n@@ -188,7 +187,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s| *self.names.get(s).unwrap_or(&0);\n+        let lookup = |s: Symbol| *self.names.get(&s).unwrap_or(&0);\n \n         match *p {\n             parse::String(_) => {}\n@@ -222,7 +221,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i) | parse::ArgumentImplicitlyIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s) => Named(s.to_string()),\n+                    parse::ArgumentNamed(s) => Named(s),\n                 };\n \n                 let ty = Placeholder(arg.format.ty.to_string());\n@@ -232,15 +231,15 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn verify_count(&mut self, c: parse::Count<'_>) {\n+    fn verify_count(&mut self, c: parse::Count) {\n         match c {\n             parse::CountImplied |\n             parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_string()), Count);\n+                self.verify_arg_type(Named(s), Count);\n             }\n         }\n     }\n@@ -390,7 +389,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n     }\n \n-    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n+    fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -739,7 +738,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                                     sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    names: FxHashMap<String, usize>,\n+                                    names: FxHashMap<Symbol, usize>,\n                                     append_newline: bool)\n                                     -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n@@ -901,25 +900,23 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = fmt.span.from_inner_byte_pos(err.start.unwrap(), err.end.unwrap());\n+        let sp = fmt.span.from_inner(err.span);\n         let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n                                                      err.description));\n         e.span_label(sp, err.label + \" in format string\");\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, start, end)) = err.secondary_label {\n-            let sp = fmt.span.from_inner_byte_pos(start.unwrap(), end.unwrap());\n+        if let Some((label, span)) = err.secondary_label {\n+            let sp = fmt.span.from_inner(span);\n             e.span_label(sp, label);\n         }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n \n     let arg_spans = parser.arg_places.iter()\n-        .map(|&(parse::SpanIndex(start), parse::SpanIndex(end))| {\n-            fmt.span.from_inner_byte_pos(start, end)\n-        })\n+        .map(|span| fmt.span.from_inner(*span))\n         .collect();\n \n     let mut cx = Context {\n@@ -1044,7 +1041,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                     let mut show_doc_note = false;\n \n                     let mut suggestions = vec![];\n-                    for sub in foreign::$kind::iter_subs(fmt_str) {\n+                    // account for `\"` and account for raw strings `r#`\n+                    let padding = str_style.map(|i| i + 2).unwrap_or(1);\n+                    for sub in foreign::$kind::iter_subs(fmt_str, padding) {\n                         let trn = match sub.translate() {\n                             Some(trn) => trn,\n \n@@ -1064,10 +1063,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                             show_doc_note = true;\n                         }\n \n-                        if let Some((start, end)) = pos {\n-                            // account for `\"` and account for raw strings `r#`\n-                            let padding = str_style.map(|i| i + 2).unwrap_or(1);\n-                            let sp = fmt_sp.from_inner_byte_pos(start + padding, end + padding);\n+                        if let Some(inner_sp) = pos {\n+                            let sp = fmt_sp.from_inner(inner_sp);\n                             suggestions.push((sp, trn));\n                         } else {\n                             diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));"}, {"sha": "7ad5997bf2c097c0942bdb4f55615e0a78c14344", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -1,5 +1,6 @@\n pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n+    use syntax_pos::InnerSpan;\n \n     /// Represents a single `printf`-style substitution.\n     #[derive(Clone, PartialEq, Debug)]\n@@ -18,7 +19,7 @@ pub mod printf {\n             }\n         }\n \n-        pub fn position(&self) -> Option<(usize, usize)> {\n+        pub fn position(&self) -> Option<InnerSpan> {\n             match *self {\n                 Substitution::Format(ref fmt) => Some(fmt.position),\n                 _ => None,\n@@ -28,7 +29,7 @@ pub mod printf {\n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n                 Substitution::Format(ref mut fmt) => {\n-                    fmt.position = (start, end);\n+                    fmt.position = InnerSpan::new(start, end);\n                 }\n                 _ => {}\n             }\n@@ -65,7 +66,7 @@ pub mod printf {\n         /// Type of parameter being converted.\n         pub type_: &'a str,\n         /// Byte offset for the start and end of this formatting directive.\n-        pub position: (usize, usize),\n+        pub position: InnerSpan,\n     }\n \n     impl Format<'_> {\n@@ -263,10 +264,10 @@ pub mod printf {\n     }\n \n     /// Returns an iterator over all substitutions in a given string.\n-    pub fn iter_subs(s: &str) -> Substitutions<'_> {\n+    pub fn iter_subs(s: &str, start_pos: usize) -> Substitutions<'_> {\n         Substitutions {\n             s,\n-            pos: 0,\n+            pos: start_pos,\n         }\n     }\n \n@@ -282,9 +283,9 @@ pub mod printf {\n             let (mut sub, tail) = parse_next_substitution(self.s)?;\n             self.s = tail;\n             match sub {\n-                Substitution::Format(_) => if let Some((start, end)) = sub.position() {\n-                    sub.set_position(start + self.pos, end + self.pos);\n-                    self.pos += end;\n+                Substitution::Format(_) => if let Some(inner_span) = sub.position() {\n+                    sub.set_position(inner_span.start + self.pos, inner_span.end + self.pos);\n+                    self.pos += inner_span.end;\n                 }\n                 Substitution::Escape => self.pos += 2,\n             }\n@@ -373,7 +374,7 @@ pub mod printf {\n                     precision: None,\n                     length: None,\n                     type_: at.slice_between(next).unwrap(),\n-                    position: (start.at, next.at),\n+                    position: InnerSpan::new(start.at, next.at),\n                 }),\n                 next.slice_after()\n             ));\n@@ -560,7 +561,7 @@ pub mod printf {\n         drop(next);\n \n         end = at;\n-        let position = (start.at, end.at);\n+        let position = InnerSpan::new(start.at, end.at);\n \n         let f = Format {\n             span: start.slice_between(end).unwrap(),\n@@ -650,7 +651,7 @@ pub mod printf {\n                                 precision: $prec,\n                                 length: $len,\n                                 type_: $type_,\n-                                position: $pos,\n+                                position: syntax_pos::InnerSpan::new($pos.0, $pos.1),\n                             }),\n                             \"!\"\n                         ))\n@@ -711,7 +712,7 @@ pub mod printf {\n         #[test]\n         fn test_iter() {\n             let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n-            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n             assert_eq!(\n                 subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n                 vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n@@ -761,6 +762,7 @@ pub mod printf {\n \n pub mod shell {\n     use super::strcursor::StrCursor as Cur;\n+    use syntax_pos::InnerSpan;\n \n     #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n@@ -778,11 +780,11 @@ pub mod shell {\n             }\n         }\n \n-        pub fn position(&self) -> Option<(usize, usize)> {\n+        pub fn position(&self) -> Option<InnerSpan> {\n             match self {\n                 Substitution::Ordinal(_, pos) |\n                 Substitution::Name(_, pos) |\n-                Substitution::Escape(pos) => Some(*pos),\n+                Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n             }\n         }\n \n@@ -804,10 +806,10 @@ pub mod shell {\n     }\n \n     /// Returns an iterator over all substitutions in a given string.\n-    pub fn iter_subs(s: &str) -> Substitutions<'_> {\n+    pub fn iter_subs(s: &str, start_pos: usize) -> Substitutions<'_> {\n         Substitutions {\n             s,\n-            pos: 0,\n+            pos: start_pos,\n         }\n     }\n \n@@ -823,7 +825,7 @@ pub mod shell {\n             match parse_next_substitution(self.s) {\n                 Some((mut sub, tail)) => {\n                     self.s = tail;\n-                    if let Some((start, end)) = sub.position() {\n+                    if let Some(InnerSpan { start, end }) = sub.position() {\n                         sub.set_position(start + self.pos, end + self.pos);\n                         self.pos += end;\n                     }\n@@ -940,7 +942,7 @@ pub mod shell {\n         fn test_iter() {\n             use super::iter_subs;\n             let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n-            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n             assert_eq!(\n                 subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n                 vec![Some(\"{0}\"), None, Some(\"{WORD}\")]"}, {"sha": "512513e9b414c8d1aa2cdff8811755f55be18e3a", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -16,11 +16,11 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n                                        feature_gate::EXPLAIN_TRACE_MACROS);\n     }\n \n-    match (tt.len(), tt.first()) {\n-        (1, Some(TokenTree::Token(token))) if token.is_keyword(kw::True) => {\n+    match tt {\n+        [TokenTree::Token(token)] if token.is_keyword(kw::True) => {\n             cx.set_trace_macros(true);\n         }\n-        (1, Some(TokenTree::Token(token))) if token.is_keyword(kw::False) => {\n+        [TokenTree::Token(token)] if token.is_keyword(kw::False) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}, {"sha": "e7158372762dd99dba0c5f8c4594c5ce0505d4cc", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -505,10 +505,10 @@ impl Span {\n         )\n     }\n \n-    pub fn from_inner_byte_pos(self, start: usize, end: usize) -> Span {\n+    pub fn from_inner(self, inner: InnerSpan) -> Span {\n         let span = self.data();\n-        Span::new(span.lo + BytePos::from_usize(start),\n-                  span.lo + BytePos::from_usize(end),\n+        Span::new(span.lo + BytePos::from_usize(inner.start),\n+                  span.lo + BytePos::from_usize(inner.end),\n                   span.ctxt)\n     }\n \n@@ -1396,6 +1396,18 @@ pub struct MalformedSourceMapPositions {\n     pub end_pos: BytePos\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct InnerSpan {\n+    pub start: usize,\n+    pub end: usize,\n+}\n+\n+impl InnerSpan {\n+    pub fn new(start: usize, end: usize) -> InnerSpan {\n+        InnerSpan { start, end }\n+    }\n+}\n+\n // Given a slice of line start positions and a position, returns the index of\n // the line the position is on. Returns -1 if the position is located before\n // the first line."}, {"sha": "029685bcc2429e620058b30d6f043f4e8f89c25a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c4797fa4f4a696b183b3aa1517ee22c78d0f5d7a", "patch": "@@ -203,6 +203,7 @@ symbols! {\n         core_intrinsics,\n         crate_id,\n         crate_in_paths,\n+        crate_local,\n         crate_name,\n         crate_type,\n         crate_visibility_modifier,\n@@ -221,6 +222,7 @@ symbols! {\n         deref,\n         deref_mut,\n         derive,\n+        direct,\n         doc,\n         doc_alias,\n         doc_cfg,\n@@ -278,8 +280,10 @@ symbols! {\n         format_args_nl,\n         from,\n         From,\n+        from_desugaring,\n         from_error,\n         from_generator,\n+        from_method,\n         from_ok,\n         from_usize,\n         fundamental,\n@@ -443,6 +447,7 @@ symbols! {\n         panic_impl,\n         panic_implementation,\n         panic_runtime,\n+        parent_trait,\n         partial_cmp,\n         PartialOrd,\n         passes,\n@@ -569,6 +574,7 @@ symbols! {\n         __rust_unstable_column,\n         rvalue_static_promotion,\n         sanitizer_runtime,\n+        _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n         Send,"}]}