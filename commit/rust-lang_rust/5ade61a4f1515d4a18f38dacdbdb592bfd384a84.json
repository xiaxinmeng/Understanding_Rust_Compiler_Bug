{"sha": "5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZGU2MWE0ZjE1MTVkNGExOGYzOGRhY2RiZGI1OTJiZmQzODRhODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-24T14:07:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-24T14:07:06Z"}, "message": "Auto merge of #63823 - petrochenkov:noapply2, r=matthewjasper\n\nAudit uses of `apply_mark` in built-in macros + Remove default macro transparencies\n\nEvery use of `apply_mark` in a built-in or procedural macro is supposed to look like this\n```rust\nlocation.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id))\n```\nwhere `SyntaxContext::root()` means that the built-in/procedural macro is defined directly, rather than expanded from some other macro.\n\nHowever, few people understood what `apply_mark` does, so we had a lot of copy-pasted uses of it looking e.g. like\n```rust\nspan = span.apply_mark(ecx.current_expansion.id);\n```\n, which doesn't really make sense for procedural macros, but at the same time is not too harmful, if the macros use the traditional `macro_rules` hygiene.\n\nSo, to fight this, we stop using `apply_mark` directly in built-in macro implementations, and follow the example of regular proc macros instead and use analogues of `Span::def_site()` and `Span::call_site()`, which are much more intuitive and less error-prone.\n- `ecx.with_def_site_ctxt(span)` takes the `span`'s location and combines it with a def-site context.\n- `ecx.with_call_site_ctxt(span)` takes the `span`'s location and combines it with a call-site context.\n\nEven if called multiple times (which sometimes happens due to some historical messiness of the built-in macro code) these functions will produce the same result, unlike `apply_mark` which will grow  the mark chain further in this case.\n\n---\n\nAfter `apply_mark`s in built-in macros are eliminated, the remaining `apply_mark`s are very few in number, so we can start passing the previously implicit `Transparency` argument to them explicitly, thus eliminating the need in `default_transparency` fields in hygiene structures and `#[rustc_macro_transparency]` annotations on built-in macros.\n\nSo, the task of making built-in macros opaque can now be formulated as \"eliminate `with_legacy_ctxt` in favor of `with_def_site_ctxt`\" rather than \"replace `#[rustc_macro_transparency = \"semitransparent\"]` with `#[rustc_macro_transparency = \"opaque\"]`\".\n\nr? @matthewjasper", "tree": {"sha": "0f61e1e6a0e1833aae8cefb15658c37f1f5a419d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f61e1e6a0e1833aae8cefb15658c37f1f5a419d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "html_url": "https://github.com/rust-lang/rust/commit/5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "478464570e60523adc6d303577d1782229ca1f93", "url": "https://api.github.com/repos/rust-lang/rust/commits/478464570e60523adc6d303577d1782229ca1f93", "html_url": "https://github.com/rust-lang/rust/commit/478464570e60523adc6d303577d1782229ca1f93"}, {"sha": "6548a5fa5d1f6d1794592945837111f7264ae598", "url": "https://api.github.com/repos/rust-lang/rust/commits/6548a5fa5d1f6d1794592945837111f7264ae598", "html_url": "https://github.com/rust-lang/rust/commit/6548a5fa5d1f6d1794592945837111f7264ae598"}], "stats": {"total": 331, "additions": 152, "deletions": 179}, "files": [{"sha": "ffaca029a8a78be3d31c72e8e349bec3eb81eaa3", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -734,7 +734,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -747,7 +746,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -1235,42 +1233,36 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n     #[unstable(feature = \"test\", issue = \"50297\",\n                reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro bench($item:item) { /* compiler built-in */ }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n     #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n                reason = \"custom test frameworks are an unstable feature\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro global_allocator($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "05e2c7854b49ce7917ffa383ae57d363fd0f8451", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -402,7 +402,6 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     parent -> _,\n     call_site,\n     def_site,\n-    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,"}, {"sha": "c21639d0dcaee0898e65e284684787ed1a6dc71d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -593,8 +593,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n         let location = || Span::with_root_ctxt(lo, hi);\n-        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n-            let span = location().fresh_expansion(expn_data);\n+        let recover_from_expn_data = |this: &Self, expn_data, transparency, pos| {\n+            let span = location().fresh_expansion_with_transparency(expn_data, transparency);\n             this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -603,9 +603,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 location()\n             }\n             TAG_EXPN_DATA_INLINE => {\n-                let expn_data = Decodable::decode(self)?;\n+                let (expn_data, transparency) = Decodable::decode(self)?;\n                 recover_from_expn_data(\n-                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n+                    self, expn_data, transparency, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n             TAG_EXPN_DATA_SHORTHAND => {\n@@ -614,9 +614,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_data =\n-                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n-                    recover_from_expn_data(self, expn_data, pos)\n+                    let (expn_data, transparency) =\n+                        self.with_position(pos.to_usize(), |this| Decodable::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, transparency, pos)\n                 }\n             }\n             _ => {\n@@ -819,15 +819,15 @@ where\n         if span_data.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            let (expn_id, transparency, expn_data) = span_data.ctxt.outer_mark_with_data();\n             if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n                 TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n                 pos.encode(self)\n             } else {\n                 TAG_EXPN_DATA_INLINE.encode(self)?;\n                 let pos = AbsoluteBytePos::new(self.position());\n                 self.expn_data_shorthands.insert(expn_id, pos);\n-                expn_data.encode(self)\n+                (expn_data, transparency).encode(self)\n             }\n         }\n     }"}, {"sha": "9a794ade729c208d92435992a2dd365bff90f1d6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -145,7 +145,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }"}, {"sha": "875ae449d94e0f0e9d5f47d208b88cf71b208e64", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -1647,10 +1647,14 @@ impl<'a> Resolver<'a> {\n             if module.expansion != parent.expansion &&\n             module.expansion.is_descendant_of(parent.expansion) {\n                 // The macro is a proc macro derive\n-                if module.expansion.looks_like_proc_macro_derive() {\n-                    if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n-                        *poisoned = Some(node_id);\n-                        return module.parent;\n+                if let Some(&def_id) = self.macro_defs.get(&module.expansion) {\n+                    if let Some(ext) = self.get_macro_by_def_id(def_id) {\n+                        if !ext.is_builtin && ext.macro_kind() == MacroKind::Derive {\n+                            if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n+                                *poisoned = Some(node_id);\n+                                return module.parent;\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "a63c4181d5e039a1d2a996e7327c63526f2768dc", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n+use crate::ext::hygiene::{ExpnId, Transparency};\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n@@ -549,8 +549,6 @@ pub struct SyntaxExtension {\n     pub kind: SyntaxExtensionKind,\n     /// Span of the macro definition.\n     pub span: Span,\n-    /// Hygienic properties of spans produced by this macro by default.\n-    pub default_transparency: Transparency,\n     /// Whitelist of unstable features that are treated as stable inside this macro.\n     pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     /// Suppresses the `unsafe_code` lint for code produced by this macro.\n@@ -572,22 +570,6 @@ pub struct SyntaxExtension {\n     pub is_derive_copy: bool,\n }\n \n-impl SyntaxExtensionKind {\n-    /// When a syntax extension is constructed,\n-    /// its transparency can often be inferred from its kind.\n-    fn default_transparency(&self) -> Transparency {\n-        match self {\n-            SyntaxExtensionKind::Bang(..) |\n-            SyntaxExtensionKind::Attr(..) |\n-            SyntaxExtensionKind::Derive(..) |\n-            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtensionKind::LegacyBang(..) |\n-            SyntaxExtensionKind::LegacyAttr(..) |\n-            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n-        }\n-    }\n-}\n-\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n     pub fn macro_kind(&self) -> MacroKind {\n@@ -606,7 +588,6 @@ impl SyntaxExtension {\n     pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n         SyntaxExtension {\n             span: DUMMY_SP,\n-            default_transparency: kind.default_transparency(),\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n@@ -646,7 +627,6 @@ impl SyntaxExtension {\n             parent,\n             call_site,\n             def_site: self.span,\n-            default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n             allow_internal_unsafe: self.allow_internal_unsafe,\n             local_inner_macros: self.local_inner_macros,\n@@ -760,23 +740,39 @@ impl<'a> ExtCtxt<'a> {\n     pub fn call_site(&self) -> Span {\n         self.current_expansion.id.expn_data().call_site\n     }\n-    pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::root().apply_mark(self.current_expansion.id)\n+\n+    /// Equivalent of `Span::def_site` from the proc macro API,\n+    /// except that the location is taken from the span passed as an argument.\n+    pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Opaque)\n+    }\n+\n+    /// Equivalent of `Span::call_site` from the proc macro API,\n+    /// except that the location is taken from the span passed as an argument.\n+    pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Transparent)\n+    }\n+\n+    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n+    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n+    /// or with `with_call_site_ctxt` (where necessary).\n+    pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n+        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::SemiTransparent)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Option<Span> {\n-        let mut ctxt = self.backtrace();\n+        let mut expn_id = self.current_expansion.id;\n         let mut last_macro = None;\n         loop {\n-            let expn_data = ctxt.outer_expn_data();\n+            let expn_data = expn_id.expn_data();\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n                 break;\n             }\n-            ctxt = expn_data.call_site.ctxt();\n+            expn_id = expn_data.call_site.ctxt().outer_expn();\n             last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n@@ -865,7 +861,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n-        let def_site = DUMMY_SP.apply_mark(self.current_expansion.id);\n+        let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()"}, {"sha": "c8c0f4ce36e8edbc8122f4bc7c70242bcf2b4b2b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -565,7 +565,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         return fragment_kind.dummy(span);\n                     }\n                     let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span, path };\n-                    let span = span.with_ctxt(self.cx.backtrace());\n                     let items = expander.expand(self.cx, span, &meta, item);\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n@@ -1389,17 +1388,3 @@ impl<'feat> ExpansionConfig<'feat> {\n         self.features.map_or(false, |features| features.custom_inner_attributes)\n     }\n }\n-\n-// A Marker adds the given mark to the syntax context.\n-#[derive(Debug)]\n-pub struct Marker(pub ExpnId);\n-\n-impl MutVisitor for Marker {\n-    fn visit_span(&mut self, span: &mut Span) {\n-        *span = span.apply_mark(self.0)\n-    }\n-\n-    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n-        noop_visit_mac(mac, self)\n-    }\n-}"}, {"sha": "b1bbd2aaac9714b206ae517b2cf7a23f010cf6dc", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -7,7 +7,6 @@ use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint}\n use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n-use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{kw, sym, Symbol};\n \n use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n@@ -363,16 +362,10 @@ impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n         let location = cx.current_expansion.id.expn_data().call_site;\n-        let to_span = |transparency| {\n-            location.with_ctxt(\n-                SyntaxContext::root()\n-                    .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n-            )\n-        };\n         Rustc {\n             sess: cx.parse_sess,\n-            def_site: to_span(Transparency::Opaque),\n-            call_site: to_span(Transparency::Transparent),\n+            def_site: cx.with_def_site_ctxt(location),\n+            call_site: cx.with_call_site_ctxt(location),\n         }\n     }\n "}, {"sha": "37cb8467ff5eefb81c1b1a4162fd5c7215442521", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -19,6 +19,7 @@ use crate::{ast, attr, attr::TransparencyError};\n \n use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -128,6 +129,7 @@ impl<'a> ParserAnyMacro<'a> {\n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     span: Span,\n+    transparency: Transparency,\n     lhses: Vec<quoted::TokenTree>,\n     rhses: Vec<quoted::TokenTree>,\n     valid: bool,\n@@ -143,7 +145,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n-        generic_extension(cx, sp, self.span, self.name, input, &self.lhses, &self.rhses)\n+        generic_extension(\n+            cx, sp, self.span, self.name, self.transparency, input, &self.lhses, &self.rhses\n+        )\n     }\n }\n \n@@ -158,6 +162,7 @@ fn generic_extension<'cx>(\n     sp: Span,\n     def_span: Span,\n     name: ast::Ident,\n+    transparency: Transparency,\n     arg: TokenStream,\n     lhses: &[quoted::TokenTree],\n     rhses: &[quoted::TokenTree],\n@@ -187,7 +192,7 @@ fn generic_extension<'cx>(\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, &named_matches, rhs);\n+                let mut tts = transcribe(cx, &named_matches, rhs, transparency);\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n@@ -415,11 +420,7 @@ pub fn compile(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let expander: Box<_> =\n-        Box::new(MacroRulesMacroExpander { name: def.ident, span: def.span, lhses, rhses, valid });\n-\n-    let (default_transparency, transparency_error) =\n-        attr::find_transparency(&def.attrs, body.legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n             sess.span_diagnostic.span_err(\n@@ -432,6 +433,10 @@ pub fn compile(\n         None => {}\n     }\n \n+    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n+        name: def.ident, span: def.span, transparency, lhses, rhses, valid\n+    });\n+\n     let allow_internal_unstable =\n         attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {\n             attr.meta_item_list()\n@@ -473,7 +478,6 @@ pub fn compile(\n     SyntaxExtension {\n         kind: SyntaxExtensionKind::LegacyBang(expander),\n         span: def.span,\n-        default_transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe: attr::contains_name(&def.attrs, sym::allow_internal_unsafe),\n         local_inner_macros,"}, {"sha": "30d5df13dcedb1d3551c2cb337f3d76a25f36b5d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -1,18 +1,40 @@\n-use crate::ast::Ident;\n+use crate::ast::{Ident, Mac};\n use crate::ext::base::ExtCtxt;\n-use crate::ext::expand::Marker;\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::ext::tt::quoted;\n-use crate::mut_visit::noop_visit_tt;\n+use crate::mut_visit::{self, MutVisitor};\n use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnId, Transparency};\n+use syntax_pos::Span;\n+\n use std::mem;\n \n+// A Marker adds the given mark to the syntax context.\n+struct Marker(ExpnId, Transparency);\n+\n+impl MutVisitor for Marker {\n+    fn visit_span(&mut self, span: &mut Span) {\n+        *span = span.apply_mark(self.0, self.1)\n+    }\n+\n+    fn visit_mac(&mut self, mac: &mut Mac) {\n+        mut_visit::noop_visit_mac(mac, self)\n+    }\n+}\n+\n+impl Marker {\n+    fn visit_delim_span(&mut self, dspan: &mut DelimSpan) {\n+        self.visit_span(&mut dspan.open);\n+        self.visit_span(&mut dspan.close);\n+    }\n+}\n+\n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited { forest: Lrc<quoted::Delimited>, idx: usize, span: DelimSpan },\n@@ -68,6 +90,7 @@ pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n     interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n+    transparency: Transparency,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n@@ -96,6 +119,7 @@ pub(super) fn transcribe(\n     // again, and we are done transcribing.\n     let mut result: Vec<TreeAndJoint> = Vec::new();\n     let mut result_stack = Vec::new();\n+    let mut marker = Marker(cx.current_expansion.id, transparency);\n \n     loop {\n         // Look at the last frame on the stack.\n@@ -207,7 +231,7 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            quoted::TokenTree::MetaVar(mut sp, ident) => {\n+            quoted::TokenTree::MetaVar(mut sp, mut ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n@@ -218,7 +242,7 @@ pub(super) fn transcribe(\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.apply_mark(cx.current_expansion.id);\n+                            marker.visit_span(&mut sp);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n@@ -232,9 +256,8 @@ pub(super) fn transcribe(\n                 } else {\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n-                    let ident =\n-                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.id));\n-                    sp = sp.apply_mark(cx.current_expansion.id);\n+                    marker.visit_span(&mut sp);\n+                    marker.visit_ident(&mut ident);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n                     result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n@@ -246,17 +269,16 @@ pub(super) fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.apply_mark(cx.current_expansion.id);\n+                marker.visit_delim_span(&mut span);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n             quoted::TokenTree::Token(token) => {\n-                let mut marker = Marker(cx.current_expansion.id);\n                 let mut tt = TokenTree::Token(token);\n-                noop_visit_tt(&mut tt, &mut marker);\n+                marker.visit_tt(&mut tt);\n                 result.push(tt.into());\n             }\n "}, {"sha": "0d9f3769ce90447133c3e3a548eaaf60406ec789", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -19,7 +19,7 @@ use crate::parse::Directory;\n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n use crate::print::pprust;\n \n-use syntax_pos::{BytePos, ExpnId, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n@@ -547,11 +547,4 @@ impl DelimSpan {\n     pub fn entire(self) -> Span {\n         self.open.with_hi(self.close.hi())\n     }\n-\n-    pub fn apply_mark(self, expn_id: ExpnId) -> Self {\n-        DelimSpan {\n-            open: self.open.apply_mark(expn_id),\n-            close: self.close.apply_mark(expn_id),\n-        }\n-    }\n }"}, {"sha": "28f907441d872391f8d3eb17aa98b9b3c13fd81c", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -63,7 +63,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(inline_asm)),\n-        span: sp.with_ctxt(cx.backtrace()),\n+        span: cx.with_legacy_ctxt(sp),\n         attrs: ThinVec::new(),\n     }))\n }"}, {"sha": "84583d0e5eca7410e2e23a0afd448386c2cc1f1b", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -23,7 +23,7 @@ pub fn expand_assert<'cx>(\n         }\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n     let panic_call = Mac {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {"}, {"sha": "21cee8ae1cb9c661c630ee9f788450e5d4d93aab", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -16,7 +16,7 @@ pub fn expand_cfg(\n     sp: Span,\n     tts: &[tokenstream::TokenTree],\n ) -> Box<dyn base::MacResult + 'static> {\n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {"}, {"sha": "ffa5154ca0c36b6cc1b03e2ae57b9be7303b7039", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -59,6 +59,6 @@ pub fn expand_syntax_ext(\n     } else if has_errors {\n         return DummyResult::any(sp);\n     }\n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "96677072d1b80bfc153e2fd2ac96afbc9570665e", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -39,7 +39,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         }\n     }\n \n-    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.id));\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), cx.with_legacy_ctxt(sp));\n \n     struct ConcatIdentsResult { ident: ast::Ident }\n "}, {"sha": "4dd0ecfebefd41d8ed260dbfd459834469870868", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -112,7 +112,7 @@ fn cs_clone_shallow(name: &str,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = span.with_ctxt(cx.backtrace());\n+        let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::clone, Symbol::intern(helper_name)]),\n                                         vec![GenericArg::Type(ty)], vec![]);"}, {"sha": "32ab47969ada4f6c9f36640d5eac0fb162904852", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -53,7 +53,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = span.with_ctxt(cx.backtrace());\n+        let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::cmp, Symbol::intern(helper_name)]),\n                                         vec![GenericArg::Type(ty)], vec![]);"}, {"sha": "781645a574e9ac76993e70aa86b86c713b1bfb04", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -60,7 +60,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     };\n \n     // We want to make sure we have the ctxt set so that we can use unstable methods\n-    let span = span.with_ctxt(cx.backtrace());\n+    let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let builder = Ident::from_str_and_span(\"debug_trait_builder\", span);\n     let builder_expr = cx.expr_ident(span, builder.clone());"}, {"sha": "cb1c7b21fee0d21b0b932c4f2ebac161ede26273", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -85,7 +85,7 @@ impl<'a> Path<'a> {\n             PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n             PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n             PathKind::Std => {\n-                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.id);\n+                let def_site = cx.with_def_site_ctxt(DUMMY_SP);\n                 idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n                 cx.path_all(span, false, idents, params, Vec::new())\n             }"}, {"sha": "60b6eba7a4b53d54baa4a6505c600cddf69674e7", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -48,6 +48,9 @@ impl MultiItemModifier for BuiltinDerive {\n               meta_item: &MetaItem,\n               item: Annotatable)\n               -> Vec<Annotatable> {\n+        // FIXME: Built-in derives often forget to give spans contexts,\n+        // so we are doing it here in a centralized way.\n+        let span = ecx.with_def_site_ctxt(span);\n         let mut items = Vec::new();\n         (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n         items\n@@ -60,7 +63,7 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    let span = span.with_ctxt(cx.backtrace());\n+    let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "6343d218de82921520e4c3e9f50b316234ef3d8e", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -20,7 +20,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         Some(v) => v,\n     };\n \n-    let sp = sp.apply_mark(cx.current_expansion.id);\n+    let sp = cx.with_legacy_ctxt(sp);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             let lt = cx.lifetime(sp, Ident::with_dummy_span(kw::StaticLifetime));"}, {"sha": "47394c02b4186cca294de29f49f7ba9180f4be09", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -12,7 +12,7 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n use syntax::tokenstream;\n-use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n+use syntax_pos::{MultiSpan, Span};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::borrow::Cow;\n@@ -666,8 +666,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n             let name = names_pos[i];\n-            let span =\n-                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.id));\n+            let span = self.ecx.with_def_site_ctxt(e.span);\n             pats.push(self.ecx.pat_ident(span, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n                 locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n@@ -745,7 +744,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ty: &ArgumentType,\n         arg: ast::Ident,\n     ) -> P<ast::Expr> {\n-        sp = sp.apply_mark(ecx.current_expansion.id);\n+        sp = ecx.with_def_site_ctxt(sp);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n@@ -798,7 +797,7 @@ fn expand_format_args_impl<'cx>(\n     tts: &[tokenstream::TokenTree],\n     nl: bool,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    sp = sp.apply_mark(ecx.current_expansion.id);\n+    sp = ecx.with_def_site_ctxt(sp);\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, nl))\n@@ -842,7 +841,7 @@ pub fn expand_preparsed_format_args(\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n \n     let mut macsp = ecx.call_site();\n-    macsp = macsp.with_ctxt(ecx.backtrace());\n+    macsp = ecx.with_def_site_ctxt(macsp);\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;"}, {"sha": "97b8087ad1581647656716e0275bf6b9bcc6026b", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -3,7 +3,6 @@ use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n@@ -29,7 +28,7 @@ pub fn expand(\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory\n-    let span = item.span.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n+    let span = ecx.with_legacy_ctxt(item.span);\n     let f = AllocFnFactory {\n         span,\n         kind: AllocatorKind::Global,"}, {"sha": "a8b61593db749a1b04a62c817e4acce39f26bf35", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -30,7 +30,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ItemKind::GlobalAsm(P(global_asm)),\n                 vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-                span: sp.with_ctxt(cx.backtrace()),\n+                span: cx.with_legacy_ctxt(sp),\n                 tokens: None,\n             })])\n         }"}, {"sha": "5fd87d3a0e5c60d45f3c8296880cd10a973045b5", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -4,7 +4,6 @@\n use syntax::ast;\n use syntax::attr::{self, check_builtin_macro_attribute};\n use syntax::ext::base::*;\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::print::pprust;\n use syntax::source_map::respan;\n use syntax::symbol::{Symbol, sym};\n@@ -29,7 +28,7 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n+    let sp = ecx.with_legacy_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n@@ -93,8 +92,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::root().apply_mark(cx.current_expansion.id);\n-    let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n+    let (sp, attr_sp) = (cx.with_legacy_ctxt(item.span), cx.with_legacy_ctxt(attr_sp));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names\n     let test_id = cx.ident_of(\"test\").gensym();"}, {"sha": "733f6f0449065c6cfc157802fa66c345631022ac", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -119,18 +119,6 @@ impl ExpnId {\n     pub fn outer_expn_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, data.outer_expn(ctxt)))\n     }\n-\n-    // Used for enabling some compatibility fallback in resolve.\n-    #[inline]\n-    pub fn looks_like_proc_macro_derive(self) -> bool {\n-        HygieneData::with(|data| {\n-            let expn_data = data.expn_data(self);\n-            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_data.kind {\n-                return expn_data.default_transparency == Transparency::Opaque;\n-            }\n-            false\n-        })\n-    }\n }\n \n #[derive(Debug)]\n@@ -195,24 +183,25 @@ impl HygieneData {\n         self.syntax_context_data[ctxt.0 as usize].outer_expn\n     }\n \n-    fn outer_transparency(&self, ctxt: SyntaxContext) -> Transparency {\n-        self.syntax_context_data[ctxt.0 as usize].outer_transparency\n+    fn outer_mark(&self, ctxt: SyntaxContext) -> (ExpnId, Transparency) {\n+        let data = &self.syntax_context_data[ctxt.0 as usize];\n+        (data.outer_expn, data.outer_transparency)\n     }\n \n     fn parent_ctxt(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].parent\n     }\n \n-    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> ExpnId {\n-        let outer_expn = self.outer_expn(*ctxt);\n+    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> (ExpnId, Transparency) {\n+        let outer_mark = self.outer_mark(*ctxt);\n         *ctxt = self.parent_ctxt(*ctxt);\n-        outer_expn\n+        outer_mark\n     }\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n         while ctxt != SyntaxContext::root() {\n-            marks.push((self.outer_expn(ctxt), self.outer_transparency(ctxt)));\n+            marks.push(self.outer_mark(ctxt));\n             ctxt = self.parent_ctxt(ctxt);\n         }\n         marks.reverse();\n@@ -229,20 +218,14 @@ impl HygieneData {\n     fn adjust(&self, ctxt: &mut SyntaxContext, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut scope = None;\n         while !self.is_descendant_of(expn_id, self.outer_expn(*ctxt)) {\n-            scope = Some(self.remove_mark(ctxt));\n+            scope = Some(self.remove_mark(ctxt).0);\n         }\n         scope\n     }\n \n-    fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n-        assert_ne!(expn_id, ExpnId::root());\n-        self.apply_mark_with_transparency(\n-            ctxt, expn_id, self.expn_data(expn_id).default_transparency\n-        )\n-    }\n-\n-    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n-                                    transparency: Transparency) -> SyntaxContext {\n+    fn apply_mark(\n+        &mut self, ctxt: SyntaxContext, expn_id: ExpnId, transparency: Transparency\n+    ) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n         if transparency == Transparency::Opaque {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n@@ -376,15 +359,9 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    /// Extend a syntax context with a given expansion and default transparency for that expansion.\n-    pub fn apply_mark(self, expn_id: ExpnId) -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark(self, expn_id))\n-    }\n-\n     /// Extend a syntax context with a given expansion and transparency.\n-    pub fn apply_mark_with_transparency(self, expn_id: ExpnId, transparency: Transparency)\n-                                        -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark_with_transparency(self, expn_id, transparency))\n+    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+        HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n \n     /// Pulls a single mark off of the syntax context. This effectively moves the\n@@ -404,7 +381,7 @@ impl SyntaxContext {\n     /// invocation of f that created g1.\n     /// Returns the mark that was removed.\n     pub fn remove_mark(&mut self) -> ExpnId {\n-        HygieneData::with(|data| data.remove_mark(self))\n+        HygieneData::with(|data| data.remove_mark(self).0)\n     }\n \n     pub fn marks(self) -> Vec<(ExpnId, Transparency)> {\n@@ -477,8 +454,8 @@ impl SyntaxContext {\n             let mut scope = None;\n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n-                scope = Some(data.remove_mark(&mut glob_ctxt));\n-                if data.remove_mark(self) != scope.unwrap() {\n+                scope = Some(data.remove_mark(&mut glob_ctxt).0);\n+                if data.remove_mark(self).0 != scope.unwrap() {\n                     return None;\n                 }\n             }\n@@ -509,9 +486,9 @@ impl SyntaxContext {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n             }\n \n-            let scope = marks.last().cloned();\n-            while let Some(mark) = marks.pop() {\n-                *self = data.apply_mark(*self, mark);\n+            let scope = marks.last().map(|mark| mark.0);\n+            while let Some((expn_id, transparency)) = marks.pop() {\n+                *self = data.apply_mark(*self, expn_id, transparency);\n             }\n             Some(scope)\n         })\n@@ -547,13 +524,11 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n-    /// `ctxt.outer_expn_with_data()` is equivalent to but faster than\n-    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_data()) }`.\n     #[inline]\n-    pub fn outer_expn_with_data(self) -> (ExpnId, ExpnData) {\n+    pub fn outer_mark_with_data(self) -> (ExpnId, Transparency, ExpnData) {\n         HygieneData::with(|data| {\n-            let outer = data.outer_expn(self);\n-            (outer, data.expn_data(outer).clone())\n+            let (expn_id, transparency) = data.outer_mark(self);\n+            (expn_id, transparency, data.expn_data(expn_id).clone())\n         })\n     }\n \n@@ -575,9 +550,15 @@ impl Span {\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n     pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n+        self.fresh_expansion_with_transparency(expn_data, Transparency::SemiTransparent)\n+    }\n+\n+    pub fn fresh_expansion_with_transparency(\n+        self, expn_data: ExpnData, transparency: Transparency\n+    ) -> Span {\n         HygieneData::with(|data| {\n             let expn_id = data.fresh_expn(Some(expn_data));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id))\n+            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id, transparency))\n         })\n     }\n }\n@@ -609,8 +590,6 @@ pub struct ExpnData {\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for the expansion with this expansion data by default.\n-    pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n     /// to them.\n@@ -633,7 +612,6 @@ impl ExpnData {\n             parent: ExpnId::root(),\n             call_site,\n             def_site: DUMMY_SP,\n-            default_transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,"}, {"sha": "3d8bfc77a89500533316eaa19161c711445891a8", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ade61a4f1515d4a18f38dacdbdb592bfd384a84/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=5ade61a4f1515d4a18f38dacdbdb592bfd384a84", "patch": "@@ -22,6 +22,7 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n pub use hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind, MacroKind, DesugaringKind};\n+use hygiene::Transparency;\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -512,10 +513,17 @@ impl Span {\n                   span.ctxt)\n     }\n \n+    /// Produces a span with the same location as `self` and context produced by a macro with the\n+    /// given ID and transparency, assuming that macro was defined directly and not produced by\n+    /// some other macro (which is the case for built-in and procedural macros).\n+    pub fn with_ctxt_from_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {\n+        self.with_ctxt(SyntaxContext::root().apply_mark(expn_id, transparency))\n+    }\n+\n     #[inline]\n-    pub fn apply_mark(self, mark: ExpnId) -> Span {\n+    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.apply_mark(mark))\n+        span.with_ctxt(span.ctxt.apply_mark(expn_id, transparency))\n     }\n \n     #[inline]"}]}