{"sha": "8e4a9710841a21f77856ae1d8207015c220a1873", "node_id": "C_kwDOAAsO6NoAKDhlNGE5NzEwODQxYTIxZjc3ODU2YWUxZDgyMDcwMTVjMjIwYTE4NzM", "commit": {"author": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2022-07-11T19:11:03Z"}, "committer": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2022-07-11T21:20:38Z"}, "message": "extract method to read scrutinee conditionally", "tree": {"sha": "788dbad5433ce00b2e1589b33b694304f07dbd3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/788dbad5433ce00b2e1589b33b694304f07dbd3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e4a9710841a21f77856ae1d8207015c220a1873", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE0u8S3YU336XkLsQOPNdIZH7vY1kFAmLMlCYACgkQPNdIZH7v\nY1nQRhAAk8/R+8uXklDo8KI8MiahqwaN5Tp66BuCpSj8YFABnb9kShL3YvYORlV0\nH1flGEdSgGvyLjIxKoyeAjlWcJeMAbvx3Fnda3Ntk7uPHTDzzpl/czsEioWxGUNY\nIQF8UNdilx9aTvttV1T89fpms1NuU5FZdSNVlOc1qJPHCRwHTccukTw74smRaVqS\ngDnZDSRzOdEuPOR6oHLdKv7g8V5ehU+b0eFCLZ1CqODLE0WE9+MaF0CR0cMnMZ1O\nOB+eepYuyO3GH4vcslBS5/XEyJw1GQQ7ODPJ+vV9+qSV4jpgI4aCR8BT7HT3SaM9\nZk2t4JbY3gtLDpH6kXN8g3qnzwIBc3oZLN2In4gXjJz+E3+chnQBFmP1JFsvGtLQ\nE1RqIgxVVWMU5vwhBykUAgDwFMosfmVaBzwJPsXbSVOKNqERGmXZNVH/Yz8sgvf1\nznDMtOAXyoY7yCp7TGvgPjTRyV7qll3rdERl+ooMnPULxk1t29Jbp5eTeVolSmk5\nKzfneICrv30KKwPPMl+Bi5n39frndp9ucG4UfJ1x8fUb2VreSXgWhNwFE+qER3UP\ntIbD5xh1XJ7Y20QYPI8Q1NqQ30Vt3fLO56CRD3ucJh6tj2pA/Bx8c+wwlrDkg25b\n7gKOLGu4rMQUZA2LB5c+QBOKN95q5mPnPZB2zZRNhL9cfgmEw2s=\n=tRHP\n-----END PGP SIGNATURE-----", "payload": "tree 788dbad5433ce00b2e1589b33b694304f07dbd3c\nparent 1cd30e7b32df602cf455d34ff8042079b8e082a3\nauthor Ding Xiang Fei <dingxiangfei2009@protonmail.ch> 1657566663 +0200\ncommitter Ding Xiang Fei <dingxiangfei2009@protonmail.ch> 1657574438 +0200\n\nextract method to read scrutinee conditionally\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4a9710841a21f77856ae1d8207015c220a1873", "html_url": "https://github.com/rust-lang/rust/commit/8e4a9710841a21f77856ae1d8207015c220a1873", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e4a9710841a21f77856ae1d8207015c220a1873/comments", "author": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cd30e7b32df602cf455d34ff8042079b8e082a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd30e7b32df602cf455d34ff8042079b8e082a3", "html_url": "https://github.com/rust-lang/rust/commit/1cd30e7b32df602cf455d34ff8042079b8e082a3"}], "stats": {"total": 208, "additions": 105, "deletions": 103}, "files": [{"sha": "7cbfe143b4d83d3701a7b30e5571f8e4d4322c1c", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e4a9710841a21f77856ae1d8207015c220a1873/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4a9710841a21f77856ae1d8207015c220a1873/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=8e4a9710841a21f77856ae1d8207015c220a1873", "patch": "@@ -36,20 +36,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             match s.kind {\n                 StmtKind::Local(ref local) => {\n                     let hir_id = self.lower_node_id(s.id);\n-                    let els = if let LocalKind::InitElse(_, els) = &local.kind {\n-                        if !self.tcx.features().let_else {\n-                            feature_err(\n-                                &self.tcx.sess.parse_sess,\n-                                sym::let_else,\n-                                s.span,\n-                                \"`let...else` statements are unstable\",\n-                            )\n-                            .emit();\n-                        }\n-                        Some(self.lower_block(els, false))\n-                    } else {\n-                        None\n-                    };\n                     let local = self.lower_local(local);\n                     self.alias_attrs(hir_id, local.hir_id);\n                     let kind = hir::StmtKind::Local(local);\n@@ -106,9 +92,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let hir_id = self.lower_node_id(l.id);\n         let pat = self.lower_pat(&l.pat);\n         let els = if let LocalKind::InitElse(_, els) = &l.kind {\n-            if !self.sess.features_untracked().let_else {\n+            if !self.tcx.features().let_else {\n                 feature_err(\n-                    &self.sess.parse_sess,\n+                    &self.tcx.sess.parse_sess,\n                     sym::let_else,\n                     l.span,\n                     \"`let...else` statements are unstable\","}, {"sha": "53a456cf94643031ca86b8b62db15e82b95345b0", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 103, "deletions": 87, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8e4a9710841a21f77856ae1d8207015c220a1873/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4a9710841a21f77856ae1d8207015c220a1873/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=8e4a9710841a21f77856ae1d8207015c220a1873", "patch": "@@ -2,7 +2,10 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n+use std::slice::from_ref;\n+\n use hir::def::DefKind;\n+use hir::Expr;\n // Export these here so that Clippy can use them.\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n@@ -257,91 +260,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(discr));\n-\n-                // Matching should not always be considered a use of the place, hence\n-                // discr does not necessarily need to be borrowed.\n-                // We only want to borrow discr if the pattern contain something other\n-                // than wildcards.\n-                let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n-                let mut needs_to_be_read = false;\n-                for arm in arms.iter() {\n-                    return_if_err!(mc.cat_pattern(discr_place.clone(), arm.pat, |place, pat| {\n-                        match &pat.kind {\n-                            PatKind::Binding(.., opt_sub_pat) => {\n-                                // If the opt_sub_pat is None, than the binding does not count as\n-                                // a wildcard for the purpose of borrowing discr.\n-                                if opt_sub_pat.is_none() {\n-                                    needs_to_be_read = true;\n-                                }\n-                            }\n-                            PatKind::Path(qpath) => {\n-                                // A `Path` pattern is just a name like `Foo`. This is either a\n-                                // named constant or else it refers to an ADT variant\n-\n-                                let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n-                                match res {\n-                                    Res::Def(DefKind::Const, _)\n-                                    | Res::Def(DefKind::AssocConst, _) => {\n-                                        // Named constants have to be equated with the value\n-                                        // being matched, so that's a read of the value being matched.\n-                                        //\n-                                        // FIXME: We don't actually  reads for ZSTs.\n-                                        needs_to_be_read = true;\n-                                    }\n-                                    _ => {\n-                                        // Otherwise, this is a struct/enum variant, and so it's\n-                                        // only a read if we need to read the discriminant.\n-                                        needs_to_be_read |= is_multivariant_adt(place.place.ty());\n-                                    }\n-                                }\n-                            }\n-                            PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n-                                // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n-                                // against a multivariant enum or struct. In that case, we have to read\n-                                // the discriminant. Otherwise this kind of pattern doesn't actually\n-                                // read anything (we'll get invoked for the `...`, which may indeed\n-                                // perform some reads).\n-\n-                                let place_ty = place.place.ty();\n-                                needs_to_be_read |= is_multivariant_adt(place_ty);\n-                            }\n-                            PatKind::Lit(_) | PatKind::Range(..) => {\n-                                // If the PatKind is a Lit or a Range then we want\n-                                // to borrow discr.\n-                                needs_to_be_read = true;\n-                            }\n-                            PatKind::Or(_)\n-                            | PatKind::Box(_)\n-                            | PatKind::Slice(..)\n-                            | PatKind::Ref(..)\n-                            | PatKind::Wild => {\n-                                // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n-                                // as these patterns contains subpatterns\n-                                // If the PatKind is Wild, the decision is made based on the other patterns being\n-                                // examined\n-                            }\n-                        }\n-                    }));\n-                }\n-\n-                if needs_to_be_read {\n-                    self.borrow_expr(discr, ty::ImmBorrow);\n-                } else {\n-                    let closure_def_id = match discr_place.place.base {\n-                        PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n-                        _ => None,\n-                    };\n-\n-                    self.delegate.fake_read(\n-                        &discr_place,\n-                        FakeReadCause::ForMatchedPlace(closure_def_id),\n-                        discr_place.hir_id,\n-                    );\n-\n-                    // We always want to walk the discriminant. We want to make sure, for instance,\n-                    // that the discriminant has been initialized.\n-                    self.walk_expr(discr);\n-                }\n+                self.maybe_read_scrutinee(\n+                    discr,\n+                    discr_place.clone(),\n+                    arms.iter().map(|arm| arm.pat),\n+                );\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -470,6 +393,97 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn maybe_read_scrutinee<'t>(\n+        &mut self,\n+        discr: &Expr<'_>,\n+        discr_place: PlaceWithHirId<'tcx>,\n+        pats: impl Iterator<Item = &'t hir::Pat<'t>>,\n+    ) {\n+        // Matching should not always be considered a use of the place, hence\n+        // discr does not necessarily need to be borrowed.\n+        // We only want to borrow discr if the pattern contain something other\n+        // than wildcards.\n+        let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n+        let mut needs_to_be_read = false;\n+        for pat in pats {\n+            return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n+                match &pat.kind {\n+                    PatKind::Binding(.., opt_sub_pat) => {\n+                        // If the opt_sub_pat is None, than the binding does not count as\n+                        // a wildcard for the purpose of borrowing discr.\n+                        if opt_sub_pat.is_none() {\n+                            needs_to_be_read = true;\n+                        }\n+                    }\n+                    PatKind::Path(qpath) => {\n+                        // A `Path` pattern is just a name like `Foo`. This is either a\n+                        // named constant or else it refers to an ADT variant\n+\n+                        let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n+                        match res {\n+                            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {\n+                                // Named constants have to be equated with the value\n+                                // being matched, so that's a read of the value being matched.\n+                                //\n+                                // FIXME: We don't actually  reads for ZSTs.\n+                                needs_to_be_read = true;\n+                            }\n+                            _ => {\n+                                // Otherwise, this is a struct/enum variant, and so it's\n+                                // only a read if we need to read the discriminant.\n+                                needs_to_be_read |= is_multivariant_adt(place.place.ty());\n+                            }\n+                        }\n+                    }\n+                    PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n+                        // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n+                        // against a multivariant enum or struct. In that case, we have to read\n+                        // the discriminant. Otherwise this kind of pattern doesn't actually\n+                        // read anything (we'll get invoked for the `...`, which may indeed\n+                        // perform some reads).\n+\n+                        let place_ty = place.place.ty();\n+                        needs_to_be_read |= is_multivariant_adt(place_ty);\n+                    }\n+                    PatKind::Lit(_) | PatKind::Range(..) => {\n+                        // If the PatKind is a Lit or a Range then we want\n+                        // to borrow discr.\n+                        needs_to_be_read = true;\n+                    }\n+                    PatKind::Or(_)\n+                    | PatKind::Box(_)\n+                    | PatKind::Slice(..)\n+                    | PatKind::Ref(..)\n+                    | PatKind::Wild => {\n+                        // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n+                        // as these patterns contains subpatterns\n+                        // If the PatKind is Wild, the decision is made based on the other patterns being\n+                        // examined\n+                    }\n+                }\n+            }));\n+        }\n+\n+        if needs_to_be_read {\n+            self.borrow_expr(discr, ty::ImmBorrow);\n+        } else {\n+            let closure_def_id = match discr_place.place.base {\n+                PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n+                _ => None,\n+            };\n+\n+            self.delegate.fake_read(\n+                &discr_place,\n+                FakeReadCause::ForMatchedPlace(closure_def_id),\n+                discr_place.hir_id,\n+            );\n+\n+            // We always want to walk the discriminant. We want to make sure, for instance,\n+            // that the discriminant has been initialized.\n+            self.walk_expr(discr);\n+        }\n+    }\n+\n     fn walk_local<F>(\n         &mut self,\n         expr: &hir::Expr<'_>,\n@@ -484,10 +498,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         f(self);\n         if let Some(els) = els {\n             // borrowing because we need to test the descriminant\n-            self.borrow_expr(expr, ImmBorrow);\n+            // self.borrow_expr(expr, ImmBorrow);\n+            self.maybe_read_scrutinee(expr, expr_place, from_ref(pat).iter());\n             self.walk_block(els)\n+        } else {\n+            self.walk_irrefutable_pat(&expr_place, &pat);\n         }\n-        self.walk_irrefutable_pat(&expr_place, &pat);\n     }\n \n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved"}]}