{"sha": "9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3Nzk1MjZkOGYyMGY0ZGNkYjFkMzNlYWIwMTcwY2M3ZDVmNDEwYTk=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-06T16:05:40Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-08T11:07:24Z"}, "message": "Record coercion adjustments", "tree": {"sha": "64f3b7494670bada397f47a84c2e9d216813b18b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64f3b7494670bada397f47a84c2e9d216813b18b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "html_url": "https://github.com/rust-lang/rust/commit/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e44c56b61656b2eed55a5b9180febd74b3333c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/e44c56b61656b2eed55a5b9180febd74b3333c72", "html_url": "https://github.com/rust-lang/rust/commit/e44c56b61656b2eed55a5b9180febd74b3333c72"}], "stats": {"total": 427, "additions": 340, "deletions": 87}, "files": [{"sha": "7838bbe5c1c8d234cc6ca03ef3c5024f6f340aa2", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -109,7 +109,7 @@ impl<'a> PatCtxt<'a> {\n         self.infer.pat_adjustments.get(&pat).map(|it| &**it).unwrap_or_default().iter().rev().fold(\n             unadjusted_pat,\n             |subpattern, ref_ty| Pat {\n-                ty: ref_ty.clone(),\n+                ty: ref_ty.target.clone(),\n                 kind: Box::new(PatKind::Deref { subpattern }),\n             },\n         )"}, {"sha": "a66caa369ca1f5c8408a68b5c73ff93469de563e", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 89, "deletions": 4, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -16,7 +16,7 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -103,12 +103,20 @@ impl Default for BindingMode {\n }\n \n #[derive(Debug)]\n-pub(crate) struct InferOk {\n+pub(crate) struct InferOk<T> {\n+    value: T,\n     goals: Vec<InEnvironment<Goal>>,\n }\n+\n+impl<T> InferOk<T> {\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> InferOk<U> {\n+        InferOk { value: f(self.value), goals: self.goals }\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct TypeError;\n-pub(crate) type InferResult = Result<InferOk, TypeError>;\n+pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n@@ -134,6 +142,78 @@ impl Default for InternedStandardTypes {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Adjustment {\n+    pub kind: Adjust,\n+    pub target: Ty,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Adjust {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+\n+    /// Dereference once, producing a place.\n+    Deref(Option<OverloadedDeref>),\n+\n+    /// Take the address and produce either a `&` or `*` pointer.\n+    Borrow(AutoBorrow),\n+\n+    Pointer(PointerCast),\n+}\n+\n+// impl fmt::Display for Adjust {\n+//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+//         match self {\n+//             Adjust::NeverToAny => write!(f, \"NeverToAny\"),\n+//             Adjust::Deref(_) => write!(f, \"Deref\"), // FIXME\n+//             Adjust::Borrow(AutoBorrow::Ref(mt)) => write!(f, \"BorrowRef{:?}\", mt),\n+//             Adjust::Borrow(AutoBorrow::RawPtr(mt)) => write!(f, \"BorrowRawPtr{:?}\", mt),\n+//             Adjust::Pointer(cast) => write!(f, \"PtrCast{:?}\", cast),\n+//         }\n+//     }\n+// }\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct OverloadedDeref(Mutability);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AutoBorrow {\n+    Ref(Mutability),\n+    RawPtr(Mutability),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum PointerCast {\n+    /// Go from a fn-item type to a fn-pointer type.\n+    ReifyFnPointer,\n+\n+    /// Go from a safe fn pointer to an unsafe fn pointer.\n+    UnsafeFnPointer,\n+\n+    /// Go from a non-capturing closure to an fn pointer or an unsafe fn pointer.\n+    /// It cannot convert a closure that requires unsafe.\n+    ClosureFnPointer(Safety),\n+\n+    /// Go from a mut raw pointer to a const raw pointer.\n+    MutToConstPointer,\n+\n+    /// Go from `*const [T; N]` to `*const T`\n+    ArrayToPointer,\n+\n+    /// Unsize a pointer/reference value, e.g., `&[T; n]` to\n+    /// `&[T]`. Note that the source could be a thin or fat pointer.\n+    /// This will do things like convert thin pointers to fat\n+    /// pointers, or convert structs containing thin pointers to\n+    /// structs containing fat pointers, or convert between fat\n+    /// pointers. We don't store the details of how the transform is\n+    /// done (in fact, we don't know that, because it might depend on\n+    /// the precise type parameters). We just store the target\n+    /// type. Codegen backends and miri figure out what has to be done\n+    /// based on the precise source/target type at hand.\n+    Unsize,\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n@@ -156,7 +236,8 @@ pub struct InferenceResult {\n     /// Interned Unknown to return references to.\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n-    pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n+    pub pat_adjustments: FxHashMap<PatId, Vec<Adjustment>>,\n+    pub expr_adjustments: FxHashMap<ExprId, Vec<Adjustment>>,\n }\n \n impl InferenceResult {\n@@ -303,6 +384,10 @@ impl<'a> InferenceContext<'a> {\n         self.result.type_of_expr.insert(expr, ty);\n     }\n \n+    fn write_expr_adj(&mut self, expr: ExprId, adjustments: Vec<Adjustment>) {\n+        self.result.expr_adjustments.insert(expr, adjustments);\n+    }\n+\n     fn write_method_resolution(&mut self, expr: ExprId, func: FunctionId, subst: Substitution) {\n         self.result.method_resolutions.insert(expr, (func, subst));\n     }"}, {"sha": "a5c97f25dd01d31f2ccbe730b814daf08ae111d2", "filename": "crates/hir_ty/src/infer/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -1,7 +1,7 @@\n //! Inference of closure parameter types based on the closure's expected type.\n \n use chalk_ir::{cast::Cast, AliasTy, FnSubst, WhereClause};\n-use hir_def::HasModule;\n+use hir_def::{expr::ExprId, HasModule};\n use smallvec::SmallVec;\n \n use crate::{\n@@ -14,6 +14,7 @@ use super::{Expectation, InferenceContext};\n impl InferenceContext<'_> {\n     pub(super) fn deduce_closure_type_from_expectations(\n         &mut self,\n+        closure_expr: ExprId,\n         closure_ty: &Ty,\n         sig_ty: &Ty,\n         expectation: &Expectation,\n@@ -24,8 +25,9 @@ impl InferenceContext<'_> {\n         };\n \n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n-        self.coerce(closure_ty, &expected_ty);\n-\n+        if let Ok(res) = self.coerce(closure_ty, &expected_ty) {\n+            self.write_expr_adj(closure_expr, res.value.0);\n+        }\n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(&Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {"}, {"sha": "578e1b07a0ebbe53f45cd93cbf1f5734e59cd0cc", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 165, "deletions": 57, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -5,30 +5,52 @@\n //! See <https://doc.rust-lang.org/nomicon/coercions.html> and\n //! `librustc_typeck/check/coercion.rs`.\n \n-use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n+use chalk_ir::{cast::Cast, Goal, Mutability, TyVariableKind};\n use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n \n use crate::{\n-    autoderef, infer::TypeMismatch, static_lifetime, Canonical, DomainGoal, FnPointer, FnSig,\n-    Interner, Solution, Substitution, Ty, TyBuilder, TyExt, TyKind,\n+    autoderef,\n+    infer::{Adjust, Adjustment, AutoBorrow, PointerCast, TypeMismatch},\n+    static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Interner, Solution, Substitution, Ty,\n+    TyBuilder, TyExt, TyKind,\n };\n \n-use super::{InEnvironment, InferOk, InferResult, InferenceContext, TypeError};\n+use super::{InEnvironment, InferOk, InferenceContext, TypeError};\n+\n+pub(crate) type CoerceResult = Result<InferOk<(Vec<Adjustment>, Ty)>, TypeError>;\n+\n+/// Do not require any adjustments, i.e. coerce `x -> x`.\n+fn identity(_: Ty) -> Vec<Adjustment> {\n+    vec![]\n+}\n+\n+fn simple(kind: Adjust) -> impl FnOnce(Ty) -> Vec<Adjustment> {\n+    move |target| vec![Adjustment { kind, target }]\n+}\n+\n+/// This always returns `Ok(...)`.\n+fn success(\n+    adj: Vec<Adjustment>,\n+    target: Ty,\n+    goals: Vec<InEnvironment<Goal<Interner>>>,\n+) -> CoerceResult {\n+    Ok(InferOk { goals, value: (adj, target) })\n+}\n \n impl<'a> InferenceContext<'a> {\n     /// Unify two types, but may coerce the first one to the second one\n     /// using \"implicit coercion rules\" if needed.\n-    pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+    pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> CoerceResult {\n         let from_ty = self.resolve_ty_shallow(from_ty);\n         let to_ty = self.resolve_ty_shallow(to_ty);\n         match self.coerce_inner(from_ty, &to_ty) {\n-            Ok(result) => {\n-                self.table.register_infer_ok(result);\n-                true\n+            Ok(InferOk { value, goals }) => {\n+                self.table.register_infer_ok(InferOk { value: (), goals });\n+                Ok(InferOk { value, goals: Vec::new() })\n             }\n-            Err(_) => {\n+            Err(e) => {\n                 // FIXME deal with error\n-                false\n+                Err(e)\n             }\n         }\n     }\n@@ -41,6 +63,7 @@ impl<'a> InferenceContext<'a> {\n     ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n     ///    least upper bound.\n     pub(super) fn coerce_merge_branch(&mut self, id: Option<ExprId>, ty1: &Ty, ty2: &Ty) -> Ty {\n+        // TODO\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n         // Special case: two function types. Try to coerce both to\n@@ -72,9 +95,9 @@ impl<'a> InferenceContext<'a> {\n         // type is a type variable and the new one is `!`, trying it the other\n         // way around first would mean we make the type variable `!`, instead of\n         // just marking it as possibly diverging.\n-        if self.coerce(&ty2, &ty1) {\n+        if self.coerce(&ty2, &ty1).is_ok() {\n             ty1\n-        } else if self.coerce(&ty1, &ty2) {\n+        } else if self.coerce(&ty1, &ty2).is_ok() {\n             ty2\n         } else {\n             if let Some(id) = id {\n@@ -87,7 +110,7 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn coerce_inner(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+    fn coerce_inner(&mut self, from_ty: Ty, to_ty: &Ty) -> CoerceResult {\n         if from_ty.is_never() {\n             // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n             // type variable, we want `?T` to fallback to `!` if not\n@@ -96,13 +119,10 @@ impl<'a> InferenceContext<'a> {\n             //     let _: Option<?T> = Some({ return; });\n             //\n             // here, we would coerce from `!` to `?T`.\n-            match to_ty.kind(&Interner) {\n-                TyKind::InferenceVar(tv, TyVariableKind::General) => {\n-                    self.table.set_diverging(*tv, true);\n-                }\n-                _ => {}\n+            if let TyKind::InferenceVar(tv, TyVariableKind::General) = to_ty.kind(&Interner) {\n+                self.table.set_diverging(*tv, true);\n             }\n-            return Ok(InferOk { goals: Vec::new() });\n+            return success(simple(Adjust::NeverToAny)(to_ty.clone()), to_ty.clone(), vec![]);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -143,35 +163,64 @@ impl<'a> InferenceContext<'a> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.table.try_unify(&from_ty, to_ty)\n+                self.unify_and(&from_ty, to_ty, identity)\n             }\n         }\n     }\n \n-    fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n-        let (_is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n+    /// Unify two types (using sub or lub) and produce a specific coercion.\n+    fn unify_and<F>(&mut self, t1: &Ty, t2: &Ty, f: F) -> CoerceResult\n+    where\n+        F: FnOnce(Ty) -> Vec<Adjustment>,\n+    {\n+        self.table\n+            .try_unify(t1, t2)\n+            .and_then(|InferOk { goals, .. }| success(f(t1.clone()), t1.clone(), goals))\n+    }\n+\n+    fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n+        let (is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n             TyKind::Ref(mt, _, ty) => (true, mt, ty),\n             TyKind::Raw(mt, ty) => (false, mt, ty),\n-            _ => return self.table.try_unify(&from_ty, to_ty),\n+            _ => return self.unify_and(&from_ty, to_ty, identity),\n         };\n \n         coerce_mutabilities(*from_mt, to_mt)?;\n \n         // Check that the types which they point at are compatible.\n         let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n-        // FIXME: behavior differs based on is_ref once we're computing adjustments\n-        self.table.try_unify(&from_raw, to_ty)\n+        // self.table.try_unify(&from_raw, to_ty);\n+\n+        // Although references and unsafe ptrs have the same\n+        // representation, we still register an Adjust::DerefRef so that\n+        // regionck knows that the region for `a` must be valid here.\n+        if is_ref {\n+            self.unify_and(&from_raw, to_ty, |target| {\n+                vec![\n+                    Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n+                    Adjustment { kind: Adjust::Borrow(AutoBorrow::RawPtr(to_mt)), target },\n+                ]\n+            })\n+        } else if *from_mt != to_mt {\n+            self.unify_and(\n+                &from_raw,\n+                to_ty,\n+                simple(Adjust::Pointer(PointerCast::MutToConstPointer)),\n+            )\n+        } else {\n+            self.unify_and(&from_raw, to_ty, identity)\n+        }\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> InferResult {\n+    fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n         match from_ty.kind(&Interner) {\n             TyKind::Ref(mt, _, _) => {\n                 coerce_mutabilities(*mt, to_mt)?;\n             }\n-            _ => return self.table.try_unify(&from_ty, to_ty),\n+            _ => return self.unify_and(&from_ty, to_ty, identity),\n         };\n \n         // NOTE: this code is mostly copied and adapted from rustc, and\n@@ -227,7 +276,7 @@ impl<'a> InferenceContext<'a> {\n             let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(&Interner);\n             match self.table.try_unify(&derefd_from_ty, to_ty) {\n                 Ok(result) => {\n-                    found = Some(result);\n+                    found = Some(result.map(|()| derefd_from_ty));\n                     break;\n                 }\n                 Err(err) => {\n@@ -243,19 +292,23 @@ impl<'a> InferenceContext<'a> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let result = match found {\n+        let InferOk { value: ty, goals } = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 return Err(err);\n             }\n         };\n-\n-        Ok(result)\n+        // FIXME: record overloarded deref adjustments\n+        success(\n+            vec![Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)), target: ty.clone() }],\n+            ty,\n+            goals,\n+        )\n     }\n \n     /// Attempts to coerce from the type of a Rust function item into a function pointer.\n-    fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> InferResult {\n+    fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> CoerceResult {\n         match to_ty.kind(&Interner) {\n             TyKind::Function(_) => {\n                 let from_sig = from_ty.callable_sig(self.db).expect(\"FnDef had no sig\");\n@@ -267,11 +320,28 @@ impl<'a> InferenceContext<'a> {\n \n                 let from_sig = from_sig.to_fn_ptr();\n                 let from_fn_pointer = TyKind::Function(from_sig.clone()).intern(&Interner);\n-                let ok = self.coerce_from_safe_fn(from_fn_pointer, &from_sig, to_ty)?;\n+                let ok = self.coerce_from_safe_fn(\n+                    from_fn_pointer.clone(),\n+                    &from_sig,\n+                    to_ty,\n+                    |unsafe_ty| {\n+                        vec![\n+                            Adjustment {\n+                                kind: Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                                target: from_fn_pointer,\n+                            },\n+                            Adjustment {\n+                                kind: Adjust::Pointer(PointerCast::UnsafeFnPointer),\n+                                target: unsafe_ty,\n+                            },\n+                        ]\n+                    },\n+                    simple(Adjust::Pointer(PointerCast::ReifyFnPointer)),\n+                )?;\n \n                 Ok(ok)\n             }\n-            _ => self.table.try_unify(&from_ty, to_ty),\n+            _ => self.unify_and(&from_ty, to_ty, identity),\n         }\n     }\n \n@@ -280,26 +350,38 @@ impl<'a> InferenceContext<'a> {\n         from_ty: Ty,\n         from_f: &FnPointer,\n         to_ty: &Ty,\n-    ) -> InferResult {\n-        self.coerce_from_safe_fn(from_ty, from_f, to_ty)\n+    ) -> CoerceResult {\n+        self.coerce_from_safe_fn(\n+            from_ty,\n+            from_f,\n+            to_ty,\n+            simple(Adjust::Pointer(PointerCast::UnsafeFnPointer)),\n+            identity,\n+        )\n     }\n \n-    fn coerce_from_safe_fn(\n+    fn coerce_from_safe_fn<F, G>(\n         &mut self,\n         from_ty: Ty,\n         from_fn_ptr: &FnPointer,\n         to_ty: &Ty,\n-    ) -> InferResult {\n+        to_unsafe: F,\n+        normal: G,\n+    ) -> CoerceResult\n+    where\n+        F: FnOnce(Ty) -> Vec<Adjustment>,\n+        G: FnOnce(Ty) -> Vec<Adjustment>,\n+    {\n         if let TyKind::Function(to_fn_ptr) = to_ty.kind(&Interner) {\n             if let (chalk_ir::Safety::Safe, chalk_ir::Safety::Unsafe) =\n                 (from_fn_ptr.sig.safety, to_fn_ptr.sig.safety)\n             {\n                 let from_unsafe =\n                     TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(&Interner);\n-                return self.table.try_unify(&from_unsafe, to_ty);\n+                return self.unify_and(&from_unsafe, to_ty, to_unsafe);\n             }\n         }\n-        self.table.try_unify(&from_ty, to_ty)\n+        self.unify_and(&from_ty, to_ty, normal)\n     }\n \n     /// Attempts to coerce from the type of a non-capturing closure into a\n@@ -309,9 +391,10 @@ impl<'a> InferenceContext<'a> {\n         from_ty: Ty,\n         from_substs: &Substitution,\n         to_ty: &Ty,\n-    ) -> InferResult {\n+    ) -> CoerceResult {\n         match to_ty.kind(&Interner) {\n-            TyKind::Function(fn_ty) /* if from_substs is non-capturing (FIXME) */ => {\n+            // if from_substs is non-capturing (FIXME)\n+            TyKind::Function(fn_ty) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n@@ -320,16 +403,20 @@ impl<'a> InferenceContext<'a> {\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n                 let safety = fn_ty.sig.safety;\n                 let pointer_ty = coerce_closure_fn_ty(from_substs, safety);\n-                self.table.try_unify(&pointer_ty, to_ty)\n+                self.unify_and(\n+                    &pointer_ty,\n+                    to_ty,\n+                    simple(Adjust::Pointer(PointerCast::ClosureFnPointer(safety))),\n+                )\n             }\n-            _ => self.table.try_unify(&from_ty, to_ty),\n+            _ => self.unify_and(&from_ty, to_ty, identity),\n         }\n     }\n \n     /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n     ///\n     /// See: <https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html>\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> InferResult {\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> CoerceResult {\n         // These 'if' statements require some explanation.\n         // The `CoerceUnsized` trait is special - it is only\n         // possible to write `impl CoerceUnsized<B> for A` where\n@@ -341,7 +428,7 @@ impl<'a> InferenceContext<'a> {\n         //\n         // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n         //\n-        // We can take advantage of this fact to avoid performing unecessary work.\n+        // We can take advantage of this fact to avoid performing unnecessary work.\n         // If either `source` or `target` is a type variable, then any applicable impl\n         // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n         // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for\n@@ -359,20 +446,34 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Handle reborrows before trying to solve `Source: CoerceUnsized<Target>`.\n-        let coerce_from = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n-            (TyKind::Ref(from_mt, _, from_inner), TyKind::Ref(to_mt, _, _)) => {\n-                coerce_mutabilities(*from_mt, *to_mt)?;\n+        let reborrow = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n+            (TyKind::Ref(from_mt, _, from_inner), &TyKind::Ref(to_mt, _, _)) => {\n+                coerce_mutabilities(*from_mt, to_mt)?;\n \n                 let lt = static_lifetime();\n-                TyKind::Ref(*to_mt, lt, from_inner.clone()).intern(&Interner)\n+                Some((\n+                    Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n+                    Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)),\n+                        target: TyKind::Ref(to_mt, lt, from_inner.clone()).intern(&Interner),\n+                    },\n+                ))\n             }\n-            (TyKind::Ref(from_mt, _, from_inner), TyKind::Raw(to_mt, _)) => {\n-                coerce_mutabilities(*from_mt, *to_mt)?;\n-\n-                TyKind::Raw(*to_mt, from_inner.clone()).intern(&Interner)\n+            (TyKind::Ref(from_mt, _, from_inner), &TyKind::Raw(to_mt, _)) => {\n+                coerce_mutabilities(*from_mt, to_mt)?;\n+\n+                Some((\n+                    Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n+                    Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::RawPtr(to_mt)),\n+                        target: TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner),\n+                    },\n+                ))\n             }\n-            _ => from_ty.clone(),\n+            _ => None,\n         };\n+        let coerce_from =\n+            reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n         let krate = self.resolver.krate().unwrap();\n         let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n@@ -417,8 +518,15 @@ impl<'a> InferenceContext<'a> {\n             // FIXME: should we accept ambiguous results here?\n             _ => return Err(TypeError),\n         };\n-\n-        Ok(InferOk { goals: Vec::new() })\n+        // TODO: this is probably wrong?\n+        let coerce_target = self.table.new_type_var();\n+        self.unify_and(&coerce_target, to_ty, |target| {\n+            let unsize = Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target };\n+            match reborrow {\n+                None => vec![unsize],\n+                Some((ref deref, ref autoref)) => vec![deref.clone(), autoref.clone(), unsize],\n+            }\n+        })\n     }\n }\n "}, {"sha": "a582d700f20beb40fabbd52bd0679fb774a14a22", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -56,15 +56,19 @@ impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, expected);\n         let ty = if let Some(target) = expected.only_has_type(&mut self.table) {\n-            if !self.coerce(&ty, &target) {\n-                self.result\n-                    .type_mismatches\n-                    .insert(expr.into(), TypeMismatch { expected: target, actual: ty.clone() });\n-                // Return actual type when type mismatch.\n-                // This is needed for diagnostic when return type mismatch.\n-                ty\n-            } else {\n-                target\n+            match self.coerce(&ty, &target) {\n+                Ok(res) => {\n+                    self.result.expr_adjustments.insert(expr, res.value.0);\n+                    target\n+                }\n+                Err(_) => {\n+                    self.result\n+                        .type_mismatches\n+                        .insert(expr.into(), TypeMismatch { expected: target, actual: ty.clone() });\n+                    // Return actual type when type mismatch.\n+                    // This is needed for diagnostic when return type mismatch.\n+                    ty\n+                }\n             }\n         } else {\n             ty\n@@ -163,16 +167,20 @@ impl<'a> InferenceContext<'a> {\n                             break_ty: break_ty.clone(),\n                             label: label.map(|label| self.body[label].name.clone()),\n                         });\n-                        let ty =\n-                            self.infer_block(statements, *tail, &Expectation::has_type(break_ty));\n+                        let ty = self.infer_block(\n+                            tgt_expr,\n+                            statements,\n+                            *tail,\n+                            &Expectation::has_type(break_ty),\n+                        );\n                         let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                         if ctxt.may_break {\n                             ctxt.break_ty\n                         } else {\n                             ty\n                         }\n                     }\n-                    None => self.infer_block(statements, *tail, expected),\n+                    None => self.infer_block(tgt_expr, statements, *tail, expected),\n                 };\n                 self.resolver = old_resolver;\n                 ty\n@@ -284,7 +292,12 @@ impl<'a> InferenceContext<'a> {\n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.deduce_closure_type_from_expectations(&closure_ty, &sig_ty, expected);\n+                self.deduce_closure_type_from_expectations(\n+                    tgt_expr,\n+                    &closure_ty,\n+                    &sig_ty,\n+                    expected,\n+                );\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -400,7 +413,9 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 } else {\n                     let unit = TyBuilder::unit();\n-                    self.coerce(&unit, &self.return_ty.clone());\n+                    if let Ok(ok) = self.coerce(&unit, &self.return_ty.clone()) {\n+                        self.write_expr_adj(tgt_expr, ok.value.0);\n+                    }\n                 }\n                 TyKind::Never.intern(&Interner)\n             }\n@@ -810,6 +825,7 @@ impl<'a> InferenceContext<'a> {\n \n     fn infer_block(\n         &mut self,\n+        expr: ExprId,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n         expected: &Expectation,\n@@ -856,7 +872,9 @@ impl<'a> InferenceContext<'a> {\n                 self.table.new_maybe_never_var()\n             } else {\n                 if let Some(t) = expected.only_has_type(&mut self.table) {\n-                    self.coerce(&TyBuilder::unit(), &t);\n+                    if let Ok(ok) = self.coerce(&TyBuilder::unit(), &t) {\n+                        self.write_expr_adj(expr, ok.value.0);\n+                    }\n                 }\n                 TyBuilder::unit()\n             }"}, {"sha": "86e2d1b8dfab307fa1820cef7829e37df8f1a42f", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -12,8 +12,9 @@ use hir_expand::name::Name;\n \n use super::{BindingMode, Expectation, InferenceContext, TypeMismatch};\n use crate::{\n-    lower::lower_to_chalk_mutability, static_lifetime, Interner, Substitution, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    infer::{Adjust, Adjustment, AutoBorrow},\n+    lower::lower_to_chalk_mutability,\n+    static_lifetime, Interner, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -103,7 +104,10 @@ impl<'a> InferenceContext<'a> {\n         if is_non_ref_pat(&body, pat) {\n             let mut pat_adjustments = Vec::new();\n             while let Some((inner, _lifetime, mutability)) = expected.as_reference() {\n-                pat_adjustments.push(expected.clone());\n+                pat_adjustments.push(Adjustment {\n+                    target: expected.clone(),\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(mutability)),\n+                });\n                 expected = self.resolve_ty_shallow(inner);\n                 default_bm = match default_bm {\n                     BindingMode::Move => BindingMode::Ref(mutability),"}, {"sha": "f9e4796c270aa9a289353ac57dfd713df1453c3e", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -315,7 +315,7 @@ impl<'a> InferenceTable<'a> {\n \n     /// Unify two types and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult {\n+    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult<()> {\n         match self.var_unification_table.relate(\n             &Interner,\n             &self.db,\n@@ -324,7 +324,7 @@ impl<'a> InferenceTable<'a> {\n             t1,\n             t2,\n         ) {\n-            Ok(result) => Ok(InferOk { goals: result.goals }),\n+            Ok(result) => Ok(InferOk { goals: result.goals, value: () }),\n             Err(chalk_ir::NoSolution) => Err(TypeError),\n         }\n     }\n@@ -347,7 +347,7 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n-    pub(crate) fn register_infer_ok(&mut self, infer_ok: InferOk) {\n+    pub(crate) fn register_infer_ok<T>(&mut self, infer_ok: InferOk<T>) {\n         infer_ok.goals.into_iter().for_each(|goal| self.register_obligation_in_env(goal));\n     }\n "}, {"sha": "af6e7732177df4bdfe885ee1711a9981260e2707", "filename": "crates/hir_ty/src/tests.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -33,7 +33,11 @@ use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};\n use tracing_tree::HierarchicalLayer;\n \n use crate::{\n-    db::HirDatabase, display::HirDisplay, infer::TypeMismatch, test_db::TestDB, InferenceResult, Ty,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    infer::{Adjustment, TypeMismatch},\n+    test_db::TestDB,\n+    InferenceResult, Ty,\n };\n \n // These tests compare the inference results for all expressions in a file\n@@ -79,6 +83,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n     let mut had_annotations = false;\n     let mut mismatches = HashMap::new();\n     let mut types = HashMap::new();\n+    let mut adjustments = HashMap::<_, Vec<_>>::new();\n     for (file_id, annotations) in db.extract_annotations() {\n         for (range, expected) in annotations {\n             let file_range = FileRange { file_id, range };\n@@ -88,6 +93,15 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 types.insert(file_range, expected.trim_start_matches(\"type: \").to_string());\n             } else if expected.starts_with(\"expected\") {\n                 mismatches.insert(file_range, expected);\n+            } else if expected.starts_with(\"adjustments: \") {\n+                adjustments.insert(\n+                    file_range,\n+                    expected\n+                        .trim_start_matches(\"adjustments: \")\n+                        .split(',')\n+                        .map(|it| it.trim().to_string())\n+                        .collect(),\n+                );\n             } else {\n                 panic!(\"unexpected annotation: {}\", expected);\n             }\n@@ -155,6 +169,19 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 };\n                 assert_eq!(actual, expected);\n             }\n+            if let Some(expected) = adjustments.remove(&range) {\n+                if let Some(adjustments) = inference_result.expr_adjustments.get(&expr) {\n+                    assert_eq!(\n+                        expected,\n+                        adjustments\n+                            .iter()\n+                            .map(|Adjustment { kind, .. }| format!(\"{:?}\", kind))\n+                            .collect::<Vec<_>>()\n+                    );\n+                } else {\n+                    panic!(\"expected {:?} adjustments, found none\", expected);\n+                }\n+            }\n         }\n \n         for (pat, mismatch) in inference_result.pat_type_mismatches() {\n@@ -212,6 +239,12 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n             format_to!(buf, \"{:?}: type {}\\n\", t.0.range, t.1);\n         }\n     }\n+    if !adjustments.is_empty() {\n+        format_to!(buf, \"Unchecked adjustments annotations:\\n\");\n+        for t in adjustments {\n+            format_to!(buf, \"{:?}: type {:?}\\n\", t.0.range, t.1);\n+        }\n+    }\n     assert!(buf.is_empty(), \"{}\", buf);\n }\n "}, {"sha": "6f146f9dd3196295d7807c6347233500822c8770", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9779526d8f20f4dcdb1d33eab0170cc7d5f410a9/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=9779526d8f20f4dcdb1d33eab0170cc7d5f410a9", "patch": "@@ -96,6 +96,7 @@ fn foo<T>(x: &[T]) -> &[T] { x }\n fn test() {\n     let x = if true {\n         foo(&[1])\n+         // ^^^^ adjustments: Deref(None), Borrow(Ref(Not)), Pointer(Unsize)\n     } else {\n         &[1]\n     };\n@@ -130,6 +131,7 @@ fn foo<T>(x: &[T]) -> &[T] { x }\n fn test(i: i32) {\n     let x = match i {\n         2 => foo(&[2]),\n+              // ^^^^ adjustments: Deref(None), Borrow(Ref(Not)), Pointer(Unsize)\n         1 => &[1],\n         _ => &[3],\n     };\n@@ -144,6 +146,7 @@ fn match_second_coerce() {\n         r#\"\n //- minicore: coerce_unsized\n fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+                          // ^^^^^^^ adjustments: NeverToAny\n fn test(i: i32) {\n     let x = match i {\n         1 => &[1],"}]}