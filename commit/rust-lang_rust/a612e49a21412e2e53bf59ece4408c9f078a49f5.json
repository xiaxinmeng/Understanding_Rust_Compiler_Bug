{"sha": "a612e49a21412e2e53bf59ece4408c9f078a49f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTJlNDlhMjE0MTJlMmU1M2JmNTllY2U0NDA4YzlmMDc4YTQ5ZjU=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-01-27T02:28:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-03T23:37:24Z"}, "message": "Converted the floating point types to the new string conversion functions.\n\nAlso fixed all conflicting calls of the old functions in the rest of the codebase.\n\nThe set of string conversion functions for each float type now consists of those items:\n- to_str(), converts to number in base 10\n- to_str_hex(), converts to number in base 16\n- to_str_radix(), converts to number in given radix\n- to_str_exact(), converts to number in base 10 with a exact number of trailing digits\n- to_str_digits(), converts to number in base 10 with a maximum number of trailing digits\n- implementations for to_str::ToStr and num::ToStrRadix\n- from_str(), parses a string as number in base 10 including decimal exponent and special values\n- from_str_hex(), parses a string as a number in base 16 including binary exponent and special values\n- from_str_radix(), parses a string as a number in a given base excluding any exponent and special values\n- implementations for from_str::FromStr and num::FromStrRadix", "tree": {"sha": "3f6e15da2c5a4b2ee4e9d287d43c90c81f3f93b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f6e15da2c5a4b2ee4e9d287d43c90c81f3f93b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a612e49a21412e2e53bf59ece4408c9f078a49f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a612e49a21412e2e53bf59ece4408c9f078a49f5", "html_url": "https://github.com/rust-lang/rust/commit/a612e49a21412e2e53bf59ece4408c9f078a49f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a612e49a21412e2e53bf59ece4408c9f078a49f5/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7113fd150ad169dcc0348f84bcd6042da0f9fd5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7113fd150ad169dcc0348f84bcd6042da0f9fd5c", "html_url": "https://github.com/rust-lang/rust/commit/7113fd150ad169dcc0348f84bcd6042da0f9fd5c"}], "stats": {"total": 841, "additions": 616, "deletions": 225}, "files": [{"sha": "ed0625624d80a3003fda8eb2bf0c34dcd77aa585", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -563,7 +563,7 @@ pub mod rt {\n     pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str, 6u)\n+              CountImplied => (float::to_str_digits, 6u)\n         };\n         let mut s = unsafe { to_str(f, digits) };\n         if 0.0 <= f {"}, {"sha": "a33a46192fdfd2f6128a44d88c5940e84e6d0915", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -18,6 +18,9 @@ use cmath;\n use cmp;\n use libc::{c_float, c_int};\n use num;\n+use option::Option;\n+use from_str;\n+use to_str;\n \n pub use cmath::c_float_targ_consts::*;\n \n@@ -333,6 +336,197 @@ impl f32: num::Round {\n     }\n }\n \n+/**\n+ * Section: String Conversions\n+ */\n+\n+/**\n+ * Converts a float to a string\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str(num: f32) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in hexadecimal format\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str_hex(num: f32) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in a given radix\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, rdx, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string with exactly the number of\n+ * provided significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigExact(dig));\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string with a maximum number of\n+ * significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_digits(num: f32, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigMax(dig));\n+    r\n+}\n+\n+impl f32: to_str::ToStr {\n+    #[inline(always)]\n+    pure fn to_str() -> ~str { to_str_digits(self, 8) }\n+}\n+\n+impl f32: num::ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+        to_str_radix(*self, rdx)\n+    }\n+}\n+\n+/**\n+ * Convert a string in base 10 to a float.\n+ * Accepts a optional decimal exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * '3.14'\n+ * * '+3.14', equivalent to '3.14'\n+ * * '-3.14'\n+ * * '2.5E10', or equivalently, '2.5e10'\n+ * * '2.5E-10'\n+ * * '.' (understood as 0)\n+ * * '5.'\n+ * * '.5', or, equivalently,  '0.5'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str(num: &str) -> Option<f32> {\n+    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+}\n+\n+/**\n+ * Convert a string in base 16 to a float.\n+ * Accepts a optional binary exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * 'a4.fe'\n+ * * '+a4.fe', equivalent to 'a4.fe'\n+ * * '-a4.fe'\n+ * * '2b.aP128', or equivalently, '2b.ap128'\n+ * * '2b.aP-128'\n+ * * '.' (understood as 0)\n+ * * 'c.'\n+ * * '.c', or, equivalently,  '0.c'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_hex(num: &str) -> Option<f32> {\n+    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+}\n+\n+/**\n+ * Convert a string in an given base to a float.\n+ *\n+ * Due to possible conflicts, this function does **not** accept\n+ * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+ * does it recognize exponents of any kind.\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ * * radix - The base to use. Must lie in the range [2 .. 36]\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number. Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n+    num::from_str_common(num, rdx, true, true, false, num::ExpNone, false)\n+}\n+\n+impl f32: from_str::FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(val: &str) -> Option<f32> { from_str(val) }\n+}\n+\n+impl f32: num::FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n+        from_str_radix(val, rdx)\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "276aa13da71f81e8368fe671664a3797c3b2db65", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -19,6 +19,9 @@ use cmp;\n use libc::{c_double, c_int};\n use libc;\n use num;\n+use option::Option;\n+use to_str;\n+use from_str;\n \n pub use cmath::c_double_targ_consts::*;\n \n@@ -357,6 +360,197 @@ impl f64: num::Round {\n     }\n }\n \n+/**\n+ * Section: String Conversions\n+ */\n+\n+/**\n+ * Converts a float to a string\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str(num: f64) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in hexadecimal format\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str_hex(num: f64) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in a given radix\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, rdx, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string with exactly the number of\n+ * provided significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigExact(dig));\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string with a maximum number of\n+ * significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_digits(num: f64, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigMax(dig));\n+    r\n+}\n+\n+impl f64: to_str::ToStr {\n+    #[inline(always)]\n+    pure fn to_str() -> ~str { to_str_digits(self, 8) }\n+}\n+\n+impl f64: num::ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+        to_str_radix(*self, rdx)\n+    }\n+}\n+\n+/**\n+ * Convert a string in base 10 to a float.\n+ * Accepts a optional decimal exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * '3.14'\n+ * * '+3.14', equivalent to '3.14'\n+ * * '-3.14'\n+ * * '2.5E10', or equivalently, '2.5e10'\n+ * * '2.5E-10'\n+ * * '.' (understood as 0)\n+ * * '5.'\n+ * * '.5', or, equivalently,  '0.5'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str(num: &str) -> Option<f64> {\n+    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+}\n+\n+/**\n+ * Convert a string in base 16 to a float.\n+ * Accepts a optional binary exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * 'a4.fe'\n+ * * '+a4.fe', equivalent to 'a4.fe'\n+ * * '-a4.fe'\n+ * * '2b.aP128', or equivalently, '2b.ap128'\n+ * * '2b.aP-128'\n+ * * '.' (understood as 0)\n+ * * 'c.'\n+ * * '.c', or, equivalently,  '0.c'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_hex(num: &str) -> Option<f64> {\n+    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+}\n+\n+/**\n+ * Convert a string in an given base to a float.\n+ *\n+ * Due to possible conflicts, this function does **not** accept\n+ * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+ * does it recognize exponents of any kind.\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ * * radix - The base to use. Must lie in the range [2 .. 36]\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number. Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n+    num::from_str_common(num, rdx, true, true, false, num::ExpNone, false)\n+}\n+\n+impl f64: from_str::FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(val: &str) -> Option<f64> { from_str(val) }\n+}\n+\n+impl f64: num::FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n+        from_str_radix(val, rdx)\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "4f683ed14f76f2a94afb885b9d4471eb788991ca", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 221, "deletions": 206, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -34,6 +34,8 @@ use num::Num::from_int;\n use option::{None, Option, Some};\n use str;\n use uint;\n+use to_str;\n+use from_str;\n \n pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n@@ -95,7 +97,7 @@ pub mod consts {\n     pub const ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n-/**\n+/*\n  * Section: String Conversions\n  */\n \n@@ -105,85 +107,41 @@ pub mod consts {\n  * # Arguments\n  *\n  * * num - The float value\n- * * digits - The number of significant digits\n- * * exact - Whether to enforce the exact number of significant digits\n  */\n-pub pure fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n-    if is_NaN(num) { return ~\"NaN\"; }\n-    if num == infinity { return ~\"inf\"; }\n-    if num == neg_infinity { return ~\"-inf\"; }\n-\n-    let mut (num, sign) = if num < 0.0 { (-num, ~\"-\") } else { (num, ~\"\") };\n-\n-    // truncated integer\n-    let trunc = num as uint;\n-\n-    // decimal remainder\n-    let mut frac = num - (trunc as float);\n-\n-    // stack of digits\n-    let mut fractionalParts = ~[];\n-\n-    // FIXME: (#2608)\n-    // This used to return right away without rounding, as \"~[-]num\",\n-    // but given epsilon like in f64.rs, I don't see how the comparison\n-    // to epsilon did much when only used there.\n-    //    if (frac < epsilon && !exact) || digits == 0u { return accum; }\n-    //\n-    // With something better, possibly weird results like this can be avoided:\n-    //     assert \"3.14158999999999988262\" == my_to_str_exact(3.14159, 20u);\n-\n-    let mut ii = digits;\n-    let mut epsilon_prime = 1.0 / pow_with_uint(10u, ii);\n-\n-    // while we still need digits\n-    // build stack of digits\n-    while ii > 0 && (frac >= epsilon_prime || exact) {\n-        // store the next digit\n-        frac *= 10.0;\n-        let digit = frac as uint;\n-        // Bleh: not really unsafe.\n-        unsafe { fractionalParts.push(digit); }\n-\n-        // calculate the next frac\n-        frac -= digit as float;\n-        epsilon_prime *= 10.0;\n-        ii -= 1u;\n-    }\n-\n-    let mut acc;\n-    let mut racc = ~\"\";\n-    let mut carry = if frac * 10.0 as uint >= 5 { 1 } else { 0 };\n-\n-    // turn digits into string\n-    // using stack of digits\n-    while !fractionalParts.is_empty() {\n-        // Bleh; shouldn't need to be unsafe\n-        let mut adjusted_digit = carry + unsafe { fractionalParts.pop() };\n-\n-        if adjusted_digit == 10 {\n-            carry = 1;\n-            adjusted_digit %= 10\n-        } else {\n-            carry = 0;\n-        };\n-\n-        racc = uint::str(adjusted_digit) + racc;\n-    }\n+#[inline(always)]\n+pub pure fn to_str(num: float) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n \n-    // pad decimals with trailing zeroes\n-    while racc.len() < digits && exact {\n-        racc += ~\"0\"\n-    }\n+/**\n+ * Converts a float to a string in hexadecimal format\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str_hex(num: float) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n \n-    // combine ints and decimals\n-    let mut ones = uint::str(trunc + carry);\n-    if racc == ~\"\" {\n-        acc = sign + ones;\n-    } else {\n-        acc = sign + ones + ~\".\" + racc;\n-    }\n-    move acc\n+/**\n+ * Converts a float to a string in a given radix\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, radix, true, true, num::SignNeg, num::DigAll);\n+    r\n }\n \n /**\n@@ -197,7 +155,9 @@ pub pure fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n-    to_str_common(num, digits, true)\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigExact(digits));\n+    r\n }\n \n #[test]\n@@ -206,7 +166,6 @@ pub fn test_to_str_exact_do_decimal() {\n     assert s == ~\"5.0000\";\n }\n \n-\n /**\n  * Converts a float to a string with a maximum number of\n  * significant digits\n@@ -217,12 +176,27 @@ pub fn test_to_str_exact_do_decimal() {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str(num: float, digits: uint) -> ~str {\n-    to_str_common(num, digits, false)\n+pub pure fn to_str_digits(num: float, digits: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigMax(digits));\n+    r\n+}\n+\n+impl float: to_str::ToStr {\n+    #[inline(always)]\n+    pure fn to_str() -> ~str { to_str_digits(self, 8) }\n+}\n+\n+impl float: num::ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        to_str_radix(*self, radix)\n+    }\n }\n \n /**\n- * Convert a string to a float\n+ * Convert a string in base 10 to a float.\n+ * Accepts a optional decimal exponent.\n  *\n  * This function accepts strings such as\n  *\n@@ -231,12 +205,12 @@ pub pure fn to_str(num: float, digits: uint) -> ~str {\n  * * '-3.14'\n  * * '2.5E10', or equivalently, '2.5e10'\n  * * '2.5E-10'\n- * * '', or, equivalently, '.' (understood as 0)\n+ * * '.' (understood as 0)\n  * * '5.'\n  * * '.5', or, equivalently,  '0.5'\n- * * 'inf', '-inf', 'NaN'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n  *\n- * Leading and trailing whitespace are ignored.\n+ * Leading and trailing whitespace represent an error.\n  *\n  * # Arguments\n  *\n@@ -245,125 +219,79 @@ pub pure fn to_str(num: float, digits: uint) -> ~str {\n  * # Return value\n  *\n  * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n+#[inline(always)]\n pub pure fn from_str(num: &str) -> Option<float> {\n-   if num == \"inf\" {\n-       return Some(infinity as float);\n-   } else if num == \"-inf\" {\n-       return Some(neg_infinity as float);\n-   } else if num == \"NaN\" {\n-       return Some(NaN as float);\n-   }\n-\n-   let mut pos = 0u;               //Current byte position in the string.\n-                                   //Used to walk the string in O(n).\n-   let len = str::len(num);        //Length of the string, in bytes.\n-\n-   if len == 0u { return None; }\n-   let mut total = 0f;             //Accumulated result\n-   let mut c     = 'z';            //Latest char.\n-\n-   //The string must start with one of the following characters.\n-   match str::char_at(num, 0u) {\n-      '-' | '+' | '0' .. '9' | '.' => (),\n-      _ => return None\n-   }\n-\n-   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n-   let mut neg = false;               //Sign of the result\n-   match str::char_at(num, 0u) {\n-      '-' => {\n-          neg = true;\n-          pos = 1u;\n-      }\n-      '+' => {\n-          pos = 1u;\n-      }\n-      _ => ()\n-   }\n+    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+}\n \n-   //Examine the following chars until '.', 'e', 'E'\n-   while(pos < len) {\n-       let char_range = str::char_range_at(num, pos);\n-       c   = char_range.ch;\n-       pos = char_range.next;\n-       match c {\n-         '0' .. '9' => {\n-           total = total * 10f;\n-           total += ((c as int) - ('0' as int)) as float;\n-         }\n-         '.' | 'e' | 'E' => break,\n-         _ => return None\n-       }\n-   }\n+/**\n+ * Convert a string in base 16 to a float.\n+ * Accepts a optional binary exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * 'a4.fe'\n+ * * '+a4.fe', equivalent to 'a4.fe'\n+ * * '-a4.fe'\n+ * * '2b.aP128', or equivalently, '2b.ap128'\n+ * * '2b.aP-128'\n+ * * '.' (understood as 0)\n+ * * 'c.'\n+ * * '.c', or, equivalently,  '0.c'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_hex(num: &str) -> Option<float> {\n+    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+}\n \n-   if c == '.' {//Examine decimal part\n-      let mut decimal = 1f;\n-      while(pos < len) {\n-         let char_range = str::char_range_at(num, pos);\n-         c = char_range.ch;\n-         pos = char_range.next;\n-         match c {\n-            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  => {\n-                 decimal /= 10f;\n-                 total += (((c as int) - ('0' as int)) as float)*decimal;\n-             }\n-             'e' | 'E' => break,\n-             _ => return None\n-         }\n-      }\n-   }\n+/**\n+ * Convert a string in an given base to a float.\n+ *\n+ * Due to possible conflicts, this function does **not** accept\n+ * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+ * does it recognize exponents of any kind.\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ * * radix - The base to use. Must lie in the range [2 .. 36]\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number. Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n+    num::from_str_common(num, radix, true, true, false, num::ExpNone, false)\n+}\n \n-   if (c == 'e') || (c == 'E') { //Examine exponent\n-      let mut exponent = 0u;\n-      let mut neg_exponent = false;\n-      if(pos < len) {\n-          let char_range = str::char_range_at(num, pos);\n-          c   = char_range.ch;\n-          match c  {\n-             '+' => {\n-                pos = char_range.next;\n-             }\n-             '-' => {\n-                pos = char_range.next;\n-                neg_exponent = true;\n-             }\n-             _ => ()\n-          }\n-          while(pos < len) {\n-             let char_range = str::char_range_at(num, pos);\n-             c = char_range.ch;\n-             match c {\n-                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' => {\n-                     exponent *= 10u;\n-                     exponent += ((c as uint) - ('0' as uint));\n-                 }\n-                 _ => break\n-             }\n-             pos = char_range.next;\n-          }\n-          let multiplier = pow_with_uint(10u, exponent);\n-              //Note: not ~[int::pow], otherwise, we'll quickly\n-              //end up with a nice overflow\n-          if neg_exponent {\n-             total = total / multiplier;\n-          } else {\n-             total = total * multiplier;\n-          }\n-      } else {\n-         return None;\n-      }\n-   }\n+impl float: from_str::FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(val: &str) -> Option<float> { from_str(val) }\n+}\n \n-   if(pos < len) {\n-     return None;\n-   } else {\n-     if(neg) {\n-        total *= -1f;\n-     }\n-     return Some(total);\n-   }\n+impl float: num::FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n+        from_str_radix(val, radix)\n+    }\n }\n \n /**\n@@ -523,7 +451,6 @@ impl float: num::Round {\n \n #[test]\n pub fn test_from_str() {\n-   assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3.14\") == Some(3.14);\n    assert from_str(~\"+3.14\") == Some(3.14);\n@@ -537,20 +464,25 @@ pub fn test_from_str() {\n    assert from_str(~\"5.\") == Some(5.);\n    assert from_str(~\".5\") == Some(0.5);\n    assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"-.5\") == Some(-0.5);\n    assert from_str(~\"-.5\") == Some(-0.5);\n    assert from_str(~\"-5\") == Some(-5.);\n-   assert from_str(~\"-0\") == Some(-0.);\n-   assert from_str(~\"0\") == Some(0.);\n    assert from_str(~\"inf\") == Some(infinity);\n+   assert from_str(~\"+inf\") == Some(infinity);\n    assert from_str(~\"-inf\") == Some(neg_infinity);\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str(~\"NaN\") {\n        Some(f) => assert is_NaN(f),\n        None => die!()\n    }\n+   // note: -0 == 0, hence these slightly more complex tests\n+   match from_str(~\"-0\") {\n+       Some(v) if is_zero(v) => assert is_negative(v),\n+       _ => fail\n+   }\n+   match from_str(~\"0\") {\n+       Some(v) if is_zero(v) => assert is_positive(v),\n+       _ => fail\n+   }\n \n    assert from_str(~\"\").is_none();\n    assert from_str(~\"x\").is_none();\n@@ -564,6 +496,89 @@ pub fn test_from_str() {\n    assert from_str(~\"1e1-1\").is_none();\n }\n \n+#[test]\n+pub fn test_from_str_hex() {\n+   assert from_str_hex(~\"a4\") == Some(164.);\n+   assert from_str_hex(~\"a4.fe\") == Some(164.9921875);\n+   assert from_str_hex(~\"-a4.fe\") == Some(-164.9921875);\n+   assert from_str_hex(~\"+a4.fe\") == Some(164.9921875);\n+   assert from_str_hex(~\"ff0P4\") == Some(0xff00 as float);\n+   assert from_str_hex(~\"ff0p4\") == Some(0xff00 as float);\n+   assert from_str_hex(~\"ff0p-4\") == Some(0xff as float);\n+   assert from_str_hex(~\".\") == Some(0.);\n+   assert from_str_hex(~\".p1\") == Some(0.);\n+   assert from_str_hex(~\".p-1\") == Some(0.);\n+   assert from_str_hex(~\"f.\") == Some(15.);\n+   assert from_str_hex(~\".f\") == Some(0.9375);\n+   assert from_str_hex(~\"0.f\") == Some(0.9375);\n+   assert from_str_hex(~\"-.f\") == Some(-0.9375);\n+   assert from_str_hex(~\"-f\") == Some(-15.);\n+   assert from_str_hex(~\"inf\") == Some(infinity);\n+   assert from_str_hex(~\"+inf\") == Some(infinity);\n+   assert from_str_hex(~\"-inf\") == Some(neg_infinity);\n+   // note: NaN != NaN, hence this slightly complex test\n+   match from_str_hex(~\"NaN\") {\n+       Some(f) => assert is_NaN(f),\n+       None => fail\n+   }\n+   // note: -0 == 0, hence these slightly more complex tests\n+   match from_str_hex(~\"-0\") {\n+       Some(v) if is_zero(v) => assert is_negative(v),\n+       _ => fail\n+   }\n+   match from_str_hex(~\"0\") {\n+       Some(v) if is_zero(v) => assert is_positive(v),\n+       _ => fail\n+   }\n+   assert from_str_hex(~\"e\") == Some(14.);\n+   assert from_str_hex(~\"E\") == Some(14.);\n+   assert from_str_hex(~\"E1\") == Some(225.);\n+   assert from_str_hex(~\"1e1e1\") == Some(123361.);\n+   assert from_str_hex(~\"1e1.1\") == Some(481.0625);\n+\n+   assert from_str_hex(~\"\").is_none();\n+   assert from_str_hex(~\"x\").is_none();\n+   assert from_str_hex(~\" \").is_none();\n+   assert from_str_hex(~\"   \").is_none();\n+   assert from_str_hex(~\"p\").is_none();\n+   assert from_str_hex(~\"P\").is_none();\n+   assert from_str_hex(~\"P1\").is_none();\n+   assert from_str_hex(~\"1p1p1\").is_none();\n+   assert from_str_hex(~\"1p1.1\").is_none();\n+   assert from_str_hex(~\"1p1-1\").is_none();\n+}\n+\n+#[test]\n+pub fn test_to_str_hex() {\n+   assert to_str_hex(164.) == ~\"a4\";\n+   assert to_str_hex(164.9921875) == ~\"a4.fe\";\n+   assert to_str_hex(-164.9921875) == ~\"-a4.fe\";\n+   assert to_str_hex(0xff00 as float) == ~\"ff00\";\n+   assert to_str_hex(-(0xff00 as float)) == ~\"-ff00\";\n+   assert to_str_hex(0.) == ~\"0\";\n+   assert to_str_hex(15.) == ~\"f\";\n+   assert to_str_hex(-15.) == ~\"-f\";\n+   assert to_str_hex(0.9375) == ~\"0.f\";\n+   assert to_str_hex(-0.9375) == ~\"-0.f\";\n+   assert to_str_hex(infinity) == ~\"inf\";\n+   assert to_str_hex(neg_infinity) == ~\"-inf\";\n+   assert to_str_hex(NaN) == ~\"NaN\";\n+   assert to_str_hex(0.) == ~\"0\";\n+   assert to_str_hex(-0.) == ~\"-0\";\n+}\n+\n+#[test]\n+pub fn test_to_str_radix() {\n+   assert to_str_radix(36., 36u) == ~\"10\";\n+   assert to_str_radix(8.125, 2u) == ~\"1000.001\";\n+}\n+\n+#[test]\n+pub fn test_from_str_radix() {\n+   assert from_str_radix(~\"10\", 36u) == Some(36.);\n+   assert from_str_radix(~\"1000.001\", 2u) == Some(8.125);\n+}\n+\n #[test]\n pub fn test_positive() {\n   assert(is_positive(infinity));\n@@ -610,8 +625,8 @@ pub fn test_nonnegative() {\n \n #[test]\n pub fn test_to_str_inf() {\n-    assert to_str(infinity, 10u) == ~\"inf\";\n-    assert to_str(-infinity, 10u) == ~\"-inf\";\n+    assert to_str_digits(infinity, 10u) == ~\"inf\";\n+    assert to_str_digits(-infinity, 10u) == ~\"-inf\";\n }\n \n #[test]"}, {"sha": "2f77e71bef00555a0b7d34438aec608275ba9e77", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -893,7 +893,7 @@ fn test_repr() {\n     exact_test(&10, \"10\");\n     exact_test(&true, \"true\");\n     exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.2340\");\n+    exact_test(&1.234, \"1.234\");\n     exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n     exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n     exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n@@ -918,11 +918,11 @@ fn test_repr() {\n     exact_test(&(&[\"hi\", \"there\"]),\n                \"&[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(P{a:10, b:1.234}),\n-               \"{a: 10, b: 1.2340}\");\n+               \"{a: 10, b: 1.234}\");\n     exact_test(&(@P{a:10, b:1.234}),\n-               \"@{a: 10, b: 1.2340}\");\n+               \"@{a: 10, b: 1.234}\");\n     exact_test(&(~P{a:10, b:1.234}),\n-               \"~{a: 10, b: 1.2340}\");\n+               \"~{a: 10, b: 1.234}\");\n     exact_test(&(10_u8, ~\"hello\"),\n                \"(10, ~\\\"hello\\\")\");\n     exact_test(&(10_u16, ~\"hello\"),"}, {"sha": "51205b0c647fd1dc104473750cc12c519d9b2cc8", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -24,18 +24,6 @@ use vec;\n \n pub trait ToStr { pub pure fn to_str() -> ~str; }\n \n-impl float: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::float::to_str(self, 4u) }\n-}\n-impl f32: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::float::to_str(self as float, 4u) }\n-}\n-impl f64: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::float::to_str(self as float, 4u) }\n-}\n impl bool: ToStr {\n     #[inline(always)]\n     pure fn to_str() -> ~str { ::bool::to_str(self) }"}, {"sha": "b1cdeef4e66503d2c1d924fffa066ee43f68a549", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a612e49a21412e2e53bf59ece4408c9f078a49f5/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a612e49a21412e2e53bf59ece4408c9f078a49f5", "patch": "@@ -109,7 +109,7 @@ pub impl Encoder: serialize::Encoder {\n     fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n     fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n     fn emit_float(&self, v: float) {\n-        self.wr.write_str(float::to_str(v, 6u));\n+        self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n     fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n@@ -213,7 +213,7 @@ pub impl PrettyEncoder: serialize::Encoder {\n     fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n     fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n     fn emit_float(&self, v: float) {\n-        self.wr.write_str(float::to_str(v, 6u));\n+        self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n     fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }"}]}