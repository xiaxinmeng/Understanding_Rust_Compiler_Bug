{"sha": "e2afefd80bf779bc3c6f697a3c6cc3a476993602", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYWZlZmQ4MGJmNzc5YmMzYzZmNjk3YTNjNmNjM2E0NzY5OTM2MDI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-18T13:47:09Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-06T08:48:19Z"}, "message": "Get rid of `SpannedIdent`", "tree": {"sha": "c419ff9b09e7065348264eff44e4c45d05060c4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c419ff9b09e7065348264eff44e4c45d05060c4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2afefd80bf779bc3c6f697a3c6cc3a476993602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2afefd80bf779bc3c6f697a3c6cc3a476993602", "html_url": "https://github.com/rust-lang/rust/commit/e2afefd80bf779bc3c6f697a3c6cc3a476993602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2afefd80bf779bc3c6f697a3c6cc3a476993602/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8719d1ed05761b344d611ae0893b1d994b6ebe6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8719d1ed05761b344d611ae0893b1d994b6ebe6f", "html_url": "https://github.com/rust-lang/rust/commit/8719d1ed05761b344d611ae0893b1d994b6ebe6f"}], "stats": {"total": 503, "additions": 231, "deletions": 272}, "files": [{"sha": "08b0def03b9ea7ae619b8d749c4d9f1b4391d536", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -1720,7 +1720,7 @@ impl<'a> LoweringContext<'a> {\n         decl.inputs\n             .iter()\n             .map(|arg| match arg.pat.node {\n-                PatKind::Ident(_, ident, None) => respan(ident.span, ident.node.name),\n+                PatKind::Ident(_, ident, None) => respan(ident.span, ident.name),\n                 _ => respan(arg.pat.span, keywords::Invalid.name()),\n             })\n             .collect()\n@@ -2099,7 +2099,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n-            name: respan(f.ident.span, self.lower_ident(f.ident.node)),\n+            name: respan(f.ident.span, self.lower_ident(f.ident)),\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n@@ -2801,7 +2801,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n-            PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n+            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n                 match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n                     // `None` can occur in body-less function signatures\n                     def @ None | def @ Some(Def::Local(_)) => {\n@@ -2812,16 +2812,16 @@ impl<'a> LoweringContext<'a> {\n                         hir::PatKind::Binding(\n                             self.lower_binding_mode(binding_mode),\n                             canonical_id,\n-                            respan(pth1.span, pth1.node.name),\n+                            respan(ident.span, ident.name),\n                             sub.as_ref().map(|x| self.lower_pat(x)),\n                         )\n                     }\n                     Some(def) => hir::PatKind::Path(hir::QPath::Resolved(\n                         None,\n                         P(hir::Path {\n-                            span: pth1.span,\n+                            span: ident.span,\n                             def,\n-                            segments: hir_vec![hir::PathSegment::from_name(pth1.node.name)],\n+                            segments: hir_vec![hir::PathSegment::from_name(ident.name)],\n                         }),\n                     )),\n                 }\n@@ -3071,7 +3071,7 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ExprKind::Field(ref el, ident) => hir::ExprField(\n                 P(self.lower_expr(el)),\n-                respan(ident.span, self.lower_ident(ident.node)),\n+                respan(ident.span, self.lower_ident(ident)),\n             ),\n             ExprKind::TupField(ref el, ident) => hir::ExprTupField(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {"}, {"sha": "2cc6708bc034e1dafe570fe975f57f8aee6bac02", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -171,16 +171,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node == fieldpat.node.name {\n+                if let PatKind::Binding(_, _, name, None) = fieldpat.node.pat.node {\n+                    if name.node == fieldpat.node.name {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\",\n-                                              ident.node));\n+                                              name.node));\n                         let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n                         err.span_suggestion_short(subspan,\n                                                   \"remove this\",\n-                                                  format!(\"{}\", ident.node));\n+                                                  format!(\"{}\", name.node));\n                         err.emit();\n                     }\n                 }\n@@ -625,7 +625,7 @@ impl EarlyLintPass for AnonymousParameters {\n                 for arg in sig.decl.inputs.iter() {\n                     match arg.pat.node {\n                         ast::PatKind::Ident(_, ident, None) => {\n-                            if ident.node.name == keywords::Invalid.name() {\n+                            if ident.name == keywords::Invalid.name() {\n                                 cx.span_lint(ANONYMOUS_PARAMETERS,\n                                              arg.pat.span,\n                                              \"use of deprecated anonymous parameter\");"}, {"sha": "9b0e4c64171ca59a2dc19c41b2e45a001ffe3b51", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -467,8 +467,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 mutability: Mutability::Not,\n             };\n             if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n-                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n-                    decl.debug_name = ident.node;\n+                if let hir::PatKind::Binding(_, _, ref name, _) = pat.node {\n+                    decl.debug_name = name.node;\n \n                     let bm = *hir.tables.pat_binding_modes()\n                                         .get(pat.hir_id)"}, {"sha": "c3f41e8ac4827f5970fb9e11dfab2c2f7db695ab", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -466,7 +466,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(_, id, ref ident, ref sub) => {\n+            PatKind::Binding(_, id, ref name, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n@@ -493,14 +493,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     if let ty::TyRef(_, mt) = ty.sty {\n                         ty = mt.ty;\n                     } else {\n-                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n+                        bug!(\"`ref {}` has wrong type {}\", name.node, ty);\n                     }\n                 }\n \n                 PatternKind::Binding {\n                     mutability,\n                     mode,\n-                    name: ident.node,\n+                    name: name.node,\n                     var: id,\n                     ty: var_ty,\n                     subpattern: self.lower_opt_pattern(sub),"}, {"sha": "45ecf665ef10bc521837e465e122fadae1d7c539", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -34,7 +34,6 @@ use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind, Variant};\n-use syntax::codemap::respan;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n@@ -115,13 +114,13 @@ impl<'a> Resolver<'a> {\n \n         let mut module_path: Vec<_> = prefix.segments.iter()\n             .chain(path.segments.iter())\n-            .map(|seg| respan(seg.span, seg.ident))\n+            .map(|seg| seg.ident)\n             .collect();\n \n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename) => {\n                 let mut ident = use_tree.ident();\n-                let mut source = module_path.pop().unwrap().node;\n+                let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n \n                 if nested {\n@@ -130,7 +129,7 @@ impl<'a> Resolver<'a> {\n                         type_ns_only = true;\n \n                         let last_segment = *module_path.last().unwrap();\n-                        if last_segment.node.name == keywords::CrateRoot.name() {\n+                        if last_segment.name == keywords::CrateRoot.name() {\n                             resolve_error(\n                                 self,\n                                 use_tree.span,\n@@ -142,9 +141,9 @@ impl<'a> Resolver<'a> {\n \n                         // Replace `use foo::self;` with `use foo;`\n                         let _ = module_path.pop();\n-                        source = last_segment.node;\n+                        source = last_segment;\n                         if rename.is_none() {\n-                            ident = last_segment.node;\n+                            ident = last_segment;\n                         }\n                     }\n                 } else {\n@@ -195,8 +194,8 @@ impl<'a> Resolver<'a> {\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 let prefix = ast::Path {\n-                    segments: module_path.iter()\n-                        .map(|s| ast::PathSegment::from_ident(s.node, s.span))\n+                    segments: module_path.into_iter()\n+                        .map(|ident| ast::PathSegment::from_ident(ident, ident.span))\n                         .collect(),\n                     span: path.span,\n                 };"}, {"sha": "41abb794f22d0235d361f952aa0070f0ad4d6859", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -41,9 +41,9 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{dummy_spanned, respan, BytePos, CodeMap};\n+use syntax::codemap::{BytePos, CodeMap};\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n-use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n+use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n@@ -1654,8 +1654,8 @@ impl<'a> Resolver<'a> {\n         {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<SpannedIdent> = segments.iter()\n-            .map(|seg| respan(span, Ident::with_empty_ctxt(seg.name)))\n+        let path: Vec<Ident> = segments.iter()\n+            .map(|seg| Ident::new(seg.name, span))\n             .collect();\n         match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n@@ -2351,7 +2351,7 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = trait_ref.path.segments.iter()\n-                .map(|seg| respan(seg.span, seg.ident))\n+                .map(|seg| seg.ident)\n                 .collect();\n             let def = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n@@ -2500,7 +2500,7 @@ impl<'a> Resolver<'a> {\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(ident.node, binding_info);\n+                    binding_map.insert(ident, binding_info);\n                 }\n             }\n             true\n@@ -2640,7 +2640,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn fresh_binding(&mut self,\n-                     ident: &SpannedIdent,\n+                     ident: Ident,\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n@@ -2652,14 +2652,14 @@ impl<'a> Resolver<'a> {\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n         let mut def = Def::Local(pat_id);\n-        match bindings.get(&ident.node).cloned() {\n+        match bindings.get(&ident).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n                     self,\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                        &ident.node.name.as_str())\n+                        &ident.name.as_str())\n                 );\n             }\n             Some(..) if pat_src == PatternSource::FnParam => {\n@@ -2668,25 +2668,25 @@ impl<'a> Resolver<'a> {\n                     self,\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                        &ident.node.name.as_str())\n+                        &ident.name.as_str())\n                 );\n             }\n             Some(..) if pat_src == PatternSource::Match ||\n                         pat_src == PatternSource::IfLet ||\n                         pat_src == PatternSource::WhileLet => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n+                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n                                        unexpected pattern source {:?}\", pat_src);\n             }\n             None => {\n                 // A completely fresh binding, add to the lists if it's valid.\n-                if ident.node.name != keywords::Invalid.name() {\n-                    bindings.insert(ident.node, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident.node, def);\n+                if ident.name != keywords::Invalid.name() {\n+                    bindings.insert(ident, outer_pat_id);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, def);\n                 }\n             }\n         }\n@@ -2704,10 +2704,10 @@ impl<'a> Resolver<'a> {\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             match pat.node {\n-                PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n+                PatKind::Ident(bmode, ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS,\n+                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n                                                                       false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n@@ -2719,7 +2719,7 @@ impl<'a> Resolver<'a> {\n                             Def::Const(..) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n-                                self.record_use(ident.node, ValueNS, binding.unwrap(), ident.span);\n+                                self.record_use(ident, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -2733,7 +2733,7 @@ impl<'a> Resolver<'a> {\n                                     self,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), ident.node.name, binding.unwrap())\n+                                        pat_src.descr(), ident.name, binding.unwrap())\n                                 );\n                                 None\n                             }\n@@ -2786,15 +2786,15 @@ impl<'a> Resolver<'a> {\n                           source: PathSource)\n                           -> PathResolution {\n         let segments = &path.segments.iter()\n-            .map(|seg| respan(seg.span, seg.ident))\n+            .map(|seg| seg.ident)\n             .collect::<Vec<_>>();\n         self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[SpannedIdent],\n+                                   path: &[Ident],\n                                    span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n@@ -2814,11 +2814,11 @@ impl<'a> Resolver<'a> {\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_str = path[path.len() - 1].node;\n+                let item_str = path[path.len() - 1];\n                 let item_span = path[path.len() - 1].span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (format!(\"\"), format!(\"this scope\"))\n-                } else if path.len() == 2 && path[0].node.name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -2852,10 +2852,10 @@ impl<'a> Resolver<'a> {\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = *path.last().unwrap();\n-            let candidates = this.lookup_import_candidates(ident.node.name, ns, is_expected);\n+            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n-                    this.lookup_import_candidates(ident.node.name, ns, is_enum_variant);\n+                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -2873,8 +2873,8 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(ident.node, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].node.span, span);\n+                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n+                    let self_is_available = this.self_value_is_available(path[0].span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion(span, \"try\",\n@@ -2919,7 +2919,7 @@ impl<'a> Resolver<'a> {\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n                             err.span_label(parent.span, format!(\"did you mean `{}::{}`?\",\n-                                                                 path_str, ident.node));\n+                                                                 path_str, ident));\n                             return (err, candidates);\n                         }\n                         ExprKind::MethodCall(ref segment, ..) => {\n@@ -3028,7 +3028,7 @@ impl<'a> Resolver<'a> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = path.last().unwrap().node;\n+                    let item_name = *path.last().unwrap();\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -3095,7 +3095,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[SpannedIdent],\n+                              path: &[Ident],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -3115,10 +3115,10 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_global = self.global_macros.get(&path[0].node.name).cloned()\n+        let is_global = self.global_macros.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n         if primary_ns != MacroNS && (is_global ||\n-                                     self.macro_names.contains(&path[0].node.modern())) {\n+                                     self.macro_names.contains(&path[0].modern())) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -3131,7 +3131,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[SpannedIdent],\n+                     path: &[Ident],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool)\n@@ -3172,8 +3172,8 @@ impl<'a> Resolver<'a> {\n             PathResult::Module(..) | PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n-                           .contains_key(&path[0].node.name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].node.name];\n+                           .contains_key(&path[0].name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n@@ -3186,8 +3186,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].node.name != keywords::CrateRoot.name() &&\n-           path[0].node.name != keywords::DollarCrate.name() {\n+           path[0].name != keywords::CrateRoot.name() &&\n+           path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n@@ -3205,7 +3205,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_path(&mut self,\n-                    path: &[SpannedIdent],\n+                    path: &[Ident],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n                     record_used: bool,\n                     path_span: Span)\n@@ -3217,14 +3217,14 @@ impl<'a> Resolver<'a> {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n-            let name = ident.node.name;\n+            let name = ident.name;\n \n             if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n-                let mut ctxt = ident.node.span.ctxt().modern();\n+                let mut ctxt = ident.span.ctxt().modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n             } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n-                let mut ctxt = ident.node.span.ctxt().modern();\n+                let mut ctxt = ident.span.ctxt().modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n                     _ => module.unwrap(),\n@@ -3244,16 +3244,16 @@ impl<'a> Resolver<'a> {\n             if ns == TypeNS {\n                 if (i == 0 && name == keywords::CrateRoot.name()) ||\n                    (i == 1 && name == keywords::Crate.name() &&\n-                              path[0].node.name == keywords::CrateRoot.name()) {\n+                              path[0].name == keywords::CrateRoot.name()) {\n                     // `::a::b` or `::crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.span.ctxt(), false));\n+                    module = Some(self.resolve_crate_root(ident.span.ctxt(), false));\n                     continue\n                 } else if i == 0 && name == keywords::DollarCrate.name() {\n                     // `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.span.ctxt(), true));\n+                    module = Some(self.resolve_crate_root(ident.span.ctxt(), true));\n                     continue\n-                } else if i == 1 && !token::is_path_segment_keyword(ident.node) {\n-                    let prev_name = path[0].node.name;\n+                } else if i == 1 && !token::is_path_segment_keyword(ident) {\n+                    let prev_name = path[0].name;\n                     if prev_name == keywords::Extern.name() ||\n                        prev_name == keywords::CrateRoot.name() &&\n                        self.session.features_untracked().extern_absolute_paths {\n@@ -3276,13 +3276,13 @@ impl<'a> Resolver<'a> {\n                name == keywords::Super.name() && i != 0 ||\n                name == keywords::Extern.name() && i != 0 ||\n                name == keywords::Crate.name() && i != 1 &&\n-                    path[0].node.name != keywords::CrateRoot.name() {\n+                    path[0].name != keywords::CrateRoot.name() {\n                 let name_str = if name == keywords::CrateRoot.name() {\n                     format!(\"crate root\")\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].node.name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].name == keywords::CrateRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else if i == 0 && name == keywords::Crate.name() {\n                     format!(\"{} can only be used in absolute paths\", name_str)\n@@ -3293,12 +3293,12 @@ impl<'a> Resolver<'a> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident.node, ns, false, record_used, path_span)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident.node, ns, record_used, path_span)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident.node, ns, record_used, path_span) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n@@ -3324,7 +3324,7 @@ impl<'a> Resolver<'a> {\n                         ));\n                     } else {\n                         return PathResult::Failed(ident.span,\n-                                                  format!(\"Not a module `{}`\", ident.node),\n+                                                  format!(\"Not a module `{}`\", ident),\n                                                   is_last);\n                     }\n                 }\n@@ -3345,12 +3345,12 @@ impl<'a> Resolver<'a> {\n                         if let Some(candidate) = candidates.get(0) {\n                             format!(\"Did you mean `{}`?\", candidate.path)\n                         } else {\n-                            format!(\"Maybe a missing `extern crate {};`?\", ident.node)\n+                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n                         }\n                     } else if i == 0 {\n-                        format!(\"Use of undeclared type or module `{}`\", ident.node)\n+                        format!(\"Use of undeclared type or module `{}`\", ident)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident.node, path[i - 1].node)\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n                     };\n                     return PathResult::Failed(ident.span, msg, is_last);\n                 }\n@@ -3516,7 +3516,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[SpannedIdent],\n+                                       path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -3577,7 +3577,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = path[path.len() - 1].node.name;\n+        let name = path[path.len() - 1].name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -3739,12 +3739,12 @@ impl<'a> Resolver<'a> {\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprKind::Field(_, name) => {\n+            ExprKind::Field(_, ident) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node, ValueNS);\n+                let traits = self.get_traits_containing_item(ident, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n@@ -4244,30 +4244,30 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-fn is_self_type(path: &[SpannedIdent], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].node.name == keywords::SelfType.name()\n+fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[SpannedIdent], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].node.name == keywords::SelfValue.name()\n+fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n }\n \n-fn names_to_string(idents: &[SpannedIdent]) -> String {\n+fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n     for (i, ident) in idents.iter()\n-                            .filter(|i| i.node.name != keywords::CrateRoot.name())\n+                            .filter(|ident| ident.name != keywords::CrateRoot.name())\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");\n         }\n-        result.push_str(&ident.node.name.as_str());\n+        result.push_str(&ident.name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path) -> String {\n     names_to_string(&path.segments.iter()\n-                        .map(|seg| respan(seg.span, seg.ident))\n+                        .map(|seg| seg.ident)\n                         .collect::<Vec<_>>())\n }\n \n@@ -4356,7 +4356,6 @@ fn module_to_string(module: Module) -> Option<String> {\n     }\n     Some(names_to_string(&names.into_iter()\n                         .rev()\n-                        .map(|n| dummy_spanned(n))\n                         .collect::<Vec<_>>()))\n }\n "}, {"sha": "3b3bdfdba9ce27887f49beac821fe1d0e2d974fe", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -20,7 +20,6 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use syntax::ast::{self, Name, Ident};\n use syntax::attr::{self, HasAttrs};\n-use syntax::codemap::respan;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n@@ -413,7 +412,7 @@ impl<'a> Resolver<'a> {\n                                   kind: MacroKind, force: bool)\n                                   -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.ident)).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&scope];\n         let module = invocation.module.get();\n         self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n@@ -447,19 +446,16 @@ impl<'a> Resolver<'a> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            let path = path.iter().map(|p| p.node).collect::<Vec<_>>();\n             self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope,\n-                                                          path[0].node,\n-                                                          false);\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0].node, MacroNS, false, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -470,7 +466,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0].node, span, kind));\n+            .push((scope, path[0], span, kind));\n \n         result\n     }\n@@ -608,7 +604,6 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            let path = path.iter().map(|p| respan(span, *p)).collect::<Vec<_>>();\n             match self.resolve_path(&path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n@@ -684,8 +679,8 @@ impl<'a> Resolver<'a> {\n                     false\n                 }\n             };\n-            let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![respan(span, ident)], MacroNS, is_macro, span)\n+            let ident = Ident::new(Symbol::intern(name), span);\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "87738f7b79be530e6ecb482d10a4a26a5da90ca9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -24,7 +24,7 @@ use rustc::hir::def::*;\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n-use syntax::ast::{Ident, Name, SpannedIdent, NodeId};\n+use syntax::ast::{Ident, Name, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::parse::token;\n@@ -58,7 +58,7 @@ pub enum ImportDirectiveSubclass<'a> {\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     pub parent: Module<'a>,\n-    pub module_path: Vec<SpannedIdent>,\n+    pub module_path: Vec<Ident>,\n     pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub span: Span,\n@@ -257,7 +257,7 @@ impl<'a> Resolver<'a> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<SpannedIdent>,\n+                                module_path: Vec<Ident>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -606,9 +606,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // FIXME: Last path segment is treated specially in import resolution, so extern crate\n         // mode for absolute paths needs some special support for single-segment imports.\n-        if module_path.len() == 1 && (module_path[0].node.name == keywords::CrateRoot.name() ||\n-                                      module_path[0].node.name == keywords::Extern.name()) {\n-            let is_extern = module_path[0].node.name == keywords::Extern.name() ||\n+        if module_path.len() == 1 && (module_path[0].name == keywords::CrateRoot.name() ||\n+                                      module_path[0].name == keywords::Extern.name()) {\n+            let is_extern = module_path[0].name == keywords::Extern.name() ||\n                             self.session.features_untracked().extern_absolute_paths;\n             match directive.subclass {\n                 GlobImport { .. } if is_extern => {\n@@ -617,7 +617,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 SingleImport { source, target, .. } => {\n                     let crate_root = if source.name == keywords::Crate.name() &&\n-                                        module_path[0].node.name != keywords::Extern.name() {\n+                                        module_path[0].name != keywords::Extern.name() {\n                         if target.name == keywords::Crate.name() {\n                             return Some((directive.span,\n                                          \"crate root imports need to be explicitly named: \\\n@@ -669,9 +669,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 let is_special = |ident| token::is_path_segment_keyword(ident) &&\n                                          ident.name != keywords::CrateRoot.name();\n-                if !self_path.is_empty() && !is_special(self_path[0].node) &&\n-                   !(self_path.len() > 1 && is_special(self_path[1].node)) {\n-                    self_path[0].node.name = keywords::SelfValue.name();\n+                if !self_path.is_empty() && !is_special(self_path[0]) &&\n+                   !(self_path.len() > 1 && is_special(self_path[1])) {\n+                    self_path[0].name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n@@ -957,7 +957,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             let resolutions = imported_module.parent.expect(\"parent should exist\")\n                                 .resolutions.borrow();\n                             let enum_path_segment_index = directive.module_path.len() - 1;\n-                            let enum_ident = directive.module_path[enum_path_segment_index].node;\n+                            let enum_ident = directive.module_path[enum_path_segment_index];\n \n                             let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n                                 .expect(\"resolution should exist\");\n@@ -1011,12 +1011,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(names: &[SpannedIdent],\n+fn import_path_to_string(names: &[Ident],\n                          subclass: &ImportDirectiveSubclass,\n                          span: Span) -> String {\n     let pos = names.iter()\n-        .position(|p| span == p.span && p.node.name != keywords::CrateRoot.name());\n-    let global = !names.is_empty() && names[0].node.name == keywords::CrateRoot.name();\n+        .position(|p| span == p.span && p.name != keywords::CrateRoot.name());\n+    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n         names_to_string(names)"}, {"sha": "74c2597fa99e9599e7bdc06a5e66cd63492520a3", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -554,7 +554,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 };\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n-                        let f = def.non_enum_variant().field_named(ident.node.name);\n+                        let f = def.non_enum_variant().field_named(ident.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n                         let span = self.span_from_span(sub_span.unwrap());\n@@ -817,7 +817,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         field_ref: &ast::Field,\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n-        let f = variant.find_field_named(field_ref.ident.node.name)?;\n+        let f = variant.find_field_named(field_ref.ident.name)?;\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n         filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n@@ -982,12 +982,12 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n             PatKind::TupleStruct(ref path, ..) | PatKind::Path(_, ref path) => {\n                 self.collected_paths.push((p.id, path));\n             }\n-            PatKind::Ident(bm, ref path1, _) => {\n+            PatKind::Ident(bm, ident, _) => {\n                 debug!(\n                     \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n-                    path1.node,\n+                    ident,\n                     p.span,\n-                    path1.span\n+                    ident.span\n                 );\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n@@ -997,7 +997,7 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 self.collected_idents\n-                    .push((p.id, path1.node, path1.span, immut));\n+                    .push((p.id, ident, ident.span, immut));\n             }\n             _ => {}\n         }"}, {"sha": "23845c94aa42f8ed78df06d3d700e57f26de9989", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -671,7 +671,7 @@ impl Sig for ast::StructField {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n         let mut text = String::new();\n         let mut defs = None;\n-        if let Some(ref ident) = self.ident {\n+        if let Some(ident) = self.ident {\n             text.push_str(&ident.to_string());\n             defs = Some(SigElement {\n                 id: id_from_node_id(self.id, scx),"}, {"sha": "652aaa795c3310f1ca6039e90628f4b475e6d7bc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -541,7 +541,7 @@ impl Pat {\n         let node = match &self.node {\n             PatKind::Wild => TyKind::Infer,\n             PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) =>\n-                TyKind::Path(None, Path::from_ident(ident.span, ident.node)),\n+                TyKind::Path(None, Path::from_ident(ident.span, *ident)),\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             PatKind::Mac(mac) => TyKind::Mac(mac.clone()),\n             PatKind::Ref(pat, mutbl) =>\n@@ -638,7 +638,7 @@ pub enum PatKind {\n     /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n     /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n     /// during name resolution.\n-    Ident(BindingMode, SpannedIdent, Option<P<Pat>>),\n+    Ident(BindingMode, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -910,15 +910,13 @@ pub struct Arm {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n-    pub ident: SpannedIdent,\n+    pub ident: Ident,\n     pub expr: P<Expr>,\n     pub span: Span,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n }\n \n-pub type SpannedIdent = Spanned<Ident>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n@@ -1144,7 +1142,7 @@ pub enum ExprKind {\n     /// For example, `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n-    Field(P<Expr>, SpannedIdent),\n+    Field(P<Expr>, Ident),\n     /// Access of an unnamed field of a struct or tuple-struct\n     ///\n     /// For example, `foo.0`.\n@@ -1689,7 +1687,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.node.name == keywords::SelfValue.name() {\n+            if ident.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n@@ -1705,13 +1703,13 @@ impl Arg {\n \n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.node.name == keywords::SelfValue.name()\n+            ident.name == keywords::SelfValue.name()\n         } else {\n             false\n         }\n     }\n \n-    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n+    pub fn from_self(eself: ExplicitSelf, eself_ident: Ident) -> Arg {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,"}, {"sha": "541517b2bcbf31eea84757d82e4fa62476d7efb8", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -1117,7 +1117,7 @@ impl MetaItem {\n         let (span, name) = match tokens.next() {\n             Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident.name),\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident.node.name),\n+                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident.name),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n                 _ => return None,\n             },"}, {"sha": "75b1366d3cdb3da71c7076fdabb05a3a1fdb5440", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -251,7 +251,7 @@ impl<F> TTMacroExpander for F\n                 if let tokenstream::TokenTree::Token(_, token::Interpolated(ref nt)) = tt {\n                     if let token::NtIdent(ident, is_raw) = nt.0 {\n                         return tokenstream::TokenTree::Token(ident.span,\n-                                                             token::Ident(ident.node, is_raw));\n+                                                             token::Ident(ident, is_raw));\n                     }\n                 }\n                 fold::noop_fold_tt(tt, self)"}, {"sha": "fc3000ea0b5f646c9fc432ccebd1f04e0927eb78", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -38,11 +38,11 @@ pub trait AstBuilder {\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::SpannedIdent)\n+             ident: ast::Ident)\n              -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n-                ident: ast::SpannedIdent,\n+                ident: ast::Ident,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding>)\n@@ -344,7 +344,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::SpannedIdent)\n+             ident: ast::Ident)\n              -> (ast::QSelf, ast::Path) {\n         self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n@@ -355,7 +355,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n-                 ident: ast::SpannedIdent,\n+                 ident: ast::Ident,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n                  bindings: Vec<ast::TypeBinding>)\n@@ -366,11 +366,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             None\n         };\n-        path.segments.push(ast::PathSegment {\n-            ident: ident.node,\n-            span: ident.span,\n-            parameters,\n-        });\n+        path.segments.push(ast::PathSegment { ident, span: ident.span, parameters });\n \n         (ast::QSelf {\n             ty: self_type,\n@@ -636,8 +632,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n-        let id = Spanned { node: ident, span: sp };\n-        self.expr(sp, ast::ExprKind::Field(expr, id))\n+        self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let id = Spanned { node: idx, span: sp };\n@@ -672,9 +667,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field {\n+    fn field_imm(&self, span: Span, ident: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field {\n-            ident: respan(span, name),\n+            ident: ident.with_span_pos(span),\n             expr: e,\n             span,\n             is_shorthand: false,\n@@ -835,7 +830,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat> {\n-        let pat = PatKind::Ident(bm, Spanned{span: span, node: ident}, None);\n+        let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n         self.pat(span, pat)\n     }\n     fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {"}, {"sha": "10dc17beb96eafe79eed1e94adbeabb42e84a961", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -75,7 +75,7 @@ pub mod rt {\n \n     impl ToTokens for ast::Ident {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, Token::from_ast_ident(*self))]\n+            vec![TokenTree::Token(self.span, Token::from_ast_ident(*self))]\n         }\n     }\n "}, {"sha": "fdff17b13ed401081c3a1918a83ad21991b7464d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -86,7 +86,6 @@ use self::TokenTreeOrTokenTreeVec::*;\n \n use ast::Ident;\n use syntax_pos::{self, BytePos, Span};\n-use codemap::respan;\n use errors::FatalError;\n use ext::tt::quoted::{self, TokenTree};\n use parse::{Directory, ParseSess};\n@@ -824,9 +823,10 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n-        \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n+        \"ident\" => if let Some((ident, is_raw))) = get_macro_ident(&p.token) {\n+            let span = p.span;\n             p.bump();\n-            token::NtIdent(respan(p.prev_span, ident), is_raw)\n+            token::NtIdent(Ident::new(ident.name, span), is_raw)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();"}, {"sha": "9ffa91c431c827b1c704e7ebd674acb706101c17", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -439,8 +439,8 @@ pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n     }\n }\n \n-pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n-    i\n+pub fn noop_fold_ident<T: Folder>(ident: Ident, fld: &mut T) -> Ident {\n+    Ident::new(ident.name, fld.new_span(ident.span))\n }\n \n pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n@@ -634,8 +634,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(id, is_raw) =>\n-            token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}, is_raw),\n+        token::NtIdent(id, is_raw) => token::NtIdent(fld.fold_ident(id), is_raw),\n         token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),\n@@ -859,7 +858,7 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n \n pub fn noop_fold_field<T: Folder>(f: Field, folder: &mut T) -> Field {\n     Field {\n-        ident: respan(f.ident.span, folder.fold_ident(f.ident.node)),\n+        ident: folder.fold_ident(f.ident),\n         expr: folder.fold_expr(f.expr),\n         span: folder.new_span(f.span),\n         is_shorthand: f.is_shorthand,\n@@ -1119,11 +1118,10 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n         id: folder.new_id(id),\n         node: match node {\n             PatKind::Wild => PatKind::Wild,\n-            PatKind::Ident(binding_mode, pth1, sub) => {\n+            PatKind::Ident(binding_mode, ident, sub) => {\n                 PatKind::Ident(binding_mode,\n-                        Spanned{span: folder.new_span(pth1.span),\n-                                node: folder.fold_ident(pth1.node)},\n-                        sub.map(|x| folder.fold_pat(x)))\n+                               folder.fold_ident(ident),\n+                               sub.map(|x| folder.fold_pat(x)))\n             }\n             PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n             PatKind::TupleStruct(pth, pats, ddpos) => {\n@@ -1272,14 +1270,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                             folder.fold_expr(er))\n             }\n             ExprKind::Field(el, ident) => {\n-                ExprKind::Field(folder.fold_expr(el),\n-                          respan(folder.new_span(ident.span),\n-                                 folder.fold_ident(ident.node)))\n+                ExprKind::Field(folder.fold_expr(el), folder.fold_ident(ident))\n             }\n-            ExprKind::TupField(el, ident) => {\n+            ExprKind::TupField(el, index) => {\n                 ExprKind::TupField(folder.fold_expr(el),\n-                             respan(folder.new_span(ident.span),\n-                                    folder.fold_usize(ident.node)))\n+                             respan(folder.new_span(index.span),\n+                                    folder.fold_usize(index.node)))\n             }\n             ExprKind::Index(el, er) => {\n                 ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "0c8ffa2ebde654b6e9b6765b03f47ddf407ff231", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -512,13 +512,10 @@ impl From<P<Expr>> for LhsExpr {\n \n /// Create a placeholder argument.\n fn dummy_arg(span: Span) -> Arg {\n-    let spanned = Spanned {\n-        span,\n-        node: keywords::Invalid.ident()\n-    };\n+    let ident = Ident::new(keywords::Invalid.name(), span);\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), spanned, None),\n+        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n         span,\n     });\n     let ty = Ty {\n@@ -778,7 +775,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(i, _) => {\n+            token::Ident(ident, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n                     if recover {\n@@ -787,8 +784,9 @@ impl<'a> Parser<'a> {\n                         return Err(err);\n                     }\n                 }\n+                let span = self.span;\n                 self.bump();\n-                Ok(i)\n+                Ok(Ident::new(ident.name, span))\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n@@ -1321,7 +1319,7 @@ impl<'a> Parser<'a> {\n \n     fn eat_label(&mut self) -> Option<Label> {\n         let ident = match self.token {\n-            token::Lifetime(ref ident) => *ident,\n+            token::Lifetime(ident) => ident,\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtLifetime(lifetime) => lifetime.ident,\n                 _ => return None,\n@@ -1784,13 +1782,11 @@ impl<'a> Parser<'a> {\n             pat\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n-            let sp = self.prev_span;\n-            let spanned = Spanned { span: sp, node: keywords::Invalid.ident() };\n+            let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n             P(Pat {\n                 id: ast::DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable),\n-                                     spanned, None),\n-                span: sp\n+                node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                span: ident.span,\n             })\n         };\n \n@@ -1899,13 +1895,14 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(sid, _) if self.token.is_path_segment_keyword() => {\n+            token::Ident(ident, _) if self.token.is_path_segment_keyword() => {\n+                let span = self.span;\n                 self.bump();\n-                Ok(sid)\n+                Ok(Ident::new(ident.name, span))\n             }\n             _ => self.parse_ident(),\n-         }\n-     }\n+        }\n+    }\n \n     /// Parses qualified path.\n     /// Assumes that the leading `<` has been parsed already.\n@@ -2003,7 +2000,6 @@ impl<'a> Parser<'a> {\n \n     fn parse_path_segment(&mut self, style: PathStyle, enable_warning: bool)\n                           -> PResult<'a, PathSegment> {\n-        let ident_span = self.span;\n         let ident = self.parse_path_segment_ident()?;\n \n         let is_args_start = |token: &token::Token| match *token {\n@@ -2051,10 +2047,10 @@ impl<'a> Parser<'a> {\n                 ParenthesizedParameterData { inputs, output, span }.into()\n             };\n \n-            PathSegment { ident, span: ident_span, parameters }\n+            PathSegment { ident, span: ident.span, parameters }\n         } else {\n             // Generic arguments are not found.\n-            PathSegment::from_ident(ident, ident_span)\n+            PathSegment::from_ident(ident, ident.span)\n         })\n     }\n \n@@ -2085,7 +2081,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n         if let token::Literal(token::Integer(name), None) = self.token {\n             self.bump();\n-            Ok(Ident::with_empty_ctxt(name))\n+            Ok(Ident::new(name, self.prev_span))\n         } else {\n             self.parse_ident_common(false)\n         }\n@@ -2095,24 +2091,22 @@ impl<'a> Parser<'a> {\n     pub fn parse_field(&mut self) -> PResult<'a, Field> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span;\n-        let hi;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n             let fieldname = self.parse_field_name()?;\n-            hi = self.prev_span;\n-            self.bump();\n+            self.bump(); // `:`\n             (fieldname, self.parse_expr()?, false)\n         } else {\n             let fieldname = self.parse_ident_common(false)?;\n-            hi = self.prev_span;\n \n             // Mimic `x: x` for the `x` field shorthand.\n-            let path = ast::Path::from_ident(lo.to(hi), fieldname);\n-            (fieldname, self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new()), true)\n+            let path = ast::Path::from_ident(fieldname.span, fieldname);\n+            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n+            (fieldname, expr, true)\n         };\n         Ok(ast::Field {\n-            ident: respan(lo.to(hi), fieldname),\n+            ident: fieldname,\n             span: lo.to(expr.span),\n             expr,\n             is_shorthand,\n@@ -2592,8 +2586,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let span = lo.to(self.prev_span);\n-                let ident = respan(segment.span, segment.ident);\n-                self.mk_expr(span, ExprKind::Field(self_arg, ident), ThinVec::new())\n+                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n             }\n         })\n     }\n@@ -2736,7 +2729,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => return,\n         };\n-        self.token = token::Ident(ident.node, is_raw);\n+        self.token = token::Ident(ident, is_raw);\n         self.span = ident.span;\n     }\n \n@@ -3672,10 +3665,9 @@ impl<'a> Parser<'a> {\n                     (false, true) => BindingMode::ByValue(Mutability::Mutable),\n                     (false, false) => BindingMode::ByValue(Mutability::Immutable),\n                 };\n-                let fieldpath = codemap::Spanned{span:self.prev_span, node:fieldname};\n                 let fieldpat = P(Pat {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: PatKind::Ident(bind_type, fieldpath, None),\n+                    node: PatKind::Ident(bind_type, fieldname, None),\n                     span: boxed_span.to(hi),\n                 });\n \n@@ -3966,9 +3958,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n                        -> PResult<'a, PatKind> {\n-        let ident_span = self.span;\n         let ident = self.parse_ident()?;\n-        let name = codemap::Spanned{span: ident_span, node: ident};\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat()?)\n         } else {\n@@ -3987,7 +3977,7 @@ impl<'a> Parser<'a> {\n                 \"expected identifier, found enum pattern\"))\n         }\n \n-        Ok(PatKind::Ident(binding_mode, name, sub))\n+        Ok(PatKind::Ident(binding_mode, ident, sub))\n     }\n \n     /// Parse a local variable declaration\n@@ -5051,9 +5041,8 @@ impl<'a> Parser<'a> {\n     fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n             // Preserve hygienic context.\n-            token::Ident(ident, _) => {\n-                let sp = this.span; this.bump(); codemap::respan(sp, ident)\n-            }\n+            token::Ident(ident, _) =>\n+                { let span = this.span; this.bump(); Ident::new(ident.name, span) }\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {"}, {"sha": "003b0ac356da0753179a71b17ca18c6ac6383f1c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -321,7 +321,7 @@ impl Token {\n         match *self {\n             Ident(ident, is_raw) => Some((ident, is_raw)),\n             Interpolated(ref nt) => match nt.0 {\n-                NtIdent(ident, is_raw) => Some((ident.node, is_raw)),\n+                NtIdent(ident, is_raw) => Some((ident, is_raw)),\n                 _ => None,\n             },\n             _ => None,\n@@ -539,7 +539,7 @@ impl Token {\n                 tokens = prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span);\n             }\n             Nonterminal::NtIdent(ident, is_raw) => {\n-                let token = Token::Ident(ident.node, is_raw);\n+                let token = Token::Ident(ident, is_raw);\n                 tokens = Some(TokenTree::Token(ident.span, token).into());\n             }\n             Nonterminal::NtLifetime(lifetime) => {\n@@ -571,7 +571,7 @@ pub enum Nonterminal {\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(ast::SpannedIdent, /* is_raw */ bool),\n+    NtIdent(ast::Ident, /* is_raw */ bool),\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),"}, {"sha": "9dad422a728fb3e22bbb5251355988919ac8b4b0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -262,26 +262,26 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n         token::Interpolated(ref nt) => match nt.0 {\n-            token::NtExpr(ref e)         => expr_to_string(e),\n-            token::NtMeta(ref e)         => meta_item_to_string(e),\n-            token::NtTy(ref e)           => ty_to_string(e),\n-            token::NtPath(ref e)         => path_to_string(e),\n-            token::NtItem(ref e)         => item_to_string(e),\n-            token::NtBlock(ref e)        => block_to_string(e),\n-            token::NtStmt(ref e)         => stmt_to_string(e),\n-            token::NtPat(ref e)          => pat_to_string(e),\n-            token::NtIdent(ref e, false) => ident_to_string(e.node),\n-            token::NtIdent(ref e, true)  => format!(\"r#{}\", ident_to_string(e.node)),\n-            token::NtTT(ref tree)        => tt_to_string(tree.clone()),\n-            token::NtArm(ref e)          => arm_to_string(e),\n-            token::NtImplItem(ref e)     => impl_item_to_string(e),\n-            token::NtTraitItem(ref e)    => trait_item_to_string(e),\n-            token::NtGenerics(ref e)     => generic_params_to_string(&e.params),\n-            token::NtWhereClause(ref e)  => where_clause_to_string(e),\n-            token::NtArg(ref e)          => arg_to_string(e),\n-            token::NtVis(ref e)          => vis_to_string(e),\n-            token::NtLifetime(ref e)     => lifetime_to_string(e),\n-            token::NtForeignItem(ref ni) => foreign_item_to_string(ni),\n+            token::NtExpr(ref e)        => expr_to_string(e),\n+            token::NtMeta(ref e)        => meta_item_to_string(e),\n+            token::NtTy(ref e)          => ty_to_string(e),\n+            token::NtPath(ref e)        => path_to_string(e),\n+            token::NtItem(ref e)        => item_to_string(e),\n+            token::NtBlock(ref e)       => block_to_string(e),\n+            token::NtStmt(ref e)        => stmt_to_string(e),\n+            token::NtPat(ref e)         => pat_to_string(e),\n+            token::NtIdent(e, false)    => ident_to_string(e),\n+            token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n+            token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n+            token::NtArm(ref e)         => arm_to_string(e),\n+            token::NtImplItem(ref e)    => impl_item_to_string(e),\n+            token::NtTraitItem(ref e)   => trait_item_to_string(e),\n+            token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n+            token::NtWhereClause(ref e) => where_clause_to_string(e),\n+            token::NtArg(ref e)         => arg_to_string(e),\n+            token::NtVis(ref e)         => vis_to_string(e),\n+            token::NtLifetime(ref e)    => lifetime_to_string(e),\n+            token::NtForeignItem(ref e) => foreign_item_to_string(e),\n         }\n     }\n }\n@@ -1924,7 +1924,7 @@ impl<'a> State<'a> {\n             |s, field| {\n                 s.ibox(INDENT_UNIT)?;\n                 if !field.is_shorthand {\n-                    s.print_ident(field.ident.node)?;\n+                    s.print_ident(field.ident)?;\n                     s.word_space(\":\")?;\n                 }\n                 s.print_expr(&field.expr)?;\n@@ -2198,10 +2198,10 @@ impl<'a> State<'a> {\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(rhs, prec)?;\n             }\n-            ast::ExprKind::Field(ref expr, id) => {\n+            ast::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n-                self.print_ident(id.node)?;\n+                self.print_ident(ident)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n@@ -2526,7 +2526,7 @@ impl<'a> State<'a> {\n          is that it doesn't matter */\n         match pat.node {\n             PatKind::Wild => self.s.word(\"_\")?,\n-            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n+            PatKind::Ident(binding_mode, ident, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -2537,7 +2537,7 @@ impl<'a> State<'a> {\n                         self.word_nbsp(\"mut\")?;\n                     }\n                 }\n-                self.print_ident(path1.node)?;\n+                self.print_ident(ident)?;\n                 if let Some(ref p) = *sub {\n                     self.s.word(\"@\")?;\n                     self.print_pat(p)?;\n@@ -2999,7 +2999,7 @@ impl<'a> State<'a> {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n                     let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n-                        ident.node.name == keywords::Invalid.name()\n+                        ident.name == keywords::Invalid.name()\n                     } else {\n                         false\n                     };"}, {"sha": "7be3c2790e8bf5413bc7f8447a2f7ecd4ab61d31", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -430,8 +430,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         PatKind::Paren(ref subpattern) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n-            visitor.visit_ident(pth1.span, pth1.node);\n+        PatKind::Ident(_, ident, ref optional_subpattern) => {\n+            visitor.visit_ident(ident.span, ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n@@ -666,7 +666,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n                 walk_list!(visitor, visit_attribute, field.attrs.iter());\n-                visitor.visit_ident(field.ident.span, field.ident.node);\n+                visitor.visit_ident(field.ident.span, field.ident);\n                 visitor.visit_expr(&field.expr)\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n@@ -745,9 +745,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n         }\n-        ExprKind::Field(ref subexpression, ref ident) => {\n+        ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident.span, ident.node);\n+            visitor.visit_ident(ident.span, ident);\n         }\n         ExprKind::TupField(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "1df7706966de5f5389ac61fc79c87067b407d8c5", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::feature_gate;\n@@ -53,43 +52,29 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         }\n     }\n-    let res = ast::Ident::new(Symbol::intern(&res_str),\n-                              DUMMY_SP.apply_mark(cx.current_expansion.mark));\n-    struct Result {\n-        ident: ast::Ident,\n-        span: Span,\n-    };\n \n-    impl Result {\n-        fn path(&self) -> ast::Path {\n-            ast::Path {\n-                span: self.span,\n-                segments: vec![ast::PathSegment::from_ident(self.ident, self.span)],\n-            }\n-        }\n-    }\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.mark));\n+\n+    struct ConcatIdentsResult { ident: ast::Ident }\n \n-    impl base::MacResult for Result {\n+    impl base::MacResult for ConcatIdentsResult {\n         fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n             Some(P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Path(None, self.path()),\n-                span: self.span,\n+                node: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident.span, self.ident)),\n+                span: self.ident.span,\n                 attrs: ast::ThinVec::new(),\n             }))\n         }\n \n         fn make_ty(self: Box<Self>) -> Option<P<ast::Ty>> {\n             Some(P(ast::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::TyKind::Path(None, self.path()),\n-                span: self.span,\n+                node: ast::TyKind::Path(None, ast::Path::from_ident(self.ident.span, self.ident)),\n+                span: self.ident.span,\n             }))\n         }\n     }\n \n-    Box::new(Result {\n-        ident: res,\n-        span: sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark)),\n-    })\n+    Box::new(ConcatIdentsResult { ident })\n }"}, {"sha": "ab285c4d395c18fdf0b47964588ab1f6caeed5a5", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -195,6 +195,7 @@ use syntax::abi::Abi;\n use syntax::ast::{\n     self, BinOpKind, EnumDef, Expr, GenericParam, Generics, Ident, PatKind, VariantData\n };\n+\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -952,7 +953,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 ast::Arg::from_self(explicit_self,\n-                                    respan(trait_.span, keywords::SelfValue.ident()))\n+                                    keywords::SelfValue.ident().with_span_pos(trait_.span))\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n@@ -1581,7 +1582,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: Vec<ast::SpannedIdent>,\n+                          field_paths: Vec<ast::Ident>,\n                           mutbl: ast::Mutability,\n                           use_temporaries: bool)\n                           -> Vec<P<ast::Pat>> {\n@@ -1613,10 +1614,7 @@ impl<'a> TraitDef<'a> {\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n-            paths.push(codemap::Spanned {\n-                span: sp,\n-                node: ident,\n-            });\n+            paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {\n                 val"}, {"sha": "279f1dec14276c6231c56fabb9f02948555efcda", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2afefd80bf779bc3c6f697a3c6cc3a476993602/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=e2afefd80bf779bc3c6f697a3c6cc3a476993602", "patch": "@@ -41,7 +41,12 @@ impl Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n-    pub fn without_first_quote(&self) -> Ident {\n+    /// Replace `lo` and `hi` with those from `span`, but keep hygiene context.\n+    pub fn with_span_pos(self, span: Span) -> Ident {\n+        Ident::new(self.name, span.with_ctxt(self.span.ctxt()))\n+    }\n+\n+    pub fn without_first_quote(self) -> Ident {\n         Ident::new(Symbol::from(self.name.as_str().trim_left_matches('\\'')), self.span)\n     }\n "}]}