{"sha": "605c64a91e5a748b29224887a63e6220ebac91f9", "node_id": "C_kwDOAAsO6NoAKDYwNWM2NGE5MWU1YTc0OGIyOTIyNDg4N2E2M2U2MjIwZWJhYzkxZjk", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-06-15T10:37:40Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-06-15T10:37:40Z"}, "message": "[RFC 2011] Minimal initial implementation", "tree": {"sha": "31d743adb2aa3ce5098308fa9d439b3f1aebfe0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d743adb2aa3ce5098308fa9d439b3f1aebfe0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/605c64a91e5a748b29224887a63e6220ebac91f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/605c64a91e5a748b29224887a63e6220ebac91f9", "html_url": "https://github.com/rust-lang/rust/commit/605c64a91e5a748b29224887a63e6220ebac91f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/605c64a91e5a748b29224887a63e6220ebac91f9/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "389352c4bbd56024eefd1566e06dcba04d223f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/389352c4bbd56024eefd1566e06dcba04d223f92", "html_url": "https://github.com/rust-lang/rust/commit/389352c4bbd56024eefd1566e06dcba04d223f92"}], "stats": {"total": 709, "additions": 668, "deletions": 41}, "files": [{"sha": "37a4bf5fdcad7cbf79d1d313b82dd60a5d6fb6f0", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 281, "deletions": 26, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -1,44 +1,299 @@\n-use rustc_ast::{ptr::P, Expr, Path};\n+use crate::assert::expr_if_not;\n+use rustc_ast::{\n+    attr,\n+    ptr::P,\n+    token,\n+    tokenstream::{DelimSpan, TokenStream, TokenTree},\n+    BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, Mutability, Path,\n+    PathSegment, Stmt, UseTree, UseTreeKind, DUMMY_NODE_ID,\n+};\n+use rustc_ast_pretty::pprust;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::ExtCtxt;\n-use rustc_span::Span;\n+use rustc_span::{\n+    symbol::{sym, Ident, Symbol},\n+    Span,\n+};\n \n pub(super) struct Context<'cx, 'a> {\n+    // Top-level `let captureN = Capture::new()` statements\n+    capture_decls: Vec<Capture>,\n     cx: &'cx ExtCtxt<'a>,\n+    // Formatting string used for debugging\n+    fmt_string: String,\n+    // Top-level `let __local_bindN = &expr` statements\n+    local_bind_decls: Vec<Stmt>,\n+    // Used to avoid capturing duplicated paths\n+    //\n+    // ```rust\n+    // let a = 1i32;\n+    // assert!(add(a, a) == 3);\n+    // ```\n+    paths: FxHashSet<Ident>,\n     span: Span,\n }\n \n impl<'cx, 'a> Context<'cx, 'a> {\n     pub(super) fn new(cx: &'cx ExtCtxt<'a>, span: Span) -> Self {\n-        Self { cx, span }\n+        Self {\n+            capture_decls: <_>::default(),\n+            cx,\n+            fmt_string: <_>::default(),\n+            local_bind_decls: <_>::default(),\n+            paths: <_>::default(),\n+            span,\n+        }\n     }\n \n-    /// Builds the whole `assert!` expression.\n+    /// Builds the whole `assert!` expression. For example, `let elem = 1; assert!(elem == 1);` expands to:\n     ///\n+    /// ```rust\n+    /// let elem = 1;\n     /// {\n-    ///    use ::core::asserting::{ ... };\n+    ///   #[allow(unused_imports)]\n+    ///   use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+    ///   let mut __capture0 = ::core::asserting::Capture::new();\n+    ///   let __local_bind0 = &elem;\n+    ///   if !(\n+    ///     *{\n+    ///       (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+    ///       __local_bind0\n+    ///     } == 1\n+    ///   ) {\n+    ///     panic!(\"Assertion failed: elem == 1\\nWith captures:\\n  elem = {}\", __capture0)\n+    ///   }\n+    /// }\n+    /// ```\n+    pub(super) fn build(mut self, mut cond_expr: P<Expr>, panic_path: Path) -> P<Expr> {\n+        let expr_str = pprust::expr_to_string(&cond_expr);\n+        self.manage_cond_expr(&mut cond_expr);\n+        let initial_imports = self.build_initial_imports();\n+        let panic = self.build_panic(&expr_str, panic_path);\n+\n+        let Self { capture_decls, cx, local_bind_decls, span, .. } = self;\n+\n+        let mut stmts = Vec::with_capacity(4);\n+        stmts.push(initial_imports);\n+        stmts.extend(capture_decls.into_iter().map(|c| c.decl));\n+        stmts.extend(local_bind_decls);\n+        stmts.push(cx.stmt_expr(expr_if_not(cx, span, cond_expr, panic, None)));\n+        cx.expr_block(cx.block(span, stmts))\n+    }\n+\n+    /// Initial **trait** imports\n+    ///\n+    /// use ::core::asserting::{ ... };\n+    fn build_initial_imports(&self) -> Stmt {\n+        let nested_tree = |this: &Self, sym| {\n+            (\n+                UseTree {\n+                    prefix: this.cx.path(this.span, vec![Ident::with_dummy_span(sym)]),\n+                    kind: UseTreeKind::Simple(None, DUMMY_NODE_ID, DUMMY_NODE_ID),\n+                    span: this.span,\n+                },\n+                DUMMY_NODE_ID,\n+            )\n+        };\n+        self.cx.stmt_item(\n+            self.span,\n+            self.cx.item(\n+                self.span,\n+                Ident::empty(),\n+                vec![self.cx.attribute(attr::mk_list_item(\n+                    Ident::new(sym::allow, self.span),\n+                    vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n+                ))],\n+                ItemKind::Use(UseTree {\n+                    prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n+                    kind: UseTreeKind::Nested(vec![\n+                        nested_tree(self, sym::TryCaptureGeneric),\n+                        nested_tree(self, sym::TryCapturePrintable),\n+                    ]),\n+                    span: self.span,\n+                }),\n+            ),\n+        )\n+    }\n+\n+    /// The necessary custom `panic!(...)` expression.\n+    ///\n+    /// panic!(\n+    ///     \"Assertion failed: ... \\n With expansion: ...\",\n+    ///     __capture0,\n+    ///     ...\n+    /// );\n+    fn build_panic(&self, expr_str: &str, panic_path: Path) -> P<Expr> {\n+        let escaped_expr_str = escape_to_fmt(expr_str);\n+        let initial = [\n+            TokenTree::token(\n+                token::Literal(token::Lit {\n+                    kind: token::LitKind::Str,\n+                    symbol: Symbol::intern(&if self.fmt_string.is_empty() {\n+                        format!(\"Assertion failed: {escaped_expr_str}\")\n+                    } else {\n+                        format!(\n+                            \"Assertion failed: {escaped_expr_str}\\nWith captures:\\n{}\",\n+                            &self.fmt_string\n+                        )\n+                    }),\n+                    suffix: None,\n+                }),\n+                self.span,\n+            ),\n+            TokenTree::token(token::Comma, self.span),\n+        ];\n+        let captures = self.capture_decls.iter().flat_map(|cap| {\n+            [\n+                TokenTree::token(token::Ident(cap.ident.name, false), cap.ident.span),\n+                TokenTree::token(token::Comma, self.span),\n+            ]\n+        });\n+        self.cx.expr(\n+            self.span,\n+            ExprKind::MacCall(MacCall {\n+                path: panic_path,\n+                args: P(MacArgs::Delimited(\n+                    DelimSpan::from_single(self.span),\n+                    MacDelimiter::Parenthesis,\n+                    initial.into_iter().chain(captures).collect::<TokenStream>(),\n+                )),\n+                prior_type_ascription: None,\n+            }),\n+        )\n+    }\n+\n+    /// Recursive function called until `cond_expr` and `fmt_str` are fully modified.\n+    ///\n+    /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n+    fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n+        match (*expr).kind {\n+            ExprKind::Binary(_, ref mut lhs, ref mut rhs) => {\n+                self.manage_cond_expr(lhs);\n+                self.manage_cond_expr(rhs);\n+            }\n+            ExprKind::Path(_, Path { ref segments, .. }) if let &[ref path_segment] = &segments[..] => {\n+                let path_ident = path_segment.ident;\n+                self.manage_initial_capture(expr, path_ident);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    /// Pushes the top-level declarations and modifies `expr` to try capturing variables.\n     ///\n-    ///    let mut __capture0 = Capture::new();\n-    ///    ...\n-    ///    ...\n-    ///    ...\n+    /// `fmt_str`, the formatting string used for debugging, is constructed to show possible\n+    /// captured variables.\n+    fn manage_initial_capture(&mut self, expr: &mut P<Expr>, path_ident: Ident) {\n+        if self.paths.contains(&path_ident) {\n+            return;\n+        } else {\n+            self.fmt_string.push_str(\"  \");\n+            self.fmt_string.push_str(path_ident.as_str());\n+            self.fmt_string.push_str(\" = {:?}\\n\");\n+            let _ = self.paths.insert(path_ident);\n+        }\n+        let curr_capture_idx = self.capture_decls.len();\n+        let capture_string = format!(\"__capture{curr_capture_idx}\");\n+        let ident = Ident::new(Symbol::intern(&capture_string), self.span);\n+        let init_std_path = self.cx.std_path(&[sym::asserting, sym::Capture, sym::new]);\n+        let init = self.cx.expr_call(\n+            self.span,\n+            self.cx.expr_path(self.cx.path(self.span, init_std_path)),\n+            vec![],\n+        );\n+        let capture = Capture { decl: self.cx.stmt_let(self.span, true, ident, init), ident };\n+        self.capture_decls.push(capture);\n+        self.manage_try_capture(ident, curr_capture_idx, expr);\n+    }\n+\n+    /// Tries to copy `__local_bindN` into `__captureN`.\n     ///\n-    ///    if !{\n-    ///       ...\n-    ///       ...\n-    ///       ...\n-    ///    } {\n-    ///        panic!(\n-    ///            \"Assertion failed: ... \\n With expansion: ...\",\n-    ///            __capture0,\n-    ///            ...\n-    ///            ...\n-    ///            ...\n-    ///        );\n-    ///    }\n+    /// *{\n+    ///    (&Wrapper(__local_bindN)).try_capture(&mut __captureN);\n+    ///    __local_bindN\n     /// }\n-    pub(super) fn build(self, _cond_expr: P<Expr>, _panic_path: Path) -> P<Expr> {\n-        let Self { cx, span, .. } = self;\n-        let stmts = Vec::new();\n-        cx.expr_block(cx.block(span, stmts))\n+    fn manage_try_capture(&mut self, capture: Ident, curr_capture_idx: usize, expr: &mut P<Expr>) {\n+        let local_bind_string = format!(\"__local_bind{curr_capture_idx}\");\n+        let local_bind = Ident::new(Symbol::intern(&local_bind_string), self.span);\n+        self.local_bind_decls.push(self.cx.stmt_let(\n+            self.span,\n+            false,\n+            local_bind,\n+            self.cx.expr_addr_of(self.span, expr.clone()),\n+        ));\n+        let wrapper = self.cx.expr_call(\n+            self.span,\n+            self.cx.expr_path(\n+                self.cx.path(self.span, self.cx.std_path(&[sym::asserting, sym::Wrapper])),\n+            ),\n+            vec![self.cx.expr_path(Path::from_ident(local_bind))],\n+        );\n+        let try_capture_call = self\n+            .cx\n+            .stmt_expr(expr_method_call(\n+                self.cx,\n+                PathSegment {\n+                    args: None,\n+                    id: DUMMY_NODE_ID,\n+                    ident: Ident::new(sym::try_capture, self.span),\n+                },\n+                vec![\n+                    expr_paren(self.cx, self.span, self.cx.expr_addr_of(self.span, wrapper)),\n+                    expr_addr_of_mut(\n+                        self.cx,\n+                        self.span,\n+                        self.cx.expr_path(Path::from_ident(capture)),\n+                    ),\n+                ],\n+                self.span,\n+            ))\n+            .add_trailing_semicolon();\n+        let local_bind_path = self.cx.expr_path(Path::from_ident(local_bind));\n+        let ret = self.cx.stmt_expr(local_bind_path);\n+        let block = self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]));\n+        *expr = self.cx.expr_deref(self.span, block);\n+    }\n+}\n+\n+/// Information about a captured element.\n+#[derive(Debug)]\n+struct Capture {\n+    // Generated indexed `Capture` statement.\n+    //\n+    // `let __capture{} = Capture::new();`\n+    decl: Stmt,\n+    // The name of the generated indexed `Capture` variable.\n+    //\n+    // `__capture{}`\n+    ident: Ident,\n+}\n+\n+/// Escapes to use as a formatting string.\n+fn escape_to_fmt(s: &str) -> String {\n+    let mut rslt = String::with_capacity(s.len());\n+    for c in s.chars() {\n+        rslt.extend(c.escape_debug());\n+        match c {\n+            '{' | '}' => rslt.push(c),\n+            _ => {}\n+        }\n     }\n+    rslt\n+}\n+\n+fn expr_addr_of_mut(cx: &ExtCtxt<'_>, sp: Span, e: P<Expr>) -> P<Expr> {\n+    cx.expr(sp, ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, e))\n+}\n+\n+fn expr_method_call(\n+    cx: &ExtCtxt<'_>,\n+    path: PathSegment,\n+    args: Vec<P<Expr>>,\n+    span: Span,\n+) -> P<Expr> {\n+    cx.expr(span, ExprKind::MethodCall(path, args, span))\n+}\n+\n+fn expr_paren(cx: &ExtCtxt<'_>, sp: Span, e: P<Expr>) -> P<Expr> {\n+    cx.expr(sp, ExprKind::Paren(e))\n }"}, {"sha": "11565ba72d7555f1fb157468fd4c83b957eb873e", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -6,6 +6,7 @@\n #![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(decl_macro)]\n+#![feature(if_let_guard)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "c35a11ff7619e6afbb40e0582a169969f9379228", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -157,6 +157,7 @@ symbols! {\n         C,\n         CStr,\n         CString,\n+        Capture,\n         Center,\n         Clone,\n         Continue,\n@@ -267,6 +268,8 @@ symbols! {\n         ToOwned,\n         ToString,\n         Try,\n+        TryCaptureGeneric,\n+        TryCapturePrintable,\n         TryFrom,\n         TryInto,\n         Ty,\n@@ -276,6 +279,7 @@ symbols! {\n         UnsafeArg,\n         Vec,\n         VecDeque,\n+        Wrapper,\n         Yield,\n         _DECLS,\n         _Self,\n@@ -358,6 +362,7 @@ symbols! {\n         assert_receiver_is_total_eq,\n         assert_uninit_valid,\n         assert_zero_valid,\n+        asserting,\n         associated_const_equality,\n         associated_consts,\n         associated_type_bounds,\n@@ -1437,6 +1442,7 @@ symbols! {\n         truncf32,\n         truncf64,\n         try_blocks,\n+        try_capture,\n         try_from,\n         try_into,\n         try_trait_v2,\n@@ -1499,6 +1505,7 @@ symbols! {\n         unsized_tuple_coercion,\n         unstable,\n         untagged_unions,\n+        unused_imports,\n         unused_qualifications,\n         unwind,\n         unwind_attributes,"}, {"sha": "da725e19e2ada9e0aaa3d3733bf91cf233863213", "filename": "src/test/ui/macros/assert-trailing-junk.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -1,3 +1,6 @@\n+// revisions: with-generic-asset without-generic-asset\n+// [with-generic-asset] compile-flags: --cfg feature=\"generic_assert\"\n+\n // Ensure assert macro does not ignore trailing garbage.\n //\n // See https://github.com/rust-lang/rust/issues/60024 for details."}, {"sha": "09dd16a0b0d89049df549e25aa2818d94d93e48f", "filename": "src/test/ui/macros/assert-trailing-junk.with-generic-asset.stderr", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.with-generic-asset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.with-generic-asset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.with-generic-asset.stderr?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -1,49 +1,49 @@\n error: expected one of `,`, `.`, `?`, or an operator, found `some`\n-  --> $DIR/assert-trailing-junk.rs:6:18\n+  --> $DIR/assert-trailing-junk.rs:9:18\n    |\n LL |     assert!(true some extra junk, \"whatever\");\n    |                  ^^^^ expected one of `,`, `.`, `?`, or an operator\n \n error: expected one of `,`, `.`, `?`, or an operator, found `some`\n-  --> $DIR/assert-trailing-junk.rs:9:18\n+  --> $DIR/assert-trailing-junk.rs:12:18\n    |\n LL |     assert!(true some extra junk);\n    |                  ^^^^ expected one of `,`, `.`, `?`, or an operator\n \n error: no rules expected the token `blah`\n-  --> $DIR/assert-trailing-junk.rs:12:30\n+  --> $DIR/assert-trailing-junk.rs:15:30\n    |\n LL |     assert!(true, \"whatever\" blah);\n    |                             -^^^^ no rules expected this token in macro call\n    |                             |\n    |                             help: missing comma here\n \n error: unexpected string literal\n-  --> $DIR/assert-trailing-junk.rs:15:18\n+  --> $DIR/assert-trailing-junk.rs:18:18\n    |\n LL |     assert!(true \"whatever\" blah);\n    |                 -^^^^^^^^^^\n    |                 |\n    |                 help: try adding a comma\n \n error: no rules expected the token `blah`\n-  --> $DIR/assert-trailing-junk.rs:15:29\n+  --> $DIR/assert-trailing-junk.rs:18:29\n    |\n LL |     assert!(true \"whatever\" blah);\n    |                            -^^^^ no rules expected this token in macro call\n    |                            |\n    |                            help: missing comma here\n \n error: macro requires an expression as an argument\n-  --> $DIR/assert-trailing-junk.rs:19:5\n+  --> $DIR/assert-trailing-junk.rs:22:5\n    |\n LL |     assert!(true;);\n    |     ^^^^^^^^^^^^-^\n    |                 |\n    |                 help: try removing semicolon\n \n error: unexpected string literal\n-  --> $DIR/assert-trailing-junk.rs:22:27\n+  --> $DIR/assert-trailing-junk.rs:25:27\n    |\n LL |     assert!(false || true \"error message\");\n    |                          -^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/macros/assert-trailing-junk.stderr"}, {"sha": "09dd16a0b0d89049df549e25aa2818d94d93e48f", "filename": "src/test/ui/macros/assert-trailing-junk.without-generic-asset.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.without-generic-asset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.without-generic-asset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert-trailing-junk.without-generic-asset.stderr?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,54 @@\n+error: expected one of `,`, `.`, `?`, or an operator, found `some`\n+  --> $DIR/assert-trailing-junk.rs:9:18\n+   |\n+LL |     assert!(true some extra junk, \"whatever\");\n+   |                  ^^^^ expected one of `,`, `.`, `?`, or an operator\n+\n+error: expected one of `,`, `.`, `?`, or an operator, found `some`\n+  --> $DIR/assert-trailing-junk.rs:12:18\n+   |\n+LL |     assert!(true some extra junk);\n+   |                  ^^^^ expected one of `,`, `.`, `?`, or an operator\n+\n+error: no rules expected the token `blah`\n+  --> $DIR/assert-trailing-junk.rs:15:30\n+   |\n+LL |     assert!(true, \"whatever\" blah);\n+   |                             -^^^^ no rules expected this token in macro call\n+   |                             |\n+   |                             help: missing comma here\n+\n+error: unexpected string literal\n+  --> $DIR/assert-trailing-junk.rs:18:18\n+   |\n+LL |     assert!(true \"whatever\" blah);\n+   |                 -^^^^^^^^^^\n+   |                 |\n+   |                 help: try adding a comma\n+\n+error: no rules expected the token `blah`\n+  --> $DIR/assert-trailing-junk.rs:18:29\n+   |\n+LL |     assert!(true \"whatever\" blah);\n+   |                            -^^^^ no rules expected this token in macro call\n+   |                            |\n+   |                            help: missing comma here\n+\n+error: macro requires an expression as an argument\n+  --> $DIR/assert-trailing-junk.rs:22:5\n+   |\n+LL |     assert!(true;);\n+   |     ^^^^^^^^^^^^-^\n+   |                 |\n+   |                 help: try removing semicolon\n+\n+error: unexpected string literal\n+  --> $DIR/assert-trailing-junk.rs:25:27\n+   |\n+LL |     assert!(false || true \"error message\");\n+   |                          -^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          help: try adding a comma\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "a314db907b8a24afcbe4f1f110687b6be3b0ed57", "filename": "src/test/ui/macros/assert.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -1,3 +1,6 @@\n+// revisions: with-generic-asset without-generic-asset\n+// [with-generic-asset] compile-flags: --cfg feature=\"generic_assert\"\n+\n fn main() {\n     assert!();  //~ ERROR requires a boolean expression\n     assert!(struct); //~ ERROR expected expression"}, {"sha": "51d8f28a35c39d4b49d1dc4eaedaf1a75362f38b", "filename": "src/test/ui/macros/assert.with-generic-asset.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert.with-generic-asset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert.with-generic-asset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert.with-generic-asset.stderr?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -1,25 +1,25 @@\n error: macro requires a boolean expression as an argument\n-  --> $DIR/assert.rs:2:5\n+  --> $DIR/assert.rs:5:5\n    |\n LL |     assert!();\n    |     ^^^^^^^^^ boolean expression required\n \n error: expected expression, found keyword `struct`\n-  --> $DIR/assert.rs:3:13\n+  --> $DIR/assert.rs:6:13\n    |\n LL |     assert!(struct);\n    |             ^^^^^^ expected expression\n \n error: macro requires a boolean expression as an argument\n-  --> $DIR/assert.rs:4:5\n+  --> $DIR/assert.rs:7:5\n    |\n LL |     debug_assert!();\n    |     ^^^^^^^^^^^^^^^ boolean expression required\n    |\n    = note: this error originates in the macro `debug_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected expression, found keyword `struct`\n-  --> $DIR/assert.rs:5:19\n+  --> $DIR/assert.rs:8:19\n    |\n LL |     debug_assert!(struct);\n    |                   ^^^^^^ expected expression", "previous_filename": "src/test/ui/macros/assert.stderr"}, {"sha": "51d8f28a35c39d4b49d1dc4eaedaf1a75362f38b", "filename": "src/test/ui/macros/assert.without-generic-asset.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert.without-generic-asset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Fassert.without-generic-asset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert.without-generic-asset.stderr?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,28 @@\n+error: macro requires a boolean expression as an argument\n+  --> $DIR/assert.rs:5:5\n+   |\n+LL |     assert!();\n+   |     ^^^^^^^^^ boolean expression required\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/assert.rs:6:13\n+   |\n+LL |     assert!(struct);\n+   |             ^^^^^^ expected expression\n+\n+error: macro requires a boolean expression as an argument\n+  --> $DIR/assert.rs:7:5\n+   |\n+LL |     debug_assert!();\n+   |     ^^^^^^^^^^^^^^^ boolean expression required\n+   |\n+   = note: this error originates in the macro `debug_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/assert.rs:8:19\n+   |\n+LL |     debug_assert!(struct);\n+   |                   ^^^^^^ expected expression\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c0e9f29fdbce0e79e67c1217682de596e2a9e0cf", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,143 @@\n+// edition:2021\n+// ignore-tidy-linelength\n+// only-x86_64\n+// run-pass\n+\n+#![allow(path_statements, unused_allocation)]\n+#![feature(box_syntax, core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+macro_rules! test {\n+  (\n+    let mut $elem_ident:ident = $elem_expr:expr;\n+    [ $($assert:tt)* ] => $msg:literal\n+  ) => {\n+    {\n+      #[allow(unused_assignments, unused_mut, unused_variables)]\n+      let rslt = std::panic::catch_unwind(|| {\n+        let mut $elem_ident = $elem_expr;\n+        assert!($($assert)*);\n+      });\n+      let err = rslt.unwrap_err();\n+      if let Some(elem) = err.downcast_ref::<String>() {\n+        assert_eq!(elem, &$msg);\n+      }\n+      else if let Some(elem) = err.downcast_ref::<&str>() {\n+        assert_eq!(elem, &$msg);\n+      }\n+      else {\n+        panic!(\"assert!( ... ) should return a string\");\n+      }\n+    }\n+  }\n+}\n+\n+macro_rules! tests {\n+  (\n+    let mut $elem_ident:ident = $elem_expr:expr;\n+\n+    $(\n+      [ $($elem_assert:tt)* ] => $elem_msg:literal\n+    )+\n+  ) => {\n+    $(\n+      test!(\n+        let mut $elem_ident = $elem_expr;\n+        [ $($elem_assert)* ] => $elem_msg\n+      );\n+    )+\n+  }\n+}\n+\n+const FOO: Foo = Foo { bar: 1 };\n+\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+struct Foo {\n+  bar: i32\n+}\n+\n+fn main() {\n+  // ***** Allowed *****\n+\n+  tests!(\n+    let mut elem = 1i32;\n+\n+    // binary\n+    [ elem + 1 == 3 ] => \"Assertion failed: elem + 1 == 3\\nWith captures:\\n  elem = 1\\n\"\n+  );\n+\n+  // ***** Disallowed *****\n+\n+  tests!(\n+    let mut elem = 1i32;\n+\n+    // assign\n+    [ { let local = elem; local } == 3 ] => \"Assertion failed: { let local = elem; local } == 3\"\n+\n+    // assign op\n+    [ { elem += 1; elem } == 3 ] => \"Assertion failed: { elem += 1; elem } == 3\"\n+\n+    // async\n+    [ { let _ = async { elem }; elem } == 3 ] => \"Assertion failed: { let _ = async { elem }; elem } == 3\"\n+\n+    // await\n+\n+    // block\n+    [ { elem } == 3 ] => \"Assertion failed: { elem } == 3\"\n+\n+    // box\n+    [ box elem == box 3 ] => \"Assertion failed: box elem == box 3\"\n+\n+    // break\n+    [ loop { break elem; } ==  3 ] => \"Assertion failed: loop { break elem; } == 3\"\n+\n+    // closure\n+    [(|| elem)() ==  3 ] => \"Assertion failed: (|| elem)() == 3\"\n+\n+    // const block\n+\n+    // continue\n+\n+    // err\n+\n+    // field\n+    [ FOO.bar ==  3 ] => \"Assertion failed: FOO.bar == 3\"\n+\n+    // for loop\n+    [ { for _ in 0..elem { elem; } elem } ==  3 ] => \"Assertion failed: { for _ in 0..elem { elem; } elem } == 3\"\n+\n+    // if\n+    [ if true { elem } else { elem } == 3 ] => \"Assertion failed: if true { elem } else { elem } == 3\"\n+\n+    // inline asm\n+\n+    // let\n+    [ if let true = true { elem } else { elem } == 3 ] => \"Assertion failed: if let true = true { elem } else { elem } == 3\"\n+\n+    // lit\n+\n+    // loop\n+    [ loop { elem; break elem; } == 3 ] => \"Assertion failed: loop { elem; break elem; } == 3\"\n+\n+    // mac call\n+\n+    // match\n+    [ match elem { _ => elem } == 3 ] => \"Assertion failed: match elem { _ => elem, } == 3\"\n+\n+    // ret\n+    [ (|| { return elem; })() == 3 ] => \"Assertion failed: (|| { return elem; })() == 3\"\n+\n+    // try\n+    [ (|| { Some(Some(elem)?) })() == Some(3) ] => \"Assertion failed: (|| { Some(Some(elem)?) })() == Some(3)\"\n+\n+    // try block\n+\n+    // underscore\n+\n+    // while\n+    [ { while false { elem; break; } elem } == 3 ] => \"Assertion failed: { while false { elem; break; } elem } == 3\"\n+\n+    // yeet\n+\n+    // yield\n+  );\n+}"}, {"sha": "86697c58fbcf13ca9f5bd2e8b929193b8ddc7686", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-not-available-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-not-available-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-not-available-cases.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,43 @@\n+// aux-build:common.rs\n+// ignore-tidy-linelength\n+// only-x86_64\n+// run-pass\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+extern crate common;\n+\n+#[derive(Clone, Copy, PartialEq)]\n+struct CopyNoDebug(i32);\n+\n+#[derive(Debug, PartialEq)]\n+struct NoCopyDebug(i32);\n+\n+#[derive(PartialEq)]\n+struct NoCopyNoDebug(i32);\n+\n+fn main() {\n+  // Has Copy but does not have Debug\n+  common::test!(\n+    let mut copy_no_debug = CopyNoDebug(1);\n+    [ copy_no_debug == CopyNoDebug(3) ] => \"Assertion failed: copy_no_debug == CopyNoDebug(3)\\nWith captures:\\n  copy_no_debug = N/A\\n\"\n+  );\n+\n+  // Does not have Copy but has Debug\n+  common::test!(\n+    let mut no_copy_debug = NoCopyDebug(1);\n+    [ no_copy_debug == NoCopyDebug(3) ] => \"Assertion failed: no_copy_debug == NoCopyDebug(3)\\nWith captures:\\n  no_copy_debug = N/A\\n\"\n+  );\n+\n+  // Does not have Copy and does not have Debug\n+  common::test!(\n+    let mut no_copy_no_debug = NoCopyNoDebug(1);\n+    [ no_copy_no_debug == NoCopyNoDebug(3) ] => \"Assertion failed: no_copy_no_debug == NoCopyNoDebug(3)\\nWith captures:\\n  no_copy_no_debug = N/A\\n\"\n+  );\n+\n+  // Unevaluated (Expression short-circuited)\n+  common::test!(\n+    let mut elem = true;\n+    [ false && elem ] => \"Assertion failed: false && elem\\nWith captures:\\n  elem = N/A\\n\"\n+  );\n+}"}, {"sha": "6a1435f792bf41eaaa5fbe95b47d4909e14e0f4f", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/assert-with-custom-errors-does-not-create-unnecessary-code.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-with-custom-errors-does-not-create-unnecessary-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-with-custom-errors-does-not-create-unnecessary-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-with-custom-errors-does-not-create-unnecessary-code.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: --test\n+// run-pass\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+#[should_panic(expected = \"Custom user message\")]\n+#[test]\n+fn test() {\n+  assert!(1 == 3, \"Custom user message\");\n+}\n+\n+fn main() {\n+}"}, {"sha": "06c4993ec30d6968b1dbbd26cbfa1d31a272e98a", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-without-captures-does-not-create-unnecessary-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-without-captures-does-not-create-unnecessary-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fassert-without-captures-does-not-create-unnecessary-code.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:common.rs\n+// only-x86_64\n+// run-pass\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+extern crate common;\n+\n+fn main() {\n+  common::test!(\n+    let mut _nothing = ();\n+    [ 1 == 3 ] => \"Assertion failed: 1 == 3\"\n+  );\n+}"}, {"sha": "903ed507c2e51a603fb93659edb3155f89ea174d", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fauxiliary%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fauxiliary%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fauxiliary%2Fcommon.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,25 @@\n+#[macro_export]\n+macro_rules! test {\n+  (\n+    let mut $elem_ident:ident = $elem_expr:expr;\n+    [ $($assert:tt)* ] => $msg:literal\n+  ) => {\n+    {\n+      #[allow(unused_assignments, unused_mut, unused_variables)]\n+      let rslt = std::panic::catch_unwind(|| {\n+        let mut $elem_ident = $elem_expr;\n+        assert!($($assert)*);\n+      });\n+      let err = rslt.unwrap_err();\n+      if let Some(elem) = err.downcast_ref::<String>() {\n+        assert_eq!(elem, &$msg);\n+      }\n+      else if let Some(elem) = err.downcast_ref::<&str>() {\n+        assert_eq!(elem, &$msg);\n+      }\n+      else {\n+        panic!(\"assert!( ... ) should return a string\");\n+      }\n+    }\n+  }\n+}"}, {"sha": "1db9d33c72aeea1cf4c36ff2eba323f3a254805f", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/codegen.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+fn main() {\n+    let elem = 1i32;\n+    assert!(elem == 1);\n+}"}, {"sha": "a590eb3223254be489a166eabbf58545857b2e8c", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/codegen.stdout", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -0,0 +1,29 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+// check-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#[prelude_import]\n+use ::std::prelude::rust_2015::*;\n+#[macro_use]\n+extern crate std;\n+\n+fn main() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if !(*{\n+                                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                                __local_bind0\n+                            } == 1) {\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem == 1\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}"}, {"sha": "01860adaac250c99bb165a86eae65d66187d5430", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/feature-gate-generic_assert.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Ffeature-gate-generic_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/605c64a91e5a748b29224887a63e6220ebac91f9/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Ffeature-gate-generic_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Ffeature-gate-generic_assert.rs?ref=605c64a91e5a748b29224887a63e6220ebac91f9", "patch": "@@ -1,8 +1,7 @@\n // compile-flags: --test\n+// ignore-tidy-linelength\n // run-pass\n \n-// `generic_assert` is completely unimplemented and doesn't generate any logic, thus the\n-// reason why this test currently passes\n #![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n \n use std::fmt::{Debug, Formatter};\n@@ -16,10 +15,11 @@ impl Debug for CopyDebug {\n   }\n }\n \n+#[should_panic(expected = \"Assertion failed: copy_debug == CopyDebug(3)\\nWith captures:\\n  copy_debug = With great power comes great electricity bills\\n\")]\n #[test]\n fn test() {\n-  let _copy_debug = CopyDebug(1);\n-  assert!(_copy_debug == CopyDebug(3));\n+  let copy_debug = CopyDebug(1);\n+  assert!(copy_debug == CopyDebug(3));\n }\n \n fn main() {"}]}