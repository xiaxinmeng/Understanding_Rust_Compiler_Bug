{"sha": "5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NzliYThhZjVhMzE1OTFhMTZiOGYwZjQzMDUzZjczZDA3ZmI4Yjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-31T12:03:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-31T12:03:24Z"}, "message": "Merge #4667\n\n4667: Infer labelled breaks correctly r=flodiebold a=robojumper\n\nFixes #4663.\n\nCo-authored-by: robojumper <robojumper@gmail.com>", "tree": {"sha": "2a0f7e55e01edc9edb2c49c3a94d07da172b1b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a0f7e55e01edc9edb2c49c3a94d07da172b1b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe050MCRBK7hj4Ov3rIwAAdHIIADtl4FSQfldu7w4VKYfK7zzE\nVgQOSz8jp07gvWUv5jy49tNyed4xj5EKaAwF/oSycQd8vrAHhiJ8DuEj/aKVRLq6\nUUF9cC0Cn8TwtKv5ztY40mfJJAeA66FSjdYKiBXDOG/zAPCq+1v0gGAqDJj9puG9\n4crgP2SPauvwKbJZFIFUJqtUbwcyvvDcD+QRvuFYrAy3K8Fj8OSfejXw/PRdAumF\nnP37Wfy1HF5+rRDSrCSLJYnjt07INC6xiTFtFmZ2MiyCUYc4PS2VZkcMkzGQsYWp\ngXhspqGSjDLT/L8RbaVYJTMiXnRBJL8Ph4LTttBGd7AZEygsFIEK0LWVVFi8UGg=\n=tcps\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a0f7e55e01edc9edb2c49c3a94d07da172b1b40\nparent d7071eae2cb78547b8345d4c6ba2731a5151c049\nparent cc6ba84c400417af873462364ba5cd4f6b5ab1f6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1590926604 +0000\ncommitter GitHub <noreply@github.com> 1590926604 +0000\n\nMerge #4667\n\n4667: Infer labelled breaks correctly r=flodiebold a=robojumper\n\nFixes #4663.\n\nCo-authored-by: robojumper <robojumper@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "html_url": "https://github.com/rust-lang/rust/commit/5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7071eae2cb78547b8345d4c6ba2731a5151c049", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7071eae2cb78547b8345d4c6ba2731a5151c049", "html_url": "https://github.com/rust-lang/rust/commit/d7071eae2cb78547b8345d4c6ba2731a5151c049"}, {"sha": "cc6ba84c400417af873462364ba5cd4f6b5ab1f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc6ba84c400417af873462364ba5cd4f6b5ab1f6", "html_url": "https://github.com/rust-lang/rust/commit/cc6ba84c400417af873462364ba5cd4f6b5ab1f6"}], "stats": {"total": 209, "additions": 172, "deletions": 37}, "files": [{"sha": "f159f80af05c71caf2d9c3a1fd81b8454c795986", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -134,7 +134,7 @@ impl ExprCollector<'_> {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n     fn empty_block(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None })\n+        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None, label: None })\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n@@ -215,7 +215,16 @@ impl ExprCollector<'_> {\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Loop {\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -230,25 +239,56 @@ impl ExprCollector<'_> {\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n-                            let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n+                            let break_ =\n+                                self.alloc_expr_desugared(Expr::Break { expr: None, label: None });\n                             let arms = vec![\n                                 MatchArm { pat, expr: body, guard: None },\n                                 MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n+                            return self.alloc_expr(\n+                                Expr::Loop {\n+                                    body: match_expr,\n+                                    label: e\n+                                        .label()\n+                                        .and_then(|l| l.lifetime_token())\n+                                        .map(|l| Name::new_lifetime(&l)),\n+                                },\n+                                syntax_ptr,\n+                            );\n                         }\n                     },\n                 };\n \n-                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::While {\n+                        condition,\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::For {\n+                        iterable,\n+                        pat,\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -301,13 +341,16 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(_e) => {\n-                // FIXME: labels\n-                self.alloc_expr(Expr::Continue, syntax_ptr)\n-            }\n+            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n+                Expr::Continue { label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n+                syntax_ptr,\n+            ),\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Break { expr, label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -529,7 +572,8 @@ impl ExprCollector<'_> {\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n+        let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n+        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "e48ff38f96048c18ebe88ae6401c566f55a929b8", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -138,10 +138,10 @@ fn compute_block_scopes(\n fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n     scopes.set_scope(expr, scope);\n     match &body[expr] {\n-        Expr::Block { statements, tail } => {\n+        Expr::Block { statements, tail, .. } => {\n             compute_block_scopes(&statements, *tail, body, scopes, scope);\n         }\n-        Expr::For { iterable, pat, body: body_expr } => {\n+        Expr::For { iterable, pat, body: body_expr, .. } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let scope = scopes.new_scope(scope);\n             scopes.add_bindings(body, scope, *pat);"}, {"sha": "ca49b26d15f857752f633018bdd902dd5b3a1244", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -52,18 +52,22 @@ pub enum Expr {\n     Block {\n         statements: Vec<Statement>,\n         tail: Option<ExprId>,\n+        label: Option<Name>,\n     },\n     Loop {\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     While {\n         condition: ExprId,\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     For {\n         iterable: ExprId,\n         pat: PatId,\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     Call {\n         callee: ExprId,\n@@ -79,9 +83,12 @@ pub enum Expr {\n         expr: ExprId,\n         arms: Vec<MatchArm>,\n     },\n-    Continue,\n+    Continue {\n+        label: Option<Name>,\n+    },\n     Break {\n         expr: Option<ExprId>,\n+        label: Option<Name>,\n     },\n     Return {\n         expr: Option<ExprId>,\n@@ -225,7 +232,7 @@ impl Expr {\n                     f(*else_branch);\n                 }\n             }\n-            Expr::Block { statements, tail } => {\n+            Expr::Block { statements, tail, .. } => {\n                 for stmt in statements {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n@@ -241,8 +248,8 @@ impl Expr {\n                 }\n             }\n             Expr::TryBlock { body } => f(*body),\n-            Expr::Loop { body } => f(*body),\n-            Expr::While { condition, body } => {\n+            Expr::Loop { body, .. } => f(*body),\n+            Expr::While { condition, body, .. } => {\n                 f(*condition);\n                 f(*body);\n             }\n@@ -268,8 +275,8 @@ impl Expr {\n                     f(arm.expr);\n                 }\n             }\n-            Expr::Continue => {}\n-            Expr::Break { expr } | Expr::Return { expr } => {\n+            Expr::Continue { .. } => {}\n+            Expr::Break { expr, .. } | Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n                     f(*expr);\n                 }"}, {"sha": "ea495cb11a2ba736e759a054fd79112bbf20deb6", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -37,6 +37,11 @@ impl Name {\n         Name(Repr::TupleField(idx))\n     }\n \n+    pub fn new_lifetime(lt: &ra_syntax::SyntaxToken) -> Name {\n+        assert!(lt.kind() == ra_syntax::SyntaxKind::LIFETIME);\n+        Name(Repr::Text(lt.text().clone()))\n+    }\n+\n     /// Shortcut to create inline plain text name\n     const fn new_inline_ascii(text: &[u8]) -> Name {\n         Name::new_text(SmolStr::new_inline_from_ascii(text.len(), text))"}, {"sha": "dc77e88e50b2a25af823373efc19bc55e23f59f2", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -219,6 +219,17 @@ struct InferenceContext<'a> {\n struct BreakableContext {\n     pub may_break: bool,\n     pub break_ty: Ty,\n+    pub label: Option<name::Name>,\n+}\n+\n+fn find_breakable<'c>(\n+    ctxs: &'c mut [BreakableContext],\n+    label: Option<&name::Name>,\n+) -> Option<&'c mut BreakableContext> {\n+    match label {\n+        Some(_) => ctxs.iter_mut().rev().find(|ctx| ctx.label.as_ref() == label),\n+        None => ctxs.last_mut(),\n+    }\n }\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "4a98e2debff5f2d3b9345ac62338979f020d1e1c", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -22,8 +22,8 @@ use crate::{\n };\n \n use super::{\n-    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n-    TypeMismatch,\n+    find_breakable, BindingMode, BreakableContext, Diverges, Expectation, InferenceContext,\n+    InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -86,16 +86,20 @@ impl<'a> InferenceContext<'a> {\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n+            Expr::Block { statements, tail, .. } => {\n+                // FIXME: Breakable block inference\n+                self.infer_block(statements, *tail, expected)\n+            }\n             Expr::TryBlock { body } => {\n                 let _inner = self.infer_expr(*body, expected);\n                 // FIXME should be std::result::Result<{inner}, _>\n                 Ty::Unknown\n             }\n-            Expr::Loop { body } => {\n+            Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n                     break_ty: self.table.new_type_var(),\n+                    label: label.clone(),\n                 });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n@@ -110,8 +114,12 @@ impl<'a> InferenceContext<'a> {\n                     Ty::simple(TypeCtor::Never)\n                 }\n             }\n-            Expr::While { condition, body } => {\n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+            Expr::While { condition, body, label } => {\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: Ty::Unknown,\n+                    label: label.clone(),\n+                });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -120,10 +128,14 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n-            Expr::For { iterable, body, pat } => {\n+            Expr::For { iterable, body, pat, label } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: Ty::Unknown,\n+                    label: label.clone(),\n+                });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n@@ -236,23 +248,24 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n-            Expr::Continue => Ty::simple(TypeCtor::Never),\n-            Expr::Break { expr } => {\n+            Expr::Continue { .. } => Ty::simple(TypeCtor::Never),\n+            Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none())\n                 } else {\n                     Ty::unit()\n                 };\n \n-                let last_ty = if let Some(ctxt) = self.breakables.last() {\n-                    ctxt.break_ty.clone()\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let last_ty =\n+                    if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n+                        ctxt.break_ty.clone()\n+                    } else {\n+                        Ty::Unknown\n+                    };\n \n                 let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n \n-                if let Some(ctxt) = self.breakables.last_mut() {\n+                if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                     ctxt.break_ty = merged_type;\n                     ctxt.may_break = true;\n                 } else {"}, {"sha": "88309157b78c08711f39197498c4a4aceda60d65", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -1943,3 +1943,57 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_labelled_break_with_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() {\n+    let _x = || 'outer: loop {\n+        let inner = 'inner: loop {\n+            let i = Default::default();\n+            if (break 'outer i) {\n+                loop { break 'inner 5i8; };\n+            } else if true {\n+                break 'inner 6;\n+            }\n+            break 7;\n+        };\n+        break inner < 8;\n+    };\n+}\n+\"#),\n+        @r###\"\n+    10..336 '{     ...  }; }': ()\n+    20..22 '_x': || -> bool\n+    25..333 '|| 'ou...     }': || -> bool\n+    28..333 ''outer...     }': bool\n+    41..333 '{     ...     }': ()\n+    55..60 'inner': i8\n+    63..301 ''inner...     }': i8\n+    76..301 '{     ...     }': ()\n+    94..95 'i': bool\n+    98..114 'Defaul...efault': {unknown}\n+    98..116 'Defaul...ault()': bool\n+    130..270 'if (br...     }': ()\n+    134..148 'break 'outer i': !\n+    147..148 'i': bool\n+    150..209 '{     ...     }': ()\n+    168..194 'loop {...5i8; }': !\n+    173..194 '{ brea...5i8; }': ()\n+    175..191 'break ...er 5i8': !\n+    188..191 '5i8': i8\n+    215..270 'if tru...     }': ()\n+    218..222 'true': bool\n+    223..270 '{     ...     }': ()\n+    241..255 'break 'inner 6': !\n+    254..255 '6': i8\n+    283..290 'break 7': !\n+    289..290 '7': i8\n+    311..326 'break inner < 8': !\n+    317..322 'inner': i8\n+    317..326 'inner < 8': bool\n+    325..326 '8': i8\n+    \"###\n+    );\n+}"}, {"sha": "cb430ca013528d1833e1349d321d76605b7efb38", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -1081,6 +1081,7 @@ pub struct BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl ast::ModuleItemOwner for BlockExpr {}\n impl BlockExpr {\n+    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }"}, {"sha": "f60f0fb16ce1ad92f3bfc67138cbcfd6922207d1", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5579ba8af5a31591a16b8f0f43053f73d07fb8b8/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=5579ba8af5a31591a16b8f0f43053f73d07fb8b8", "patch": "@@ -1058,7 +1058,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         /// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n         /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct BlockExpr: AttrsOwner, ModuleItemOwner {\n-            T!['{'], statements: [Stmt], Expr, T!['}'],\n+            Label, T!['{'], statements: [Stmt], Expr, T!['}'],\n         }\n \n         /// Return expression."}]}