{"sha": "8872d9057230e46f4bf35af5880cc6095a06e744", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzJkOTA1NzIzMGU0NmY0YmYzNWFmNTg4MGNjNjA5NWEwNmU3NDQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-16T12:16:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-16T12:16:44Z"}, "message": "Rollup merge of #69989 - petrochenkov:nolegacy, r=eddyb,matthewjasper\n\nresolve/hygiene: `macro_rules` are not \"legacy\"\n\nThe \"modern\" vs \"legacy\" naming was introduced by jseyfried during initial implementation of macros 2.0.\nAt this point it's clear that `macro_rules` are not going anywhere and won't be deprecated in the near future.\nSo this PR changes the naming \"legacy\" (when it implies \"macro_rules\") to \"macro_rules\".\nThis should also help people reading this code because it's wasn't obvious that \"legacy\" actually meant \"macro_rules\" in these contexts.\n\nThe most contentious renaming here is probably\n```\nfn modern -> fn normalize_to_macros_2_0\nfn modern_and_legacy -> fn normalize_to_macro_rules\n```\nOther alternatives that I could think of are `normalize_to_opaque`/`normalize_to_semitransparent`, or `strip_non_opaque`/`strip_transparent`, but they seemed less intuitive.\nThe documentation to these functions can be found in `symbol.rs`.\n\nr? @matthewjasper", "tree": {"sha": "66780180c8104b7528546896aa9e7ebec9ce6333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66780180c8104b7528546896aa9e7ebec9ce6333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8872d9057230e46f4bf35af5880cc6095a06e744", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeb24sCRBK7hj4Ov3rIwAAdHIIAByYlf2i6HKCAYMzI/KtN9IX\nK/OBmqSgX+jKQ7ilnAZMdo/tn70S2qTGp+GFLmiTSHYtmTFPsy3bZ5yKz1vc0aWE\nzDyVqa3d2jq2oz4674nN6ktvm1pYsZeJcyjp0mYBoVWXkOjanpVU9Bm8NwvNr+/y\nEMaIwe1R/83hOTx2i/Bh1WiaiQVOE9a2eY0ZwriFgHWROiXiLG+Ua/Y6FthaHi8T\n+9X6VVWtDIAzDyhBlEtG4/J7j2mZpdZIJjw8deE3PPvbHjUA13RyhJh9Klia04WZ\nRE0sk/MQME6WIgKTbRVGllw1CYLPLGtcavM/KVQNZfYBg+YjqO5p11hzwdZC6R8=\n=s8RL\n-----END PGP SIGNATURE-----\n", "payload": "tree 66780180c8104b7528546896aa9e7ebec9ce6333\nparent 8f2482b8012993a7e173f2296880818c1b90a0ca\nparent db638bd123b7b73be691f7b4daebb61469587a27\nauthor Dylan DPC <dylan.dpc@gmail.com> 1584361004 +0100\ncommitter GitHub <noreply@github.com> 1584361004 +0100\n\nRollup merge of #69989 - petrochenkov:nolegacy, r=eddyb,matthewjasper\n\nresolve/hygiene: `macro_rules` are not \"legacy\"\n\nThe \"modern\" vs \"legacy\" naming was introduced by jseyfried during initial implementation of macros 2.0.\nAt this point it's clear that `macro_rules` are not going anywhere and won't be deprecated in the near future.\nSo this PR changes the naming \"legacy\" (when it implies \"macro_rules\") to \"macro_rules\".\nThis should also help people reading this code because it's wasn't obvious that \"legacy\" actually meant \"macro_rules\" in these contexts.\n\nThe most contentious renaming here is probably\n```\nfn modern -> fn normalize_to_macros_2_0\nfn modern_and_legacy -> fn normalize_to_macro_rules\n```\nOther alternatives that I could think of are `normalize_to_opaque`/`normalize_to_semitransparent`, or `strip_non_opaque`/`strip_transparent`, but they seemed less intuitive.\nThe documentation to these functions can be found in `symbol.rs`.\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8872d9057230e46f4bf35af5880cc6095a06e744", "html_url": "https://github.com/rust-lang/rust/commit/8872d9057230e46f4bf35af5880cc6095a06e744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8872d9057230e46f4bf35af5880cc6095a06e744/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f2482b8012993a7e173f2296880818c1b90a0ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2482b8012993a7e173f2296880818c1b90a0ca", "html_url": "https://github.com/rust-lang/rust/commit/8f2482b8012993a7e173f2296880818c1b90a0ca"}, {"sha": "db638bd123b7b73be691f7b4daebb61469587a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/db638bd123b7b73be691f7b4daebb61469587a27", "html_url": "https://github.com/rust-lang/rust/commit/db638bd123b7b73be691f7b4daebb61469587a27"}], "stats": {"total": 471, "additions": 260, "deletions": 211}, "files": [{"sha": "338ff45a4ac7aacce623f7b04eb6185da0ce886d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -3083,7 +3083,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n         // We could use `Ident::eq` here, but we deliberately don't. The name\n         // comparison fails frequently, and we want to avoid the expensive\n-        // `modern()` calls required for the span comparison whenever possible.\n+        // `normalize_to_macros_2_0()` calls required for the span comparison whenever possible.\n         use_name.name == def_name.name\n             && use_name\n                 .span\n@@ -3099,7 +3099,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n-        ident.span.modernize_and_adjust(self.expansion_that_defined(scope));\n+        ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope));\n         ident\n     }\n \n@@ -3109,12 +3109,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         scope: DefId,\n         block: hir::HirId,\n     ) -> (Ident, DefId) {\n-        let scope = match ident.span.modernize_and_adjust(self.expansion_that_defined(scope)) {\n-            Some(actual_expansion) => {\n-                self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n-            }\n-            None => self.parent_module(block),\n-        };\n+        let scope =\n+            match ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope))\n+            {\n+                Some(actual_expansion) => {\n+                    self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n+                }\n+                None => self.parent_module(block),\n+            };\n         (ident, scope)\n     }\n "}, {"sha": "68960ba9fe920c3e9a977b3d610c6d59a5f4f431", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1450,7 +1450,7 @@ impl MacDelimiter {\n pub struct MacroDef {\n     pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n-    pub legacy: bool,\n+    pub macro_rules: bool,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, Eq, PartialEq)]"}, {"sha": "aa2968b3cbe44dc3826869a720b0c25bd7872ffa", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -591,7 +591,7 @@ pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n-    let MacroDef { body, legacy: _ } = macro_def;\n+    let MacroDef { body, macro_rules: _ } = macro_def;\n     visit_mac_args(body, vis);\n }\n "}, {"sha": "aab6aa7c35b0eb96a29f90fe61ef1337435475e3", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -115,7 +115,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             _ => &[],\n         };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.modern()),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -220,8 +220,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n \n-        if let ItemKind::MacroDef(MacroDef { ref body, legacy }) = i.kind {\n-            if !legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n+        if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n+            if !macro_rules || attr::contains_name(&i.attrs, sym::macro_export) {\n                 let hir_id = self.lower_node_id(i.id);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {\n@@ -230,7 +230,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     attrs,\n                     hir_id,\n                     span: i.span,\n-                    ast: MacroDef { body, legacy },\n+                    ast: MacroDef { body, macro_rules },\n                 });\n             } else {\n                 self.non_exported_macro_attrs.extend(attrs.iter().cloned());"}, {"sha": "32b0f0db3589d40e1e575c2ac3dbf5b22a9bdd03", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -153,7 +153,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// against this list to see if it is already in-scope, or if a definition\n     /// needs to be created for it.\n     ///\n-    /// We always store a `modern()` version of the param-name in this\n+    /// We always store a `normalize_to_macros_2_0()` version of the param-name in this\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n@@ -803,14 +803,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             return;\n         }\n \n-        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.modern())) {\n+        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.normalize_to_macros_2_0())) {\n             return;\n         }\n \n         let hir_name = ParamName::Plain(ident);\n \n-        if self.lifetimes_to_define.iter().any(|(_, lt_name)| lt_name.modern() == hir_name.modern())\n-        {\n+        if self.lifetimes_to_define.iter().any(|(_, lt_name)| {\n+            lt_name.normalize_to_macros_2_0() == hir_name.normalize_to_macros_2_0()\n+        }) {\n             return;\n         }\n \n@@ -838,7 +839,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n+            GenericParamKind::Lifetime { .. } => {\n+                Some(ParamName::Plain(param.ident.normalize_to_macros_2_0()))\n+            }\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);"}, {"sha": "2a9847c900e94173add4b5aad763e2cea937412d", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -366,7 +366,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, trait_alias, i.span, \"trait aliases are experimental\");\n             }\n \n-            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+            ast::ItemKind::MacroDef(ast::MacroDef { macro_rules: false, .. }) => {\n                 let msg = \"`macro` is experimental\";\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }"}, {"sha": "b2e6ab7c5e7772a4af5863a4caad505c228ec25b", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1238,7 +1238,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n-                let (kw, has_bang) = if macro_def.legacy {\n+                let (kw, has_bang) = if macro_def.macro_rules {\n                     (\"macro_rules\", true)\n                 } else {\n                     self.print_visibility(&item.vis);"}, {"sha": "99083cca6cb3443a6424aff1eec92335172bc74e", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1024,7 +1024,7 @@ pub enum TransparencyError {\n \n pub fn find_transparency(\n     attrs: &[Attribute],\n-    is_legacy: bool,\n+    macro_rules: bool,\n ) -> (Transparency, Option<TransparencyError>) {\n     let mut transparency = None;\n     let mut error = None;\n@@ -1049,7 +1049,7 @@ pub fn find_transparency(\n             }\n         }\n     }\n-    let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n+    let fallback = if macro_rules { Transparency::SemiTransparent } else { Transparency::Opaque };\n     (transparency.map_or(fallback, |t| t.0), error)\n }\n "}, {"sha": "8c6bfbec902775e8756ac8397c38577a387114d7", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -419,10 +419,10 @@ fn check_nested_occurrences(\n             | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n                 if del.delim == DelimToken::Brace =>\n             {\n-                let legacy = state == NestedMacroState::MacroRulesNotName;\n+                let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n                 let rest =\n-                    check_nested_macro(sess, node_id, legacy, &del.tts, &nested_macros, valid);\n+                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n@@ -493,21 +493,21 @@ fn check_nested_occurrences(\n /// Arguments:\n /// - `sess` is used to emit diagnostics and lints\n /// - `node_id` is used to emit lints\n-/// - `legacy` specifies whether the macro is legacy\n+/// - `macro_rules` specifies whether the macro is `macro_rules`\n /// - `tts` is checked as a list of (LHS) => {RHS}\n /// - `macros` is the stack of outer macros\n /// - `valid` is set in case of errors\n fn check_nested_macro(\n     sess: &ParseSess,\n     node_id: NodeId,\n-    legacy: bool,\n+    macro_rules: bool,\n     tts: &[TokenTree],\n     macros: &Stack<'_, MacroState<'_>>,\n     valid: &mut bool,\n ) -> usize {\n     let n = tts.len();\n     let mut i = 0;\n-    let separator = if legacy { TokenKind::Semi } else { TokenKind::Comma };\n+    let separator = if macro_rules { TokenKind::Semi } else { TokenKind::Comma };\n     loop {\n         // We expect 3 token trees: `(LHS) => {RHS}`. The separator is checked after.\n         if i + 2 >= n\n@@ -522,7 +522,7 @@ fn check_nested_macro(\n         let mut binders = Binders::default();\n         check_binders(sess, node_id, lhs, macros, &mut binders, &Stack::Empty, valid);\n         check_occurrences(sess, node_id, rhs, macros, &binders, &Stack::Empty, valid);\n-        // Since the last semicolon is optional for legacy macros and decl_macro are not terminated,\n+        // Since the last semicolon is optional for `macro_rules` macros and decl_macro are not terminated,\n         // we increment our checked position by how many token trees we already checked (the 3\n         // above) before checking for the separator.\n         i += 3;"}, {"sha": "3cad3ff55d91018517d7fd5562922b94870fa12e", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -350,8 +350,8 @@ pub fn compile_declarative_macro(\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n-    let (is_legacy, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(macro_def) => (macro_def.legacy, macro_def.body.inner_tokens()),\n+    let (macro_rules, body) = match &def.kind {\n+        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.inner_tokens()),\n         _ => unreachable!(),\n     };\n \n@@ -370,7 +370,7 @@ pub fn compile_declarative_macro(\n                     mbe::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n                 ],\n                 separator: Some(Token::new(\n-                    if is_legacy { token::Semi } else { token::Comma },\n+                    if macro_rules { token::Semi } else { token::Comma },\n                     def.span,\n                 )),\n                 kleene: mbe::KleeneToken::new(mbe::KleeneOp::OneOrMore, def.span),\n@@ -382,7 +382,7 @@ pub fn compile_declarative_macro(\n             DelimSpan::dummy(),\n             Lrc::new(mbe::SequenceRepetition {\n                 tts: vec![mbe::TokenTree::token(\n-                    if is_legacy { token::Semi } else { token::Comma },\n+                    if macro_rules { token::Semi } else { token::Comma },\n                     def.span,\n                 )],\n                 separator: None,\n@@ -456,7 +456,7 @@ pub fn compile_declarative_macro(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, is_legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) => {\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value))"}, {"sha": "0ef35b184e17f3f3cde776a46be9e3fb6c1a59e2", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -79,9 +79,9 @@ impl ParamName {\n         }\n     }\n \n-    pub fn modern(&self) -> ParamName {\n+    pub fn normalize_to_macros_2_0(&self) -> ParamName {\n         match *self {\n-            ParamName::Plain(ident) => ParamName::Plain(ident.modern()),\n+            ParamName::Plain(ident) => ParamName::Plain(ident.normalize_to_macros_2_0()),\n             param_name => param_name,\n         }\n     }\n@@ -151,9 +151,11 @@ impl LifetimeName {\n         self == &LifetimeName::Static\n     }\n \n-    pub fn modern(&self) -> LifetimeName {\n+    pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Param(param_name) => LifetimeName::Param(param_name.modern()),\n+            LifetimeName::Param(param_name) => {\n+                LifetimeName::Param(param_name.normalize_to_macros_2_0())\n+            }\n             lifetime_name => lifetime_name,\n         }\n     }"}, {"sha": "f56bef031a748b74acc4c228a19fa9b0026bc187", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1088,9 +1088,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> =\n-                    items.iter().map(|iiref| iiref.ident.modern()).collect();\n+                    items.iter().map(|iiref| iiref.ident.normalize_to_macros_2_0()).collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.ident.modern()) {\n+                    if overridden_methods.contains(&method.ident.normalize_to_macros_2_0()) {\n                         continue;\n                     }\n "}, {"sha": "e927bcd07e2cd2ed1a4465ff2207664cd910e32e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1260,7 +1260,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_token.span));\n-        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, macro_rules: false })))\n     }\n \n     /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n@@ -1270,7 +1270,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(2, |t| t.is_ident())\n     }\n \n-    /// Parses a legacy `macro_rules! foo { ... }` declarative macro.\n+    /// Parses a `macro_rules! foo { ... }` declarative macro.\n     fn parse_item_macro_rules(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n         self.expect_keyword(kw::MacroRules)?; // `macro_rules`\n         self.expect(&token::Not)?; // `!`\n@@ -1280,7 +1280,7 @@ impl<'a> Parser<'a> {\n         self.eat_semi_for_macro_if_needed(&body);\n         self.complain_if_pub_macro(vis, true);\n \n-        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true })))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, macro_rules: true })))\n     }\n \n     /// Item macro invocations or `macro_rules!` definitions need inherited visibility."}, {"sha": "108a8006409e1b367beab318703fb5ada141232e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -920,7 +920,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        if attr::find_transparency(&md.attrs, md.ast.legacy).0 != Transparency::Opaque {\n+        if attr::find_transparency(&md.attrs, md.ast.macro_rules).0 != Transparency::Opaque {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return;\n         }"}, {"sha": "ce3b1233a74737d94df369fd6caa8ab9c5bad79a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -7,7 +7,7 @@\n \n use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n-use crate::macros::{LegacyBinding, LegacyScope};\n+use crate::macros::{MacroRulesBinding, MacroRulesScope};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n use crate::{\n@@ -165,11 +165,11 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n-    ) -> LegacyScope<'a> {\n+    ) -> MacroRulesScope<'a> {\n         collect_definitions(&mut self.definitions, fragment, parent_scope.expansion);\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n-        visitor.parent_scope.legacy\n+        visitor.parent_scope.macro_rules\n     }\n \n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n@@ -624,7 +624,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                let used = self.process_legacy_macro_imports(item, module);\n+                let used = self.process_macro_use_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n                 let import = self.r.arenas.alloc_import(Import {\n@@ -645,7 +645,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.potentially_unused_imports.push(import);\n                 let imported_binding = self.r.import(binding, import);\n                 if ptr::eq(parent, self.r.graph_root) {\n-                    if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n+                    if let Some(entry) = self.r.extern_prelude.get(&ident.normalize_to_macros_2_0())\n+                    {\n                         if expansion != ExpnId::root()\n                             && orig_name.is_some()\n                             && entry.extern_crate_item.is_none()\n@@ -656,10 +657,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n                     }\n                     let entry =\n-                        self.r.extern_prelude.entry(ident.modern()).or_insert(ExternPreludeEntry {\n-                            extern_crate_item: None,\n-                            introduced_by_item: true,\n-                        });\n+                        self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert(\n+                            ExternPreludeEntry {\n+                                extern_crate_item: None,\n+                                introduced_by_item: true,\n+                            },\n+                        );\n                     entry.extern_crate_item = Some(imported_binding);\n                     if orig_name.is_some() {\n                         entry.introduced_by_item = true;\n@@ -913,7 +916,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn legacy_import_macro(\n+    fn add_macro_use_binding(\n         &mut self,\n         name: ast::Name,\n         binding: &'a NameBinding<'a>,\n@@ -929,7 +932,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n+    fn process_macro_use_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n@@ -1004,7 +1007,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module.for_each_child(self, |this, ident, ns, binding| {\n                 if ns == MacroNS {\n                     let imported_binding = this.r.import(binding, import);\n-                    this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+                    this.add_macro_use_binding(ident.name, imported_binding, span, allow_shadowing);\n                 }\n             });\n         } else {\n@@ -1021,7 +1024,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     let import = macro_use_import(self, ident.span);\n                     self.r.potentially_unused_imports.push(import);\n                     let imported_binding = self.r.import(binding, import);\n-                    self.legacy_import_macro(\n+                    self.add_macro_use_binding(\n                         ident.name,\n                         imported_binding,\n                         ident.span,\n@@ -1060,15 +1063,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> MacroRulesScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        LegacyScope::Invocation(invoc_id)\n+        MacroRulesScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1095,20 +1098,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n+    fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n-        let (ext, ident, span, is_legacy) = match &item.kind {\n+        let (ext, ident, span, macro_rules) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n-                (ext, item.ident, item.span, def.legacy)\n+                (ext, item.ident, item.span, def.macro_rules)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n                     self.r.proc_macro_stubs.insert(item.id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n                 }\n-                None => return parent_scope.legacy,\n+                None => return parent_scope.macro_rules,\n             },\n             _ => unreachable!(),\n         };\n@@ -1118,8 +1121,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         self.r.macro_map.insert(def_id, ext);\n         self.r.local_macro_def_scopes.insert(item.id, parent_scope.module);\n \n-        if is_legacy {\n-            let ident = ident.modern();\n+        if macro_rules {\n+            let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n@@ -1137,8 +1140,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, item.id, span);\n             }\n-            LegacyScope::Binding(self.r.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: parent_scope.legacy,\n+            MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n+                parent_macro_rules_scope: parent_scope.macro_rules,\n                 binding,\n                 ident,\n             }))\n@@ -1149,7 +1152,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_unused_macro(ident, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n-            self.parent_scope.legacy\n+            self.parent_scope.macro_rules\n         }\n     }\n }\n@@ -1174,29 +1177,29 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.kind {\n             ItemKind::MacroDef(..) => {\n-                self.parent_scope.legacy = self.define_macro(item);\n+                self.parent_scope.macro_rules = self.define_macro(item);\n                 return;\n             }\n             ItemKind::MacCall(..) => {\n-                self.parent_scope.legacy = self.visit_invoc(item.id);\n+                self.parent_scope.macro_rules = self.visit_invoc(item.id);\n                 return;\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n         let orig_current_module = self.parent_scope.module;\n-        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        let orig_current_macro_rules_scope = self.parent_scope.macro_rules;\n         self.build_reduced_graph_for_item(item);\n         visit::walk_item(self, item);\n         self.parent_scope.module = orig_current_module;\n         if !macro_use {\n-            self.parent_scope.legacy = orig_current_legacy_scope;\n+            self.parent_scope.macro_rules = orig_current_macro_rules_scope;\n         }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::MacCall(..) = stmt.kind {\n-            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n+            self.parent_scope.macro_rules = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1214,11 +1217,11 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_block(&mut self, block: &'b Block) {\n         let orig_current_module = self.parent_scope.module;\n-        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        let orig_current_macro_rules_scope = self.parent_scope.macro_rules;\n         self.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.parent_scope.module = orig_current_module;\n-        self.parent_scope.legacy = orig_current_legacy_scope;\n+        self.parent_scope.macro_rules = orig_current_macro_rules_scope;\n     }\n \n     fn visit_assoc_item(&mut self, item: &'b AssocItem, ctxt: AssocCtxt) {"}, {"sha": "63fbc800ff7067fb280615202ddb4c92f4c2a2c1", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -21,7 +21,9 @@ use rustc_span::{BytePos, MultiSpan, Span};\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{\n+    BindingError, CrateLint, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot,\n+};\n use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n@@ -498,12 +500,12 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                 }\n-                Scope::MacroRules(legacy_scope) => {\n-                    if let LegacyScope::Binding(legacy_binding) = legacy_scope {\n-                        let res = legacy_binding.binding.res();\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    if let MacroRulesScope::Binding(macro_rules_binding) = macro_rules_scope {\n+                        let res = macro_rules_binding.binding.res();\n                         if filter_fn(res) {\n                             suggestions\n-                                .push(TypoSuggestion::from_res(legacy_binding.ident.name, res))\n+                                .push(TypoSuggestion::from_res(macro_rules_binding.ident.name, res))\n                         }\n                     }\n                 }\n@@ -756,7 +758,7 @@ impl<'a> Resolver<'a> {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n             err.span_note(ident.span, &msg);\n         }\n-        if self.macro_names.contains(&ident.modern()) {\n+        if self.macro_names.contains(&ident.normalize_to_macros_2_0()) {\n             err.help(\"have you added the `#[macro_use]` on the module/import?\");\n         }\n     }"}, {"sha": "681c039211892e3ee01f214572aa259ab73ac445", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -416,7 +416,8 @@ impl<'a> Resolver<'a> {\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n             let tmp_parent_scope;\n-            let (mut adjusted_parent_scope, mut ident) = (parent_scope, ident.modern());\n+            let (mut adjusted_parent_scope, mut ident) =\n+                (parent_scope, ident.normalize_to_macros_2_0());\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope ="}, {"sha": "867aa8c63216839d8714821b412589d0e1bb3eaa", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -935,7 +935,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 _ => unreachable!(),\n             };\n \n-            let ident = param.ident.modern();\n+            let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n             if seen_bindings.contains_key(&ident) {\n@@ -1464,7 +1464,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n         // (We must not add it if it's in the bindings map because that breaks the assumptions\n         // later passes make about or-patterns.)\n-        let ident = ident.modern_and_legacy();\n+        let ident = ident.normalize_to_macro_rules();\n \n         let mut bound_iter = bindings.iter().filter(|(_, set)| set.contains(&ident));\n         // Already bound in a product pattern? e.g. `(a, a)` which is not allowed.\n@@ -1873,7 +1873,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             }\n             self.with_label_rib(NormalRibKind, |this| {\n-                let ident = label.ident.modern_and_legacy();\n+                let ident = label.ident.normalize_to_macro_rules();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });\n@@ -1949,7 +1949,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n                 let node_id = self.search_label(label.ident, |rib, ident| {\n-                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                    rib.bindings.get(&ident.normalize_to_macro_rules()).cloned()\n                 });\n                 match node_id {\n                     None => {\n@@ -2115,7 +2115,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        ident.span = ident.span.modern();\n+        ident.span = ident.span.normalize_to_macros_2_0();\n         let mut search_module = self.parent_scope.module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);"}, {"sha": "c015841cdc52b3154cc4401fc564efa845abec70", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -62,7 +62,7 @@ impl RegionExt for Region {\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n@@ -73,7 +73,7 @@ impl RegionExt for Region {\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -1174,7 +1174,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n+                    if let Some(def) =\n+                        lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n+                    {\n                         let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -1253,7 +1255,7 @@ fn object_lifetime_defaults_for_item(\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                set.insert(lifetime.name.modern());\n+                set.insert(lifetime.name.normalize_to_macros_2_0());\n             }\n         }\n     }\n@@ -1791,7 +1793,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n-                            if let Some(&def) = lifetimes.get(&param_name.modern()) {\n+                            if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n+                            {\n                                 break Some(def.shifted(late_depth));\n                             }\n                         }\n@@ -2542,7 +2545,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let lifetimes: Vec<_> = params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => Some((param, param.name.modern())),\n+                GenericParamKind::Lifetime { .. } => {\n+                    Some((param, param.name.normalize_to_macros_2_0()))\n+                }\n                 _ => None,\n             })\n             .collect();\n@@ -2659,7 +2664,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n-                    if let Some(&def) = lifetimes.get(&param.name.modern()) {\n+                    if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n                         let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -2797,7 +2802,7 @@ fn insert_late_bound_lifetimes(\n                 // `'a: 'b` means both `'a` and `'b` are referenced\n                 appears_in_where_clause\n                     .regions\n-                    .insert(hir::LifetimeName::Param(param.name.modern()));\n+                    .insert(hir::LifetimeName::Param(param.name.normalize_to_macros_2_0()));\n             }\n         }\n     }\n@@ -2819,7 +2824,7 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let lt_name = hir::LifetimeName::Param(param.name.modern());\n+        let lt_name = hir::LifetimeName::Param(param.name.normalize_to_macros_2_0());\n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&lt_name) {\n             continue;\n@@ -2883,7 +2888,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.modern());\n+            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n         }\n     }\n \n@@ -2900,7 +2905,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.modern());\n+            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n         }\n     }\n }"}, {"sha": "05d0f2064503364118d708552a2373385b85fc37", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -58,7 +58,7 @@ use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_ne\n use diagnostics::{ImportSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n-use macros::{LegacyBinding, LegacyScope};\n+use macros::{MacroRulesBinding, MacroRulesScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -94,7 +94,7 @@ impl Determinacy {\n enum Scope<'a> {\n     DeriveHelpers(ExpnId),\n     DeriveHelpersCompat,\n-    MacroRules(LegacyScope<'a>),\n+    MacroRules(MacroRulesScope<'a>),\n     CrateRoot,\n     Module(Module<'a>),\n     RegisteredAttrs,\n@@ -127,15 +127,20 @@ enum ScopeSet {\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n-    legacy: LegacyScope<'a>,\n+    macro_rules: MacroRulesScope<'a>,\n     derives: &'a [ast::Path],\n }\n \n impl<'a> ParentScope<'a> {\n     /// Creates a parent scope with the passed argument used as the module scope component,\n     /// and other scope components set to default empty values.\n     pub fn module(module: Module<'a>) -> ParentScope<'a> {\n-        ParentScope { module, expansion: ExpnId::root(), legacy: LegacyScope::Empty, derives: &[] }\n+        ParentScope {\n+            module,\n+            expansion: ExpnId::root(),\n+            macro_rules: MacroRulesScope::Empty,\n+            derives: &[],\n+        }\n     }\n }\n \n@@ -419,7 +424,7 @@ impl ModuleKind {\n /// program) if all but one of them come from glob imports.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n struct BindingKey {\n-    /// The identifier for the binding, aways the `modern` version of the\n+    /// The identifier for the binding, aways the `normalize_to_macros_2_0` version of the\n     /// identifier.\n     ident: Ident,\n     ns: Namespace,\n@@ -613,7 +618,7 @@ enum AmbiguityKind {\n     Import,\n     BuiltinAttr,\n     DeriveHelper,\n-    LegacyVsModern,\n+    MacroRulesVsModularized,\n     GlobVsOuter,\n     GlobVsGlob,\n     GlobVsExpanded,\n@@ -626,7 +631,9 @@ impl AmbiguityKind {\n             AmbiguityKind::Import => \"name vs any other name during import resolution\",\n             AmbiguityKind::BuiltinAttr => \"built-in attribute vs any other name\",\n             AmbiguityKind::DeriveHelper => \"derive helper attribute vs any other name\",\n-            AmbiguityKind::LegacyVsModern => \"`macro_rules` vs non-`macro_rules` from other module\",\n+            AmbiguityKind::MacroRulesVsModularized => {\n+                \"`macro_rules` vs non-`macro_rules` from other module\"\n+            }\n             AmbiguityKind::GlobVsOuter => {\n                 \"glob import vs any other name from outer scope during import/macro resolution\"\n             }\n@@ -930,9 +937,9 @@ pub struct Resolver<'a> {\n     /// Parent scopes in which the macros were invoked.\n     /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n     invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n-    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// `macro_rules` scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n-    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n+    output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScope<'a>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n@@ -965,7 +972,7 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     imports: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    macro_rules_bindings: arena::TypedArena<MacroRulesBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n }\n \n@@ -989,8 +996,11 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n-        self.legacy_bindings.alloc(binding)\n+    fn alloc_macro_rules_binding(\n+        &'a self,\n+        binding: MacroRulesBinding<'a>,\n+    ) -> &'a MacroRulesBinding<'a> {\n+        self.macro_rules_bindings.alloc(binding)\n     }\n     fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n         self.ast_paths.alloc_from_iter(paths.iter().cloned())\n@@ -1210,7 +1220,7 @@ impl<'a> Resolver<'a> {\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocation_parent_scopes,\n-            output_legacy_scopes: Default::default(),\n+            output_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n@@ -1352,7 +1362,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n-        let ident = ident.modern();\n+        let ident = ident.normalize_to_macros_2_0();\n         let disambiguator = if ident.name == kw::Underscore {\n             self.underscore_disambiguator += 1;\n             self.underscore_disambiguator\n@@ -1403,7 +1413,7 @@ impl<'a> Resolver<'a> {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,\n             // but not introduce it, as used if they are accessed from lexical scope.\n             if is_lexical_scope {\n-                if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                if let Some(entry) = self.extern_prelude.get(&ident.normalize_to_macros_2_0()) {\n                     if let Some(crate_item) = entry.extern_crate_item {\n                         if ptr::eq(used_binding, crate_item) && !entry.introduced_by_item {\n                             return;\n@@ -1465,7 +1475,7 @@ impl<'a> Resolver<'a> {\n         //    derives (you need to resolve the derive first to add helpers into scope), but they\n         //    should be available before the derive is expanded for compatibility.\n         //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n         //    priority than prelude macros, but create ambiguities with macros in modules.\n         // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled). Have higher priority than prelude macros, but create\n@@ -1490,7 +1500,7 @@ impl<'a> Resolver<'a> {\n             TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n-        let mut ident = ident.modern();\n+        let mut ident = ident.normalize_to_macros_2_0();\n         let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n@@ -1530,16 +1540,18 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::DeriveHelpers(..) => Scope::DeriveHelpersCompat,\n-                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.legacy),\n-                Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                    LegacyScope::Binding(binding) => Scope::MacroRules(binding.parent_legacy_scope),\n-                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n-                        self.output_legacy_scopes\n+                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n+                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope {\n+                    MacroRulesScope::Binding(binding) => {\n+                        Scope::MacroRules(binding.parent_macro_rules_scope)\n+                    }\n+                    MacroRulesScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_macro_rules_scopes\n                             .get(&invoc_id)\n                             .cloned()\n-                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy),\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].macro_rules),\n                     ),\n-                    LegacyScope::Empty => Scope::Module(module),\n+                    MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1610,27 +1622,27 @@ impl<'a> Resolver<'a> {\n         if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n-        let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n+        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n             let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n-            let modern_span = ident.span.modern();\n-            (modern_span, modern_span)\n+            let normalized_span = ident.span.normalize_to_macros_2_0();\n+            (normalized_span, normalized_span)\n         } else {\n-            (ident.span.modern_and_legacy(), ident.span.modern())\n+            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n         };\n         ident.span = general_span;\n-        let modern_ident = Ident { span: modern_span, ..ident };\n+        let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n         let record_used = record_used_id.is_some();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n-            // (modern hygiene) or local variables (legacy hygiene).\n-            let rib_ident = if ribs[i].kind.contains_params() { modern_ident } else { ident };\n+            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n+            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n             if let Some(res) = ribs[i].bindings.get(&rib_ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n@@ -1673,7 +1685,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident = modern_ident;\n+        ident = normalized_ident;\n         let mut poisoned = None;\n         loop {\n             let opt_module = if let Some(node_id) = record_used_id {\n@@ -1842,14 +1854,14 @@ impl<'a> Resolver<'a> {\n         let mut adjusted_parent_scope = parent_scope;\n         match module {\n             ModuleOrUniformRoot::Module(m) => {\n-                if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n+                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n                         ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.modernize_and_adjust(ExpnId::root());\n+                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n             }\n             ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n                 // No adjustments\n@@ -1872,14 +1884,14 @@ impl<'a> Resolver<'a> {\n         let mark = if ident.name == kw::DollarCrate {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n-            // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n+            // as described in `SyntaxContext::apply_mark`, so we ignore prepended opaque marks.\n             // FIXME: This is only a guess and it doesn't work correctly for `macro_rules!`\n             // definitions actually produced by `macro` and `macro` definitions produced by\n             // `macro_rules!`, but at least such configurations are not stable yet.\n-            ctxt = ctxt.modern_and_legacy();\n+            ctxt = ctxt.normalize_to_macro_rules();\n             let mut iter = ctxt.marks().into_iter().rev().peekable();\n             let mut result = None;\n-            // Find the last modern mark from the end if it exists.\n+            // Find the last opaque mark from the end if it exists.\n             while let Some(&(mark, transparency)) = iter.peek() {\n                 if transparency == Transparency::Opaque {\n                     result = Some(mark);\n@@ -1888,7 +1900,7 @@ impl<'a> Resolver<'a> {\n                     break;\n                 }\n             }\n-            // Then find the last legacy mark from the end if it exists.\n+            // Then find the last semi-transparent mark from the end if it exists.\n             for (mark, transparency) in iter {\n                 if transparency == Transparency::SemiTransparent {\n                     result = Some(mark);\n@@ -1898,7 +1910,7 @@ impl<'a> Resolver<'a> {\n             }\n             result\n         } else {\n-            ctxt = ctxt.modern();\n+            ctxt = ctxt.normalize_to_macros_2_0();\n             ctxt.adjust(ExpnId::root())\n         };\n         let module = match mark {\n@@ -1910,7 +1922,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n         let mut module = self.get_module(module.normal_ancestor_id);\n-        while module.span.ctxt().modern() != *ctxt {\n+        while module.span.ctxt().normalize_to_macros_2_0() != *ctxt {\n             let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n             module = self.get_module(parent.normal_ancestor_id);\n         }\n@@ -1978,7 +1990,7 @@ impl<'a> Resolver<'a> {\n \n             if ns == TypeNS {\n                 if allow_super && name == kw::Super {\n-                    let mut ctxt = ident.span.ctxt().modern();\n+                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                     let self_module = match i {\n                         0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n                         _ => match module {\n@@ -2004,7 +2016,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 if i == 0 {\n                     if name == kw::SelfLower {\n-                        let mut ctxt = ident.span.ctxt().modern();\n+                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, parent_scope.module),\n                         ));\n@@ -2413,21 +2425,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn disambiguate_legacy_vs_modern(\n+    fn disambiguate_macro_rules_vs_modularized(\n         &self,\n-        legacy: &'a NameBinding<'a>,\n-        modern: &'a NameBinding<'a>,\n+        macro_rules: &'a NameBinding<'a>,\n+        modularized: &'a NameBinding<'a>,\n     ) -> bool {\n-        // Some non-controversial subset of ambiguities \"modern macro name\" vs \"macro_rules\"\n+        // Some non-controversial subset of ambiguities \"modularized macro name\" vs \"macro_rules\"\n         // is disambiguated to mitigate regressions from macro modularization.\n         // Scoping for `macro_rules` behaves like scoping for `let` at module level, in general.\n         match (\n-            self.binding_parent_modules.get(&PtrKey(legacy)),\n-            self.binding_parent_modules.get(&PtrKey(modern)),\n+            self.binding_parent_modules.get(&PtrKey(macro_rules)),\n+            self.binding_parent_modules.get(&PtrKey(modularized)),\n         ) {\n-            (Some(legacy), Some(modern)) => {\n-                legacy.normal_ancestor_id == modern.normal_ancestor_id\n-                    && modern.is_ancestor_of(legacy)\n+            (Some(macro_rules), Some(modularized)) => {\n+                macro_rules.normal_ancestor_id == modularized.normal_ancestor_id\n+                    && modularized.is_ancestor_of(macro_rules)\n             }\n             _ => false,\n         }\n@@ -2757,7 +2769,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n             return None;\n         }\n-        self.extern_prelude.get(&ident.modern()).cloned().and_then(|entry| {\n+        self.extern_prelude.get(&ident.normalize_to_macros_2_0()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n                 if !speculative && entry.introduced_by_item {\n                     self.record_use(ident, TypeNS, binding, false);"}, {"sha": "058ead95f50bd7494f790cbb85aac3c7f8893909", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -33,26 +33,26 @@ use std::{mem, ptr};\n type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n-/// Not modularized, can shadow previous legacy bindings, etc.\n+/// Not modularized, can shadow previous `macro_rules` bindings, etc.\n #[derive(Debug)]\n-pub struct LegacyBinding<'a> {\n+pub struct MacroRulesBinding<'a> {\n     crate binding: &'a NameBinding<'a>,\n-    /// Legacy scope into which the `macro_rules` item was planted.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n+    /// `macro_rules` scope into which the `macro_rules` item was planted.\n+    crate parent_macro_rules_scope: MacroRulesScope<'a>,\n     crate ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n /// This starts at the macro's definition and ends at the end of the macro's parent\n /// module (named or unnamed), or even further if it escapes with `#[macro_use]`.\n-/// Some macro invocations need to introduce legacy scopes too because they\n+/// Some macro invocations need to introduce `macro_rules` scopes too because they\n /// can potentially expand into macro definitions.\n #[derive(Copy, Clone, Debug)]\n-pub enum LegacyScope<'a> {\n+pub enum MacroRulesScope<'a> {\n     /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n     /// The scope introduced by a `macro_rules!` macro definition.\n-    Binding(&'a LegacyBinding<'a>),\n+    Binding(&'a MacroRulesBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n     Invocation(ExpnId),\n@@ -159,8 +159,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n-        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+        let output_macro_rules_scope = self.build_reduced_graph(fragment, parent_scope);\n+        self.output_macro_rules_scopes.insert(expansion, output_macro_rules_scope);\n \n         parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n@@ -258,7 +258,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n                             force,\n                         ) {\n                             Ok((Some(ext), _)) => {\n-                                let span = path.segments.last().unwrap().ident.span.modern();\n+                                let span = path\n+                                    .segments\n+                                    .last()\n+                                    .unwrap()\n+                                    .ident\n+                                    .span\n+                                    .normalize_to_macros_2_0();\n                                 helper_attrs.extend(\n                                     ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n                                 );\n@@ -608,12 +614,14 @@ impl<'a> Resolver<'a> {\n                         }\n                         result\n                     }\n-                    Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                        LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident => {\n-                            Ok((legacy_binding.binding, Flags::MACRO_RULES))\n+                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope {\n+                        MacroRulesScope::Binding(macro_rules_binding)\n+                            if ident == macro_rules_binding.ident =>\n+                        {\n+                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n                         }\n-                        LegacyScope::Invocation(invoc_id)\n-                            if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                        MacroRulesScope::Invocation(invoc_id)\n+                            if !this.output_macro_rules_scopes.contains_key(&invoc_id) =>\n                         {\n                             Err(Determinacy::Undetermined)\n                         }\n@@ -759,16 +767,18 @@ impl<'a> Resolver<'a> {\n                                     Some(AmbiguityKind::DeriveHelper)\n                                 } else if innermost_flags.contains(Flags::MACRO_RULES)\n                                     && flags.contains(Flags::MODULE)\n-                                    && !this\n-                                        .disambiguate_legacy_vs_modern(innermost_binding, binding)\n+                                    && !this.disambiguate_macro_rules_vs_modularized(\n+                                        innermost_binding,\n+                                        binding,\n+                                    )\n                                     || flags.contains(Flags::MACRO_RULES)\n                                         && innermost_flags.contains(Flags::MODULE)\n-                                        && !this.disambiguate_legacy_vs_modern(\n+                                        && !this.disambiguate_macro_rules_vs_modularized(\n                                             binding,\n                                             innermost_binding,\n                                         )\n                                 {\n-                                    Some(AmbiguityKind::LegacyVsModern)\n+                                    Some(AmbiguityKind::MacroRulesVsModularized)\n                                 } else if innermost_binding.is_glob_import() {\n                                     Some(AmbiguityKind::GlobVsOuter)\n                                 } else if innermost_binding"}, {"sha": "e073d735a1225a3db7194125b30ebca7ac2533c6", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -201,11 +201,11 @@ impl HygieneData {\n         true\n     }\n \n-    fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+    fn normalize_to_macros_2_0(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n \n-    fn modern_and_legacy(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+    fn normalize_to_macro_rules(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent\n     }\n \n@@ -266,9 +266,9 @@ impl HygieneData {\n \n         let call_site_ctxt = self.expn_data(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n-            self.modern(call_site_ctxt)\n+            self.normalize_to_macros_2_0(call_site_ctxt)\n         } else {\n-            self.modern_and_legacy(call_site_ctxt)\n+            self.normalize_to_macro_rules(call_site_ctxt)\n         };\n \n         if call_site_ctxt == SyntaxContext::root() {\n@@ -491,10 +491,10 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.adjust(self, expn_id))\n     }\n \n-    /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n-    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+    /// Like `SyntaxContext::adjust`, but also normalizes `self` to macros 2.0.\n+    pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| {\n-            *self = data.modern(*self);\n+            *self = data.normalize_to_macros_2_0(*self);\n             data.adjust(self, expn_id)\n         })\n     }\n@@ -527,7 +527,7 @@ impl SyntaxContext {\n     pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             let mut scope = None;\n-            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut glob_ctxt = data.normalize_to_macros_2_0(glob_span.ctxt());\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 scope = Some(data.remove_mark(&mut glob_ctxt).0);\n                 if data.remove_mark(self).0 != scope.unwrap() {\n@@ -558,7 +558,7 @@ impl SyntaxContext {\n                 return None;\n             }\n \n-            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut glob_ctxt = data.normalize_to_macros_2_0(glob_span.ctxt());\n             let mut marks = Vec::new();\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n@@ -574,20 +574,20 @@ impl SyntaxContext {\n \n     pub fn hygienic_eq(self, other: SyntaxContext, expn_id: ExpnId) -> bool {\n         HygieneData::with(|data| {\n-            let mut self_modern = data.modern(self);\n-            data.adjust(&mut self_modern, expn_id);\n-            self_modern == data.modern(other)\n+            let mut self_normalized = data.normalize_to_macros_2_0(self);\n+            data.adjust(&mut self_normalized, expn_id);\n+            self_normalized == data.normalize_to_macros_2_0(other)\n         })\n     }\n \n     #[inline]\n-    pub fn modern(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.modern(self))\n+    pub fn normalize_to_macros_2_0(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.normalize_to_macros_2_0(self))\n     }\n \n     #[inline]\n-    pub fn modern_and_legacy(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.modern_and_legacy(self))\n+    pub fn normalize_to_macro_rules(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.normalize_to_macro_rules(self))\n     }\n \n     #[inline]"}, {"sha": "caa50e9a41c0c0998c3c31e4518fbd295d313e38", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -548,9 +548,9 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+    pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.modernize_and_adjust(expn_id);\n+        let mark = span.ctxt.normalize_to_macros_2_0_and_adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n@@ -576,15 +576,15 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn modern(self) -> Span {\n+    pub fn normalize_to_macros_2_0(self) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.modern())\n+        span.with_ctxt(span.ctxt.normalize_to_macros_2_0())\n     }\n \n     #[inline]\n-    pub fn modern_and_legacy(self) -> Span {\n+    pub fn normalize_to_macro_rules(self) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.modern_and_legacy())\n+        span.with_ctxt(span.ctxt.normalize_to_macro_rules())\n     }\n }\n "}, {"sha": "5760e1d004e038734d200bc76f8e32716d1663dd", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -853,21 +853,21 @@ impl Ident {\n     }\n \n     /// \"Normalize\" ident for use in comparisons using \"item hygiene\".\n-    /// Identifiers with same string value become same if they came from the same \"modern\" macro\n+    /// Identifiers with same string value become same if they came from the same macro 2.0 macro\n     /// (e.g., `macro` item, but not `macro_rules` item) and stay different if they came from\n-    /// different \"modern\" macros.\n+    /// different macro 2.0 macros.\n     /// Technically, this operation strips all non-opaque marks from ident's syntactic context.\n-    pub fn modern(self) -> Ident {\n-        Ident::new(self.name, self.span.modern())\n+    pub fn normalize_to_macros_2_0(self) -> Ident {\n+        Ident::new(self.name, self.span.normalize_to_macros_2_0())\n     }\n \n     /// \"Normalize\" ident for use in comparisons using \"local variable hygiene\".\n     /// Identifiers with same string value become same if they came from the same non-transparent\n     /// macro (e.g., `macro` or `macro_rules!` items) and stay different if they came from different\n     /// non-transparent macros.\n     /// Technically, this operation strips all transparent marks from ident's syntactic context.\n-    pub fn modern_and_legacy(self) -> Ident {\n-        Ident::new(self.name, self.span.modern_and_legacy())\n+    pub fn normalize_to_macro_rules(self) -> Ident {\n+        Ident::new(self.name, self.span.normalize_to_macro_rules())\n     }\n \n     /// Convert the name to a `SymbolStr`. This is a slowish operation because"}, {"sha": "b273efa78276d562903069caed48745f304c7919", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1441,12 +1441,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n \n-        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n         let assoc_ty = tcx\n             .associated_items(candidate.def_id())\n             .filter_by_name_unhygienic(assoc_ident.name)\n-            .find(|i| i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident)\n+            .find(|i| {\n+                i.kind == ty::AssocKind::Type && i.ident.normalize_to_macros_2_0() == assoc_ident\n+            })\n             .expect(\"missing associated type\");\n \n         if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n@@ -2298,12 +2300,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n \n-        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n         let item = tcx\n             .associated_items(trait_did)\n             .in_definition_order()\n-            .find(|i| i.kind.namespace() == Namespace::TypeNS && i.ident.modern() == assoc_ident)\n+            .find(|i| {\n+                i.kind.namespace() == Namespace::TypeNS\n+                    && i.ident.normalize_to_macros_2_0() == assoc_ident\n+            })\n             .expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, assoc_segment, bound);"}, {"sha": "4531d93c01d27404331ae9000b96f91b55cb45c5", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .map(|(i, field)| (field.ident.normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         let mut seen_fields = FxHashMap::default();\n@@ -1469,7 +1469,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n+                    if let Some(index) =\n+                        fields.iter().position(|f| f.ident.normalize_to_macros_2_0() == ident)\n+                    {\n                         let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case"}, {"sha": "0f3884de84e1282048189a45a90147d4487439bd", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -1023,7 +1023,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .map(|(i, field)| (field.ident.normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut unmentioned_fields = variant\n             .fields\n             .iter()\n-            .map(|field| field.ident.modern())\n+            .map(|field| field.ident.normalize_to_macros_2_0())\n             .filter(|ident| !used_fields.contains_key(&ident))\n             .collect::<Vec<_>>();\n "}, {"sha": "7513759c76b015ffe8675b757592cb26655b93a8", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -26,7 +26,8 @@ impl InherentOverlapChecker<'tcx> {\n             let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).any(|item2| {\n                 // Symbols and namespace match, compare hygienically.\n                 item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.modern() == item2.ident.modern()\n+                    && item1.ident.normalize_to_macros_2_0()\n+                        == item2.ident.normalize_to_macros_2_0()\n             });\n \n             if collision {\n@@ -50,11 +51,12 @@ impl InherentOverlapChecker<'tcx> {\n             let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).find(|item2| {\n                 // Symbols and namespace match, compare hygienically.\n                 item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.modern() == item2.ident.modern()\n+                    && item1.ident.normalize_to_macros_2_0()\n+                        == item2.ident.normalize_to_macros_2_0()\n             });\n \n             if let Some(item2) = collision {\n-                let name = item1.ident.modern();\n+                let name = item1.ident.normalize_to_macros_2_0();\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     self.tcx.span_of_impl(item1.def_id).unwrap(),"}, {"sha": "1ee344db1dd680ccb9df4a5595e9ee155ba13164", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -828,7 +828,7 @@ fn convert_variant(\n         .iter()\n         .map(|f| {\n             let fid = tcx.hir().local_def_id(f.hir_id);\n-            let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n+            let dup_span = seen_fields.get(&f.ident.normalize_to_macros_2_0()).cloned();\n             if let Some(prev_span) = dup_span {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -841,7 +841,7 @@ fn convert_variant(\n                 .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n                 .emit();\n             } else {\n-                seen_fields.insert(f.ident.modern(), f.span);\n+                seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }\n \n             ty::FieldDef {"}, {"sha": "5fb510d6e33df6d46318da38f69905b785472597", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8872d9057230e46f4bf35af5880cc6095a06e744/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=8872d9057230e46f4bf35af5880cc6095a06e744", "patch": "@@ -227,7 +227,7 @@ fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplI\n             hir::ImplItemKind::TyAlias(_) => &mut seen_type_items,\n             _ => &mut seen_value_items,\n         };\n-        match seen_items.entry(impl_item.ident.modern()) {\n+        match seen_items.entry(impl_item.ident.normalize_to_macros_2_0()) {\n             Occupied(entry) => {\n                 let mut err = struct_span_err!(\n                     tcx.sess,"}]}