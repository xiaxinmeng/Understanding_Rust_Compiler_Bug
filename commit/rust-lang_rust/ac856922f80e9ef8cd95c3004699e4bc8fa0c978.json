{"sha": "ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODU2OTIyZjgwZTllZjhjZDk1YzMwMDQ2OTllNGJjOGZhMGM5Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-06T15:56:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-06T15:56:52Z"}, "message": "Auto merge of #5301 - JarredAllen:option_if_let_else, r=flip1995\n\nSuggest `Option::map_or`(_else) for `if let Some { y } else { x }`\n\nFixes #5203\n\nThere are two issues with this code that I have noticed:\n\n- Use of `Option::map_or` causes it to always evaluate the code in the else block. If that block is computationally expensive or if it updates some state (such as getting the next value from an iterator), then this change would cause the code to behave differently. In either of those circumstances, it should suggest Option::map_or_else, which takes both cases as a closure and runs one. However, I don't know how to check if the expression would change some state, so I left the lint's applicability as MaybeIncorrect.\n\n- There are lints which can trigger on specific sub-cases of this lint (`if_let_some_result`, `question_mark`, and `while_let_loop`) and suggest different changes (usually better ones because they're more specific). Is this acceptable for clippy to give multiple suggestions, or should I have the code check if those other lints trigger and then not trigger this lint if they do?\n\nchangelog: Add lint [`option_if_let_else`]", "tree": {"sha": "49cbbe0c038ae067a7c256f94c876b4dc04985a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49cbbe0c038ae067a7c256f94c876b4dc04985a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "html_url": "https://github.com/rust-lang/rust/commit/ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57cdf2dc16e1833008ae5b120cb2c045d267dda8", "url": "https://api.github.com/repos/rust-lang/rust/commits/57cdf2dc16e1833008ae5b120cb2c045d267dda8", "html_url": "https://github.com/rust-lang/rust/commit/57cdf2dc16e1833008ae5b120cb2c045d267dda8"}, {"sha": "c8f700ea697f74ef8f86891b050c859cf457e3ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8f700ea697f74ef8f86891b050c859cf457e3ab", "html_url": "https://github.com/rust-lang/rust/commit/c8f700ea697f74ef8f86891b050c859cf457e3ab"}], "stats": {"total": 988, "additions": 760, "deletions": 228}, "files": [{"sha": "1a081bb85feab6c5ed35df1bbf0bf2d0aa2f8159", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -1577,6 +1577,7 @@ Released 2018-09-13\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option"}, {"sha": "d68d0d8ccf58dd45a4ef1299d852840560208a02", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -481,15 +481,14 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n }\n \n fn is_relevant_block(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n-    if let Some(stmt) = block.stmts.first() {\n-        match &stmt.kind {\n+    block.stmts.first().map_or(\n+        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e)),\n+        |stmt| match &stmt.kind {\n             StmtKind::Local(_) => true,\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n             _ => false,\n-        }\n-    } else {\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e))\n-    }\n+        },\n+    )\n }\n \n fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n@@ -499,11 +498,10 @@ fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.kind {\n-                if let Some(fun_id) = tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n-                } else {\n-                    true\n-                }\n+                tables\n+                    .qpath_res(qpath, path_expr.hir_id)\n+                    .opt_def_id()\n+                    .map_or(true, |fun_id| !match_def_path(cx, fun_id, &paths::BEGIN_PANIC))\n             } else {\n                 true\n             }"}, {"sha": "fbd2eeacc6ef553cf7146eade14619877280cab2", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -135,13 +135,10 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     }\n }\n \n-impl<'tcx> ArmVisitor<'_, 'tcx> {\n+impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n     fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n-        if let Some(arm_mutex) = self.found_mutex {\n-            SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n-        } else {\n-            false\n-        }\n+        self.found_mutex\n+            .map_or(false, |arm_mutex| SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex))\n     }\n }\n "}, {"sha": "1b09328ceabb004275f41c031f913d132154ec64", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -302,16 +302,12 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables().expr_ty(expr));\n     match ty.kind {\n-        ty::Dynamic(ref tt, ..) => {\n-            if let Some(principal) = tt.principal() {\n-                cx.tcx\n-                    .associated_items(principal.def_id())\n-                    .in_definition_order()\n-                    .any(|item| is_is_empty(cx, &item))\n-            } else {\n-                false\n-            }\n-        },\n+        ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n+            cx.tcx\n+                .associated_items(principal.def_id())\n+                .in_definition_order()\n+                .any(|item| is_is_empty(cx, &item))\n+        }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,"}, {"sha": "fe34e4390d65966d181b974183646aab27f32cc6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -264,6 +264,7 @@ mod non_copy_const;\n mod non_expressive_names;\n mod open_options;\n mod option_env_unwrap;\n+mod option_if_let_else;\n mod overflow_check_conditional;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n@@ -734,6 +735,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &non_expressive_names::SIMILAR_NAMES,\n         &open_options::NONSENSICAL_OPEN_OPTIONS,\n         &option_env_unwrap::OPTION_ENV_UNWRAP,\n+        &option_if_let_else::OPTION_IF_LET_ELSE,\n         &overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n         &panic_unimplemented::PANIC,\n         &panic_unimplemented::PANIC_PARAMS,\n@@ -1052,6 +1054,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n     store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n@@ -1158,6 +1161,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_continue::NEEDLESS_CONTINUE),\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n+        LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),"}, {"sha": "a36fdca5d5de6a5816d8ff369501fad9c651b3dd", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -264,10 +264,13 @@ impl LiteralDigitGrouping {\n \n         let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n             (exponent, &[\"32\", \"64\"][..], 'f')\n-        } else if let Some(fraction) = &mut num_lit.fraction {\n-            (fraction, &[\"32\", \"64\"][..], 'f')\n         } else {\n-            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+            num_lit\n+                .fraction\n+                .as_mut()\n+                .map_or((&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i'), |fraction| {\n+                    (fraction, &[\"32\", \"64\"][..], 'f')\n+                })\n         };\n \n         let mut split = part.rsplit('_');"}, {"sha": "b803d753b6d0474c9d17b28e910ca610816dd5ab", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -686,13 +686,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => {\n-            if let Some(ref e) = *e {\n-                combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n-            } else {\n-                NeverLoopResult::AlwaysBreak\n-            }\n-        },\n+        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+        }),\n         ExprKind::InlineAsm(ref asm) => asm\n             .operands\n             .iter()\n@@ -1881,13 +1877,9 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.kind {\n-        ty::Array(_, n) => {\n-            if let Some(val) = n.try_eval_usize(cx.tcx, cx.param_env) {\n-                (0..=32).contains(&val)\n-            } else {\n-                false\n-            }\n-        },\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n         _ => false,\n     }\n }\n@@ -1899,11 +1891,7 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n         return None;\n     }\n     if let StmtKind::Local(ref local) = block.stmts[0].kind {\n-        if let Some(expr) = local.init {\n-            Some(expr)\n-        } else {\n-            None\n-        }\n+        local.init //.map(|expr| expr)\n     } else {\n         None\n     }\n@@ -2023,15 +2011,13 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n                 if let PatKind::Binding(.., ident, _) = local.pat.kind {\n                     self.name = Some(ident.name);\n \n-                    self.state = if let Some(ref init) = local.init {\n+                    self.state = local.init.as_ref().map_or(VarState::Declared, |init| {\n                         if is_integer_const(&self.cx, init, 0) {\n                             VarState::Warn\n                         } else {\n                             VarState::Declared\n                         }\n-                    } else {\n-                        VarState::Declared\n-                    }\n+                    })\n                 }\n             }\n         }"}, {"sha": "f1c8894c0ee2973311bf06f2ab6f1618e721fd46", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -2460,13 +2460,9 @@ fn derefs_to_slice<'tcx>(\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n-            ty::Array(_, size) => {\n-                if let Some(size) = size.try_eval_usize(cx.tcx, cx.param_env) {\n-                    size < 32\n-                } else {\n-                    false\n-                }\n-            },\n+            ty::Array(_, size) => size\n+                .try_eval_usize(cx.tcx, cx.param_env)\n+                .map_or(false, |size| size < 32),\n             ty::Ref(_, inner, _) => may_slice(cx, inner),\n             _ => false,\n         }"}, {"sha": "75e123eb5939d971b7c7943485ea569894377ee1", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -77,13 +77,10 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             }\n             (true, true)\n         },\n-        hir::ExprKind::Block(ref block, _) => {\n-            if let Some(expr) = &block.expr {\n-                check_expression(cx, arg_id, &expr)\n-            } else {\n-                (false, false)\n-            }\n-        },\n+        hir::ExprKind::Block(ref block, _) => block\n+            .expr\n+            .as_ref()\n+            .map_or((false, false), |expr| check_expression(cx, arg_id, &expr)),\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;"}, {"sha": "c8aa98d348927e3f870d7e666df7d653f45b5dff", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MinMaxPass {\n     }\n }\n \n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n enum MinMax {\n     Min,\n     Max,\n@@ -86,16 +86,15 @@ fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Opt\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(cx, cx.tables(), &args[0]) {\n-        if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n-            // otherwise ignore\n-            Some((m, c, &args[1]))\n-        } else {\n-            None\n-        }\n-    } else if let Some(c) = constant_simple(cx, cx.tables(), &args[1]) {\n-        Some((m, c, &args[0]))\n-    } else {\n-        None\n-    }\n+    constant_simple(cx, cx.tables(), &args[0]).map_or_else(\n+        || constant_simple(cx, cx.tables(), &args[1]).map(|c| (m, c, &args[0])),\n+        |c| {\n+            if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n+                // otherwise ignore\n+                Some((m, c, &args[1]))\n+            } else {\n+                None\n+            }\n+        },\n+    )\n }"}, {"sha": "3d4225f36a7d046cb56922c3f23e7ef23dbaa329", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -682,16 +682,10 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let Some(parent) = get_parent_expr(cx, expr) {\n-        match parent.kind {\n-            ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => {\n-                SpanlessEq::new(cx).eq_expr(rhs, expr)\n-            },\n-            _ => is_used(cx, parent),\n-        }\n-    } else {\n-        true\n-    }\n+    get_parent_expr(cx, expr).map_or(true, |parent| match parent.kind {\n+        ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n+        _ => is_used(cx, parent),\n+    })\n }\n \n /// Tests whether an expression is in a macro expansion (e.g., something"}, {"sha": "8dbe58763bfb287648e369f0491dbe7cf206cd3f", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -0,0 +1,267 @@\n+use crate::utils;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use if_chain::if_chain;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n+    /// idiomatically done with `Option::map_or` (if the else bit is a simple\n+    /// expression) or `Option::map_or_else` (if the else bit is a longer\n+    /// block).\n+    ///\n+    /// **Why is this bad?**\n+    /// Using the dedicated functions of the Option type is clearer and\n+    /// more concise than an if let expression.\n+    ///\n+    /// **Known problems:**\n+    /// This lint uses whether the block is just an expression or if it has\n+    /// more statements to decide whether to use `Option::map_or` or\n+    /// `Option::map_or_else`. If you have a single expression which calls\n+    /// an expensive function, then it would be more efficient to use\n+    /// `Option::map_or_else`, but this lint would suggest `Option::map_or`.\n+    ///\n+    /// Also, this lint uses a deliberately conservative metric for checking\n+    /// if the inside of either body contains breaks or continues which will\n+    /// cause it to not suggest a fix if either block contains a loop with\n+    /// continues or breaks contained within the loop.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// # fn do_complicated_function() -> u32 { 5 };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     5\n+    /// };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// };\n+    /// ```\n+    ///\n+    /// should be\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// # fn do_complicated_function() -> u32 { 5 };\n+    /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or_else(||{\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// }, |foo| foo);\n+    /// ```\n+    pub OPTION_IF_LET_ELSE,\n+    pedantic,\n+    \"reimplementation of Option::map_or\"\n+}\n+\n+declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n+\n+/// Returns true iff the given expression is the result of calling `Result::ok`\n+fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+    if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n+        path.ident.name.to_ident_string() == \"ok\" && match_type(cx, &cx.tables().expr_ty(&receiver), &paths::RESULT)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// A struct containing information about occurences of the\n+/// `if let Some(..) = .. else` construct that this lint detects.\n+struct OptionIfLetElseOccurence {\n+    option: String,\n+    method_sugg: String,\n+    some_expr: String,\n+    none_expr: String,\n+    wrap_braces: bool,\n+}\n+\n+struct ReturnBreakContinueMacroVisitor {\n+    seen_return_break_continue: bool,\n+}\n+impl ReturnBreakContinueMacroVisitor {\n+    fn new() -> ReturnBreakContinueMacroVisitor {\n+        ReturnBreakContinueMacroVisitor {\n+            seen_return_break_continue: false,\n+        }\n+    }\n+}\n+impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self.seen_return_break_continue {\n+            // No need to look farther if we've already seen one of them\n+            return;\n+        }\n+        match &ex.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n+                self.seen_return_break_continue = true;\n+            },\n+            // Something special could be done here to handle while or for loop\n+            // desugaring, as this will detect a break if there's a while loop\n+            // or a for loop inside the expression.\n+            _ => {\n+                if utils::in_macro(ex.span) {\n+                    self.seen_return_break_continue = true;\n+                } else {\n+                    rustc_hir::intravisit::walk_expr(self, ex);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n+    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n+    recursive_visitor.visit_expr(expression);\n+    recursive_visitor.seen_return_break_continue\n+}\n+\n+/// Extracts the body of a given arm. If the arm contains only an expression,\n+/// then it returns the expression. Otherwise, it returns the entire block\n+fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+    if let ExprKind::Block(\n+        Block {\n+            stmts: statements,\n+            expr: Some(expr),\n+            ..\n+        },\n+        _,\n+    ) = &arm.body.kind\n+    {\n+        if let [] = statements {\n+            Some(&expr)\n+        } else {\n+            Some(&arm.body)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If this is the else body of an if/else expression, then we need to wrap\n+/// it in curcly braces. Otherwise, we don't.\n+fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n+        if let Some(Expr {\n+            kind:\n+                ExprKind::Match(\n+                    _,\n+                    arms,\n+                    MatchSource::IfDesugar {\n+                        contains_else_clause: true,\n+                    }\n+                    | MatchSource::IfLetDesugar {\n+                        contains_else_clause: true,\n+                    },\n+                ),\n+            ..\n+        }) = parent.expr\n+        {\n+            expr.hir_id == arms[1].body.hir_id\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n+    format!(\n+        \"{}{}\",\n+        Sugg::hir(cx, cond_expr, \"..\").maybe_par(),\n+        if as_mut {\n+            \".as_mut()\"\n+        } else if as_ref {\n+            \".as_ref()\"\n+        } else {\n+            \"\"\n+        }\n+    )\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an `OptionIfLetElseOccurence` struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OptionIfLetElseOccurence> {\n+    if_chain! {\n+        if !utils::in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n+        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if arms.len() == 2;\n+        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n+        if utils::match_qpath(struct_qpath, &paths::OPTION_SOME);\n+        if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n+        if !contains_return_break_continue_macro(arms[0].body);\n+        if !contains_return_break_continue_macro(arms[1].body);\n+        then {\n+            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let some_body = extract_body_from_arm(&arms[0])?;\n+            let none_body = extract_body_from_arm(&arms[1])?;\n+            let method_sugg = match &none_body.kind {\n+                ExprKind::Block(..) => \"map_or_else\",\n+                _ => \"map_or\",\n+            };\n+            let capture_name = id.name.to_ident_string();\n+            let wrap_braces = should_wrap_in_braces(cx, expr);\n+            let (as_ref, as_mut) = match &cond_expr.kind {\n+                ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n+                ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n+                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n+            };\n+            let cond_expr = match &cond_expr.kind {\n+                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n+                ExprKind::Unary(UnOp::UnDeref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n+                _ => cond_expr,\n+            };\n+            Some(OptionIfLetElseOccurence {\n+                option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n+                method_sugg: method_sugg.to_string(),\n+                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir(cx, some_body, \"..\")),\n+                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\")),\n+                wrap_braces,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a> LateLintPass<'a> for OptionIfLetElse {\n+    fn check_expr(&mut self, cx: &LateContext<'a>, expr: &Expr<'_>) {\n+        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n+            span_lint_and_sugg(\n+                cx,\n+                OPTION_IF_LET_ELSE,\n+                expr.span,\n+                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n+                \"try\",\n+                format!(\n+                    \"{}{}.{}({}, {}){}\",\n+                    if detection.wrap_braces { \"{ \" } else { \"\" },\n+                    detection.option,\n+                    detection.method_sugg,\n+                    detection.none_expr,\n+                    detection.some_expr,\n+                    if detection.wrap_braces { \" }\" } else { \"\" },\n+                ),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}"}, {"sha": "faef7e724dd056a8464957cfb91a5b4e6c53f157", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -259,15 +259,15 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n \n fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n     let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        if let Some(rpos) = fn_source.rfind(\"->\") {\n-            #[allow(clippy::cast_possible_truncation)]\n-            (\n-                ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                Applicability::MachineApplicable,\n-            )\n-        } else {\n-            (ty.span, Applicability::MaybeIncorrect)\n-        }\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n     } else {\n         (ty.span, Applicability::MaybeIncorrect)\n     };"}, {"sha": "4cdff63f1180a2e031c94c0eea9967d6aa833abf", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -165,14 +165,10 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables().node_type_opt(pat_id);\n-    if let Some(var_ty) = var_ty {\n-        match var_ty.kind {\n-            ty::Adt(..) => false,\n-            _ => true,\n-        }\n-    } else {\n-        false\n-    }\n+    var_ty.map_or(false, |var_ty| match var_ty.kind {\n+        ty::Adt(..) => false,\n+        _ => true,\n+    })\n }\n \n fn check_pat<'tcx>("}, {"sha": "d6f31a99bb36a8df1fe4151513bc2e4a46c7b180", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -1205,16 +1205,19 @@ fn span_lossless_lint(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     // has parens on the outside, they are no longer needed.\n     let mut applicability = Applicability::MachineApplicable;\n     let opt = snippet_opt(cx, op.span);\n-    let sugg = if let Some(ref snip) = opt {\n-        if should_strip_parens(op, snip) {\n-            &snip[1..snip.len() - 1]\n-        } else {\n-            snip.as_str()\n-        }\n-    } else {\n-        applicability = Applicability::HasPlaceholders;\n-        \"..\"\n-    };\n+    let sugg = opt.as_ref().map_or_else(\n+        || {\n+            applicability = Applicability::HasPlaceholders;\n+            \"..\"\n+        },\n+        |snip| {\n+            if should_strip_parens(op, snip) {\n+                &snip[1..snip.len() - 1]\n+            } else {\n+                snip.as_str()\n+            }\n+        },\n+    );\n \n     span_lint_and_sugg(\n         cx,"}, {"sha": "39a8c0208728466b4cff8903424e9bfe0acab801", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -167,14 +167,13 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.kind;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                let should_check = if let Some(ref params) = *parameters {\n-                    !params.parenthesized && !params.args.iter().any(|arg| match arg {\n+                let should_check = parameters.as_ref().map_or(\n+                    true,\n+                    |params| !params.parenthesized && !params.args.iter().any(|arg| match arg {\n                         GenericArg::Lifetime(_) => true,\n                         _ => false,\n                     })\n-                } else {\n-                    true\n-                };\n+                );\n \n                 if should_check {\n                     let visitor = &mut UseSelfVisitor {"}, {"sha": "4bb4b087c5566773b5dfa9249c936a486b103f98", "filename": "clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -65,42 +65,45 @@ pub fn get_attr<'a>(\n         };\n         let attr_segments = &attr.path.segments;\n         if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n-            if let Some(deprecation_status) =\n-                BUILTIN_ATTRIBUTES\n-                    .iter()\n-                    .find_map(|(builtin_name, deprecation_status)| {\n-                        if *builtin_name == attr_segments[1].ident.to_string() {\n-                            Some(deprecation_status)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-            {\n-                let mut diag = sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n-                match *deprecation_status {\n-                    DeprecationStatus::Deprecated => {\n-                        diag.emit();\n-                        false\n-                    },\n-                    DeprecationStatus::Replaced(new_name) => {\n-                        diag.span_suggestion(\n-                            attr_segments[1].ident.span,\n-                            \"consider using\",\n-                            new_name.to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        diag.emit();\n+            BUILTIN_ATTRIBUTES\n+                .iter()\n+                .find_map(|(builtin_name, deprecation_status)| {\n+                    if *builtin_name == attr_segments[1].ident.to_string() {\n+                        Some(deprecation_status)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .map_or_else(\n+                    || {\n+                        sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n                         false\n                     },\n-                    DeprecationStatus::None => {\n-                        diag.cancel();\n-                        attr_segments[1].ident.to_string() == name\n+                    |deprecation_status| {\n+                        let mut diag =\n+                            sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n+                        match *deprecation_status {\n+                            DeprecationStatus::Deprecated => {\n+                                diag.emit();\n+                                false\n+                            },\n+                            DeprecationStatus::Replaced(new_name) => {\n+                                diag.span_suggestion(\n+                                    attr_segments[1].ident.span,\n+                                    \"consider using\",\n+                                    new_name.to_string(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                diag.emit();\n+                                false\n+                            },\n+                            DeprecationStatus::None => {\n+                                diag.cancel();\n+                                attr_segments[1].ident.to_string() == name\n+                            },\n+                        }\n                     },\n-                }\n-            } else {\n-                sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n-                false\n-            }\n+                )\n         } else {\n             false\n         }"}, {"sha": "3a3b79925ff9aec8d241ebb03cbf0532a4048173", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -153,11 +153,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n-    if let Some(trt_id) = trt_id {\n-        match_def_path(cx, trt_id, path)\n-    } else {\n-        false\n-    }\n+    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n \n /// Checks if an expression references a variable of the given name.\n@@ -600,21 +596,15 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n /// //  ^^^^^^^^^^\n /// ```\n pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    if let Some(first_char_pos) = first_char_in_first_line(cx, span) {\n-        span.with_lo(first_char_pos)\n-    } else {\n-        span\n-    }\n+    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n }\n \n fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n     let line_span = line_span(cx, span);\n-    if let Some(snip) = snippet_opt(cx, line_span) {\n+    snippet_opt(cx, line_span).and_then(|snip| {\n         snip.find(|c: char| !c.is_whitespace())\n             .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n-    } else {\n-        None\n-    }\n+    })\n }\n \n /// Returns the indentation of the line of a span\n@@ -626,11 +616,7 @@ fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePo\n /// //          ^^ -- will return 4\n /// ```\n pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n-    if let Some(snip) = snippet_opt(cx, line_span(cx, span)) {\n-        snip.find(|c: char| !c.is_whitespace())\n-    } else {\n-        None\n-    }\n+    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n@@ -738,25 +724,21 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     let enclosing_node = map\n         .get_enclosing_scope(hir_id)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n-    if let Some(node) = enclosing_node {\n-        match node {\n-            Node::Block(block) => Some(block),\n-            Node::Item(&Item {\n-                kind: ItemKind::Fn(_, _, eid),\n-                ..\n-            })\n-            | Node::ImplItem(&ImplItem {\n-                kind: ImplItemKind::Fn(_, eid),\n-                ..\n-            }) => match cx.tcx.hir().body(eid).value.kind {\n-                ExprKind::Block(ref block, _) => Some(block),\n-                _ => None,\n-            },\n+    enclosing_node.and_then(|node| match node {\n+        Node::Block(block) => Some(block),\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(_, _, eid),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(_, eid),\n+            ..\n+        }) => match cx.tcx.hir().body(eid).value.kind {\n+            ExprKind::Block(ref block, _) => Some(block),\n             _ => None,\n-        }\n-    } else {\n-        None\n-    }\n+        },\n+        _ => None,\n+    })\n }\n \n /// Returns the base type for HIR references and pointers.\n@@ -1328,11 +1310,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    if let Some(did) = did {\n-        must_use_attr(&cx.tcx.get_attrs(did)).is_some()\n-    } else {\n-        false\n-    }\n+    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {"}, {"sha": "7a79741b30bd09a9e992d003a4573c1b2247ba97", "filename": "clippy_lints/src/utils/numeric_literal.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -200,12 +200,10 @@ impl<'a> NumericLiteral<'a> {\n \n fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n     debug_assert!(lit_kind.is_numeric());\n-    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n+    lit_suffix_length(lit_kind).map_or((src, None), |suffix_length| {\n         let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n         (unsuffixed, Some(suffix))\n-    } else {\n-        (src, None)\n-    }\n+    })\n }\n \n fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {"}, {"sha": "0ac7714fbeb79cd9b3feb6d3665b437c72aabcd0", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -492,20 +492,20 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n /// before it on its line.\n fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().source_map().lookup_char_pos(span.lo());\n-    if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n-        if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n-            // We can mix char and byte positions here because we only consider `[ \\t]`.\n-            if lo.col == CharPos(pos) {\n-                Some(line[..pos].into())\n+    lo.file\n+        .get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */)\n+        .and_then(|line| {\n+            if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n+                // We can mix char and byte positions here because we only consider `[ \\t]`.\n+                if lo.col == CharPos(pos) {\n+                    Some(line[..pos].into())\n+                } else {\n+                    None\n+                }\n             } else {\n                 None\n             }\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n+        })\n }\n \n /// Convenience extension trait for `DiagnosticBuilder`."}, {"sha": "063f94582b9d14cc38f138d8914e8ce178aaae66", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -297,12 +297,13 @@ impl EarlyLintPass for Write {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = if let Some(e) = expr {\n-                        snippet_with_applicability(cx, e.span, \"v\", &mut applicability)\n-                    } else {\n-                        applicability = Applicability::HasPlaceholders;\n-                        Cow::Borrowed(\"v\")\n-                    };\n+                    let suggestion = expr.map_or_else(\n+                        || {\n+                            applicability = Applicability::HasPlaceholders;\n+                            Cow::Borrowed(\"v\")\n+                        },\n+                        |e| snippet_with_applicability(cx, e.span, \"v\", &mut Applicability::MachineApplicable),\n+                    );\n \n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "e681f47f949dfee5e6eee6830550833f454afd2b", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -1620,6 +1620,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"option_env_unwrap\",\n     },\n+    Lint {\n+        name: \"option_if_let_else\",\n+        group: \"pedantic\",\n+        desc: \"reimplementation of Option::map_or\",\n+        deprecation: None,\n+        module: \"option_if_let_else\",\n+    },\n     Lint {\n         name: \"option_map_or_none\",\n         group: \"style\","}, {"sha": "eb6d495acbe202e4d2924b4a56ba738755db77b5", "filename": "tests/compile-test.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -12,19 +12,11 @@ use std::path::{Path, PathBuf};\n mod cargo;\n \n fn host_lib() -> PathBuf {\n-    if let Some(path) = option_env!(\"HOST_LIBS\") {\n-        PathBuf::from(path)\n-    } else {\n-        cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\"))\n-    }\n+    option_env!(\"HOST_LIBS\").map_or(cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\")), PathBuf::from)\n }\n \n fn clippy_driver_path() -> PathBuf {\n-    if let Some(path) = option_env!(\"CLIPPY_DRIVER_PATH\") {\n-        PathBuf::from(path)\n-    } else {\n-        cargo::TARGET_LIB.join(\"clippy-driver\")\n-    }\n+    option_env!(\"CLIPPY_DRIVER_PATH\").map_or(cargo::TARGET_LIB.join(\"clippy-driver\"), PathBuf::from)\n }\n \n // When we'll want to use `extern crate ..` for a dependency that is used"}, {"sha": "695a460cc4edfda0a16871c1aa0b3f1498359271", "filename": "tests/ui/option_if_let_else.fixed", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -0,0 +1,74 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    string.map_or((false, \"hello\"), |x| (true, x))\n+}\n+\n+fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n+    if string.is_none() {\n+        None\n+    } else { string.map_or(Some((false, \"\")), |x| Some((true, x))) }\n+}\n+\n+fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n+    let _ = string.map_or(0, |s| s.len());\n+    let _ = num.as_ref().map_or(&0, |s| s);\n+    let _ = num.as_mut().map_or(&mut 0, |s| {\n+        *s += 1;\n+        s\n+    });\n+    let _ = num.as_ref().map_or(&0, |s| s);\n+    let _ = num.map_or(0, |mut s| {\n+        s += 1;\n+        s\n+    });\n+    let _ = num.as_mut().map_or(&mut 0, |s| {\n+        *s += 1;\n+        s\n+    });\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    arg.map_or(13, |x| {\n+        let y = x * x;\n+        y * y\n+    })\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = arg.map_or_else(|| {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    }, |x| x * x * x * x);\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = optional.map_or(5, |x| x + 2);\n+    let _ = bad1(None);\n+    let _ = else_if_option(None);\n+    unop_bad(&None, None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "dee80d26bd976d93fda3f72fd0ce3a4cd65c3307", "filename": "tests/ui/option_if_let_else.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -0,0 +1,92 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    if let Some(x) = string {\n+        (true, x)\n+    } else {\n+        (false, \"hello\")\n+    }\n+}\n+\n+fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n+    if string.is_none() {\n+        None\n+    } else if let Some(x) = string {\n+        Some((true, x))\n+    } else {\n+        Some((false, \"\"))\n+    }\n+}\n+\n+fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n+    let _ = if let Some(s) = *string { s.len() } else { 0 };\n+    let _ = if let Some(s) = &num { s } else { &0 };\n+    let _ = if let Some(s) = &mut num {\n+        *s += 1;\n+        s\n+    } else {\n+        &mut 0\n+    };\n+    let _ = if let Some(ref s) = num { s } else { &0 };\n+    let _ = if let Some(mut s) = num {\n+        s += 1;\n+        s\n+    } else {\n+        0\n+    };\n+    let _ = if let Some(ref mut s) = num {\n+        *s += 1;\n+        s\n+    } else {\n+        &mut 0\n+    };\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    if let Some(x) = arg {\n+        let y = x * x;\n+        y * y\n+    } else {\n+        13\n+    }\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = if let Some(x) = arg {\n+        x * x * x * x\n+    } else {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    };\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+    let _ = bad1(None);\n+    let _ = else_if_option(None);\n+    unop_bad(&None, None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "7005850efaf833b47f693ae04a7e9cd37722e476", "filename": "tests/ui/option_if_let_else.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -0,0 +1,151 @@\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:5:5\n+   |\n+LL | /     if let Some(x) = string {\n+LL | |         (true, x)\n+LL | |     } else {\n+LL | |         (false, \"hello\")\n+LL | |     }\n+   | |_____^ help: try: `string.map_or((false, \"hello\"), |x| (true, x))`\n+   |\n+   = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:15:12\n+   |\n+LL |       } else if let Some(x) = string {\n+   |  ____________^\n+LL | |         Some((true, x))\n+LL | |     } else {\n+LL | |         Some((false, \"\"))\n+LL | |     }\n+   | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:23:13\n+   |\n+LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:24:13\n+   |\n+LL |     let _ = if let Some(s) = &num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:25:13\n+   |\n+LL |       let _ = if let Some(s) = &mut num {\n+   |  _____________^\n+LL | |         *s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         &mut 0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.as_mut().map_or(&mut 0, |s| {\n+LL |         *s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:31:13\n+   |\n+LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:32:13\n+   |\n+LL |       let _ = if let Some(mut s) = num {\n+   |  _____________^\n+LL | |         s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.map_or(0, |mut s| {\n+LL |         s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:38:13\n+   |\n+LL |       let _ = if let Some(ref mut s) = num {\n+   |  _____________^\n+LL | |         *s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         &mut 0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.as_mut().map_or(&mut 0, |s| {\n+LL |         *s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:47:5\n+   |\n+LL | /     if let Some(x) = arg {\n+LL | |         let y = x * x;\n+LL | |         y * y\n+LL | |     } else {\n+LL | |         13\n+LL | |     }\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     arg.map_or(13, |x| {\n+LL |         let y = x * x;\n+LL |         y * y\n+LL |     })\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:56:13\n+   |\n+LL |       let _ = if let Some(x) = arg {\n+   |  _____________^\n+LL | |         x * x * x * x\n+LL | |     } else {\n+LL | |         let mut y = 1;\n+...  |\n+LL | |         y\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = arg.map_or_else(|| {\n+LL |         let mut y = 1;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y\n+LL |     }, |x| x * x * x * x);\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:85:13\n+   |\n+LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n+\n+error: aborting due to 11 previous errors\n+"}]}