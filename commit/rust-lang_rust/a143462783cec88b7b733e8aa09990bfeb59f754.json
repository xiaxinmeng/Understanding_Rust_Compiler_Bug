{"sha": "a143462783cec88b7b733e8aa09990bfeb59f754", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNDM0NjI3ODNjZWM4OGI3YjczM2U4YWEwOTk5MGJmZWI1OWY3NTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-06T09:32:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-06T09:32:03Z"}, "message": "Auto merge of #49154 - petrochenkov:spident, r=eddyb\n\nAST: Give spans to all identifiers\n\nChange representation of `ast::Ident` from `{ name: Symbol, ctxt: SyntaxContext }` to `{ name: Symbol, span: Span }`.\nSyntax contexts still can be extracted from spans (`span.ctxt()`).\n\nWhy this should not require more memory:\n- `Span` is `u32` just like `SyntaxContext`.\n- Despite keeping more spans in AST we don't actually *create* more spans, so the number of \"outlined\" spans kept in span interner shouldn't become larger.\n\nWhy this may be slightly slower:\n- When we need to extract ctxt from an identifier instead of just field read we need to do bit field extraction possibly followed by and access by index into span interner's vector. Both operations should be fast (unless the span interner is under some synchronization) and we already do ctxt extraction from spans all the time during macro expansion, so the difference should be lost in noise.\n\ncc https://github.com/rust-lang/rust/pull/48842#issuecomment-373365661", "tree": {"sha": "0b54bd1ccd7a5394795254f91fdd9e191e4947e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b54bd1ccd7a5394795254f91fdd9e191e4947e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a143462783cec88b7b733e8aa09990bfeb59f754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a143462783cec88b7b733e8aa09990bfeb59f754", "html_url": "https://github.com/rust-lang/rust/commit/a143462783cec88b7b733e8aa09990bfeb59f754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a143462783cec88b7b733e8aa09990bfeb59f754/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db4235c4fd20b18fcda7f331913cfe30a13f216c", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4235c4fd20b18fcda7f331913cfe30a13f216c", "html_url": "https://github.com/rust-lang/rust/commit/db4235c4fd20b18fcda7f331913cfe30a13f216c"}, {"sha": "145868427989655f286a3dda0cd46435bcdf42ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/145868427989655f286a3dda0cd46435bcdf42ac", "html_url": "https://github.com/rust-lang/rust/commit/145868427989655f286a3dda0cd46435bcdf42ac"}], "stats": {"total": 1649, "additions": 791, "deletions": 858}, "files": [{"sha": "32697e46a08ac58787543402d0767f3ea72bf8bd", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -1097,15 +1097,17 @@ impl TokenTree {\n                 }).into();\n             },\n             self::TokenTree::Term(tt) => {\n-                let ident = ast::Ident { name: tt.sym, ctxt: tt.span.0.ctxt() };\n+                let ident = ast::Ident::new(tt.sym, tt.span.0);\n                 let sym_str = tt.sym.as_str();\n-                let token =\n-                    if sym_str.starts_with(\"'\") { Lifetime(ident) }\n-                    else if sym_str.starts_with(\"r#\") {\n-                        let name = Symbol::intern(&sym_str[2..]);\n-                        let ident = ast::Ident { name, ctxt: tt.span.0.ctxt() };\n-                        Ident(ident, true)\n-                    } else { Ident(ident, false) };\n+                let token = if sym_str.starts_with(\"'\") {\n+                    Lifetime(ident)\n+                } else if sym_str.starts_with(\"r#\") {\n+                    let name = Symbol::intern(&sym_str[2..]);\n+                    let ident = ast::Ident::new(name, ident.span);\n+                    Ident(ident, true)\n+                } else {\n+                    Ident(ident, false)\n+                };\n                 return TokenTree::Token(tt.span.0, token).into();\n             }\n             self::TokenTree::Literal(self::Literal {"}, {"sha": "b13c289394a7bf92ce83d11a714fcec10425f5a9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -909,7 +909,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ident(&mut self, ident: Ident) -> Name {\n         let ident = ident.modern();\n-        if ident.ctxt == SyntaxContext::empty() {\n+        if ident.span.ctxt() == SyntaxContext::empty() {\n             return ident.name;\n         }\n         *self.name_map\n@@ -920,7 +920,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n         label.map(|label| hir::Label {\n             name: label.ident.name,\n-            span: label.span,\n+            span: label.ident.span,\n         })\n     }\n \n@@ -1358,7 +1358,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n         Spanned {\n             node: hir::Variant_ {\n-                name: v.node.name.name,\n+                name: v.node.ident.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node\n@@ -1607,7 +1607,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::PathSegment::new(\n-            self.lower_ident(segment.identifier),\n+            self.lower_ident(segment.ident),\n             parameters,\n             infer_types,\n         )\n@@ -1720,7 +1720,7 @@ impl<'a> LoweringContext<'a> {\n         decl.inputs\n             .iter()\n             .map(|arg| match arg.pat.node {\n-                PatKind::Ident(_, ident, None) => respan(ident.span, ident.node.name),\n+                PatKind::Ident(_, ident, None) => respan(ident.span, ident.name),\n                 _ => respan(arg.pat.span, keywords::Invalid.name()),\n             })\n             .collect()\n@@ -1810,7 +1810,7 @@ impl<'a> LoweringContext<'a> {\n             default: tp.default\n                 .as_ref()\n                 .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n-            span: tp.span,\n+            span: tp.ident.span,\n             pure_wrt_drop: attr::contains_name(&tp.attrs, \"may_dangle\"),\n             synthetic: tp.attrs\n                 .iter()\n@@ -1822,21 +1822,22 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n+        let span = l.ident.span;\n         match self.lower_ident(l.ident) {\n-            x if x == \"'static\" => self.new_named_lifetime(l.id, l.span, hir::LifetimeName::Static),\n+            x if x == \"'static\" => self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n             x if x == \"'_\" => match self.anonymous_lifetime_mode {\n                 AnonymousLifetimeMode::CreateParameter => {\n-                    let fresh_name = self.collect_fresh_in_band_lifetime(l.span);\n-                    self.new_named_lifetime(l.id, l.span, fresh_name)\n+                    let fresh_name = self.collect_fresh_in_band_lifetime(span);\n+                    self.new_named_lifetime(l.id, span, fresh_name)\n                 }\n \n                 AnonymousLifetimeMode::PassThrough => {\n-                    self.new_named_lifetime(l.id, l.span, hir::LifetimeName::Underscore)\n+                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n                 }\n             },\n             name => {\n-                self.maybe_collect_in_band_lifetime(l.span, name);\n-                self.new_named_lifetime(l.id, l.span, hir::LifetimeName::Name(name))\n+                self.maybe_collect_in_band_lifetime(span, name);\n+                self.new_named_lifetime(l.id, span, hir::LifetimeName::Name(name))\n             }\n         }\n     }\n@@ -2089,10 +2090,7 @@ impl<'a> LoweringContext<'a> {\n             name: self.lower_ident(match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n-                None => Ident {\n-                    name: Symbol::intern(&index.to_string()),\n-                    ctxt: f.span.ctxt(),\n-                },\n+                None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n             }),\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty, ImplTraitContext::Disallowed),\n@@ -2102,7 +2100,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n-            name: respan(f.ident.span, self.lower_ident(f.ident.node)),\n+            name: respan(f.ident.span, self.lower_ident(f.ident)),\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n@@ -2359,11 +2357,11 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().identifier.name == keywords::SelfValue.name()\n+                    && path.segments.last().unwrap().ident.name == keywords::SelfValue.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {\n-                        *name = path.segments.last().unwrap().identifier.name;\n+                        *name = path.segments.last().unwrap().ident.name;\n                     }\n                 }\n \n@@ -2804,7 +2802,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n-            PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n+            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n                 match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n                     // `None` can occur in body-less function signatures\n                     def @ None | def @ Some(Def::Local(_)) => {\n@@ -2815,16 +2813,16 @@ impl<'a> LoweringContext<'a> {\n                         hir::PatKind::Binding(\n                             self.lower_binding_mode(binding_mode),\n                             canonical_id,\n-                            respan(pth1.span, pth1.node.name),\n+                            respan(ident.span, ident.name),\n                             sub.as_ref().map(|x| self.lower_pat(x)),\n                         )\n                     }\n                     Some(def) => hir::PatKind::Path(hir::QPath::Resolved(\n                         None,\n                         P(hir::Path {\n-                            span: pth1.span,\n+                            span: ident.span,\n                             def,\n-                            segments: hir_vec![hir::PathSegment::from_name(pth1.node.name)],\n+                            segments: hir_vec![hir::PathSegment::from_name(ident.name)],\n                         }),\n                     )),\n                 }\n@@ -2939,7 +2937,7 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed,\n                 );\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(hir_seg, seg.span, args)\n+                hir::ExprMethodCall(hir_seg, seg.ident.span, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n@@ -3074,7 +3072,7 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ExprKind::Field(ref el, ident) => hir::ExprField(\n                 P(self.lower_expr(el)),\n-                respan(ident.span, self.lower_ident(ident.node)),\n+                respan(ident.span, self.lower_ident(ident)),\n             ),\n             ExprKind::TupField(ref el, ident) => hir::ExprTupField(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {\n@@ -3505,12 +3503,10 @@ impl<'a> LoweringContext<'a> {\n                 let attr = {\n                     // allow(unreachable_code)\n                     let allow = {\n-                        let allow_ident = self.str_to_ident(\"allow\");\n-                        let uc_ident = self.str_to_ident(\"unreachable_code\");\n-                        let uc_meta_item = attr::mk_spanned_word_item(e.span, uc_ident);\n-                        let uc_nested = NestedMetaItemKind::MetaItem(uc_meta_item);\n-                        let uc_spanned = respan(e.span, uc_nested);\n-                        attr::mk_spanned_list_item(e.span, allow_ident, vec![uc_spanned])\n+                        let allow_ident = Ident::from_str(\"allow\").with_span_pos(e.span);\n+                        let uc_ident = Ident::from_str(\"unreachable_code\").with_span_pos(e.span);\n+                        let uc_nested = attr::mk_nested_word_item(uc_ident);\n+                        attr::mk_list_item(e.span, allow_ident, vec![uc_nested])\n                     };\n                     attr::mk_spanned_attr_outer(e.span, attr::mk_attr_id(), allow)\n                 };"}, {"sha": "4bd857c73e6cf6d50e73961d5b90542d2028e3d8", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -132,7 +132,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n+                                            DefPathData::EnumVariant(v.node.ident.name.as_str()),\n                                             REGULAR_SPACE,\n                                             v.span);\n                         this.with_parent(variant_def_index, |this| {\n@@ -202,15 +202,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     lifetime_def.lifetime.id,\n                     DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_str()),\n                     REGULAR_SPACE,\n-                    lifetime_def.lifetime.span\n+                    lifetime_def.lifetime.ident.span\n                 );\n             }\n             GenericParam::Type(ref ty_param) => {\n                 self.create_def(\n                     ty_param.id,\n                     DefPathData::TypeParam(ty_param.ident.name.as_str()),\n                     REGULAR_SPACE,\n-                    ty_param.span\n+                    ty_param.ident.span\n                 );\n             }\n         }"}, {"sha": "38b284fd64637025c34cb6acbb741ed5e2aa5570", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -654,11 +654,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n-            ref name,\n-            ctxt: _ // Ignore this\n+            name,\n+            span,\n         } = *self;\n \n         name.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "3bb4c86e7c22ca23578fb58cef8898d38ce5c00b", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -162,7 +162,7 @@ impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n-impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n+impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n@@ -211,7 +211,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n         style.hash_stable(hcx, hasher);\n         path.segments.len().hash_stable(hcx, hasher);\n         for segment in &path.segments {\n-            segment.identifier.name.hash_stable(hcx, hasher);\n+            segment.ident.name.hash_stable(hcx, hasher);\n         }\n         for tt in tokens.trees() {\n             tt.hash_stable(hcx, hasher);\n@@ -341,7 +341,7 @@ impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItemKind {\n });\n \n impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n-    name,\n+    ident,\n     node,\n     span\n });"}, {"sha": "9f8cc2f86992f54ffa5d73f15be5cf2c5a10cab9", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -952,8 +952,8 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         ast_visit::walk_ty(self, t);\n     }\n \n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n-        run_lints!(self, check_ident, early_passes, sp, id);\n+    fn visit_ident(&mut self, ident: ast::Ident) {\n+        run_lints!(self, check_ident, early_passes, ident);\n     }\n \n     fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {"}, {"sha": "e8b536d52676382e356f723d64564451376c2e27", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue\n                     }\n                 };\n-                let name = word.name();\n+                let name = word.ident.name;\n                 match store.check_lint_name(&name.as_str()) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span);"}, {"sha": "89a9f3034787b8ed61eeec8a11e54274b86cdc69", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -236,7 +236,7 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n }\n \n pub trait EarlyLintPass: LintPass {\n-    fn check_ident(&mut self, _: &EarlyContext, _: Span, _: ast::Ident) { }\n+    fn check_ident(&mut self, _: &EarlyContext, _: ast::Ident) { }\n     fn check_crate(&mut self, _: &EarlyContext, _: &ast::Crate) { }\n     fn check_crate_post(&mut self, _: &EarlyContext, _: &ast::Crate) { }\n     fn check_mod(&mut self, _: &EarlyContext, _: &ast::Mod, _: Span, _: ast::NodeId) { }"}, {"sha": "8cb87e7e080b8c005fc3f3fdb02854a87081a442", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -1683,12 +1683,12 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n             } else if meta_item.is_meta_item_list() {\n                 let msg = format!(\n                     \"invalid predicate in --cfg command line argument: `{}`\",\n-                    meta_item.name()\n+                    meta_item.ident\n                 );\n                 early_error(ErrorOutputType::default(), &msg)\n             }\n \n-            (meta_item.name(), meta_item.value_str())\n+            (meta_item.ident.name, meta_item.value_str())\n         })\n         .collect::<ast::CrateConfig>()\n }"}, {"sha": "a1018cb946a018eb9bc9a0c41e8db854b46bd855", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(c.name().as_str().to_string(),\n+                    options.contains(&(c.ident.name.as_str().to_string(),\n                                       match c.value_str().map(|s| s.as_str().to_string()) {\n                                           Some(s) => Some(s),\n                                           None => None"}, {"sha": "b920553ec369835e663256d96768b20af7446278", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -2088,8 +2088,8 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n             return Some(index);\n         }\n         let mut ident = name.to_ident();\n-        while ident.ctxt != SyntaxContext::empty() {\n-            ident.ctxt.remove_mark();\n+        while ident.span.ctxt() != SyntaxContext::empty() {\n+            ident.span.remove_mark();\n             if let Some(field) = self.fields.iter().position(|f| f.name.to_ident() == ident) {\n                 return Some(field);\n             }\n@@ -2558,7 +2558,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             LOCAL_CRATE => self.hir.definitions().expansion(scope.index),\n             _ => Mark::root(),\n         };\n-        let scope = match ident.ctxt.adjust(expansion) {\n+        let scope = match ident.span.adjust(expansion) {\n             Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n             None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n             None => self.hir.get_module_parent(block),"}, {"sha": "6f88b0aecb6b674e935619c37aecb9b6be3ae9b5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -1045,7 +1045,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            name,\n+                            ident: ast::Ident::with_empty_ctxt(name),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "70b73ebb8cdeb476f5b978bdf9579a8e017542a7", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -466,11 +466,11 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n+            pprust::NodeIdent(&ast::Ident { name, span }) => {\n                 s.s.space()?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n+                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }\n             pprust::NodeName(&name) => {\n                 s.s.space()?;"}, {"sha": "57311a7b588a049fdf3580c25ae63503475fa286", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n                 Some(word) if value.is_none() =>\n-                    value = Some(word.name().clone()),\n+                    value = Some(word.ident.name),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n                     span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),"}, {"sha": "2cc6708bc034e1dafe570fe975f57f8aee6bac02", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -171,16 +171,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node == fieldpat.node.name {\n+                if let PatKind::Binding(_, _, name, None) = fieldpat.node.pat.node {\n+                    if name.node == fieldpat.node.name {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\",\n-                                              ident.node));\n+                                              name.node));\n                         let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n                         err.span_suggestion_short(subspan,\n                                                   \"remove this\",\n-                                                  format!(\"{}\", ident.node));\n+                                                  format!(\"{}\", name.node));\n                         err.emit();\n                     }\n                 }\n@@ -625,7 +625,7 @@ impl EarlyLintPass for AnonymousParameters {\n                 for arg in sig.decl.inputs.iter() {\n                     match arg.pat.node {\n                         ast::PatKind::Ident(_, ident, None) => {\n-                            if ident.node.name == keywords::Invalid.name() {\n+                            if ident.name == keywords::Invalid.name() {\n                                 cx.span_lint(ANONYMOUS_PARAMETERS,\n                                              arg.pat.span,\n                                              \"use of deprecated anonymous parameter\");"}, {"sha": "bf86f6a69522f07492094c0fc81f28fee8646931", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -377,7 +377,7 @@ impl UnusedImportBraces {\n             let node_ident;\n             match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename) => {\n-                    let orig_ident = items[0].0.prefix.segments.last().unwrap().identifier;\n+                    let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n                     if orig_ident.name == keywords::SelfValue.name() {\n                         return;\n                     } else {"}, {"sha": "9b0e4c64171ca59a2dc19c41b2e45a001ffe3b51", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -467,8 +467,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 mutability: Mutability::Not,\n             };\n             if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n-                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n-                    decl.debug_name = ident.node;\n+                if let hir::PatKind::Binding(_, _, ref name, _) = pat.node {\n+                    decl.debug_name = name.node;\n \n                     let bm = *hir.tables.pat_binding_modes()\n                                         .get(pat.hir_id)"}, {"sha": "454b6cbd27df1e93b20952c3964b32ef8507d02a", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n                 } else {\n                     sess.span_err(\n                         item.span,\n-                        &format!(\"{} attribute requires a path\", item.name()));\n+                        &format!(\"{} attribute requires a path\", item.ident));\n                     return None;\n                 }\n             }"}, {"sha": "c3f41e8ac4827f5970fb9e11dfab2c2f7db695ab", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -466,7 +466,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(_, id, ref ident, ref sub) => {\n+            PatKind::Binding(_, id, ref name, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n@@ -493,14 +493,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     if let ty::TyRef(_, mt) = ty.sty {\n                         ty = mt.ty;\n                     } else {\n-                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n+                        bug!(\"`ref {}` has wrong type {}\", name.node, ty);\n                     }\n                 }\n \n                 PatternKind::Binding {\n                     mutability,\n                     mode,\n-                    name: ident.node,\n+                    name: name.node,\n                     var: id,\n                     ty: var_ty,\n                     subpattern: self.lower_opt_pattern(sub),"}, {"sha": "1866122454c7057cab50c8511a3a1d2775512a0a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -36,19 +36,20 @@ impl<'a> AstValidator<'a> {\n         &self.session.parse_sess.span_diagnostic\n     }\n \n-    fn check_lifetime(&self, lifetime: &Lifetime) {\n+    fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [keywords::UnderscoreLifetime.name(),\n                            keywords::StaticLifetime.name(),\n                            keywords::Invalid.name()];\n-        if !valid_names.contains(&lifetime.ident.name) &&\n-            token::is_reserved_ident(lifetime.ident.without_first_quote()) {\n-            self.err_handler().span_err(lifetime.span, \"lifetimes cannot use keyword names\");\n+        if !valid_names.contains(&ident.name) &&\n+            token::is_reserved_ident(ident.without_first_quote()) {\n+            self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n         }\n     }\n \n-    fn check_label(&self, label: Ident, span: Span) {\n-        if token::is_reserved_ident(label.without_first_quote()) {\n-            self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n+    fn check_label(&self, ident: Ident) {\n+        if token::is_reserved_ident(ident.without_first_quote()) {\n+            self.err_handler()\n+                .span_err(ident.span, &format!(\"invalid label name `{}`\", ident.name));\n         }\n     }\n \n@@ -144,7 +145,7 @@ impl<'a> AstValidator<'a> {\n         let non_lifetime_param_spans : Vec<_> = params.iter()\n             .filter_map(|param| match *param {\n                 GenericParam::Lifetime(_) => None,\n-                GenericParam::Type(ref t) => Some(t.span),\n+                GenericParam::Type(ref t) => Some(t.ident.span),\n             }).collect();\n         if !non_lifetime_param_spans.is_empty() {\n             self.err_handler().span_err(non_lifetime_param_spans,\n@@ -156,7 +157,7 @@ impl<'a> AstValidator<'a> {\n             match *param {\n                 GenericParam::Lifetime(ref l) => {\n                     if !l.bounds.is_empty() {\n-                        let spans : Vec<_> = l.bounds.iter().map(|b| b.span).collect();\n+                        let spans: Vec<_> = l.bounds.iter().map(|b| b.ident.span).collect();\n                         self.err_handler().span_err(spans,\n                             \"lifetime bounds cannot be used in this context\");\n                     }\n@@ -193,7 +194,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 for bound in bounds {\n                     if let RegionTyParamBound(ref lifetime) = *bound {\n                         if any_lifetime_bounds {\n-                            span_err!(self.session, lifetime.span, E0226,\n+                            span_err!(self.session, lifetime.ident.span, E0226,\n                                       \"only a single explicit lifetime bound is permitted\");\n                             break;\n                         }\n@@ -234,12 +235,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_label(&mut self, label: &'a Label) {\n-        self.check_label(label.ident, label.span);\n+        self.check_label(label.ident);\n         visit::walk_label(self, label);\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'a Lifetime) {\n-        self.check_lifetime(lifetime);\n+        self.check_lifetime(lifetime.ident);\n         visit::walk_lifetime(self, lifetime);\n     }\n \n@@ -328,19 +329,19 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::TraitAlias(Generics { ref params, .. }, ..) => {\n                 for param in params {\n                     if let GenericParam::Type(TyParam {\n+                        ident,\n                         ref bounds,\n                         ref default,\n-                        span,\n                         ..\n                     }) = *param\n                     {\n                         if !bounds.is_empty() {\n-                            self.err_handler().span_err(span,\n+                            self.err_handler().span_err(ident.span,\n                                                         \"type parameters on the left side of a \\\n                                                          trait alias cannot be bounded\");\n                         }\n                         if !default.is_none() {\n-                            self.err_handler().span_err(span,\n+                            self.err_handler().span_err(ident.span,\n                                                         \"type parameters on the left side of a \\\n                                                          trait alias cannot have defaults\");\n                         }\n@@ -408,7 +409,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             match (param, seen_non_lifetime_param) {\n                 (&GenericParam::Lifetime(ref ld), true) => {\n                     self.err_handler()\n-                        .span_err(ld.lifetime.span, \"lifetime parameters must be leading\");\n+                        .span_err(ld.lifetime.ident.span, \"lifetime parameters must be leading\");\n                 },\n                 (&GenericParam::Lifetime(_), false) => {}\n                 _ => {\n@@ -417,7 +418,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n \n             if let GenericParam::Type(ref ty_param @ TyParam { default: Some(_), .. }) = *param {\n-                seen_default = Some(ty_param.span);\n+                seen_default = Some(ty_param.ident.span);\n             } else if let Some(span) = seen_default {\n                 self.err_handler()\n                     .span_err(span, \"type parameters with a default must be trailing\");"}, {"sha": "d951a7f1cc1cdb90835c1adc8ecafaede64e1510", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -35,7 +35,6 @@ use rustc::util::nodemap::NodeSet;\n use syntax::ast::{self, CRATE_NODE_ID, Ident};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::SyntaxContext;\n \n use std::cmp;\n use std::mem::replace;\n@@ -495,11 +494,11 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     // Checks that a field in a struct constructor (expression or pattern) is accessible.\n     fn check_field(&mut self,\n-                   use_ctxt: SyntaxContext, // Syntax context of the field name at the use site\n+                   use_ctxt: Span, // Syntax context of the field name at the use site\n                    span: Span, // Span of the field pattern, e.g. `x: 0`\n                    def: &'tcx ty::AdtDef, // Definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // Definition of the field\n-        let ident = Ident { ctxt: use_ctxt.modern(), ..keywords::Invalid.ident() };\n+        let ident = Ident::new(keywords::Invalid.name(), use_ctxt.modern());\n         let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n@@ -573,14 +572,14 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                     for variant_field in &variant.fields {\n                         let field = fields.iter().find(|f| f.name.node == variant_field.name);\n                         let (use_ctxt, span) = match field {\n-                            Some(field) => (field.name.node.to_ident().ctxt, field.span),\n-                            None => (base.span.ctxt(), base.span),\n+                            Some(field) => (field.name.node.to_ident().span, field.span),\n+                            None => (base.span, base.span),\n                         };\n                         self.check_field(use_ctxt, span, adt, variant_field);\n                     }\n                 } else {\n                     for field in fields {\n-                        let use_ctxt = field.name.node.to_ident().ctxt;\n+                        let use_ctxt = field.name.node.to_ident().span;\n                         let field_def = variant.field_named(field.name.node);\n                         self.check_field(use_ctxt, field.span, adt, field_def);\n                     }\n@@ -599,7 +598,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n-                    let use_ctxt = field.node.name.to_ident().ctxt;\n+                    let use_ctxt = field.node.name.to_ident().span;\n                     let field_def = variant.field_named(field.node.name);\n                     self.check_field(use_ctxt, field.span, adt, field_def);\n                 }"}, {"sha": "0542ca6fb24c271c18fa282b459e5a0e6af78140", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -34,7 +34,6 @@ use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind, Variant};\n-use syntax::codemap::respan;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n@@ -115,13 +114,13 @@ impl<'a> Resolver<'a> {\n \n         let mut module_path: Vec<_> = prefix.segments.iter()\n             .chain(path.segments.iter())\n-            .map(|seg| respan(seg.span, seg.identifier))\n+            .map(|seg| seg.ident)\n             .collect();\n \n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename) => {\n                 let mut ident = use_tree.ident();\n-                let mut source = module_path.pop().unwrap().node;\n+                let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n \n                 if nested {\n@@ -130,7 +129,7 @@ impl<'a> Resolver<'a> {\n                         type_ns_only = true;\n \n                         let last_segment = *module_path.last().unwrap();\n-                        if last_segment.node.name == keywords::CrateRoot.name() {\n+                        if last_segment.name == keywords::CrateRoot.name() {\n                             resolve_error(\n                                 self,\n                                 use_tree.span,\n@@ -142,9 +141,9 @@ impl<'a> Resolver<'a> {\n \n                         // Replace `use foo::self;` with `use foo;`\n                         let _ = module_path.pop();\n-                        source = last_segment.node;\n+                        source = last_segment;\n                         if rename.is_none() {\n-                            ident = last_segment.node;\n+                            ident = last_segment;\n                         }\n                     }\n                 } else {\n@@ -157,7 +156,7 @@ impl<'a> Resolver<'a> {\n \n                     // Disallow `use $crate;`\n                     if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n-                        let crate_root = self.resolve_crate_root(source.ctxt, true);\n+                        let crate_root = self.resolve_crate_root(source.span.ctxt(), true);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n@@ -195,12 +194,8 @@ impl<'a> Resolver<'a> {\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 let prefix = ast::Path {\n-                    segments: module_path.iter()\n-                        .map(|s| ast::PathSegment {\n-                            identifier: s.node,\n-                            span: s.span,\n-                            parameters: None,\n-                        })\n+                    segments: module_path.into_iter()\n+                        .map(|ident| ast::PathSegment::from_ident(ident))\n                         .collect(),\n                     span: path.span,\n                 };\n@@ -428,7 +423,7 @@ impl<'a> Resolver<'a> {\n                                        parent: Module<'a>,\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n-        let ident = variant.node.name;\n+        let ident = variant.node.ident;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n@@ -722,7 +717,7 @@ impl<'a> Resolver<'a> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((word.name(), attr.span()));\n+                            imports.imports.push((word.ident.name, attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }\n@@ -736,7 +731,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(names) = attr.meta_item_list() {\n                     for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.reexports.push((word.name(), attr.span()));\n+                            imports.reexports.push((word.ident.name, attr.span()));\n                         } else {\n                             bad_macro_reexport(self, attr.span());\n                         }"}, {"sha": "2bf17cd1317d449d4fcc5d20200ebdda9d30a57b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -41,9 +41,9 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{dummy_spanned, respan, BytePos, CodeMap};\n+use syntax::codemap::{BytePos, CodeMap};\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n-use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n+use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n@@ -851,7 +851,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n \n         // `visit::walk_variant` without the discriminant expression.\n         self.visit_variant_data(&variant.node.data,\n-                                variant.node.name,\n+                                variant.node.ident,\n                                 generics,\n                                 item_id,\n                                 variant.span);\n@@ -1654,8 +1654,8 @@ impl<'a> Resolver<'a> {\n         {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<SpannedIdent> = segments.iter()\n-            .map(|seg| respan(span, Ident::with_empty_ctxt(seg.name)))\n+        let path: Vec<Ident> = segments.iter()\n+            .map(|seg| Ident::new(seg.name, span))\n             .collect();\n         match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n@@ -1912,10 +1912,11 @@ impl<'a> Resolver<'a> {\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident.ctxt = if ident.name == keywords::SelfType.name() {\n-                SyntaxContext::empty() // FIXME(jseyfried) improve `Self` hygiene\n+            ident.span = if ident.name == keywords::SelfType.name() {\n+                // FIXME(jseyfried) improve `Self` hygiene\n+                ident.span.with_ctxt(SyntaxContext::empty())\n             } else {\n-                ident.ctxt.modern()\n+                ident.span.modern()\n             }\n         }\n \n@@ -1931,10 +1932,10 @@ impl<'a> Resolver<'a> {\n \n             module = match self.ribs[ns][i].kind {\n                 ModuleRibKind(module) => module,\n-                MacroDefinition(def) if def == self.macro_def(ident.ctxt) => {\n+                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    ident.ctxt.remove_mark();\n+                    ident.span.remove_mark();\n                     continue\n                 }\n                 _ => continue,\n@@ -1954,9 +1955,9 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident.ctxt = ident.ctxt.modern();\n+        ident.span = ident.span.modern();\n         loop {\n-            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.ctxt), break);\n+            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.span), break);\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n@@ -1980,10 +1981,10 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, ctxt: &mut SyntaxContext)\n+    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n-        if !module.expansion.is_descendant_of(ctxt.outer()) {\n-            return Some(self.macro_def_scope(ctxt.remove_mark()));\n+        if !module.expansion.is_descendant_of(span.ctxt().outer()) {\n+            return Some(self.macro_def_scope(span.remove_mark()));\n         }\n \n         if let ModuleKind::Block(..) = module.kind {\n@@ -1995,7 +1996,7 @@ impl<'a> Resolver<'a> {\n             let parent_expansion = parent.expansion.modern();\n             if module_expansion.is_descendant_of(parent_expansion) &&\n                parent_expansion != module_expansion {\n-                return if parent_expansion.is_descendant_of(ctxt.outer()) {\n+                return if parent_expansion.is_descendant_of(span.ctxt().outer()) {\n                     Some(parent)\n                 } else {\n                     None\n@@ -2016,9 +2017,9 @@ impl<'a> Resolver<'a> {\n                                record_used: bool,\n                                span: Span)\n                                -> Result<&'a NameBinding<'a>, Determinacy> {\n-        ident.ctxt = ident.ctxt.modern();\n+        ident.span = ident.span.modern();\n         let orig_current_module = self.current_module;\n-        if let Some(def) = ident.ctxt.adjust(module.expansion) {\n+        if let Some(def) = ident.span.adjust(module.expansion) {\n             self.current_module = self.macro_def_scope(def);\n         }\n         let result = self.resolve_ident_in_module_unadjusted(\n@@ -2108,8 +2109,8 @@ impl<'a> Resolver<'a> {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 MacroDefinition(def) => {\n-                    if def == self.macro_def(ident.ctxt) {\n-                        ident.ctxt.remove_mark();\n+                    if def == self.macro_def(ident.span.ctxt()) {\n+                        ident.span.remove_mark();\n                     }\n                 }\n                 _ => {\n@@ -2280,9 +2281,9 @@ impl<'a> Resolver<'a> {\n                                 ident.name,\n                                 span,\n                             );\n-                            resolve_error(self, type_parameter.span, err);\n+                            resolve_error(self, type_parameter.ident.span, err);\n                         }\n-                        seen_bindings.entry(ident).or_insert(type_parameter.span);\n+                        seen_bindings.entry(ident).or_insert(type_parameter.ident.span);\n \n                         // plain insert (no renaming)\n                         let def_id = self.definitions.local_def_id(type_parameter.id);\n@@ -2350,7 +2351,7 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = trait_ref.path.segments.iter()\n-                .map(|seg| respan(seg.span, seg.identifier))\n+                .map(|seg| seg.ident)\n                 .collect();\n             let def = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n@@ -2499,7 +2500,7 @@ impl<'a> Resolver<'a> {\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(ident.node, binding_info);\n+                    binding_map.insert(ident, binding_info);\n                 }\n             }\n             true\n@@ -2639,7 +2640,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn fresh_binding(&mut self,\n-                     ident: &SpannedIdent,\n+                     ident: Ident,\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n@@ -2651,14 +2652,14 @@ impl<'a> Resolver<'a> {\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n         let mut def = Def::Local(pat_id);\n-        match bindings.get(&ident.node).cloned() {\n+        match bindings.get(&ident).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n                     self,\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                        &ident.node.name.as_str())\n+                        &ident.name.as_str())\n                 );\n             }\n             Some(..) if pat_src == PatternSource::FnParam => {\n@@ -2667,25 +2668,25 @@ impl<'a> Resolver<'a> {\n                     self,\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                        &ident.node.name.as_str())\n+                        &ident.name.as_str())\n                 );\n             }\n             Some(..) if pat_src == PatternSource::Match ||\n                         pat_src == PatternSource::IfLet ||\n                         pat_src == PatternSource::WhileLet => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n+                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n                                        unexpected pattern source {:?}\", pat_src);\n             }\n             None => {\n                 // A completely fresh binding, add to the lists if it's valid.\n-                if ident.node.name != keywords::Invalid.name() {\n-                    bindings.insert(ident.node, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident.node, def);\n+                if ident.name != keywords::Invalid.name() {\n+                    bindings.insert(ident, outer_pat_id);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, def);\n                 }\n             }\n         }\n@@ -2703,10 +2704,10 @@ impl<'a> Resolver<'a> {\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             match pat.node {\n-                PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n+                PatKind::Ident(bmode, ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS,\n+                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n                                                                       false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n@@ -2718,7 +2719,7 @@ impl<'a> Resolver<'a> {\n                             Def::Const(..) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n-                                self.record_use(ident.node, ValueNS, binding.unwrap(), ident.span);\n+                                self.record_use(ident, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -2732,7 +2733,7 @@ impl<'a> Resolver<'a> {\n                                     self,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), ident.node.name, binding.unwrap())\n+                                        pat_src.descr(), ident.name, binding.unwrap())\n                                 );\n                                 None\n                             }\n@@ -2785,15 +2786,15 @@ impl<'a> Resolver<'a> {\n                           source: PathSource)\n                           -> PathResolution {\n         let segments = &path.segments.iter()\n-            .map(|seg| respan(seg.span, seg.identifier))\n+            .map(|seg| seg.ident)\n             .collect::<Vec<_>>();\n         self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[SpannedIdent],\n+                                   path: &[Ident],\n                                    span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n@@ -2813,11 +2814,11 @@ impl<'a> Resolver<'a> {\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_str = path[path.len() - 1].node;\n+                let item_str = path[path.len() - 1];\n                 let item_span = path[path.len() - 1].span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (format!(\"\"), format!(\"this scope\"))\n-                } else if path.len() == 2 && path[0].node.name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -2851,10 +2852,10 @@ impl<'a> Resolver<'a> {\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = *path.last().unwrap();\n-            let candidates = this.lookup_import_candidates(ident.node.name, ns, is_expected);\n+            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n-                    this.lookup_import_candidates(ident.node.name, ns, is_enum_variant);\n+                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -2872,8 +2873,8 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(ident.node, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].node.ctxt, span);\n+                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n+                    let self_is_available = this.self_value_is_available(path[0].span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion(span, \"try\",\n@@ -2918,12 +2919,12 @@ impl<'a> Resolver<'a> {\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n                             err.span_label(parent.span, format!(\"did you mean `{}::{}`?\",\n-                                                                 path_str, ident.node));\n+                                                                 path_str, ident));\n                             return (err, candidates);\n                         }\n                         ExprKind::MethodCall(ref segment, ..) => {\n                             err.span_label(parent.span, format!(\"did you mean `{}::{}(...)`?\",\n-                                                                 path_str, segment.identifier));\n+                                                                 path_str, segment.ident));\n                             return (err, candidates);\n                         }\n                         _ => {}\n@@ -3027,7 +3028,7 @@ impl<'a> Resolver<'a> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = path.last().unwrap().node;\n+                    let item_name = *path.last().unwrap();\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -3084,17 +3085,17 @@ impl<'a> Resolver<'a> {\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, ctxt: SyntaxContext, span: Span) -> bool {\n-        let ident = Ident { name: keywords::SelfValue.name(), ctxt: ctxt };\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, span);\n+    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n+        let ident = Ident::new(keywords::SelfValue.name(), self_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, path_span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[SpannedIdent],\n+                              path: &[Ident],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -3114,10 +3115,10 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_global = self.global_macros.get(&path[0].node.name).cloned()\n+        let is_global = self.global_macros.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n         if primary_ns != MacroNS && (is_global ||\n-                                     self.macro_names.contains(&path[0].node.modern())) {\n+                                     self.macro_names.contains(&path[0].modern())) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -3130,7 +3131,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[SpannedIdent],\n+                     path: &[Ident],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool)\n@@ -3171,8 +3172,8 @@ impl<'a> Resolver<'a> {\n             PathResult::Module(..) | PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n-                           .contains_key(&path[0].node.name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].node.name];\n+                           .contains_key(&path[0].name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n@@ -3185,8 +3186,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].node.name != keywords::CrateRoot.name() &&\n-           path[0].node.name != keywords::DollarCrate.name() {\n+           path[0].name != keywords::CrateRoot.name() &&\n+           path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n@@ -3204,7 +3205,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_path(&mut self,\n-                    path: &[SpannedIdent],\n+                    path: &[Ident],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n                     record_used: bool,\n                     path_span: Span)\n@@ -3216,14 +3217,14 @@ impl<'a> Resolver<'a> {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n-            let name = ident.node.name;\n+            let name = ident.name;\n \n             if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n-                let mut ctxt = ident.node.ctxt.modern();\n+                let mut ctxt = ident.span.ctxt().modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n             } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n-                let mut ctxt = ident.node.ctxt.modern();\n+                let mut ctxt = ident.span.ctxt().modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n                     _ => module.unwrap(),\n@@ -3243,16 +3244,16 @@ impl<'a> Resolver<'a> {\n             if ns == TypeNS {\n                 if (i == 0 && name == keywords::CrateRoot.name()) ||\n                    (i == 1 && name == keywords::Crate.name() &&\n-                              path[0].node.name == keywords::CrateRoot.name()) {\n+                              path[0].name == keywords::CrateRoot.name()) {\n                     // `::a::b` or `::crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.ctxt, false));\n+                    module = Some(self.resolve_crate_root(ident.span.ctxt(), false));\n                     continue\n                 } else if i == 0 && name == keywords::DollarCrate.name() {\n                     // `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.ctxt, true));\n+                    module = Some(self.resolve_crate_root(ident.span.ctxt(), true));\n                     continue\n-                } else if i == 1 && !token::is_path_segment_keyword(ident.node) {\n-                    let prev_name = path[0].node.name;\n+                } else if i == 1 && !token::is_path_segment_keyword(ident) {\n+                    let prev_name = path[0].name;\n                     if prev_name == keywords::Extern.name() ||\n                        prev_name == keywords::CrateRoot.name() &&\n                        self.session.features_untracked().extern_absolute_paths {\n@@ -3275,13 +3276,13 @@ impl<'a> Resolver<'a> {\n                name == keywords::Super.name() && i != 0 ||\n                name == keywords::Extern.name() && i != 0 ||\n                name == keywords::Crate.name() && i != 1 &&\n-                    path[0].node.name != keywords::CrateRoot.name() {\n+                    path[0].name != keywords::CrateRoot.name() {\n                 let name_str = if name == keywords::CrateRoot.name() {\n                     format!(\"crate root\")\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].node.name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].name == keywords::CrateRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else if i == 0 && name == keywords::Crate.name() {\n                     format!(\"{} can only be used in absolute paths\", name_str)\n@@ -3292,12 +3293,12 @@ impl<'a> Resolver<'a> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident.node, ns, false, record_used, path_span)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident.node, ns, record_used, path_span)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident.node, ns, record_used, path_span) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n@@ -3323,7 +3324,7 @@ impl<'a> Resolver<'a> {\n                         ));\n                     } else {\n                         return PathResult::Failed(ident.span,\n-                                                  format!(\"Not a module `{}`\", ident.node),\n+                                                  format!(\"Not a module `{}`\", ident),\n                                                   is_last);\n                     }\n                 }\n@@ -3344,12 +3345,12 @@ impl<'a> Resolver<'a> {\n                         if let Some(candidate) = candidates.get(0) {\n                             format!(\"Did you mean `{}`?\", candidate.path)\n                         } else {\n-                            format!(\"Maybe a missing `extern crate {};`?\", ident.node)\n+                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n                         }\n                     } else if i == 0 {\n-                        format!(\"Use of undeclared type or module `{}`\", ident.node)\n+                        format!(\"Use of undeclared type or module `{}`\", ident)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident.node, path[i - 1].node)\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n                     };\n                     return PathResult::Failed(ident.span, msg, is_last);\n                 }\n@@ -3515,7 +3516,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[SpannedIdent],\n+                                       path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -3576,7 +3577,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = path[path.len() - 1].node.name;\n+        let name = path[path.len() - 1].name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -3633,7 +3634,7 @@ impl<'a> Resolver<'a> {\n                         });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n-                                      label.span,\n+                                      label.ident.span,\n                                       ResolutionError::UndeclaredLabel(&label.ident.name.as_str(),\n                                                                        close_match));\n                     }\n@@ -3738,18 +3739,18 @@ impl<'a> Resolver<'a> {\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprKind::Field(_, name) => {\n+            ExprKind::Field(_, ident) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node, ValueNS);\n+                let traits = self.get_traits_containing_item(ident, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(segment.identifier, ValueNS);\n+                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3771,12 +3772,12 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident.ctxt = ident.ctxt.modern();\n+        ident.span = ident.span.modern();\n         let mut search_module = self.current_module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n             search_module =\n-                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.ctxt), break);\n+                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.span), break);\n         }\n \n         if let Some(prelude) = self.prelude {\n@@ -3808,7 +3809,7 @@ impl<'a> Resolver<'a> {\n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n             let module = binding.module().unwrap();\n             let mut ident = ident;\n-            if ident.ctxt.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n+            if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n                 continue\n             }\n             if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)\n@@ -3864,7 +3865,7 @@ impl<'a> Resolver<'a> {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n                         let mut segms = path_segments.clone();\n-                        segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                        segms.push(ast::PathSegment::from_ident(ident));\n                         let path = Path {\n                             span: name_binding.span,\n                             segments: segms,\n@@ -3886,7 +3887,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3925,7 +3926,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n                     if module.def() == Some(module_def) {\n                         let path = Path {\n                             span: name_binding.span,\n@@ -3957,7 +3958,7 @@ impl<'a> Resolver<'a> {\n             enum_module.for_each_child_stable(|ident, _, name_binding| {\n                 if let Def::Variant(..) = name_binding.def() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n-                    segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                    segms.push(ast::PathSegment::from_ident(ident));\n                     variants.push(Path {\n                         span: name_binding.span,\n                         segments: segms,\n@@ -3987,7 +3988,7 @@ impl<'a> Resolver<'a> {\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // Visibilities are resolved as global by default, add starting root segment.\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n-                    .map(|seg| respan(seg.span, seg.identifier))\n+                    .map(|seg| seg.ident)\n                     .collect::<Vec<_>>();\n                 let def = self.smart_resolve_path_fragment(id, None, &segments, path.span,\n                                                            PathSource::Visibility).base_def();\n@@ -4221,7 +4222,7 @@ impl<'a> Resolver<'a> {\n             if attr.path.segments.len() > 1 {\n                 continue\n             }\n-            let ident = attr.path.segments[0].identifier;\n+            let ident = attr.path.segments[0].ident;\n             let result = self.resolve_lexical_macro_path_segment(ident,\n                                                                  MacroNS,\n                                                                  false,\n@@ -4243,30 +4244,30 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-fn is_self_type(path: &[SpannedIdent], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].node.name == keywords::SelfType.name()\n+fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[SpannedIdent], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].node.name == keywords::SelfValue.name()\n+fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n }\n \n-fn names_to_string(idents: &[SpannedIdent]) -> String {\n+fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n     for (i, ident) in idents.iter()\n-                            .filter(|i| i.node.name != keywords::CrateRoot.name())\n+                            .filter(|ident| ident.name != keywords::CrateRoot.name())\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");\n         }\n-        result.push_str(&ident.node.name.as_str());\n+        result.push_str(&ident.name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path) -> String {\n     names_to_string(&path.segments.iter()\n-                        .map(|seg| respan(seg.span, seg.identifier))\n+                        .map(|seg| seg.ident)\n                         .collect::<Vec<_>>())\n }\n \n@@ -4355,7 +4356,6 @@ fn module_to_string(module: Module) -> Option<String> {\n     }\n     Some(names_to_string(&names.into_iter()\n                         .rev()\n-                        .map(|n| dummy_spanned(n))\n                         .collect::<Vec<_>>()))\n }\n "}, {"sha": "0388465b485cb5527727dc50045c16db5ed16351", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -20,7 +20,6 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use syntax::ast::{self, Name, Ident};\n use syntax::attr::{self, HasAttrs};\n-use syntax::codemap::respan;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n@@ -137,15 +136,15 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n-                let ident = path.segments[0].identifier;\n+                let ident = path.segments[0].ident;\n                 if ident.name == keywords::DollarCrate.name() {\n-                    path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_root(ident.ctxt, true);\n+                    path.segments[0].ident.name = keywords::CrateRoot.name();\n+                    let module = self.0.resolve_crate_root(ident.span.ctxt(), true);\n                     if !module.is_local() {\n-                        let span = path.segments[0].span;\n+                        let span = path.segments[0].ident.span;\n                         path.segments.insert(1, match module.kind {\n                             ModuleKind::Def(_, name) => ast::PathSegment::from_ident(\n-                                ast::Ident::with_empty_ctxt(name), span\n+                                ast::Ident::with_empty_ctxt(name).with_span_pos(span)\n                             ),\n                             _ => unreachable!(),\n                         })\n@@ -249,7 +248,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     if traits[j].segments.len() > 1 {\n                         continue\n                     }\n-                    let trait_name = traits[j].segments[0].identifier.name;\n+                    let trait_name = traits[j].segments[0].ident.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n                     if !self.global_macros.contains_key(&legacy_name) {\n                         continue\n@@ -268,7 +267,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                                 if k > 0 {\n                                     tokens.push(TokenTree::Token(path.span, Token::ModSep).into());\n                                 }\n-                                let tok = Token::from_ast_ident(segment.identifier);\n+                                let tok = Token::from_ast_ident(segment.ident);\n                                 tokens.push(TokenTree::Token(path.span, tok).into());\n                             }\n                         }\n@@ -278,7 +277,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                         }).into();\n                     }\n                     return Some(ast::Attribute {\n-                        path: ast::Path::from_ident(span, Ident::with_empty_ctxt(legacy_name)),\n+                        path: ast::Path::from_ident(Ident::new(legacy_name, span)),\n                         tokens: TokenStream::empty(),\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n@@ -365,7 +364,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let attr_name = match path.segments.len() {\n-            1 => path.segments[0].identifier.name,\n+            1 => path.segments[0].ident.name,\n             _ => return Err(determinacy),\n         };\n         for path in traits {\n@@ -413,7 +412,7 @@ impl<'a> Resolver<'a> {\n                                   kind: MacroKind, force: bool)\n                                   -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.identifier)).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&scope];\n         let module = invocation.module.get();\n         self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n@@ -447,19 +446,16 @@ impl<'a> Resolver<'a> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            let path = path.iter().map(|p| p.node).collect::<Vec<_>>();\n             self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope,\n-                                                          path[0].node,\n-                                                          false);\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0].node, MacroNS, false, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -470,7 +466,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0].node, span, kind));\n+            .push((scope, path[0], span, kind));\n \n         result\n     }\n@@ -534,7 +530,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             module = match module {\n-                Some(module) => self.hygienic_lexical_parent(module, &mut ident.ctxt),\n+                Some(module) => self.hygienic_lexical_parent(module, &mut ident.span),\n                 None => return potential_illegal_shadower,\n             }\n         }\n@@ -608,7 +604,6 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            let path = path.iter().map(|p| respan(span, *p)).collect::<Vec<_>>();\n             match self.resolve_path(&path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n@@ -684,8 +679,8 @@ impl<'a> Resolver<'a> {\n                     false\n                 }\n             };\n-            let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![respan(span, ident)], MacroNS, is_macro, span)\n+            let ident = Ident::new(Symbol::intern(name), span);\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "87738f7b79be530e6ecb482d10a4a26a5da90ca9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -24,7 +24,7 @@ use rustc::hir::def::*;\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n-use syntax::ast::{Ident, Name, SpannedIdent, NodeId};\n+use syntax::ast::{Ident, Name, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::parse::token;\n@@ -58,7 +58,7 @@ pub enum ImportDirectiveSubclass<'a> {\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     pub parent: Module<'a>,\n-    pub module_path: Vec<SpannedIdent>,\n+    pub module_path: Vec<Ident>,\n     pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub span: Span,\n@@ -238,7 +238,7 @@ impl<'a> Resolver<'a> {\n             }\n             let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n-            match ident.ctxt.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n+            match ident.span.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n@@ -257,7 +257,7 @@ impl<'a> Resolver<'a> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<SpannedIdent>,\n+                                module_path: Vec<Ident>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -398,7 +398,7 @@ impl<'a> Resolver<'a> {\n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n             let mut ident = ident.modern();\n-            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion,\n                                                              directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent,\n@@ -606,9 +606,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // FIXME: Last path segment is treated specially in import resolution, so extern crate\n         // mode for absolute paths needs some special support for single-segment imports.\n-        if module_path.len() == 1 && (module_path[0].node.name == keywords::CrateRoot.name() ||\n-                                      module_path[0].node.name == keywords::Extern.name()) {\n-            let is_extern = module_path[0].node.name == keywords::Extern.name() ||\n+        if module_path.len() == 1 && (module_path[0].name == keywords::CrateRoot.name() ||\n+                                      module_path[0].name == keywords::Extern.name()) {\n+            let is_extern = module_path[0].name == keywords::Extern.name() ||\n                             self.session.features_untracked().extern_absolute_paths;\n             match directive.subclass {\n                 GlobImport { .. } if is_extern => {\n@@ -617,13 +617,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 SingleImport { source, target, .. } => {\n                     let crate_root = if source.name == keywords::Crate.name() &&\n-                                        module_path[0].node.name != keywords::Extern.name() {\n+                                        module_path[0].name != keywords::Extern.name() {\n                         if target.name == keywords::Crate.name() {\n                             return Some((directive.span,\n                                          \"crate root imports need to be explicitly named: \\\n                                           `use crate as name;`\".to_string()));\n                         } else {\n-                            Some(self.resolve_crate_root(source.ctxt.modern(), false))\n+                            Some(self.resolve_crate_root(source.span.ctxt().modern(), false))\n                         }\n                     } else if is_extern && !token::is_path_segment_keyword(source) {\n                         let crate_id =\n@@ -669,9 +669,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 let is_special = |ident| token::is_path_segment_keyword(ident) &&\n                                          ident.name != keywords::CrateRoot.name();\n-                if !self_path.is_empty() && !is_special(self_path[0].node) &&\n-                   !(self_path.len() > 1 && is_special(self_path[1].node)) {\n-                    self_path[0].node.name = keywords::SelfValue.name();\n+                if !self_path.is_empty() && !is_special(self_path[0]) &&\n+                   !(self_path.len() > 1 && is_special(self_path[1])) {\n+                    self_path[0].name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n@@ -860,7 +860,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n-            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion,\n                                                              directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => self.current_module,\n@@ -957,7 +957,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             let resolutions = imported_module.parent.expect(\"parent should exist\")\n                                 .resolutions.borrow();\n                             let enum_path_segment_index = directive.module_path.len() - 1;\n-                            let enum_ident = directive.module_path[enum_path_segment_index].node;\n+                            let enum_ident = directive.module_path[enum_path_segment_index];\n \n                             let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n                                 .expect(\"resolution should exist\");\n@@ -1011,12 +1011,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(names: &[SpannedIdent],\n+fn import_path_to_string(names: &[Ident],\n                          subclass: &ImportDirectiveSubclass,\n                          span: Span) -> String {\n     let pos = names.iter()\n-        .position(|p| span == p.span && p.node.name != keywords::CrateRoot.name());\n-    let global = !names.is_empty() && names[0].node.name == keywords::CrateRoot.name();\n+        .position(|p| span == p.span && p.name != keywords::CrateRoot.name());\n+    let global = !names.is_empty() && names[0].name == keywords::CrateRoot.name();\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n         names_to_string(names)"}, {"sha": "ed8904b34a214dd8180bedc133feef320aad1512", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -183,15 +183,15 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         for (i, seg) in segments.iter().enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {\n-                span: seg.span, // span for the last segment\n+                span: seg.ident.span, // span for the last segment\n                 segments: segs,\n             };\n             let qualname = if i == 0 && path.is_global() {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n                 path_to_string(&sub_path)\n             };\n-            result.push((seg.span, qualname));\n+            result.push((seg.ident.span, qualname));\n             segs = sub_path.segments;\n         }\n \n@@ -351,14 +351,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n \n-            for (id, i, sp, ..) in collector.collected_idents {\n+            for (id, ident, ..) in collector.collected_idents {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n-                let sub_span = span_utils.span_for_last_ident(sp);\n-                if !self.span.filter_generated(sub_span, sp) {\n+                let sub_span = span_utils.span_for_last_ident(ident.span);\n+                if !self.span.filter_generated(sub_span, ident.span) {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n@@ -371,8 +371,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                             kind: DefKind::Local,\n                             id,\n                             span,\n-                            name: i.to_string(),\n-                            qualname: format!(\"{}::{}\", qualname, i.to_string()),\n+                            name: ident.to_string(),\n+                            qualname: format!(\"{}::{}\", qualname, ident.to_string()),\n                             value: typ,\n                             parent: None,\n                             children: vec![],\n@@ -447,7 +447,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         for param in &generics.params {\n             if let ast::GenericParam::Type(ref ty_param) = *param {\n-                let param_ss = ty_param.span;\n+                let param_ss = ty_param.ident.span;\n                 let name = escape(self.span.snippet(param_ss));\n                 // Append $id to name to make sure each one is unique\n                 let qualname = format!(\"{}::{}${}\", prefix, name, id);\n@@ -663,7 +663,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let access = access_from!(self.save_ctxt, item);\n \n         for variant in &enum_definition.variants {\n-            let name = variant.node.name.name.to_string();\n+            let name = variant.node.ident.name.to_string();\n             let mut qualname = enum_data.qualname.clone();\n             qualname.push_str(\"::\");\n             qualname.push_str(&name);\n@@ -1040,11 +1040,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // process collected paths\n-        for (id, i, sp, immut) in collector.collected_idents {\n+        for (id, ident, immut) in collector.collected_idents {\n             match self.save_ctxt.get_path_def(id) {\n                 HirDef::Local(id) => {\n                     let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(sp).to_string()\n+                        self.span.snippet(ident.span).to_string()\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n@@ -1057,10 +1057,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n-                    if !self.span.filter_generated(Some(sp), sp) {\n-                        let qualname = format!(\"{}${}\", i.to_string(), id);\n+                    if !self.span.filter_generated(Some(ident.span), ident.span) {\n+                        let qualname = format!(\"{}${}\", ident.to_string(), id);\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n-                        let span = self.span_from_span(sp);\n+                        let span = self.span_from_span(ident.span);\n \n                         self.dumper.dump_def(\n                             &Access {\n@@ -1071,7 +1071,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                                 kind: DefKind::Local,\n                                 id,\n                                 span,\n-                                name: i.to_string(),\n+                                name: ident.to_string(),\n                                 qualname,\n                                 value: typ,\n                                 parent: None,\n@@ -1093,7 +1093,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 HirDef::TyAlias(..) |\n                 HirDef::AssociatedTy(..) |\n                 HirDef::SelfTy(..) => {\n-                    self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n+                    self.dump_path_ref(id, &ast::Path::from_ident(ident));\n                 }\n                 def => error!(\n                     \"unexpected definition kind when processing collected idents: {:?}\",\n@@ -1114,7 +1114,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         collector.visit_pat(&p);\n         self.visit_pat(&p);\n \n-        for (id, i, sp, immut) in collector.collected_idents {\n+        for (id, ident, immut) in collector.collected_idents {\n             let mut value = match immut {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n@@ -1134,10 +1134,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(sp);\n+            let sub_span = self.span.span_for_last_ident(ident.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(sub_span, sp) {\n-                let qualname = format!(\"{}${}\", i.to_string(), id);\n+            if !self.span.filter_generated(sub_span, ident.span) {\n+                let qualname = format!(\"{}${}\", ident.to_string(), id);\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n@@ -1150,7 +1150,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         kind: DefKind::Local,\n                         id,\n                         span,\n-                        name: i.to_string(),\n+                        name: ident.to_string(),\n                         qualname,\n                         value: typ,\n                         parent: None,"}, {"sha": "4f46fb3545b15833f314e6d8ae1dda38067ac28a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -297,7 +297,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, sub_span, item.span, None);\n                 let variants_str = def.variants\n                     .iter()\n-                    .map(|v| v.node.name.to_string())\n+                    .map(|v| v.node.ident.to_string())\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{}::{{{}}}\", name, variants_str);\n@@ -554,7 +554,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 };\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n-                        let f = def.non_enum_variant().field_named(ident.node.name);\n+                        let f = def.non_enum_variant().field_named(ident.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n                         let span = self.span_from_span(sub_span.unwrap());\n@@ -603,7 +603,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n-                let sub_span = seg.span;\n+                let sub_span = seg.ident.span;\n                 filter!(self.span_utils, Some(sub_span), expr.span, None);\n                 let span = self.span_from_span(sub_span);\n                 Some(Data::RefData(Ref {\n@@ -707,7 +707,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let def = self.get_path_def(id);\n         let last_seg = &path.segments[path.segments.len() - 1];\n-        let sub_span = last_seg.span;\n+        let sub_span = last_seg.ident.span;\n         filter!(self.span_utils, Some(sub_span), path.span, None);\n         match def {\n             HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n@@ -817,7 +817,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         field_ref: &ast::Field,\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n-        let f = variant.find_field_named(field_ref.ident.node.name)?;\n+        let f = variant.find_field_named(field_ref.ident.name)?;\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n         filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n@@ -961,7 +961,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n // variables (idents) from patterns.\n struct PathCollector<'l> {\n     collected_paths: Vec<(NodeId, &'l ast::Path)>,\n-    collected_idents: Vec<(NodeId, ast::Ident, Span, ast::Mutability)>,\n+    collected_idents: Vec<(NodeId, ast::Ident, ast::Mutability)>,\n }\n \n impl<'l> PathCollector<'l> {\n@@ -982,12 +982,12 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n             PatKind::TupleStruct(ref path, ..) | PatKind::Path(_, ref path) => {\n                 self.collected_paths.push((p.id, path));\n             }\n-            PatKind::Ident(bm, ref path1, _) => {\n+            PatKind::Ident(bm, ident, _) => {\n                 debug!(\n                     \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n-                    path1.node,\n+                    ident,\n                     p.span,\n-                    path1.span\n+                    ident.span\n                 );\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n@@ -997,7 +997,7 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 self.collected_idents\n-                    .push((p.id, path1.node, path1.span, immut));\n+                    .push((p.id, ident, immut));\n             }\n             _ => {}\n         }"}, {"sha": "a9df898efb6350659e4191eaa504539763c20efa", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -671,7 +671,7 @@ impl Sig for ast::StructField {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n         let mut text = String::new();\n         let mut defs = None;\n-        if let Some(ref ident) = self.ident {\n+        if let Some(ident) = self.ident {\n             text.push_str(&ident.to_string());\n             defs = Some(SigElement {\n                 id: id_from_node_id(self.id, scx),\n@@ -692,7 +692,7 @@ impl Sig for ast::StructField {\n \n impl Sig for ast::Variant_ {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n-        let mut text = self.name.to_string();\n+        let mut text = self.ident.to_string();\n         match self.data {\n             ast::VariantData::Struct(ref fields, id) => {\n                 let name_def = SigElement {"}, {"sha": "6d85e949d6bd8506edf2156cbcd5c7b9d0fdf0d9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -3213,10 +3213,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n-                    let ident = ast::Ident {\n-                        name: Symbol::intern(&idx.node.to_string()),\n-                        ctxt: idx.span.ctxt().modern(),\n-                    };\n+                    let ident =\n+                        ast::Ident::new(Symbol::intern(&idx.node.to_string()), idx.span.modern());\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;"}, {"sha": "a87e1df5efc2c1d8258d68557294daf518e82982", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             let mut segments = path.segments.into_vec();\n             let last = segments.pop().unwrap();\n \n-            let real_name = name.as_ref().map(|n| Symbol::from(n.as_str()));\n+            let real_name = name.map(|name| Symbol::intern(&name));\n \n             segments.push(hir::PathSegment::new(\n                 real_name.unwrap_or(last.name),"}, {"sha": "7f89b3e6b3a2aad64c6f3a343f8b8e6bfc2d2532", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -67,7 +67,7 @@ impl Cfg {\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n     pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n-        let name = cfg.name();\n+        let name = cfg.ident.name;\n         match cfg.node {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n             MetaItemKind::NameValue(ref lit) => match lit.node {\n@@ -562,14 +562,14 @@ mod test {\n     fn test_parse_ok() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::Word,\n                 span: DUMMY_SP,\n             };\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n                     Symbol::intern(\"done\"),\n                     StrStyle::Cooked,\n@@ -579,15 +579,15 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -597,15 +597,15 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"any\"),\n+                ident: Ident::from_str(\"any\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -615,10 +615,10 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -628,26 +628,26 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"any\"),\n+                        ident: Ident::from_str(\"any\"),\n                         node: MetaItemKind::List(vec![\n                             dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                name: Symbol::intern(\"a\"),\n+                                ident: Ident::from_str(\"a\"),\n                                 node: MetaItemKind::Word,\n                                 span: DUMMY_SP,\n                             })),\n                             dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                name: Symbol::intern(\"all\"),\n+                                ident: Ident::from_str(\"all\"),\n                                 node: MetaItemKind::List(vec![\n                                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        name: Symbol::intern(\"b\"),\n+                                        ident: Ident::from_str(\"b\"),\n                                         node: MetaItemKind::Word,\n                                         span: DUMMY_SP,\n                                     })),\n                                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        name: Symbol::intern(\"c\"),\n+                                        ident: Ident::from_str(\"c\"),\n                                         node: MetaItemKind::Word,\n                                         span: DUMMY_SP,\n                                     })),\n@@ -663,20 +663,20 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"c\"),\n+                        ident: Ident::from_str(\"c\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -691,22 +691,22 @@ mod test {\n     fn test_parse_err() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                name: Symbol::intern(\"foo\"),\n+                ident: Ident::from_str(\"foo\"),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -716,17 +716,17 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![]),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"foo\"),\n+                ident: Ident::from_str(\"foo\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -736,15 +736,15 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"foo\"),\n+                        ident: Ident::from_str(\"foo\"),\n                         node: MetaItemKind::List(vec![]),\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -754,15 +754,15 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"any\"),\n+                ident: Ident::from_str(\"any\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"foo\"),\n+                        ident: Ident::from_str(\"foo\"),\n                         node: MetaItemKind::List(vec![]),\n                         span: DUMMY_SP,\n                     })),\n@@ -772,10 +772,10 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"foo\"),\n+                        ident: Ident::from_str(\"foo\"),\n                         node: MetaItemKind::List(vec![]),\n                         span: DUMMY_SP,\n                     })),"}, {"sha": "b57c9589afabc7792c3d1d7a782817d010fa0c53", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -21,9 +21,9 @@ pub use self::Visibility::*;\n \n use syntax;\n use syntax::abi::Abi;\n-use syntax::ast::{self, AttrStyle};\n+use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n-use syntax::codemap::Spanned;\n+use syntax::codemap::{dummy_spanned, Spanned};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n@@ -840,7 +840,8 @@ impl Attributes {\n         for attr in attrs.lists(\"target_feature\") {\n             if attr.check_name(\"enable\") {\n                 if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(\"target_feature\".into(), feat);\n+                    let meta = attr::mk_name_value_item_str(Ident::from_str(\"target_feature\"),\n+                                                            dummy_spanned(feat));\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;\n                     }\n@@ -1146,16 +1147,8 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     use syntax::ext::hygiene::Mark;\n-    let segment = ast::PathSegment {\n-        identifier: ast::Ident::from_str(path_str),\n-        span: DUMMY_SP,\n-        parameters: None,\n-    };\n-    let path = ast::Path {\n-        span: DUMMY_SP,\n-        segments: vec![segment],\n-    };\n-\n+    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n+    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     let mut resolver = cx.resolver.borrow_mut();\n     let mark = Mark::root();\n     let res = resolver\n@@ -1166,7 +1159,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n         } else {\n             None\n         }\n-    } else if let Some(def) = resolver.all_macros.get(&path_str.into()) {\n+    } else if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n         Some(*def)\n     } else {\n         None"}, {"sha": "1c9ea2618411347e78c22f2d50625f0dfdf6f351", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -2966,7 +2966,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let name = attr.name();\n+    let name = attr.ident.name;\n \n     if attr.is_word() {\n         Some(format!(\"{}\", name))"}, {"sha": "e7900af7f121dca4869c8a32cbfb3ca4e9402000", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -36,7 +36,6 @@ use std::u32;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Label {\n     pub ident: Ident,\n-    pub span: Span,\n }\n \n impl fmt::Debug for Label {\n@@ -48,7 +47,6 @@ impl fmt::Debug for Label {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n-    pub span: Span,\n     pub ident: Ident,\n }\n \n@@ -82,7 +80,7 @@ pub struct Path {\n \n impl<'a> PartialEq<&'a str> for Path {\n     fn eq(&self, string: &&'a str) -> bool {\n-        self.segments.len() == 1 && self.segments[0].identifier.name == *string\n+        self.segments.len() == 1 && self.segments[0].ident.name == *string\n     }\n }\n \n@@ -101,17 +99,14 @@ impl fmt::Display for Path {\n impl Path {\n     // convert a span and an identifier to the corresponding\n     // 1-segment path\n-    pub fn from_ident(s: Span, identifier: Ident) -> Path {\n-        Path {\n-            span: s,\n-            segments: vec![PathSegment::from_ident(identifier, s)],\n-        }\n+    pub fn from_ident(ident: Ident) -> Path {\n+        Path { segments: vec![PathSegment::from_ident(ident)], span: ident.span }\n     }\n \n     // Make a \"crate root\" segment for this path unless it already has it\n     // or starts with something like `self`/`super`/`$crate`/etc.\n     pub fn make_root(&self) -> Option<PathSegment> {\n-        if let Some(ident) = self.segments.get(0).map(|seg| seg.identifier) {\n+        if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n             if ::parse::token::is_path_segment_keyword(ident) &&\n                ident.name != keywords::Crate.name() {\n                 return None;\n@@ -121,7 +116,7 @@ impl Path {\n     }\n \n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].identifier.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n     }\n }\n \n@@ -131,9 +126,7 @@ impl Path {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n-    pub identifier: Ident,\n-    /// Span of the segment identifier.\n-    pub span: Span,\n+    pub ident: Ident,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`.\n@@ -145,15 +138,11 @@ pub struct PathSegment {\n }\n \n impl PathSegment {\n-    pub fn from_ident(ident: Ident, span: Span) -> Self {\n-        PathSegment { identifier: ident, span: span, parameters: None }\n+    pub fn from_ident(ident: Ident) -> Self {\n+        PathSegment { ident, parameters: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n-        PathSegment {\n-            identifier: Ident { ctxt: span.ctxt(), ..keywords::CrateRoot.ident() },\n-            span,\n-            parameters: None,\n-        }\n+        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n     }\n }\n \n@@ -297,7 +286,7 @@ impl TyParamBound {\n     pub fn span(&self) -> Span {\n         match self {\n             &TraitTyParamBound(ref t, ..) => t.span,\n-            &RegionTyParamBound(ref l) => l.span,\n+            &RegionTyParamBound(ref l) => l.ident.span,\n         }\n     }\n }\n@@ -319,7 +308,6 @@ pub struct TyParam {\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n-    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -370,7 +358,7 @@ impl Generics {\n         for param in &self.params {\n             if let GenericParam::Type(ref t) = *param {\n                 if t.ident.name == name {\n-                    return Some(t.span);\n+                    return Some(t.ident.span);\n                 }\n             }\n         }\n@@ -489,7 +477,7 @@ pub enum NestedMetaItemKind {\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MetaItem {\n-    pub name: Name,\n+    pub ident: Ident,\n     pub node: MetaItemKind,\n     pub span: Span,\n }\n@@ -545,7 +533,7 @@ impl Pat {\n         let node = match &self.node {\n             PatKind::Wild => TyKind::Infer,\n             PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) =>\n-                TyKind::Path(None, Path::from_ident(ident.span, ident.node)),\n+                TyKind::Path(None, Path::from_ident(*ident)),\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             PatKind::Mac(mac) => TyKind::Mac(mac.clone()),\n             PatKind::Ref(pat, mutbl) =>\n@@ -642,7 +630,7 @@ pub enum PatKind {\n     /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n     /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n     /// during name resolution.\n-    Ident(BindingMode, SpannedIdent, Option<P<Pat>>),\n+    Ident(BindingMode, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -914,15 +902,13 @@ pub struct Arm {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n-    pub ident: SpannedIdent,\n+    pub ident: Ident,\n     pub expr: P<Expr>,\n     pub span: Span,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n }\n \n-pub type SpannedIdent = Spanned<Ident>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n@@ -1148,7 +1134,7 @@ pub enum ExprKind {\n     /// For example, `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n-    Field(P<Expr>, SpannedIdent),\n+    Field(P<Expr>, Ident),\n     /// Access of an unnamed field of a struct or tuple-struct\n     ///\n     /// For example, `foo.0`.\n@@ -1693,7 +1679,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n-            if ident.node.name == keywords::SelfValue.name() {\n+            if ident.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n                     TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n@@ -1709,13 +1695,13 @@ impl Arg {\n \n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.node {\n-            ident.node.name == keywords::SelfValue.name()\n+            ident.name == keywords::SelfValue.name()\n         } else {\n             false\n         }\n     }\n \n-    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n+    pub fn from_self(eself: ExplicitSelf, eself_ident: Ident) -> Arg {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n@@ -1872,7 +1858,7 @@ pub struct EnumDef {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n-    pub name: Ident,\n+    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, e.g. `Foo = 1`\n@@ -1906,7 +1892,7 @@ impl UseTree {\n         match self.kind {\n             UseTreeKind::Simple(Some(rename)) => rename,\n             UseTreeKind::Simple(None) =>\n-                self.prefix.segments.last().expect(\"empty prefix in a simple import\").identifier,\n+                self.prefix.segments.last().expect(\"empty prefix in a simple import\").ident,\n             _ => panic!(\"`UseTree::ident` can only be used on a simple import\"),\n         }\n     }"}, {"sha": "2812e1238e9a0fd98fb39887879b1752ae33f6a6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 44, "deletions": 62, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -19,7 +19,7 @@ use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n use codemap::{Spanned, respan, dummy_spanned};\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -137,7 +137,7 @@ impl NestedMetaItem {\n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n     pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n+        self.meta_item().and_then(|meta_item| Some(meta_item.ident.name))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,7 +154,7 @@ impl NestedMetaItem {\n                     if meta_item_list.len() == 1 {\n                         let nested_item = &meta_item_list[0];\n                         if nested_item.is_literal() {\n-                            Some((meta_item.name(), nested_item.literal().unwrap()))\n+                            Some((meta_item.ident.name, nested_item.literal().unwrap()))\n                         } else {\n                             None\n                         }\n@@ -215,7 +215,7 @@ impl Attribute {\n \n     pub fn name(&self) -> Option<Name> {\n         match self.path.segments.len() {\n-            1 => Some(self.path.segments[0].identifier.name),\n+            1 => Some(self.path.segments[0].ident.name),\n             _ => None,\n         }\n     }\n@@ -250,10 +250,6 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> Name {\n-        self.name\n-    }\n-\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n@@ -283,7 +279,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        self.name() == name\n+        self.ident.name == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -300,8 +296,8 @@ impl Attribute {\n     pub fn meta(&self) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n-            name: match self.path.segments.len() {\n-                1 => self.path.segments[0].identifier.name,\n+            ident: match self.path.segments.len() {\n+                1 => self.path.segments[0].ident,\n                 _ => return None,\n             },\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n@@ -353,7 +349,7 @@ impl Attribute {\n         }\n \n         Ok(MetaItem {\n-            name: self.path.segments.last().unwrap().identifier.name,\n+            ident: self.path.segments.last().unwrap().ident,\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n@@ -368,8 +364,8 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                Symbol::intern(\"doc\"),\n-                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())));\n+                Ident::from_str(\"doc\"),\n+                dummy_spanned(Symbol::intern(&strip_doc_comment_decoration(&comment.as_str()))));\n             let mut attr = if self.style == ast::AttrStyle::Outer {\n                 mk_attr_outer(self.span, self.id, meta)\n             } else {\n@@ -385,37 +381,24 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n-    let value_lit = dummy_spanned(LitKind::Str(value, ast::StrStyle::Cooked));\n-    mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n+pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n+    let value = respan(value.span, LitKind::Str(value.node, ast::StrStyle::Cooked));\n+    mk_name_value_item(ident.span.to(value.span), ident, value)\n }\n \n-pub fn mk_name_value_item(name: Name, value: ast::Lit) -> MetaItem {\n-    mk_spanned_name_value_item(DUMMY_SP, name, value)\n+pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n+    MetaItem { ident, span, node: MetaItemKind::NameValue(value) }\n }\n \n-pub fn mk_list_item(name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n-    mk_spanned_list_item(DUMMY_SP, name, items)\n+pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n+    MetaItem { ident, span, node: MetaItemKind::List(items) }\n }\n \n-pub fn mk_list_word_item(name: Name) -> ast::NestedMetaItem {\n-    dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n+pub fn mk_word_item(ident: Ident) -> MetaItem {\n+    MetaItem { ident, span: ident.span, node: MetaItemKind::Word }\n }\n-\n-pub fn mk_word_item(name: Name) -> MetaItem {\n-    mk_spanned_word_item(DUMMY_SP, name)\n-}\n-\n-pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> MetaItem {\n-    MetaItem { span: sp, name: name, node: MetaItemKind::NameValue(value) }\n-}\n-\n-pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { span: sp, name: name, node: MetaItemKind::List(items) }\n-}\n-\n-pub fn mk_spanned_word_item(sp: Span, name: Name) -> MetaItem {\n-    MetaItem { span: sp, name: name, node: MetaItemKind::Word }\n+pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n+    respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n }\n \n pub fn mk_attr_id() -> AttrId {\n@@ -439,7 +422,7 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        path: ast::Path::from_ident(item.ident),\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -457,7 +440,7 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        path: ast::Path::from_ident(item.ident),\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -470,7 +453,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id,\n         style,\n-        path: ast::Path::from_ident(span, ast::Ident::from_str(\"doc\")),\n+        path: ast::Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n@@ -506,7 +489,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| {\n-                mi.word().map(|w| w.name() == feature_name)\n+                mi.word().map(|w| w.ident.name == feature_name)\n                          .unwrap_or(false)\n             })\n         }).unwrap_or(false)\n@@ -579,7 +562,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n         if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n             gated_cfg.check_and_emit(sess, feats);\n         }\n-        sess.config.contains(&(cfg.name(), cfg.value_str()))\n+        sess.config.contains(&(cfg.ident.name, cfg.value_str()))\n     })\n }\n \n@@ -600,7 +583,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.name.as_str() {\n+            match &*cfg.ident.name.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n@@ -693,7 +676,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -712,14 +695,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n+                            match &*mi.ident.name.as_str() {\n                                 $(\n                                     stringify!($name)\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                                  AttrError::UnknownMetaItem(mi.ident.name));\n                                     continue 'outer\n                                 }\n                             }\n@@ -731,7 +714,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             }\n \n-            match &*meta.name.as_str() {\n+            match &*meta.ident.name.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -786,13 +769,13 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n+                            match &*mi.ident.name.as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                                  AttrError::UnknownMetaItem(mi.ident.name));\n                                     continue 'outer\n                                 }\n                             }\n@@ -842,12 +825,12 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name().as_str() {\n+                            match &*mi.ident.name.as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                                  AttrError::UnknownMetaItem(mi.ident.name));\n                                     continue 'outer\n                                 }\n                             }\n@@ -934,7 +917,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -950,12 +933,12 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name().as_str() {\n+                    match &*mi.ident.name.as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n                             handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.name()));\n+                                          AttrError::UnknownMetaItem(mi.ident.name));\n                             continue 'outer\n                         }\n                     }\n@@ -1007,7 +990,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n \n                 let mut recognised = false;\n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.name().as_str();\n+                    let word = &*mi.ident.name.as_str();\n                     let hint = match word {\n                         \"C\" => Some(ReprC),\n                         \"packed\" => Some(ReprPacked),\n@@ -1106,18 +1089,17 @@ impl IntType {\n \n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n-        let ident = TokenTree::Token(self.span,\n-                                     Token::from_ast_ident(Ident::with_empty_ctxt(self.name)));\n+        let ident = TokenTree::Token(self.span, Token::from_ast_ident(self.ident));\n         TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n-        let (span, name) = match tokens.next() {\n-            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident.name),\n+        let (span, ident) = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident),\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident.node.name),\n+                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n                 _ => return None,\n             },\n@@ -1130,7 +1112,7 @@ impl MetaItem {\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n             _ => span.hi(),\n         };\n-        Some(MetaItem { name, node, span: span.with_hi(hi) })\n+        Some(MetaItem { ident, node, span: span.with_hi(hi) })\n     }\n }\n "}, {"sha": "36911683a0e7785654cd7c88a642cec1c106814f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -204,7 +204,7 @@ impl<'a> StripUnconfigured<'a> {\n                     self.configure(v).map(|v| {\n                         Spanned {\n                             node: ast::Variant_ {\n-                                name: v.node.name,\n+                                ident: v.node.ident,\n                                 attrs: v.node.attrs,\n                                 data: self.configure_variant_data(v.node.data),\n                                 disr_expr: v.node.disr_expr,"}, {"sha": "a09bea25a249c55daeeca573a69cef2a7c47a542", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -251,7 +251,7 @@ impl<F> TTMacroExpander for F\n                 if let tokenstream::TokenTree::Token(_, token::Interpolated(ref nt)) = tt {\n                     if let token::NtIdent(ident, is_raw) = nt.0 {\n                         return tokenstream::TokenTree::Token(ident.span,\n-                                                             token::Ident(ident.node, is_raw));\n+                                                             token::Ident(ident, is_raw));\n                     }\n                 }\n                 fold::noop_fold_tt(tt, self)\n@@ -876,8 +876,8 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n-        let def_site = SyntaxContext::empty().apply_mark(self.current_expansion.mark);\n-        iter::once(Ident { ctxt: def_site, ..keywords::DollarCrate.ident() })\n+        let def_site = DUMMY_SP.apply_mark(self.current_expansion.mark);\n+        iter::once(Ident::new(keywords::DollarCrate.name(), def_site))\n             .chain(components.iter().map(|s| self.ident_of(s)))\n             .collect()\n     }\n@@ -897,7 +897,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n                               -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span = expr.span.with_ctxt(expr.span.ctxt().apply_mark(cx.current_expansion.mark));\n+        expr.span = expr.span.apply_mark(cx.current_expansion.mark);\n         expr\n     });\n "}, {"sha": "062f3ce112752cec5d82a474bd0b8aec469f4584", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -38,11 +38,11 @@ pub trait AstBuilder {\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::SpannedIdent)\n+             ident: ast::Ident)\n              -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n-                ident: ast::SpannedIdent,\n+                ident: ast::Ident,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding>)\n@@ -319,16 +319,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n-        let last_identifier = idents.pop().unwrap();\n+        let last_ident = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = Vec::new();\n \n-        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, span)));\n+        segments.extend(idents.into_iter().map(|ident| {\n+            ast::PathSegment::from_ident(ident.with_span_pos(span))\n+        }));\n         let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n             ast::AngleBracketedParameterData { lifetimes, types, bindings, span }.into()\n         } else {\n             None\n         };\n-        segments.push(ast::PathSegment { identifier: last_identifier, span, parameters });\n+        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), parameters });\n         let mut path = ast::Path { span, segments };\n         if global {\n             if let Some(seg) = path.make_root() {\n@@ -344,7 +346,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::SpannedIdent)\n+             ident: ast::Ident)\n              -> (ast::QSelf, ast::Path) {\n         self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n@@ -355,7 +357,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n-                 ident: ast::SpannedIdent,\n+                 ident: ast::Ident,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n                  bindings: Vec<ast::TypeBinding>)\n@@ -366,11 +368,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             None\n         };\n-        path.segments.push(ast::PathSegment {\n-            identifier: ident.node,\n-            span: ident.span,\n-            parameters,\n-        });\n+        path.segments.push(ast::PathSegment { ident, parameters });\n \n         (ast::QSelf {\n             ty: self_type,\n@@ -439,17 +437,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn typaram(&self,\n                span: Span,\n-               id: ast::Ident,\n+               ident: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n                bounds: ast::TyParamBounds,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n-            ident: id,\n+            ident: ident.with_span_pos(span),\n             id: ast::DUMMY_NODE_ID,\n             attrs: attrs.into(),\n             bounds,\n             default,\n-            span,\n         }\n     }\n \n@@ -473,7 +470,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n-        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, ident: ident }\n+        ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n     fn lifetime_def(&self,\n@@ -636,8 +633,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n-        let id = Spanned { node: ident, span: sp };\n-        self.expr(sp, ast::ExprKind::Field(expr, id))\n+        self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let id = Spanned { node: idx, span: sp };\n@@ -667,14 +663,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         ident: ast::Ident,\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         args.insert(0, expr);\n-        self.expr(span, ast::ExprKind::MethodCall(ast::PathSegment::from_ident(ident, span), args))\n+        let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n+        self.expr(span, ast::ExprKind::MethodCall(segment, args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b))\n     }\n-    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field {\n+    fn field_imm(&self, span: Span, ident: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field {\n-            ident: respan(span, name),\n+            ident: ident.with_span_pos(span),\n             expr: e,\n             span,\n             is_shorthand: false,\n@@ -835,7 +832,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat> {\n-        let pat = PatKind::Ident(bm, Spanned{span: span, node: ident}, None);\n+        let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n         self.pat(span, pat)\n     }\n     fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n@@ -1027,7 +1024,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             body)\n     }\n \n-    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n+    fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             ast::StructField {\n                 span: ty.span,\n@@ -1047,7 +1044,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n         respan(span,\n                ast::Variant_ {\n-                   name,\n+                   ident,\n                    attrs: Vec::new(),\n                    data: vdata,\n                    disr_expr: None,\n@@ -1132,21 +1129,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n-        attr::mk_spanned_word_item(sp, w)\n+        attr::mk_word_item(Ident::with_empty_ctxt(w).with_span_pos(sp))\n     }\n \n     fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n-        respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n+        attr::mk_nested_word_item(Ident::with_empty_ctxt(w).with_span_pos(sp))\n     }\n \n     fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n                  -> ast::MetaItem {\n-        attr::mk_spanned_list_item(sp, name, mis)\n+        attr::mk_list_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp), mis)\n     }\n \n     fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)\n                        -> ast::MetaItem {\n-        attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n+        attr::mk_name_value_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp),\n+                                 respan(sp, value))\n     }\n \n     fn item_use(&self, sp: Span,"}, {"sha": "6bf166dfe950a84dc3559068d200e132ee4d26e3", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -54,7 +54,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n             pretty_name.push_str(\", \");\n         }\n         pretty_name.push_str(&path.to_string());\n-        names.insert(unwrap_or!(path.segments.get(0), continue).identifier.name);\n+        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n     }\n     pretty_name.push(')');\n "}, {"sha": "678c20402d6f47aab78e99f35b0234f61d2846eb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -168,10 +168,10 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n             path_str.push_str(\"::\");\n         }\n \n-        if segment.identifier.name != keywords::CrateRoot.name() &&\n-            segment.identifier.name != keywords::DollarCrate.name()\n+        if segment.ident.name != keywords::CrateRoot.name() &&\n+            segment.ident.name != keywords::DollarCrate.name()\n         {\n-            path_str.push_str(&segment.identifier.name.as_str())\n+            path_str.push_str(&segment.ident.name.as_str())\n         }\n     }\n \n@@ -688,7 +688,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             opt_expanded\n         } else {\n             let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                              name = path.segments[0].identifier.name, kind = kind.name());\n+                              name = path.segments[0].ident.name, kind = kind.name());\n             self.cx.span_err(path.span, &msg);\n             self.cx.trace_macros_diag();\n             kind.dummy(span)\n@@ -733,7 +733,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    name: keywords::Invalid.name(),\n+                    ident: keywords::Invalid.ident(),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n@@ -1279,15 +1279,16 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_name_value_item_str(\"file\".into(),\n-                                                                     file))),\n+                                        attr::mk_name_value_item_str(Ident::from_str(\"file\"),\n+                                                                     dummy_spanned(file)))),\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_name_value_item_str(\"contents\".into(),\n-                                                                     (&*src).into()))),\n+                                        attr::mk_name_value_item_str(Ident::from_str(\"contents\"),\n+                                                            dummy_spanned(Symbol::intern(&src))))),\n                             ];\n \n-                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_list_item(\"include\".into(), include_info))));\n+                            let include_ident = Ident::from_str(\"include\");\n+                            let item = attr::mk_list_item(DUMMY_SP, include_ident, include_info);\n+                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(item)));\n                         }\n                         Err(_) => {\n                             self.cx.span_err(at.span,\n@@ -1300,7 +1301,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 }\n             }\n \n-            let meta = attr::mk_list_item(\"doc\".into(), items);\n+            let meta = attr::mk_list_item(DUMMY_SP, Ident::from_str(\"doc\"), items);\n             match at.style {\n                 ast::AttrStyle::Inner =>\n                     Some(attr::mk_spanned_attr_inner(at.span, at.id, meta)),\n@@ -1378,12 +1379,12 @@ pub struct Marker(pub Mark);\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n-        ident.ctxt = ident.ctxt.apply_mark(self.0);\n+        ident.span = ident.span.apply_mark(self.0);\n         ident\n     }\n \n     fn new_span(&mut self, span: Span) -> Span {\n-        span.with_ctxt(span.ctxt().apply_mark(self.0))\n+        span.apply_mark(self.0)\n     }\n \n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {"}, {"sha": "3303955d398a64375035a3223ace0c1ba6347e1f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -75,7 +75,7 @@ pub mod rt {\n \n     impl ToTokens for ast::Ident {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, Token::from_ast_ident(*self))]\n+            vec![TokenTree::Token(self.span, Token::from_ast_ident(*self))]\n         }\n     }\n \n@@ -193,7 +193,7 @@ pub mod rt {\n \n     impl ToTokens for ast::Lifetime {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Lifetime(self.ident))]\n+            vec![TokenTree::Token(self.ident.span, token::Lifetime(self.ident))]\n         }\n     }\n \n@@ -239,7 +239,7 @@ pub mod rt {\n                     inner.push(TokenTree::Token(self.span, token::Colon).into());\n                 }\n                 inner.push(TokenTree::Token(\n-                    self.span, token::Token::from_ast_ident(segment.identifier)\n+                    self.span, token::Token::from_ast_ident(segment.ident)\n                 ).into());\n             }\n             inner.push(self.tokens.clone());"}, {"sha": "d9c3deb30da30a8b6107bbafb181e7e6c90adf84", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -86,7 +86,6 @@ use self::TokenTreeOrTokenTreeVec::*;\n \n use ast::Ident;\n use syntax_pos::{self, BytePos, Span};\n-use codemap::respan;\n use errors::FatalError;\n use ext::tt::quoted::{self, TokenTree};\n use parse::{Directory, ParseSess};\n@@ -366,7 +365,7 @@ pub fn parse_failure_msg(tok: Token) -> String {\n fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     if let (Some((id1, is_raw1)), Some((id2, is_raw2))) = (t1.ident(), t2.ident()) {\n         id1.name == id2.name && is_raw1 == is_raw2\n-    } else if let (&token::Lifetime(id1), &token::Lifetime(id2)) = (t1, t2) {\n+    } else if let (Some(id1), Some(id2)) = (t1.lifetime(), t2.lifetime()) {\n         id1.name == id2.name\n     } else {\n         *t1 == *t2\n@@ -825,8 +824,9 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n+            let span = p.span;\n             p.bump();\n-            token::NtIdent(respan(p.prev_span, ident), is_raw)\n+            token::NtIdent(Ident::new(ident.name, span), is_raw)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();\n@@ -835,7 +835,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"path\" => token::NtPath(panictry!(p.parse_path_common(PathStyle::Type, false))),\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n-        \"lifetime\" => token::NtLifetime(p.expect_lifetime()),\n+        \"lifetime\" => token::NtLifetime(p.expect_lifetime().ident),\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\"),"}, {"sha": "ffe68289d5224be79aa5cb086791919d07b08abc", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -53,7 +53,7 @@ impl<'a> ParserAnyMacro<'a> {\n         }\n \n         // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n-        let path = ast::Path::from_ident(site_span, macro_ident);\n+        let path = ast::Path::from_ident(macro_ident.with_span_pos(site_span));\n         parser.ensure_complete_parse(&path, kind.name(), site_span);\n         expansion\n     }"}, {"sha": "01b971976a763c3d49bf72f5283e2303e52f0442", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -289,14 +289,11 @@ where\n             // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n             // metavariable that names the crate of the invokation.\n             Some(tokenstream::TokenTree::Token(ident_span, ref token)) if token.is_ident() => {\n-                let (ident, _) = token.ident().unwrap();\n+                let (ident, is_raw) = token.ident().unwrap();\n                 let span = ident_span.with_lo(span.lo());\n-                if ident.name == keywords::Crate.name() {\n-                    let ident = ast::Ident {\n-                        name: keywords::DollarCrate.name(),\n-                        ..ident\n-                    };\n-                    TokenTree::Token(span, token::Ident(ident, false))\n+                if ident.name == keywords::Crate.name() && !is_raw {\n+                    let ident = ast::Ident::new(keywords::DollarCrate.name(), ident.span);\n+                    TokenTree::Token(span, token::Ident(ident, is_raw))\n                 } else {\n                     TokenTree::MetaVar(span, ident)\n                 }"}, {"sha": "1cdb6b0e5c902692f8130ce6f6839ca301cc6ce7", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -156,7 +156,7 @@ pub fn transcribe(cx: &ExtCtxt,\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+                            sp = sp.apply_mark(cx.current_expansion.mark);\n                             let token = TokenTree::Token(sp, Token::interpolated((**nt).clone()));\n                             result.push(token.into());\n                         }\n@@ -166,14 +166,14 @@ pub fn transcribe(cx: &ExtCtxt,\n                     }\n                 } else {\n                     let ident =\n-                        Ident { ctxt: ident.ctxt.apply_mark(cx.current_expansion.mark), ..ident };\n-                    sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.mark));\n+                    sp = sp.apply_mark(cx.current_expansion.mark);\n                     result.push(TokenTree::Token(sp, token::Dollar).into());\n                     result.push(TokenTree::Token(sp, token::Token::from_ast_ident(ident)).into());\n                 }\n             }\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.with_ctxt(span.ctxt().apply_mark(cx.current_expansion.mark));\n+                span = span.apply_mark(cx.current_expansion.mark);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span: span });\n                 result_stack.push(mem::replace(&mut result, Vec::new()));\n             }"}, {"sha": "e1f1d95b8ab51e930bb078e320784f345db1b6fd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -1054,7 +1054,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name().as_str();\n+        let name = cfg.ident.name.as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -1766,11 +1766,19 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_path(&mut self, path: &'a ast::Path, _id: NodeId) {\n         for segment in &path.segments {\n-            if segment.identifier.name == keywords::Crate.name() {\n-                gate_feature_post!(&self, crate_in_paths, segment.span,\n+            // Identifiers we are going to check could come from a legacy macro (e.g. `#[test]`).\n+            // For such macros identifiers must have empty context, because this context is\n+            // used during name resolution and produced names must be unhygienic for compatibility.\n+            // On the other hand, we need the actual non-empty context for feature gate checking\n+            // because it's hygienic even for legacy macros. As previously stated, such context\n+            // cannot be kept in identifiers, so it's kept in paths instead and we take it from\n+            // there while keeping location info from the ident span.\n+            let span = segment.ident.span.with_ctxt(path.span.ctxt());\n+            if segment.ident.name == keywords::Crate.name() {\n+                gate_feature_post!(&self, crate_in_paths, span,\n                                    \"`crate` in paths is experimental\");\n-            } else if segment.identifier.name == keywords::Extern.name() {\n-                gate_feature_post!(&self, extern_in_paths, segment.span,\n+            } else if segment.ident.name == keywords::Extern.name() {\n+                gate_feature_post!(&self, extern_in_paths, span,\n                                    \"`extern` in paths is experimental\");\n             }\n         }\n@@ -1811,7 +1819,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                 for mi in list {\n \n                     let name = if let Some(word) = mi.word() {\n-                        word.name()\n+                        word.ident.name\n                     } else {\n                         span_err!(span_handler, mi.span, E0556,\n                                   \"malformed feature, expected just one word\");"}, {"sha": "ba6703b9c74406ee24db0cc8b83e24074e47520f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -430,7 +430,7 @@ pub fn noop_fold_global_asm<T: Folder>(ga: P<GlobalAsm>,\n pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n     Spanned {\n         node: Variant_ {\n-            name: fld.fold_ident(v.node.name),\n+            ident: fld.fold_ident(v.node.ident),\n             attrs: fold_attrs(v.node.attrs, fld),\n             data: fld.fold_variant_data(v.node.data),\n             disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n@@ -439,8 +439,8 @@ pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n     }\n }\n \n-pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n-    i\n+pub fn noop_fold_ident<T: Folder>(ident: Ident, fld: &mut T) -> Ident {\n+    Ident::new(ident.name, fld.new_span(ident.span))\n }\n \n pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n@@ -449,9 +449,8 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {identifier, span, parameters}| PathSegment {\n-            identifier: fld.fold_ident(identifier),\n-            span: fld.new_span(span),\n+        segments: segments.move_map(|PathSegment {ident, parameters}| PathSegment {\n+            ident: fld.fold_ident(ident),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)\n@@ -544,7 +543,7 @@ pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n \n pub fn noop_fold_meta_item<T: Folder>(mi: MetaItem, fld: &mut T) -> MetaItem {\n     MetaItem {\n-        name: mi.name,\n+        ident: mi.ident,\n         node: match mi.node {\n             MetaItemKind::Word => MetaItemKind::Word,\n             MetaItemKind::List(mis) => {\n@@ -634,8 +633,8 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(id, is_raw) =>\n-            token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}, is_raw),\n+        token::NtIdent(ident, is_raw) => token::NtIdent(fld.fold_ident(ident), is_raw),\n+        token::NtLifetime(ident) => token::NtLifetime(fld.fold_ident(ident)),\n         token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),\n@@ -651,7 +650,6 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n         token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n         token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n-        token::NtLifetime(lifetime) => token::NtLifetime(fld.fold_lifetime(lifetime)),\n         token::NtForeignItem(ni) =>\n             token::NtForeignItem(fld.fold_foreign_item(ni)\n                                  // see reasoning above\n@@ -680,7 +678,7 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n }\n \n pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {attrs, id, ident, bounds, default, span} = tp;\n+    let TyParam {attrs, id, ident, bounds, default} = tp;\n     let attrs: Vec<_> = attrs.into();\n     TyParam {\n         attrs: attrs.into_iter()\n@@ -691,7 +689,6 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n         ident: fld.fold_ident(ident),\n         bounds: fld.fold_bounds(bounds),\n         default: default.map(|x| fld.fold_ty(x)),\n-        span: fld.new_span(span),\n     }\n }\n \n@@ -712,15 +709,13 @@ pub fn noop_fold_generic_params<T: Folder>(\n pub fn noop_fold_label<T: Folder>(label: Label, fld: &mut T) -> Label {\n     Label {\n         ident: fld.fold_ident(label.ident),\n-        span: fld.new_span(label.span),\n     }\n }\n \n pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         ident: fld.fold_ident(l.ident),\n-        span: fld.new_span(l.span)\n     }\n }\n \n@@ -859,7 +854,7 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n \n pub fn noop_fold_field<T: Folder>(f: Field, folder: &mut T) -> Field {\n     Field {\n-        ident: respan(f.ident.span, folder.fold_ident(f.ident.node)),\n+        ident: folder.fold_ident(f.ident),\n         expr: folder.fold_expr(f.expr),\n         span: folder.new_span(f.span),\n         is_shorthand: f.is_shorthand,\n@@ -1119,11 +1114,10 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n         id: folder.new_id(id),\n         node: match node {\n             PatKind::Wild => PatKind::Wild,\n-            PatKind::Ident(binding_mode, pth1, sub) => {\n+            PatKind::Ident(binding_mode, ident, sub) => {\n                 PatKind::Ident(binding_mode,\n-                        Spanned{span: folder.new_span(pth1.span),\n-                                node: folder.fold_ident(pth1.node)},\n-                        sub.map(|x| folder.fold_pat(x)))\n+                               folder.fold_ident(ident),\n+                               sub.map(|x| folder.fold_pat(x)))\n             }\n             PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n             PatKind::TupleStruct(pth, pats, ddpos) => {\n@@ -1195,8 +1189,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::MethodCall(seg, args) => {\n                 ExprKind::MethodCall(\n                     PathSegment {\n-                        identifier: folder.fold_ident(seg.identifier),\n-                        span: folder.new_span(seg.span),\n+                        ident: folder.fold_ident(seg.ident),\n                         parameters: seg.parameters.map(|ps| {\n                             ps.map(|ps| folder.fold_path_parameters(ps))\n                         }),\n@@ -1272,14 +1265,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                             folder.fold_expr(er))\n             }\n             ExprKind::Field(el, ident) => {\n-                ExprKind::Field(folder.fold_expr(el),\n-                          respan(folder.new_span(ident.span),\n-                                 folder.fold_ident(ident.node)))\n+                ExprKind::Field(folder.fold_expr(el), folder.fold_ident(ident))\n             }\n-            ExprKind::TupField(el, ident) => {\n+            ExprKind::TupField(el, index) => {\n                 ExprKind::TupField(folder.fold_expr(el),\n-                             respan(folder.new_span(ident.span),\n-                                    folder.fold_usize(ident.node)))\n+                             respan(folder.new_span(index.span),\n+                                    folder.fold_usize(index.node)))\n             }\n             ExprKind::Index(el, er) => {\n                 ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "90f08ab1468e212ca37cce4df7ae0f7bf6e669c0", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -149,8 +149,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (ast::Path::from_ident(meta.span, ast::Ident::with_empty_ctxt(meta.name)),\n-             meta.node.tokens(meta.span))\n+            (ast::Path::from_ident(meta.ident), meta.node.tokens(meta.span))\n         } else {\n             (self.parse_path(PathStyle::Mod)?, self.parse_tokens())\n         })\n@@ -228,7 +227,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n         let ident = self.parse_ident()?;\n         let node = self.parse_meta_item_kind()?;\n-        Ok(ast::MetaItem { name: ident.name, node: node, span: lo.to(self.prev_span) })\n+        Ok(ast::MetaItem { ident, node: node, span: lo.to(self.prev_span) })\n     }\n \n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {"}, {"sha": "152c4c31eb3e3669ee7731958a4b6333503bae1a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -76,7 +76,7 @@ impl<'a> StringReader<'a> {\n     fn mk_ident(&self, string: &str) -> Ident {\n         let mut ident = Ident::from_str(string);\n         if let Some(span) = self.override_span {\n-            ident.ctxt = span.ctxt();\n+            ident.span = span;\n         }\n         ident\n     }"}, {"sha": "428b3b136df76edb2c51a507d130db258fd9a355", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -689,7 +689,7 @@ mod tests {\n     }\n \n     fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n-        ast::PathSegment::from_ident(Ident::from_str(s), sp(lo, hi))\n+        ast::PathSegment::from_ident(Ident::new(Symbol::intern(s), sp(lo, hi)))\n     }\n \n     #[test] fn path_exprs_1() {\n@@ -873,10 +873,8 @@ mod tests {\n                     == P(ast::Pat{\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n-                                        Spanned{ span:sp(0, 1),\n-                                                node: Ident::from_str(\"b\")\n-                        },\n-                                        None),\n+                                         Ident::new(Symbol::intern(\"b\"), sp(0, 1)),\n+                                         None),\n                     span: sp(0,1)}));\n             parser_done(parser);\n         })\n@@ -912,9 +910,7 @@ mod tests {\n                                             node: PatKind::Ident(\n                                                 ast::BindingMode::ByValue(\n                                                     ast::Mutability::Immutable),\n-                                                Spanned{\n-                                                    span: sp(6,7),\n-                                                    node: Ident::from_str(\"b\")},\n+                                                Ident::new(Symbol::intern(\"b\"), sp(6, 7)),\n                                                 None\n                                             ),\n                                             span: sp(6,7)"}, {"sha": "e6da5bcaa3ae6cc61a8bd84b9445211274fcb2e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -512,13 +512,10 @@ impl From<P<Expr>> for LhsExpr {\n \n /// Create a placeholder argument.\n fn dummy_arg(span: Span) -> Arg {\n-    let spanned = Spanned {\n-        span,\n-        node: keywords::Invalid.ident()\n-    };\n+    let ident = Ident::new(keywords::Invalid.name(), span);\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), spanned, None),\n+        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n         span,\n     });\n     let ty = Ty {\n@@ -778,7 +775,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(i, _) => {\n+            token::Ident(ident, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n                     if recover {\n@@ -787,8 +784,9 @@ impl<'a> Parser<'a> {\n                         return Err(err);\n                     }\n                 }\n+                let span = self.span;\n                 self.bump();\n-                Ok(i)\n+                Ok(Ident::new(ident.name, span))\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n@@ -1319,19 +1317,6 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern) && self.is_extern_non_path()\n     }\n \n-    fn eat_label(&mut self) -> Option<Label> {\n-        let ident = match self.token {\n-            token::Lifetime(ref ident) => *ident,\n-            token::Interpolated(ref nt) => match nt.0 {\n-                token::NtLifetime(lifetime) => lifetime.ident,\n-                _ => return None,\n-            },\n-            _ => return None,\n-        };\n-        self.bump();\n-        Some(Label { ident, span: self.prev_span })\n-    }\n-\n     /// parse a TyKind::BareFn type:\n     pub fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>)\n                             -> PResult<'a, TyKind> {\n@@ -1784,13 +1769,11 @@ impl<'a> Parser<'a> {\n             pat\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n-            let sp = self.prev_span;\n-            let spanned = Spanned { span: sp, node: keywords::Invalid.ident() };\n+            let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n             P(Pat {\n                 id: ast::DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable),\n-                                     spanned, None),\n-                span: sp\n+                node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                span: ident.span,\n             })\n         };\n \n@@ -1899,13 +1882,14 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(sid, _) if self.token.is_path_segment_keyword() => {\n+            token::Ident(ident, _) if self.token.is_path_segment_keyword() => {\n+                let span = self.span;\n                 self.bump();\n-                Ok(sid)\n+                Ok(Ident::new(ident.name, span))\n             }\n             _ => self.parse_ident(),\n-         }\n-     }\n+        }\n+    }\n \n     /// Parses qualified path.\n     /// Assumes that the leading `<` has been parsed already.\n@@ -1973,7 +1957,7 @@ impl<'a> Parser<'a> {\n         let meta_ident = match self.token {\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtMeta(ref meta) => match meta.node {\n-                    ast::MetaItemKind::Word => Some(ast::Ident::with_empty_ctxt(meta.name)),\n+                    ast::MetaItemKind::Word => Some(meta.ident),\n                     _ => None,\n                 },\n                 _ => None,\n@@ -1982,7 +1966,7 @@ impl<'a> Parser<'a> {\n         };\n         if let Some(ident) = meta_ident {\n             self.bump();\n-            return Ok(ast::Path::from_ident(self.prev_span, ident));\n+            return Ok(ast::Path::from_ident(ident));\n         }\n         self.parse_path(style)\n     }\n@@ -2003,7 +1987,6 @@ impl<'a> Parser<'a> {\n \n     fn parse_path_segment(&mut self, style: PathStyle, enable_warning: bool)\n                           -> PResult<'a, PathSegment> {\n-        let ident_span = self.span;\n         let ident = self.parse_path_segment_ident()?;\n \n         let is_args_start = |token: &token::Token| match *token {\n@@ -2051,10 +2034,10 @@ impl<'a> Parser<'a> {\n                 ParenthesizedParameterData { inputs, output, span }.into()\n             };\n \n-            PathSegment { identifier: ident, span: ident_span, parameters }\n+            PathSegment { ident, parameters }\n         } else {\n             // Generic arguments are not found.\n-            PathSegment::from_ident(ident, ident_span)\n+            PathSegment::from_ident(ident)\n         })\n     }\n \n@@ -2065,14 +2048,25 @@ impl<'a> Parser<'a> {\n \n     /// Parse single lifetime 'a or panic.\n     pub fn expect_lifetime(&mut self) -> Lifetime {\n-        if let Some(lifetime) = self.token.lifetime(self.span) {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.span;\n             self.bump();\n-            lifetime\n+            Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n         } else {\n             self.span_bug(self.span, \"not a lifetime\")\n         }\n     }\n \n+    fn eat_label(&mut self) -> Option<Label> {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.span;\n+            self.bump();\n+            Some(Label { ident: Ident::new(ident.name, span) })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Parse mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(keywords::Mut) {\n@@ -2085,7 +2079,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n         if let token::Literal(token::Integer(name), None) = self.token {\n             self.bump();\n-            Ok(Ident::with_empty_ctxt(name))\n+            Ok(Ident::new(name, self.prev_span))\n         } else {\n             self.parse_ident_common(false)\n         }\n@@ -2095,24 +2089,22 @@ impl<'a> Parser<'a> {\n     pub fn parse_field(&mut self) -> PResult<'a, Field> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span;\n-        let hi;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n             let fieldname = self.parse_field_name()?;\n-            hi = self.prev_span;\n-            self.bump();\n+            self.bump(); // `:`\n             (fieldname, self.parse_expr()?, false)\n         } else {\n             let fieldname = self.parse_ident_common(false)?;\n-            hi = self.prev_span;\n \n             // Mimic `x: x` for the `x` field shorthand.\n-            let path = ast::Path::from_ident(lo.to(hi), fieldname);\n-            (fieldname, self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new()), true)\n+            let path = ast::Path::from_ident(fieldname);\n+            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n+            (fieldname, expr, true)\n         };\n         Ok(ast::Field {\n-            ident: respan(lo.to(hi), fieldname),\n+            ident: fieldname,\n             span: lo.to(expr.span),\n             expr,\n             is_shorthand,\n@@ -2318,7 +2310,7 @@ impl<'a> Parser<'a> {\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if let Some(label) = self.eat_label() {\n-                    let lo = label.span;\n+                    let lo = label.ident.span;\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n                         return self.parse_while_expr(Some(label), lo, attrs)\n@@ -2592,8 +2584,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let span = lo.to(self.prev_span);\n-                let ident = respan(segment.span, segment.identifier);\n-                self.mk_expr(span, ExprKind::Field(self_arg, ident), ThinVec::new())\n+                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n             }\n         })\n     }\n@@ -2714,7 +2705,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn process_potential_macro_variable(&mut self) {\n-        let (ident, is_raw) = match self.token {\n+        let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n@@ -2729,15 +2720,18 @@ impl<'a> Parser<'a> {\n             }\n             token::Interpolated(ref nt) => {\n                 self.meta_var_span = Some(self.span);\n+                // Interpolated identifier and lifetime tokens are replaced with usual identifier\n+                // and lifetime tokens, so the former are never encountered during normal parsing.\n                 match nt.0 {\n-                    token::NtIdent(ident, is_raw) => (ident, is_raw),\n+                    token::NtIdent(ident, is_raw) => (token::Ident(ident, is_raw), ident.span),\n+                    token::NtLifetime(ident) => (token::Lifetime(ident), ident.span),\n                     _ => return,\n                 }\n             }\n             _ => return,\n         };\n-        self.token = token::Ident(ident.node, is_raw);\n-        self.span = ident.span;\n+        self.token = token;\n+        self.span = span;\n     }\n \n     /// parse a single token tree from the input.\n@@ -3672,10 +3666,9 @@ impl<'a> Parser<'a> {\n                     (false, true) => BindingMode::ByValue(Mutability::Mutable),\n                     (false, false) => BindingMode::ByValue(Mutability::Immutable),\n                 };\n-                let fieldpath = codemap::Spanned{span:self.prev_span, node:fieldname};\n                 let fieldpat = P(Pat {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: PatKind::Ident(bind_type, fieldpath, None),\n+                    node: PatKind::Ident(bind_type, fieldname, None),\n                     span: boxed_span.to(hi),\n                 });\n \n@@ -3966,9 +3959,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n                        -> PResult<'a, PatKind> {\n-        let ident_span = self.span;\n         let ident = self.parse_ident()?;\n-        let name = codemap::Spanned{span: ident_span, node: ident};\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat()?)\n         } else {\n@@ -3987,7 +3978,7 @@ impl<'a> Parser<'a> {\n                 \"expected identifier, found enum pattern\"))\n         }\n \n-        Ok(PatKind::Ident(binding_mode, name, sub))\n+        Ok(PatKind::Ident(binding_mode, ident, sub))\n     }\n \n     /// Parse a local variable declaration\n@@ -4699,7 +4690,6 @@ impl<'a> Parser<'a> {\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> {\n-        let span = self.span;\n         let ident = self.parse_ident()?;\n \n         // Parse optional colon and param bounds.\n@@ -4721,15 +4711,13 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             bounds,\n             default,\n-            span,\n         })\n     }\n \n     /// Parses the following grammar:\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [TyParamBounds]] [\"where\" ...] [\"=\" Ty]\n     fn parse_trait_item_assoc_ty(&mut self, preceding_attrs: Vec<Attribute>)\n         -> PResult<'a, (ast::Generics, TyParam)> {\n-        let span = self.span;\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -4754,7 +4742,6 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             bounds,\n             default,\n-            span,\n         }))\n     }\n \n@@ -5051,9 +5038,8 @@ impl<'a> Parser<'a> {\n     fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n             // Preserve hygienic context.\n-            token::Ident(ident, _) => {\n-                let sp = this.span; this.bump(); codemap::respan(sp, ident)\n-            }\n+            token::Ident(ident, _) =>\n+                { let span = this.span; this.bump(); Ident::new(ident.name, span) }\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n@@ -5566,7 +5552,7 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, path) => path,\n                     _ => {\n                         self.span_err(ty_first.span, \"expected a trait, found type\");\n-                        ast::Path::from_ident(ty_first.span, keywords::Invalid.ident())\n+                        ast::Path::from_ident(Ident::new(keywords::Invalid.name(), ty_first.span))\n                     }\n                 };\n                 let trait_ref = TraitRef { path, ref_id: ty_first.id };\n@@ -5951,8 +5937,7 @@ impl<'a> Parser<'a> {\n                     let attr = Attribute {\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n-                        path: ast::Path::from_ident(syntax_pos::DUMMY_SP,\n-                                                    Ident::from_str(\"warn_directory_ownership\")),\n+                        path: ast::Path::from_ident(Ident::from_str(\"warn_directory_ownership\")),\n                         tokens: TokenStream::empty(),\n                         is_sugared_doc: false,\n                         span: syntax_pos::DUMMY_SP,\n@@ -6334,7 +6319,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let vr = ast::Variant_ {\n-                name: ident,\n+                ident,\n                 attrs: variant_attrs,\n                 data: struct_def,\n                 disr_expr,"}, {"sha": "6544619af9c707379e9ade92f080e3300c500ec6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -317,21 +317,36 @@ impl Token {\n         }\n     }\n \n-    pub fn ident(&self) -> Option<(ast::Ident, bool)> {\n+    /// Returns an identifier if this token is an identifier.\n+    pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n         match *self {\n             Ident(ident, is_raw) => Some((ident, is_raw)),\n             Interpolated(ref nt) => match nt.0 {\n-                NtIdent(ident, is_raw) => Some((ident.node, is_raw)),\n+                NtIdent(ident, is_raw) => Some((ident, is_raw)),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+    /// Returns a lifetime identifier if this token is a lifetime.\n+    pub fn lifetime(&self) -> Option<ast::Ident> {\n+        match *self {\n+            Lifetime(ident) => Some(ident),\n+            Interpolated(ref nt) => match nt.0 {\n+                NtLifetime(ident) => Some(ident),\n                 _ => None,\n             },\n             _ => None,\n         }\n     }\n-\n     /// Returns `true` if the token is an identifier.\n     pub fn is_ident(&self) -> bool {\n         self.ident().is_some()\n     }\n+    /// Returns `true` if the token is a lifetime.\n+    pub fn is_lifetime(&self) -> bool {\n+        self.lifetime().is_some()\n+    }\n \n     /// Returns `true` if the token is a documentation comment.\n     pub fn is_doc_comment(&self) -> bool {\n@@ -359,26 +374,6 @@ impl Token {\n         false\n     }\n \n-    /// Returns a lifetime with the span and a dummy id if it is a lifetime,\n-    /// or the original lifetime if it is an interpolated lifetime, ignoring\n-    /// the span.\n-    pub fn lifetime(&self, span: Span) -> Option<ast::Lifetime> {\n-        match *self {\n-            Lifetime(ident) =>\n-                Some(ast::Lifetime { ident: ident, span: span, id: ast::DUMMY_NODE_ID }),\n-            Interpolated(ref nt) => match nt.0 {\n-                NtLifetime(lifetime) => Some(lifetime),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the token is a lifetime.\n-    pub fn is_lifetime(&self) -> bool {\n-        self.lifetime(syntax_pos::DUMMY_SP).is_some()\n-    }\n-\n     /// Returns `true` if the token is either the `mut` or `const` keyword.\n     pub fn is_mutability(&self) -> bool {\n         self.is_keyword(keywords::Mut) ||\n@@ -431,6 +426,14 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token is either a special identifier or a keyword.\n+    pub fn is_reserved_ident(&self) -> bool {\n+        match self.ident() {\n+            Some((id, false)) => is_reserved_ident(id),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn glue(self, joint: Token) -> Option<Token> {\n         Some(match self {\n             Eq => match joint {\n@@ -497,14 +500,6 @@ impl Token {\n         }\n     }\n \n-    /// Returns `true` if the token is either a special identifier or a keyword.\n-    pub fn is_reserved_ident(&self) -> bool {\n-        match self.ident() {\n-            Some((id, false)) => is_reserved_ident(id),\n-            _ => false,\n-        }\n-    }\n-\n     pub fn interpolated_to_tokenstream(&self, sess: &ParseSess, span: Span)\n         -> TokenStream\n     {\n@@ -539,12 +534,12 @@ impl Token {\n                 tokens = prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span);\n             }\n             Nonterminal::NtIdent(ident, is_raw) => {\n-                let token = Token::Ident(ident.node, is_raw);\n+                let token = Token::Ident(ident, is_raw);\n                 tokens = Some(TokenTree::Token(ident.span, token).into());\n             }\n-            Nonterminal::NtLifetime(lifetime) => {\n-                let token = Token::Lifetime(lifetime.ident);\n-                tokens = Some(TokenTree::Token(lifetime.span, token).into());\n+            Nonterminal::NtLifetime(ident) => {\n+                let token = Token::Lifetime(ident);\n+                tokens = Some(TokenTree::Token(ident.span, token).into());\n             }\n             Nonterminal::NtTT(ref tt) => {\n                 tokens = Some(tt.clone().into());\n@@ -571,7 +566,8 @@ pub enum Nonterminal {\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(ast::SpannedIdent, /* is_raw */ bool),\n+    NtIdent(ast::Ident, /* is_raw */ bool),\n+    NtLifetime(ast::Ident),\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n@@ -585,7 +581,6 @@ pub enum Nonterminal {\n     NtGenerics(ast::Generics),\n     NtWhereClause(ast::WhereClause),\n     NtArg(ast::Arg),\n-    NtLifetime(ast::Lifetime),\n }\n \n impl fmt::Debug for Nonterminal {"}, {"sha": "8d42206c5ccffa4c62c8c0f48ea123942aa5154f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -26,7 +26,7 @@ use print::pp::{self, Breaks};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n-use symbol::{Symbol, keywords};\n+use symbol::keywords;\n use syntax_pos::{DUMMY_SP, FileName};\n use tokenstream::{self, TokenStream, TokenTree};\n \n@@ -101,13 +101,13 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_list_word_item(Symbol::intern(\"prelude_import\"));\n-        let list = attr::mk_list_item(Symbol::intern(\"feature\"), vec![prelude_import_meta]);\n+        let pi_nested = attr::mk_nested_word_item(ast::Ident::from_str(\"prelude_import\"));\n+        let list = attr::mk_list_item(DUMMY_SP, ast::Ident::from_str(\"feature\"), vec![pi_nested]);\n         let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), list);\n         s.print_attribute(&fake_attr)?;\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(Symbol::intern(\"no_std\"));\n+        let no_std_meta = attr::mk_word_item(ast::Ident::from_str(\"no_std\"));\n         let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), no_std_meta);\n         s.print_attribute(&fake_attr)?;\n     }\n@@ -262,26 +262,26 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n         token::Interpolated(ref nt) => match nt.0 {\n-            token::NtExpr(ref e)         => expr_to_string(e),\n-            token::NtMeta(ref e)         => meta_item_to_string(e),\n-            token::NtTy(ref e)           => ty_to_string(e),\n-            token::NtPath(ref e)         => path_to_string(e),\n-            token::NtItem(ref e)         => item_to_string(e),\n-            token::NtBlock(ref e)        => block_to_string(e),\n-            token::NtStmt(ref e)         => stmt_to_string(e),\n-            token::NtPat(ref e)          => pat_to_string(e),\n-            token::NtIdent(ref e, false) => ident_to_string(e.node),\n-            token::NtIdent(ref e, true)  => format!(\"r#{}\", ident_to_string(e.node)),\n-            token::NtTT(ref tree)        => tt_to_string(tree.clone()),\n-            token::NtArm(ref e)          => arm_to_string(e),\n-            token::NtImplItem(ref e)     => impl_item_to_string(e),\n-            token::NtTraitItem(ref e)    => trait_item_to_string(e),\n-            token::NtGenerics(ref e)     => generic_params_to_string(&e.params),\n-            token::NtWhereClause(ref e)  => where_clause_to_string(e),\n-            token::NtArg(ref e)          => arg_to_string(e),\n-            token::NtVis(ref e)          => vis_to_string(e),\n-            token::NtLifetime(ref e)     => lifetime_to_string(e),\n-            token::NtForeignItem(ref ni) => foreign_item_to_string(ni),\n+            token::NtExpr(ref e)        => expr_to_string(e),\n+            token::NtMeta(ref e)        => meta_item_to_string(e),\n+            token::NtTy(ref e)          => ty_to_string(e),\n+            token::NtPath(ref e)        => path_to_string(e),\n+            token::NtItem(ref e)        => item_to_string(e),\n+            token::NtBlock(ref e)       => block_to_string(e),\n+            token::NtStmt(ref e)        => stmt_to_string(e),\n+            token::NtPat(ref e)         => pat_to_string(e),\n+            token::NtIdent(e, false)    => ident_to_string(e),\n+            token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n+            token::NtLifetime(e)        => ident_to_string(e),\n+            token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n+            token::NtArm(ref e)         => arm_to_string(e),\n+            token::NtImplItem(ref e)    => impl_item_to_string(e),\n+            token::NtTraitItem(ref e)   => trait_item_to_string(e),\n+            token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n+            token::NtWhereClause(ref e) => where_clause_to_string(e),\n+            token::NtArg(ref e)         => arg_to_string(e),\n+            token::NtVis(ref e)         => vis_to_string(e),\n+            token::NtForeignItem(ref e) => foreign_item_to_string(e),\n         }\n     }\n }\n@@ -739,11 +739,11 @@ pub trait PrintState<'a> {\n                     if i > 0 {\n                         self.writer().word(\"::\")?\n                     }\n-                    if segment.identifier.name != keywords::CrateRoot.name() &&\n-                       segment.identifier.name != keywords::DollarCrate.name() {\n-                        self.writer().word(&segment.identifier.name.as_str())?;\n-                    } else if segment.identifier.name == keywords::DollarCrate.name() {\n-                        self.print_dollar_crate(segment.identifier.ctxt)?;\n+                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                       segment.ident.name != keywords::DollarCrate.name() {\n+                        self.writer().word(&segment.ident.name.as_str())?;\n+                    } else if segment.ident.name == keywords::DollarCrate.name() {\n+                        self.print_dollar_crate(segment.ident.span.ctxt())?;\n                     }\n                 }\n                 self.writer().space()?;\n@@ -768,15 +768,15 @@ pub trait PrintState<'a> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n             ast::MetaItemKind::Word => {\n-                self.writer().word(&item.name.as_str())?;\n+                self.writer().word(&item.ident.name.as_str())?;\n             }\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.word_space(&item.name.as_str())?;\n+                self.word_space(&item.ident.name.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.writer().word(&item.name.as_str())?;\n+                self.writer().word(&item.ident.name.as_str())?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],\n@@ -1540,7 +1540,7 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n         self.head(\"\")?;\n         let generics = ast::Generics::default();\n-        self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n+        self.print_struct(&v.node.data, &generics, v.node.ident, v.span, false)?;\n         match v.node.disr_expr {\n             Some(ref d) => {\n                 self.s.space()?;\n@@ -1924,7 +1924,7 @@ impl<'a> State<'a> {\n             |s, field| {\n                 s.ibox(INDENT_UNIT)?;\n                 if !field.is_shorthand {\n-                    s.print_ident(field.ident.node)?;\n+                    s.print_ident(field.ident)?;\n                     s.word_space(\":\")?;\n                 }\n                 s.print_expr(&field.expr)?;\n@@ -1981,7 +1981,7 @@ impl<'a> State<'a> {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n-        self.print_ident(segment.identifier)?;\n+        self.print_ident(segment.ident)?;\n         if let Some(ref parameters) = segment.parameters {\n             self.print_path_parameters(parameters, true)?;\n         }\n@@ -2198,10 +2198,10 @@ impl<'a> State<'a> {\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(rhs, prec)?;\n             }\n-            ast::ExprKind::Field(ref expr, id) => {\n+            ast::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n-                self.print_ident(id.node)?;\n+                self.print_ident(ident)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n@@ -2417,14 +2417,14 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.identifier.name != keywords::CrateRoot.name() &&\n-           segment.identifier.name != keywords::DollarCrate.name() {\n-            self.print_ident(segment.identifier)?;\n+        if segment.ident.name != keywords::CrateRoot.name() &&\n+           segment.ident.name != keywords::DollarCrate.name() {\n+            self.print_ident(segment.ident)?;\n             if let Some(ref parameters) = segment.parameters {\n                 self.print_path_parameters(parameters, colons_before_params)?;\n             }\n-        } else if segment.identifier.name == keywords::DollarCrate.name() {\n-            self.print_dollar_crate(segment.identifier.ctxt)?;\n+        } else if segment.ident.name == keywords::DollarCrate.name() {\n+            self.print_dollar_crate(segment.ident.span.ctxt())?;\n         }\n         Ok(())\n     }\n@@ -2446,7 +2446,7 @@ impl<'a> State<'a> {\n         self.s.word(\">\")?;\n         self.s.word(\"::\")?;\n         let item_segment = path.segments.last().unwrap();\n-        self.print_ident(item_segment.identifier)?;\n+        self.print_ident(item_segment.ident)?;\n         match item_segment.parameters {\n             Some(ref parameters) => self.print_path_parameters(parameters, colons_before_params),\n             None => Ok(()),\n@@ -2526,7 +2526,7 @@ impl<'a> State<'a> {\n          is that it doesn't matter */\n         match pat.node {\n             PatKind::Wild => self.s.word(\"_\")?,\n-            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n+            PatKind::Ident(binding_mode, ident, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -2537,7 +2537,7 @@ impl<'a> State<'a> {\n                         self.word_nbsp(\"mut\")?;\n                     }\n                 }\n-                self.print_ident(path1.node)?;\n+                self.print_ident(ident)?;\n                 if let Some(ref p) = *sub {\n                     self.s.word(\"@\")?;\n                     self.print_pat(p)?;\n@@ -2999,7 +2999,7 @@ impl<'a> State<'a> {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n                     let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n-                        ident.node.name == keywords::Invalid.name()\n+                        ident.name == keywords::Invalid.name()\n                     } else {\n                         false\n                     };\n@@ -3194,7 +3194,7 @@ mod tests {\n             let ident = ast::Ident::from_str(\"principal_skinner\");\n \n             let var = codemap::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n-                name: ident,\n+                ident,\n                 attrs: Vec::new(),\n                 // making this up as I go.... ?\n                 data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),"}, {"sha": "63d7b3336a861a9158d5c26aa3fa0f594a33a79a", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -57,7 +57,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n                                         attr::mk_attr_id(),\n-                                        attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n+                                        attr::mk_word_item(ast::Ident::from_str(\"macro_use\")))],\n         vis: dummy_spanned(ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::ExternCrate(alt_std_name.map(Symbol::intern)),\n         ident: ast::Ident::from_str(name),\n@@ -70,7 +70,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n-            path: ast::Path::from_ident(span, ast::Ident::from_str(\"prelude_import\")),\n+            path: ast::Path::from_ident(ast::Ident::new(Symbol::intern(\"prelude_import\"), span)),\n             tokens: TokenStream::empty(),\n             id: attr::mk_attr_id(),\n             is_sugared_doc: false,\n@@ -80,7 +80,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n                 segments: [name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                    ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n+                    ast::PathSegment::from_ident(ast::Ident::from_str(name))\n                 }).collect(),\n                 span,\n             },"}, {"sha": "fd2e760e9bee0ab5108d76eb779735280dcf909b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -195,10 +195,10 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_str = Symbol::intern(\"allow\");\n-                    let dead_code_str = Symbol::intern(\"dead_code\");\n-                    let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n-                    let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n+                    let allow_ident = Ident::from_str(\"allow\");\n+                    let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n+                    let allow_dead_code_item = attr::mk_list_item(DUMMY_SP, allow_ident,\n+                                                                  vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(DUMMY_SP,\n                                                               attr::mk_attr_id(),\n                                                               allow_dead_code_item);\n@@ -623,7 +623,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n-        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id, DUMMY_SP)).collect(),\n+        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id)).collect(),\n     }\n }\n "}, {"sha": "d4c6b4b158b25dc2590063e1e04d6e0cced892c7", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -27,9 +27,9 @@ impl NodeCounter {\n }\n \n impl<'ast> Visitor<'ast> for NodeCounter {\n-    fn visit_ident(&mut self, span: Span, ident: Ident) {\n+    fn visit_ident(&mut self, ident: Ident) {\n         self.count += 1;\n-        walk_ident(self, span, ident);\n+        walk_ident(self, ident);\n     }\n     fn visit_mod(&mut self, m: &Mod, _s: Span, _a: &[Attribute], _n: NodeId) {\n         self.count += 1;"}, {"sha": "fdb3e2c5f31db138e55b23eeda7c4500df1a23f7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -55,8 +55,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n-    fn visit_ident(&mut self, span: Span, ident: Ident) {\n-        walk_ident(self, span, ident);\n+    fn visit_ident(&mut self, ident: Ident) {\n+        walk_ident(self, ident);\n     }\n     fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) {\n         walk_mod(self, m);\n@@ -166,8 +166,8 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident) {\n-    visitor.visit_name(span, ident.name);\n+pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.span, ident.name);\n }\n \n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n@@ -189,11 +189,11 @@ pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n }\n \n pub fn walk_label<'a, V: Visitor<'a>>(visitor: &mut V, label: &'a Label) {\n-    visitor.visit_ident(label.span, label.ident);\n+    visitor.visit_ident(label.ident);\n }\n \n pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n-    visitor.visit_ident(lifetime.span, lifetime.ident);\n+    visitor.visit_ident(lifetime.ident);\n }\n \n pub fn walk_poly_trait_ref<'a, V>(visitor: &mut V,\n@@ -211,7 +211,7 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n \n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n-    visitor.visit_ident(item.span, item.ident);\n+    visitor.visit_ident(item.ident);\n     match item.node {\n         ItemKind::ExternCrate(orig_name) => {\n             if let Some(orig_name) = orig_name {\n@@ -293,8 +293,8 @@ pub fn walk_variant<'a, V>(visitor: &mut V,\n                            item_id: NodeId)\n     where V: Visitor<'a>,\n {\n-    visitor.visit_ident(variant.span, variant.node.name);\n-    visitor.visit_variant_data(&variant.node.data, variant.node.name,\n+    visitor.visit_ident(variant.node.ident);\n+    visitor.visit_variant_data(&variant.node.data, variant.node.ident,\n                              generics, item_id, variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n@@ -357,7 +357,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n     match use_tree.kind {\n         UseTreeKind::Simple(rename) => {\n             if let Some(rename) = rename {\n-                visitor.visit_ident(use_tree.span, rename);\n+                visitor.visit_ident(rename);\n             }\n         }\n         UseTreeKind::Glob => {},\n@@ -372,7 +372,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n-    visitor.visit_ident(path_span, segment.identifier);\n+    visitor.visit_ident(segment.ident);\n     if let Some(ref parameters) = segment.parameters {\n         visitor.visit_path_parameters(path_span, parameters);\n     }\n@@ -398,7 +398,7 @@ pub fn walk_path_parameters<'a, V>(visitor: &mut V,\n \n pub fn walk_assoc_type_binding<'a, V: Visitor<'a>>(visitor: &mut V,\n                                                    type_binding: &'a TypeBinding) {\n-    visitor.visit_ident(type_binding.span, type_binding.ident);\n+    visitor.visit_ident(type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n@@ -418,7 +418,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n                 walk_list!(visitor, visit_attribute, field.node.attrs.iter());\n-                visitor.visit_ident(field.span, field.node.ident);\n+                visitor.visit_ident(field.node.ident);\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n@@ -430,8 +430,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         PatKind::Paren(ref subpattern) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n-            visitor.visit_ident(pth1.span, pth1.node);\n+        PatKind::Ident(_, ident, ref optional_subpattern) => {\n+            visitor.visit_ident(ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n@@ -451,7 +451,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a ForeignItem) {\n     visitor.visit_vis(&foreign_item.vis);\n-    visitor.visit_ident(foreign_item.span, foreign_item.ident);\n+    visitor.visit_ident(foreign_item.ident);\n \n     match foreign_item.node {\n         ForeignItemKind::Fn(ref function_declaration, ref generics) => {\n@@ -489,7 +489,7 @@ pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Generi\n             walk_list!(visitor, visit_attribute, &*l.attrs);\n         }\n         GenericParam::Type(ref t) => {\n-            visitor.visit_ident(t.span, t.ident);\n+            visitor.visit_ident(t.ident);\n             walk_list!(visitor, visit_ty_param_bound, &t.bounds);\n             walk_list!(visitor, visit_ty, &t.default);\n             walk_list!(visitor, visit_attribute, &*t.attrs);\n@@ -561,7 +561,7 @@ pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl\n }\n \n pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a TraitItem) {\n-    visitor.visit_ident(trait_item.span, trait_item.ident);\n+    visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.node {\n@@ -588,7 +588,7 @@ pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a Trai\n \n pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplItem) {\n     visitor.visit_vis(&impl_item.vis);\n-    visitor.visit_ident(impl_item.span, impl_item.ident);\n+    visitor.visit_ident(impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     visitor.visit_generics(&impl_item.generics);\n     match impl_item.node {\n@@ -616,7 +616,7 @@ pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &\n pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n     visitor.visit_vis(&struct_field.vis);\n     if let Some(ident) = struct_field.ident {\n-        visitor.visit_ident(struct_field.span, ident);\n+        visitor.visit_ident(ident);\n     }\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n@@ -666,7 +666,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n                 walk_list!(visitor, visit_attribute, field.attrs.iter());\n-                visitor.visit_ident(field.ident.span, field.ident.node);\n+                visitor.visit_ident(field.ident);\n                 visitor.visit_expr(&field.expr)\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n@@ -745,9 +745,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n         }\n-        ExprKind::Field(ref subexpression, ref ident) => {\n+        ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident.span, ident.node);\n+            visitor.visit_ident(ident);\n         }\n         ExprKind::TupField(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "7352c494a426cf3c8468d1ee7c55861b5f45e32c", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -14,6 +14,7 @@ use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -35,9 +36,9 @@ pub fn expand_assert<'cx>(\n         None\n     };\n \n-    let sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+    let sp = sp.apply_mark(cx.current_expansion.mark);\n     let panic_call = Mac_ {\n-        path: Path::from_ident(sp, Ident::from_str(\"panic\")),\n+        path: Path::from_ident(Ident::new(Symbol::intern(\"panic\"), sp)),\n         tts: if let Some(ts) = custom_msg_args {\n             ts.into()\n         } else {"}, {"sha": "6acc578d07e783040ba0aec680b6b242f4d008c0", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -24,7 +24,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n                        -> Box<base::MacResult + 'static> {\n-    let sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+    let sp = sp.apply_mark(cx.current_expansion.mark);\n     let mut p = cx.new_parser_from_tts(tts);\n     let cfg = panictry!(p.parse_meta_item());\n "}, {"sha": "6c085528a6632e4ac17091a68399dab6d1c79928", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -57,6 +57,6 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    let sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+    let sp = sp.apply_mark(cx.current_expansion.mark);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "544b1410d3d912135d8550c01d5345635ebb40d6", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -16,7 +16,6 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n-use syntax_pos::hygiene::SyntaxContext;\n use syntax::tokenstream::TokenTree;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n@@ -53,46 +52,29 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         }\n     }\n-    let res = ast::Ident {\n-        name: Symbol::intern(&res_str),\n-        ctxt: SyntaxContext::empty().apply_mark(cx.current_expansion.mark),\n-    };\n \n-    struct Result {\n-        ident: ast::Ident,\n-        span: Span,\n-    };\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), sp.apply_mark(cx.current_expansion.mark));\n \n-    impl Result {\n-        fn path(&self) -> ast::Path {\n-            ast::Path {\n-                span: self.span,\n-                segments: vec![ast::PathSegment::from_ident(self.ident, self.span)],\n-            }\n-        }\n-    }\n+    struct ConcatIdentsResult { ident: ast::Ident }\n \n-    impl base::MacResult for Result {\n+    impl base::MacResult for ConcatIdentsResult {\n         fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n             Some(P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Path(None, self.path()),\n-                span: self.span,\n+                node: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n+                span: self.ident.span,\n                 attrs: ast::ThinVec::new(),\n             }))\n         }\n \n         fn make_ty(self: Box<Self>) -> Option<P<ast::Ty>> {\n             Some(P(ast::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::TyKind::Path(None, self.path()),\n-                span: self.span,\n+                node: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n+                span: self.ident.span,\n             }))\n         }\n     }\n \n-    Box::new(Result {\n-        ident: res,\n-        span: sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark)),\n-    })\n+    Box::new(ConcatIdentsResult { ident })\n }"}, {"sha": "dec24d13c9b493fd766013b773c612a14f966f0a", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -177,7 +177,7 @@ fn cs_clone(name: &str,\n             vdata = vdata_;\n         }\n         EnumMatching(.., variant, ref af) => {\n-            ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.name]);\n+            ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.ident]);\n             all_fields = af;\n             vdata = &variant.node.data;\n         }"}, {"sha": "c007285cd85191afdf4eaa0037e3cd5cf7035de1", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -61,7 +61,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n     // based on the \"shape\".\n     let (ident, is_struct) = match *substr.fields {\n         Struct(vdata, _) => (substr.type_ident, vdata.is_struct()),\n-        EnumMatching(_, _, v, _) => (v.node.name, v.node.data.is_struct()),\n+        EnumMatching(_, _, v, _) => (v.node.ident, v.node.data.is_struct()),\n         EnumNonMatchingCollapsed(..) |\n         StaticStruct(..) |\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),"}, {"sha": "d579b3abd45a902b39a947ddc480975717fddcd1", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -277,7 +277,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, variant.node.name.name);\n+            let name = cx.expr_str(trait_span, variant.node.ident.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),"}, {"sha": "4126ce79f355517d8e8502796727378adc4f73f2", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -195,6 +195,7 @@ use syntax::abi::Abi;\n use syntax::ast::{\n     self, BinOpKind, EnumDef, Expr, GenericParam, Generics, Ident, PatKind, VariantData\n };\n+\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -367,7 +368,7 @@ fn find_type_parameters(ty: &ast::Ty,\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n             if let ast::TyKind::Path(_, ref path) = ty.node {\n                 if let Some(segment) = path.segments.first() {\n-                    if self.ty_param_names.contains(&segment.identifier.name) {\n+                    if self.ty_param_names.contains(&segment.ident.name) {\n                         self.types.push(P(ty.clone()));\n                     }\n                 }\n@@ -622,7 +623,7 @@ impl<'a> TraitDef<'a> {\n                         // if we have already handled this type, skip it\n                         if let ast::TyKind::Path(_, ref p) = ty.node {\n                             if p.segments.len() == 1 &&\n-                            ty_param_names.contains(&p.segments[0].identifier.name) ||\n+                            ty_param_names.contains(&p.segments[0].ident.name) ||\n                             processed_field_types.contains(&p.segments) {\n                                 continue;\n                             };\n@@ -952,7 +953,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 ast::Arg::from_self(explicit_self,\n-                                    respan(trait_.span, keywords::SelfValue.ident()))\n+                                    keywords::SelfValue.ident().with_span_pos(trait_.span))\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n@@ -1537,10 +1538,9 @@ impl<'a> MethodDef<'a> {\n         let summary = enum_def.variants\n             .iter()\n             .map(|v| {\n-                let ident = v.node.name;\n                 let sp = v.span.with_ctxt(trait_.span.ctxt());\n                 let summary = trait_.summarise_struct(cx, &v.node.data);\n-                (ident, sp, summary)\n+                (v.node.ident, sp, summary)\n             })\n             .collect();\n         self.call_substructure_method(cx,\n@@ -1581,7 +1581,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: Vec<ast::SpannedIdent>,\n+                          field_paths: Vec<ast::Ident>,\n                           mutbl: ast::Mutability,\n                           use_temporaries: bool)\n                           -> Vec<P<ast::Pat>> {\n@@ -1613,10 +1613,7 @@ impl<'a> TraitDef<'a> {\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n-            paths.push(codemap::Spanned {\n-                span: sp,\n-                node: ident,\n-            });\n+            paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {\n                 val\n@@ -1669,9 +1666,8 @@ impl<'a> TraitDef<'a> {\n          prefix: &str,\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n-        let variant_ident = variant.node.name;\n         let sp = variant.span.with_ctxt(self.span.ctxt());\n-        let variant_path = cx.path(sp, vec![enum_ident, variant_ident]);\n+        let variant_path = cx.path(sp, vec![enum_ident, variant.node.ident]);\n         let use_temporaries = false; // enums can't be repr(packed)\n         self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl,\n                                    use_temporaries)"}, {"sha": "25a2969448835dca4ba648e9be841b01dd61ee0f", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -18,10 +18,9 @@ use syntax::ast;\n use syntax::ast::{Expr, GenericParam, Generics, Ident, SelfKind};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::respan;\n+use syntax::codemap::{respan, DUMMY_SP};\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::SyntaxContext;\n use syntax_pos::symbol::keywords;\n \n /// The types of pointers\n@@ -93,8 +92,8 @@ impl<'a> Path<'a> {\n             PathKind::Global => cx.path_all(span, true, idents, lt, tys, Vec::new()),\n             PathKind::Local => cx.path_all(span, false, idents, lt, tys, Vec::new()),\n             PathKind::Std => {\n-                let def_site = SyntaxContext::empty().apply_mark(cx.current_expansion.mark);\n-                idents.insert(0, Ident { ctxt: def_site, ..keywords::DollarCrate.ident() });\n+                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.mark);\n+                idents.insert(0, Ident::new(keywords::DollarCrate.name(), def_site));\n                 cx.path_all(span, false, idents, lt, tys, Vec::new())\n             }\n         }"}, {"sha": "4e1af108ab4fa038765d01da23b0977a3d5922ce", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -32,7 +32,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some(v) => v,\n     };\n \n-    let sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+    let sp = sp.apply_mark(cx.current_expansion.mark);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             let lt = cx.lifetime(sp, keywords::StaticLifetime.ident());"}, {"sha": "c78decb1eb9d0bc2983a94c75974fe9c8e4a0a22", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -641,7 +641,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   ty: &ArgumentType,\n                   arg: ast::Ident)\n                   -> P<ast::Expr> {\n-        sp = sp.with_ctxt(sp.ctxt().apply_mark(ecx.current_expansion.mark));\n+        sp = sp.apply_mark(ecx.current_expansion.mark);\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n@@ -678,7 +678,7 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n                                mut sp: Span,\n                                tts: &[tokenstream::TokenTree])\n                                -> Box<base::MacResult + 'cx> {\n-    sp = sp.with_ctxt(sp.ctxt().apply_mark(ecx.current_expansion.mark));\n+    sp = sp.apply_mark(ecx.current_expansion.mark);\n     match parse_args(ecx, sp, tts) {\n         Some((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names))\n@@ -700,7 +700,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let mut macsp = ecx.call_site();\n-    macsp = macsp.with_ctxt(macsp.ctxt().apply_mark(ecx.current_expansion.mark));\n+    macsp = macsp.apply_mark(ecx.current_expansion.mark);\n     let msg = \"format argument must be a string literal.\";\n     let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n         Some(fmt) => fmt,"}, {"sha": "d684e8b4ffea5a4894428fa73f587199863b905e", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute, respan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::fold::Folder;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n@@ -371,7 +371,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n             allow_internal_unsafe: false,\n         }\n     });\n-    let span = DUMMY_SP.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n+    let span = DUMMY_SP.apply_mark(mark);\n \n     let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,"}, {"sha": "c180563450f83ebf712ea05dda99a1aeba64d2ff", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -123,7 +123,7 @@ pub struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n-    gensym_to_ctxt: HashMap<Symbol, SyntaxContext>,\n+    gensym_to_ctxt: HashMap<Symbol, Span>,\n }\n \n impl HygieneData {\n@@ -461,15 +461,15 @@ impl Symbol {\n     pub fn from_ident(ident: Ident) -> Symbol {\n         HygieneData::with(|data| {\n             let gensym = ident.name.gensymed();\n-            data.gensym_to_ctxt.insert(gensym, ident.ctxt);\n+            data.gensym_to_ctxt.insert(gensym, ident.span);\n             gensym\n         })\n     }\n \n     pub fn to_ident(self) -> Ident {\n         HygieneData::with(|data| {\n             match data.gensym_to_ctxt.get(&self) {\n-                Some(&ctxt) => Ident { name: self.interned(), ctxt: ctxt },\n+                Some(&span) => Ident::new(self.interned(), span),\n                 None => Ident::with_empty_ctxt(self),\n             }\n         })"}, {"sha": "8b2ebfef2504e13aa4b6ddeb7341eeaa45ac5890", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -50,7 +50,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n extern crate unicode_width;\n \n pub mod hygiene;\n-pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n+pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -422,6 +422,52 @@ impl Span {\n             if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n         )\n     }\n+\n+    #[inline]\n+    pub fn apply_mark(self, mark: Mark) -> Span {\n+        let span = self.data();\n+        span.with_ctxt(span.ctxt.apply_mark(mark))\n+    }\n+\n+    #[inline]\n+    pub fn remove_mark(&mut self) -> Mark {\n+        let mut span = self.data();\n+        let mark = span.ctxt.remove_mark();\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.adjust(expansion);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn glob_adjust(&mut self, expansion: Mark, glob_ctxt: SyntaxContext)\n+                       -> Option<Option<Mark>> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.glob_adjust(expansion, glob_ctxt);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_ctxt: SyntaxContext)\n+                               -> Option<Option<Mark>> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.reverse_glob_adjust(expansion, glob_ctxt);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn modern(self) -> Span {\n+        let span = self.data();\n+        span.with_ctxt(span.ctxt.modern())\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "331b0fe5481d5c0d0593626b21dcce8288b241e3", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -13,40 +13,64 @@\n //! type, and vice versa.\n \n use hygiene::SyntaxContext;\n-use GLOBALS;\n+use {Span, DUMMY_SP, GLOBALS};\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::collections::HashMap;\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Eq)]\n pub struct Ident {\n     pub name: Symbol,\n-    pub ctxt: SyntaxContext,\n+    pub span: Span,\n }\n \n impl Ident {\n+    #[inline]\n+    pub const fn new(name: Symbol, span: Span) -> Ident {\n+        Ident { name, span }\n+    }\n+    #[inline]\n     pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n-        Ident { name: name, ctxt: SyntaxContext::empty() }\n+        Ident::new(name, DUMMY_SP)\n     }\n \n     /// Maps a string to an identifier with an empty syntax context.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n-    pub fn without_first_quote(&self) -> Ident {\n-        Ident { name: Symbol::from(self.name.as_str().trim_left_matches('\\'')), ctxt: self.ctxt }\n+    /// Replace `lo` and `hi` with those from `span`, but keep hygiene context.\n+    pub fn with_span_pos(self, span: Span) -> Ident {\n+        Ident::new(self.name, span.with_ctxt(self.span.ctxt()))\n+    }\n+\n+    pub fn without_first_quote(self) -> Ident {\n+        Ident::new(Symbol::intern(self.name.as_str().trim_left_matches('\\'')), self.span)\n     }\n \n     pub fn modern(self) -> Ident {\n-        Ident { name: self.name, ctxt: self.ctxt.modern() }\n+        Ident::new(self.name, self.span.modern())\n+    }\n+}\n+\n+impl PartialEq for Ident {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.name == rhs.name && self.span.ctxt() == rhs.span.ctxt()\n+    }\n+}\n+\n+impl Hash for Ident {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state);\n+        self.span.ctxt().hash(state);\n     }\n }\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{:?}\", self.name, self.ctxt)\n+        write!(f, \"{}{:?}\", self.name, self.span.ctxt())\n     }\n }\n \n@@ -58,7 +82,7 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        if self.ctxt.modern() == SyntaxContext::empty() {\n+        if self.span.ctxt().modern() == SyntaxContext::empty() {\n             s.emit_str(&self.name.as_str())\n         } else { // FIXME(jseyfried) intercrate hygiene\n             let mut string = \"#\".to_owned();\n@@ -123,12 +147,6 @@ impl Symbol {\n     }\n }\n \n-impl<'a> From<&'a str> for Symbol {\n-    fn from(string: &'a str) -> Symbol {\n-        Symbol::intern(string)\n-    }\n-}\n-\n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));"}, {"sha": "040f0b661be14fab1b21698a682b0e837f29dad7", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -117,7 +117,7 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                ast::Ident::with_empty_ctxt(word.name())\n+                word.ident\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "2f80408ac1ce98833c65cefe424f84039810e961", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -112,7 +112,7 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                ast::Ident::with_empty_ctxt(word.name())\n+                word.ident\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "3a848a31c4dd7671e712322a322d1132168f15fa", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -61,15 +61,8 @@ fn expr(kind: ExprKind) -> P<Expr> {\n }\n \n fn make_x() -> P<Expr> {\n-    let seg = PathSegment {\n-        identifier: Ident::from_str(\"x\"),\n-        span: DUMMY_SP,\n-        parameters: None,\n-    };\n-    let path = Path {\n-        span: DUMMY_SP,\n-        segments: vec![seg],\n-    };\n+    let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n+    let path = Path { segments: vec![seg], span: DUMMY_SP };\n     expr(ExprKind::Path(None, path))\n }\n \n@@ -89,12 +82,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n             1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n             2 => {\n-                let seg = PathSegment {\n-                    identifier: Ident::from_str(\"x\"),\n-                    span: DUMMY_SP,\n-                    parameters: None,\n-                };\n-\n+                let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n                             seg.clone(), vec![e, make_x()])));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n@@ -146,8 +134,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e)));\n             },\n             10 => {\n-                let ident = Spanned { span: DUMMY_SP, node: Ident::from_str(\"f\") };\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, ident)));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, Ident::from_str(\"f\"))));\n             },\n             11 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n@@ -163,15 +150,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n             },\n             14 => {\n-                let seg = PathSegment {\n-                    identifier: Ident::from_str(\"S\"),\n-                    span: DUMMY_SP,\n-                    parameters: None,\n-                };\n-                let path = Path {\n-                    span: DUMMY_SP,\n-                    segments: vec![seg],\n-                };\n+                let path = Path::from_ident(Ident::from_str(\"S\"));\n                 g(ExprKind::Struct(path, vec![], Some(make_x())));\n             },\n             15 => {"}, {"sha": "a2853570d6d3fa1a04f11b6246d1ef723f829122", "filename": "src/test/ui/feature-gate-non_ascii_idents.stderr", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Fui%2Ffeature-gate-non_ascii_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a143462783cec88b7b733e8aa09990bfeb59f754/src%2Ftest%2Fui%2Ffeature-gate-non_ascii_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-non_ascii_idents.stderr?ref=a143462783cec88b7b733e8aa09990bfeb59f754", "patch": "@@ -1,38 +1,32 @@\n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:11:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:11:22\n    |\n LL | extern crate core as b\u00e4z; //~ ERROR non-ascii idents\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                      ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n   --> $DIR/feature-gate-non_ascii_idents.rs:13:5\n    |\n LL | use f\u00f6\u00f6::bar; //~ ERROR non-ascii idents\n-   |     ^^^^^^^^\n+   |     ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:15:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:15:5\n    |\n LL | mod f\u00f6\u00f6 { //~ ERROR non-ascii idents\n-   | ^^^^^^^\n+   |     ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:19:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:19:4\n    |\n-LL | / fn b\u00e4r( //~ ERROR non-ascii idents\n-LL | |     b\u00e4z: isize //~ ERROR non-ascii idents\n-LL | |     ) {\n-LL | |     let _\u00f6: isize; //~ ERROR non-ascii idents\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL | fn b\u00e4r( //~ ERROR non-ascii idents\n+   |    ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n@@ -61,26 +55,26 @@ LL |         (_\u00e4, _) => {} //~ ERROR non-ascii idents\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:29:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:29:8\n    |\n LL | struct F\u00f6\u00f6 { //~ ERROR non-ascii idents\n-   | ^^^^^^^^^^\n+   |        ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n   --> $DIR/feature-gate-non_ascii_idents.rs:30:5\n    |\n LL |     f\u00f6\u00f6: isize //~ ERROR non-ascii idents\n-   |     ^^^^^^^^^^\n+   |     ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:33:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:33:6\n    |\n LL | enum B\u00e4r { //~ ERROR non-ascii idents\n-   | ^^^^^^^^\n+   |      ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n@@ -96,15 +90,15 @@ error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n   --> $DIR/feature-gate-non_ascii_idents.rs:35:9\n    |\n LL |         q\u00fcx: isize //~ ERROR non-ascii idents\n-   |         ^^^^^^^^^^\n+   |         ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:40:5\n+  --> $DIR/feature-gate-non_ascii_idents.rs:40:8\n    |\n LL |     fn q\u00fcx();  //~ ERROR non-ascii idents\n-   |     ^^^^^^^^^\n+   |        ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n "}]}