{"sha": "0e652c550711b301086b8f5ead2f6c90418fe7a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjUyYzU1MDcxMWIzMDEwODZiOGY1ZWFkMmY2YzkwNDE4ZmU3YTE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-12T16:24:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-13T17:53:21Z"}, "message": "Move resolve_instance to rustc_ty.", "tree": {"sha": "3c451c0cd7eb9f665c6fa1b2c153d722d1c50968", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c451c0cd7eb9f665c6fa1b2c153d722d1c50968"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e652c550711b301086b8f5ead2f6c90418fe7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e652c550711b301086b8f5ead2f6c90418fe7a1", "html_url": "https://github.com/rust-lang/rust/commit/0e652c550711b301086b8f5ead2f6c90418fe7a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e652c550711b301086b8f5ead2f6c90418fe7a1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be493fe8cc40c3d3f6030a1313c1ff747fce770d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be493fe8cc40c3d3f6030a1313c1ff747fce770d", "html_url": "https://github.com/rust-lang/rust/commit/be493fe8cc40c3d3f6030a1313c1ff747fce770d"}], "stats": {"total": 284, "additions": 161, "deletions": 123}, "files": [{"sha": "007a752129062426cbb8766d0b52b57980f063ba", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -4123,6 +4123,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_span\",\n+ \"rustc_target\",\n ]\n \n [[package]]"}, {"sha": "332fd0bf46fb446a1c5365bb484d13f14aefa85d", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 20, "deletions": 123, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -1,12 +1,11 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::middle::lang_items::DropInPlaceFnLangItem;\n-use crate::traits;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeFoldable};\n+use rustc_data_structures::AtomicRef;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_macros::HashStable;\n-use rustc_target::spec::abi::Abi;\n \n use std::fmt;\n \n@@ -263,45 +262,7 @@ impl<'tcx> Instance<'tcx> {\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n-        debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n-        let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n-            debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n-            let item = tcx.associated_item(def_id);\n-            resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n-        } else {\n-            let ty = tcx.type_of(def_id);\n-            let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, &ty);\n-\n-            let def = match item_type.kind {\n-                ty::FnDef(..)\n-                    if {\n-                        let f = item_type.fn_sig(tcx);\n-                        f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic\n-                    } =>\n-                {\n-                    debug!(\" => intrinsic\");\n-                    ty::InstanceDef::Intrinsic(def_id)\n-                }\n-                _ => {\n-                    if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n-                        let ty = substs.type_at(0);\n-                        if ty.needs_drop(tcx, param_env.with_reveal_all()) {\n-                            debug!(\" => nontrivial drop glue\");\n-                            ty::InstanceDef::DropGlue(def_id, Some(ty))\n-                        } else {\n-                            debug!(\" => trivial drop glue\");\n-                            ty::InstanceDef::DropGlue(def_id, None)\n-                        }\n-                    } else {\n-                        debug!(\" => free item\");\n-                        ty::InstanceDef::Item(def_id)\n-                    }\n-                }\n-            };\n-            Some(Instance { def: def, substs: substs })\n-        };\n-        debug!(\"resolve(def_id={:?}, substs={:?}) = {:?}\", def_id, substs, result);\n-        result\n+        (*RESOLVE_INSTANCE)(tcx, param_env, def_id, substs)\n     }\n \n     pub fn resolve_for_fn_ptr(\n@@ -398,88 +359,6 @@ impl<'tcx> Instance<'tcx> {\n     }\n }\n \n-fn resolve_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_item: &ty::AssocItem,\n-    param_env: ty::ParamEnv<'tcx>,\n-    trait_id: DefId,\n-    rcvr_substs: SubstsRef<'tcx>,\n-) -> Option<Instance<'tcx>> {\n-    let def_id = trait_item.def_id;\n-    debug!(\n-        \"resolve_associated_item(trait_item={:?}, \\\n-            param_env={:?}, \\\n-            trait_id={:?}, \\\n-            rcvr_substs={:?})\",\n-        def_id, param_env, trait_id, rcvr_substs\n-    );\n-\n-    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) =\n-                traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n-\n-            let resolved_item = tcx.associated_item(def_id);\n-\n-            // Since this is a trait item, we need to see if the item is either a trait default item\n-            // or a specialization because we can't resolve those unless we can `Reveal::All`.\n-            // NOTE: This should be kept in sync with the similar code in\n-            // `rustc::traits::project::assemble_candidates_from_impls()`.\n-            let eligible = if !resolved_item.defaultness.is_default() {\n-                true\n-            } else if param_env.reveal == traits::Reveal::All {\n-                !trait_ref.needs_subst()\n-            } else {\n-                false\n-            };\n-\n-            if !eligible {\n-                return None;\n-            }\n-\n-            let substs = tcx.erase_regions(&substs);\n-            Some(ty::Instance::new(def_id, substs))\n-        }\n-        traits::VtableGenerator(generator_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-            substs: generator_data.substs,\n-        }),\n-        traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n-            Some(Instance::resolve_closure(\n-                tcx,\n-                closure_data.closure_def_id,\n-                closure_data.substs,\n-                trait_closure_kind,\n-            ))\n-        }\n-        traits::VtableFnPointer(ref data) => Some(Instance {\n-            def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n-            substs: rcvr_substs,\n-        }),\n-        traits::VtableObject(ref data) => {\n-            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n-            Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n-        }\n-        traits::VtableBuiltin(..) => {\n-            if tcx.lang_items().clone_trait().is_some() {\n-                Some(Instance {\n-                    def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n-                    substs: rcvr_substs,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-        traits::VtableAutoImpl(..) | traits::VtableParam(..) | traits::VtableTraitAlias(..) => None,\n-    }\n-}\n-\n fn needs_fn_once_adapter_shim(\n     actual_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,\n@@ -512,3 +391,21 @@ fn needs_fn_once_adapter_shim(\n         (ty::ClosureKind::FnMut, _) | (ty::ClosureKind::FnOnce, _) => Err(()),\n     }\n }\n+\n+fn resolve_instance_default(\n+    _tcx: TyCtxt<'tcx>,\n+    _param_env: ty::ParamEnv<'tcx>,\n+    _def_id: DefId,\n+    _substs: SubstsRef<'tcx>,\n+) -> Option<Instance<'tcx>> {\n+    unimplemented!()\n+}\n+\n+pub static RESOLVE_INSTANCE: AtomicRef<\n+    for<'tcx> fn(\n+        TyCtxt<'tcx>,\n+        ty::ParamEnv<'tcx>,\n+        DefId,\n+        SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>>,\n+> = AtomicRef::new(&(resolve_instance_default as _));"}, {"sha": "04e8c0c38d773390bb17c51a1793f9828429fa45", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -83,6 +83,7 @@ pub use self::context::{\n     CtxtInterners, GeneratorInteriorTypeCause, GlobalCtxt, Lift, TypeckTables,\n };\n \n+pub use self::instance::RESOLVE_INSTANCE;\n pub use self::instance::{Instance, InstanceDef};\n \n pub use self::trait_def::TraitDef;"}, {"sha": "7c8e682e9fb185050b729698050bd09b4ddfccbf", "filename": "src/librustc_interface/callbacks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_interface%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_interface%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fcallbacks.rs?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -58,4 +58,5 @@ pub fn setup_callbacks() {\n     rustc_span::SPAN_DEBUG.swap(&(span_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     rustc_hir::def_id::DEF_ID_DEBUG.swap(&(def_id_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     TRACK_DIAGNOSTICS.swap(&(track_diagnostic as fn(&_)));\n+    rustc::ty::RESOLVE_INSTANCE.swap(&(rustc_ty::instance::resolve_instance as _));\n }"}, {"sha": "52606e5fdfeea08d1c0643d8113a1812345ba4d2", "filename": "src/librustc_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2FCargo.toml?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -14,3 +14,4 @@ rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_span = { path = \"../librustc_span\" }\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "66f189a5d979d9191a4af524c9a880c17398755e", "filename": "src/librustc_ty/instance.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -0,0 +1,136 @@\n+use rustc::traits;\n+use rustc::ty::subst::SubstsRef;\n+use rustc::ty::{self, Instance, TyCtxt, TypeFoldable};\n+use rustc_hir::def_id::DefId;\n+use rustc_target::spec::abi::Abi;\n+\n+use log::debug;\n+\n+pub fn resolve_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+) -> Option<Instance<'tcx>> {\n+    debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n+    let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n+        debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n+        let item = tcx.associated_item(def_id);\n+        resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n+    } else {\n+        let ty = tcx.type_of(def_id);\n+        let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, &ty);\n+\n+        let def = match item_type.kind {\n+            ty::FnDef(..)\n+                if {\n+                    let f = item_type.fn_sig(tcx);\n+                    f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic\n+                } =>\n+            {\n+                debug!(\" => intrinsic\");\n+                ty::InstanceDef::Intrinsic(def_id)\n+            }\n+            _ => {\n+                if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n+                    let ty = substs.type_at(0);\n+                    if ty.needs_drop(tcx, param_env.with_reveal_all()) {\n+                        debug!(\" => nontrivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                    } else {\n+                        debug!(\" => trivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, None)\n+                    }\n+                } else {\n+                    debug!(\" => free item\");\n+                    ty::InstanceDef::Item(def_id)\n+                }\n+            }\n+        };\n+        Some(Instance { def: def, substs: substs })\n+    };\n+    debug!(\"resolve(def_id={:?}, substs={:?}) = {:?}\", def_id, substs, result);\n+    result\n+}\n+\n+fn resolve_associated_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item: &ty::AssocItem,\n+    param_env: ty::ParamEnv<'tcx>,\n+    trait_id: DefId,\n+    rcvr_substs: SubstsRef<'tcx>,\n+) -> Option<Instance<'tcx>> {\n+    let def_id = trait_item.def_id;\n+    debug!(\n+        \"resolve_associated_item(trait_item={:?}, \\\n+            param_env={:?}, \\\n+            trait_id={:?}, \\\n+            rcvr_substs={:?})\",\n+        def_id, param_env, trait_id, rcvr_substs\n+    );\n+\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(impl_data) => {\n+            let (def_id, substs) =\n+                traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n+\n+            let resolved_item = tcx.associated_item(def_id);\n+\n+            // Since this is a trait item, we need to see if the item is either a trait default item\n+            // or a specialization because we can't resolve those unless we can `Reveal::All`.\n+            // NOTE: This should be kept in sync with the similar code in\n+            // `rustc::traits::project::assemble_candidates_from_impls()`.\n+            let eligible = if !resolved_item.defaultness.is_default() {\n+                true\n+            } else if param_env.reveal == traits::Reveal::All {\n+                !trait_ref.needs_subst()\n+            } else {\n+                false\n+            };\n+\n+            if !eligible {\n+                return None;\n+            }\n+\n+            let substs = tcx.erase_regions(&substs);\n+            Some(ty::Instance::new(def_id, substs))\n+        }\n+        traits::VtableGenerator(generator_data) => Some(Instance {\n+            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n+            substs: generator_data.substs,\n+        }),\n+        traits::VtableClosure(closure_data) => {\n+            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n+            Some(Instance::resolve_closure(\n+                tcx,\n+                closure_data.closure_def_id,\n+                closure_data.substs,\n+                trait_closure_kind,\n+            ))\n+        }\n+        traits::VtableFnPointer(ref data) => Some(Instance {\n+            def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+            substs: rcvr_substs,\n+        }),\n+        traits::VtableObject(ref data) => {\n+            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n+            Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n+        }\n+        traits::VtableBuiltin(..) => {\n+            if tcx.lang_items().clone_trait().is_some() {\n+                Some(Instance {\n+                    def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n+                    substs: rcvr_substs,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+        traits::VtableAutoImpl(..) | traits::VtableParam(..) | traits::VtableTraitAlias(..) => None,\n+    }\n+}"}, {"sha": "f9ee4e20d2721b03099f1082237164a013041a4c", "filename": "src/librustc_ty/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_ty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e652c550711b301086b8f5ead2f6c90418fe7a1/src%2Flibrustc_ty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Flib.rs?ref=0e652c550711b301086b8f5ead2f6c90418fe7a1", "patch": "@@ -17,6 +17,7 @@ extern crate log;\n use rustc::ty::query::Providers;\n \n mod common_traits;\n+pub mod instance;\n mod needs_drop;\n mod ty;\n "}]}