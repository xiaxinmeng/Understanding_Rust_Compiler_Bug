{"sha": "b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "node_id": "C_kwDOAAsO6NoAKGI3YjNkMmNlZTBlMzcxZmRlY2Y5NzI2YWI5NDlhMjRlYWQzZGNiOTc", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-15T12:46:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-15T15:47:05Z"}, "message": "generalize the outlives obligation code\n\nThe code now accepts `Binder<OutlivesPredicate>`\ninstead of just `OutlivesPredicate` and thus exercises\nthe new, generalized `IfEqBound` codepaths. Note though\nthat we never *produce* Binder<OutlivesPredicate>, so we\nare only testing a subset of those codepaths that excludes\nactual higher-ranked outlives bounds.", "tree": {"sha": "f697c01e90cb7bea72ce3b2703a8cd4f9302d46f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f697c01e90cb7bea72ce3b2703a8cd4f9302d46f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "html_url": "https://github.com/rust-lang/rust/commit/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f0f66d454c9a04e6f9703e66cbfe6ed109655a", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f0f66d454c9a04e6f9703e66cbfe6ed109655a", "html_url": "https://github.com/rust-lang/rust/commit/10f0f66d454c9a04e6f9703e66cbfe6ed109655a"}], "stats": {"total": 283, "additions": 109, "deletions": 174}, "files": [{"sha": "42a173bf092b7c69a7b751991f41d2a9df3ca58b", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "patch": "@@ -359,13 +359,21 @@ where\n         // #55756) in cases where you have e.g., `<T as Foo<'a>>::Item:\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition.\n-        approx_env_bounds.retain(|bound| match *bound.0.kind() {\n-            ty::Projection(projection_ty) => self\n-                .verify_bound\n-                .projection_declared_bounds_from_trait(projection_ty)\n-                .all(|r| r != bound.1),\n-\n-            _ => panic!(\"expected only projection types from env, not {:?}\", bound.0),\n+        approx_env_bounds.retain(|bound_outlives| {\n+            // OK to skip binder because we only manipulate and compare against other\n+            // values from the same inder. e.g. if we have (e.g.) `for<'a> <T as Trait<'a>>::Item: 'a`\n+            // in `bound`, the `'a` will be a `^1` (bound, debruijn index == innermost) region.\n+            // If the declaration is `trait Trait<'b> { type Item: 'b; }`, then `projection_declared_bounds_from_trait`\n+            // will be invoked with `['b => ^1]` and so we will get `^1` returned.\n+            let bound = bound_outlives.skip_binder();\n+            match *bound.0.kind() {\n+                ty::Projection(projection_ty) => self\n+                    .verify_bound\n+                    .projection_declared_bounds_from_trait(projection_ty)\n+                    .all(|r| r != bound.1),\n+\n+                _ => panic!(\"expected only projection types from env, not {:?}\", bound.0),\n+            }\n         });\n \n         // If declared bounds list is empty, the only applicable rule is\n@@ -416,8 +424,16 @@ where\n         if !trait_bounds.is_empty()\n             && trait_bounds[1..]\n                 .iter()\n-                .chain(approx_env_bounds.iter().map(|b| &b.1))\n-                .all(|b| *b == trait_bounds[0])\n+                .map(|r| Some(*r))\n+                .chain(\n+                    // NB: The environment may contain `for<'a> T: 'a` style bounds.\n+                    // In that case, we don't know if they are equal to the trait bound\n+                    // or not (since we don't *know* whether the environment bound even applies),\n+                    // so just map to `None` here if there are bound vars, ensuring that\n+                    // the call to `all` will fail below.\n+                    approx_env_bounds.iter().map(|b| b.map_bound(|b| b.1).no_bound_vars()),\n+                )\n+                .all(|b| b == Some(trait_bounds[0]))\n         {\n             let unique_bound = trait_bounds[0];\n             debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n@@ -433,7 +449,7 @@ where\n         // even though a satisfactory solution exists.\n         let generic = GenericKind::Projection(projection_ty);\n         let verify_bound = self.verify_bound.generic_bound(generic);\n-        debug!(\"projection_must_outlive: pushing verify_bound={:?}\", verify_bound,);\n+        debug!(\"projection_must_outlive: pushing {:?}\", verify_bound);\n         self.delegate.push_verify(origin, generic, region, verify_bound);\n     }\n }"}, {"sha": "bdd31dafd90d2fd19b5cb22261e885703b166531", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "patch": "@@ -34,6 +34,7 @@ use crate::infer::region_constraints::VerifyIfEq;\n /// like are used. This is a particular challenge since this function is invoked\n /// very late in inference and hence cannot make use of the normal inference\n /// machinery.\n+#[tracing::instrument(level = \"Debug\", skip(tcx, param_env))]\n pub fn extract_verify_if_eq_bound<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -61,6 +62,25 @@ pub fn extract_verify_if_eq_bound<'tcx>(\n     }\n }\n \n+/// True if a (potentially higher-ranked) outlives\n+#[tracing::instrument(level = \"Debug\", skip(tcx, param_env))]\n+pub(super) fn can_match_erased_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    outlives_predicate: ty::Binder<'tcx, ty::TypeOutlivesPredicate<'tcx>>,\n+    erased_ty: Ty<'tcx>,\n+) -> bool {\n+    assert!(!outlives_predicate.has_escaping_bound_vars());\n+    let erased_outlives_predicate = tcx.erase_regions(outlives_predicate);\n+    let outlives_ty = erased_outlives_predicate.skip_binder().0;\n+    if outlives_ty == erased_ty {\n+        // pointless micro-optimization\n+        true\n+    } else {\n+        Match::new(tcx, param_env).relate(outlives_ty, erased_ty).is_ok()\n+    }\n+}\n+\n struct Match<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -82,6 +102,7 @@ impl<'tcx> Match<'tcx> {\n \n     /// Binds the pattern variable `br` to `value`; returns an `Err` if the pattern\n     /// is already bound to a different value.\n+    #[tracing::instrument(level = \"Debug\", skip(self))]\n     fn bind(\n         &mut self,\n         br: ty::BoundRegion,\n@@ -133,15 +154,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         pattern: ty::Region<'tcx>,\n         value: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"self.pattern_depth = {:?}\", self.pattern_depth);\n         if let ty::RegionKind::ReLateBound(depth, br) = pattern.kind() && depth == self.pattern_depth {\n-            self.bind(br, pattern)\n+            self.bind(br, value)\n         } else if pattern == value {\n             Ok(pattern)\n         } else {\n             self.no_match()\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, pattern: Ty<'tcx>, value: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         if pattern == value {\n             return Ok(pattern);\n@@ -150,6 +173,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn consts(\n         &mut self,\n         pattern: ty::Const<'tcx>,"}, {"sha": "a88bcdaef582def448a46e3ed0a218a00ce63049", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "patch": "@@ -1,4 +1,5 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n+use crate::infer::region_constraints::VerifyIfEq;\n use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::sso::SsoHashSet;\n@@ -82,25 +83,39 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         debug!(\"param_bound(param_ty={:?})\", param_ty);\n \n         // Start with anything like `T: 'a` we can scrape from the\n-        // environment\n-        let param_bounds =\n-            self.declared_generic_bounds_from_env(param_ty).into_iter().map(|outlives| outlives.1);\n+        // environment. If the environment contains something like\n+        // `for<'a> T: 'a`, then we know that `T` outlives everything.\n+        let declared_bounds_from_env = self.declared_generic_bounds_from_env(param_ty);\n+        let mut param_bounds = vec![];\n+        for declared_bound in declared_bounds_from_env {\n+            let bound_region = declared_bound.map_bound(|outlives| outlives.1);\n+            if let Some(region) = bound_region.no_bound_vars() {\n+                // This is `T: 'a` for some free region `'a`.\n+                param_bounds.push(VerifyBound::OutlivedBy(region));\n+            } else {\n+                // This is `for<'a> T: 'a`. This means that `T` outlives everything! All done here.\n+                return VerifyBound::AllBounds(vec![]);\n+            }\n+        }\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        let param_bounds = param_bounds.chain(self.implicit_region_bound);\n-\n-        let any_bounds: Vec<_> = param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect();\n+        if let Some(r) = self.implicit_region_bound {\n+            param_bounds.push(VerifyBound::OutlivedBy(r));\n+        }\n \n-        if any_bounds.is_empty() {\n+        if param_bounds.is_empty() {\n             // We know that all types `T` outlive `'empty`, so if we\n             // can find no other bound, then check that the region\n             // being tested is `'empty`.\n             VerifyBound::IsEmpty\n+        } else if param_bounds.len() == 1 {\n+            // Micro-opt: no need to store the vector if it's just len 1\n+            param_bounds.pop().unwrap()\n         } else {\n             // If we can find any other bound `R` such that `T: R`, then\n             // we don't need to check for `'empty`, because `R: 'empty`.\n-            VerifyBound::AnyBound(any_bounds)\n+            VerifyBound::AnyBound(param_bounds)\n         }\n     }\n \n@@ -120,7 +135,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     pub fn projection_approx_declared_bounds_from_env(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+    ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n         self.declared_generic_bounds_from_env_for_erased_ty(erased_projection_ty)\n@@ -150,14 +165,15 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let env_bounds = self\n             .projection_approx_declared_bounds_from_env(projection_ty)\n             .into_iter()\n-            .map(|ty::OutlivesPredicate(ty, r)| {\n-                if ty == projection_ty_as_ty {\n+            .map(|binder| {\n+                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == projection_ty_as_ty {\n                     // Micro-optimize if this is an exact match (this\n                     // occurs often when there are no region variables\n                     // involved).\n                     VerifyBound::OutlivedBy(r)\n                 } else {\n-                    VerifyBound::IfEq(ty, r)\n+                    let verify_if_eq_b = binder.map_bound(|ty::OutlivesPredicate(ty, bound)| VerifyIfEq { ty, bound });\n+                    VerifyBound::IfEqBound(verify_if_eq_b)\n                 }\n             });\n \n@@ -210,7 +226,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn declared_generic_bounds_from_env(\n         &self,\n         param_ty: ty::ParamTy,\n-    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+    ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n         let generic_ty = param_ty.to_ty(self.tcx);\n         self.declared_generic_bounds_from_env_for_erased_ty(generic_ty)\n     }\n@@ -229,7 +245,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn declared_generic_bounds_from_env_for_erased_ty(\n         &self,\n         erased_ty: Ty<'tcx>,\n-    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+    ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n         let tcx = self.tcx;\n \n         // To start, collect bounds from user environment. Note that\n@@ -259,7 +275,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n             );\n             let p_ty = p.to_ty(tcx);\n             let erased_p_ty = self.tcx.erase_regions(p_ty);\n-            (erased_p_ty == erased_ty).then_some(ty::OutlivesPredicate(p.to_ty(tcx), r))\n+            (erased_p_ty == erased_ty)\n+                .then_some(ty::Binder::dummy(ty::OutlivesPredicate(p.to_ty(tcx), r)))\n         });\n \n         param_bounds\n@@ -348,11 +365,17 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         &self,\n         erased_ty: Ty<'tcx>,\n         predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-    ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n+    ) -> impl Iterator<Item = ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>>\n+    {\n         let tcx = self.tcx;\n-        predicates\n-            .filter_map(|p| p.to_opt_type_outlives())\n-            .filter_map(|p| p.no_bound_vars())\n-            .filter(move |p| tcx.erase_regions(p.0) == erased_ty)\n+        let param_env = self.param_env;\n+        predicates.filter_map(|p| p.to_opt_type_outlives()).filter(move |outlives_predicate| {\n+            super::test_type_match::can_match_erased_ty(\n+                tcx,\n+                param_env,\n+                *outlives_predicate,\n+                erased_ty,\n+            )\n+        })\n     }\n }"}, {"sha": "42100edeaa7125d40dfda579781f6b960d5a593e", "filename": "src/test/ui/borrowck/issue-71546.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.rs?ref=b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "patch": "@@ -1,20 +1,16 @@\n // Regression test for #71546.\n+//\n+// Made to pass as part of fixing #98095.\n+//\n+// check-pass\n \n pub fn serialize_as_csv<V>(value: &V) -> Result<String, &str>\n where\n     V: 'static,\n     for<'a> &'a V: IntoIterator,\n     for<'a> <&'a V as IntoIterator>::Item: ToString + 'static,\n {\n-    let csv_str: String = value\n-        //~^ ERROR higher-ranked lifetime error\n-        //~| ERROR higher-ranked lifetime error\n-        //~| ERROR higher-ranked lifetime error\n-        .into_iter()\n-        .map(|elem| elem.to_string())\n-        //~^ ERROR higher-ranked lifetime error\n-        .collect::<String>();\n-        //~^ ERROR higher-ranked lifetime error\n+    let csv_str: String = value.into_iter().map(|elem| elem.to_string()).collect::<String>();\n     Ok(csv_str)\n }\n "}, {"sha": "b8d79f0939b41c43c711ac09fb3cef89aa4c0521", "filename": "src/test/ui/borrowck/issue-71546.stderr", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/10f0f66d454c9a04e6f9703e66cbfe6ed109655a/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f0f66d454c9a04e6f9703e66cbfe6ed109655a/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-71546.stderr?ref=10f0f66d454c9a04e6f9703e66cbfe6ed109655a", "patch": "@@ -1,59 +0,0 @@\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:9:27\n-   |\n-LL |       let csv_str: String = value\n-   |  ___________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         .into_iter()\n-LL | |         .map(|elem| elem.to_string())\n-   | |_____________________________________^\n-   |\n-   = note: could not prove for<'r> [closure@$DIR/issue-71546.rs:14:14: 14:37] well-formed\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:9:27\n-   |\n-LL |       let csv_str: String = value\n-   |  ___________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         .into_iter()\n-LL | |         .map(|elem| elem.to_string())\n-   | |_____________________________________^\n-   |\n-   = note: could not prove for<'r, 's> Map<<&'r V as IntoIterator>::IntoIter, [closure@$DIR/issue-71546.rs:14:14: 14:37]> well-formed\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:9:27\n-   |\n-LL |       let csv_str: String = value\n-   |  ___________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |\n-LL | |         .collect::<String>();\n-   | |____________________________^\n-   |\n-   = note: could not prove for<'r, 's> Map<<&'r V as IntoIterator>::IntoIter, [closure@$DIR/issue-71546.rs:14:14: 14:37]> well-formed\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:14:14\n-   |\n-LL |         .map(|elem| elem.to_string())\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: could not prove for<'a> <&'a V as IntoIterator>::Item: 'static\n-\n-error: higher-ranked lifetime error\n-  --> $DIR/issue-71546.rs:16:10\n-   |\n-LL |         .collect::<String>();\n-   |          ^^^^^^^\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "07dd0bffd4685900d5db37878e472cc05fea3fb7", "filename": "src/test/ui/generic-associated-types/issue-86483.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.rs?ref=b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "patch": "@@ -1,14 +1,16 @@\n // Regression test of #86483.\n+//\n+// Made to pass as part of fixing #98095.\n+//\n+// check-pass\n \n #![feature(generic_associated_types)]\n \n-pub trait IceIce<T> //~ ERROR: the parameter type `T` may not live long enough\n+pub trait IceIce<T>\n where\n     for<'a> T: 'a,\n {\n     type Ice<'v>: IntoIterator<Item = &'v T>;\n-    //~^ ERROR: the parameter type `T` may not live long enough\n-    //~| ERROR: the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "a13dc043dc52bc57163e45ce321e5fd9d8663cf9", "filename": "src/test/ui/generic-associated-types/issue-86483.stderr", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/10f0f66d454c9a04e6f9703e66cbfe6ed109655a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f0f66d454c9a04e6f9703e66cbfe6ed109655a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86483.stderr?ref=10f0f66d454c9a04e6f9703e66cbfe6ed109655a", "patch": "@@ -1,50 +0,0 @@\n-error[E0311]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-86483.rs:5:1\n-   |\n-LL | / pub trait IceIce<T>\n-LL | | where\n-LL | |     for<'a> T: 'a,\n-LL | | {\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n-   |\n-   = note: ...so that the type `T` will meet its required lifetime bounds...\n-note: ...that is required by this bound\n-  --> $DIR/issue-86483.rs:7:16\n-   |\n-LL |     for<'a> T: 'a,\n-   |                ^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL |     for<'a> T: 'a + 'a,\n-   |                   ++++\n-\n-error[E0311]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-86483.rs:9:5\n-   |\n-LL |     type Ice<'v>: IntoIterator<Item = &'v T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n-   |\n-note: ...that is required by this bound\n-  --> $DIR/issue-86483.rs:7:16\n-   |\n-LL |     for<'a> T: 'a,\n-   |                ^^\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL |     for<'a> T: 'a + 'a,\n-   |                   ++++\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-86483.rs:9:32\n-   |\n-LL |     type Ice<'v>: IntoIterator<Item = &'v T>;\n-   |                                ^^^^^^^^^^^^ - help: consider adding a where clause: `where T: 'v`\n-   |                                |\n-   |                                ...so that the reference type `&'v T` does not outlive the data it points at\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "92b7c5deb812e2946573db4516e454d06b5f8e5d", "filename": "src/test/ui/higher-rank-trait-bounds/issue-88586-hr-self-outlives-in-trait-def.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b3d2cee0e371fdecf9726ab949a24ead3dcb97/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.rs?ref=b7b3d2cee0e371fdecf9726ab949a24ead3dcb97", "patch": "@@ -1,10 +1,12 @@\n // Regression test for #88586: a higher-ranked outlives bound on Self in a trait\n // definition caused an ICE when debug_assertions were enabled.\n //\n-// FIXME: The error output in the absence of the ICE is unhelpful; this should be improved.\n+// Made to pass as part of fixing #98095.\n+//\n+// check-pass\n \n-trait A where for<'a> Self: 'a\n-//~^ ERROR the parameter type `Self` may not live long enough\n+trait A where\n+    for<'a> Self: 'a,\n {\n }\n "}, {"sha": "18618ffcc86dc84098cab2debd2ad05d604dc2ce", "filename": "src/test/ui/higher-rank-trait-bounds/issue-88586-hr-self-outlives-in-trait-def.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/10f0f66d454c9a04e6f9703e66cbfe6ed109655a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f0f66d454c9a04e6f9703e66cbfe6ed109655a/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-88586-hr-self-outlives-in-trait-def.stderr?ref=10f0f66d454c9a04e6f9703e66cbfe6ed109655a", "patch": "@@ -1,19 +0,0 @@\n-error[E0311]: the parameter type `Self` may not live long enough\n-  --> $DIR/issue-88586-hr-self-outlives-in-trait-def.rs:6:1\n-   |\n-LL | / trait A where for<'a> Self: 'a\n-LL | |\n-LL | | {\n-LL | | }\n-   | |_^\n-   |\n-   = help: consider adding an explicit lifetime bound `Self: 'a`...\n-   = note: ...so that the type `Self` will meet its required lifetime bounds...\n-note: ...that is required by this bound\n-  --> $DIR/issue-88586-hr-self-outlives-in-trait-def.rs:6:29\n-   |\n-LL | trait A where for<'a> Self: 'a\n-   |                             ^^\n-\n-error: aborting due to previous error\n-"}]}