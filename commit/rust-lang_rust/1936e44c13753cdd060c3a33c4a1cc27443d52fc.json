{"sha": "1936e44c13753cdd060c3a33c4a1cc27443d52fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MzZlNDRjMTM3NTNjZGQwNjBjM2EzM2M0YTFjYzI3NDQzZDUyZmM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T01:56:17Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T01:57:10Z"}, "message": "Factor out repeated `self.nodes[i]` expressions.", "tree": {"sha": "02607fe7ce2814d33201b6b062d7646998c60472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02607fe7ce2814d33201b6b062d7646998c60472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1936e44c13753cdd060c3a33c4a1cc27443d52fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1936e44c13753cdd060c3a33c4a1cc27443d52fc", "html_url": "https://github.com/rust-lang/rust/commit/1936e44c13753cdd060c3a33c4a1cc27443d52fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1936e44c13753cdd060c3a33c4a1cc27443d52fc/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "html_url": "https://github.com/rust-lang/rust/commit/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3"}], "stats": {"total": 29, "additions": 14, "deletions": 15}, "files": [{"sha": "595323da02fd1e83bca5621f345c9911b8574abd", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1936e44c13753cdd060c3a33c4a1cc27443d52fc/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1936e44c13753cdd060c3a33c4a1cc27443d52fc/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=1936e44c13753cdd060c3a33c4a1cc27443d52fc", "patch": "@@ -386,7 +386,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     fn insert_into_error_cache(&mut self, node_index: usize) {\n         let node = &self.nodes[node_index];\n-\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n@@ -407,11 +406,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut stalled = true;\n \n         for i in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\", i, self.nodes[i]);\n+            let node = &mut self.nodes[i];\n+\n+            debug!(\"process_obligations: node {} == {:?}\", i, node);\n \n-            let result = match self.nodes[i] {\n-                Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n-                    processor.process_obligation(obligation),\n+            let result = match node.state.get() {\n+                NodeState::Pending => processor.process_obligation(&mut node.obligation),\n                 _ => continue\n             };\n \n@@ -424,7 +424,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    self.nodes[i].state.set(NodeState::Success);\n+                    node.state.set(NodeState::Success);\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n@@ -491,8 +491,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n-            let state = self.nodes[i].state.get();\n-            match state {\n+            match self.nodes[i].state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n                 _ => self.find_cycles_from_node(&mut stack, processor, i),\n             }\n@@ -508,8 +507,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let node = &self.nodes[i];\n-        let state = node.state.get();\n-        match state {\n+        match node.state.get() {\n             NodeState::OnDfsStack => {\n                 let i = stack.iter().rposition(|n| *n == i).unwrap();\n                 processor.process_backedge(stack[i..].iter().map(GetObligation(&self.nodes)),\n@@ -557,7 +555,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             let node = &self.nodes[i];\n             match node.state.get() {\n                 NodeState::Error => continue,\n-                _ => self.nodes[i].state.set(NodeState::Error),\n+                _ => node.state.set(NodeState::Error),\n             }\n \n             error_stack.extend(\n@@ -630,7 +628,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n         //     self.nodes[i - dead_nodes..i] are all dead\n         //     self.nodes[i..] are unchanged\n         for i in 0..self.nodes.len() {\n-            match self.nodes[i].state.get() {\n+            let node = &self.nodes[i];\n+            match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n                         self.nodes.swap(i, i - dead_nodes);\n@@ -640,11 +639,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 NodeState::Done => {\n                     // Avoid cloning the key (predicate) in case it exists in the waiting cache\n                     if let Some((predicate, _)) = self.waiting_cache\n-                        .remove_entry(self.nodes[i].obligation.as_predicate())\n+                        .remove_entry(node.obligation.as_predicate())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n-                        self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                        self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n@@ -653,7 +652,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    self.waiting_cache.remove(node.obligation.as_predicate());\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n                     self.insert_into_error_cache(i);"}]}