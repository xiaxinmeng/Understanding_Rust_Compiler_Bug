{"sha": "41942fac7d0711c6b3d0faa69748e22c0eb41388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOTQyZmFjN2QwNzExYzZiM2QwZmFhNjk3NDhlMjJjMGViNDEzODg=", "commit": {"author": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-09-26T19:28:26Z"}, "committer": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-09-26T23:42:26Z"}, "message": "SsoHashSet reimplemented as a wrapper on top of SsoHashMap\n\nSsoHashSet::replace had to be removed because\nit requires missing API from SsoHashMap.\nIt's not a widely used function, so I think it's ok\nto omit it for now.\n\nEitherIter moved into its own file.\n\nAlso sprinkled code with #[inline] attributes where appropriate.", "tree": {"sha": "0e101f5980b028cd8e6dec772427c0ed340ae1fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e101f5980b028cd8e6dec772427c0ed340ae1fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41942fac7d0711c6b3d0faa69748e22c0eb41388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41942fac7d0711c6b3d0faa69748e22c0eb41388", "html_url": "https://github.com/rust-lang/rust/commit/41942fac7d0711c6b3d0faa69748e22c0eb41388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41942fac7d0711c6b3d0faa69748e22c0eb41388/comments", "author": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "committer": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "html_url": "https://github.com/rust-lang/rust/commit/0600b178aa0e9f310067bf8ccaf736e77a03eb1d"}], "stats": {"total": 386, "additions": 158, "deletions": 228}, "files": [{"sha": "af8ffcf4c13a58ba2f9b7ff70fe69d00bec0ea61", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=41942fac7d0711c6b3d0faa69748e22c0eb41388", "patch": "@@ -0,0 +1,75 @@\n+use std::fmt;\n+use std::iter::ExactSizeIterator;\n+use std::iter::FusedIterator;\n+use std::iter::Iterator;\n+\n+/// Iterator which may contain instance of\n+/// one of two specific implementations.\n+///\n+/// Note: For most methods providing custom\n+///       implementation may margianlly\n+///       improve performance by avoiding\n+///       doing Left/Right match on every step\n+///       and doing it only once instead.\n+#[derive(Clone)]\n+pub enum EitherIter<L, R> {\n+    Left(L),\n+    Right(R),\n+}\n+\n+impl<L, R> Iterator for EitherIter<L, R>\n+where\n+    L: Iterator,\n+    R: Iterator<Item = L::Item>,\n+{\n+    type Item = L::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self {\n+            EitherIter::Left(l) => l.next(),\n+            EitherIter::Right(r) => r.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self {\n+            EitherIter::Left(l) => l.size_hint(),\n+            EitherIter::Right(r) => r.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<L, R> ExactSizeIterator for EitherIter<L, R>\n+where\n+    L: ExactSizeIterator,\n+    R: ExactSizeIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+    fn len(&self) -> usize {\n+        match self {\n+            EitherIter::Left(l) => l.len(),\n+            EitherIter::Right(r) => r.len(),\n+        }\n+    }\n+}\n+\n+impl<L, R> FusedIterator for EitherIter<L, R>\n+where\n+    L: FusedIterator,\n+    R: FusedIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+}\n+\n+impl<L, R> fmt::Debug for EitherIter<L, R>\n+where\n+    L: fmt::Debug,\n+    R: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            EitherIter::Left(l) => l.fmt(f),\n+            EitherIter::Right(r) => r.fmt(f),\n+        }\n+    }\n+}"}, {"sha": "3089f88784581e30f4a6f58b5639df302e529461", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=41942fac7d0711c6b3d0faa69748e22c0eb41388", "patch": "@@ -1,4 +1,4 @@\n-use super::EitherIter;\n+use super::either_iter::EitherIter;\n use crate::fx::FxHashMap;\n use arrayvec::ArrayVec;\n use std::borrow::Borrow;\n@@ -32,6 +32,7 @@ pub enum SsoHashMap<K, V> {\n \n impl<K, V> SsoHashMap<K, V> {\n     /// Creates an empty `SsoHashMap`.\n+    #[inline]\n     pub fn new() -> Self {\n         SsoHashMap::Array(ArrayVec::new())\n     }\n@@ -81,13 +82,15 @@ impl<K, V> SsoHashMap<K, V> {\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// The iterator element type is `(&'a K, &'a V)`.\n-    pub fn iter(&self) -> impl Iterator<Item = (&'_ K, &'_ V)> {\n+    #[inline]\n+    pub fn iter(&self) -> <&Self as IntoIterator>::IntoIter {\n         self.into_iter()\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// The iterator element type is `(&'a K, &'a mut V)`.\n+    #[inline]\n     pub fn iter_mut(&mut self) -> impl Iterator<Item = (&'_ K, &'_ mut V)> {\n         self.into_iter()\n     }\n@@ -319,12 +322,14 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    #[inline]\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         Entry { ssomap: self, key }\n     }\n }\n \n impl<K, V> Default for SsoHashMap<K, V> {\n+    #[inline]\n     fn default() -> Self {\n         Self::new()\n     }\n@@ -348,6 +353,7 @@ impl<K: Eq + Hash, V> Extend<(K, V)> for SsoHashMap<K, V> {\n         }\n     }\n \n+    #[inline]\n     fn extend_one(&mut self, (k, v): (K, V)) {\n         self.insert(k, v);\n     }\n@@ -375,10 +381,12 @@ where\n         self.extend(iter.into_iter().map(|(k, v)| (k.clone(), v.clone())))\n     }\n \n+    #[inline]\n     fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n         self.insert(k, v);\n     }\n \n+    #[inline]\n     fn extend_reserve(&mut self, additional: usize) {\n         Extend::<(K, V)>::extend_reserve(self, additional)\n     }\n@@ -400,12 +408,14 @@ impl<K, V> IntoIterator for SsoHashMap<K, V> {\n }\n \n /// adapts Item of array reference iterator to Item of hashmap reference iterator.\n+#[inline(always)]\n fn adapt_array_ref_it<K, V>(pair: &'a (K, V)) -> (&'a K, &'a V) {\n     let (a, b) = pair;\n     (a, b)\n }\n \n /// adapts Item of array mut reference iterator to Item of hashmap mut reference iterator.\n+#[inline(always)]\n fn adapt_array_mut_it<K, V>(pair: &'a mut (K, V)) -> (&'a K, &'a mut V) {\n     let (a, b) = pair;\n     (a, b)\n@@ -464,6 +474,7 @@ where\n {\n     type Output = V;\n \n+    #[inline]\n     fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }\n@@ -490,6 +501,7 @@ impl<'a, K: Eq + Hash, V> Entry<'a, K, V> {\n \n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    #[inline]\n     pub fn or_insert(self, value: V) -> &'a mut V {\n         self.or_insert_with(|| value)\n     }\n@@ -515,6 +527,7 @@ impl<'a, K: Eq + Hash, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    #[inline]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n@@ -523,6 +536,7 @@ impl<'a, K: Eq + Hash, V> Entry<'a, K, V> {\n impl<'a, K: Eq + Hash, V: Default> Entry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default value if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    #[inline]\n     pub fn or_default(self) -> &'a mut V {\n         self.or_insert_with(Default::default)\n     }"}, {"sha": "dd21bc8e6963680253ac03c0e59bdd5ce59ce2a7", "filename": "compiler/rustc_data_structures/src/sso/mod.rs", "status": "modified", "additions": 1, "deletions": 72, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs?ref=41942fac7d0711c6b3d0faa69748e22c0eb41388", "patch": "@@ -1,75 +1,4 @@\n-use std::fmt;\n-use std::iter::ExactSizeIterator;\n-use std::iter::FusedIterator;\n-use std::iter::Iterator;\n-\n-/// Iterator which may contain instance of\n-/// one of two specific implementations.\n-///\n-/// Used by both SsoHashMap and SsoHashSet.\n-#[derive(Clone)]\n-pub enum EitherIter<L, R> {\n-    Left(L),\n-    Right(R),\n-}\n-\n-impl<L, R> Iterator for EitherIter<L, R>\n-where\n-    L: Iterator,\n-    R: Iterator<Item = L::Item>,\n-{\n-    type Item = L::Item;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self {\n-            EitherIter::Left(l) => l.next(),\n-            EitherIter::Right(r) => r.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self {\n-            EitherIter::Left(l) => l.size_hint(),\n-            EitherIter::Right(r) => r.size_hint(),\n-        }\n-    }\n-}\n-\n-impl<L, R> ExactSizeIterator for EitherIter<L, R>\n-where\n-    L: ExactSizeIterator,\n-    R: ExactSizeIterator,\n-    EitherIter<L, R>: Iterator,\n-{\n-    fn len(&self) -> usize {\n-        match self {\n-            EitherIter::Left(l) => l.len(),\n-            EitherIter::Right(r) => r.len(),\n-        }\n-    }\n-}\n-\n-impl<L, R> FusedIterator for EitherIter<L, R>\n-where\n-    L: FusedIterator,\n-    R: FusedIterator,\n-    EitherIter<L, R>: Iterator,\n-{\n-}\n-\n-impl<L, R> fmt::Debug for EitherIter<L, R>\n-where\n-    L: fmt::Debug,\n-    R: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            EitherIter::Left(l) => l.fmt(f),\n-            EitherIter::Right(r) => r.fmt(f),\n-        }\n-    }\n-}\n-\n+mod either_iter;\n mod map;\n mod set;\n "}, {"sha": "353529b0598925e99738696a2891440aea39e90d", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "modified", "additions": 66, "deletions": 154, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41942fac7d0711c6b3d0faa69748e22c0eb41388/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=41942fac7d0711c6b3d0faa69748e22c0eb41388", "patch": "@@ -1,11 +1,10 @@\n-use super::EitherIter;\n-use crate::fx::FxHashSet;\n-use arrayvec::ArrayVec;\n use std::borrow::Borrow;\n use std::fmt;\n use std::hash::Hash;\n use std::iter::FromIterator;\n \n+use super::map::SsoHashMap;\n+\n /// Small-storage-optimized implementation of a set.\n ///\n /// Stores elements in a small array up to a certain length\n@@ -18,234 +17,151 @@ use std::iter::FromIterator;\n ///   try_reserve (unstable)\n ///   shrink_to (unstable)\n ///   drain_filter (unstable)\n+///   replace\n ///   get_or_insert/get_or_insert_owned/get_or_insert_with (unstable)\n ///   difference/symmetric_difference/intersection/union\n ///   is_disjoint/is_subset/is_superset\n-///   PartialEq/Eq (requires sorting the array)\n+///   PartialEq/Eq (requires SsoHashMap implementation)\n ///   BitOr/BitAnd/BitXor/Sub\n #[derive(Clone)]\n-pub enum SsoHashSet<T> {\n-    Array(ArrayVec<[T; 8]>),\n-    Set(FxHashSet<T>),\n+pub struct SsoHashSet<T> {\n+    map: SsoHashMap<T, ()>,\n+}\n+\n+/// Adapter function used ot return\n+/// result if SsoHashMap functions into\n+/// result SsoHashSet should return.\n+#[inline(always)]\n+fn entry_to_key<K, V>((k, _v): (K, V)) -> K {\n+    k\n }\n \n impl<T> SsoHashSet<T> {\n     /// Creates an empty `SsoHashSet`.\n+    #[inline]\n     pub fn new() -> Self {\n-        SsoHashSet::Array(ArrayVec::new())\n+        Self { map: SsoHashMap::new() }\n     }\n \n     /// Creates an empty `SsoHashSet` with the specified capacity.\n+    #[inline]\n     pub fn with_capacity(cap: usize) -> Self {\n-        let array = ArrayVec::new();\n-        if array.capacity() >= cap {\n-            SsoHashSet::Array(array)\n-        } else {\n-            SsoHashSet::Set(FxHashSet::with_capacity_and_hasher(cap, Default::default()))\n-        }\n+        Self { map: SsoHashMap::with_capacity(cap) }\n     }\n \n     /// Clears the set, removing all values.\n+    #[inline]\n     pub fn clear(&mut self) {\n-        match self {\n-            SsoHashSet::Array(array) => array.clear(),\n-            SsoHashSet::Set(set) => set.clear(),\n-        }\n+        self.map.clear()\n     }\n \n     /// Returns the number of elements the set can hold without reallocating.\n+    #[inline]\n     pub fn capacity(&self) -> usize {\n-        match self {\n-            SsoHashSet::Array(array) => array.capacity(),\n-            SsoHashSet::Set(set) => set.capacity(),\n-        }\n+        self.map.capacity()\n     }\n \n     /// Returns the number of elements in the set.\n+    #[inline]\n     pub fn len(&self) -> usize {\n-        match self {\n-            SsoHashSet::Array(array) => array.len(),\n-            SsoHashSet::Set(set) => set.len(),\n-        }\n+        self.map.len()\n     }\n \n     /// Returns `true` if the set contains no elements.\n+    #[inline]\n     pub fn is_empty(&self) -> bool {\n-        match self {\n-            SsoHashSet::Array(array) => array.is_empty(),\n-            SsoHashSet::Set(set) => set.is_empty(),\n-        }\n+        self.map.is_empty()\n     }\n \n     /// An iterator visiting all elements in arbitrary order.\n     /// The iterator element type is `&'a T`.\n+    #[inline]\n     pub fn iter(&'a self) -> impl Iterator<Item = &'a T> {\n         self.into_iter()\n     }\n \n     /// Clears the set, returning all elements in an iterator.\n+    #[inline]\n     pub fn drain(&mut self) -> impl Iterator<Item = T> + '_ {\n-        match self {\n-            SsoHashSet::Array(array) => EitherIter::Left(array.drain(..)),\n-            SsoHashSet::Set(set) => EitherIter::Right(set.drain()),\n-        }\n+        self.map.drain().map(entry_to_key)\n     }\n }\n \n impl<T: Eq + Hash> SsoHashSet<T> {\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `SsoHashSet`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n+    #[inline]\n     pub fn reserve(&mut self, additional: usize) {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if array.capacity() < (array.len() + additional) {\n-                    let mut set: FxHashSet<T> = array.drain(..).collect();\n-                    set.reserve(additional);\n-                    *self = SsoHashSet::Set(set);\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.reserve(additional),\n-        }\n+        self.map.reserve(additional)\n     }\n \n     /// Shrinks the capacity of the set as much as possible. It will drop\n     /// down as much as possible while maintaining the internal rules\n     /// and possibly leaving some space in accordance with the resize policy.\n+    #[inline]\n     pub fn shrink_to_fit(&mut self) {\n-        if let SsoHashSet::Set(set) = self {\n-            let mut array = ArrayVec::new();\n-            if set.len() <= array.capacity() {\n-                array.extend(set.drain());\n-                *self = SsoHashSet::Array(array);\n-            } else {\n-                set.shrink_to_fit();\n-            }\n-        }\n+        self.map.shrink_to_fit()\n     }\n \n     /// Retains only the elements specified by the predicate.\n+    #[inline]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        match self {\n-            SsoHashSet::Array(array) => array.retain(|v| f(v)),\n-            SsoHashSet::Set(set) => set.retain(f),\n-        }\n+        self.map.retain(|k, _v| f(k))\n     }\n \n     /// Removes and returns the value in the set, if any, that is equal to the given one.\n+    #[inline]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n     where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if let Some(index) = array.iter().position(|val| val.borrow() == value) {\n-                    Some(array.swap_remove(index))\n-                } else {\n-                    None\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.take(value),\n-        }\n-    }\n-\n-    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n-    /// one. Returns the replaced value.\n-    pub fn replace(&mut self, value: T) -> Option<T> {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if let Some(index) = array.iter().position(|val| *val == value) {\n-                    let old_value = std::mem::replace(&mut array[index], value);\n-                    Some(old_value)\n-                } else {\n-                    None\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.replace(value),\n-        }\n+        self.map.remove_entry(value).map(entry_to_key)\n     }\n \n     /// Returns a reference to the value in the set, if any, that is equal to the given value.\n+    #[inline]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n     where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if let Some(index) = array.iter().position(|val| val.borrow() == value) {\n-                    Some(&array[index])\n-                } else {\n-                    None\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.get(value),\n-        }\n+        self.map.get_key_value(value).map(entry_to_key)\n     }\n \n     /// Adds a value to the set.\n     ///\n     /// If the set did not have this value present, `true` is returned.\n     ///\n     /// If the set did have this value present, `false` is returned.\n+    #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if array.iter().any(|e| *e == elem) {\n-                    false\n-                } else {\n-                    if let Err(error) = array.try_push(elem) {\n-                        let mut set: FxHashSet<T> = array.drain(..).collect();\n-                        set.insert(error.element());\n-                        *self = SsoHashSet::Set(set);\n-                    }\n-                    true\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.insert(elem),\n-        }\n+        self.map.insert(elem, ()).is_none()\n     }\n \n     /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n+    #[inline]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n     where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if let Some(index) = array.iter().position(|val| val.borrow() == value) {\n-                    array.swap_remove(index);\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.remove(value),\n-        }\n+        self.map.remove(value).is_some()\n     }\n \n     /// Returns `true` if the set contains a value.\n+    #[inline]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n     where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        match self {\n-            SsoHashSet::Array(array) => array.iter().any(|v| v.borrow() == value),\n-            SsoHashSet::Set(set) => set.contains(value),\n-        }\n-    }\n-}\n-\n-impl<T> Default for SsoHashSet<T> {\n-    fn default() -> Self {\n-        Self::new()\n+        self.map.contains_key(value)\n     }\n }\n \n@@ -257,6 +173,13 @@ impl<T: Eq + Hash> FromIterator<T> for SsoHashSet<T> {\n     }\n }\n \n+impl<T> Default for SsoHashSet<T> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n impl<T: Eq + Hash> Extend<T> for SsoHashSet<T> {\n     fn extend<I>(&mut self, iter: I)\n     where\n@@ -267,68 +190,57 @@ impl<T: Eq + Hash> Extend<T> for SsoHashSet<T> {\n         }\n     }\n \n+    #[inline]\n     fn extend_one(&mut self, item: T) {\n         self.insert(item);\n     }\n \n+    #[inline]\n     fn extend_reserve(&mut self, additional: usize) {\n-        match self {\n-            SsoHashSet::Array(array) => {\n-                if array.capacity() < (array.len() + additional) {\n-                    let mut set: FxHashSet<T> = array.drain(..).collect();\n-                    set.extend_reserve(additional);\n-                    *self = SsoHashSet::Set(set);\n-                }\n-            }\n-            SsoHashSet::Set(set) => set.extend_reserve(additional),\n-        }\n+        self.map.extend_reserve(additional)\n     }\n }\n \n impl<'a, T> Extend<&'a T> for SsoHashSet<T>\n where\n     T: 'a + Eq + Hash + Copy,\n {\n+    #[inline]\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n \n+    #[inline]\n     fn extend_one(&mut self, &item: &'a T) {\n         self.insert(item);\n     }\n \n+    #[inline]\n     fn extend_reserve(&mut self, additional: usize) {\n         Extend::<T>::extend_reserve(self, additional)\n     }\n }\n \n impl<T> IntoIterator for SsoHashSet<T> {\n-    type IntoIter = EitherIter<\n-        <ArrayVec<[T; 8]> as IntoIterator>::IntoIter,\n-        <FxHashSet<T> as IntoIterator>::IntoIter,\n-    >;\n+    type IntoIter = std::iter::Map<<SsoHashMap<T, ()> as IntoIterator>::IntoIter, fn((T, ())) -> T>;\n     type Item = <Self::IntoIter as Iterator>::Item;\n \n+    #[inline]\n     fn into_iter(self) -> Self::IntoIter {\n-        match self {\n-            SsoHashSet::Array(array) => EitherIter::Left(array.into_iter()),\n-            SsoHashSet::Set(set) => EitherIter::Right(set.into_iter()),\n-        }\n+        self.map.into_iter().map(entry_to_key)\n     }\n }\n \n impl<'a, T> IntoIterator for &'a SsoHashSet<T> {\n-    type IntoIter = EitherIter<\n-        <&'a ArrayVec<[T; 8]> as IntoIterator>::IntoIter,\n-        <&'a FxHashSet<T> as IntoIterator>::IntoIter,\n+    type IntoIter = std::iter::Map<\n+        <&'a SsoHashMap<T, ()> as IntoIterator>::IntoIter,\n+        fn((&'a T, &'a ())) -> &'a T,\n     >;\n     type Item = <Self::IntoIter as Iterator>::Item;\n \n+    #[inline]\n     fn into_iter(self) -> Self::IntoIter {\n-        match self {\n-            SsoHashSet::Array(array) => EitherIter::Left(array.into_iter()),\n-            SsoHashSet::Set(set) => EitherIter::Right(set.into_iter()),\n-        }\n+        self.map.iter().map(entry_to_key)\n     }\n }\n "}]}