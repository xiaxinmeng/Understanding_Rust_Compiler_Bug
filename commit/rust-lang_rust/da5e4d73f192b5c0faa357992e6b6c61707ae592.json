{"sha": "da5e4d73f192b5c0faa357992e6b6c61707ae592", "node_id": "C_kwDOAAsO6NoAKGRhNWU0ZDczZjE5MmI1YzBmYWEzNTc5OTJlNmI2YzYxNzA3YWU1OTI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T15:36:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T20:57:31Z"}, "message": "add a Vtable kind of symbolic allocations", "tree": {"sha": "4f1672a1f13dc7ef0bd814b7b5d393d40ec32350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f1672a1f13dc7ef0bd814b7b5d393d40ec32350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da5e4d73f192b5c0faa357992e6b6c61707ae592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da5e4d73f192b5c0faa357992e6b6c61707ae592", "html_url": "https://github.com/rust-lang/rust/commit/da5e4d73f192b5c0faa357992e6b6c61707ae592", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da5e4d73f192b5c0faa357992e6b6c61707ae592/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7468c60f8dbf5feb23ad840b174d7e57113a846", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7468c60f8dbf5feb23ad840b174d7e57113a846", "html_url": "https://github.com/rust-lang/rust/commit/a7468c60f8dbf5feb23ad840b174d7e57113a846"}], "stats": {"total": 121, "additions": 106, "deletions": 15}, "files": [{"sha": "389ff7231b0af69343bd7e3d0fbf3ea8670cc9bc", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -195,9 +195,13 @@ pub(crate) fn codegen_const_value<'tcx>(\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts(); // we know the `offset` is relative\n-                let alloc_kind = fx.tcx.get_global_alloc(alloc_id);\n-                let base_addr = match alloc_kind {\n-                    Some(GlobalAlloc::Memory(alloc)) => {\n+                // For vtables, get the underlying data allocation.\n+                let alloc_id = match fx.tcx.global_alloc(alloc_id) {\n+                    GlobalAlloc::Vtable(ty, trait_ref) => fx.tcx.vtable_allocation((ty, trait_ref)),\n+                    _ => alloc_id,\n+                };\n+                let base_addr = match fx.tcx.global_alloc(alloc_id) {\n+                    GlobalAlloc::Memory(alloc) => {\n                         let data_id = data_id_for_alloc_id(\n                             &mut fx.constants_cx,\n                             fx.module,\n@@ -211,13 +215,14 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n-                    Some(GlobalAlloc::Function(instance)) => {\n+                    GlobalAlloc::Function(instance) => {\n                         let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n                         let local_func_id =\n                             fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                         fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                     }\n-                    Some(GlobalAlloc::Static(def_id)) => {\n+                    GlobalAlloc::Vtable(..) => bug!(\"vtables are already handled\"),\n+                    GlobalAlloc::Static(def_id) => {\n                         assert!(fx.tcx.is_static(def_id));\n                         let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n                         let local_data_id =\n@@ -227,7 +232,6 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n-                    None => bug!(\"missing allocation {:?}\", alloc_id),\n                 };\n                 let val = if offset.bytes() != 0 {\n                     fx.bcx.ins().iadd_imm(base_addr, i64::try_from(offset.bytes()).unwrap())\n@@ -360,7 +364,9 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 //println!(\"alloc_id {}\", alloc_id);\n                 let alloc = match tcx.get_global_alloc(alloc_id).unwrap() {\n                     GlobalAlloc::Memory(alloc) => alloc,\n-                    GlobalAlloc::Function(_) | GlobalAlloc::Static(_) => unreachable!(),\n+                    GlobalAlloc::Function(_) | GlobalAlloc::Static(_) | GlobalAlloc::Vtable(..) => {\n+                        unreachable!()\n+                    }\n                 };\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n                     module\n@@ -424,7 +430,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 read_target_uint(endianness, bytes).unwrap()\n             };\n \n-            let reloc_target_alloc = tcx.get_global_alloc(alloc_id).unwrap();\n+            let reloc_target_alloc = tcx.global_alloc(alloc_id);\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n@@ -436,6 +442,10 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 GlobalAlloc::Memory(target_alloc) => {\n                     data_id_for_alloc_id(cx, module, alloc_id, target_alloc.inner().mutability)\n                 }\n+                GlobalAlloc::Vtable(ty, trait_ref) => {\n+                    let alloc_id = tcx.vtable_allocation((ty, trait_ref));\n+                    data_id_for_alloc_id(cx, module, alloc_id, Mutability::Not)\n+                }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {"}, {"sha": "3868f2f7a49510150c644b8e4d42f1f6960d7e8b", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -183,6 +183,13 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n+                // For vtables, get the underlying data allocation.\n+                let alloc_id = match self.tcx.global_alloc(alloc_id) {\n+                    GlobalAlloc::Vtable(ty, trait_ref) => {\n+                        self.tcx.vtable_allocation((ty, trait_ref))\n+                    }\n+                    _ => alloc_id,\n+                };\n                 let base_addr =\n                     match self.tcx.global_alloc(alloc_id) {\n                         GlobalAlloc::Memory(alloc) => {\n@@ -201,6 +208,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         GlobalAlloc::Function(fn_instance) => {\n                             self.get_fn_addr(fn_instance)\n                         },\n+                        GlobalAlloc::Vtable(..) => panic!(\"vtables are already handled\"),\n                         GlobalAlloc::Static(def_id) => {\n                             assert!(self.tcx.is_static(def_id));\n                             self.get_static(def_id).get_address(None)"}, {"sha": "b465f65fcab30dbc41c3b554a92a115bbf027bec", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -240,6 +240,13 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n+                // For vtables, get the underlying data allocation.\n+                let alloc_id = match self.tcx.global_alloc(alloc_id) {\n+                    GlobalAlloc::Vtable(ty, trait_ref) => {\n+                        self.tcx.vtable_allocation((ty, trait_ref))\n+                    }\n+                    _ => alloc_id,\n+                };\n                 let (base_addr, base_addr_space) = match self.tcx.global_alloc(alloc_id) {\n                     GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n@@ -257,6 +264,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         self.get_fn_addr(fn_instance.polymorphize(self.tcx)),\n                         self.data_layout().instruction_address_space,\n                     ),\n+                    GlobalAlloc::Vtable(..) => bug!(\"vtables are already handled\"),\n                     GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n                         assert!(!self.tcx.is_thread_local_static(def_id));"}, {"sha": "1fef22796ddad7d09994bddf04e43fa000735279", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -101,7 +101,9 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n \n         let address_space = match cx.tcx.global_alloc(alloc_id) {\n             GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n-            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) => AddressSpace::DATA,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::Vtable(..) => {\n+                AddressSpace::DATA\n+            }\n         };\n \n         llvals.push(cx.scalar_to_backend("}, {"sha": "5d6620d8782d40348354751cfa1978ec01913c0d", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -62,6 +62,8 @@ pub enum AllocKind {\n     LiveData,\n     /// A function allocation (that fn ptrs point to).\n     Function,\n+    /// A (symbolic) vtable allocation.\n+    Vtable,\n     /// A dead allocation.\n     Dead,\n }\n@@ -291,6 +293,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Some(GlobalAlloc::Function(..)) => {\n                     err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n                 }\n+                Some(GlobalAlloc::Vtable(..)) => {\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is a vtable\")\n+                }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n                     err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n                 }\n@@ -479,6 +484,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 (mem, None)\n             }\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n+            Some(GlobalAlloc::Vtable(..)) => throw_ub!(DerefVtablePointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 assert!(self.tcx.is_static(def_id));\n@@ -678,6 +684,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 (alloc.size(), alloc.align, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),\n+            Some(GlobalAlloc::Vtable(..)) => {\n+                // No data to be accessed here.\n+                return (Size::ZERO, Align::ONE, AllocKind::Vtable);\n+            }\n             // The rest must be dead.\n             None => {\n                 // Deallocated pointers are allowed, we should be able to find\n@@ -840,7 +850,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                             )?;\n                         }\n                         Some(GlobalAlloc::Function(func)) => {\n-                            write!(fmt, \" (fn: {})\", func)?;\n+                            write!(fmt, \" (fn: {func})\")?;\n+                        }\n+                        Some(GlobalAlloc::Vtable(ty, Some(trait_ref))) => {\n+                            write!(fmt, \" (vtable: impl {trait_ref} for {ty})\")?;\n+                        }\n+                        Some(GlobalAlloc::Vtable(ty, None)) => {\n+                            write!(fmt, \" (vtable: impl ? for {ty})\")?;\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n                             write!(fmt, \" (static: {})\", self.ecx.tcx.def_path_str(did))?;"}, {"sha": "68559ae2249fb2c2e36713ff5ec5c7171e66a171", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -271,6 +271,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     WriteToReadOnly(AllocId),\n     // Trying to access the data behind a function pointer.\n     DerefFunctionPointer(AllocId),\n+    // Trying to access the data behind a vtable pointer.\n+    DerefVtablePointer(AllocId),\n     /// The value validity check found a problem.\n     /// Should only be thrown by `validity.rs` and always point out which part of the value\n     /// is the problem.\n@@ -359,6 +361,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             ),\n             WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n             DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n+            DerefVtablePointer(a) => write!(f, \"accessing {a:?} which contains a vtable\"),\n             ValidationFailure { path: None, msg } => {\n                 write!(f, \"constructing invalid value: {msg}\")\n             }"}, {"sha": "d1039ed30b08b74d8e886df147f32bf4317dd82c", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -196,6 +196,7 @@ impl fmt::Debug for AllocId {\n enum AllocDiscriminant {\n     Alloc,\n     Fn,\n+    Vtable,\n     Static,\n }\n \n@@ -215,6 +216,12 @@ pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>>(\n             AllocDiscriminant::Fn.encode(encoder);\n             fn_instance.encode(encoder);\n         }\n+        GlobalAlloc::Vtable(ty, poly_trait_ref) => {\n+            trace!(\"encoding {:?} with {ty:#?}, {poly_trait_ref:#?}\", alloc_id);\n+            AllocDiscriminant::Vtable.encode(encoder);\n+            ty.encode(encoder);\n+            poly_trait_ref.encode(encoder);\n+        }\n         GlobalAlloc::Static(did) => {\n             assert!(!tcx.is_thread_local_static(did));\n             // References to statics doesn't need to know about their allocations,\n@@ -305,7 +312,7 @@ impl<'s> AllocDecodingSession<'s> {\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n                         }\n-                        AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n+                        AllocDiscriminant::Fn | AllocDiscriminant::Static | AllocDiscriminant::Vtable => {\n                             // Fns and statics cannot be cyclic, and their `AllocId`\n                             // is determined later by interning.\n                             *entry =\n@@ -355,6 +362,15 @@ impl<'s> AllocDecodingSession<'s> {\n                     let alloc_id = decoder.interner().create_fn_alloc(instance);\n                     alloc_id\n                 }\n+                AllocDiscriminant::Vtable => {\n+                    assert!(alloc_id.is_none());\n+                    trace!(\"creating static alloc ID\");\n+                    let ty = <Ty<'_> as Decodable<D>>::decode(decoder);\n+                    let poly_trait_ref = <Option<ty::PolyExistentialTraitRef<'_>> as Decodable<D>>::decode(decoder);\n+                    trace!(\"decoded vtable alloc instance: {ty:?}, {poly_trait_ref:?}\");\n+                    let alloc_id = decoder.interner().create_vtable_alloc(ty, poly_trait_ref);\n+                    alloc_id\n+                }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n@@ -380,6 +396,8 @@ impl<'s> AllocDecodingSession<'s> {\n pub enum GlobalAlloc<'tcx> {\n     /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),\n+    /// This alloc ID points to a symbolic (not-reified) vtable.\n+    Vtable(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n     /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n@@ -407,6 +425,16 @@ impl<'tcx> GlobalAlloc<'tcx> {\n             _ => bug!(\"expected function, got {:?}\", self),\n         }\n     }\n+\n+    /// Panics if the `GlobalAlloc` is not `GlobalAlloc::Vtable`\n+    #[track_caller]\n+    #[inline]\n+    pub fn unwrap_vtable(&self) -> (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n+        match *self {\n+            GlobalAlloc::Vtable(ty, poly_trait_ref) => (ty, poly_trait_ref),\n+            _ => bug!(\"expected vtable, got {:?}\", self),\n+        }\n+    }\n }\n \n pub(crate) struct AllocMap<'tcx> {\n@@ -454,12 +482,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n-    /// Should only be used for function pointers and statics, we don't want\n-    /// to dedup IDs for \"real\" memory!\n+    /// Should only be used for \"symbolic\" allocations (function pointers, vtables, statics), we\n+    /// don't want to dedup IDs for \"real\" memory!\n     fn reserve_and_set_dedup(self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n         let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n-            GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n+            GlobalAlloc::Function(..) | GlobalAlloc::Static(..) | GlobalAlloc::Vtable(..) => {}\n             GlobalAlloc::Memory(..) => bug!(\"Trying to dedup-reserve memory with real data!\"),\n         }\n         if let Some(&alloc_id) = alloc_map.dedup.get(&alloc) {\n@@ -504,6 +532,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Generates an `AllocId` for a (symbolic, not-reified) vtable.  Will get deduplicated.\n+    pub fn create_vtable_alloc(self, ty: Ty<'tcx>, poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>) -> AllocId {\n+        self.reserve_and_set_dedup(GlobalAlloc::Vtable(ty, poly_trait_ref))\n+    }\n+\n     /// Interns the `Allocation` and return a new `AllocId`, even if there's already an identical\n     /// `Allocation` with a different `AllocId`.\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,"}, {"sha": "120dfb5a36116c153ad3de8d8eada659f3f57146", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -725,6 +725,8 @@ pub fn write_allocations<'tcx>(\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,\n             Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {inst})\")?,\n+            Some(GlobalAlloc::Vtable(ty, Some(trait_ref))) => write!(w, \" (vtable: impl {trait_ref} for {ty})\")?,\n+            Some(GlobalAlloc::Vtable(ty, None)) => write!(w, \" (vtable: impl ? for {ty})\")?,\n             Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n                 match tcx.eval_static_initializer(did) {\n                     Ok(alloc) => {"}, {"sha": "51137c52659db493ec2979c0d81728765d4796a3", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -523,4 +523,5 @@ impl_binder_encode_decode! {\n     ty::ExistentialPredicate<'tcx>,\n     ty::TraitRef<'tcx>,\n     Vec<ty::GeneratorInteriorTypeCause<'tcx>>,\n+    ty::ExistentialTraitRef<'tcx>,\n }"}, {"sha": "d46e9ae949d72e56523cfc608262a18d497900cc", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -1282,11 +1282,12 @@ pub trait PrettyPrinter<'tcx>:\n                                         p!(\"<too short allocation>\")\n                                     }\n                                 }\n-                                // FIXME: for statics and functions, we could in principle print more detail.\n+                                // FIXME: for statics, vtables, and functions, we could in principle print more detail.\n                                 Some(GlobalAlloc::Static(def_id)) => {\n                                     p!(write(\"<static({:?})>\", def_id))\n                                 }\n                                 Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n+                                Some(GlobalAlloc::Vtable(..)) => p!(\"<vtable>\"),\n                                 None => p!(\"<dangling pointer>\"),\n                             }\n                             return Ok(self);"}, {"sha": "3cee9a460c1263aabadd8067860dc86ae4ea0eae", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5e4d73f192b5c0faa357992e6b6c61707ae592/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=da5e4d73f192b5c0faa357992e6b6c61707ae592", "patch": "@@ -1427,6 +1427,13 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n                 output.push(create_fn_mono_item(tcx, fn_instance, DUMMY_SP));\n             }\n         }\n+        GlobalAlloc::Vtable(ty, trait_ref) => {\n+            // FIXME(RJ) no ideas if this is correct. There is this nice\n+            // `create_mono_items_for_vtable_methods` method but I wouldn't know how to call it from\n+            // here. So instead we just generate the actual vtable and recurse.\n+            let alloc_id = tcx.vtable_allocation((ty, trait_ref));\n+            collect_miri(tcx, alloc_id, output)\n+        }\n     }\n }\n "}]}