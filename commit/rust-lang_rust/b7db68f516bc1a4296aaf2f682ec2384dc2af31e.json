{"sha": "b7db68f516bc1a4296aaf2f682ec2384dc2af31e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZGI2OGY1MTZiYzFhNDI5NmFhZjJmNjgyZWMyMzg0ZGMyYWYzMWU=", "commit": {"author": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2018-05-18T12:20:48Z"}, "committer": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2018-05-18T12:32:05Z"}, "message": "Find the largest niche when computing layouts\n\nOtherwise we end up with `Option<Option<(&(), bool)>>` unnecessarily large.", "tree": {"sha": "545bc872d51080de9b75bb5d00961c67f1384fe0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/545bc872d51080de9b75bb5d00961c67f1384fe0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7db68f516bc1a4296aaf2f682ec2384dc2af31e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7db68f516bc1a4296aaf2f682ec2384dc2af31e", "html_url": "https://github.com/rust-lang/rust/commit/b7db68f516bc1a4296aaf2f682ec2384dc2af31e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7db68f516bc1a4296aaf2f682ec2384dc2af31e/comments", "author": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc", "html_url": "https://github.com/rust-lang/rust/commit/dfc07a48f6797a20b3ee04fcff6f6c64bf0443bc"}], "stats": {"total": 114, "additions": 77, "deletions": 37}, "files": [{"sha": "235a541f07bf67665e2b2b24bb2da5d0fd8a209b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 74, "deletions": 37, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b7db68f516bc1a4296aaf2f682ec2384dc2af31e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db68f516bc1a4296aaf2f682ec2384dc2af31e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b7db68f516bc1a4296aaf2f682ec2384dc2af31e", "patch": "@@ -18,6 +18,7 @@ use syntax_pos::DUMMY_SP;\n use std::cmp;\n use std::fmt;\n use std::i128;\n+use std::iter;\n use std::mem;\n \n use ich::StableHashingContext;\n@@ -813,11 +814,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     if let Some(i) = dataful_variant {\n                         let count = (niche_variants.end() - niche_variants.start() + 1) as u128;\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n-                            let (offset, niche, niche_start) =\n-                                match self.find_niche(field, count)? {\n-                                    Some(niche) => niche,\n-                                    None => continue\n-                                };\n+                            let niche = match self.find_niche(field)? {\n+                                Some(niche) => niche,\n+                                _ => continue,\n+                            };\n+                            let (niche_start, niche_scalar) = match niche.reserve(self, count) {\n+                                Some(pair) => pair,\n+                                None => continue,\n+                            };\n+\n                             let mut align = dl.aggregate_align;\n                             let st = variants.iter().enumerate().map(|(j, v)| {\n                                 let mut st = univariant_uninterned(v,\n@@ -829,21 +834,27 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 Ok(st)\n                             }).collect::<Result<Vec<_>, _>>()?;\n \n-                            let offset = st[i].fields.offset(field_index) + offset;\n+                            let offset = st[i].fields.offset(field_index) + niche.offset;\n                             let size = st[i].size;\n \n                             let mut abi = match st[i].abi {\n-                                Abi::Scalar(_) => Abi::Scalar(niche.clone()),\n+                                Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n                                 Abi::ScalarPair(ref first, ref second) => {\n                                     // We need to use scalar_unit to reset the\n                                     // valid range to the maximal one for that\n                                     // primitive, because only the niche is\n                                     // guaranteed to be initialised, not the\n                                     // other primitive.\n                                     if offset.bytes() == 0 {\n-                                        Abi::ScalarPair(niche.clone(), scalar_unit(second.value))\n+                                        Abi::ScalarPair(\n+                                            niche_scalar.clone(),\n+                                            scalar_unit(second.value),\n+                                        )\n                                     } else {\n-                                        Abi::ScalarPair(scalar_unit(first.value), niche.clone())\n+                                        Abi::ScalarPair(\n+                                            scalar_unit(first.value),\n+                                            niche_scalar.clone(),\n+                                        )\n                                     }\n                                 }\n                                 _ => Abi::Aggregate { sized: true },\n@@ -857,7 +868,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 variants: Variants::NicheFilling {\n                                     dataful_variant: i,\n                                     niche_variants,\n-                                    niche,\n+                                    niche: niche_scalar,\n                                     niche_start,\n                                     variants: st,\n                                 },\n@@ -1674,40 +1685,56 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n     }\n }\n \n+struct Niche {\n+    offset: Size,\n+    scalar: Scalar,\n+    available: u128,\n+}\n+\n+impl Niche {\n+    fn reserve<'a, 'tcx>(\n+        &self,\n+        cx: LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>>,\n+        count: u128,\n+    ) -> Option<(u128, Scalar)> {\n+        if count > self.available {\n+            return None;\n+        }\n+        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let bits = value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let max_value = !0u128 >> (128 - bits);\n+        let start = v.end().wrapping_add(1) & max_value;\n+        let end = v.end().wrapping_add(count) & max_value;\n+        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n+    }\n+}\n+\n impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// Find the offset of a niche leaf field, starting from\n-    /// the given type and recursing through aggregates, which\n-    /// has at least `count` consecutive invalid values.\n-    /// The tuple is `(offset, scalar, niche_value)`.\n+    /// the given type and recursing through aggregates.\n     // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche(self, layout: TyLayout<'tcx>, count: u128)\n-        -> Result<Option<(Size, Scalar, u128)>, LayoutError<'tcx>>\n-    {\n-        let scalar_component = |scalar: &Scalar, offset| {\n+    fn find_niche(self, layout: TyLayout<'tcx>) -> Result<Option<Niche>, LayoutError<'tcx>> {\n+        let scalar_niche = |scalar: &Scalar, offset| {\n             let Scalar { value, valid_range: ref v } = *scalar;\n \n             let bits = value.size(self).bits();\n             assert!(bits <= 128);\n             let max_value = !0u128 >> (128 - bits);\n \n             // Find out how many values are outside the valid range.\n-            let niches = if v.start() <= v.end() {\n+            let available = if v.start() <= v.end() {\n                 v.start() + (max_value - v.end())\n             } else {\n                 v.start() - v.end() - 1\n             };\n \n-            // Give up if we can't fit `count` consecutive niches.\n-            if count > niches {\n+            // Give up if there is no niche value available.\n+            if available == 0 {\n                 return None;\n             }\n \n-            let niche_start = v.end().wrapping_add(1) & max_value;\n-            let niche_end = v.end().wrapping_add(count) & max_value;\n-            Some((offset, Scalar {\n-                value,\n-                valid_range: *v.start()..=niche_end\n-            }, niche_start))\n+            Some(Niche { offset, scalar: scalar.clone(), available })\n         };\n \n         // Locals variables which live across yields are stored\n@@ -1719,15 +1746,19 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n         match layout.abi {\n             Abi::Scalar(ref scalar) => {\n-                return Ok(scalar_component(scalar, Size::from_bytes(0)));\n+                return Ok(scalar_niche(scalar, Size::from_bytes(0)));\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n-                return Ok(scalar_component(a, Size::from_bytes(0)).or_else(|| {\n-                    scalar_component(b, a.value.size(self).abi_align(b.value.align(self)))\n-                }));\n+                // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+                // returns the last maximum.\n+                let niche = iter::once((b, a.value.size(self).abi_align(b.value.align(self))))\n+                    .chain(iter::once((a, Size::from_bytes(0))))\n+                    .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n+                    .max_by_key(|niche| niche.available);\n+                return Ok(niche);\n             }\n             Abi::Vector { ref element, .. } => {\n-                return Ok(scalar_component(element, Size::from_bytes(0)));\n+                return Ok(scalar_niche(element, Size::from_bytes(0)));\n             }\n             _ => {}\n         }\n@@ -1742,17 +1773,23 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         }\n         if let FieldPlacement::Array { .. } = layout.fields {\n             if layout.fields.count() > 0 {\n-                return self.find_niche(layout.field(self, 0)?, count);\n+                return self.find_niche(layout.field(self, 0)?);\n+            } else {\n+                return Ok(None);\n             }\n         }\n+        let mut niche = None;\n+        let mut available = 0;\n         for i in 0..layout.fields.count() {\n-            let r = self.find_niche(layout.field(self, i)?, count)?;\n-            if let Some((offset, scalar, niche_value)) = r {\n-                let offset = layout.fields.offset(i) + offset;\n-                return Ok(Some((offset, scalar, niche_value)));\n+            if let Some(mut c) = self.find_niche(layout.field(self, i)?)? {\n+                if c.available > available {\n+                    available = c.available;\n+                    c.offset += layout.fields.offset(i);\n+                    niche = Some(c);\n+                }\n             }\n         }\n-        Ok(None)\n+        Ok(niche)\n     }\n }\n "}, {"sha": "5eb079988f5be7e1b3d9937290ec2f90e8ca80b9", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7db68f516bc1a4296aaf2f682ec2384dc2af31e/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7db68f516bc1a4296aaf2f682ec2384dc2af31e/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=b7db68f516bc1a4296aaf2f682ec2384dc2af31e", "patch": "@@ -116,4 +116,7 @@ pub fn main() {\n     assert_eq!(size_of::<EnumWithMaybeUninhabitedVariant<!>>(),\n                size_of::<EnumWithMaybeUninhabitedVariant<()>>());\n     assert_eq!(size_of::<NicheFilledEnumWithAbsentVariant>(), size_of::<&'static ()>());\n+\n+    assert_eq!(size_of::<Option<Option<(bool, &())>>>(), size_of::<(bool, &())>());\n+    assert_eq!(size_of::<Option<Option<(&(), bool)>>>(), size_of::<(bool, &())>());\n }"}]}