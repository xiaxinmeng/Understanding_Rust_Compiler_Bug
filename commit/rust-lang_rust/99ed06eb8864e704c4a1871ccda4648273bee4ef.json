{"sha": "99ed06eb8864e704c4a1871ccda4648273bee4ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZWQwNmViODg2NGU3MDRjNGExODcxY2NkYTQ2NDgyNzNiZWU0ZWY=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-09T22:16:58Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-10T23:57:25Z"}, "message": "libs: doc comments", "tree": {"sha": "fedfce65fa389e4fc58636bfbb9d9997656e3470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fedfce65fa389e4fc58636bfbb9d9997656e3470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99ed06eb8864e704c4a1871ccda4648273bee4ef", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99ed06eb8864e704c4a1871ccda4648273bee4ef", "html_url": "https://github.com/rust-lang/rust/commit/99ed06eb8864e704c4a1871ccda4648273bee4ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99ed06eb8864e704c4a1871ccda4648273bee4ef/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "html_url": "https://github.com/rust-lang/rust/commit/b87363e7632b3f20f9b529696ffb5d5d9c3927cd"}], "stats": {"total": 781, "additions": 394, "deletions": 387}, "files": [{"sha": "40c71f12cd8a6320e9751024c25fcc81716440cd", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -137,11 +137,11 @@ impl<T> ToOwned for T\n /// ```\n /// use std::borrow::{Cow, ToOwned};\n ///\n-/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned=Vec<X>> {\n+/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n ///     values: Cow<'a, [X]>,\n /// }\n ///\n-/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned=Vec<X>> {\n+/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned = Vec<X>> {\n ///     fn new(v: Cow<'a, [X]>) -> Self {\n ///         Items { values: v }\n ///     }"}, {"sha": "3b94379b58f8f03c2e09e09bba1254263b53b423", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -863,7 +863,7 @@ struct Hole<'a, T: 'a> {\n }\n \n impl<'a, T> Hole<'a, T> {\n-    /// Create a new Hole at index `pos`.\n+    /// Create a new `Hole` at index `pos`.\n     ///\n     /// Unsafe because pos must be within the data slice.\n     #[inline]"}, {"sha": "5ec5064b735150b45465fc1c0fc996daf52ac285", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -2368,7 +2368,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n-    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n     /// destruction of the `Entry` value, see [`into_mut`].\n     ///\n     /// [`into_mut`]: #method.into_mut"}, {"sha": "eb0667228d1fff347f64b859fede02b99e8dc88f", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1295,7 +1295,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n     /// a node to hold the combination of the nodes to the left and right of this handle along\n     /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n@@ -1573,7 +1573,7 @@ unsafe fn move_edges<K, V>(\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n-    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n+    /// Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}, {"sha": "870e3e47692b02ba605dea74239aa740e088c452", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -556,7 +556,7 @@ impl<T: Ord> BTreeSet<T> {\n         Recover::replace(&mut self.map, value)\n     }\n \n-    /// Removes a value from the set. Returns `true` if the value was\n+    /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n     ///\n     /// The value may be any borrowed form of the set's value type,\n@@ -988,7 +988,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n         (None, _) => short,"}, {"sha": "b6fdaa89992122f98c94938e9e091cfedf41a0e4", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -124,7 +124,7 @@ impl<T> VecDeque<T> {\n         ptr::write(self.ptr().add(off), value);\n     }\n \n-    /// Returns `true` if and only if the buffer is at full capacity.\n+    /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n     fn is_full(&self) -> bool {\n         self.cap() - self.len() == 1\n@@ -560,7 +560,7 @@ impl<T> VecDeque<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -924,15 +924,15 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n-    /// Create a draining iterator that removes the specified range in the\n+    /// Creates a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is not\n     /// consumed until the end.\n     ///\n     /// Note 2: It is unspecified how many elements are removed from the deque,\n     /// if the `Drain` value is not dropped, but the borrow it holds expires\n-    /// (eg. due to mem::forget).\n+    /// (e.g., due to `mem::forget`).\n     ///\n     /// # Panics\n     ///"}, {"sha": "aadc5d68ac1c8f6cf5a9930220855f3ecbc7baa2", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -67,7 +67,7 @@ macro_rules! vec {\n ///\n /// Additional parameters passed to `format!` replace the `{}`s within the\n /// formatting string in the order given unless named or positional parameters\n-/// are used, see [`std::fmt`][fmt] for more information.\n+/// are used; see [`std::fmt`][fmt] for more information.\n ///\n /// A common use for `format!` is concatenation and interpolation of strings.\n /// The same convention is used with [`print!`] and [`write!`] macros,"}, {"sha": "fe28fe5095ccef29333311057ac65cb415f31da0", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -335,7 +335,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n     /// more efficient logic can be provided for this than the general case.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///\n@@ -504,7 +504,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///"}, {"sha": "12f75d84211e6f03e555b4c7e32e2aabc7c5255c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -512,7 +512,7 @@ impl<T: ?Sized> Rc<T> {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n     /// this inner value.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -561,7 +561,7 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Rc`s point to the same value (not\n+    /// Returns `true` if the two `Rc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1334,8 +1334,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n         if is_dangling(self.ptr) {\n@@ -1345,7 +1345,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "c4f4a80a017df80aed003097f3252e0bea645b67", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -205,10 +205,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`."}, {"sha": "84c35c6f1bd2b0b943faa86cbf24d65fe87114e1", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -963,7 +963,7 @@ impl String {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -1377,9 +1377,7 @@ impl String {\n         self.vec.len()\n     }\n \n-    /// Returns `true` if this `String` has a length of zero.\n-    ///\n-    /// Returns `false` otherwise.\n+    /// Returns `true` if this `String` has a length of zero, and `false` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b7d7995b540bac75fd23000e8351cd76c66bfd1b", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -560,7 +560,7 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Arc`s point to the same value (not\n+    /// Returns `true` if the two `Arc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1191,8 +1191,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n         if is_dangling(self.ptr) {\n@@ -1202,7 +1202,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "7bc1aac7c8b59643723339646360a8abaf439564", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -2,7 +2,7 @@\n \n use std::alloc::{Global, Alloc, Layout, System};\n \n-/// https://github.com/rust-lang/rust/issues/45955\n+/// Issue #45955.\n #[test]\n fn alloc_system_overaligned_request() {\n     check_overalign_requests(System)"}, {"sha": "57723e4d2128182001b917c90a7ba81b39bd2710", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -463,7 +463,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Panics\n@@ -525,7 +525,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -2608,7 +2608,7 @@ impl<T> Drain<'_, T> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n         let vec = self.vec.as_mut();\n         let range_start = vec.len;\n@@ -2628,7 +2628,7 @@ impl<T> Drain<'_, T> {\n         true\n     }\n \n-    /// Make room for inserting more elements before the tail.\n+    /// Makes room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n         let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;"}, {"sha": "8383d305518ab39e7ea822ab67ef3715358c7213", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -130,7 +130,7 @@\n //!\n //! This is simply a special - but common - case of the previous: hiding mutability for operations\n //! that appear to be immutable. The `clone` method is expected to not change the source value, and\n-//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n+//! is declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the\n //! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n //! `Cell<T>`.\n //!\n@@ -1145,7 +1145,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Make a new `Ref` for a component of the borrowed data.\n+    /// Makes a new `Ref` for a component of the borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n@@ -1217,7 +1217,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for Ref<'_, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g., an enum\n+    /// Makes a new `RefMut` for a component of the borrowed data, e.g., an enum\n     /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n@@ -1416,7 +1416,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n /// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// okay (provided you enforce the invariants some other way), it is still undefined behavior\n+/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n /// to have multiple `&mut UnsafeCell<T>` aliases.\n ///\n /// # Examples"}, {"sha": "133c9169df858c050e3bf536cb8b988c82dfd030", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -20,7 +20,7 @@ pub struct DecodeUtf16Error {\n     code: u16,\n }\n \n-/// Create an iterator over the UTF-16 encoded code points in `iter`,\n+/// Creates an iterator over the UTF-16 encoded code points in `iter`,\n /// returning unpaired surrogates as `Err`s.\n ///\n /// # Examples"}, {"sha": "72967b9adf7a05f726ec774c30f56d09db1c7459", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -524,7 +524,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n     ///\n     /// # Examples\n     ///\n@@ -548,7 +548,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Start' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Start' is a Unicode Derived Property specified in\n@@ -562,7 +562,7 @@ impl char {\n         derived_property::XID_Start(self)\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n@@ -576,7 +576,7 @@ impl char {\n         derived_property::XID_Continue(self)\n     }\n \n-    /// Returns true if this `char` is lowercase, and false otherwise.\n+    /// Returns `true` if this `char` is lowercase.\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n@@ -604,7 +604,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is uppercase, and false otherwise.\n+    /// Returns `true` if this `char` is uppercase.\n     ///\n     /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n@@ -632,7 +632,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is whitespace, and false otherwise.\n+    /// Returns `true` if this `char` is whitespace.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n     /// Property `White_Space`.\n@@ -659,7 +659,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is alphanumeric, and false otherwise.\n+    /// Returns `true` if this `char` is alphanumeric.\n     ///\n     /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n@@ -684,7 +684,7 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns true if this `char` is a control code point, and false otherwise.\n+    /// Returns `true` if this `char` is a control code point.\n     ///\n     /// 'Control code point' is defined in terms of the Unicode General\n     /// Category `Cc`.\n@@ -704,7 +704,7 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns true if this `char` is an extended grapheme character, and false otherwise.\n+    /// Returns `true` if this `char` is an extended grapheme character.\n     ///\n     /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n     /// Category `Grapheme_Extend`.\n@@ -713,7 +713,7 @@ impl char {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns true if this `char` is numeric, and false otherwise.\n+    /// Returns `true` if this `char` is numeric.\n     ///\n     /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No'."}, {"sha": "5ad05b3824764f5ba3038c638357c988ce44a89b", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -54,7 +54,7 @@\n ///\n /// ## How can I implement `Default`?\n ///\n-/// Provide an implementation for the `default()` method that returns the value of\n+/// Provides an implementation for the `default()` method that returns the value of\n /// your type that should be the default:\n ///\n /// ```"}, {"sha": "d88793f2801e72abdf5449d8f8cf19b5ae66fa2c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -184,7 +184,7 @@ impl<'a> VaList<'a> {\n         va_arg(self)\n     }\n \n-    /// Copy the `va_list` at the current location.\n+    /// Copies the `va_list` at the current location.\n     #[unstable(feature = \"c_variadic\",\n                reason = \"the `c_variadic` feature has not been properly tested on \\\n                          all supported platforms\",\n@@ -213,7 +213,7 @@ extern \"rust-intrinsic\" {\n     /// `va_copy`.\n     fn va_end(ap: &mut VaList);\n \n-    /// Copy the current location of arglist `src` to the arglist `dst`.\n+    /// Copies the current location of arglist `src` to the arglist `dst`.\n     #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                   not(target_arch = \"x86_64\")),\n               windows))]"}, {"sha": "2ce58c803b878ec2b153d063183b130fbe86b1e5", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -483,12 +483,12 @@ impl Display for Arguments<'_> {\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n-/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n+/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n /// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n ///\n-/// Pretty printing with `#?`:\n+/// Pretty-printing with `#?`:\n ///\n /// ```\n /// #[derive(Debug)]"}, {"sha": "0f142347a95babd3f429f459b1c78893d0805579", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -60,7 +60,7 @@ pub trait Future {\n     /// progress, meaning that each time the current task is woken up, it should\n     /// actively re-`poll` pending futures that it still has an interest in.\n     ///\n-    /// The `poll` function is not called repeatedly in a tight loop-- instead,\n+    /// The `poll` function is not called repeatedly in a tight loop -- instead,\n     /// it should only be called when the future indicates that it is ready to\n     /// make progress (by calling `wake()`). If you're familiar with the\n     /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures"}, {"sha": "235c79307ab8dfa3b48844c165a55afdb288e063", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -10,7 +10,7 @@ use mem;\n /// An implementation of SipHash 1-3.\n ///\n /// This is currently the default hashing function used by standard library\n-/// (eg. `collections::HashMap` uses it by default).\n+/// (e.g., `collections::HashMap` uses it by default).\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n@@ -90,7 +90,7 @@ macro_rules! compress {\n     });\n }\n \n-/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n /// `copy_nonoverlapping` to let the compiler generate the most efficient way\n /// to load it from a possibly unaligned address.\n ///\n@@ -107,7 +107,7 @@ macro_rules! load_int_le {\n     });\n }\n \n-/// Load an u64 using up to 7 bytes of a byte slice.\n+/// Loads an u64 using up to 7 bytes of a byte slice.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "89de5c1bc8af80d5c2652849fe760ca5247e19d0", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -34,7 +34,7 @@ use intrinsics;\n ///     use std::hint::unreachable_unchecked;\n ///\n ///     // `b.saturating_add(1)` is always positive (not zero),\n-///     // hence `checked_div` will never return None.\n+///     // hence `checked_div` will never return `None`.\n ///     // Therefore, the else branch is unreachable.\n ///     a.checked_div(b.saturating_add(1))\n ///         .unwrap_or_else(|| unsafe { unreachable_unchecked() })"}, {"sha": "f6de7566be914281686e5109f20760886c7abfd0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -315,35 +315,35 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -556,31 +556,31 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n@@ -857,7 +857,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n-    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // same `Vec` internals. Therefore, the new inner type must have the\n     /// // exact same size, and the same alignment, as the old type.\n     /// // The same caveats exist for this method as transmute, for\n     /// // the original inner type (`&i32`) to the converted inner type\n@@ -875,8 +875,8 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// use std::{slice, mem};\n     ///\n-    /// // There are multiple ways to do this; and there are multiple problems\n-    /// // with the following, transmute, way.\n+    /// // There are multiple ways to do this, and there are multiple problems\n+    /// // with the following (transmute) way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n     ///                              -> (&mut [T], &mut [T]) {\n     ///     let len = slice.len();\n@@ -1200,19 +1200,19 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n-    /// Perform a volatile load from the `src` pointer.\n+    /// Performs a volatile load from the `src` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n-    /// Perform a volatile load from the `src` pointer\n+    /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n "}, {"sha": "a3e9cfa94931297cfbfc32aab5fb55e81ddf2990", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -20,19 +20,19 @@ pub trait Step: Clone + PartialOrd + Sized {\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning itself\n+    /// Replaces this step with `1`, returning itself.\n     fn replace_one(&mut self) -> Self;\n \n-    /// Replaces this step with `0`, returning itself\n+    /// Replaces this step with `0`, returning itself.\n     fn replace_zero(&mut self) -> Self;\n \n-    /// Adds one to this step, returning the result\n+    /// Adds one to this step, returning the result.\n     fn add_one(&self) -> Self;\n \n-    /// Subtracts one to this step, returning the result\n+    /// Subtracts one to this step, returning the result.\n     fn sub_one(&self) -> Self;\n \n-    /// Add an usize, returning None on overflow\n+    /// Adds a `usize`, returning `None` on overflow.\n     fn add_usize(&self, n: usize) -> Option<Self>;\n }\n "}, {"sha": "d6eab40213edb0fe9902fb95838ca294a99c82e9", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -104,7 +104,7 @@ pub trait ExactSizeIterator: Iterator {\n         lower\n     }\n \n-    /// Returns whether the iterator is empty.\n+    /// Returns `true` if the iterator is empty.\n     ///\n     /// This method has a default implementation using `self.len()`, so you\n     /// don't need to implement it yourself."}, {"sha": "861e9c3157a790d51da98e72c698566f2b5b1391", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -120,7 +120,7 @@ pub trait Iterator {\n     /// // ... and then None once it's over.\n     /// assert_eq!(None, iter.next());\n     ///\n-    /// // More calls may or may not return None. Here, they always will.\n+    /// // More calls may or may not return `None`. Here, they always will.\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next());\n     /// ```\n@@ -1215,7 +1215,7 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(4));\n     /// assert_eq!(iter.next(), None);\n     ///\n-    /// // it will always return None after the first time.\n+    /// // it will always return `None` after the first time.\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);"}, {"sha": "2a9cb75df2ce4fd75a03f4aca7cfd7bd85a3998d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1,4 +1,4 @@\n-/// Entry point of thread panic, for details, see std::macros\n+/// Entry point of thread panic. For details, see `std::macros`.\n #[macro_export]\n #[allow_internal_unstable]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -493,7 +493,7 @@ macro_rules! unreachable {\n /// A standardized placeholder for marking unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck, or if you're implementing a trait that requires multiple\n+/// code type-check, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n /// # Panics"}, {"sha": "2a493e88fe89617ccdb0121fb42befc58e5848a5", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -295,7 +295,7 @@ pub const fn size_of<T>() -> usize {\n /// Returns the size of the pointed-to value in bytes.\n ///\n /// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n@@ -403,7 +403,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns whether dropping values of type `T` matters.\n+/// Returns `true` if dropping values of type `T` matters.\n ///\n /// This is purely an optimization hint, and may be implemented conservatively:\n /// it may return `true` for types that don't actually need to be dropped.\n@@ -958,7 +958,7 @@ impl<T> ManuallyDrop<T> {\n         ManuallyDrop { value }\n     }\n \n-    /// Extract the value from the `ManuallyDrop` container.\n+    /// Extracts the value from the `ManuallyDrop` container.\n     ///\n     /// This allows the value to be dropped again.\n     ///\n@@ -1038,26 +1038,29 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// A newtype to construct uninitialized instances of `T`.\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n-/// at their respective type.  For example, a variable of reference type must\n-/// be aligned and non-NULL.  This is an invariant that must *always* be upheld,\n-/// even in unsafe code.  As a consequence, 0-initializing a variable of reference\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n /// type causes instantaneous undefined behavior, no matter whether that reference\n /// ever gets used to access memory:\n+///\n /// ```rust,no_run\n /// use std::mem;\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n /// ```\n+///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of 0-initializing it) causes the same\n+/// Not initializing memory at all (instead of zero--initializing it) causes the same\n /// issue: after all, the initial value of the variable might just happen to be\n /// one that violates the invariant.\n ///\n /// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n /// it is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n+///\n /// ```rust\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n@@ -1070,6 +1073,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// // initializing `x`!\n /// let x = unsafe { x.into_initialized() };\n /// ```\n+///\n /// The compiler then knows to not optimize this code.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n@@ -1090,7 +1094,7 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit` in an uninitialized state.\n     ///\n     /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1100,7 +1104,7 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n     /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n@@ -1118,9 +1122,9 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Set the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n-    /// For your convenience, this also returns a mutable reference to the (now\n-    /// safely initialized) content of `self`.\n+    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n+    /// contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn set(&mut self, val: T) -> &mut T {\n@@ -1130,7 +1134,7 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n-    /// Extract the value from the `MaybeUninit` container. This is a great way\n+    /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n@@ -1145,15 +1149,15 @@ impl<T> MaybeUninit<T> {\n         ManuallyDrop::into_inner(self.value)\n     }\n \n-    /// Deprecated alternative to `into_initialized`.  Will never get stabilized.\n+    /// Deprecated alternative to `into_initialized`. Will never get stabilized.\n     /// Exists only to transition stdsimd to `into_initialized`.\n     #[inline(always)]\n     #[allow(unused)]\n     pub(crate) unsafe fn into_inner(self) -> T {\n         self.into_initialized()\n     }\n \n-    /// Get a reference to the contained value.\n+    /// Gets a reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n@@ -1165,7 +1169,7 @@ impl<T> MaybeUninit<T> {\n         &*self.value\n     }\n \n-    /// Get a mutable reference to the contained value.\n+    /// Gets a mutable reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n@@ -1180,30 +1184,30 @@ impl<T> MaybeUninit<T> {\n         &mut *self.value\n     }\n \n-    /// Get a pointer to the contained value. Reading from this pointer or turning it\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n     }\n \n-    /// Get a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// Get sa mutable pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n \n-    /// Get a pointer to the first element of the array.\n+    /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n-    /// Get a mutable pointer to the first element of the array.\n+    /// Gets a mutable pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {"}, {"sha": "3b57bb7544b35bb3b8b18d4422f01527ab7da3c3", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -61,7 +61,7 @@ mod fpu_precision {\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n     }\n \n-    /// Set the precision field of the FPU to `T` and return a `FPUControlWord`\n+    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n     pub fn set_precision<T>() -> FPUControlWord {\n         let cw = 0u16;\n "}, {"sha": "47ea5aa5ff000b8c8b1b08f8656375112e4b0802", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -54,7 +54,7 @@\n //! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n //! and round *exactly once, at the end*, by considering all truncated bits at once.\n //!\n-//! FIXME Although some code duplication is necessary, perhaps parts of the code could be shuffled\n+//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n //! around such that less code is duplicated. Large parts of the algorithms are independent of the\n //! float type to output, or only needs access to a few constants, which could be passed in as\n //! parameters.\n@@ -219,7 +219,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n     }\n }\n \n-/// Convert a decimal string into a floating point number.\n+/// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n         return Err(pfe_empty())"}, {"sha": "126713185711b3fecd0a4046e8e8bf4c0bee8ccc", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -27,7 +27,7 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n     Equal\n }\n \n-/// Convert an ASCII string containing only decimal digits to a `u64`.\n+/// Converts an ASCII string containing only decimal digits to a `u64`.\n ///\n /// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n /// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n@@ -44,7 +44,7 @@ pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'\n     result\n }\n \n-/// Convert a string of ASCII digits into a bignum.\n+/// Converts a string of ASCII digits into a bignum.\n ///\n /// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\n pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n@@ -69,7 +69,7 @@ pub fn to_u64(x: &Big) -> u64 {\n }\n \n \n-/// Extract a range of bits.\n+/// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual.\n /// Panics if asked to extract more bits than fit into the return type."}, {"sha": "933f8c1d3f781e959c7dbe309a92fbc9ca784bb6", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -42,7 +42,7 @@ pub enum ParseResult<'a> {\n     Invalid,\n }\n \n-/// Check if the input string is a valid floating point number and if so, locate the integral\n+/// Checks if the input string is a valid floating point number and if so, locate the integral\n /// part, the fractional part, and the exponent in it. Does not handle signs.\n pub fn parse_decimal(s: &str) -> ParseResult {\n     if s.is_empty() {"}, {"sha": "b65f539b29c97c105df01ada310443a104a0eb9f", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -240,7 +240,7 @@ impl RawFloat for f64 {\n     fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n }\n \n-/// Convert an Fp to the closest machine float type.\n+/// Converts an `Fp` to the closest machine float type.\n /// Does not handle subnormal results.\n pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let x = x.normalize();\n@@ -319,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n     }\n }\n \n-/// Find the largest floating point number strictly smaller than the argument.\n+/// Finds the largest floating point number strictly smaller than the argument.\n /// Does not handle subnormals, zero, or exponent underflow.\n pub fn prev_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {"}, {"sha": "dc0580764acb74838221593997cb5a194337c153", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f32\"]\n #[cfg(not(test))]\n impl f32 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -169,8 +169,8 @@ impl f32 {\n         f32::from_bits(self.to_bits() & 0x7fff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -272,7 +272,7 @@ impl f32 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -288,7 +288,7 @@ impl f32 {\n         !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "c3677f8c8faea466532e864c1d68110fff0ffc3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f64\"]\n #[cfg(not(test))]\n impl f64 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -169,8 +169,8 @@ impl f64 {\n         f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -272,7 +272,7 @@ impl f64 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -296,7 +296,7 @@ impl f64 {\n         self.is_sign_positive()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "6b3ec2c21bef1a40e626af35820d7e784eb616ce", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -52,7 +52,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n             }\n \n             impl $Ty {\n-                /// Create a non-zero without checking the value.\n+                /// Creates a non-zero without checking the value.\n                 ///\n                 /// # Safety\n                 ///\n@@ -63,7 +63,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                     $Ty(n)\n                 }\n \n-                /// Create a non-zero if the given value is not zero.\n+                /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {"}, {"sha": "0252edee231254a0afe3e0786e3701cd5cfb5669", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -49,7 +49,7 @@\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Add<Output=T>> Add for Point<T> {\n+/// impl<T: Add<Output = T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn add(self, other: Point<T>) -> Point<T> {\n@@ -157,7 +157,7 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Sub<Output=T>> Sub for Point<T> {\n+/// impl<T: Sub<Output = T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn sub(self, other: Point<T>) -> Point<T> {"}, {"sha": "b3dd5d20299c1706ec50582ca7f1cf8180b64d86", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -52,7 +52,7 @@ impl fmt::Debug for RangeFull {\n /// (`start..end`).\n ///\n /// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`.  It is empty unless `start < end`.\n+/// `x < end`. It is empty unless `start < end`.\n ///\n /// # Examples\n ///\n@@ -297,7 +297,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// A range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n-/// and `x <= end`.  It is empty unless `start <= end`.\n+/// and `x <= end`. It is empty unless `start <= end`.\n ///\n /// This iterator is [fused], but the specific values of `start` and `end` after\n /// iteration has finished are **unspecified** other than that [`.is_empty()`]"}, {"sha": "76ef36ac30962d19dfef4a5792f742b03ee0bbb5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -214,7 +214,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n     /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n@@ -395,7 +395,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n     ///\n     /// [`String`]: ../../std/string/struct.String.html\n     /// [`usize`]: ../../std/primitive.usize.html\n@@ -963,7 +963,7 @@ impl<T: Default> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning\n     /// [`None`] on error."}, {"sha": "ee9098d73ee92ff8ad2933dbfd7ea0a5c91e9602", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -199,7 +199,7 @@ impl<P: Deref> Pin<P> {\n         Pin { pointer }\n     }\n \n-    /// Get a pinned shared reference from this pinned pointer.\n+    /// Gets a pinned shared reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n@@ -208,7 +208,7 @@ impl<P: Deref> Pin<P> {\n }\n \n impl<P: DerefMut> Pin<P> {\n-    /// Get a pinned mutable reference from this pinned pointer.\n+    /// Gets a pinned mutable reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n@@ -247,7 +247,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n         Pin::new_unchecked(new_pointer)\n     }\n \n-    /// Get a shared reference out of a pin.\n+    /// Gets a shared reference out of a pin.\n     ///\n     /// Note: `Pin` also implements `Deref` to the target, which can be used\n     /// to access the inner value. However, `Deref` only provides a reference\n@@ -262,14 +262,14 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n }\n \n impl<'a, T: ?Sized> Pin<&'a mut T> {\n-    /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n+    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// This requires that the data inside this `Pin` is `Unpin`.\n     ///\n@@ -286,7 +286,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         self.pointer\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// # Safety\n     ///"}, {"sha": "866c8d0896b3c637a714d13dd8f4106b115ae98b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -825,7 +825,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -903,7 +903,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -2473,7 +2473,7 @@ impl<T: ?Sized> PartialEq for *mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Eq for *mut T {}\n \n-/// Compare raw pointers for equality.\n+/// Compares raw pointers for equality.\n ///\n /// This is the same as using the `==` operator, but less generic:\n /// the arguments have to be `*const T` raw pointers,"}, {"sha": "92d29f6ee8a30c83ba9ec50c9cbf7983c61fc22b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -896,7 +896,7 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning an\n     /// [`Err`] on error."}, {"sha": "cbba546b8dabad1137a3cc235c199cad5a424faa", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -11,7 +11,7 @@ const HI_U64: u64 = 0x8080808080808080;\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n \n-/// Returns whether `x` contains any zero byte.\n+/// Returns `true` if `x` contains any zero byte.\n ///\n /// From *Matters Computational*, J. Arndt:\n ///"}, {"sha": "acca9748372ca15b521a7e4c82a37aa481f1092b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -4123,7 +4123,7 @@ pub struct ChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4247,7 +4247,7 @@ pub struct ChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4619,7 +4619,7 @@ pub struct RChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4744,7 +4744,7 @@ pub struct RChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "6c08e545c5c0f7473a795fb5f3e0c0ae42151ffb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -226,7 +226,7 @@ impl Utf8Error {\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n \n-    /// Provide more information about the failure:\n+    /// Provides more information about the failure:\n     ///\n     /// * `None`: the end of the input was reached unexpectedly.\n     ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n@@ -3504,7 +3504,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3541,7 +3541,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n@@ -3787,7 +3787,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3819,7 +3819,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples"}, {"sha": "2571780ad0bab11987bd02cff0fb79cdb30ac55a", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -117,7 +117,7 @@ pub unsafe trait Searcher<'a> {\n     /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next()`\n+    /// Finds the next `Match` result. See `next()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_reject will overlap. This will return (start_match, end_match),\n@@ -134,7 +134,7 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next()` and `next_match()`\n+    /// Finds the next `Reject` result. See `next()` and `next_match()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_match will overlap.\n@@ -185,7 +185,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n     fn next_back(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next_back()`\n+    /// Finds the next `Match` result. See `next_back()`\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)>{\n         loop {\n@@ -197,7 +197,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next_back()`\n+    /// Finds the next `Reject` result. See `next_back()`\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n         loop {"}, {"sha": "c811f96ace3baba30f317458db80230eaca8837e", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -22,7 +22,7 @@ pub enum Poll<T> {\n }\n \n impl<T> Poll<T> {\n-    /// Change the ready value of this `Poll` with the closure provided\n+    /// Changes the ready value of this `Poll` with the closure provided.\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n         where F: FnOnce(T) -> U\n     {\n@@ -32,7 +32,7 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Ready`\n+    /// Returns `true` if this is `Poll::Ready`\n     #[inline]\n     pub fn is_ready(&self) -> bool {\n         match *self {\n@@ -41,15 +41,15 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Pending`\n+    /// Returns `true` if this is `Poll::Pending`\n     #[inline]\n     pub fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n }\n \n impl<T, E> Poll<Result<T, E>> {\n-    /// Change the success value of this `Poll` with the closure provided\n+    /// Changes the success value of this `Poll` with the closure provided.\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n         where F: FnOnce(T) -> U\n     {\n@@ -60,7 +60,7 @@ impl<T, E> Poll<Result<T, E>> {\n         }\n     }\n \n-    /// Change the error value of this `Poll` with the closure provided\n+    /// Changes the error value of this `Poll` with the closure provided.\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n         where F: FnOnce(E) -> U\n     {"}, {"sha": "6d54989706cac9c46c2a1282c299d84fdb449bf3", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -41,11 +41,11 @@ impl Waker {\n         unsafe { self.inner.as_ref().wake() }\n     }\n \n-    /// Returns whether or not this `Waker` and `other` awaken the same task.\n+    /// Returns `true` if or not this `Waker` and `other` awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n+    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same\n     /// task.\n     ///\n     /// This function is primarily used for optimization purposes.\n@@ -54,7 +54,7 @@ impl Waker {\n         self.inner == other.inner\n     }\n \n-    /// Returns whether or not this `Waker` and `other` `LocalWaker` awaken\n+    /// Returns `true` if or not this `Waker` and `other` `LocalWaker` awaken\n     /// the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n@@ -150,7 +150,7 @@ impl LocalWaker {\n         unsafe { self.0.inner.as_ref().wake_local() }\n     }\n \n-    /// Returns whether or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n+    /// Returns `true` if or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `LocalWaker`s would awaken the same task. However, if this function\n@@ -163,7 +163,7 @@ impl LocalWaker {\n         self.0.will_wake(&other.0)\n     }\n \n-    /// Returns whether or not this `LocalWaker` and `other` `Waker` awaken the same task.\n+    /// Returns `true` if or not this `LocalWaker` and `other` `Waker` awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n@@ -223,14 +223,14 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// Drops this instance of `UnsafeWake`, deallocating resources\n     /// associated with it.\n     ///\n-    /// FIXME(cramertj)\n+    // FIXME(cramertj):\n     /// This method is intended to have a signature such as:\n     ///\n     /// ```ignore (not-a-doctest)\n     /// fn drop_raw(self: *mut Self);\n     /// ```\n     ///\n-    /// Unfortunately in Rust today that signature is not object safe.\n+    /// Unfortunately, in Rust today that signature is not object safe.\n     /// Nevertheless it's recommended to implement this function *as if* that\n     /// were its signature. As such it is not safe to call on an invalid\n     /// pointer, nor is the validity of the pointer guaranteed after this"}, {"sha": "51a6017de1b5fead95d446117fa7f452118da28f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -881,7 +881,7 @@ fn test_iterator_flat_map() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `FlatMap::fold` with items already picked off the front and back,\n+/// Tests `FlatMap::fold` with items already picked off the front and back,\n /// to make sure all parts of the `FlatMap` are folded correctly.\n #[test]\n fn test_iterator_flat_map_fold() {\n@@ -919,7 +919,7 @@ fn test_iterator_flatten() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `Flatten::fold` with items already picked off the front and back,\n+/// Tests `Flatten::fold` with items already picked off the front and back,\n /// to make sure all parts of the `Flatten` are folded correctly.\n #[test]\n fn test_iterator_flatten_fold() {"}, {"sha": "ac7e11754aa3a21955d9036134dd0ce055140403", "filename": "src/libcore/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -515,7 +515,7 @@ impl Duration {\n         }\n     }\n \n-    /// Multiply `Duration` by `f64`.\n+    /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n     /// This method will panic if result is not finite, negative or overflows `Duration`."}, {"sha": "beecfb1aa295fb7cecf003780d7de20707d3471b", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -370,7 +370,7 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n /// }\n ///\n /// impl Viking {\n-///     /// Create a new Viking.\n+///     /// Creates a new Viking.\n ///     fn new(name: &str, country: &str) -> Viking {\n ///         Viking { name: name.to_string(), country: country.to_string() }\n ///     }\n@@ -556,7 +556,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n     (retkey, retval, gap.into_table())\n }\n \n-/// Perform robin hood bucket stealing at the given `bucket`. You must\n+/// Performs robin hood bucket stealing at the given `bucket`. You must\n /// also pass that bucket's displacement so we don't have to recalculate it.\n ///\n /// `hash`, `key`, and `val` are the elements to \"robin hood\" into the hashtable.\n@@ -1214,7 +1214,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.table.size()\n     }\n \n-    /// Returns true if the map contains no elements.\n+    /// Returns `true` if the map contains no elements.\n     ///\n     /// # Examples\n     ///\n@@ -1332,7 +1332,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.search(k).map(|bucket| bucket.into_refs())\n     }\n \n-    /// Returns true if the map contains a value for the specified key.\n+    /// Returns `true` if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n@@ -1896,7 +1896,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     where S: BuildHasher,\n           K: Eq + Hash,\n {\n-    /// Create a `RawEntryMut` from the given key.\n+    /// Creates a `RawEntryMut` from the given key.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n@@ -1907,7 +1907,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n         self.from_key_hashed_nocheck(hasher.finish(), k)\n     }\n \n-    /// Create a `RawEntryMut` from the given key and its hash.\n+    /// Creates a `RawEntryMut` from the given key and its hash.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n@@ -1939,7 +1939,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n             }\n         }\n     }\n-    /// Create a `RawEntryMut` from the given hash.\n+    /// Creates a `RawEntryMut` from the given hash.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>"}, {"sha": "92e63df7c682e4eb579de7519bdeb2740b116383", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -471,7 +471,7 @@ impl<T, S> HashSet<T, S>\n         self.map.len()\n     }\n \n-    /// Returns true if the set contains no elements.\n+    /// Returns `true` if the set contains no elements.\n     ///\n     /// # Examples\n     ///\n@@ -696,7 +696,7 @@ impl<T, S> HashSet<T, S>\n         Recover::replace(&mut self.map, value)\n     }\n \n-    /// Removes a value from the set. Returns `true` if the value was\n+    /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n     ///\n     /// The value may be any borrowed form of the set's value type, but"}, {"sha": "9446a80a55cd25f957c81caa9a720a4614bc6ca9", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -248,11 +248,11 @@ impl<K, V, M> FullBucket<K, V, M> {\n     pub fn into_table(self) -> M {\n         self.table\n     }\n-    /// Get the raw index.\n+    /// Gets the raw index.\n     pub fn index(&self) -> usize {\n         self.raw.idx\n     }\n-    /// Get the raw bucket.\n+    /// Gets the raw bucket.\n     pub fn raw(&self) -> RawBucket<K, V> {\n         self.raw\n     }\n@@ -270,7 +270,7 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n }\n \n impl<K, V, M> Bucket<K, V, M> {\n-    /// Get the raw index.\n+    /// Gets the raw index.\n     pub fn index(&self) -> usize {\n         self.raw.idx\n     }\n@@ -503,7 +503,7 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n         }\n     }\n \n-    /// Get the distance between this bucket and the 'ideal' location\n+    /// Gets the distance between this bucket and the 'ideal' location\n     /// as determined by the key's hash stored in it.\n     ///\n     /// In the cited blog posts above, this is called the \"distance to\n@@ -839,12 +839,12 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n-    /// Set the table tag\n+    /// Sets the table tag.\n     pub fn set_tag(&mut self, value: bool) {\n         self.hashes.set_tag(value)\n     }\n \n-    /// Get the table tag\n+    /// Gets the table tag.\n     pub fn tag(&self) -> bool {\n         self.hashes.tag()\n     }"}, {"sha": "9ebeff48426f597d8d8a28ebaa371702a8d2cb7a", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -323,8 +323,8 @@\n //! // A client of the bar. They have a blood alcohol level.\n //! struct Person { blood_alcohol: f32 }\n //!\n-//! // All the orders made to the bar, by client id.\n-//! let orders = vec![1,2,1,2,3,4,1,2,2,3,4,1,1,1];\n+//! // All the orders made to the bar, by client ID.\n+//! let orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];\n //!\n //! // Our clients.\n //! let mut blood_alcohol = BTreeMap::new();"}, {"sha": "f792ff5617970e56724048250fdf759ac1760ef4", "filename": "src/libstd/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -195,7 +195,7 @@ pub trait Error: Debug + Display {\n     #[stable(feature = \"error_source\", since = \"1.30.0\")]\n     fn source(&self) -> Option<&(dyn Error + 'static)> { None }\n \n-    /// Get the `TypeId` of `self`\n+    /// Gets the `TypeId` of `self`\n     #[doc(hidden)]\n     #[stable(feature = \"error_type_id\", since = \"1.34.0\")]\n     fn type_id(&self) -> TypeId where Self: 'static {\n@@ -564,7 +564,7 @@ impl Error for char::ParseCharError {\n \n // copied from any.rs\n impl dyn Error + 'static {\n-    /// Returns true if the boxed type is the same as `T`\n+    /// Returns `true` if the boxed type is the same as `T`\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {"}, {"sha": "caf490a02777e1f2ae7102318b91a8bfec1f7064", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -377,7 +377,7 @@ impl CString {\n     ///\n     /// # Examples\n     ///\n-    /// Create a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n+    /// Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n     /// ownership with `from_raw`:\n     ///\n     /// ```ignore (extern-declaration)"}, {"sha": "7dbf15cdc90abc68da76d7c27c35882f56dc4a45", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -259,7 +259,7 @@ impl OsString {\n     /// already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer reserve if future insertions are expected.\n     ///\n     /// # Examples"}, {"sha": "f1e8619fc8ffce412769d147a03e09cab6d8053d", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -25,7 +25,7 @@ use time::SystemTime;\n ///\n /// # Examples\n ///\n-/// Create a new file and write bytes to it:\n+/// Creates a new file and write bytes to it:\n ///\n /// ```no_run\n /// use std::fs::File;\n@@ -488,13 +488,13 @@ impl File {\n         self.inner.file_attr().map(Metadata)\n     }\n \n-    /// Create a new `File` instance that shares the same underlying file handle\n+    /// Creates a new `File` instance that shares the same underlying file handle\n     /// as the existing `File` instance. Reads, writes, and seeks will affect\n     /// both `File` instances simultaneously.\n     ///\n     /// # Examples\n     ///\n-    /// Create two handles for a file named `foo.txt`:\n+    /// Creates two handles for a file named `foo.txt`:\n     ///\n     /// ```no_run\n     /// use std::fs::File;\n@@ -896,7 +896,7 @@ impl Metadata {\n         FileType(self.0.file_type())\n     }\n \n-    /// Returns whether this metadata is for a directory. The\n+    /// Returns `true` if this metadata is for a directory. The\n     /// result is mutually exclusive to the result of\n     /// [`is_file`], and will be false for symlink metadata\n     /// obtained from [`symlink_metadata`].\n@@ -919,7 +919,7 @@ impl Metadata {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n \n-    /// Returns whether this metadata is for a regular file. The\n+    /// Returns `true` if this metadata is for a regular file. The\n     /// result is mutually exclusive to the result of\n     /// [`is_dir`], and will be false for symlink metadata\n     /// obtained from [`symlink_metadata`].\n@@ -1096,7 +1096,7 @@ impl AsInner<fs_imp::FileAttr> for Metadata {\n }\n \n impl Permissions {\n-    /// Returns whether these permissions describe a readonly (unwritable) file.\n+    /// Returns `true` if these permissions describe a readonly (unwritable) file.\n     ///\n     /// # Examples\n     ///\n@@ -1152,7 +1152,7 @@ impl Permissions {\n }\n \n impl FileType {\n-    /// Test whether this file type represents a directory. The\n+    /// Tests whether this file type represents a directory. The\n     /// result is mutually exclusive to the results of\n     /// [`is_file`] and [`is_symlink`]; only zero or one of these\n     /// tests may pass.\n@@ -1176,7 +1176,7 @@ impl FileType {\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n     pub fn is_dir(&self) -> bool { self.0.is_dir() }\n \n-    /// Test whether this file type represents a regular file.\n+    /// Tests whether this file type represents a regular file.\n     /// The result is  mutually exclusive to the results of\n     /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n     /// tests may pass.\n@@ -1200,7 +1200,7 @@ impl FileType {\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n     pub fn is_file(&self) -> bool { self.0.is_file() }\n \n-    /// Test whether this file type represents a symbolic link.\n+    /// Tests whether this file type represents a symbolic link.\n     /// The result is mutually exclusive to the results of\n     /// [`is_dir`] and [`is_file`]; only zero or one of these\n     /// tests may pass.\n@@ -1209,7 +1209,7 @@ impl FileType {\n     /// with the [`fs::symlink_metadata`] function and not the\n     /// [`fs::metadata`] function. The [`fs::metadata`] function\n     /// follows symbolic links, so [`is_symlink`] would always\n-    /// return false for the target file.\n+    /// return `false` for the target file.\n     ///\n     /// [`Metadata`]: struct.Metadata.html\n     /// [`fs::metadata`]: fn.metadata.html\n@@ -1290,7 +1290,7 @@ impl DirEntry {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn path(&self) -> PathBuf { self.0.path() }\n \n-    /// Return the metadata for the file that this entry points at.\n+    /// Returns the metadata for the file that this entry points at.\n     ///\n     /// This function will not traverse symlinks if this entry points at a\n     /// symlink.\n@@ -1325,7 +1325,7 @@ impl DirEntry {\n         self.0.metadata().map(Metadata)\n     }\n \n-    /// Return the file type for the file that this entry points at.\n+    /// Returns the file type for the file that this entry points at.\n     ///\n     /// This function will not traverse symlinks if this entry points at a\n     /// symlink.\n@@ -2025,7 +2025,7 @@ impl DirBuilder {\n         self\n     }\n \n-    /// Create the specified directory with the options configured in this\n+    /// Creates the specified directory with the options configured in this\n     /// builder.\n     ///\n     /// It is considered an error if the directory already exists unless"}, {"sha": "c0570ae60a19c0575ec12ba2fbab0d6afd9e7015", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1219,19 +1219,19 @@ pub trait Seek {\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum SeekFrom {\n-    /// Set the offset to the provided number of bytes.\n+    /// Sets the offset to the provided number of bytes.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Start(#[stable(feature = \"rust1\", since = \"1.0.0\")] u64),\n \n-    /// Set the offset to the size of this object plus the specified number of\n+    /// Sets the offset to the size of this object plus the specified number of\n     /// bytes.\n     ///\n     /// It is possible to seek beyond the end of an object, but it's an error to\n     /// seek before byte 0.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     End(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n \n-    /// Set the offset to the current position plus the specified number of\n+    /// Sets the offset to the current position plus the specified number of\n     /// bytes.\n     ///\n     /// It is possible to seek beyond the end of an object, but it's an error to"}, {"sha": "bef6bc9266197af914c33bf26232a3c22327d9d4", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -260,7 +260,7 @@ mod extern_keyword { }\n /// }\n ///\n /// fn generic_where<T>(x: T) -> T\n-///     where T: std::ops::Add<Output=T> + Copy\n+///     where T: std::ops::Add<Output = T> + Copy\n /// {\n ///     x + x + x\n /// }\n@@ -289,7 +289,7 @@ mod fn_keyword { }\n /// `for` is primarily used in for-in-loops, but it has a few other pieces of syntactic uses such as\n /// `impl Trait for Type` (see [`impl`] for more info on that). for-in-loops, or to be more\n /// precise, iterator loops, are a simple syntactic sugar over an exceedingly common practice\n-/// within Rust, which is to loop over an iterator until that iterator returns None (or `break`\n+/// within Rust, which is to loop over an iterator until that iterator returns `None` (or `break`\n /// is called).\n ///\n /// ```rust"}, {"sha": "63cf6b62145a9a32aac7ac2a6f4fa27959fbded3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -7,7 +7,7 @@\n //! primitives](#primitives), [standard macros](#macros), [I/O] and\n //! [multithreading], among [many other things][other].\n //!\n-//! `std` is available to all Rust crates by default. Therefore the\n+//! `std` is available to all Rust crates by default. Therefore, the\n //! standard library can be accessed in [`use`] statements through the path\n //! `std`, as in [`use std::env`].\n //!"}, {"sha": "654ad64d97b36daa871fab037739bc057e8b80b9", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -510,7 +510,7 @@ impl SocketAddrV6 {\n         self.inner.sin6_scope_id\n     }\n \n-    /// Change the scope ID associated with this socket address.\n+    /// Changes the scope ID associated with this socket address.\n     ///\n     /// See the [`scope_id`] method's documentation for more details.\n     ///"}, {"sha": "4d59aeb6765d3d749bf3ad2d1c497f28cf3f6f65", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -773,7 +773,7 @@ impl FromInner<c::in_addr> for Ipv4Addr {\n \n #[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n impl From<Ipv4Addr> for u32 {\n-    /// Convert an `Ipv4Addr` into a host byte order `u32`.\n+    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n     ///\n     /// # Examples\n     ///\n@@ -791,7 +791,7 @@ impl From<Ipv4Addr> for u32 {\n \n #[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n impl From<u32> for Ipv4Addr {\n-    /// Convert a host byte order `u32` into an `Ipv4Addr`.\n+    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n     ///\n     /// # Examples\n     ///\n@@ -823,7 +823,7 @@ impl From<[u8; 4]> for Ipv4Addr {\n \n #[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n impl From<[u8; 4]> for IpAddr {\n-    /// Create an `IpAddr::V4` from a four element byte array.\n+    /// Creates an `IpAddr::V4` from a four element byte array.\n     ///\n     /// # Examples\n     ///\n@@ -1420,7 +1420,7 @@ impl From<[u16; 8]> for Ipv6Addr {\n \n #[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n impl From<[u8; 16]> for IpAddr {\n-    /// Create an `IpAddr::V6` from a sixteen element byte array.\n+    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n     ///\n     /// # Examples\n     ///\n@@ -1448,7 +1448,7 @@ impl From<[u8; 16]> for IpAddr {\n \n #[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n impl From<[u16; 8]> for IpAddr {\n-    /// Create an `IpAddr::V6` from an eight element 16-bit array.\n+    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c4b0cd0f17c347e6e4240637dd3b5976eaf733e0", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -497,7 +497,7 @@ impl TcpStream {\n         self.0.ttl()\n     }\n \n-    /// Get the value of the `SO_ERROR` option on this socket.\n+    /// Gets the value of the `SO_ERROR` option on this socket.\n     ///\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n@@ -636,15 +636,15 @@ impl TcpListener {\n     ///\n     /// # Examples\n     ///\n-    /// Create a TCP listener bound to `127.0.0.1:80`:\n+    /// Creates a TCP listener bound to `127.0.0.1:80`:\n     ///\n     /// ```no_run\n     /// use std::net::TcpListener;\n     ///\n     /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n     /// ```\n     ///\n-    /// Create a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n+    /// Creates a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n     /// TCP listener bound to `127.0.0.1:443`:\n     ///\n     /// ```no_run\n@@ -811,7 +811,7 @@ impl TcpListener {\n         self.0.only_v6()\n     }\n \n-    /// Get the value of the `SO_ERROR` option on this socket.\n+    /// Gets the value of the `SO_ERROR` option on this socket.\n     ///\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between"}, {"sha": "d49871ce7bd86556c3b7690920d4232d33ce8f67", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -69,15 +69,15 @@ impl UdpSocket {\n     ///\n     /// # Examples\n     ///\n-    /// Create a UDP socket bound to `127.0.0.1:3400`:\n+    /// Creates a UDP socket bound to `127.0.0.1:3400`:\n     ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n     /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n     /// ```\n     ///\n-    /// Create a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n+    /// Creates a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n     /// bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n     ///\n     /// ```no_run\n@@ -158,7 +158,7 @@ impl UdpSocket {\n     /// This will return an error when the IP version of the local socket\n     /// does not match that returned from [`ToSocketAddrs`].\n     ///\n-    /// See <https://github.com/rust-lang/rust/issues/34202> for more details.\n+    /// See issue #34202 for more details.\n     ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n@@ -590,7 +590,7 @@ impl UdpSocket {\n         self.0.leave_multicast_v6(multiaddr, interface)\n     }\n \n-    /// Get the value of the `SO_ERROR` option on this socket.\n+    /// Gets the value of the `SO_ERROR` option on this socket.\n     ///\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n@@ -627,7 +627,7 @@ impl UdpSocket {\n     ///\n     /// # Examples\n     ///\n-    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// Creates a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n     /// `127.0.0.1:8080`:\n     ///\n     /// ```no_run\n@@ -756,7 +756,7 @@ impl UdpSocket {\n     ///\n     /// # Examples\n     ///\n-    /// Create a UDP socket bound to `127.0.0.1:7878` and read bytes in\n+    /// Creates a UDP socket bound to `127.0.0.1:7878` and read bytes in\n     /// nonblocking mode:\n     ///\n     /// ```no_run"}, {"sha": "0f1d627fa1e85547a9926261fef5d01e087d90ee", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -2393,7 +2393,7 @@ impl Path {\n         fs::read_dir(self)\n     }\n \n-    /// Returns whether the path points at an existing entity.\n+    /// Returns `true` if the path points at an existing entity.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n@@ -2419,7 +2419,7 @@ impl Path {\n         fs::metadata(self).is_ok()\n     }\n \n-    /// Returns whether the path exists on disk and is pointing at a regular file.\n+    /// Returns `true` if the path exists on disk and is pointing at a regular file.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n@@ -2448,7 +2448,7 @@ impl Path {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n     }\n \n-    /// Returns whether the path exists on disk and is pointing at a directory.\n+    /// Returns `true` if the path exists on disk and is pointing at a directory.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`."}, {"sha": "6bb7f28efebcfd3197e57260c45e7fd1f0271a4c", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -126,7 +126,7 @@ mod prim_bool { }\n ///\n /// ```ignore (string-from-str-error-type-is-not-never-yet)\n /// #[feature(exhaustive_patterns)]\n-/// // NOTE: This does not work today!\n+/// // NOTE: this does not work today!\n /// let Ok(s) = String::from_str(\"hello\");\n /// ```\n ///"}, {"sha": "a2ef85016d8a28151c08c2234d114ed734746240", "filename": "src/libstd/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -427,7 +427,7 @@ impl Command {\n     /// The search path to be used may be controlled by setting the\n     /// `PATH` environment variable on the Command,\n     /// but this has some implementation limitations on Windows\n-    /// (see <https://github.com/rust-lang/rust/issues/37519>).\n+    /// (see issue #37519).\n     ///\n     /// # Examples\n     ///\n@@ -445,7 +445,7 @@ impl Command {\n         Command { inner: imp::Command::new(program.as_ref()) }\n     }\n \n-    /// Add an argument to pass to the program.\n+    /// Adds an argument to pass to the program.\n     ///\n     /// Only one argument can be passed per use. So instead of:\n     ///\n@@ -487,7 +487,7 @@ impl Command {\n         self\n     }\n \n-    /// Add multiple arguments to pass to the program.\n+    /// Adds multiple arguments to pass to the program.\n     ///\n     /// To pass a single argument see [`arg`].\n     ///\n@@ -540,7 +540,7 @@ impl Command {\n         self\n     }\n \n-    /// Add or update multiple environment variable mappings.\n+    /// Adds or updates multiple environment variable mappings.\n     ///\n     /// # Examples\n     ///\n@@ -1287,7 +1287,7 @@ impl Child {\n     ///\n     /// let mut command = Command::new(\"ls\");\n     /// if let Ok(child) = command.spawn() {\n-    ///     println!(\"Child's id is {}\", child.id());\n+    ///     println!(\"Child's ID is {}\", child.id());\n     /// } else {\n     ///     println!(\"ls command didn't start\");\n     /// }\n@@ -1332,7 +1332,7 @@ impl Child {\n     ///\n     /// This function will not block the calling thread and will only\n     /// check to see if the child process has exited or not. If the child has\n-    /// exited then on Unix the process id is reaped. This function is\n+    /// exited then on Unix the process ID is reaped. This function is\n     /// guaranteed to repeatedly return a successful exit status so long as the\n     /// child has already exited.\n     ///\n@@ -1979,7 +1979,7 @@ mod tests {\n         }\n     }\n \n-    /// Test that process creation flags work by debugging a process.\n+    /// Tests that process creation flags work by debugging a process.\n     /// Other creation flags make it hard or impossible to detect\n     /// behavioral changes in the process.\n     #[test]"}, {"sha": "bc2e14d436a994cc388b536f9d00ebeb459511d3", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -159,7 +159,7 @@ impl fmt::Debug for BarrierWaitResult {\n }\n \n impl BarrierWaitResult {\n-    /// Returns whether this thread from [`wait`] is the \"leader thread\".\n+    /// Returns `true` if this thread from [`wait`] is the \"leader thread\".\n     ///\n     /// Only one thread will have `true` returned from their result, all other\n     /// threads will have `false` returned."}, {"sha": "036aff090ead992357d60fd4af7db161ddf7e237", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -17,7 +17,7 @@ use time::{Duration, Instant};\n pub struct WaitTimeoutResult(bool);\n \n impl WaitTimeoutResult {\n-    /// Returns whether the wait was known to have timed out.\n+    /// Returns `true` if the wait was known to have timed out.\n     ///\n     /// # Examples\n     ///"}, {"sha": "eaf09a16756b272348d956a21853ef8192c85ee9", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -50,14 +50,14 @@ impl SignalToken {\n         wake\n     }\n \n-    /// Convert to an unsafe usize value. Useful for storing in a pipe's state\n+    /// Converts to an unsafe usize value. Useful for storing in a pipe's state\n     /// flag.\n     #[inline]\n     pub unsafe fn cast_to_usize(self) -> usize {\n         mem::transmute(self.inner)\n     }\n \n-    /// Convert from an unsafe usize value. Useful for retrieving a pipe's state\n+    /// Converts from an unsafe usize value. Useful for retrieving a pipe's state\n     /// flag.\n     #[inline]\n     pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n@@ -72,7 +72,7 @@ impl WaitToken {\n         }\n     }\n \n-    /// Returns true if we wake up normally, false otherwise.\n+    /// Returns `true` if we wake up normally.\n     pub fn wait_max_until(self, end: Instant) -> bool {\n         while !self.inner.woken.load(Ordering::SeqCst) {\n             let now = Instant::now();"}, {"sha": "bfde50f79ff6342fbbbcb914d440db64cec06446", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -148,7 +148,7 @@ impl Select {\n     }\n \n     /// Waits for an event on this receiver set. The returned value is *not* an\n-    /// index, but rather an id. This id can be queried against any active\n+    /// index, but rather an ID. This ID can be queried against any active\n     /// `Handle` structures (each one has an `id` method). The handle with\n     /// the matching `id` will have some sort of event available on it. The\n     /// event could either be that data is available or the corresponding\n@@ -251,7 +251,7 @@ impl Select {\n }\n \n impl<'rx, T: Send> Handle<'rx, T> {\n-    /// Retrieves the id of this handle.\n+    /// Retrieves the ID of this handle.\n     #[inline]\n     pub fn id(&self) -> usize { self.id }\n "}, {"sha": "3da73ac0b822ea4c256b2ec1067e729c47cc2f5e", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1,4 +1,4 @@\n-/// Shared channels\n+/// Shared channels.\n ///\n /// This is the flavor of channels which are not necessarily optimized for any\n /// particular use case, but are the most general in how they are used. Shared"}, {"sha": "340dca7ce73b868523b8dec1e1a55c3a94e4c2af", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -335,7 +335,7 @@ impl<T: ?Sized> Mutex<T> {\n     /// Returns a mutable reference to the underlying data.\n     ///\n     /// Since this call borrows the `Mutex` mutably, no actual locking needs to\n-    /// take place---the mutable borrow statically guarantees no locks exist.\n+    /// take place -- the mutable borrow statically guarantees no locks exist.\n     ///\n     /// # Errors\n     ///"}, {"sha": "656389789d771827b6cd559d4f677ec77b14fa01", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -228,7 +228,7 @@ impl Once {\n     /// result in an immediate panic. If `f` panics, the `Once` will remain\n     /// in a poison state. If `f` does _not_ panic, the `Once` will no\n     /// longer be in a poison state and all future calls to `call_once` or\n-    /// `call_one_force` will no-op.\n+    /// `call_one_force` will be no-ops.\n     ///\n     /// The closure `f` is yielded a [`OnceState`] structure which can be used\n     /// to query the poison status of the `Once`.\n@@ -279,7 +279,7 @@ impl Once {\n         });\n     }\n \n-    /// Returns true if some `call_once` call has completed\n+    /// Returns `true` if some `call_once` call has completed\n     /// successfully. Specifically, `is_completed` will return false in\n     /// the following situations:\n     ///   * `call_once` was not called at all,\n@@ -465,7 +465,7 @@ impl<'a> Drop for Finish<'a> {\n }\n \n impl OnceState {\n-    /// Returns whether the associated [`Once`] was poisoned prior to the\n+    /// Returns `true` if the associated [`Once`] was poisoned prior to the\n     /// invocation of the closure passed to [`call_once_force`].\n     ///\n     /// [`call_once_force`]: struct.Once.html#method.call_once_force"}, {"sha": "730362e2ac86aaae122f0a0ff334da583c426b16", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -384,7 +384,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// Returns a mutable reference to the underlying data.\n     ///\n     /// Since this call borrows the `RwLock` mutably, no actual locking needs to\n-    /// take place---the mutable borrow statically guarantees no locks exist.\n+    /// take place -- the mutable borrow statically guarantees no locks exist.\n     ///\n     /// # Errors\n     ///"}, {"sha": "83d45b3547bc2e80ef04890f63f8ee6f06f1c0a3", "filename": "src/libstd/sys/cloudabi/abi/cloudabi.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -673,11 +673,11 @@ bitflags! {\n   /// Methods of synchronizing memory with physical storage.\n   #[repr(C)]\n   pub struct msflags: u8 {\n-    /// Perform asynchronous writes.\n+    /// Performs asynchronous writes.\n     const ASYNC      = 0x01;\n-    /// Invalidate cached data.\n+    /// Invalidates cached data.\n     const INVALIDATE = 0x02;\n-    /// Perform synchronous writes.\n+    /// Performs synchronous writes.\n     const SYNC       = 0x04;\n   }\n }\n@@ -1750,11 +1750,9 @@ fn tcb_layout_test_64() {\n \n /// Entry point for additionally created threads.\n ///\n-/// **tid**:\n-/// Thread ID of the current thread.\n+/// `tid`: thread ID of the current thread.\n ///\n-/// **aux**:\n-/// Copy of the value stored in\n+/// `aux`: copy of the value stored in\n /// [`threadattr.argument`](struct.threadattr.html#structfield.argument).\n pub type threadentry = unsafe extern \"C\" fn(\n   tid: tid,\n@@ -2590,7 +2588,7 @@ pub unsafe fn mem_map(addr_: *mut (), len_: usize, prot_: mprot, flags_: mflags,\n   cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_)\n }\n \n-/// Change the protection of a memory mapping.\n+/// Changes the protection of a memory mapping.\n ///\n /// ## Parameters\n ///\n@@ -2604,7 +2602,7 @@ pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n   cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_)\n }\n \n-/// Synchronize a region of memory with its physical storage.\n+/// Synchronizes a region of memory with its physical storage.\n ///\n /// ## Parameters\n ///"}, {"sha": "0a56f4fad6d15ee69b5bedb31a46912862c7f28b", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1,4 +1,4 @@\n-//! Platform-dependent platform abstraction\n+//! Platform-dependent platform abstraction.\n //!\n //! The `std::sys` module is the abstracted interface through which\n //! `std` talks to the underlying operating system. It has different"}, {"sha": "8b81273f201cfe16ab85ac80d6e0723e8305a37e", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -117,7 +117,7 @@ pub trait OpenOptionsExt {\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n \n-    /// Pass custom flags to the `flags` argument of `open`.\n+    /// Passes custom flags to the `flags` argument of `open`.\n     ///\n     /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n     /// ensure they do not interfere with the access mode set by Rusts options."}, {"sha": "7411b8e068f643a9934b00699c44441c55a7ae73", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -60,7 +60,7 @@ impl SocketAddr {\n         None\n     }\n \n-    /// Returns true if and only if the address is unnamed.\n+    /// Returns `true` if the address is unnamed.\n     ///\n     /// # Examples\n     ///\n@@ -374,7 +374,7 @@ impl UnixStream {\n     /// ```\n     ///\n     /// # Platform specific\n-    /// On Redox this always returns None.\n+    /// On Redox this always returns `None`.\n     #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n@@ -635,7 +635,7 @@ impl UnixListener {\n     /// ```\n     ///\n     /// # Platform specific\n-    /// On Redox this always returns None.\n+    /// On Redox this always returns `None`.\n     #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)"}, {"sha": "1dcc1169510f3f4613025fe3a51b0c388e307e4c", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -13,13 +13,13 @@ use sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n /// [`process::Command`]: ../../../../std/process/struct.Command.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CommandExt {\n-    /// Sets the child process's user id. This translates to a\n+    /// Sets the child process's user ID. This translates to a\n     /// `setuid` call in the child process. Failure in the `setuid`\n     /// call will cause the spawn to fail.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn uid(&mut self, id: u32) -> &mut process::Command;\n \n-    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// Similar to `uid`, but sets the group ID of the child process. This has\n     /// the same semantics as the `uid` field.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gid(&mut self, id: u32) -> &mut process::Command;"}, {"sha": "bf39cc485911b720ebd254a2a15b4395aa644e5c", "filename": "src/libstd/sys/redox/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -50,7 +50,7 @@ pub struct Mutex {\n }\n \n impl Mutex {\n-    /// Create a new mutex.\n+    /// Creates a new mutex.\n     pub const fn new() -> Self {\n         Mutex {\n             lock: UnsafeCell::new(0),"}, {"sha": "9e23c537f22d4da28d88909c416b431ac00862c8", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -561,7 +561,7 @@ impl ExitCode {\n     }\n }\n \n-/// The unique id of the process (this should never be negative).\n+/// The unique ID of the process (this should never be negative).\n pub struct Process {\n     pid: usize,\n     status: Option<ExitStatus>,"}, {"sha": "b9abb48a8d3680b5dc6ffde2a4a9c29c3146a3de", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -25,7 +25,7 @@ pub unsafe fn brk(addr: usize) -> Result<usize> {\n     syscall1(SYS_BRK, addr)\n }\n \n-/// Change the process's working directory\n+/// Changes the process's working directory.\n ///\n /// This function will attempt to set the process's working directory to `path`, which can be\n /// either a relative, scheme relative, or absolute path.\n@@ -47,90 +47,90 @@ pub fn chmod<T: AsRef<[u8]>>(path: T, mode: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_CHMOD, path.as_ref().as_ptr() as usize, path.as_ref().len(), mode) }\n }\n \n-/// Produce a fork of the current process, or a new process thread\n+/// Produces a fork of the current process, or a new process thread.\n pub unsafe fn clone(flags: usize) -> Result<usize> {\n     syscall1_clobber(SYS_CLONE, flags)\n }\n \n-/// Close a file\n+/// Closes a file.\n pub fn close(fd: usize) -> Result<usize> {\n     unsafe { syscall1(SYS_CLOSE, fd) }\n }\n \n-/// Get the current system time\n+/// Gets the current system time.\n pub fn clock_gettime(clock: usize, tp: &mut TimeSpec) -> Result<usize> {\n     unsafe { syscall2(SYS_CLOCK_GETTIME, clock, tp as *mut TimeSpec as usize) }\n }\n \n-/// Copy and transform a file descriptor\n+/// Copies and transforms a file descriptor.\n pub fn dup(fd: usize, buf: &[u8]) -> Result<usize> {\n     unsafe { syscall3(SYS_DUP, fd, buf.as_ptr() as usize, buf.len()) }\n }\n \n-/// Copy and transform a file descriptor\n+/// Copies and transforms a file descriptor.\n pub fn dup2(fd: usize, newfd: usize, buf: &[u8]) -> Result<usize> {\n     unsafe { syscall4(SYS_DUP2, fd, newfd, buf.as_ptr() as usize, buf.len()) }\n }\n \n-/// Exit the current process\n+/// Exits the current process.\n pub fn exit(status: usize) -> Result<usize> {\n     unsafe { syscall1(SYS_EXIT, status) }\n }\n \n-/// Change file permissions\n+/// Changes file permissions.\n pub fn fchmod(fd: usize, mode: u16) -> Result<usize> {\n     unsafe { syscall2(SYS_FCHMOD, fd, mode as usize) }\n \n }\n \n-/// Change file ownership\n+/// Changes file ownership.\n pub fn fchown(fd: usize, uid: u32, gid: u32) -> Result<usize> {\n     unsafe { syscall3(SYS_FCHOWN, fd, uid as usize, gid as usize) }\n \n }\n \n-/// Change file descriptor flags\n+/// Changes file descriptor flags.\n pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_FCNTL, fd, cmd, arg) }\n }\n \n-/// Replace the current process with a new executable\n+/// Replaces the current process with a new executable.\n pub fn fexec(fd: usize, args: &[[usize; 2]], vars: &[[usize; 2]]) -> Result<usize> {\n     unsafe { syscall5(SYS_FEXEC, fd, args.as_ptr() as usize, args.len(),\n                       vars.as_ptr() as usize, vars.len()) }\n }\n \n-/// Map a file into memory\n+/// Maps a file into memory.\n pub unsafe fn fmap(fd: usize, offset: usize, size: usize) -> Result<usize> {\n     syscall3(SYS_FMAP, fd, offset, size)\n }\n \n-/// Unmap a memory-mapped file\n+/// Unmaps a memory-mapped file.\n pub unsafe fn funmap(addr: usize) -> Result<usize> {\n     syscall1(SYS_FUNMAP, addr)\n }\n \n-/// Retrieve the canonical path of a file\n+/// Retrieves the canonical path of a file.\n pub fn fpath(fd: usize, buf: &mut [u8]) -> Result<usize> {\n     unsafe { syscall3(SYS_FPATH, fd, buf.as_mut_ptr() as usize, buf.len()) }\n }\n \n-/// Rename a file\n+/// Renames a file.\n pub fn frename<T: AsRef<[u8]>>(fd: usize, path: T) -> Result<usize> {\n     unsafe { syscall3(SYS_FRENAME, fd, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n }\n \n-/// Get metadata about a file\n+/// Gets metadata about a file.\n pub fn fstat(fd: usize, stat: &mut Stat) -> Result<usize> {\n     unsafe { syscall3(SYS_FSTAT, fd, stat as *mut Stat as usize, mem::size_of::<Stat>()) }\n }\n \n-/// Get metadata about a filesystem\n+/// Gets metadata about a filesystem.\n pub fn fstatvfs(fd: usize, stat: &mut StatVfs) -> Result<usize> {\n     unsafe { syscall3(SYS_FSTATVFS, fd, stat as *mut StatVfs as usize, mem::size_of::<StatVfs>()) }\n }\n \n-/// Sync a file descriptor to its underlying medium\n+/// Syncs a file descriptor to its underlying medium.\n pub fn fsync(fd: usize) -> Result<usize> {\n     unsafe { syscall1(SYS_FSYNC, fd) }\n }\n@@ -152,113 +152,113 @@ pub unsafe fn futex(addr: *mut i32, op: usize, val: i32, val2: usize, addr2: *mu\n     syscall5(SYS_FUTEX, addr as usize, op, (val as isize) as usize, val2, addr2 as usize)\n }\n \n-/// Get the current working directory\n+/// Gets the current working directory.\n pub fn getcwd(buf: &mut [u8]) -> Result<usize> {\n     unsafe { syscall2(SYS_GETCWD, buf.as_mut_ptr() as usize, buf.len()) }\n }\n \n-/// Get the effective group ID\n+/// Gets the effective group ID.\n pub fn getegid() -> Result<usize> {\n     unsafe { syscall0(SYS_GETEGID) }\n }\n \n-/// Get the effective namespace\n+/// Gets the effective namespace.\n pub fn getens() -> Result<usize> {\n     unsafe { syscall0(SYS_GETENS) }\n }\n \n-/// Get the effective user ID\n+/// Gets the effective user ID.\n pub fn geteuid() -> Result<usize> {\n     unsafe { syscall0(SYS_GETEUID) }\n }\n \n-/// Get the current group ID\n+/// Gets the current group ID.\n pub fn getgid() -> Result<usize> {\n     unsafe { syscall0(SYS_GETGID) }\n }\n \n-/// Get the current namespace\n+/// Gets the current namespace.\n pub fn getns() -> Result<usize> {\n     unsafe { syscall0(SYS_GETNS) }\n }\n \n-/// Get the current process ID\n+/// Gets the current process ID.\n pub fn getpid() -> Result<usize> {\n     unsafe { syscall0(SYS_GETPID) }\n }\n \n-/// Get the process group ID\n+/// Gets the process group ID.\n pub fn getpgid(pid: usize) -> Result<usize> {\n     unsafe { syscall1(SYS_GETPGID, pid) }\n }\n \n-/// Get the parent process ID\n+/// Gets the parent process ID.\n pub fn getppid() -> Result<usize> {\n     unsafe { syscall0(SYS_GETPPID) }\n }\n \n-/// Get the current user ID\n+/// Gets the current user ID.\n pub fn getuid() -> Result<usize> {\n     unsafe { syscall0(SYS_GETUID) }\n }\n \n-/// Set the I/O privilege level\n+/// Sets the I/O privilege level\n pub unsafe fn iopl(level: usize) -> Result<usize> {\n     syscall1(SYS_IOPL, level)\n }\n \n-/// Send a signal `sig` to the process identified by `pid`\n+/// Sends a signal `sig` to the process identified by `pid`.\n pub fn kill(pid: usize, sig: usize) -> Result<usize> {\n     unsafe { syscall2(SYS_KILL, pid, sig) }\n }\n \n-/// Create a link to a file\n+/// Creates a link to a file.\n pub unsafe fn link(old: *const u8, new: *const u8) -> Result<usize> {\n     syscall2(SYS_LINK, old as usize, new as usize)\n }\n \n-/// Seek to `offset` bytes in a file descriptor\n+/// Seeks to `offset` bytes in a file descriptor.\n pub fn lseek(fd: usize, offset: isize, whence: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_LSEEK, fd, offset as usize, whence) }\n }\n \n-/// Make a new scheme namespace\n+/// Makes a new scheme namespace.\n pub fn mkns(schemes: &[[usize; 2]]) -> Result<usize> {\n     unsafe { syscall2(SYS_MKNS, schemes.as_ptr() as usize, schemes.len()) }\n }\n \n-/// Sleep for the time specified in `req`\n+/// Sleeps for the time specified in `req`.\n pub fn nanosleep(req: &TimeSpec, rem: &mut TimeSpec) -> Result<usize> {\n     unsafe { syscall2(SYS_NANOSLEEP, req as *const TimeSpec as usize,\n                                      rem as *mut TimeSpec as usize) }\n }\n \n-/// Open a file\n+/// Opens a file.\n pub fn open<T: AsRef<[u8]>>(path: T, flags: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_OPEN, path.as_ref().as_ptr() as usize, path.as_ref().len(), flags) }\n }\n \n-/// Allocate pages, linearly in physical memory\n+/// Allocates pages, linearly in physical memory.\n pub unsafe fn physalloc(size: usize) -> Result<usize> {\n     syscall1(SYS_PHYSALLOC, size)\n }\n \n-/// Free physically allocated pages\n+/// Frees physically allocated pages.\n pub unsafe fn physfree(physical_address: usize, size: usize) -> Result<usize> {\n     syscall2(SYS_PHYSFREE, physical_address, size)\n }\n \n-/// Map physical memory to virtual memory\n+/// Maps physical memory to virtual memory.\n pub unsafe fn physmap(physical_address: usize, size: usize, flags: usize) -> Result<usize> {\n     syscall3(SYS_PHYSMAP, physical_address, size, flags)\n }\n \n-/// Unmap previously mapped physical memory\n+/// Unmaps previously mapped physical memory.\n pub unsafe fn physunmap(virtual_address: usize) -> Result<usize> {\n     syscall1(SYS_PHYSUNMAP, virtual_address)\n }\n \n-/// Create a pair of file descriptors referencing the read and write ends of a pipe\n+/// Creates a pair of file descriptors referencing the read and write ends of a pipe.\n pub fn pipe2(fds: &mut [usize; 2], flags: usize) -> Result<usize> {\n     unsafe { syscall2(SYS_PIPE2, fds.as_ptr() as usize, flags) }\n }\n@@ -268,32 +268,32 @@ pub fn read(fd: usize, buf: &mut [u8]) -> Result<usize> {\n     unsafe { syscall3(SYS_READ, fd, buf.as_mut_ptr() as usize, buf.len()) }\n }\n \n-/// Remove a directory\n+/// Removes a directory.\n pub fn rmdir<T: AsRef<[u8]>>(path: T) -> Result<usize> {\n     unsafe { syscall2(SYS_RMDIR, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n }\n \n-/// Set the process group ID\n+/// Sets the process group ID.\n pub fn setpgid(pid: usize, pgid: usize) -> Result<usize> {\n     unsafe { syscall2(SYS_SETPGID, pid, pgid) }\n }\n \n-/// Set the current process group IDs\n+/// Sets the current process group IDs.\n pub fn setregid(rgid: usize, egid: usize) -> Result<usize> {\n     unsafe { syscall2(SYS_SETREGID, rgid, egid) }\n }\n \n-/// Make a new scheme namespace\n+/// Makes a new scheme namespace.\n pub fn setrens(rns: usize, ens: usize) -> Result<usize> {\n     unsafe { syscall2(SYS_SETRENS, rns, ens) }\n }\n \n-/// Set the current process user IDs\n+/// Sets the current process user IDs.\n pub fn setreuid(ruid: usize, euid: usize) -> Result<usize> {\n     unsafe { syscall2(SYS_SETREUID, ruid, euid) }\n }\n \n-/// Set up a signal handler\n+/// Sets up a signal handler.\n pub fn sigaction(sig: usize, act: Option<&SigAction>, oldact: Option<&mut SigAction>)\n -> Result<usize> {\n     unsafe { syscall4(SYS_SIGACTION, sig,\n@@ -302,27 +302,27 @@ pub fn sigaction(sig: usize, act: Option<&SigAction>, oldact: Option<&mut SigAct\n                       restorer as usize) }\n }\n \n-// Return from signal handler\n+/// Returns from signal handler.\n pub fn sigreturn() -> Result<usize> {\n     unsafe { syscall0(SYS_SIGRETURN) }\n }\n \n-/// Remove a file\n+/// Removes a file.\n pub fn unlink<T: AsRef<[u8]>>(path: T) -> Result<usize> {\n     unsafe { syscall2(SYS_UNLINK, path.as_ref().as_ptr() as usize, path.as_ref().len()) }\n }\n \n-/// Convert a virtual address to a physical one\n+/// Converts a virtual address to a physical one.\n pub unsafe fn virttophys(virtual_address: usize) -> Result<usize> {\n     syscall1(SYS_VIRTTOPHYS, virtual_address)\n }\n \n-/// Check if a child process has exited or received a signal\n+/// Checks if a child process has exited or received a signal.\n pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_WAITPID, pid, status as *mut usize as usize, options) }\n }\n \n-/// Write a buffer to a file descriptor\n+/// Writes a buffer to a file descriptor.\n ///\n /// The kernel will attempt to write the bytes in `buf` to the file descriptor `fd`, returning\n /// either an `Err`, explained below, or `Ok(count)` where `count` is the number of bytes which\n@@ -340,7 +340,7 @@ pub fn write(fd: usize, buf: &[u8]) -> Result<usize> {\n     unsafe { syscall3(SYS_WRITE, fd, buf.as_ptr() as usize, buf.len()) }\n }\n \n-/// Yield the process's time slice to the kernel\n+/// Yields the process's time slice to the kernel.\n ///\n /// This function will return Ok(0) on success\n pub fn sched_yield() -> Result<usize> {"}, {"sha": "5820f1ad03a314bbacd2614688f3b483c6f1d0a9", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -107,42 +107,42 @@ pub const WNOHANG: usize =    0x01;\n pub const WUNTRACED: usize =  0x02;\n pub const WCONTINUED: usize = 0x08;\n \n-/// True if status indicates the child is stopped.\n+/// Returns `true` if status indicates the child is stopped.\n pub fn wifstopped(status: usize) -> bool {\n     (status & 0xff) == 0x7f\n }\n \n-/// If wifstopped(status), the signal that stopped the child.\n+/// If wifstopped(status), returns the signal that stopped the child.\n pub fn wstopsig(status: usize) -> usize {\n     (status >> 8) & 0xff\n }\n \n-/// True if status indicates the child continued after a stop.\n+/// Returns `true` if status indicates the child continued after a stop.\n pub fn wifcontinued(status: usize) -> bool {\n     status == 0xffff\n }\n \n-/// True if STATUS indicates termination by a signal.\n+/// Returns `true` if status indicates termination by a signal.\n pub fn wifsignaled(status: usize) -> bool {\n     ((status & 0x7f) + 1) as i8 >= 2\n }\n \n-/// If wifsignaled(status), the terminating signal.\n+/// If wifsignaled(status), returns the terminating signal.\n pub fn wtermsig(status: usize) -> usize {\n     status & 0x7f\n }\n \n-/// True if status indicates normal termination.\n+/// Returns `true` if status indicates normal termination.\n pub fn wifexited(status: usize) -> bool {\n     wtermsig(status) == 0\n }\n \n-/// If wifexited(status), the exit status.\n+/// If wifexited(status), returns the exit status.\n pub fn wexitstatus(status: usize) -> usize {\n     (status >> 8) & 0xff\n }\n \n-/// True if status indicates a core dump was created.\n+/// Returns `true` if status indicates a core dump was created.\n pub fn wcoredump(status: usize) -> bool {\n     (status & 0x80) != 0\n }"}, {"sha": "86fe09d003520c5477152a3eddc2605a655cc5d7", "filename": "src/libstd/sys/sgx/abi/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fthread.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1,6 +1,6 @@\n use fortanix_sgx_abi::Tcs;\n \n-/// Get the ID for the current thread. The ID is guaranteed to be unique among\n+/// Gets the ID for the current thread. The ID is guaranteed to be unique among\n /// all currently running threads in the enclave, and it is guaranteed to be\n /// constant for the lifetime of the thread. More specifically for SGX, there\n /// is a one-to-one correspondence of the ID to the address of the TCS."}, {"sha": "e1fc36968452766d4e237d1f49d70c04b4ddd150", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -182,7 +182,7 @@ mod sync_bitset {\n             self.0[hi].fetch_and(!lo, Ordering::Relaxed);\n         }\n \n-        /// Set any unset bit. Not atomic. Returns `None` if all bits were\n+        /// Sets any unset bit. Not atomic. Returns `None` if all bits were\n         /// observed to be set.\n         pub fn set(&self) -> Option<usize> {\n             'elems: for (idx, elem) in self.0.iter().enumerate() {"}, {"sha": "0ccbbbc65015d0c1fa01e0e12baef64580458bc0", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -63,44 +63,49 @@ pub unsafe trait UserSafe {\n \n     /// Construct a pointer to `Self` given a memory range in user space.\n     ///\n-    /// NB. This takes a size, not a length!\n+    /// N.B., this takes a size, not a length!\n     ///\n     /// # Safety\n+    ///\n     /// The caller must ensure the memory range is in user memory, is the\n     /// correct size and is correctly aligned and points to the right type.\n     unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self;\n \n     /// Construct a pointer to `Self` given a memory range.\n     ///\n-    /// NB. This takes a size, not a length!\n+    /// N.B., this takes a size, not a length!\n     ///\n     /// # Safety\n+    ///\n     /// The caller must ensure the memory range points to the correct type.\n     ///\n     /// # Panics\n+    ///\n     /// This function panics if:\n     ///\n-    /// * The pointer is not aligned\n-    /// * The pointer is null\n-    /// * The pointed-to range is not in user memory\n+    /// * the pointer is not aligned.\n+    /// * the pointer is null.\n+    /// * the pointed-to range is not in user memory.\n     unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n         let ret = Self::from_raw_sized_unchecked(ptr, size);\n         Self::check_ptr(ret);\n         NonNull::new_unchecked(ret as _)\n     }\n \n-    /// Check if a pointer may point to Self in user memory.\n+    /// Checks if a pointer may point to `Self` in user memory.\n     ///\n     /// # Safety\n+    ///\n     /// The caller must ensure the memory range points to the correct type and\n     /// length (if this is a slice).\n     ///\n     /// # Panics\n+    ///\n     /// This function panics if:\n     ///\n-    /// * The pointer is not aligned\n-    /// * The pointer is null\n-    /// * The pointed-to range is not in user memory\n+    /// * the pointer is not aligned.\n+    /// * the pointer is null.\n+    /// * the pointed-to range is not in user memory.\n     unsafe fn check_ptr(ptr: *const Self) {\n         let is_aligned = |p| -> bool {\n             0 == (p as usize) & (Self::align_of() - 1)\n@@ -188,7 +193,7 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n         }\n     }\n \n-    /// Copy `val` into freshly allocated space in user memory.\n+    /// Copies `val` into freshly allocated space in user memory.\n     pub fn new_from_enclave(val: &T) -> Self {\n         unsafe {\n             let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n@@ -201,7 +206,7 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n         }\n     }\n \n-    /// Create an owned `User<T>` from a raw pointer.\n+    /// Creates an owned `User<T>` from a raw pointer.\n     ///\n     /// # Safety\n     /// The caller must ensure `ptr` points to `T`, is freeable with the `free`\n@@ -218,7 +223,7 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n         User(NonNull::new_userref(ptr))\n     }\n \n-    /// Convert this value into a raw pointer. The value will no longer be\n+    /// Converts this value into a raw pointer. The value will no longer be\n     /// automatically freed.\n     pub fn into_raw(self) -> *mut T {\n         let ret = self.0;\n@@ -242,7 +247,7 @@ impl<T> User<[T]> where [T]: UserSafe {\n         Self::new_uninit_bytes(n * mem::size_of::<T>())\n     }\n \n-    /// Create an owned `User<[T]>` from a raw thin pointer and a slice length.\n+    /// Creates an owned `User<[T]>` from a raw thin pointer and a slice length.\n     ///\n     /// # Safety\n     /// The caller must ensure `ptr` points to `len` elements of `T`, is\n@@ -262,7 +267,7 @@ impl<T> User<[T]> where [T]: UserSafe {\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T> where T: UserSafe {\n-    /// Create a `&UserRef<[T]>` from a raw pointer.\n+    /// Creates a `&UserRef<[T]>` from a raw pointer.\n     ///\n     /// # Safety\n     /// The caller must ensure `ptr` points to `T`.\n@@ -278,7 +283,7 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         &*(ptr as *const Self)\n     }\n \n-    /// Create a `&mut UserRef<[T]>` from a raw pointer. See the struct\n+    /// Creates a `&mut UserRef<[T]>` from a raw pointer. See the struct\n     /// documentation for the nuances regarding a `&mut UserRef<T>`.\n     ///\n     /// # Safety\n@@ -295,7 +300,7 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         &mut*(ptr as *mut Self)\n     }\n \n-    /// Copy `val` into user memory.\n+    /// Copies `val` into user memory.\n     ///\n     /// # Panics\n     /// This function panics if the destination doesn't have the same size as\n@@ -311,7 +316,7 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         }\n     }\n \n-    /// Copy the value from user memory and place it into `dest`.\n+    /// Copies the value from user memory and place it into `dest`.\n     ///\n     /// # Panics\n     /// This function panics if the destination doesn't have the same size as\n@@ -340,15 +345,15 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> UserRef<T> where T: UserSafe {\n-    /// Copy the value from user memory into enclave memory.\n+    /// Copies the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n         unsafe { ptr::read(self.0.get()) }\n     }\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> UserRef<[T]> where [T]: UserSafe {\n-    /// Create a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n+    /// Creates a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n     ///\n     /// # Safety\n     /// The caller must ensure `ptr` points to `n` elements of `T`.\n@@ -363,7 +368,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n     }\n \n-    /// Create a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n+    /// Creates a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n     /// See the struct documentation for the nuances regarding a\n     /// `&mut UserRef<T>`.\n     ///\n@@ -395,7 +400,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         unsafe { (*self.0.get()).len() }\n     }\n \n-    /// Copy the value from user memory and place it into `dest`. Afterwards,\n+    /// Copies the value from user memory and place it into `dest`. Afterwards,\n     /// `dest` will contain exactly `self.len()` elements.\n     ///\n     /// # Panics\n@@ -411,7 +416,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         }\n     }\n \n-    /// Copy the value from user memory into a vector in enclave memory.\n+    /// Copies the value from user memory into a vector in enclave memory.\n     pub fn to_enclave(&self) -> Vec<T> {\n         let mut ret = Vec::with_capacity(self.len());\n         self.copy_to_enclave_vec(&mut ret);\n@@ -526,7 +531,7 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I:\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl UserRef<super::raw::ByteBuffer> {\n-    /// Copy the user memory range pointed to by the user `ByteBuffer` to\n+    /// Copies the user memory range pointed to by the user `ByteBuffer` to\n     /// enclave memory.\n     ///\n     /// # Panics"}, {"sha": "004cf57602bc2118b7bb52dd963badc6e82881ce", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -12,14 +12,16 @@ extern \"C\" {\n     fn usercall(nr: u64, p1: u64, p2: u64, _ignore: u64, p3: u64, p4: u64) -> UsercallReturn;\n }\n \n-/// Perform the raw usercall operation as defined in the ABI calling convention.\n+/// Performs the raw usercall operation as defined in the ABI calling convention.\n ///\n /// # Safety\n+///\n /// The caller must ensure to pass parameters appropriate for the usercall `nr`\n /// and to observe all requirements specified in the ABI.\n ///\n /// # Panics\n-/// Panics if `nr` is 0.\n+///\n+/// Panics if `nr` is `0`.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n     if nr==0 { panic!(\"Invalid usercall number {}\",nr) }"}, {"sha": "aec643b3175b40f2bfb20de7f9a4a4fde998bcca", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -3,7 +3,7 @@\n /// This queue is used to implement condition variable and mutexes.\n ///\n /// Users of this API are expected to use the `WaitVariable<T>` type. Since\n-/// that type is not `Sync`, it needs to be protected by e.g. a `SpinMutex` to\n+/// that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n /// allow shared access.\n ///\n /// Since userspace may send spurious wake-ups, the wakeup event state is\n@@ -136,7 +136,7 @@ impl WaitQueue {\n         self.inner.is_empty()\n     }\n \n-    /// Add the calling thread to the WaitVariable's wait queue, then wait\n+    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n     /// until a wakeup event.\n     ///\n     /// This function does not return until this thread has been awoken."}, {"sha": "abcce3ab829625898bd813abee17f654914062d8", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -684,7 +684,7 @@ impl MetadataExt for fs::Metadata {\n /// [`FileType`]: ../../../../std/fs/struct.FileType.html\n #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n pub trait FileTypeExt {\n-    /// Returns whether this file type is a block device.\n+    /// Returns `true` if this file type is a block device.\n     ///\n     /// # Examples\n     ///\n@@ -702,7 +702,7 @@ pub trait FileTypeExt {\n     /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_block_device(&self) -> bool;\n-    /// Returns whether this file type is a char device.\n+    /// Returns `true` if this file type is a char device.\n     ///\n     /// # Examples\n     ///\n@@ -720,7 +720,7 @@ pub trait FileTypeExt {\n     /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_char_device(&self) -> bool;\n-    /// Returns whether this file type is a fifo.\n+    /// Returns `true` if this file type is a fifo.\n     ///\n     /// # Examples\n     ///\n@@ -738,7 +738,7 @@ pub trait FileTypeExt {\n     /// ```\n     #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n     fn is_fifo(&self) -> bool;\n-    /// Returns whether this file type is a socket.\n+    /// Returns `true` if this file type is a socket.\n     ///\n     /// # Examples\n     ///"}, {"sha": "acc064acfcd29992c943eea8fe8a91de9cee9e76", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -134,7 +134,7 @@ impl SocketAddr {\n         })\n     }\n \n-    /// Returns true if and only if the address is unnamed.\n+    /// Returns `true` if the address is unnamed.\n     ///\n     /// # Examples\n     ///\n@@ -516,7 +516,7 @@ impl UnixStream {\n     /// ```\n     ///\n     /// # Platform specific\n-    /// On Redox this always returns None.\n+    /// On Redox this always returns `None`.\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -841,7 +841,7 @@ impl UnixListener {\n     /// ```\n     ///\n     /// # Platform specific\n-    /// On Redox this always returns None.\n+    /// On Redox this always returns `None`.\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -1047,7 +1047,7 @@ impl UnixDatagram {\n         Ok(UnixDatagram(inner))\n     }\n \n-    /// Create an unnamed pair of connected sockets.\n+    /// Creates an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixDatagrams`s which are connected to each other.\n     ///"}, {"sha": "2c5943fdac348e4fe697c0b5db2ffbf767709990", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -13,13 +13,13 @@ use sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n /// [`process::Command`]: ../../../../std/process/struct.Command.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CommandExt {\n-    /// Sets the child process's user id. This translates to a\n+    /// Sets the child process's user ID. This translates to a\n     /// `setuid` call in the child process. Failure in the `setuid`\n     /// call will cause the spawn to fail.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn uid(&mut self, id: u32) -> &mut process::Command;\n \n-    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// Similar to `uid`, but sets the group ID of the child process. This has\n     /// the same semantics as the `uid` field.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gid(&mut self, id: u32) -> &mut process::Command;"}, {"sha": "12d3e9b13b1156120f73b5f983c330f97c17dd77", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -383,7 +383,7 @@ impl Command {\n // Processes\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// The unique id of the process (this should never be negative).\n+/// The unique ID of the process (this should never be negative).\n pub struct Process {\n     pid: pid_t,\n     status: Option<ExitStatus>,"}, {"sha": "89038da6295f2e5371be2801de1e3c5889b76fe1", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -441,10 +441,10 @@ impl MetadataExt for Metadata {\n /// [`FileType`]: ../../../../std/fs/struct.FileType.html\n #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n pub trait FileTypeExt {\n-    /// Returns whether this file type is a symbolic link that is also a directory.\n+    /// Returns `true` if this file type is a symbolic link that is also a directory.\n     #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n     fn is_symlink_dir(&self) -> bool;\n-    /// Returns whether this file type is a symbolic link that is also a file.\n+    /// Returns `true` if this file type is a symbolic link that is also a file.\n     #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n     fn is_symlink_file(&self) -> bool;\n }"}, {"sha": "fbe0426ce5a8cb33bff80d400a7c68e24c645ee7", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -16,7 +16,7 @@ pub type RawHandle = raw::HANDLE;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type RawSocket = raw::SOCKET;\n \n-/// Extract raw handles.\n+/// Extracts raw handles.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRawHandle {\n     /// Extracts the raw handle, without taking any ownership.\n@@ -98,15 +98,15 @@ impl IntoRawHandle for fs::File {\n     }\n }\n \n-/// Extract raw sockets.\n+/// Extracts raw sockets.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRawSocket {\n     /// Extracts the underlying raw socket from this object.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_raw_socket(&self) -> RawSocket;\n }\n \n-/// Create I/O objects from raw sockets.\n+/// Creates I/O objects from raw sockets.\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n pub trait FromRawSocket {\n     /// Creates a new I/O object from the given raw socket."}, {"sha": "7399dd41a41cf3c552573188a7bca40d9b54f331", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -1,4 +1,4 @@\n-//! Implementation of `std::os` functionality for Windows\n+//! Implementation of `std::os` functionality for Windows.\n \n #![allow(nonstandard_style)]\n "}, {"sha": "d3b102268f6320fc05e413b092bcfb3d05bb303d", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -282,7 +282,7 @@ impl<'a> AsyncPipe<'a> {\n     /// Takes a parameter `wait` which indicates if this pipe is currently being\n     /// read whether the function should block waiting for the read to complete.\n     ///\n-    /// Return values:\n+    /// Returns values:\n     ///\n     /// * `true` - finished any pending read and the pipe is not at EOF (keep\n     ///            going)"}, {"sha": "347244b0e0d440309732c5b3b6137bbc11e1e6ee", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -171,7 +171,7 @@ pub fn log_enabled() -> Option<PrintFormat> {\n     val\n }\n \n-/// Print the symbol of the backtrace frame.\n+/// Prints the symbol of the backtrace frame.\n ///\n /// These output functions should now be used everywhere to ensure consistency.\n /// You may want to also use `output_fileline`.\n@@ -203,7 +203,7 @@ fn output(w: &mut dyn Write, idx: usize, frame: Frame,\n     w.write_all(b\"\\n\")\n }\n \n-/// Print the filename and line number of the backtrace frame.\n+/// Prints the filename and line number of the backtrace frame.\n ///\n /// See also `output`.\n #[allow(dead_code)]"}, {"sha": "6d4594fe295ca07b1af2c64a83b6640c6b8b6bf8", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -34,7 +34,7 @@ const UTF8_REPLACEMENT_CHARACTER: &str = \"\\u{FFFD}\";\n \n /// A Unicode code point: from U+0000 to U+10FFFF.\n ///\n-/// Compare with the `char` type,\n+/// Compares with the `char` type,\n /// which represents a Unicode scalar value:\n /// a code point that is not a surrogate (U+D800 to U+DFFF).\n #[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]\n@@ -366,7 +366,7 @@ impl Wtf8Buf {\n     }\n }\n \n-/// Create a new WTF-8 string from an iterator of code points.\n+/// Creates a new WTF-8 string from an iterator of code points.\n ///\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n@@ -664,7 +664,7 @@ impl Wtf8 {\n }\n \n \n-/// Return a slice of the given string for the byte range [`begin`..`end`).\n+/// Returns a slice of the given string for the byte range [`begin`..`end`).\n ///\n /// # Panics\n ///\n@@ -686,7 +686,7 @@ impl ops::Index<ops::Range<usize>> for Wtf8 {\n     }\n }\n \n-/// Return a slice of the given string from byte `begin` to its end.\n+/// Returns a slice of the given string from byte `begin` to its end.\n ///\n /// # Panics\n ///\n@@ -706,7 +706,7 @@ impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     }\n }\n \n-/// Return a slice of the given string from its beginning to byte `end`.\n+/// Returns a slice of the given string from its beginning to byte `end`.\n ///\n /// # Panics\n ///"}, {"sha": "e753a74b925310e5870d4c94db5c66fb65ec9f99", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ed06eb8864e704c4a1871ccda4648273bee4ef/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=99ed06eb8864e704c4a1871ccda4648273bee4ef", "patch": "@@ -328,7 +328,7 @@ pub fn test_main_static(tests: &[&TestDescAndFn]) {\n }\n \n /// Invoked when unit tests terminate. Should panic if the unit\n-/// test is considered a failure. By default, invokes `report()`\n+/// Tests is considered a failure. By default, invokes `report()`\n /// and checks for a `0` result.\n pub fn assert_test_result<T: Termination>(result: T) {\n     let code = result.report();"}]}