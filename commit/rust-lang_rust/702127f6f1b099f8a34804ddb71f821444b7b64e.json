{"sha": "702127f6f1b099f8a34804ddb71f821444b7b64e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMjEyN2Y2ZjFiMDk5ZjhhMzQ4MDRkZGI3MWY4MjE0NDRiN2I2NGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-26T17:44:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-27T00:49:36Z"}, "message": "rollup merge of #19296: csouth3/trieset-union\n\nTrieSet doesn't yet have union, intersection, difference, and symmetric difference functions implemented.  Luckily, TrieSet is largely similar to TreeSet, so I was able to reference the implementations of these functions in the latter, and adapt them as necessary to make them work for TrieSet.\n\nOne thing that I thought was interesting is that the Iterator yielded by `iter()` for TrieSet iterates over the set's values directly rather than references to the values (whereas I think in most cases I see the Iterator given by `iter()` iterating over immutable references), so for consistency within TrieSet's interface, all of these Iterators also iterate over the values directly.  Let me know if all of these should be instead iterating over references.", "tree": {"sha": "b68fb1546ea86614e422c695ccd6c5308cbd52c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b68fb1546ea86614e422c695ccd6c5308cbd52c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/702127f6f1b099f8a34804ddb71f821444b7b64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/702127f6f1b099f8a34804ddb71f821444b7b64e", "html_url": "https://github.com/rust-lang/rust/commit/702127f6f1b099f8a34804ddb71f821444b7b64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/702127f6f1b099f8a34804ddb71f821444b7b64e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f40fa8304fea63e04364645260112ddaf91ce70f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f40fa8304fea63e04364645260112ddaf91ce70f", "html_url": "https://github.com/rust-lang/rust/commit/f40fa8304fea63e04364645260112ddaf91ce70f"}, {"sha": "2a6f197bf4358f6ed9211777e59553128caa459b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a6f197bf4358f6ed9211777e59553128caa459b", "html_url": "https://github.com/rust-lang/rust/commit/2a6f197bf4358f6ed9211777e59553128caa459b"}], "stats": {"total": 269, "additions": 268, "deletions": 1}, "files": [{"sha": "dd884b6ee41d88a5ab82a10c1335ef6c230ce92f", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 268, "deletions": 1, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/702127f6f1b099f8a34804ddb71f821444b7b64e/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702127f6f1b099f8a34804ddb71f821444b7b64e/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=702127f6f1b099f8a34804ddb71f821444b7b64e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): implement union family of fns\n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n // FIXME(conventions): replace each_reverse by making iter DoubleEnded\n // FIXME(conventions): implement iter_mut and into_iter\n@@ -19,6 +18,7 @@ use core::prelude::*;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n+use core::iter::Peekable;\n use std::hash::Hash;\n \n use trie_map::{TrieMap, Entries};\n@@ -172,6 +172,106 @@ impl TrieSet {\n         SetItems{iter: self.map.upper_bound(val)}\n     }\n \n+    /// Visits the values representing the difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1 then 2\n+    /// }\n+    ///\n+    /// let diff1: TrieSet = a.difference(&b).collect();\n+    /// assert_eq!(diff1, [1, 2].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff2: TrieSet = b.difference(&a).collect();\n+    /// assert_eq!(diff2, [4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn difference<'a>(&'a self, other: &'a TrieSet) -> DifferenceItems<'a> {\n+        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 4, 5 in ascending order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: TrieSet = a.symmetric_difference(&b).collect();\n+    /// let diff2: TrieSet = b.symmetric_difference(&a).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle.\"]\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TrieSet) -> SymDifferenceItems<'a> {\n+        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the intersection, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in ascending order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TrieSet = a.intersection(&b).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn intersection<'a>(&'a self, other: &'a TrieSet) -> IntersectionItems<'a> {\n+        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the union, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TrieSet = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4, 5 in ascending order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TrieSet = a.union(&b).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn union<'a>(&'a self, other: &'a TrieSet) -> UnionItems<'a> {\n+        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n     /// Return the number of elements in the set\n     ///\n     /// # Example\n@@ -368,6 +468,39 @@ pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n }\n \n+/// An iterator producing elements in the set difference (in-order).\n+pub struct DifferenceItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// An iterator producing elements in the set symmetric difference (in-order).\n+pub struct SymDifferenceItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// An iterator producing elements in the set intersection (in-order).\n+pub struct IntersectionItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// An iterator producing elements in the set union (in-order).\n+pub struct UnionItems<'a> {\n+    a: Peekable<uint, SetItems<'a>>,\n+    b: Peekable<uint, SetItems<'a>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt(x: Option<&uint>, y: Option<&uint>, short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n+}\n+\n impl<'a> Iterator<uint> for SetItems<'a> {\n     fn next(&mut self) -> Option<uint> {\n         self.iter.next().map(|(key, _)| key)\n@@ -378,6 +511,60 @@ impl<'a> Iterator<uint> for SetItems<'a> {\n     }\n }\n \n+impl<'a> Iterator<uint> for DifferenceItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<uint> for SymDifferenceItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less => return self.a.next(),\n+                Equal => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<uint> for IntersectionItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<uint> for UnionItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use std::prelude::*;\n@@ -471,4 +658,84 @@ mod test {\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n+\n+    fn check(a: &[uint],\n+             b: &[uint],\n+             expected: &[uint],\n+             f: |&TrieSet, &TrieSet, f: |uint| -> bool| -> bool) {\n+        let mut set_a = TrieSet::new();\n+        let mut set_b = TrieSet::new();\n+\n+        for x in a.iter() { assert!(set_a.insert(*x)) }\n+        for y in b.iter() { assert!(set_b.insert(*y)) }\n+\n+        let mut i = 0;\n+        f(&set_a, &set_b, |x| {\n+            assert_eq!(x, expected[i]);\n+            i += 1;\n+            true\n+        });\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        fn check_intersection(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n+        }\n+\n+        check_intersection(&[], &[], &[]);\n+        check_intersection(&[1, 2, 3], &[], &[]);\n+        check_intersection(&[], &[1, 2, 3], &[]);\n+        check_intersection(&[2], &[1, 2, 3], &[2]);\n+        check_intersection(&[1, 2, 3], &[2], &[2]);\n+        check_intersection(&[11, 1, 3, 77, 103, 5],\n+                           &[2, 11, 77, 5, 3],\n+                           &[3, 5, 11, 77]);\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        fn check_difference(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n+        }\n+\n+        check_difference(&[], &[], &[]);\n+        check_difference(&[1, 12], &[], &[1, 12]);\n+        check_difference(&[], &[1, 2, 3, 9], &[]);\n+        check_difference(&[1, 3, 5, 9, 11],\n+                         &[3, 9],\n+                         &[1, 5, 11]);\n+        check_difference(&[11, 22, 33, 40, 42],\n+                         &[14, 23, 34, 38, 39, 50],\n+                         &[11, 22, 33, 40, 42]);\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        fn check_symmetric_difference(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n+        }\n+\n+        check_symmetric_difference(&[], &[], &[]);\n+        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n+        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n+        check_symmetric_difference(&[1, 3, 5, 9, 11],\n+                                   &[3, 9, 14, 22],\n+                                   &[1, 5, 11, 14, 22]);\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        fn check_union(a: &[uint], b: &[uint], expected: &[uint]) {\n+            check(a, b, expected, |x, y, f| x.union(y).all(f))\n+        }\n+\n+        check_union(&[], &[], &[]);\n+        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n+        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n+        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n+                    &[1, 5, 9, 13, 19],\n+                    &[1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+    }\n }"}]}