{"sha": "0a84708edca7c275cb99ad080317fbc7637516d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhODQ3MDhlZGNhN2MyNzVjYjk5YWQwODAzMTdmYmM3NjM3NTE2ZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-31T16:47:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-31T16:47:06Z"}, "message": "Auto merge of #88535 - m-ou-se:rollup-jeusxbo, r=m-ou-se\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #85017 (Add carrying_add, borrowing_sub, widening_mul, carrying_mul methods to integers)\n - #86362 (Avoid cloning LocalDecls)\n - #88391 (Fix json tuple struct enum variant )\n - #88399 (Disallow the aapcs CC on Aarch64)\n - #88418 (Allow `~const` bounds on trait assoc functions)\n - #88445 (Clean up the lowering of AST items)\n - #88495 (Add `TcpStream::set_linger` and `TcpStream::linger`)\n - #88501 (Use right span in prelude collision suggestions with macros. )\n - #88504 (Keep turbofish in prelude collision lint.)\n - #88524 (Remove unnecessary `mut` from udp doctests)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e2cc9552e3d5ae365f6c373b60e6f6d87080c1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2cc9552e3d5ae365f6c373b60e6f6d87080c1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a84708edca7c275cb99ad080317fbc7637516d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a84708edca7c275cb99ad080317fbc7637516d8", "html_url": "https://github.com/rust-lang/rust/commit/0a84708edca7c275cb99ad080317fbc7637516d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a84708edca7c275cb99ad080317fbc7637516d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76d18cfb8945f824c8777e04981e930d2037954e", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d18cfb8945f824c8777e04981e930d2037954e", "html_url": "https://github.com/rust-lang/rust/commit/76d18cfb8945f824c8777e04981e930d2037954e"}, {"sha": "f5cf9678c23bea8a9a865f0ced879714ec107871", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5cf9678c23bea8a9a865f0ced879714ec107871", "html_url": "https://github.com/rust-lang/rust/commit/f5cf9678c23bea8a9a865f0ced879714ec107871"}], "stats": {"total": 1136, "additions": 1008, "deletions": 128}, "files": [{"sha": "8daeef0cbd95fbaa0e8c5f869fcf9eaf9079d84e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -26,44 +26,43 @@ pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n }\n \n impl ItemLowerer<'_, '_, '_> {\n-    fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n+    fn with_trait_impl_ref<T>(\n+        &mut self,\n+        impl_ref: &Option<TraitRef>,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n         let old = self.lctx.is_in_trait_impl;\n         self.lctx.is_in_trait_impl = impl_ref.is_some();\n-        f(self);\n+        let ret = f(self);\n         self.lctx.is_in_trait_impl = old;\n+        ret\n     }\n }\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_item(&mut self, item: &'a Item) {\n-        let mut item_hir_id = None;\n-        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+        let hir_id = self.lctx.with_hir_id_owner(item.id, |lctx| {\n             lctx.without_in_scope_lifetime_defs(|lctx| {\n-                if let Some(hir_item) = lctx.lower_item(item) {\n-                    let id = lctx.insert_item(hir_item);\n-                    item_hir_id = Some(id);\n-                }\n+                let hir_item = lctx.lower_item(item);\n+                lctx.insert_item(hir_item)\n             })\n         });\n \n-        if let Some(hir_id) = item_hir_id {\n-            self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n-                let this = &mut ItemLowerer { lctx: this };\n-                match item.kind {\n-                    ItemKind::Mod(..) => {\n-                        let def_id = this.lctx.lower_node_id(item.id).expect_owner();\n-                        let old_current_module =\n-                            mem::replace(&mut this.lctx.current_module, def_id);\n-                        visit::walk_item(this, item);\n-                        this.lctx.current_module = old_current_module;\n-                    }\n-                    ItemKind::Impl(box ImplKind { ref of_trait, .. }) => {\n-                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-                    }\n-                    _ => visit::walk_item(this, item),\n+        self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n+            let this = &mut ItemLowerer { lctx: this };\n+            match item.kind {\n+                ItemKind::Mod(..) => {\n+                    let def_id = this.lctx.lower_node_id(item.id).expect_owner();\n+                    let old_current_module = mem::replace(&mut this.lctx.current_module, def_id);\n+                    visit::walk_item(this, item);\n+                    this.lctx.current_module = old_current_module;\n                 }\n-            });\n-        }\n+                ItemKind::Impl(box ImplKind { ref of_trait, .. }) => {\n+                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n+                }\n+                _ => visit::walk_item(this, item),\n+            }\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'a>, sp: Span, _: NodeId) {\n@@ -113,7 +112,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n         parent_hir_id: hir::ItemId,\n-        f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n@@ -137,10 +136,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // Clears (and restores) the `in_scope_lifetimes` field. Used when\n     // visiting nested items, which never inherit in-scope lifetimes\n     // from their surrounding environment.\n-    fn without_in_scope_lifetime_defs<T>(\n-        &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n-    ) -> T {\n+    fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n         let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n \n         // this vector is only used when walking over impl headers,\n@@ -208,19 +204,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n+    pub fn lower_item(&mut self, i: &Item) -> hir::Item<'hir> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let hir_id = self.lower_node_id(i.id);\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n-        Some(hir::Item {\n+        hir::Item {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis,\n             span: self.lower_span(i.span),\n-        })\n+        }\n     }\n \n     fn lower_item_kind("}, {"sha": "a243300edd9d2be480e3581bdcc970fe0edb3dff", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1442,7 +1442,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 if !self.is_tilde_const_allowed {\n                     self.err_handler()\n                         .struct_span_err(bound.span(), \"`~const` is not allowed here\")\n-                        .note(\"only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\")\n+                        .note(\"only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\")\n                         .emit();\n                 }\n             }\n@@ -1616,7 +1616,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_ty, ty);\n             }\n             AssocItemKind::Fn(box FnKind(_, ref sig, ref generics, ref body))\n-                if self.in_const_trait_impl =>\n+                if self.in_const_trait_impl || ctxt == AssocCtxt::Trait =>\n             {\n                 self.visit_vis(&item.vis);\n                 self.visit_ident(item.ident);"}, {"sha": "346a9e8021731b233ba2ae8e62a74155618d5d76", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -426,6 +426,11 @@ impl<'tcx> Body<'tcx> {\n         (arg_count + 1..local_count).map(Local::new)\n     }\n \n+    #[inline]\n+    pub fn drain_vars_and_temps<'a>(&'a mut self) -> impl Iterator<Item = LocalDecl<'tcx>> + 'a {\n+        self.local_decls.drain(self.arg_count + 1..)\n+    }\n+\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_statement_nop(&mut self, location: Location) {"}, {"sha": "8e9da31eba11f04bcff01ea0c3348ce8e48d0ef1", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -607,13 +607,7 @@ impl Inliner<'tcx> {\n                 }\n \n                 // Insert all of the (mapped) parts of the callee body into the caller.\n-                caller_body.local_decls.extend(\n-                    // FIXME(eddyb) make `Range<Local>` iterable so that we can use\n-                    // `callee_body.local_decls.drain(callee_body.vars_and_temps())`\n-                    callee_body\n-                        .vars_and_temps_iter()\n-                        .map(|local| callee_body.local_decls[local].clone()),\n-                );\n+                caller_body.local_decls.extend(callee_body.drain_vars_and_temps());\n                 caller_body.source_scopes.extend(&mut callee_body.source_scopes.drain(..));\n                 caller_body.var_debug_info.append(&mut callee_body.var_debug_info);\n                 caller_body.basic_blocks_mut().extend(callee_body.basic_blocks_mut().drain(..));"}, {"sha": "10e9bde0d972be2b904373b8e93291943a7eb42f", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -597,6 +597,14 @@ impl Span {\n         if !expn_data.is_root() { Some(expn_data.call_site) } else { None }\n     }\n \n+    /// Walk down the expansion ancestors to find a span that's contained within `outer`.\n+    pub fn find_ancestor_inside(mut self, outer: Span) -> Option<Span> {\n+        while !outer.contains(self) {\n+            self = self.parent()?;\n+        }\n+        Some(self)\n+    }\n+\n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n         self.ctxt().edition()"}, {"sha": "4d0cad80764e946ab950711644c2d3ffd56b14fe", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1501,7 +1501,8 @@ impl Target {\n             | Cdecl\n             | EfiApi => true,\n             X86Interrupt => [\"x86\", \"x86_64\"].contains(&&self.arch[..]),\n-            Aapcs | CCmseNonSecureCall => [\"arm\", \"aarch64\"].contains(&&self.arch[..]),\n+            Aapcs => \"arm\" == self.arch,\n+            CCmseNonSecureCall => [\"arm\", \"aarch64\"].contains(&&self.arch[..]),\n             Win64 | SysV64 => self.arch == \"x86_64\",\n             PtxKernel => self.arch == \"nvptx64\",\n             Msp430Interrupt => self.arch == \"msp430\","}, {"sha": "5c8056b244242343791656967f54d2cd9a92f61a", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -156,15 +156,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         segment.ident.name\n                     ));\n \n-                    let (self_adjusted, precise) = self.adjust_expr(pick, self_expr);\n+                    let (self_adjusted, precise) = self.adjust_expr(pick, self_expr, sp);\n                     if precise {\n                         let args = args\n                             .iter()\n                             .skip(1)\n                             .map(|arg| {\n+                                let span = arg.span.find_ancestor_inside(sp).unwrap_or_default();\n                                 format!(\n                                     \", {}\",\n-                                    self.sess().source_map().span_to_snippet(arg.span).unwrap()\n+                                    self.sess().source_map().span_to_snippet(span).unwrap()\n                                 )\n                             })\n                             .collect::<String>();\n@@ -173,8 +174,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             sp,\n                             \"disambiguate the associated function\",\n                             format!(\n-                                \"{}::{}({}{})\",\n-                                trait_name, segment.ident.name, self_adjusted, args\n+                                \"{}::{}{}({}{})\",\n+                                trait_name,\n+                                segment.ident.name,\n+                                if let Some(args) = segment.args.as_ref().and_then(|args| self\n+                                    .sess()\n+                                    .source_map()\n+                                    .span_to_snippet(args.span_ext)\n+                                    .ok())\n+                                {\n+                                    // Keep turbofish.\n+                                    format!(\"::{}\", args)\n+                                } else {\n+                                    String::new()\n+                                },\n+                                self_adjusted,\n+                                args,\n                             ),\n                             Applicability::MachineApplicable,\n                         );\n@@ -272,11 +287,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method_name.name\n             ));\n \n-            let mut self_ty_name = self\n-                .sess()\n-                .source_map()\n-                .span_to_snippet(self_ty_span)\n-                .unwrap_or_else(|_| self_ty.to_string());\n+            let mut self_ty_name = self_ty_span\n+                .find_ancestor_inside(span)\n+                .and_then(|span| self.sess().source_map().span_to_snippet(span).ok())\n+                .unwrap_or_else(|| self_ty.to_string());\n \n             // Get the number of generics the self type has (if an Adt) unless we can determine that\n             // the user has written the self type with generics already which we (naively) do by looking\n@@ -370,7 +384,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Creates a string version of the `expr` that includes explicit adjustments.\n     /// Returns the string and also a bool indicating whther this is a *precise*\n     /// suggestion.\n-    fn adjust_expr(&self, pick: &Pick<'tcx>, expr: &hir::Expr<'tcx>) -> (String, bool) {\n+    fn adjust_expr(\n+        &self,\n+        pick: &Pick<'tcx>,\n+        expr: &hir::Expr<'tcx>,\n+        outer: Span,\n+    ) -> (String, bool) {\n         let derefs = \"*\".repeat(pick.autoderefs);\n \n         let autoref = match pick.autoref_or_ptr_adjustment {\n@@ -379,12 +398,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n         };\n \n-        let (expr_text, precise) =\n-            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n-                (expr_text, true)\n-            } else {\n-                (\"(..)\".to_string(), false)\n-            };\n+        let (expr_text, precise) = if let Some(expr_text) = expr\n+            .span\n+            .find_ancestor_inside(outer)\n+            .and_then(|span| self.sess().source_map().span_to_snippet(span).ok())\n+        {\n+            (expr_text, true)\n+        } else {\n+            (\"(..)\".to_string(), false)\n+        };\n \n         let adjusted_text = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n             pick.autoref_or_ptr_adjustment"}, {"sha": "a25d0f8064404783d96d6912cbc90e2980136c59", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -680,15 +680,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         migrated_variables_concat\n                     );\n \n-                    let mut closure_body_span = self.tcx.hir().span(body_id.hir_id);\n-\n                     // If the body was entirely expanded from a macro\n                     // invocation, i.e. the body is not contained inside the\n                     // closure span, then we walk up the expansion until we\n                     // find the span before the expansion.\n-                    while !closure_body_span.is_dummy() && !closure_span.contains(closure_body_span) {\n-                        closure_body_span = closure_body_span.parent().unwrap_or(DUMMY_SP);\n-                    }\n+                    let closure_body_span = self.tcx.hir().span(body_id.hir_id)\n+                        .find_ancestor_inside(closure_span)\n+                        .unwrap_or(DUMMY_SP);\n \n                     if let Ok(s) = self.tcx.sess.source_map().span_to_snippet(closure_body_span) {\n                         let mut lines = s.lines();"}, {"sha": "d667fff4b81ee8bf4c2c091906515c35e66bd360", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -76,6 +76,7 @@\n #![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n #![feature(const_assert_type)]\n+#![feature(const_bigint_helper_methods)]\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_discriminant)]"}, {"sha": "1a310917fdfc4fd00e2fc18c133350f615fbc48a", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1341,6 +1341,33 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n+        /// additional bit of overflow. This allows for chaining together multiple additions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (\", stringify!($SelfT), \"::MIN, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (\", stringify!($SelfT), \"::MIN + 1, false));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n+            let (sum, carry) = (self as $UnsignedT).carrying_add(rhs as $UnsignedT, carry);\n+            (sum as $SelfT, carry)\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n@@ -1365,6 +1392,33 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n+        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, false));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n+            let (sum, borrow) = (self as $UnsignedT).borrowing_sub(rhs as $UnsignedT, borrow);\n+            (sum as $SelfT, borrow)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow"}, {"sha": "59b68cbe9c0ceb318af73074de99c0959aae936d", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -93,27 +93,104 @@ depending on the target pointer size.\n     };\n }\n \n+macro_rules! widening_impl {\n+    ($SelfT:ty, $WideT:ty, $BITS:literal) => {\n+        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n+        ///\n+        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n+        /// of the result as two separate values, in that order.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n+        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n+            // note: longer-term this should be done via an intrinsic,\n+            //   but for now we can deal without an impl for u128/i128\n+            // SAFETY: overflow will be contained within the wider types\n+            let wide = unsafe { (self as $WideT).unchecked_mul(rhs as $WideT) };\n+            (wide as $SelfT, (wide >> $BITS) as $SelfT)\n+        }\n+\n+        /// Calculates the \"full multiplication\" `self * rhs + carry`\n+        /// without the possibility to overflow.\n+        ///\n+        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n+        /// of the result as two separate values, in that order.\n+        ///\n+        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n+        /// additional amount of overflow. This allows for chaining together multiple\n+        /// multiplications to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u32` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n+        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n+        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n+        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n+            // note: longer-term this should be done via an intrinsic,\n+            //   but for now we can deal without an impl for u128/i128\n+            // SAFETY: overflow will be contained within the wider types\n+            let wide = unsafe {\n+                (self as $WideT).unchecked_mul(rhs as $WideT).unchecked_add(carry as $WideT)\n+            };\n+            (wide as $SelfT, (wide >> $BITS) as $SelfT)\n+        }\n+    };\n+}\n+\n #[lang = \"i8\"]\n impl i8 {\n+    widening_impl! { i8, i16, 8 }\n     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n+    widening_impl! { i16, i32, 16 }\n     int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n+    widening_impl! { i32, i64, 32 }\n     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n+    widening_impl! { i64, i128, 64 }\n     int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -135,6 +212,7 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i32, 16 }\n     int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -143,6 +221,7 @@ impl isize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i64, 32 }\n     int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\",\n@@ -152,6 +231,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n+    widening_impl! { isize, i128, 64 }\n     int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n     12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n      \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -164,6 +244,7 @@ const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n #[lang = \"u8\"]\n impl u8 {\n+    widening_impl! { u8, u16, 8 }\n     uint_impl! { u8, u8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n \n@@ -697,18 +778,21 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n+    widening_impl! { u16, u32, 16 }\n     uint_impl! { u16, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n+    widening_impl! { u32, u64, 32 }\n     uint_impl! { u32, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n+    widening_impl! { u64, u128, 64 }\n     uint_impl! { u64, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n@@ -731,13 +815,15 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u32, 16 }\n     uint_impl! { usize, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u64, 32 }\n     uint_impl! { usize, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -746,6 +832,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n+    widening_impl! { usize, u128, 64 }\n     uint_impl! { usize, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\","}, {"sha": "9366efb32bcf9e8ecb767e85a294b0970e78fb74", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1408,6 +1408,36 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary addition\" which takes in an extra bit to add, and may return an\n+        /// additional bit of overflow. This allows for chaining together multiple additions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (0, true));\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n+            // note: longer-term this should be done via an intrinsic, but this has been shown\n+            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n+            let (a, b) = self.overflowing_add(rhs);\n+            let (c, d) = a.overflowing_add(carry as $SelfT);\n+            (c, b | d)\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating\n@@ -1433,6 +1463,36 @@ macro_rules! uint_impl {\n             (a as Self, b)\n         }\n \n+        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        ///\n+        /// Performs \"ternary subtraction\" which takes in an extra bit to subtract, and may return\n+        /// an additional bit of overflow. This allows for chaining together multiple subtractions\n+        /// to create \"big integers\" which represent larger values.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, false), (\", stringify!($SelfT), \"::MAX, true));\")]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, true));\")]\n+        /// ```\n+        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n+        #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n+            // note: longer-term this should be done via an intrinsic, but this has been shown\n+            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n+            let (a, b) = self.overflowing_sub(rhs);\n+            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n+            (c, b | d)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean"}, {"sha": "5b4a9fa7979de644cb0cc043114071cc53dfb480", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -401,6 +401,53 @@ impl TcpStream {\n         self.0.peek(buf)\n     }\n \n+    /// Sets the value of the `SO_LINGER` option on this socket.\n+    ///\n+    /// This value controls how the socket is closed when data remains\n+    /// to be sent. If `SO_LINGER` is set, the socket will remain open\n+    /// for the specified duration as the system attempts to send pending data.\n+    /// Otherwise, the system may close the socket immediately, or wait for a\n+    /// default timeout.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(tcp_linger)]\n+    ///\n+    /// use std::net::TcpStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_linger(Some(Duration::from_secs(0))).expect(\"set_linger call failed\");\n+    /// ```\n+    #[unstable(feature = \"tcp_linger\", issue = \"88494\")]\n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        self.0.set_linger(linger)\n+    }\n+\n+    /// Gets the value of the `SO_LINGER` option on this socket.\n+    ///\n+    /// For more information about this option, see [`TcpStream::set_linger`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(tcp_linger)]\n+    ///\n+    /// use std::net::TcpStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n+    ///                        .expect(\"Couldn't connect to the server...\");\n+    /// stream.set_linger(Some(Duration::from_secs(0))).expect(\"set_linger call failed\");\n+    /// assert_eq!(stream.linger().unwrap(), Some(Duration::from_secs(0)));\n+    /// ```\n+    #[unstable(feature = \"tcp_linger\", issue = \"88494\")]\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        self.0.linger()\n+    }\n+\n     /// Sets the value of the `TCP_NODELAY` option on this socket.\n     ///\n     /// If set, this option disables the Nagle algorithm. This means that"}, {"sha": "c2061c1351262595cf9f9d804da9a87f1a606f0e", "filename": "library/std/src/net/tcp/tests.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -767,6 +767,21 @@ fn test_timeout_zero_duration() {\n     drop(listener);\n }\n \n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n+fn linger() {\n+    let addr = next_test_ip4();\n+    let _listener = t!(TcpListener::bind(&addr));\n+\n+    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+    assert_eq!(None, t!(stream.linger()));\n+    t!(stream.set_linger(Some(Duration::from_secs(1))));\n+    assert_eq!(Some(Duration::from_secs(1)), t!(stream.linger()));\n+    t!(stream.set_linger(None));\n+    assert_eq!(None, t!(stream.linger()));\n+}\n+\n #[test]\n #[cfg_attr(target_env = \"sgx\", ignore)]\n fn nodelay() {"}, {"sha": "6354752e64e766c97517bce6f845a994ad1e1228", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -39,7 +39,7 @@ use crate::time::Duration;\n ///\n /// fn main() -> std::io::Result<()> {\n ///     {\n-///         let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n+///         let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n ///\n ///         // Receives a single datagram message on the socket. If `buf` is too small to hold\n ///         // the message, it will be cut off."}, {"sha": "880ef678a4f7a2f704635cbdd35dd863cec37bad", "filename": "library/std/src/sys/hermit/net.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -182,6 +182,14 @@ impl TcpStream {\n         Ok(self.clone())\n     }\n \n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        unsupported()\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        unsupported()\n+    }\n+\n     pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n             .map_err(|_| io::Error::new_const(ErrorKind::Uncategorized, &\"set_nodelay failed\"))"}, {"sha": "89c5af6124f201bfdb8225a5306b494a4080099b", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -183,6 +183,14 @@ impl TcpStream {\n         Ok(self.clone())\n     }\n \n+    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {\n+        sgx_ineffective(())\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        sgx_ineffective(None)\n+    }\n+\n     pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n         sgx_ineffective(())\n     }"}, {"sha": "ba63b41534c1a4f55deca27ad7c99d67ec85158d", "filename": "library/std/src/sys/unix/l4re.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -98,6 +98,14 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn linger(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n         pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n             unimpl!();\n         }\n@@ -214,6 +222,14 @@ pub mod net {\n             unimpl!();\n         }\n \n+        pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn linger(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n         pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n             unimpl!();\n         }"}, {"sha": "9ae6d12dcb95cfc9a30256f3185db31f74ee7004", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -12,6 +12,14 @@ use crate::time::{Duration, Instant};\n \n use libc::{c_int, c_void, size_t, sockaddr, socklen_t, MSG_PEEK};\n \n+cfg_if::cfg_if! {\n+    if #[cfg(target_vendor = \"apple\")] {\n+        use libc::SO_LINGER_SEC as SO_LINGER;\n+    } else {\n+        use libc::SO_LINGER;\n+    }\n+}\n+\n pub use crate::sys::{cvt, cvt_r};\n \n #[allow(unused_extern_crates)]\n@@ -376,6 +384,21 @@ impl Socket {\n         Ok(())\n     }\n \n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        let linger = libc::linger {\n+            l_onoff: linger.is_some() as libc::c_int,\n+            l_linger: linger.unwrap_or_default().as_secs() as libc::c_int,\n+        };\n+\n+        setsockopt(self, libc::SOL_SOCKET, SO_LINGER, linger)\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        let val: libc::linger = getsockopt(self, libc::SOL_SOCKET, SO_LINGER)?;\n+\n+        Ok((val.l_onoff != 0).then(|| Duration::from_secs(val.l_linger as u64)))\n+    }\n+\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n     }"}, {"sha": "dbb6ce22c22de18cd99c6df1483a4efeb2e835cc", "filename": "library/std/src/sys/unsupported/net.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -76,6 +76,14 @@ impl TcpStream {\n         self.0\n     }\n \n+    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {\n+        self.0\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        self.0\n+    }\n+\n     pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n         self.0\n     }"}, {"sha": "a4dbb225376eee1d7e0b0c63fcf65ae80cd6450e", "filename": "library/std/src/sys/wasi/net.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -127,6 +127,14 @@ impl TcpStream {\n         unsupported()\n     }\n \n+    pub fn set_linger(&self, _: Option<Duration>) -> io::Result<()> {\n+        unsupported()\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        unsupported()\n+    }\n+\n     pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n         unsupported()\n     }"}, {"sha": "cedf389fbf503b85b0ef7770ec17c0ba7974baf5", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -197,6 +197,7 @@ pub const SOCK_DGRAM: c_int = 2;\n pub const SOCK_STREAM: c_int = 1;\n pub const SOCKET_ERROR: c_int = -1;\n pub const SOL_SOCKET: c_int = 0xffff;\n+pub const SO_LINGER: c_int = 0x0080;\n pub const SO_RCVTIMEO: c_int = 0x1006;\n pub const SO_SNDTIMEO: c_int = 0x1005;\n pub const IPPROTO_IP: c_int = 0;\n@@ -216,6 +217,13 @@ pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n pub const MSG_PEEK: c_int = 0x2;\n \n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct linger {\n+    pub l_onoff: c_ushort,\n+    pub l_linger: c_ushort,\n+}\n+\n #[repr(C)]\n pub struct ip_mreq {\n     pub imr_multiaddr: in_addr,"}, {"sha": "33152cc97abc018428c3f2aa7e8f6f4ed808fef2", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -15,7 +15,7 @@ use crate::sys_common::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n-use libc::{c_int, c_long, c_ulong};\n+use libc::{c_int, c_long, c_ulong, c_ushort};\n \n pub type wrlen_t = i32;\n \n@@ -446,6 +446,21 @@ impl Socket {\n         cvt(result).map(drop)\n     }\n \n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        let linger = c::linger {\n+            l_onoff: linger.is_some() as c_ushort,\n+            l_linger: linger.unwrap_or_default().as_secs() as c_ushort,\n+        };\n+\n+        net::setsockopt(self, c::SOL_SOCKET, c::SO_LINGER, linger)\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        let val: c::linger = net::getsockopt(self, c::SOL_SOCKET, c::SO_LINGER)?;\n+\n+        Ok((val.l_onoff != 0).then(|| Duration::from_secs(val.l_linger as u64)))\n+    }\n+\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         net::setsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c::BYTE)\n     }"}, {"sha": "c5c3df361f34bf86066eee932b74817ae83f2a43", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -297,6 +297,14 @@ impl TcpStream {\n         self.inner.duplicate().map(|s| TcpStream { inner: s })\n     }\n \n+    pub fn set_linger(&self, linger: Option<Duration>) -> io::Result<()> {\n+        self.inner.set_linger(linger)\n+    }\n+\n+    pub fn linger(&self) -> io::Result<Option<Duration>> {\n+        self.inner.linger()\n+    }\n+\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         self.inner.set_nodelay(nodelay)\n     }"}, {"sha": "b566239423e0455654e597c627ac8adef8ce22e4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1702,12 +1702,28 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     }\n }\n \n+impl Clean<Vec<Item>> for hir::VariantData<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n+        self.fields().iter().map(|x| x.clean(cx)).collect()\n+    }\n+}\n+\n impl Clean<Item> for ty::VariantDef {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n             CtorKind::Fn => Variant::Tuple(\n-                self.fields.iter().map(|f| cx.tcx.type_of(f.did).clean(cx)).collect(),\n+                self.fields\n+                    .iter()\n+                    .map(|field| {\n+                        let name = Some(field.ident.name);\n+                        let kind = StructFieldItem(cx.tcx.type_of(field.did).clean(cx));\n+                        let what_rustc_thinks =\n+                            Item::from_def_id_and_parts(field.did, name, kind, cx);\n+                        // don't show `pub` for fields, which are always public\n+                        Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n+                    })\n+                    .collect(),\n             ),\n             CtorKind::Fictive => Variant::Struct(VariantStruct {\n                 struct_type: CtorKind::Fictive,\n@@ -1737,13 +1753,7 @@ impl Clean<Variant> for hir::VariantData<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Variant {\n         match self {\n             hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n-            // Important note here: `Variant::Tuple` is used on tuple structs which are not in an\n-            // enum (so where converting from `ty::VariantDef`). In case we are in an enum, the kind\n-            // is provided by the `Variant` wrapper directly, and since we need the fields' name\n-            // (even for a tuple struct variant!), it's simpler to just store it as a\n-            // `Variant::Struct` instead of a `Variant::Tuple` (otherwise it would force us to make\n-            // a lot of changes when rendering them to generate the name as well).\n-            hir::VariantData::Tuple(..) => Variant::Struct(self.clean(cx)),\n+            hir::VariantData::Tuple(..) => Variant::Tuple(self.clean(cx)),\n             hir::VariantData::Unit(..) => Variant::CLike,\n         }\n     }"}, {"sha": "4194c99c0ba707ec197e797406816d32e5dc5bf8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -715,6 +715,7 @@ impl ItemKind {\n             StructItem(s) => s.fields.iter(),\n             UnionItem(u) => u.fields.iter(),\n             VariantItem(Variant::Struct(v)) => v.fields.iter(),\n+            VariantItem(Variant::Tuple(v)) => v.iter(),\n             EnumItem(e) => e.variants.iter(),\n             TraitItem(t) => t.items.iter(),\n             ImplItem(i) => i.items.iter(),\n@@ -1937,7 +1938,7 @@ crate struct Enum {\n #[derive(Clone, Debug)]\n crate enum Variant {\n     CLike,\n-    Tuple(Vec<Type>),\n+    Tuple(Vec<Item>),\n     Struct(VariantStruct),\n }\n "}, {"sha": "b4859e4c9c7fe2e10340f66df721dc7ef9214e3d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -56,6 +56,10 @@ crate trait DocFolder: Sized {\n                             || j.fields.iter().any(|f| f.is_stripped());\n                         VariantItem(Variant::Struct(j))\n                     }\n+                    Variant::Tuple(fields) => {\n+                        let fields = fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n+                        VariantItem(Variant::Tuple(fields))\n+                    }\n                     _ => VariantItem(i2),\n                 }\n             }"}, {"sha": "722cfc97a8d898e8047d2c7e906a2875c4076bf3", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -937,6 +937,19 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n     document_type_layout(w, cx, def_id);\n }\n \n+fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]) {\n+    for (i, ty) in s\n+        .iter()\n+        .map(|f| if let clean::StructFieldItem(ref ty) = *f.kind { ty } else { unreachable!() })\n+        .enumerate()\n+    {\n+        if i > 0 {\n+            w.write_str(\",&nbsp;\");\n+        }\n+        write!(w, \"{}\", ty.print(cx));\n+    }\n+}\n+\n fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"enum\", |w| {\n@@ -964,14 +977,9 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                     match *v.kind {\n                         clean::VariantItem(ref var) => match var {\n                             clean::Variant::CLike => write!(w, \"{}\", name),\n-                            clean::Variant::Tuple(ref tys) => {\n+                            clean::Variant::Tuple(ref s) => {\n                                 write!(w, \"{}(\", name);\n-                                for (i, ty) in tys.iter().enumerate() {\n-                                    if i > 0 {\n-                                        w.write_str(\",&nbsp;\")\n-                                    }\n-                                    write!(w, \"{}\", ty.print(cx));\n-                                }\n+                                print_tuple_struct_fields(w, cx, s);\n                                 w.write_str(\")\");\n                             }\n                             clean::Variant::Struct(ref s) => {\n@@ -1024,14 +1032,9 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 id = id,\n                 name = variant.name.as_ref().unwrap()\n             );\n-            if let clean::VariantItem(clean::Variant::Tuple(ref tys)) = *variant.kind {\n+            if let clean::VariantItem(clean::Variant::Tuple(ref s)) = *variant.kind {\n                 w.write_str(\"(\");\n-                for (i, ty) in tys.iter().enumerate() {\n-                    if i > 0 {\n-                        w.write_str(\",&nbsp;\");\n-                    }\n-                    write!(w, \"{}\", ty.print(cx));\n-                }\n+                print_tuple_struct_fields(w, cx, s);\n                 w.write_str(\")\");\n             }\n             w.write_str(\"</code>\");\n@@ -1041,7 +1044,11 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             document_non_exhaustive(w, variant);\n \n             use crate::clean::Variant;\n-            if let clean::VariantItem(Variant::Struct(ref s)) = *variant.kind {\n+            if let Some((extra, fields)) = match *variant.kind {\n+                clean::VariantItem(Variant::Struct(ref s)) => Some((\"\", &s.fields)),\n+                clean::VariantItem(Variant::Tuple(ref fields)) => Some((\"Tuple \", fields)),\n+                _ => None,\n+            } {\n                 let variant_id = cx.derive_id(format!(\n                     \"{}.{}.fields\",\n                     ItemType::Variant,\n@@ -1051,10 +1058,10 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 write!(\n                     w,\n                     \"<h3>{extra}Fields of <b>{name}</b></h3><div>\",\n-                    extra = if s.struct_type == CtorKind::Fn { \"Tuple \" } else { \"\" },\n+                    extra = extra,\n                     name = variant.name.as_ref().unwrap(),\n                 );\n-                for field in &s.fields {\n+                for field in fields {\n                     use crate::clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = *field.kind {\n                         let id = cx.derive_id(format!("}, {"sha": "9453e6d35ee6796ce28f98d195bfabe7c36dfff5", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -569,7 +569,18 @@ impl FromWithTcx<clean::Variant> for Variant {\n         use clean::Variant::*;\n         match variant {\n             CLike => Variant::Plain,\n-            Tuple(t) => Variant::Tuple(t.into_iter().map(|x| x.into_tcx(tcx)).collect()),\n+            Tuple(fields) => Variant::Tuple(\n+                fields\n+                    .into_iter()\n+                    .map(|f| {\n+                        if let clean::StructFieldItem(ty) = *f.kind {\n+                            ty.into_tcx(tcx)\n+                        } else {\n+                            unreachable!()\n+                        }\n+                    })\n+                    .collect(),\n+            ),\n             Struct(s) => Variant::Struct(ids(s.fields)),\n         }\n     }"}, {"sha": "a93880453ba274916cca5561235e5179ac9da166", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -94,8 +94,8 @@ impl<'a> DocFolder for Stripper<'a> {\n \n             // implementations of traits are always public.\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-            // Struct variant fields have inherited visibility\n-            clean::VariantItem(clean::Variant::Struct(..)) => true,\n+            // Variant fields have inherited visibility\n+            clean::VariantItem(clean::Variant::Struct(..) | clean::Variant::Tuple(..)) => true,\n             _ => false,\n         };\n "}, {"sha": "246e6a09007b347ec0cb79071d701aae62597b74", "filename": "src/test/rustdoc-json/enums/variant_struct.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_struct.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,11 @@\n+// @has variant_struct.json \"$.index[*][?(@.name=='EnumStruct')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='EnumStruct')].kind\" \\\"enum\\\"\n+pub enum EnumStruct {\n+    // @has - \"$.index[*][?(@.name=='VariantS')].inner.variant_kind\" \\\"struct\\\"\n+    // @has - \"$.index[*][?(@.name=='x')]\"\n+    // @has - \"$.index[*][?(@.name=='y')]\"\n+    VariantS {\n+        x: u32,\n+        y: String,\n+    },\n+}"}, {"sha": "d948dc552cdbcab874b9b4a2e41be150c1e0e02a", "filename": "src/test/rustdoc-json/enums/variant_tuple_struct.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fvariant_tuple_struct.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,6 @@\n+// @has variant_tuple_struct.json \"$.index[*][?(@.name=='EnumTupleStruct')].visibility\" \\\"public\\\"\n+// @has - \"$.index[*][?(@.name=='EnumTupleStruct')].kind\" \\\"enum\\\"\n+pub enum EnumTupleStruct {\n+    // @has - \"$.index[*][?(@.name=='VariantA')].inner.variant_kind\" \\\"tuple\\\"\n+    VariantA(u32, String),\n+}"}, {"sha": "225d49e05a3fa49fef67994992f726d6c772bbcf", "filename": "src/test/ui/abi/unsupported.aarch64.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.aarch64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.aarch64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Funsupported.aarch64.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1,41 +1,47 @@\n error[E0570]: `\"ptx-kernel\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:24:1\n+  --> $DIR/unsupported.rs:26:1\n    |\n LL | extern \"ptx-kernel\" fn ptx() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"amdgpu-kernel\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:26:1\n+  --> $DIR/unsupported.rs:28:1\n    |\n LL | extern \"amdgpu-kernel\" fn amdgpu() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"wasm\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:28:1\n+  --> $DIR/unsupported.rs:30:1\n    |\n LL | extern \"wasm\" fn wasm() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n+error[E0570]: `\"aapcs\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:32:1\n+   |\n+LL | extern \"aapcs\" fn aapcs() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error[E0570]: `\"msp430-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:33:1\n+  --> $DIR/unsupported.rs:36:1\n    |\n LL | extern \"msp430-interrupt\" fn msp430() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"avr-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:35:1\n+  --> $DIR/unsupported.rs:38:1\n    |\n LL | extern \"avr-interrupt\" fn avr() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"x86-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:37:1\n+  --> $DIR/unsupported.rs:40:1\n    |\n LL | extern \"x86-interrupt\" fn x86() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: use of calling convention not supported on this target\n-  --> $DIR/unsupported.rs:39:1\n+  --> $DIR/unsupported.rs:43:1\n    |\n LL | extern \"stdcall\" fn stdcall() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -45,14 +51,14 @@ LL | extern \"stdcall\" fn stdcall() {}\n    = note: for more information, see issue #87678 <https://github.com/rust-lang/rust/issues/87678>\n \n warning: use of calling convention not supported on this target\n-  --> $DIR/unsupported.rs:44:1\n+  --> $DIR/unsupported.rs:50:1\n    |\n LL | extern \"thiscall\" fn thiscall() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #87678 <https://github.com/rust-lang/rust/issues/87678>\n \n-error: aborting due to 6 previous errors; 2 warnings emitted\n+error: aborting due to 7 previous errors; 2 warnings emitted\n \n For more information about this error, try `rustc --explain E0570`."}, {"sha": "b050ee0aa3148501b5bc94661152b5d2a07633b3", "filename": "src/test/ui/abi/unsupported.arm.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Funsupported.arm.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,58 @@\n+error[E0570]: `\"ptx-kernel\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:26:1\n+   |\n+LL | extern \"ptx-kernel\" fn ptx() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0570]: `\"amdgpu-kernel\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:28:1\n+   |\n+LL | extern \"amdgpu-kernel\" fn amdgpu() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0570]: `\"wasm\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:30:1\n+   |\n+LL | extern \"wasm\" fn wasm() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0570]: `\"msp430-interrupt\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:36:1\n+   |\n+LL | extern \"msp430-interrupt\" fn msp430() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0570]: `\"avr-interrupt\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:38:1\n+   |\n+LL | extern \"avr-interrupt\" fn avr() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0570]: `\"x86-interrupt\"` is not a supported ABI for the current target\n+  --> $DIR/unsupported.rs:40:1\n+   |\n+LL | extern \"x86-interrupt\" fn x86() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: use of calling convention not supported on this target\n+  --> $DIR/unsupported.rs:43:1\n+   |\n+LL | extern \"stdcall\" fn stdcall() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(unsupported_calling_conventions)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #87678 <https://github.com/rust-lang/rust/issues/87678>\n+\n+warning: use of calling convention not supported on this target\n+  --> $DIR/unsupported.rs:50:1\n+   |\n+LL | extern \"thiscall\" fn thiscall() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #87678 <https://github.com/rust-lang/rust/issues/87678>\n+\n+error: aborting due to 6 previous errors; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0570`."}, {"sha": "7ca93516db989f7bb536c73ae800635300b0b59a", "filename": "src/test/ui/abi/unsupported.i686.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.i686.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.i686.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Funsupported.i686.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1,35 +1,35 @@\n error[E0570]: `\"ptx-kernel\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:24:1\n+  --> $DIR/unsupported.rs:26:1\n    |\n LL | extern \"ptx-kernel\" fn ptx() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"amdgpu-kernel\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:26:1\n+  --> $DIR/unsupported.rs:28:1\n    |\n LL | extern \"amdgpu-kernel\" fn amdgpu() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"wasm\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:28:1\n+  --> $DIR/unsupported.rs:30:1\n    |\n LL | extern \"wasm\" fn wasm() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"aapcs\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:30:1\n+  --> $DIR/unsupported.rs:32:1\n    |\n LL | extern \"aapcs\" fn aapcs() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"msp430-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:33:1\n+  --> $DIR/unsupported.rs:36:1\n    |\n LL | extern \"msp430-interrupt\" fn msp430() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"avr-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:35:1\n+  --> $DIR/unsupported.rs:38:1\n    |\n LL | extern \"avr-interrupt\" fn avr() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "9319eac8d30d84bd84be935d7bd7fe0ba49fe17d", "filename": "src/test/ui/abi/unsupported.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Funsupported.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1,11 +1,13 @@\n-// revisions: x64 i686 aarch64\n+// revisions: x64 i686 aarch64 arm\n //\n // [x64] needs-llvm-components: x86\n-// [x64]compile-flags: --target=x86_64-unknown-linux-gnu --crate-type=rlib\n+// [x64] compile-flags: --target=x86_64-unknown-linux-gnu --crate-type=rlib\n // [i686] needs-llvm-components: x86\n-// [i686]compile-flags: --target=i686-unknown-linux-gnu --crate-type=rlib\n+// [i686] compile-flags: --target=i686-unknown-linux-gnu --crate-type=rlib\n // [aarch64] needs-llvm-components: aarch64\n-// [aarch64]compile-flags: --target=aarch64-unknown-linux-gnu --crate-type=rlib\n+// [aarch64] compile-flags: --target=aarch64-unknown-linux-gnu --crate-type=rlib\n+// [arm] needs-llvm-components: arm\n+// [arm] compile-flags: --target=armv7-unknown-linux-gnueabihf --crate-type=rlib\n #![no_core]\n #![feature(\n     no_core,\n@@ -30,19 +32,25 @@ extern \"wasm\" fn wasm() {}\n extern \"aapcs\" fn aapcs() {}\n //[x64]~^ ERROR is not a supported ABI\n //[i686]~^^ ERROR is not a supported ABI\n+//[aarch64]~^^^ ERROR is not a supported ABI\n extern \"msp430-interrupt\" fn msp430() {}\n //~^ ERROR is not a supported ABI\n extern \"avr-interrupt\" fn avr() {}\n //~^ ERROR is not a supported ABI\n extern \"x86-interrupt\" fn x86() {}\n //[aarch64]~^ ERROR is not a supported ABI\n+//[arm]~^^ ERROR is not a supported ABI\n extern \"stdcall\" fn stdcall() {}\n //[x64]~^ WARN use of calling convention not supported\n //[x64]~^^ WARN this was previously accepted\n //[aarch64]~^^^ WARN use of calling convention not supported\n //[aarch64]~^^^^ WARN this was previously accepted\n+//[arm]~^^^^^ WARN use of calling convention not supported\n+//[arm]~^^^^^^ WARN this was previously accepted\n extern \"thiscall\" fn thiscall() {}\n //[x64]~^ WARN use of calling convention not supported\n //[x64]~^^ WARN this was previously accepted\n //[aarch64]~^^^ WARN use of calling convention not supported\n //[aarch64]~^^^^ WARN this was previously accepted\n+//[arm]~^^^^^ WARN use of calling convention not supported\n+//[arm]~^^^^^^ WARN this was previously accepted"}, {"sha": "f2f52683324dba69576e9759aa00e298d88a7c3c", "filename": "src/test/ui/abi/unsupported.x64.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.x64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Fabi%2Funsupported.x64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Funsupported.x64.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -1,41 +1,41 @@\n error[E0570]: `\"ptx-kernel\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:24:1\n+  --> $DIR/unsupported.rs:26:1\n    |\n LL | extern \"ptx-kernel\" fn ptx() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"amdgpu-kernel\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:26:1\n+  --> $DIR/unsupported.rs:28:1\n    |\n LL | extern \"amdgpu-kernel\" fn amdgpu() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"wasm\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:28:1\n+  --> $DIR/unsupported.rs:30:1\n    |\n LL | extern \"wasm\" fn wasm() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"aapcs\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:30:1\n+  --> $DIR/unsupported.rs:32:1\n    |\n LL | extern \"aapcs\" fn aapcs() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"msp430-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:33:1\n+  --> $DIR/unsupported.rs:36:1\n    |\n LL | extern \"msp430-interrupt\" fn msp430() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0570]: `\"avr-interrupt\"` is not a supported ABI for the current target\n-  --> $DIR/unsupported.rs:35:1\n+  --> $DIR/unsupported.rs:38:1\n    |\n LL | extern \"avr-interrupt\" fn avr() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: use of calling convention not supported on this target\n-  --> $DIR/unsupported.rs:39:1\n+  --> $DIR/unsupported.rs:43:1\n    |\n LL | extern \"stdcall\" fn stdcall() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -45,7 +45,7 @@ LL | extern \"stdcall\" fn stdcall() {}\n    = note: for more information, see issue #87678 <https://github.com/rust-lang/rust/issues/87678>\n \n warning: use of calling convention not supported on this target\n-  --> $DIR/unsupported.rs:44:1\n+  --> $DIR/unsupported.rs:50:1\n    |\n LL | extern \"thiscall\" fn thiscall() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "033ec21ba8408defa7bc509cef0053531482df2c", "filename": "src/test/ui/rfc-2632-const-trait-impl/tilde-const-invalid-places.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-invalid-places.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-invalid-places.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftilde-const-invalid-places.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -4,47 +4,47 @@ error: `~const` is not allowed here\n LL | fn rpit() -> impl ~const T { S }\n    |                   ^^^^^^^^\n    |\n-   = note: only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\n+   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:11:17\n    |\n LL | fn apit(_: impl ~const T) {}\n    |                 ^^^^^^^^\n    |\n-   = note: only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\n+   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:14:50\n    |\n LL | fn rpit_assoc_bound() -> impl IntoIterator<Item: ~const T> { Some(S) }\n    |                                                  ^^^^^^^^\n    |\n-   = note: only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\n+   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:17:48\n    |\n LL | fn apit_assoc_bound(_: impl IntoIterator<Item: ~const T>) {}\n    |                                                ^^^^^^^^\n    |\n-   = note: only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\n+   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:20:15\n    |\n LL | fn generic<P: ~const T>() {}\n    |               ^^^^^^^^\n    |\n-   = note: only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\n+   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n \n error: `~const` is not allowed here\n   --> $DIR/tilde-const-invalid-places.rs:23:31\n    |\n LL | fn where_clause<P>() where P: ~const T {}\n    |                               ^^^^^^^^\n    |\n-   = note: only allowed on bounds on traits' associated types, const fns, const impls and its associated functions\n+   = note: only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\n \n error: `~const` and `?` are mutually exclusive\n   --> $DIR/tilde-const-invalid-places.rs:26:25"}, {"sha": "0cde5b6f84218951370ff4b47730b7659be77ef8", "filename": "src/test/ui/rfc-2632-const-trait-impl/trait-where-clause-run.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause-run.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(const_fn_trait_bound)]\n+\n+trait Bar {\n+    fn bar() -> u8;\n+}\n+\n+trait Foo {\n+    #[default_method_body_is_const]\n+    fn foo() -> u8 where Self: ~const Bar {\n+        <Self as Bar>::bar() * 6\n+    }\n+}\n+\n+struct NonConst;\n+struct Const;\n+\n+impl Bar for NonConst {\n+    fn bar() -> u8 {\n+        3\n+    }\n+}\n+\n+impl Foo for NonConst {}\n+\n+impl const Bar for Const {\n+    fn bar() -> u8 {\n+        4\n+    }\n+}\n+\n+impl const Foo for Const {}\n+\n+fn main() {\n+    const ANS1: u8 = Const::foo();\n+    let ans2 = NonConst::foo();\n+\n+    assert_eq!(ANS1 + ans2, 42);\n+}"}, {"sha": "ae9ab26cdc04ad708706007e9bc19e9dc742f512", "filename": "src/test/ui/rfc-2632-const-trait-impl/trait-where-clause-self-referential.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause-self-referential.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(const_fn_trait_bound)]\n+\n+trait Foo {\n+    fn bar() where Self: ~const Foo;\n+}\n+\n+struct S;\n+\n+impl Foo for S {\n+    fn bar() {}\n+}\n+\n+fn baz<T: Foo>() {\n+    T::bar();\n+}\n+\n+const fn qux<T: ~const Foo>() {\n+    T::bar();\n+}\n+\n+fn main() {}"}, {"sha": "d64822d7ce8af77a4d5296a668dfffe0c8551f5d", "filename": "src/test/ui/rfc-2632-const-trait-impl/trait-where-clause.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,40 @@\n+#![feature(const_fn_trait_bound)]\n+#![feature(const_trait_impl)]\n+\n+trait Bar {}\n+\n+trait Foo {\n+    fn a();\n+    fn b() where Self: ~const Bar;\n+    fn c<T: ~const Bar>();\n+}\n+\n+const fn test1<T: ~const Foo + Bar>() {\n+    T::a();\n+    T::b();\n+    //~^ ERROR the trait bound\n+    T::c::<T>();\n+    //~^ ERROR the trait bound\n+}\n+\n+const fn test2<T: ~const Foo + ~const Bar>() {\n+    T::a();\n+    T::b();\n+    T::c::<T>();\n+}\n+\n+fn test3<T: Foo>() {\n+    T::a();\n+    T::b();\n+    //~^ ERROR the trait bound\n+    T::c::<T>();\n+    //~^ ERROR the trait bound\n+}\n+\n+fn test4<T: Foo + Bar>() {\n+    T::a();\n+    T::b();\n+    T::c::<T>();\n+}\n+\n+fn main() {}"}, {"sha": "fffb91f98700bdf8f9c9210468645a851944d9ca", "filename": "src/test/ui/rfc-2632-const-trait-impl/trait-where-clause.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,67 @@\n+error[E0277]: the trait bound `T: Bar` is not satisfied\n+  --> $DIR/trait-where-clause.rs:14:5\n+   |\n+LL |     T::b();\n+   |     ^^^^ the trait `Bar` is not implemented for `T`\n+   |\n+note: required by `Foo::b`\n+  --> $DIR/trait-where-clause.rs:8:5\n+   |\n+LL |     fn b() where Self: ~const Bar;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider further restricting this bound\n+   |\n+LL | const fn test1<T: ~const Foo + Bar + Bar>() {\n+   |                                    +++++\n+\n+error[E0277]: the trait bound `T: Bar` is not satisfied\n+  --> $DIR/trait-where-clause.rs:16:5\n+   |\n+LL |     T::c::<T>();\n+   |     ^^^^^^^^^ the trait `Bar` is not implemented for `T`\n+   |\n+note: required by `Foo::c`\n+  --> $DIR/trait-where-clause.rs:9:5\n+   |\n+LL |     fn c<T: ~const Bar>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: consider further restricting this bound\n+   |\n+LL | const fn test1<T: ~const Foo + Bar + Bar>() {\n+   |                                    +++++\n+\n+error[E0277]: the trait bound `T: Bar` is not satisfied\n+  --> $DIR/trait-where-clause.rs:28:5\n+   |\n+LL |     T::b();\n+   |     ^^^^ the trait `Bar` is not implemented for `T`\n+   |\n+note: required by `Foo::b`\n+  --> $DIR/trait-where-clause.rs:8:5\n+   |\n+LL |     fn b() where Self: ~const Bar;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider further restricting this bound\n+   |\n+LL | fn test3<T: Foo + Bar>() {\n+   |                 +++++\n+\n+error[E0277]: the trait bound `T: Bar` is not satisfied\n+  --> $DIR/trait-where-clause.rs:30:5\n+   |\n+LL |     T::c::<T>();\n+   |     ^^^^^^^^^ the trait `Bar` is not implemented for `T`\n+   |\n+note: required by `Foo::c`\n+  --> $DIR/trait-where-clause.rs:9:5\n+   |\n+LL |     fn c<T: ~const Bar>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: consider further restricting this bound\n+   |\n+LL | fn test3<T: Foo + Bar>() {\n+   |                 +++++\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a97dc176e1b8b019ccdef82fcb40adcfb3ead81d", "filename": "src/test/ui/rust-2021/future-prelude-collision-macros.fixed", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.fixed?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,45 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(rust_2021_prelude_collisions)]\n+#![allow(unreachable_code)]\n+\n+macro_rules! foo {\n+    () => {{\n+        123;\n+        S\n+    }};\n+}\n+\n+trait MyTry<T> {\n+    fn try_into(self, _: u8);\n+}\n+\n+struct S;\n+\n+impl MyTry<i32> for S {\n+    fn try_into(self, _: u8) {}\n+}\n+\n+trait TryFromU8: Sized {\n+    fn try_from(_: u8);\n+}\n+\n+impl TryFromU8 for u32 {\n+    fn try_from(_: u8) {}\n+}\n+\n+macro_rules! bar {\n+    () => {\n+        u32\n+    };\n+}\n+\n+fn main() {\n+    MyTry::try_into(foo!(), todo!());\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition\n+    <bar!() as TryFromU8>::try_from(0);\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition\n+}"}, {"sha": "82484b5b3688d52dc8c98fe87fa8a24cd1b03352", "filename": "src/test/ui/rust-2021/future-prelude-collision-macros.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,45 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(rust_2021_prelude_collisions)]\n+#![allow(unreachable_code)]\n+\n+macro_rules! foo {\n+    () => {{\n+        123;\n+        S\n+    }};\n+}\n+\n+trait MyTry<T> {\n+    fn try_into(self, _: u8);\n+}\n+\n+struct S;\n+\n+impl MyTry<i32> for S {\n+    fn try_into(self, _: u8) {}\n+}\n+\n+trait TryFromU8: Sized {\n+    fn try_from(_: u8);\n+}\n+\n+impl TryFromU8 for u32 {\n+    fn try_from(_: u8) {}\n+}\n+\n+macro_rules! bar {\n+    () => {\n+        u32\n+    };\n+}\n+\n+fn main() {\n+    foo!().try_into(todo!());\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition\n+    <bar!()>::try_from(0);\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition\n+}"}, {"sha": "4c3543ca782e8340e8af45e94af425cdedffdec5", "filename": "src/test/ui/rust-2021/future-prelude-collision-macros.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-macros.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,25 @@\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-macros.rs:39:5\n+   |\n+LL |     foo!().try_into(todo!());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `MyTry::try_into(foo!(), todo!())`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/future-prelude-collision-macros.rs:4:9\n+   |\n+LL | #![warn(rust_2021_prelude_collisions)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/prelude.html>\n+\n+warning: trait-associated function `try_from` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-macros.rs:42:5\n+   |\n+LL |     <bar!()>::try_from(0);\n+   |     ^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `<bar!() as TryFromU8>::try_from`\n+   |\n+   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/prelude.html>\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "3e76fced774dbdfc379bd82b6cb4e57192336085", "filename": "src/test/ui/rust-2021/future-prelude-collision-turbofish.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.fixed?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,28 @@\n+// See https://github.com/rust-lang/rust/issues/88442\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![allow(unused)]\n+#![warn(rust_2021_prelude_collisions)]\n+\n+trait AnnotatableTryInto {\n+    fn try_into<T>(self) -> Result<T, Self::Error>\n+    where Self: std::convert::TryInto<T> {\n+        std::convert::TryInto::try_into(self)\n+    }\n+}\n+\n+impl<T> AnnotatableTryInto for T where T: From<u8> {}\n+\n+fn main() -> Result<(), &'static str> {\n+    let x: u64 = 1;\n+    AnnotatableTryInto::try_into::<usize>(x).or(Err(\"foo\"))?.checked_sub(1);\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+\n+    AnnotatableTryInto::try_into::<usize>(x).or(Err(\"foo\"))?;\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+\n+    Ok(())\n+}"}, {"sha": "abb292ef99284ea547597026182673376b4c66b8", "filename": "src/test/ui/rust-2021/future-prelude-collision-turbofish.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.rs?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,28 @@\n+// See https://github.com/rust-lang/rust/issues/88442\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![allow(unused)]\n+#![warn(rust_2021_prelude_collisions)]\n+\n+trait AnnotatableTryInto {\n+    fn try_into<T>(self) -> Result<T, Self::Error>\n+    where Self: std::convert::TryInto<T> {\n+        std::convert::TryInto::try_into(self)\n+    }\n+}\n+\n+impl<T> AnnotatableTryInto for T where T: From<u8> {}\n+\n+fn main() -> Result<(), &'static str> {\n+    let x: u64 = 1;\n+    x.try_into::<usize>().or(Err(\"foo\"))?.checked_sub(1);\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+\n+    x.try_into::<usize>().or(Err(\"foo\"))?;\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~| WARNING this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+\n+    Ok(())\n+}"}, {"sha": "2de9020bce7ac53ca39d6399d88b0acceeb95910", "filename": "src/test/ui/rust-2021/future-prelude-collision-turbofish.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a84708edca7c275cb99ad080317fbc7637516d8/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-turbofish.stderr?ref=0a84708edca7c275cb99ad080317fbc7637516d8", "patch": "@@ -0,0 +1,25 @@\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-turbofish.rs:19:5\n+   |\n+LL |     x.try_into::<usize>().or(Err(\"foo\"))?.checked_sub(1);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `AnnotatableTryInto::try_into::<usize>(x)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/future-prelude-collision-turbofish.rs:6:9\n+   |\n+LL | #![warn(rust_2021_prelude_collisions)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/prelude.html>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-turbofish.rs:23:5\n+   |\n+LL |     x.try_into::<usize>().or(Err(\"foo\"))?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `AnnotatableTryInto::try_into::<usize>(x)`\n+   |\n+   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/prelude.html>\n+\n+warning: 2 warnings emitted\n+"}]}