{"sha": "dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "node_id": "C_kwDOAAsO6NoAKGRkM2Y1ZTA5OTMzYzhhMWUxNjkxNzNiYzU2NGRhZThmNmZmNWJiMGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T20:22:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T20:22:30Z"}, "message": "Auto merge of #12168 - Veykril:completion-rev, r=Veykril\n\ninternal: Remove unqualified_path completions module", "tree": {"sha": "84ab7751ba1545ebf52927745f716542434214cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84ab7751ba1545ebf52927745f716542434214cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "html_url": "https://github.com/rust-lang/rust/commit/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc9ae2b89e01a30e441371b9fd3376c3d03a475f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9ae2b89e01a30e441371b9fd3376c3d03a475f", "html_url": "https://github.com/rust-lang/rust/commit/cc9ae2b89e01a30e441371b9fd3376c3d03a475f"}, {"sha": "0c4e23b8ef80d3a2b590246e17272b91d252b979", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4e23b8ef80d3a2b590246e17272b91d252b979", "html_url": "https://github.com/rust-lang/rust/commit/0c4e23b8ef80d3a2b590246e17272b91d252b979"}], "stats": {"total": 1501, "additions": 769, "deletions": 732}, "files": [{"sha": "8b537a1d38569217f587703d67933dffb76e7e9e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -88,7 +88,7 @@ pub use crate::{\n         UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n-    semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo},\n+    semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n };\n \n // Be careful with these re-exports."}, {"sha": "d887dae99c1439bcab9f1988c1a46b15e9905ca4", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -1370,10 +1370,10 @@ impl<'a> SemanticsScope<'a> {\n         &self.resolver\n     }\n \n-    /// Note: `FxHashSet<TraitId>` should be treated as an opaque type, passed into `Type\n-    pub fn visible_traits(&self) -> FxHashSet<TraitId> {\n+    /// Note: `VisibleTraits` should be treated as an opaque type, passed into `Type\n+    pub fn visible_traits(&self) -> VisibleTraits {\n         let resolver = &self.resolver;\n-        resolver.traits_in_scope(self.db.upcast())\n+        VisibleTraits(resolver.traits_in_scope(self.db.upcast()))\n     }\n \n     pub fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n@@ -1424,3 +1424,5 @@ impl<'a> SemanticsScope<'a> {\n         )\n     }\n }\n+\n+pub struct VisibleTraits(pub FxHashSet<TraitId>);"}, {"sha": "82a67fb51db672a7602fe73a23341139b9333607", "filename": "crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -148,14 +148,13 @@ fn is_ref_and_impls_iter_method(\n     let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n     let scope = sema.scope(iterable.syntax())?;\n     let krate = scope.krate();\n-    let traits_in_scope = scope.visible_traits();\n     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n \n     let has_wanted_method = ty\n         .iterate_method_candidates(\n             sema.db,\n             &scope,\n-            &traits_in_scope,\n+            &scope.visible_traits().0,\n             None,\n             Some(&wanted_method),\n             |func| {"}, {"sha": "062b12a50bcd46338df0c87119db8311c3e26a36", "filename": "crates/ide-assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -95,10 +95,14 @@ fn get_impl_method(\n \n     let scope = ctx.sema.scope(impl_.syntax())?;\n     let ty = impl_def.self_ty(db);\n-    let traits_in_scope = scope.visible_traits();\n-    ty.iterate_method_candidates(db, &scope, &traits_in_scope, None, Some(fn_name), |func| {\n-        Some(func)\n-    })\n+    ty.iterate_method_candidates(\n+        db,\n+        &scope,\n+        &scope.visible_traits().0,\n+        None,\n+        Some(fn_name),\n+        |func| Some(func),\n+    )\n }\n \n #[cfg(test)]"}, {"sha": "687a598bacc1bfbc8f84bc405596c11a732dd332", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -13,7 +13,6 @@ pub(crate) mod lifetime;\n pub(crate) mod mod_;\n pub(crate) mod pattern;\n pub(crate) mod postfix;\n-pub(crate) mod qualified_path;\n pub(crate) mod record;\n pub(crate) mod snippet;\n pub(crate) mod trait_impl;"}, {"sha": "03d9d3fa875b24dcc43c22ab958aa14c2c536781", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -78,18 +78,10 @@ fn complete_methods(\n     mut f: impl FnMut(hir::Function),\n ) {\n     let mut seen_methods = FxHashSet::default();\n-    let mut traits_in_scope = ctx.scope.visible_traits();\n-\n-    // Remove drop from the environment as calling `Drop::drop` is not allowed\n-    if let Some(drop_trait) = ctx.famous_defs().core_ops_Drop() {\n-        cov_mark::hit!(dot_remove_drop_trait);\n-        traits_in_scope.remove(&drop_trait.into());\n-    }\n-\n     receiver.iterate_method_candidates(\n         ctx.db,\n         &ctx.scope,\n-        &traits_in_scope,\n+        &ctx.traits_in_scope().0,\n         Some(ctx.module),\n         None,\n         |func| {\n@@ -758,7 +750,6 @@ fn main() {\n \n     #[test]\n     fn postfix_drop_completion() {\n-        cov_mark::check!(dot_remove_drop_trait);\n         cov_mark::check!(postfix_drop_completion);\n         check_edit(\n             \"drop\","}, {"sha": "fb9955c5e8cd9f52358f0ed31ae14bb56586f932", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 136, "deletions": 9, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -1,6 +1,7 @@\n //! Completion of names from the current scope in expression position.\n \n use hir::ScopeDef;\n+use ide_db::FxHashSet;\n \n use crate::{\n     context::{PathCompletionCtx, PathKind, PathQualifierCtx},\n@@ -20,8 +21,129 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         _ => return,\n     };\n \n+    let scope_def_applicable = |def| {\n+        use hir::{GenericParam::*, ModuleDef::*};\n+        match def {\n+            ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n+            // Don't suggest attribute macros and derives.\n+            ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n+            _ => true,\n+        }\n+    };\n+\n     match qualifier {\n-        Some(PathQualifierCtx { .. }) => return,\n+        Some(PathQualifierCtx { is_infer_qualifier, resolution, .. }) => {\n+            if *is_infer_qualifier {\n+                ctx.traits_in_scope()\n+                    .0\n+                    .into_iter()\n+                    .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n+                    .for_each(|item| add_assoc_item(acc, ctx, item));\n+                return;\n+            }\n+            let resolution = match resolution {\n+                Some(it) => it,\n+                None => return,\n+            };\n+            // Add associated types on type parameters and `Self`.\n+            ctx.scope.assoc_type_shorthand_candidates(resolution, |_, alias| {\n+                acc.add_type_alias(ctx, alias);\n+                None::<()>\n+            });\n+            match resolution {\n+                hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+                    let module_scope = module.scope(ctx.db, Some(ctx.module));\n+                    for (name, def) in module_scope {\n+                        if scope_def_applicable(def) {\n+                            acc.add_resolution(ctx, name, def);\n+                        }\n+                    }\n+                }\n+\n+                hir::PathResolution::Def(\n+                    def @ (hir::ModuleDef::Adt(_)\n+                    | hir::ModuleDef::TypeAlias(_)\n+                    | hir::ModuleDef::BuiltinType(_)),\n+                ) => {\n+                    if let &hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n+                        add_enum_variants(acc, ctx, e);\n+                    }\n+                    let ty = match def {\n+                        hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n+                        hir::ModuleDef::TypeAlias(a) => {\n+                            let ty = a.ty(ctx.db);\n+                            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                                cov_mark::hit!(completes_variant_through_alias);\n+                                add_enum_variants(acc, ctx, e);\n+                            }\n+                            ty\n+                        }\n+                        hir::ModuleDef::BuiltinType(builtin) => {\n+                            cov_mark::hit!(completes_primitive_assoc_const);\n+                            builtin.ty(ctx.db)\n+                        }\n+                        _ => unreachable!(),\n+                    };\n+\n+                    // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n+                    // (where AssocType is defined on a trait, not an inherent impl)\n+\n+                    ty.iterate_path_candidates(\n+                        ctx.db,\n+                        &ctx.scope,\n+                        &ctx.traits_in_scope().0,\n+                        Some(ctx.module),\n+                        None,\n+                        |item| {\n+                            add_assoc_item(acc, ctx, item);\n+                            None::<()>\n+                        },\n+                    );\n+\n+                    // Iterate assoc types separately\n+                    ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                        if let hir::AssocItem::TypeAlias(ty) = item {\n+                            acc.add_type_alias(ctx, ty)\n+                        }\n+                        None::<()>\n+                    });\n+                }\n+                hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n+                    // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n+                    for item in t.items(ctx.db) {\n+                        add_assoc_item(acc, ctx, item);\n+                    }\n+                }\n+                hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n+                    let ty = match resolution {\n+                        hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                        hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                        _ => return,\n+                    };\n+\n+                    if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                        add_enum_variants(acc, ctx, e);\n+                    }\n+                    let mut seen = FxHashSet::default();\n+                    ty.iterate_path_candidates(\n+                        ctx.db,\n+                        &ctx.scope,\n+                        &ctx.traits_in_scope().0,\n+                        Some(ctx.module),\n+                        None,\n+                        |item| {\n+                            // We might iterate candidates of a trait multiple times here, so deduplicate\n+                            // them.\n+                            if seen.insert(item) {\n+                                add_assoc_item(acc, ctx, item);\n+                            }\n+                            None::<()>\n+                        },\n+                    );\n+                }\n+                _ => (),\n+            }\n+        }\n         None if is_absolute_path => acc.add_crate_roots(ctx),\n         None => {\n             acc.add_nameref_keywords_with_colon(ctx);\n@@ -33,17 +155,22 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                 });\n             }\n             ctx.process_all_names(&mut |name, def| {\n-                use hir::{GenericParam::*, ModuleDef::*};\n-                let add_resolution = match def {\n-                    ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n-                    // Don't suggest attribute macros and derives.\n-                    ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n-                    _ => true,\n-                };\n-                if add_resolution {\n+                if scope_def_applicable(def) {\n                     acc.add_resolution(ctx, name, def);\n                 }\n             });\n         }\n     }\n }\n+\n+fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n+    match item {\n+        hir::AssocItem::Function(func) => acc.add_function(ctx, func, None),\n+        hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+    }\n+}\n+\n+fn add_enum_variants(acc: &mut Completions, ctx: &CompletionContext, e: hir::Enum) {\n+    e.variants(ctx.db).into_iter().for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+}"}, {"sha": "963ee309590f592930fd4b087e49ffc98c1c9acd", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -163,12 +163,11 @@ fn pattern_path_completion(\n                         _ => return,\n                     };\n \n-                    let traits_in_scope = ctx.scope.visible_traits();\n                     let mut seen = FxHashSet::default();\n                     ty.iterate_path_candidates(\n                         ctx.db,\n                         &ctx.scope,\n-                        &traits_in_scope,\n+                        &ctx.scope.visible_traits().0,\n                         Some(ctx.module),\n                         None,\n                         |item| {"}, {"sha": "d12f8490bd1e06d4528329f9a27b0ade3e934280", "filename": "crates/ide-completion/src/completions/qualified_path.rs", "status": "removed", "additions": 0, "deletions": 670, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/cc9ae2b89e01a30e441371b9fd3376c3d03a475f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9ae2b89e01a30e441371b9fd3376c3d03a475f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=cc9ae2b89e01a30e441371b9fd3376c3d03a475f", "patch": "@@ -1,670 +0,0 @@\n-//! Completion of paths, i.e. `some::prefix::$0`.\n-\n-use hir::{ScopeDef, Trait};\n-use ide_db::FxHashSet;\n-use syntax::ast;\n-\n-use crate::{\n-    context::{PathCompletionCtx, PathKind},\n-    CompletionContext, Completions,\n-};\n-\n-pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    if ctx.is_path_disallowed() || ctx.has_unfinished_impl_or_trait_prev_sibling() {\n-        return;\n-    }\n-    if ctx.pattern_ctx.is_some() {\n-        return;\n-    }\n-    let (qualifier, kind) = match ctx.path_context {\n-        // let ... else, syntax would come in really handy here right now\n-        Some(PathCompletionCtx { qualifier: Some(ref qualifier), kind, .. }) => (qualifier, kind),\n-        _ => return,\n-    };\n-    let traits_in_scope = |ctx: &CompletionContext| {\n-        let mut traits_in_scope = ctx.scope.visible_traits();\n-        if let Some(drop) = ctx.famous_defs().core_ops_Drop() {\n-            traits_in_scope.remove(&drop.into());\n-        }\n-        traits_in_scope\n-    };\n-\n-    // special case `<_>::$0` as this doesn't resolve to anything.\n-    if qualifier.path.qualifier().is_none() {\n-        if matches!(\n-            qualifier.path.segment().and_then(|it| it.kind()),\n-            Some(ast::PathSegmentKind::Type {\n-                type_ref: Some(ast::Type::InferType(_)),\n-                trait_ref: None,\n-            })\n-        ) {\n-            cov_mark::hit!(completion_type_anchor_empty);\n-            traits_in_scope(ctx)\n-                .into_iter()\n-                .flat_map(|it| Trait::from(it).items(ctx.sema.db))\n-                .for_each(|item| add_assoc_item(acc, ctx, item));\n-            return;\n-        }\n-    }\n-\n-    let resolution = match &qualifier.resolution {\n-        Some(res) => res,\n-        None => return,\n-    };\n-\n-    match kind {\n-        Some(\n-            PathKind::Pat\n-            | PathKind::Attr { .. }\n-            | PathKind::Vis { .. }\n-            | PathKind::Use\n-            | PathKind::Item\n-            | PathKind::Derive,\n-        ) => {\n-            return;\n-        }\n-        _ => {\n-            // Add associated types on type parameters and `Self`.\n-            ctx.scope.assoc_type_shorthand_candidates(resolution, |_, alias| {\n-                acc.add_type_alias(ctx, alias);\n-                None::<()>\n-            });\n-        }\n-    }\n-\n-    match resolution {\n-        hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n-            let module_scope = module.scope(ctx.db, Some(ctx.module));\n-            for (name, def) in module_scope {\n-                let add_resolution = match def {\n-                    // Don't suggest attribute macros and derives.\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n-                    // no values in type places\n-                    ScopeDef::ModuleDef(\n-                        hir::ModuleDef::Function(_)\n-                        | hir::ModuleDef::Variant(_)\n-                        | hir::ModuleDef::Static(_),\n-                    )\n-                    | ScopeDef::Local(_) => !ctx.expects_type(),\n-                    // unless its a constant in a generic arg list position\n-                    ScopeDef::ModuleDef(hir::ModuleDef::Const(_)) => {\n-                        !ctx.expects_type() || ctx.expects_generic_arg()\n-                    }\n-                    _ => true,\n-                };\n-\n-                if add_resolution {\n-                    acc.add_resolution(ctx, name, def);\n-                }\n-            }\n-        }\n-        hir::PathResolution::Def(\n-            def @ (hir::ModuleDef::Adt(_)\n-            | hir::ModuleDef::TypeAlias(_)\n-            | hir::ModuleDef::BuiltinType(_)),\n-        ) => {\n-            if let &hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n-                add_enum_variants(acc, ctx, e);\n-            }\n-            let ty = match def {\n-                hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n-                hir::ModuleDef::TypeAlias(a) => {\n-                    let ty = a.ty(ctx.db);\n-                    if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                        cov_mark::hit!(completes_variant_through_alias);\n-                        add_enum_variants(acc, ctx, e);\n-                    }\n-                    ty\n-                }\n-                hir::ModuleDef::BuiltinType(builtin) => {\n-                    cov_mark::hit!(completes_primitive_assoc_const);\n-                    builtin.ty(ctx.db)\n-                }\n-                _ => unreachable!(),\n-            };\n-\n-            // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n-            // (where AssocType is defined on a trait, not an inherent impl)\n-\n-            let traits_in_scope = traits_in_scope(ctx);\n-            ty.iterate_path_candidates(\n-                ctx.db,\n-                &ctx.scope,\n-                &traits_in_scope,\n-                Some(ctx.module),\n-                None,\n-                |item| {\n-                    add_assoc_item(acc, ctx, item);\n-                    None::<()>\n-                },\n-            );\n-\n-            // Iterate assoc types separately\n-            ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n-                if let hir::AssocItem::TypeAlias(ty) = item {\n-                    acc.add_type_alias(ctx, ty)\n-                }\n-                None::<()>\n-            });\n-        }\n-        hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n-            // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n-            for item in t.items(ctx.db) {\n-                add_assoc_item(acc, ctx, item);\n-            }\n-        }\n-        hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n-            let ty = match resolution {\n-                hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n-                hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n-                _ => return,\n-            };\n-\n-            if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                add_enum_variants(acc, ctx, e);\n-            }\n-            let traits_in_scope = traits_in_scope(ctx);\n-            let mut seen = FxHashSet::default();\n-            ty.iterate_path_candidates(\n-                ctx.db,\n-                &ctx.scope,\n-                &traits_in_scope,\n-                Some(ctx.module),\n-                None,\n-                |item| {\n-                    // We might iterate candidates of a trait multiple times here, so deduplicate\n-                    // them.\n-                    if seen.insert(item) {\n-                        add_assoc_item(acc, ctx, item);\n-                    }\n-                    None::<()>\n-                },\n-            );\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n-    match item {\n-        hir::AssocItem::Function(func) if !ctx.expects_type() => acc.add_function(ctx, func, None),\n-        hir::AssocItem::Const(ct) if !ctx.expects_type() || ctx.expects_generic_arg() => {\n-            acc.add_const(ctx, ct)\n-        }\n-        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-        _ => (),\n-    }\n-}\n-\n-fn add_enum_variants(acc: &mut Completions, ctx: &CompletionContext, e: hir::Enum) {\n-    if ctx.expects_type() {\n-        return;\n-    }\n-    e.variants(ctx.db).into_iter().for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::tests::{check_edit, completion_list_no_kw};\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = completion_list_no_kw(ra_fixture);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn associated_item_visibility() {\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib new_source_root:library\n-pub struct S;\n-\n-impl S {\n-    pub fn public_method() { }\n-    fn private_method() { }\n-    pub type PublicType = u32;\n-    type PrivateType = u32;\n-    pub const PUBLIC_CONST: u32 = 1;\n-    const PRIVATE_CONST: u32 = 1;\n-}\n-\n-//- /main.rs crate:main deps:lib new_source_root:local\n-fn foo() { let _ = lib::S::$0 }\n-\"#,\n-            expect![[r#\"\n-                ct PUBLIC_CONST    pub const PUBLIC_CONST: u32\n-                fn public_method() fn()\n-                ta PublicType      pub type PublicType = u32\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_union_associated_method() {\n-        check(\n-            r#\"\n-union U {};\n-impl U { fn m() { } }\n-\n-fn foo() { let _ = U::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn m() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_trait_associated_method_1() {\n-        check(\n-            r#\"\n-trait Trait { fn m(); }\n-\n-fn foo() { let _ = Trait::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn m() (as Trait) fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_trait_associated_method_2() {\n-        check(\n-            r#\"\n-trait Trait { fn m(); }\n-\n-struct S;\n-impl Trait for S {}\n-\n-fn foo() { let _ = S::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn m() (as Trait) fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_trait_associated_method_3() {\n-        check(\n-            r#\"\n-trait Trait { fn m(); }\n-\n-struct S;\n-impl Trait for S {}\n-\n-fn foo() { let _ = <S as Trait>::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn m() (as Trait) fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_ty_param_assoc_ty() {\n-        check(\n-            r#\"\n-trait Super {\n-    type Ty;\n-    const CONST: u8;\n-    fn func() {}\n-    fn method(&self) {}\n-}\n-\n-trait Sub: Super {\n-    type SubTy;\n-    const C2: ();\n-    fn subfunc() {}\n-    fn submethod(&self) {}\n-}\n-\n-fn foo<T: Sub>() { T::$0 }\n-\"#,\n-            expect![[r#\"\n-                ct C2 (as Sub)           const C2: ()\n-                ct CONST (as Super)      const CONST: u8\n-                fn func() (as Super)     fn()\n-                fn subfunc() (as Sub)    fn()\n-                ta SubTy (as Sub)        type SubTy\n-                ta Ty (as Super)         type Ty\n-                me method(\u2026) (as Super)  fn(&self)\n-                me submethod(\u2026) (as Sub) fn(&self)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_self_param_assoc_ty() {\n-        check(\n-            r#\"\n-trait Super {\n-    type Ty;\n-    const CONST: u8 = 0;\n-    fn func() {}\n-    fn method(&self) {}\n-}\n-\n-trait Sub: Super {\n-    type SubTy;\n-    const C2: () = ();\n-    fn subfunc() {}\n-    fn submethod(&self) {}\n-}\n-\n-struct Wrap<T>(T);\n-impl<T> Super for Wrap<T> {}\n-impl<T> Sub for Wrap<T> {\n-    fn subfunc() {\n-        // Should be able to assume `Self: Sub + Super`\n-        Self::$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                ct C2 (as Sub)           const C2: ()\n-                ct CONST (as Super)      const CONST: u8\n-                fn func() (as Super)     fn()\n-                fn subfunc() (as Sub)    fn()\n-                ta SubTy (as Sub)        type SubTy\n-                ta Ty (as Super)         type Ty\n-                me method(\u2026) (as Super)  fn(&self)\n-                me submethod(\u2026) (as Sub) fn(&self)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_type_alias() {\n-        check(\n-            r#\"\n-struct S;\n-impl S { fn foo() {} }\n-type T = S;\n-impl T { fn bar() {} }\n-\n-fn main() { T::$0; }\n-\"#,\n-            expect![[r#\"\n-                fn bar() fn()\n-                fn foo() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_qualified_macros() {\n-        check(\n-            r#\"\n-#[macro_export]\n-macro_rules! foo { () => {} }\n-\n-fn main() { let _ = crate::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn main()  fn()\n-                ma foo!(\u2026) macro_rules! foo\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_complete_non_fn_macros() {\n-        check(\n-            r#\"\n-mod m {\n-    #[rustc_builtin_macro]\n-    pub macro Clone {}\n-}\n-\n-fn f() {m::$0}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-        check(\n-            r#\"\n-mod m {\n-    #[rustc_builtin_macro]\n-    pub macro bench {}\n-}\n-\n-fn f() {m::$0}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_reexported_items_under_correct_name() {\n-        check(\n-            r#\"\n-fn foo() { self::m::$0 }\n-\n-mod m {\n-    pub use super::p::wrong_fn as right_fn;\n-    pub use super::p::WRONG_CONST as RIGHT_CONST;\n-    pub use super::p::WrongType as RightType;\n-}\n-mod p {\n-    fn wrong_fn() {}\n-    const WRONG_CONST: u32 = 1;\n-    struct WrongType {};\n-}\n-\"#,\n-            expect![[r#\"\n-                ct RIGHT_CONST\n-                fn right_fn()  fn()\n-                st RightType\n-            \"#]],\n-        );\n-\n-        check_edit(\n-            \"RightType\",\n-            r#\"\n-fn foo() { self::m::$0 }\n-\n-mod m {\n-    pub use super::p::wrong_fn as right_fn;\n-    pub use super::p::WRONG_CONST as RIGHT_CONST;\n-    pub use super::p::WrongType as RightType;\n-}\n-mod p {\n-    fn wrong_fn() {}\n-    const WRONG_CONST: u32 = 1;\n-    struct WrongType {};\n-}\n-\"#,\n-            r#\"\n-fn foo() { self::m::RightType }\n-\n-mod m {\n-    pub use super::p::wrong_fn as right_fn;\n-    pub use super::p::WRONG_CONST as RIGHT_CONST;\n-    pub use super::p::WrongType as RightType;\n-}\n-mod p {\n-    fn wrong_fn() {}\n-    const WRONG_CONST: u32 = 1;\n-    struct WrongType {};\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_call() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn main() { m!(self::f$0); }\n-fn foo() {}\n-\"#,\n-            expect![[r#\"\n-                fn foo()  fn()\n-                fn main() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn function_mod_share_name() {\n-        check(\n-            r#\"\n-fn foo() { self::m::$0 }\n-\n-mod m {\n-    pub mod z {}\n-    pub fn z() {}\n-}\n-\"#,\n-            expect![[r#\"\n-                fn z() fn()\n-                md z\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_hashmap_new() {\n-        check(\n-            r#\"\n-struct RandomState;\n-struct HashMap<K, V, S = RandomState> {}\n-\n-impl<K, V> HashMap<K, V, RandomState> {\n-    pub fn new() -> HashMap<K, V, RandomState> { }\n-}\n-fn foo() {\n-    HashMap::$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn new() fn() -> HashMap<K, V, RandomState>\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_variant_through_self() {\n-        check(\n-            r#\"\n-enum Foo {\n-    Bar,\n-    Baz,\n-}\n-\n-impl Foo {\n-    fn foo(self) {\n-        Self::$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Bar    Bar\n-                ev Baz    Baz\n-                me foo(\u2026) fn(self)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_primitive_assoc_const() {\n-        cov_mark::check!(completes_primitive_assoc_const);\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:core\n-fn f() {\n-    u8::$0\n-}\n-\n-//- /core.rs crate:core\n-#[lang = \"u8\"]\n-impl u8 {\n-    pub const MAX: Self = 255;\n-\n-    pub fn func(self) {}\n-}\n-\"#,\n-            expect![[r#\"\n-                ct MAX     pub const MAX: Self\n-                me func(\u2026) fn(self)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_variant_through_alias() {\n-        cov_mark::check!(completes_variant_through_alias);\n-        check(\n-            r#\"\n-enum Foo {\n-    Bar\n-}\n-type Foo2 = Foo;\n-fn main() {\n-    Foo2::$0\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Bar Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn respects_doc_hidden() {\n-        cov_mark::check!(qualified_path_doc_hidden);\n-        check(\n-            r#\"\n-//- /lib.rs crate:lib deps:dep\n-fn f() {\n-    dep::$0\n-}\n-\n-//- /dep.rs crate:dep\n-#[doc(hidden)]\n-#[macro_export]\n-macro_rules! m {\n-    () => {}\n-}\n-\n-#[doc(hidden)]\n-pub fn f() {}\n-\n-#[doc(hidden)]\n-pub struct S;\n-\n-#[doc(hidden)]\n-pub mod m {}\n-            \"#,\n-            expect![[r#\"\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn type_anchor_empty() {\n-        cov_mark::check!(completion_type_anchor_empty);\n-        check(\n-            r#\"\n-trait Foo {\n-    fn foo() -> Self;\n-}\n-struct Bar;\n-impl Foo for Bar {\n-    fn foo() -> {\n-        Bar\n-    }\n-}\n-fn bar() -> Bar {\n-    <_>::$0\n-}\n-\"#,\n-            expect![[r#\"\n-                fn foo() (as Foo) fn() -> Self\n-            \"#]],\n-        )\n-    }\n-}"}, {"sha": "64c3bd3fdf181a76a09d034790709aa73688692b", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 129, "deletions": 26, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -1,6 +1,7 @@\n //! Completion of names from the current scope in type position.\n \n use hir::ScopeDef;\n+use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n@@ -22,8 +23,126 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n         _ => return,\n     };\n \n+    let scope_def_applicable = |def| {\n+        use hir::{GenericParam::*, ModuleDef::*};\n+        match def {\n+            ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n+            // no values in type places\n+            ScopeDef::ModuleDef(Function(_) | Variant(_) | Static(_)) | ScopeDef::Local(_) => false,\n+            // unless its a constant in a generic arg list position\n+            ScopeDef::ModuleDef(Const(_)) | ScopeDef::GenericParam(ConstParam(_)) => {\n+                ctx.expects_generic_arg()\n+            }\n+            ScopeDef::ImplSelfType(_) => {\n+                !ctx.previous_token_is(syntax::T![impl]) && !ctx.previous_token_is(syntax::T![for])\n+            }\n+            // Don't suggest attribute macros and derives.\n+            ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n+            // Type things are fine\n+            ScopeDef::ModuleDef(BuiltinType(_) | Adt(_) | Module(_) | Trait(_) | TypeAlias(_))\n+            | ScopeDef::AdtSelfType(_)\n+            | ScopeDef::Unknown\n+            | ScopeDef::GenericParam(TypeParam(_)) => true,\n+        }\n+    };\n+\n     match qualifier {\n-        Some(PathQualifierCtx { .. }) => return,\n+        Some(PathQualifierCtx { is_infer_qualifier, resolution, .. }) => {\n+            if *is_infer_qualifier {\n+                ctx.traits_in_scope()\n+                    .0\n+                    .into_iter()\n+                    .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n+                    .for_each(|item| add_assoc_item(acc, ctx, item));\n+                return;\n+            }\n+            let resolution = match resolution {\n+                Some(it) => it,\n+                None => return,\n+            };\n+            // Add associated types on type parameters and `Self`.\n+            ctx.scope.assoc_type_shorthand_candidates(resolution, |_, alias| {\n+                acc.add_type_alias(ctx, alias);\n+                None::<()>\n+            });\n+\n+            match resolution {\n+                hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+                    let module_scope = module.scope(ctx.db, Some(ctx.module));\n+                    for (name, def) in module_scope {\n+                        if scope_def_applicable(def) {\n+                            acc.add_resolution(ctx, name, def);\n+                        }\n+                    }\n+                }\n+                hir::PathResolution::Def(\n+                    def @ (hir::ModuleDef::Adt(_)\n+                    | hir::ModuleDef::TypeAlias(_)\n+                    | hir::ModuleDef::BuiltinType(_)),\n+                ) => {\n+                    let ty = match def {\n+                        hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n+                        hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n+                        hir::ModuleDef::BuiltinType(builtin) => builtin.ty(ctx.db),\n+                        _ => unreachable!(),\n+                    };\n+\n+                    // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n+                    // (where AssocType is defined on a trait, not an inherent impl)\n+\n+                    ty.iterate_path_candidates(\n+                        ctx.db,\n+                        &ctx.scope,\n+                        &ctx.traits_in_scope().0,\n+                        Some(ctx.module),\n+                        None,\n+                        |item| {\n+                            add_assoc_item(acc, ctx, item);\n+                            None::<()>\n+                        },\n+                    );\n+\n+                    // Iterate assoc types separately\n+                    ty.iterate_assoc_items(ctx.db, ctx.krate, |item| {\n+                        if let hir::AssocItem::TypeAlias(ty) = item {\n+                            acc.add_type_alias(ctx, ty)\n+                        }\n+                        None::<()>\n+                    });\n+                }\n+                hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n+                    // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n+                    for item in t.items(ctx.db) {\n+                        add_assoc_item(acc, ctx, item);\n+                    }\n+                }\n+                hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n+                    let ty = match resolution {\n+                        hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                        hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                        _ => return,\n+                    };\n+\n+                    let mut seen = FxHashSet::default();\n+                    ty.iterate_path_candidates(\n+                        ctx.db,\n+                        &ctx.scope,\n+                        &ctx.traits_in_scope().0,\n+                        Some(ctx.module),\n+                        None,\n+                        |item| {\n+                            // We might iterate candidates of a trait multiple times here, so deduplicate\n+                            // them.\n+                            if seen.insert(item) {\n+                                add_assoc_item(acc, ctx, item);\n+                            }\n+                            None::<()>\n+                        },\n+                    );\n+                }\n+                _ => (),\n+            }\n+        }\n         None if is_absolute_path => acc.add_crate_roots(ctx),\n         None => {\n             acc.add_nameref_keywords_with_colon(ctx);\n@@ -57,34 +176,18 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n                 }\n             }\n             ctx.process_all_names(&mut |name, def| {\n-                use hir::{GenericParam::*, ModuleDef::*};\n-                let add_resolution = match def {\n-                    ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n-                    // no values in type places\n-                    ScopeDef::ModuleDef(Function(_) | Variant(_) | Static(_))\n-                    | ScopeDef::Local(_) => false,\n-                    // unless its a constant in a generic arg list position\n-                    ScopeDef::ModuleDef(Const(_)) | ScopeDef::GenericParam(ConstParam(_)) => {\n-                        ctx.expects_generic_arg()\n-                    }\n-                    ScopeDef::ImplSelfType(_) => {\n-                        !ctx.previous_token_is(syntax::T![impl])\n-                            && !ctx.previous_token_is(syntax::T![for])\n-                    }\n-                    // Don't suggest attribute macros and derives.\n-                    ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n-                    // Type things are fine\n-                    ScopeDef::ModuleDef(\n-                        BuiltinType(_) | Adt(_) | Module(_) | Trait(_) | TypeAlias(_),\n-                    )\n-                    | ScopeDef::AdtSelfType(_)\n-                    | ScopeDef::Unknown\n-                    | ScopeDef::GenericParam(TypeParam(_)) => true,\n-                };\n-                if add_resolution {\n+                if scope_def_applicable(def) {\n                     acc.add_resolution(ctx, name, def);\n                 }\n             });\n         }\n     }\n }\n+\n+fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n+    match item {\n+        hir::AssocItem::Const(ct) if ctx.expects_generic_arg() => acc.add_const(ctx, ct),\n+        hir::AssocItem::Function(_) | hir::AssocItem::Const(_) => (),\n+        hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+    }\n+}"}, {"sha": "fd6d7709a0ee01cf674346f3e88fb1959134d7b7", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -19,7 +19,7 @@ pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext)\n     };\n \n     match qualifier {\n-        Some(PathQualifierCtx { path, resolution, is_super_chain, use_tree_parent }) => {\n+        Some(PathQualifierCtx { path, resolution, is_super_chain, use_tree_parent, .. }) => {\n             if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }"}, {"sha": "c4de8dc52e16bbc07d3e10242cad7bf0010c7b47", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -75,6 +75,7 @@ pub(crate) struct PathCompletionCtx {\n     // FIXME: use this\n     /// The parent of the path we are completing.\n     pub(super) parent: Option<ast::Path>,\n+    // FIXME: This should be PathKind, the none case should never occur\n     pub(super) kind: Option<PathKind>,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n@@ -91,6 +92,8 @@ pub(crate) struct PathQualifierCtx {\n     pub(crate) is_super_chain: bool,\n     /// Whether the qualifier comes from a use tree parent or not\n     pub(crate) use_tree_parent: bool,\n+    /// <_>\n+    pub(crate) is_infer_qualifier: bool,\n }\n \n #[derive(Debug)]\n@@ -378,6 +381,15 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n+    /// Returns the traits in scope, with the [`Drop`] trait removed.\n+    pub(crate) fn traits_in_scope(&self) -> hir::VisibleTraits {\n+        let mut traits_in_scope = self.scope.visible_traits();\n+        if let Some(drop) = self.famous_defs().core_ops_Drop() {\n+            traits_in_scope.0.remove(&drop.into());\n+        }\n+        traits_in_scope\n+    }\n+\n     /// A version of [`SemanticsScope::process_all_names`] that filters out `#[doc(hidden)]` items.\n     pub(crate) fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n         let _p = profile::span(\"CompletionContext::process_all_names\");\n@@ -1046,7 +1058,24 @@ impl<'a> CompletionContext<'a> {\n                 let res = sema.resolve_path(&path);\n                 let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n                     .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n-                PathQualifierCtx { path, resolution: res, is_super_chain, use_tree_parent }\n+\n+                // `<_>::$0`\n+                let is_infer_qualifier = path.qualifier().is_none()\n+                    && matches!(\n+                        path.segment().and_then(|it| it.kind()),\n+                        Some(ast::PathSegmentKind::Type {\n+                            type_ref: Some(ast::Type::InferType(_)),\n+                            trait_ref: None,\n+                        })\n+                    );\n+\n+                PathQualifierCtx {\n+                    path,\n+                    resolution: res,\n+                    is_super_chain,\n+                    use_tree_parent,\n+                    is_infer_qualifier,\n+                }\n             });\n             return Some((path_ctx, pat_ctx));\n         }"}, {"sha": "bc18e80516c328dd3c56692f16742ff130cacb54", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -166,7 +166,6 @@ pub fn completions(\n         completions::mod_::complete_mod(acc, ctx);\n         completions::pattern::complete_pattern(acc, ctx);\n         completions::postfix::complete_postfix(acc, ctx);\n-        completions::qualified_path::complete_qualified_path(acc, ctx);\n         completions::record::complete_record_literal(acc, ctx);\n         completions::record::complete_record(acc, ctx);\n         completions::snippet::complete_expr_snippet(acc, ctx);"}, {"sha": "6195537a18efb093fd31c482fcc58032c0129fc8", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -1,3 +1,5 @@\n+//! Tests that don't fit into a specific category.\n+\n use expect_test::{expect, Expect};\n \n use crate::tests::{check_edit, completion_list_no_kw};\n@@ -181,3 +183,456 @@ pub mod prelude {\n             \"#]],\n     );\n }\n+\n+#[test]\n+fn associated_item_visibility() {\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib new_source_root:library\n+pub struct S;\n+\n+impl S {\n+    pub fn public_method() { }\n+    fn private_method() { }\n+    pub type PublicType = u32;\n+    type PrivateType = u32;\n+    pub const PUBLIC_CONST: u32 = 1;\n+    const PRIVATE_CONST: u32 = 1;\n+}\n+\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn foo() { let _ = lib::S::$0 }\n+\"#,\n+        expect![[r#\"\n+                ct PUBLIC_CONST    pub const PUBLIC_CONST: u32\n+                fn public_method() fn()\n+                ta PublicType      pub type PublicType = u32\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_union_associated_method() {\n+    check(\n+        r#\"\n+union U {};\n+impl U { fn m() { } }\n+\n+fn foo() { let _ = U::$0 }\n+\"#,\n+        expect![[r#\"\n+                fn m() fn()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_trait_associated_method_1() {\n+    check(\n+        r#\"\n+trait Trait { fn m(); }\n+\n+fn foo() { let _ = Trait::$0 }\n+\"#,\n+        expect![[r#\"\n+                fn m() (as Trait) fn()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_trait_associated_method_2() {\n+    check(\n+        r#\"\n+trait Trait { fn m(); }\n+\n+struct S;\n+impl Trait for S {}\n+\n+fn foo() { let _ = S::$0 }\n+\"#,\n+        expect![[r#\"\n+                fn m() (as Trait) fn()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_trait_associated_method_3() {\n+    check(\n+        r#\"\n+trait Trait { fn m(); }\n+\n+struct S;\n+impl Trait for S {}\n+\n+fn foo() { let _ = <S as Trait>::$0 }\n+\"#,\n+        expect![[r#\"\n+                fn m() (as Trait) fn()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_ty_param_assoc_ty() {\n+    check(\n+        r#\"\n+trait Super {\n+    type Ty;\n+    const CONST: u8;\n+    fn func() {}\n+    fn method(&self) {}\n+}\n+\n+trait Sub: Super {\n+    type SubTy;\n+    const C2: ();\n+    fn subfunc() {}\n+    fn submethod(&self) {}\n+}\n+\n+fn foo<T: Sub>() { T::$0 }\n+\"#,\n+        expect![[r#\"\n+                ct C2 (as Sub)           const C2: ()\n+                ct CONST (as Super)      const CONST: u8\n+                fn func() (as Super)     fn()\n+                fn subfunc() (as Sub)    fn()\n+                ta SubTy (as Sub)        type SubTy\n+                ta Ty (as Super)         type Ty\n+                me method(\u2026) (as Super)  fn(&self)\n+                me submethod(\u2026) (as Sub) fn(&self)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_self_param_assoc_ty() {\n+    check(\n+        r#\"\n+trait Super {\n+    type Ty;\n+    const CONST: u8 = 0;\n+    fn func() {}\n+    fn method(&self) {}\n+}\n+\n+trait Sub: Super {\n+    type SubTy;\n+    const C2: () = ();\n+    fn subfunc() {}\n+    fn submethod(&self) {}\n+}\n+\n+struct Wrap<T>(T);\n+impl<T> Super for Wrap<T> {}\n+impl<T> Sub for Wrap<T> {\n+    fn subfunc() {\n+        // Should be able to assume `Self: Sub + Super`\n+        Self::$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+                ct C2 (as Sub)           const C2: ()\n+                ct CONST (as Super)      const CONST: u8\n+                fn func() (as Super)     fn()\n+                fn subfunc() (as Sub)    fn()\n+                ta SubTy (as Sub)        type SubTy\n+                ta Ty (as Super)         type Ty\n+                me method(\u2026) (as Super)  fn(&self)\n+                me submethod(\u2026) (as Sub) fn(&self)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_type_alias() {\n+    check(\n+        r#\"\n+struct S;\n+impl S { fn foo() {} }\n+type T = S;\n+impl T { fn bar() {} }\n+\n+fn main() { T::$0; }\n+\"#,\n+        expect![[r#\"\n+                fn bar() fn()\n+                fn foo() fn()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_qualified_macros() {\n+    check(\n+        r#\"\n+#[macro_export]\n+macro_rules! foo { () => {} }\n+\n+fn main() { let _ = crate::$0 }\n+\"#,\n+        expect![[r#\"\n+                fn main()  fn()\n+                ma foo!(\u2026) macro_rules! foo\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn does_not_complete_non_fn_macros() {\n+    check(\n+        r#\"\n+mod m {\n+    #[rustc_builtin_macro]\n+    pub macro Clone {}\n+}\n+\n+fn f() {m::$0}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+    check(\n+        r#\"\n+mod m {\n+    #[rustc_builtin_macro]\n+    pub macro bench {}\n+}\n+\n+fn f() {m::$0}\n+\"#,\n+        expect![[r#\"\"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_reexported_items_under_correct_name() {\n+    check(\n+        r#\"\n+fn foo() { self::m::$0 }\n+\n+mod m {\n+    pub use super::p::wrong_fn as right_fn;\n+    pub use super::p::WRONG_CONST as RIGHT_CONST;\n+    pub use super::p::WrongType as RightType;\n+}\n+mod p {\n+    fn wrong_fn() {}\n+    const WRONG_CONST: u32 = 1;\n+    struct WrongType {};\n+}\n+\"#,\n+        expect![[r#\"\n+                ct RIGHT_CONST\n+                fn right_fn()  fn()\n+                st RightType\n+            \"#]],\n+    );\n+\n+    check_edit(\n+        \"RightType\",\n+        r#\"\n+fn foo() { self::m::$0 }\n+\n+mod m {\n+    pub use super::p::wrong_fn as right_fn;\n+    pub use super::p::WRONG_CONST as RIGHT_CONST;\n+    pub use super::p::WrongType as RightType;\n+}\n+mod p {\n+    fn wrong_fn() {}\n+    const WRONG_CONST: u32 = 1;\n+    struct WrongType {};\n+}\n+\"#,\n+        r#\"\n+fn foo() { self::m::RightType }\n+\n+mod m {\n+    pub use super::p::wrong_fn as right_fn;\n+    pub use super::p::WRONG_CONST as RIGHT_CONST;\n+    pub use super::p::WrongType as RightType;\n+}\n+mod p {\n+    fn wrong_fn() {}\n+    const WRONG_CONST: u32 = 1;\n+    struct WrongType {};\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn completes_in_simple_macro_call() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn main() { m!(self::f$0); }\n+fn foo() {}\n+\"#,\n+        expect![[r#\"\n+                fn foo()  fn()\n+                fn main() fn()\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn function_mod_share_name() {\n+    check(\n+        r#\"\n+fn foo() { self::m::$0 }\n+\n+mod m {\n+    pub mod z {}\n+    pub fn z() {}\n+}\n+\"#,\n+        expect![[r#\"\n+                fn z() fn()\n+                md z\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_hashmap_new() {\n+    check(\n+        r#\"\n+struct RandomState;\n+struct HashMap<K, V, S = RandomState> {}\n+\n+impl<K, V> HashMap<K, V, RandomState> {\n+    pub fn new() -> HashMap<K, V, RandomState> { }\n+}\n+fn foo() {\n+    HashMap::$0\n+}\n+\"#,\n+        expect![[r#\"\n+                fn new() fn() -> HashMap<K, V, RandomState>\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_variant_through_self() {\n+    check(\n+        r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\n+impl Foo {\n+    fn foo(self) {\n+        Self::$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+                ev Bar    Bar\n+                ev Baz    Baz\n+                me foo(\u2026) fn(self)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_primitive_assoc_const() {\n+    cov_mark::check!(completes_primitive_assoc_const);\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:core\n+fn f() {\n+    u8::$0\n+}\n+\n+//- /core.rs crate:core\n+#[lang = \"u8\"]\n+impl u8 {\n+    pub const MAX: Self = 255;\n+\n+    pub fn func(self) {}\n+}\n+\"#,\n+        expect![[r#\"\n+                ct MAX     pub const MAX: Self\n+                me func(\u2026) fn(self)\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_variant_through_alias() {\n+    cov_mark::check!(completes_variant_through_alias);\n+    check(\n+        r#\"\n+enum Foo {\n+    Bar\n+}\n+type Foo2 = Foo;\n+fn main() {\n+    Foo2::$0\n+}\n+\"#,\n+        expect![[r#\"\n+                ev Bar Bar\n+            \"#]],\n+    );\n+}\n+\n+#[test]\n+fn respects_doc_hidden2() {\n+    cov_mark::check!(qualified_path_doc_hidden);\n+    check(\n+        r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn f() {\n+    dep::$0\n+}\n+\n+//- /dep.rs crate:dep\n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! m {\n+    () => {}\n+}\n+\n+#[doc(hidden)]\n+pub fn f() {}\n+\n+#[doc(hidden)]\n+pub struct S;\n+\n+#[doc(hidden)]\n+pub mod m {}\n+            \"#,\n+        expect![[r#\"\"#]],\n+    )\n+}\n+\n+#[test]\n+fn type_anchor_empty() {\n+    check(\n+        r#\"\n+trait Foo {\n+    fn foo() -> Self;\n+}\n+struct Bar;\n+impl Foo for Bar {\n+    fn foo() -> {\n+        Bar\n+    }\n+}\n+fn bar() -> Bar {\n+    <_>::$0\n+}\n+\"#,\n+        expect![[r#\"\n+                fn foo() (as Foo) fn() -> Self\n+            \"#]],\n+    )\n+}"}, {"sha": "f3b1af8e77fe1efa4e47c39763cc250c6c7e8607", "filename": "crates/ide-ssr/src/resolving.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f/crates%2Fide-ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fresolving.rs?ref=dd3f5e09933c8a1e169173bc564dae8f6ff5bb0f", "patch": "@@ -230,7 +230,7 @@ impl<'db> ResolutionScope<'db> {\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 &self.scope,\n-                &self.scope.visible_traits(),\n+                &self.scope.visible_traits().0,\n                 Some(module),\n                 None,\n                 |assoc_item| {"}]}