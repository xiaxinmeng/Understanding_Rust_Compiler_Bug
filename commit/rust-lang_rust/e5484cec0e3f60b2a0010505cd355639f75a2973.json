{"sha": "e5484cec0e3f60b2a0010505cd355639f75a2973", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NDg0Y2VjMGUzZjYwYjJhMDAxMDUwNWNkMzU1NjM5Zjc1YTI5NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-25T02:17:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-25T02:17:41Z"}, "message": "Auto merge of #88242 - bonega:allocation_range, r=oli-obk\n\nUse custom wrap-around type instead of RangeInclusive\n\nTwo reasons:\n\n1. More memory is allocated than necessary for `valid_range` in `Scalar`. The range is not used as an iterator and `exhausted` is never used.\n2. `contains`, `count` etc. methods in `RangeInclusive` are doing very unhelpful(and dangerous!) things when used as a wrap-around range. - In general this PR wants to limit potentially confusing methods, that have a low probability of working.\n\nDoing a local perf run, every metric shows improvement except for instructions.\nMax-rss seem to have a very consistent improvement.\n\nSorry - newbie here, probably doing something wrong.", "tree": {"sha": "25a26fad7e088f2c98dc4a268f8ce0351ea469d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25a26fad7e088f2c98dc4a268f8ce0351ea469d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5484cec0e3f60b2a0010505cd355639f75a2973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5484cec0e3f60b2a0010505cd355639f75a2973", "html_url": "https://github.com/rust-lang/rust/commit/e5484cec0e3f60b2a0010505cd355639f75a2973", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5484cec0e3f60b2a0010505cd355639f75a2973/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faa0a10406319264e81086fe88fd426cbfa09021", "url": "https://api.github.com/repos/rust-lang/rust/commits/faa0a10406319264e81086fe88fd426cbfa09021", "html_url": "https://github.com/rust-lang/rust/commit/faa0a10406319264e81086fe88fd426cbfa09021"}, {"sha": "f17e384a43dd8ca0aefb36bfcd8a69d9ad7f12cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f17e384a43dd8ca0aefb36bfcd8a69d9ad7f12cf", "html_url": "https://github.com/rust-lang/rust/commit/f17e384a43dd8ca0aefb36bfcd8a69d9ad7f12cf"}], "stats": {"total": 198, "additions": 116, "deletions": 82}, "files": [{"sha": "13538683e05af97c363e38286555aa303e786e45", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -462,15 +462,14 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             load: &'ll Value,\n             scalar: &abi::Scalar,\n         ) {\n-            let vr = scalar.valid_range.clone();\n             match scalar.value {\n                 abi::Int(..) => {\n                     let range = scalar.valid_range_exclusive(bx);\n                     if range.start != range.end {\n                         bx.range_metadata(load, range);\n                     }\n                 }\n-                abi::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                abi::Pointer if !scalar.valid_range.contains_zero() => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}"}, {"sha": "ec92bd686d2dfb845a530c96f164598db36842f3", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -16,7 +16,9 @@ use rustc_middle::mir::interpret::{\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n-use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n+use rustc_target::abi::{\n+    AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size, WrappingRange,\n+};\n use tracing::debug;\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n@@ -59,7 +61,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n+            &Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n             cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "f0b32c96309d629f90e66a6aaa94c71967404753", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -406,11 +406,11 @@ fn push_debuginfo_type_name<'tcx>(\n             let dataful_discriminant_range =\n                 &dataful_variant_layout.largest_niche.as_ref().unwrap().scalar.valid_range;\n \n-            let min = dataful_discriminant_range.start();\n-            let min = tag.value.size(&tcx).truncate(*min);\n+            let min = dataful_discriminant_range.start;\n+            let min = tag.value.size(&tcx).truncate(min);\n \n-            let max = dataful_discriminant_range.end();\n-            let max = tag.value.size(&tcx).truncate(*max);\n+            let max = dataful_discriminant_range.end;\n+            let max = tag.value.size(&tcx).truncate(max);\n \n             let dataful_variant_name = def.variants[*dataful_variant].ident.as_str();\n "}, {"sha": "02e2db54e741b38b77c71dc24604b7478cc753ec", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -310,15 +310,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                                 let er = scalar.valid_range_exclusive(bx.cx());\n                                 if er.end != er.start\n-                                    && scalar.valid_range.end() >= scalar.valid_range.start()\n+                                    && scalar.valid_range.end >= scalar.valid_range.start\n                                 {\n                                     // We want `table[e as usize \u00b1 k]` to not\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`s.\n-                                    if *scalar.valid_range.start() > 0 {\n+                                    if scalar.valid_range.start > 0 {\n                                         let enum_value_lower_bound = bx\n                                             .cx()\n-                                            .const_uint_big(ll_t_in, *scalar.valid_range.start());\n+                                            .const_uint_big(ll_t_in, scalar.valid_range.start);\n                                         let cmp_start = bx.icmp(\n                                             IntPredicate::IntUGE,\n                                             llval,\n@@ -328,7 +328,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     }\n \n                                     let enum_value_upper_bound =\n-                                        bx.cx().const_uint_big(ll_t_in, *scalar.valid_range.end());\n+                                        bx.cx().const_uint_big(ll_t_in, scalar.valid_range.end);\n                                     let cmp_end = bx.icmp(\n                                         IntPredicate::IntULE,\n                                         llval,"}, {"sha": "829a2abef0db23cb4f350c4ad2657b3e8450660e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -795,7 +795,7 @@ crate fn repr_nullable_ptr<'tcx>(\n         // Return the nullable type this Option-like enum can be safely represented with.\n         let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n         if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n-            match (field_ty_scalar.valid_range.start(), field_ty_scalar.valid_range.end()) {\n+            match (field_ty_scalar.valid_range.start, field_ty_scalar.valid_range.end) {\n                 (0, _) => unreachable!(\"Non-null optimisation extended to a non-zero value.\"),\n                 (1, _) => {\n                     return Some(get_nullable_type(cx, field_ty).unwrap());"}, {"sha": "0cbe57455a1c96fa3545b73c9afbc968841d6d04", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let scalar_unit = |value: Primitive| {\n             let bits = value.size(dl).bits();\n             assert!(bits <= 128);\n-            Scalar { value, valid_range: 0..=(!0 >> (128 - bits)) }\n+            Scalar { value, valid_range: WrappingRange { start: 0, end: (!0 >> (128 - bits)) } }\n         };\n         let scalar = |value: Primitive| tcx.intern_layout(Layout::scalar(self, scalar_unit(value)));\n \n@@ -512,11 +512,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             // Basic scalars.\n             ty::Bool => tcx.intern_layout(Layout::scalar(\n                 self,\n-                Scalar { value: Int(I8, false), valid_range: 0..=1 },\n+                Scalar { value: Int(I8, false), valid_range: WrappingRange { start: 0, end: 1 } },\n             )),\n             ty::Char => tcx.intern_layout(Layout::scalar(\n                 self,\n-                Scalar { value: Int(I32, false), valid_range: 0..=0x10FFFF },\n+                Scalar {\n+                    value: Int(I32, false),\n+                    valid_range: WrappingRange { start: 0, end: 0x10FFFF },\n+                },\n             )),\n             ty::Int(ity) => scalar(Int(Integer::from_int_ty(dl, ity), true)),\n             ty::Uint(ity) => scalar(Int(Integer::from_uint_ty(dl, ity), false)),\n@@ -526,7 +529,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }),\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n-                ptr.valid_range = 1..=*ptr.valid_range.end();\n+                ptr.valid_range = ptr.valid_range.with_start(1);\n                 tcx.intern_layout(Layout::scalar(self, ptr))\n             }\n \n@@ -544,7 +547,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n-                    data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n+                    data_ptr.valid_range = data_ptr.valid_range.with_start(1);\n                 }\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n@@ -560,7 +563,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n                     ty::Dynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n-                        vtable.valid_range = 1..=*vtable.valid_range.end();\n+                        vtable.valid_range = vtable.valid_range.with_start(1);\n                         vtable\n                     }\n                     _ => return Err(LayoutError::Unknown(unsized_part)),\n@@ -933,14 +936,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             if let Bound::Included(start) = start {\n                                 // FIXME(eddyb) this might be incorrect - it doesn't\n                                 // account for wrap-around (end < start) ranges.\n-                                assert!(*scalar.valid_range.start() <= start);\n-                                scalar.valid_range = start..=*scalar.valid_range.end();\n+                                assert!(scalar.valid_range.start <= start);\n+                                scalar.valid_range.start = start;\n                             }\n                             if let Bound::Included(end) = end {\n                                 // FIXME(eddyb) this might be incorrect - it doesn't\n                                 // account for wrap-around (end < start) ranges.\n-                                assert!(*scalar.valid_range.end() >= end);\n-                                scalar.valid_range = *scalar.valid_range.start()..=end;\n+                                assert!(scalar.valid_range.end >= end);\n+                                scalar.valid_range.end = end;\n                             }\n \n                             // Update `largest_niche` if we have introduced a larger niche.\n@@ -1256,7 +1259,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let tag_mask = !0u128 >> (128 - ity.size().bits());\n                 let tag = Scalar {\n                     value: Int(ity, signed),\n-                    valid_range: (min as u128 & tag_mask)..=(max as u128 & tag_mask),\n+                    valid_range: WrappingRange {\n+                        start: (min as u128 & tag_mask),\n+                        end: (max as u128 & tag_mask),\n+                    },\n                 };\n                 let mut abi = Abi::Aggregate { sized: true };\n                 if tag.value.size(dl) == size {\n@@ -1535,7 +1541,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n         let discr_int = Integer::fit_unsigned(max_discr);\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n-        let tag = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n+        let tag = Scalar {\n+            value: Primitive::Int(discr_int, false),\n+            valid_range: WrappingRange { start: 0, end: max_discr },\n+        };\n         let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag.clone()));\n         let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n@@ -2846,10 +2855,8 @@ where\n                 return;\n             }\n \n-            if scalar.valid_range.start() < scalar.valid_range.end() {\n-                if *scalar.valid_range.start() > 0 {\n-                    attrs.set(ArgAttribute::NonNull);\n-                }\n+            if !scalar.valid_range.contains_zero() {\n+                attrs.set(ArgAttribute::NonNull);\n             }\n \n             if let Some(pointee) = layout.pointee_info_at(cx, offset) {"}, {"sha": "2bb2f88725784f30186729c866eb728db7dffaeb", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -7,15 +7,16 @@\n use std::convert::TryFrom;\n use std::fmt::Write;\n use std::num::NonZeroUsize;\n-use std::ops::RangeInclusive;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, LayoutOf, Scalar as ScalarAbi, Size, VariantIdx, Variants};\n+use rustc_target::abi::{\n+    Abi, LayoutOf, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange,\n+};\n \n use std::hash::Hash;\n \n@@ -181,22 +182,10 @@ fn write_path(out: &mut String, path: &[PathElem]) {\n     }\n }\n \n-// Test if a range that wraps at overflow contains `test`\n-fn wrapping_range_contains(r: &RangeInclusive<u128>, test: u128) -> bool {\n-    let (lo, hi) = r.clone().into_inner();\n-    if lo > hi {\n-        // Wrapped\n-        (..=hi).contains(&test) || (lo..).contains(&test)\n-    } else {\n-        // Normal\n-        r.contains(&test)\n-    }\n-}\n-\n // Formats such that a sentence like \"expected something {}\" to mean\n // \"expected something <in the given range>\" makes sense.\n-fn wrapping_range_format(r: &RangeInclusive<u128>, max_hi: u128) -> String {\n-    let (lo, hi) = r.clone().into_inner();\n+fn wrapping_range_format(r: WrappingRange, max_hi: u128) -> String {\n+    let WrappingRange { start: lo, end: hi } = r;\n     assert!(hi <= max_hi);\n     if lo > hi {\n         format!(\"less or equal to {}, or greater or equal to {}\", hi, lo)\n@@ -634,8 +623,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         scalar_layout: &ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         let value = self.read_scalar(op)?;\n-        let valid_range = &scalar_layout.valid_range;\n-        let (lo, hi) = valid_range.clone().into_inner();\n+        let valid_range = scalar_layout.valid_range.clone();\n+        let WrappingRange { start: lo, end: hi } = valid_range;\n         // Determine the allowed range\n         // `max_hi` is as big as the size fits\n         let max_hi = u128::MAX >> (128 - op.layout.size.bits());\n@@ -684,7 +673,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             Ok(int) => int.assert_bits(op.layout.size),\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n-        if wrapping_range_contains(&valid_range, bits) {\n+        if valid_range.contains(bits) {\n             Ok(())\n         } else {\n             throw_validation_failure!(self.path,"}, {"sha": "d206df461200a6f1396d5a98c05938add7f3ded7", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 71, "deletions": 34, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5484cec0e3f60b2a0010505cd355639f75a2973/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=e5484cec0e3f60b2a0010505cd355639f75a2973", "patch": "@@ -677,32 +677,80 @@ impl Primitive {\n     }\n }\n \n+/// Inclusive wrap-around range of valid values, that is, if\n+/// start > end, it represents `start..=MAX`,\n+/// followed by `0..=end`.\n+///\n+/// That is, for an i8 primitive, a range of `254..=2` means following\n+/// sequence:\n+///\n+///    254 (-2), 255 (-1), 0, 1, 2\n+///\n+/// This is intended specifically to mirror LLVM\u2019s `!range` metadata,\n+/// semantics.\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(HashStable_Generic)]\n+pub struct WrappingRange {\n+    pub start: u128,\n+    pub end: u128,\n+}\n+\n+impl WrappingRange {\n+    /// Returns `true` if `v` is contained in the range.\n+    #[inline(always)]\n+    pub fn contains(&self, v: u128) -> bool {\n+        if self.start <= self.end {\n+            self.start <= v && v <= self.end\n+        } else {\n+            self.start <= v || v <= self.end\n+        }\n+    }\n+\n+    /// Returns `true` if zero is contained in the range.\n+    /// Equal to `range.contains(0)` but should be faster.\n+    #[inline(always)]\n+    pub fn contains_zero(&self) -> bool {\n+        self.start > self.end || self.start == 0\n+    }\n+\n+    /// Returns `self` with replaced `start`\n+    #[inline(always)]\n+    pub fn with_start(mut self, start: u128) -> Self {\n+        self.start = start;\n+        self\n+    }\n+\n+    /// Returns `self` with replaced `end`\n+    #[inline(always)]\n+    pub fn with_end(mut self, end: u128) -> Self {\n+        self.end = end;\n+        self\n+    }\n+}\n+\n+impl fmt::Debug for WrappingRange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(fmt, \"{}..={}\", self.start, self.end)?;\n+        Ok(())\n+    }\n+}\n+\n /// Information about one scalar component of a Rust type.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub struct Scalar {\n     pub value: Primitive,\n \n-    /// Inclusive wrap-around range of valid values, that is, if\n-    /// start > end, it represents `start..=MAX`,\n-    /// followed by `0..=end`.\n-    ///\n-    /// That is, for an i8 primitive, a range of `254..=2` means following\n-    /// sequence:\n-    ///\n-    ///    254 (-2), 255 (-1), 0, 1, 2\n-    ///\n-    /// This is intended specifically to mirror LLVM\u2019s `!range` metadata,\n-    /// semantics.\n     // FIXME(eddyb) always use the shortest range, e.g., by finding\n     // the largest space between two consecutive valid values and\n     // taking everything else as the (shortest) valid range.\n-    pub valid_range: RangeInclusive<u128>,\n+    pub valid_range: WrappingRange,\n }\n \n impl Scalar {\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.value, Int(I8, false)) && self.valid_range == (0..=1)\n+        matches!(self.value, Int(I8, false))\n+            && matches!(self.valid_range, WrappingRange { start: 0, end: 1 })\n     }\n \n     /// Returns the valid range as a `x..y` range.\n@@ -715,8 +763,8 @@ impl Scalar {\n         let bits = self.value.size(cx).bits();\n         assert!(bits <= 128);\n         let mask = !0u128 >> (128 - bits);\n-        let start = *self.valid_range.start();\n-        let end = *self.valid_range.end();\n+        let start = self.valid_range.start;\n+        let end = self.valid_range.end;\n         assert_eq!(start, start & mask);\n         assert_eq!(end, end & mask);\n         start..(end.wrapping_add(1) & mask)\n@@ -971,14 +1019,14 @@ impl Niche {\n         let max_value = !0u128 >> (128 - bits);\n \n         // Find out how many values are outside the valid range.\n-        let niche = v.end().wrapping_add(1)..*v.start();\n+        let niche = v.end.wrapping_add(1)..v.start;\n         niche.end.wrapping_sub(niche.start) & max_value\n     }\n \n     pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n         assert!(count > 0);\n \n-        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let Scalar { value, valid_range: v } = self.scalar.clone();\n         let bits = value.size(cx).bits();\n         assert!(bits <= 128);\n         let max_value = !0u128 >> (128 - bits);\n@@ -988,24 +1036,14 @@ impl Niche {\n         }\n \n         // Compute the range of invalid values being reserved.\n-        let start = v.end().wrapping_add(1) & max_value;\n-        let end = v.end().wrapping_add(count) & max_value;\n-\n-        // If the `end` of our range is inside the valid range,\n-        // then we ran out of invalid values.\n-        // FIXME(eddyb) abstract this with a wraparound range type.\n-        let valid_range_contains = |x| {\n-            if v.start() <= v.end() {\n-                *v.start() <= x && x <= *v.end()\n-            } else {\n-                *v.start() <= x || x <= *v.end()\n-            }\n-        };\n-        if valid_range_contains(end) {\n+        let start = v.end.wrapping_add(1) & max_value;\n+        let end = v.end.wrapping_add(count) & max_value;\n+\n+        if v.contains(end) {\n             return None;\n         }\n \n-        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n+        Some((start, Scalar { value, valid_range: v.with_end(end) }))\n     }\n }\n \n@@ -1212,9 +1250,8 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n             if zero {\n-                let range = &s.valid_range;\n                 // The range must contain 0.\n-                range.contains(&0) || (*range.start() > *range.end()) // wrap-around allows 0\n+                s.valid_range.contains_zero()\n             } else {\n                 // The range must include all values. `valid_range_exclusive` handles\n                 // the wrap-around using target arithmetic; with wrap-around then the full"}]}