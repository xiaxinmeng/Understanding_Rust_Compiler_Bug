{"sha": "fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlY2Q5MmE3ZmUwYjc3YWRiYjdmMWEzZDQzZmVlNDM2MDA2ZmE2YTU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-21T14:44:05Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-23T17:47:12Z"}, "message": "incr.comp.: Initial implemenation of append-only dep-graph.", "tree": {"sha": "e499be5d171e170b49f87d2fc2365ff1387490ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e499be5d171e170b49f87d2fc2365ff1387490ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "html_url": "https://github.com/rust-lang/rust/commit/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a83c3e777145bd2fd127857b3b73d5a174e1f2dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a83c3e777145bd2fd127857b3b73d5a174e1f2dd", "html_url": "https://github.com/rust-lang/rust/commit/a83c3e777145bd2fd127857b3b73d5a174e1f2dd"}], "stats": {"total": 331, "additions": 287, "deletions": 44}, "files": [{"sha": "b12db11cb6af692f83ba54042ffd179cfa9bc9d0", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "patch": "@@ -17,7 +17,7 @@ use std::mem;\n use super::{DepGraphQuery, DepKind, DepNode};\n use super::debug::EdgeFilter;\n \n-pub struct DepGraphEdges {\n+pub(super) struct DepGraphEdges {\n     nodes: Vec<DepNode>,\n     indices: FxHashMap<DepNode, DepNodeIndex>,\n     edges: FxHashSet<(DepNodeIndex, DepNodeIndex)>,\n@@ -31,8 +31,8 @@ pub struct DepGraphEdges {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DepNodeIndex {\n-    index: u32\n+pub(super) struct DepNodeIndex {\n+    index: u32,\n }\n \n impl DepNodeIndex {"}, {"sha": "b823ea71d1446fd532f56a784ea47539b1900a38", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 262, "deletions": 10, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n+use std::hash::Hash;\n use std::rc::Rc;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n@@ -22,7 +24,7 @@ use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n-use super::edges::{DepGraphEdges, DepNodeIndex};\n+use super::edges::{self, DepGraphEdges};\n \n #[derive(Clone)]\n pub struct DepGraph {\n@@ -38,10 +40,34 @@ pub struct DepGraph {\n     fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n }\n \n+/// As a temporary measure, while transitioning to the new DepGraph\n+/// implementation, we maintain the old and the new dep-graph encoding in\n+/// parallel, so a DepNodeIndex actually contains two indices, one for each\n+/// version.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DepNodeIndex {\n+    legacy: edges::DepNodeIndex,\n+    new: DepNodeIndexNew,\n+}\n+\n+impl DepNodeIndex {\n+    pub const INVALID: DepNodeIndex = DepNodeIndex {\n+        legacy: edges::DepNodeIndex::INVALID,\n+        new: DepNodeIndexNew::INVALID,\n+    };\n+}\n+\n struct DepGraphData {\n-    /// The actual graph data.\n+    /// The old, initial encoding of the dependency graph. This will soon go\n+    /// away.\n     edges: RefCell<DepGraphEdges>,\n \n+    /// The new encoding of the dependency graph, optimized for red/green\n+    /// tracking. The `current` field is the dependency graph of only the\n+    /// current compilation session: We don't merge the previous dep-graph into\n+    /// current one anymore.\n+    current: RefCell<CurrentDepGraph>,\n+\n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n@@ -63,6 +89,7 @@ impl DepGraph {\n                     work_products: RefCell::new(FxHashMap()),\n                     edges: RefCell::new(DepGraphEdges::new()),\n                     dep_node_debug: RefCell::new(FxHashMap()),\n+                    current: RefCell::new(CurrentDepGraph::new()),\n                 }))\n             } else {\n                 None\n@@ -82,7 +109,8 @@ impl DepGraph {\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges))\n+        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges,\n+                                                            &data.current))\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -130,6 +158,7 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n+            data.current.borrow_mut().push_task(key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n             };\n@@ -145,7 +174,9 @@ impl DepGraph {\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskEnd)\n             };\n-            let dep_node_index = data.edges.borrow_mut().pop_task(key);\n+\n+            let dep_node_index_legacy = data.edges.borrow_mut().pop_task(key);\n+            let dep_node_index_new = data.current.borrow_mut().pop_task(key);\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -155,7 +186,10 @@ impl DepGraph {\n                         .insert(key, stable_hasher.finish())\n                         .is_none());\n \n-            (result, dep_node_index)\n+            (result, DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            })\n         } else {\n             if key.kind.fingerprint_needed_for_crate_hash() {\n                 let mut hcx = cx.create_stable_hashing_context();\n@@ -180,9 +214,14 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_anon_task();\n+            data.current.borrow_mut().push_anon_task();\n             let result = op();\n-            let dep_node = data.edges.borrow_mut().pop_anon_task(dep_kind);\n-            (result, dep_node)\n+            let dep_node_index_legacy = data.edges.borrow_mut().pop_anon_task(dep_kind);\n+            let dep_node_index_new = data.current.borrow_mut().pop_anon_task(dep_kind);\n+            (result, DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            })\n         } else {\n             (op(), DepNodeIndex::INVALID)\n         }\n@@ -192,13 +231,15 @@ impl DepGraph {\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().read(v);\n+            data.current.borrow_mut().read(v);\n         }\n     }\n \n     #[inline]\n     pub fn read_index(&self, v: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().read_index(v);\n+            data.edges.borrow_mut().read_index(v.legacy);\n+            data.current.borrow_mut().read_index(v.new);\n         }\n     }\n \n@@ -215,7 +256,13 @@ impl DepGraph {\n \n     pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().add_node(node)\n+            let dep_node_index_legacy = data.edges.borrow_mut().add_node(node);\n+            let dep_node_index_new = data.current.borrow_mut()\n+                                                 .alloc_node(node, Vec::new());\n+            DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            }\n         } else {\n             DepNodeIndex::INVALID\n         }\n@@ -335,3 +382,208 @@ pub struct WorkProduct {\n     /// Saved files associated with this CGU\n     pub saved_files: Vec<(OutputType, String)>,\n }\n+\n+pub(super) struct CurrentDepGraph {\n+    nodes: IndexVec<DepNodeIndexNew, DepNode>,\n+    edges: IndexVec<DepNodeIndexNew, Vec<DepNodeIndexNew>>,\n+    node_to_node_index: FxHashMap<DepNode, DepNodeIndexNew>,\n+\n+    task_stack: Vec<OpenTask>,\n+}\n+\n+impl CurrentDepGraph {\n+    fn new() -> CurrentDepGraph {\n+        CurrentDepGraph {\n+            nodes: IndexVec::new(),\n+            edges: IndexVec::new(),\n+            node_to_node_index: FxHashMap(),\n+            task_stack: Vec::new(),\n+        }\n+    }\n+\n+    pub(super) fn push_ignore(&mut self) {\n+        self.task_stack.push(OpenTask::Ignore);\n+    }\n+\n+    pub(super) fn pop_ignore(&mut self) {\n+        let popped_node = self.task_stack.pop().unwrap();\n+        debug_assert_eq!(popped_node, OpenTask::Ignore);\n+    }\n+\n+    pub(super) fn push_task(&mut self, key: DepNode) {\n+        self.task_stack.push(OpenTask::Regular {\n+            node: key,\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    pub(super) fn pop_task(&mut self, key: DepNode) -> DepNodeIndexNew {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Regular {\n+            node,\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            debug_assert_eq!(node, key);\n+            self.alloc_node(node, reads)\n+        } else {\n+            bug!(\"pop_task() - Expected regular task to be popped\")\n+        }\n+    }\n+\n+    fn push_anon_task(&mut self) {\n+        self.task_stack.push(OpenTask::Anon {\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndexNew {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Anon {\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            let mut fingerprint = Fingerprint::zero();\n+            let mut hasher = StableHasher::new();\n+\n+            for &read in reads.iter() {\n+                let read_dep_node = self.nodes[read];\n+\n+                ::std::mem::discriminant(&read_dep_node.kind).hash(&mut hasher);\n+\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                fingerprint = fingerprint.combine(read_dep_node.hash);\n+            }\n+\n+            fingerprint = fingerprint.combine(hasher.finish());\n+\n+            let target_dep_node = DepNode {\n+                kind,\n+                hash: fingerprint,\n+            };\n+\n+            if let Some(&index) = self.node_to_node_index.get(&target_dep_node) {\n+                return index;\n+            }\n+\n+            self.alloc_node(target_dep_node, reads)\n+        } else {\n+            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n+        }\n+    }\n+\n+    fn read(&mut self, source: DepNode) {\n+        let dep_node_index = self.maybe_alloc_node(source);\n+        self.read_index(dep_node_index);\n+    }\n+\n+    fn read_index(&mut self, source: DepNodeIndexNew) {\n+        match self.task_stack.last_mut() {\n+            Some(&mut OpenTask::Regular {\n+                ref mut reads,\n+                ref mut read_set,\n+                node: _,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Anon {\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Ignore) | None => {\n+                // ignore\n+            }\n+        }\n+    }\n+\n+    fn alloc_node(&mut self,\n+                  dep_node: DepNode,\n+                  edges: Vec<DepNodeIndexNew>)\n+                  -> DepNodeIndexNew {\n+        debug_assert_eq!(self.edges.len(), self.nodes.len());\n+        debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n+        debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n+        let dep_node_index = DepNodeIndexNew::new(self.nodes.len());\n+        self.nodes.push(dep_node);\n+        self.node_to_node_index.insert(dep_node, dep_node_index);\n+        self.edges.push(edges);\n+        dep_node_index\n+    }\n+\n+    fn maybe_alloc_node(&mut self,\n+                        dep_node: DepNode)\n+                        -> DepNodeIndexNew {\n+        debug_assert_eq!(self.edges.len(), self.nodes.len());\n+        debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n+\n+        let CurrentDepGraph {\n+            ref mut node_to_node_index,\n+            ref mut nodes,\n+            ref mut edges,\n+            ..\n+        } = *self;\n+\n+        *node_to_node_index.entry(dep_node).or_insert_with(|| {\n+            let next_id = nodes.len();\n+            nodes.push(dep_node);\n+            edges.push(Vec::new());\n+            DepNodeIndexNew::new(next_id)\n+        })\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub(super) struct DepNodeIndexNew {\n+    index: u32,\n+}\n+\n+impl Idx for DepNodeIndexNew {\n+    fn new(idx: usize) -> Self {\n+        DepNodeIndexNew::new(idx)\n+    }\n+    fn index(self) -> usize {\n+        self.index()\n+    }\n+}\n+\n+impl DepNodeIndexNew {\n+\n+    const INVALID: DepNodeIndexNew = DepNodeIndexNew {\n+        index: ::std::u32::MAX,\n+    };\n+\n+    fn new(v: usize) -> DepNodeIndexNew {\n+        assert!((v & 0xFFFF_FFFF) == v);\n+        DepNodeIndexNew { index: v as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum OpenTask {\n+    Regular {\n+        node: DepNode,\n+        reads: Vec<DepNodeIndexNew>,\n+        read_set: FxHashSet<DepNodeIndexNew>,\n+    },\n+    Anon {\n+        reads: Vec<DepNodeIndexNew>,\n+        read_set: FxHashSet<DepNodeIndexNew>,\n+    },\n+    Ignore,\n+}"}, {"sha": "1a4c5381abf3b6661f00c3d47e79fbbd25136387", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "patch": "@@ -22,10 +22,9 @@ pub use self::dep_node::DepNode;\n pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n-pub use self::edges::DepNodeIndex;\n+pub use self::graph::DepNodeIndex;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::raii::DepTask;\n \n pub use self::dep_node::{DepKind, DepConstructor};"}, {"sha": "6e9e4f4a18b15ca8e9b6185e0ae5d8cc60357eee", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "patch": "@@ -8,50 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::DepNode;\n use super::edges::DepGraphEdges;\n+use super::graph::CurrentDepGraph;\n \n use std::cell::RefCell;\n \n-pub struct DepTask<'graph> {\n-    graph: &'graph RefCell<DepGraphEdges>,\n-    key: DepNode,\n-}\n-\n-impl<'graph> DepTask<'graph> {\n-    pub fn new(graph: &'graph RefCell<DepGraphEdges>,\n-               key: DepNode)\n-               -> DepTask<'graph> {\n-        graph.borrow_mut().push_task(key);\n-        DepTask {\n-            graph,\n-            key,\n-        }\n-    }\n-}\n-\n-impl<'graph> Drop for DepTask<'graph> {\n-    fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_task(self.key);\n-    }\n-}\n-\n pub struct IgnoreTask<'graph> {\n-    graph: &'graph RefCell<DepGraphEdges>,\n+    legacy_graph: &'graph RefCell<DepGraphEdges>,\n+    new_graph: &'graph RefCell<CurrentDepGraph>,\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub fn new(graph: &'graph RefCell<DepGraphEdges>) -> IgnoreTask<'graph> {\n-        graph.borrow_mut().push_ignore();\n+    pub(super) fn new(legacy_graph: &'graph RefCell<DepGraphEdges>,\n+                      new_graph: &'graph RefCell<CurrentDepGraph>)\n+                      -> IgnoreTask<'graph> {\n+        legacy_graph.borrow_mut().push_ignore();\n+        new_graph.borrow_mut().push_ignore();\n         IgnoreTask {\n-            graph\n+            legacy_graph,\n+            new_graph,\n         }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_ignore();\n+        self.legacy_graph.borrow_mut().pop_ignore();\n+        self.new_graph.borrow_mut().pop_ignore();\n     }\n }\n "}, {"sha": "80fadcda2775d426501f90b5ceb66811834d00a9", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=fecd92a7fe0b77adbb7f1a3d43fee436006fa6a5", "patch": "@@ -88,6 +88,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             ).1;\n         }\n \n+        {\n+            dep_graph.with_task(\n+                DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n+                &hcx,\n+                &krate.trait_impls,\n+                identity_fn\n+            );\n+        }\n+\n         let hir_body_nodes = vec![root_mod_def_path_hash];\n \n         let mut collector = NodeCollector {"}]}