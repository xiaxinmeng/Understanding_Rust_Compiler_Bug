{"sha": "bdad2d427d097fd778b41fa8891a561d756ea373", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYWQyZDQyN2QwOTdmZDc3OGI0MWZhODg5MWE1NjFkNzU2ZWEzNzM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-24T12:29:56Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-24T12:29:56Z"}, "message": "Implement SetDiscriminant", "tree": {"sha": "8695cdb3d64166f1194afeccabf943509ba1efbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8695cdb3d64166f1194afeccabf943509ba1efbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdad2d427d097fd778b41fa8891a561d756ea373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdad2d427d097fd778b41fa8891a561d756ea373", "html_url": "https://github.com/rust-lang/rust/commit/bdad2d427d097fd778b41fa8891a561d756ea373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdad2d427d097fd778b41fa8891a561d756ea373/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c53d58f92395b2168dbc94b45bc472430a20ee26", "url": "https://api.github.com/repos/rust-lang/rust/commits/c53d58f92395b2168dbc94b45bc472430a20ee26", "html_url": "https://github.com/rust-lang/rust/commit/c53d58f92395b2168dbc94b45bc472430a20ee26"}], "stats": {"total": 63, "additions": 30, "deletions": 33}, "files": [{"sha": "6aa67721256b61f498752fa16bfd815da5f53230", "filename": "src/base.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2d427d097fd778b41fa8891a561d756ea373/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2d427d097fd778b41fa8891a561d756ea373/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=bdad2d427d097fd778b41fa8891a561d756ea373", "patch": "@@ -292,59 +292,47 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n \n fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx>) {\n     match &stmt.kind {\n-        /*StatementKind::SetDiscriminant { place, variant_index } => {\n-            if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n+        StatementKind::SetDiscriminant { place, variant_index } => {\n+            let place_ty = fx.monomorphize(&place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n+            let place = trans_place(fx, place);\n+            let layout = fx.layout_of(place_ty);\n+            if layout.for_variant(&*fx, *variant_index).abi == layout::Abi::Uninhabited {\n                 return;\n             }\n-            match self.layout.variants {\n+            match layout.variants {\n                 layout::Variants::Single { index } => {\n-                    assert_eq!(index, variant_index);\n+                    assert_eq!(index, *variant_index);\n                 }\n                 layout::Variants::Tagged { .. } => {\n-                    let ptr = self.project_field(bx, 0);\n-                    let to = self.layout.ty.ty_adt_def().unwrap()\n-                        .discriminant_for_variant(bx.tcx(), variant_index)\n+                    let ptr = place.place_field(fx, mir::Field::new(0), place_ty);\n+                    let to = layout.ty.ty_adt_def().unwrap()\n+                        .discriminant_for_variant(fx.tcx, *variant_index)\n                         .val;\n-                    bx.store(\n-                        C_uint_big(ptr.layout.llvm_type(bx.cx), to),\n-                        ptr.llval,\n-                        ptr.align);\n+                    let discr = CValue::const_val(fx, ptr.1.ty, to as u64 as i64);\n+                    ptr.0.write_cvalue(fx, discr, ptr.1.ty);\n                 }\n                 layout::Variants::NicheFilling {\n                     dataful_variant,\n                     ref niche_variants,\n                     niche_start,\n                     ..\n                 } => {\n-                    if variant_index != dataful_variant {\n-                        if bx.sess().target.target.arch == \"arm\" ||\n-                        bx.sess().target.target.arch == \"aarch64\" {\n-                            // Issue #34427: As workaround for LLVM bug on ARM,\n-                            // use memset of 0 before assigning niche value.\n-                            let llptr = bx.pointercast(self.llval, Type::i8(bx.cx).ptr_to());\n-                            let fill_byte = C_u8(bx.cx, 0);\n-                            let (size, align) = self.layout.size_and_align();\n-                            let size = C_usize(bx.cx, size.bytes());\n-                            let align = C_u32(bx.cx, align.abi() as u32);\n-                            base::call_memset(bx, llptr, fill_byte, size, align, false);\n-                        }\n-\n-                        let niche = self.project_field(bx, 0);\n-                        let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n+                    if *variant_index != dataful_variant {\n+                        let niche = place.place_field(fx, mir::Field::new(0), place_ty);\n+                        //let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n                         let niche_value = ((variant_index - *niche_variants.start()) as u128)\n                             .wrapping_add(niche_start);\n                         // FIXME(eddyb) Check the actual primitive type here.\n                         let niche_llval = if niche_value == 0 {\n-                            // HACK(eddyb) Using `C_null` as it works on all types.\n-                            C_null(niche_llty)\n+                            CValue::const_val(fx, niche.1.ty, 0)\n                         } else {\n-                            C_uint_big(niche_llty, niche_value)\n+                            CValue::const_val(fx, niche.1.ty, niche_value as u64 as i64)\n                         };\n-                        OperandValue::Immediate(niche_llval).store(bx, niche);\n+                        niche.0.write_cvalue(fx, niche_llval, niche.1.ty);\n                     }\n                 }\n             }\n-        }*/\n+        }\n         StatementKind::Assign(to_place, rval) => {\n             let dest_ty = fx.monomorphize(&to_place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n             let lval = trans_place(fx, to_place);\n@@ -402,6 +390,15 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                                 bin_op => unimplemented!(\"checked uint bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n                             }\n                         }\n+                        TypeVariants::TyInt(_) => {\n+                            match bin_op {\n+                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n+                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n+                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n+                                BinOp::Div => fx.bcx.ins().sdiv(lhs, rhs),\n+                                bin_op => unimplemented!(\"checked int bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n+                            }\n+                        }\n                         _ => unimplemented!(),\n                     };\n                     lval.write_cvalue(fx, CValue::ByVal(res), ty);\n@@ -493,10 +490,10 @@ fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>)\n         Place::Local(local) => fx.get_local_place(*local),\n         Place::Projection(projection) => {\n             let base = trans_place(fx, &projection.base);\n-            let place_ty = fx.monomorphize(&place.ty(&*fx.mir, fx.tcx)).to_ty(fx.tcx);\n+            let base_ty = projection.base.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx);\n             match projection.elem {\n                 ProjectionElem::Deref => {\n-                    CPlace::Addr(base.to_cvalue(fx).load_value(fx, place_ty))\n+                    CPlace::Addr(base.to_cvalue(fx).load_value(fx, base_ty))\n                 }\n                 ProjectionElem::Field(field, ty) => {\n                     base.place_field(fx, field, ty).0"}]}