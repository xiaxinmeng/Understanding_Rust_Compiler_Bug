{"sha": "8454ee89b2f519a5436a4699c7f65b76ee4fb259", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NTRlZTg5YjJmNTE5YTU0MzZhNDY5OWM3ZjY1Yjc2ZWU0ZmIyNTk=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-07-20T14:44:43Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-07-21T01:22:14Z"}, "message": "Migrate rustc_depr uses to use deprecation attribute\n\nThis should not be a change in behavior.", "tree": {"sha": "9e41d757f7672ef04b8165e907159c37d6b67653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e41d757f7672ef04b8165e907159c37d6b67653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8454ee89b2f519a5436a4699c7f65b76ee4fb259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8454ee89b2f519a5436a4699c7f65b76ee4fb259", "html_url": "https://github.com/rust-lang/rust/commit/8454ee89b2f519a5436a4699c7f65b76ee4fb259", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8454ee89b2f519a5436a4699c7f65b76ee4fb259/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21a3d294dc096422ebdd492d06d4e4ba4998d8a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/21a3d294dc096422ebdd492d06d4e4ba4998d8a2", "html_url": "https://github.com/rust-lang/rust/commit/21a3d294dc096422ebdd492d06d4e4ba4998d8a2"}], "stats": {"total": 319, "additions": 138, "deletions": 181}, "files": [{"sha": "1e088b52dcc35b5fffb03d09cde40843b6801e81", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -129,7 +129,6 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: Symbol,\n-    pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// Represents the `#[rustc_const_unstable]` and `#[rustc_const_stable]` attributes.\n@@ -162,15 +161,6 @@ impl StabilityLevel {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n-#[derive(HashStable_Generic)]\n-pub struct RustcDeprecation {\n-    pub since: Symbol,\n-    pub reason: Symbol,\n-    /// A text snippet used to completely replace any use of the deprecated item in an expression.\n-    pub suggestion: Option<Symbol>,\n-}\n-\n /// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n@@ -204,7 +194,6 @@ where\n     use StabilityLevel::*;\n \n     let mut stab: Option<Stability> = None;\n-    let mut rustc_depr: Option<RustcDeprecation> = None;\n     let mut const_stab: Option<ConstStability> = None;\n     let mut promotable = false;\n     let mut allow_const_fn_ptr = false;\n@@ -256,45 +245,6 @@ where\n                 }\n             };\n \n-            macro_rules! get_meta {\n-                ($($name:ident),+) => {\n-                    $(\n-                        let mut $name = None;\n-                    )+\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty() {\n-                                $(\n-                                    sym::$name => if !get(mi, &mut $name) { continue 'outer },\n-                                )+\n-                                _ => {\n-                                    let expected = &[ $( stringify!($name) ),+ ];\n-                                    handle_errors(\n-                                        sess,\n-                                        mi.span,\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            expected,\n-                                        ),\n-                                    );\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(\n-                                sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(\n-                                    \"unsupported literal\",\n-                                    false,\n-                                ),\n-                            );\n-                            continue 'outer\n-                        }\n-                    }\n-                }\n-            }\n-\n             let meta_name = meta.name_or_empty();\n             match meta_name {\n                 sym::rustc_const_unstable | sym::unstable => {\n@@ -398,7 +348,7 @@ where\n                         (Some(feature), reason, Some(_)) => {\n                             let level = Unstable { reason, issue: issue_num, is_soft };\n                             if sym::unstable == meta_name {\n-                                stab = Some(Stability { level, feature, rustc_depr: None });\n+                                stab = Some(Stability { level, feature });\n                             } else {\n                                 const_stab = Some(ConstStability {\n                                     level,\n@@ -470,7 +420,7 @@ where\n                         (Some(feature), Some(since)) => {\n                             let level = Stable { since };\n                             if sym::stable == meta_name {\n-                                stab = Some(Stability { level, feature, rustc_depr: None });\n+                                stab = Some(Stability { level, feature });\n                             } else {\n                                 const_stab = Some(ConstStability {\n                                     level,"}, {"sha": "5f7ff54fd31c3ee5a3e329752aa59e6e19e96ad4", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -5,7 +5,7 @@ pub use self::StabilityLevel::*;\n \n use crate::ty::{self, TyCtxt};\n use rustc_ast::ast::CRATE_NODE_ID;\n-use rustc_attr::{self as attr, ConstStability, Deprecation, RustcDeprecation, Stability};\n+use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::GateIssue;\n@@ -130,14 +130,26 @@ pub fn report_unstable(\n \n /// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n-pub fn deprecation_in_effect(since: &str) -> bool {\n+pub fn deprecation_in_effect(is_since_rustc_version: bool, since: Option<&str>) -> bool {\n+    let since = if let Some(since) = since {\n+        if is_since_rustc_version {\n+            since\n+        } else {\n+            // We assume that the deprecation is in effect if it's not a\n+            // rustc version.\n+            return true;\n+        }\n+    } else {\n+        // If since attribute is not set, then we're definitely in effect.\n+        return true;\n+    };\n     fn parse_version(ver: &str) -> Vec<u32> {\n         // We ignore non-integer components of the version (e.g., \"nightly\").\n         ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n     }\n \n     if let Some(rustc) = option_env!(\"CFG_RELEASE\") {\n-        let since: Vec<u32> = parse_version(since);\n+        let since: Vec<u32> = parse_version(&since);\n         let rustc: Vec<u32> = parse_version(rustc);\n         // We simply treat invalid `since` attributes as relating to a previous\n         // Rust version, thus always displaying the warning.\n@@ -167,31 +179,27 @@ pub fn deprecation_suggestion(\n     }\n }\n \n-fn deprecation_message_common(message: String, reason: Option<Symbol>) -> String {\n-    match reason {\n-        Some(reason) => format!(\"{}: {}\", message, reason),\n-        None => message,\n-    }\n-}\n-\n pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n-    let message = format!(\"use of deprecated item '{}'\", path);\n-    (deprecation_message_common(message, depr.note), DEPRECATED)\n-}\n-\n-pub fn rustc_deprecation_message(depr: &RustcDeprecation, path: &str) -> (String, &'static Lint) {\n-    let (message, lint) = if deprecation_in_effect(&depr.since.as_str()) {\n+    let (message, lint) = if deprecation_in_effect(\n+        depr.is_since_rustc_version,\n+        depr.since.map(Symbol::as_str).as_deref(),\n+    ) {\n         (format!(\"use of deprecated item '{}'\", path), DEPRECATED)\n     } else {\n         (\n             format!(\n                 \"use of item '{}' that will be deprecated in future version {}\",\n-                path, depr.since\n+                path,\n+                depr.since.unwrap()\n             ),\n             DEPRECATED_IN_FUTURE,\n         )\n     };\n-    (deprecation_message_common(message, Some(depr.reason)), lint)\n+    let message = match depr.note {\n+        Some(reason) => format!(\"{}: {}\", message, reason),\n+        None => message,\n+    };\n+    (message, lint)\n }\n \n pub fn early_report_deprecation(\n@@ -289,10 +297,23 @@ impl<'tcx> TyCtxt<'tcx> {\n                     .lookup_deprecation_entry(parent_def_id.to_def_id())\n                     .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n-                if !skip {\n+                // #[deprecated] doesn't emit a notice if we're not on the\n+                // topmost deprecation. For example, if a struct is deprecated,\n+                // the use of a field won't be linted.\n+                //\n+                // #[rustc_deprecated] however wants to emit down the whole\n+                // hierarchy.\n+                if !skip || depr_entry.attr.is_since_rustc_version {\n                     let (message, lint) =\n                         deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, None, lint, span, id);\n+                    late_report_deprecation(\n+                        self,\n+                        &message,\n+                        depr_entry.attr.suggestion,\n+                        lint,\n+                        span,\n+                        id,\n+                    );\n                 }\n             };\n         }\n@@ -310,16 +331,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             def_id, span, stability\n         );\n \n-        if let Some(id) = id {\n-            if let Some(stability) = stability {\n-                if let Some(depr) = &stability.rustc_depr {\n-                    let (message, lint) =\n-                        rustc_deprecation_message(depr, &self.def_path_str(def_id));\n-                    late_report_deprecation(self, &message, depr.suggestion, lint, span, id);\n-                }\n-            }\n-        }\n-\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !def_id.is_local();\n         if !cross_crate {"}, {"sha": "830af8d31e7a6a3b48baa76f6f72ffb05624c9a6", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -59,20 +59,50 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n+        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n+        let mut did_error = false;\n         if !self.tcx.features().staged_api {\n-            self.forbid_staged_api_attrs(hir_id, attrs, item_sp, kind, visit_children);\n-            return;\n+            did_error = self.forbid_staged_api_attrs(hir_id, attrs);\n         }\n \n-        // This crate explicitly wants staged API.\n+        let depr = if did_error {\n+            None\n+        } else {\n+            attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp)\n+        };\n+        let mut is_deprecated = false;\n+        if let Some(depr) = &depr {\n+            is_deprecated = true;\n \n-        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n-        if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-            self.tcx.sess.span_err(\n-                item_sp,\n-                \"`#[deprecated]` cannot be used in staged API; \\\n-                                             use `#[rustc_deprecated]` instead\",\n+            if kind == AnnotationKind::Prohibited {\n+                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+            }\n+\n+            // `Deprecation` is just two pointers, no need to intern it\n+            let depr_entry = DeprecationEntry::local(depr.clone(), hir_id);\n+            self.index.depr_map.insert(hir_id, depr_entry);\n+        } else if let Some(parent_depr) = self.parent_depr.clone() {\n+            is_deprecated = true;\n+            info!(\"tagging child {:?} as deprecated from parent\", hir_id);\n+            self.index.depr_map.insert(hir_id, parent_depr);\n+        }\n+\n+        if self.tcx.features().staged_api {\n+            if let Some(..) = attrs.iter().find(|a| a.check_name(sym::deprecated)) {\n+                self.tcx.sess.span_err(\n+                    item_sp,\n+                    \"`#[deprecated]` cannot be used in staged API; \\\n+                                                use `#[rustc_deprecated]` instead\",\n+                );\n+            }\n+        } else {\n+            self.recurse_with_stability_attrs(\n+                depr.map(|d| DeprecationEntry::local(d, hir_id)),\n+                None,\n+                None,\n+                visit_children,\n             );\n+            return;\n         }\n \n         let (stab, const_stab) = attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n@@ -92,33 +122,34 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        let stab = stab.map(|mut stab| {\n+        if depr.as_ref().map_or(false, |d| d.is_since_rustc_version) {\n+            if stab.is_none() {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    item_sp,\n+                    E0549,\n+                    \"rustc_deprecated attribute must be paired with \\\n+                    either stable or unstable attribute\"\n+                )\n+                .emit();\n+            }\n+        }\n+\n+        let stab = stab.map(|stab| {\n             // Error if prohibited, or can't inherit anything from a container.\n             if kind == AnnotationKind::Prohibited\n-                || (kind == AnnotationKind::Container\n-                    && stab.level.is_stable()\n-                    && stab.rustc_depr.is_none())\n+                || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n                 self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n-            // If parent is deprecated and we're not, inherit this by merging\n-            // deprecated_since and its reason.\n-            if let Some(parent_stab) = self.parent_stab {\n-                if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                    stab.rustc_depr = parent_stab.rustc_depr\n-                }\n-            }\n-\n             let stab = self.tcx.intern_stability(stab);\n \n             // Check if deprecated_since < stable_since. If it is,\n             // this is *almost surely* an accident.\n-            if let (\n-                &Some(attr::RustcDeprecation { since: dep_since, .. }),\n-                &attr::Stable { since: stab_since },\n-            ) = (&stab.rustc_depr, &stab.level)\n+            if let (&Some(dep_since), &attr::Stable { since: stab_since }) =\n+                (&depr.as_ref().and_then(|d| d.since), &stab.level)\n             {\n                 // Explicit version of iter::order::lt to handle parse errors properly\n                 for (dep_v, stab_v) in\n@@ -163,19 +194,29 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        self.recurse_with_stability_attrs(stab, const_stab, visit_children);\n+        self.recurse_with_stability_attrs(\n+            depr.map(|d| DeprecationEntry::local(d, hir_id)),\n+            stab,\n+            const_stab,\n+            visit_children,\n+        );\n     }\n \n     fn recurse_with_stability_attrs(\n         &mut self,\n+        depr: Option<DeprecationEntry>,\n         stab: Option<&'tcx Stability>,\n         const_stab: Option<&'tcx ConstStability>,\n         f: impl FnOnce(&mut Self),\n     ) {\n         // These will be `Some` if this item changes the corresponding stability attribute.\n+        let mut replaced_parent_depr = None;\n         let mut replaced_parent_stab = None;\n         let mut replaced_parent_const_stab = None;\n \n+        if let Some(depr) = depr {\n+            replaced_parent_depr = Some(replace(&mut self.parent_depr, Some(depr)));\n+        }\n         if let Some(stab) = stab {\n             replaced_parent_stab = Some(replace(&mut self.parent_stab, Some(stab)));\n         }\n@@ -186,6 +227,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         f(self);\n \n+        if let Some(orig_parent_depr) = replaced_parent_depr {\n+            self.parent_depr = orig_parent_depr;\n+        }\n         if let Some(orig_parent_stab) = replaced_parent_stab {\n             self.parent_stab = orig_parent_stab;\n         }\n@@ -194,14 +238,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n     }\n \n-    fn forbid_staged_api_attrs(\n-        &mut self,\n-        hir_id: HirId,\n-        attrs: &[Attribute],\n-        item_sp: Span,\n-        kind: AnnotationKind,\n-        visit_children: impl FnOnce(&mut Self),\n-    ) {\n+    // returns true if an error occurred, used to suppress some spurious errors\n+    fn forbid_staged_api_attrs(&mut self, hir_id: HirId, attrs: &[Attribute]) -> bool {\n         // Emit errors for non-staged-api crates.\n         let unstable_attrs = [\n             sym::unstable,\n@@ -210,6 +248,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             sym::rustc_const_unstable,\n             sym::rustc_const_stable,\n         ];\n+        let mut has_error = false;\n         for attr in attrs {\n             let name = attr.name_or_empty();\n             if unstable_attrs.contains(&name) {\n@@ -221,6 +260,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                     \"stability attributes may not be used outside of the standard library\",\n                 )\n                 .emit();\n+                has_error = true;\n             }\n         }\n \n@@ -232,24 +272,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n-        if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n-            if kind == AnnotationKind::Prohibited {\n-                self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n-            }\n-\n-            // `Deprecation` is just two pointers, no need to intern it\n-            let depr_entry = DeprecationEntry::local(depr, hir_id);\n-            self.index.depr_map.insert(hir_id, depr_entry.clone());\n-\n-            let orig_parent_depr = replace(&mut self.parent_depr, Some(depr_entry));\n-            visit_children(self);\n-            self.parent_depr = orig_parent_depr;\n-        } else if let Some(parent_depr) = self.parent_depr.clone() {\n-            self.index.depr_map.insert(hir_id, parent_depr);\n-            visit_children(self);\n-        } else {\n-            visit_children(self);\n-        }\n+        has_error\n     }\n }\n \n@@ -454,7 +477,6 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n                     is_soft: false,\n                 },\n                 feature: sym::rustc_private,\n-                rustc_depr: None,\n             });\n             annotator.parent_stab = Some(stability);\n         }"}, {"sha": "fee7cb4836e3d6a61e11901540979b02f4e33b23", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -1017,22 +1017,17 @@ impl<'a> Resolver<'a> {\n                     );\n                 }\n             }\n-            if let Some(depr) = &stability.rustc_depr {\n-                let path = pprust::path_to_string(path);\n-                let (message, lint) = stability::rustc_deprecation_message(depr, &path);\n-                stability::early_report_deprecation(\n-                    &mut self.lint_buffer,\n-                    &message,\n-                    depr.suggestion,\n-                    lint,\n-                    span,\n-                );\n-            }\n         }\n         if let Some(depr) = &ext.deprecation {\n             let path = pprust::path_to_string(&path);\n             let (message, lint) = stability::deprecation_message(depr, &path);\n-            stability::early_report_deprecation(&mut self.lint_buffer, &message, None, lint, span);\n+            stability::early_report_deprecation(\n+                &mut self.lint_buffer,\n+                &message,\n+                depr.suggestion,\n+                lint,\n+                span,\n+            );\n         }\n     }\n "}, {"sha": "94d95115dcdbcaed7bfd447b6cc22331da063d87", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -2353,10 +2353,6 @@ impl Clean<Stability> for attr::Stability {\n                 attr::Stable { ref since } => since.to_string(),\n                 _ => String::new(),\n             },\n-            deprecation: self.rustc_depr.as_ref().map(|d| Deprecation {\n-                note: Some(d.reason.to_string()).filter(|r| !r.is_empty()),\n-                since: Some(d.since.to_string()).filter(|d| !d.is_empty()),\n-            }),\n             unstable_reason: match self.level {\n                 attr::Unstable { reason: Some(ref reason), .. } => Some(reason.to_string()),\n                 _ => None,\n@@ -2374,6 +2370,7 @@ impl Clean<Deprecation> for attr::Deprecation {\n         Deprecation {\n             since: self.since.map(|s| s.to_string()).filter(|s| !s.is_empty()),\n             note: self.note.map(|n| n.to_string()).filter(|n| !n.is_empty()),\n+            is_since_rustc_version: self.is_since_rustc_version,\n         }\n     }\n }"}, {"sha": "071834c59d65ec749aafa5f8b4a72113638b74d7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -195,7 +195,8 @@ impl Item {\n                 classes.push(\"unstable\");\n             }\n \n-            if s.deprecation.is_some() {\n+            // FIXME: what about non-staged API items that are deprecated?\n+            if self.deprecation.is_some() {\n                 classes.push(\"deprecated\");\n             }\n \n@@ -216,14 +217,6 @@ impl Item {\n         ItemType::from(self)\n     }\n \n-    /// Returns the info in the item's `#[deprecated]` or `#[rustc_deprecated]` attributes.\n-    ///\n-    /// If the item is not deprecated, returns `None`.\n-    pub fn deprecation(&self) -> Option<&Deprecation> {\n-        self.deprecation\n-            .as_ref()\n-            .or_else(|| self.stability.as_ref().and_then(|s| s.deprecation.as_ref()))\n-    }\n     pub fn is_default(&self) -> bool {\n         match self.inner {\n             ItemEnum::MethodItem(ref meth) => {\n@@ -1528,7 +1521,6 @@ pub struct Stability {\n     pub level: stability::StabilityLevel,\n     pub feature: Option<String>,\n     pub since: String,\n-    pub deprecation: Option<Deprecation>,\n     pub unstable_reason: Option<String>,\n     pub issue: Option<NonZeroU32>,\n }\n@@ -1537,6 +1529,7 @@ pub struct Stability {\n pub struct Deprecation {\n     pub since: Option<String>,\n     pub note: Option<String>,\n+    pub is_since_rustc_version: bool,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or"}, {"sha": "f7050cf377722622eee91859903f82a04b0cf5d0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8454ee89b2f519a5436a4699c7f65b76ee4fb259/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8454ee89b2f519a5436a4699c7f65b76ee4fb259", "patch": "@@ -2216,16 +2216,10 @@ fn stability_tags(item: &clean::Item) -> String {\n     }\n \n     // The trailing space after each tag is to space it properly against the rest of the docs.\n-    if item.deprecation().is_some() {\n+    if let Some(depr) = &item.deprecation {\n         let mut message = \"Deprecated\";\n-        if let Some(ref stab) = item.stability {\n-            if let Some(ref depr) = stab.deprecation {\n-                if let Some(ref since) = depr.since {\n-                    if !stability::deprecation_in_effect(&since) {\n-                        message = \"Deprecation planned\";\n-                    }\n-                }\n-            }\n+        if !stability::deprecation_in_effect(depr.is_since_rustc_version, depr.since.as_deref()) {\n+            message = \"Deprecation planned\";\n         }\n         tags += &tag_html(\"deprecated\", message);\n     }\n@@ -2254,23 +2248,18 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     let mut stability = vec![];\n     let error_codes = cx.shared.codes;\n \n-    if let Some(Deprecation { note, since }) = &item.deprecation() {\n+    if let Some(Deprecation { ref note, ref since, is_since_rustc_version }) = item.deprecation {\n         // We display deprecation messages for #[deprecated] and #[rustc_deprecated]\n         // but only display the future-deprecation messages for #[rustc_deprecated].\n         let mut message = if let Some(since) = since {\n-            format!(\"Deprecated since {}\", Escape(since))\n+            if !stability::deprecation_in_effect(is_since_rustc_version, Some(since)) {\n+                format!(\"Deprecating in {}\", Escape(&since))\n+            } else {\n+                format!(\"Deprecated since {}\", Escape(&since))\n+            }\n         } else {\n             String::from(\"Deprecated\")\n         };\n-        if let Some(ref stab) = item.stability {\n-            if let Some(ref depr) = stab.deprecation {\n-                if let Some(ref since) = depr.since {\n-                    if !stability::deprecation_in_effect(&since) {\n-                        message = format!(\"Deprecating in {}\", Escape(&since));\n-                    }\n-                }\n-            }\n-        }\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();"}]}