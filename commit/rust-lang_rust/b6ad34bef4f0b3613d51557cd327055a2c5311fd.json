{"sha": "b6ad34bef4f0b3613d51557cd327055a2c5311fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2YWQzNGJlZjRmMGIzNjEzZDUxNTU3Y2QzMjcwNTVhMmM1MzExZmQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-09T12:35:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T09:22:46Z"}, "message": "Properly recognize external intrinsics", "tree": {"sha": "9d94307570687aedc031e0e8b8b16a6b8cd4f9fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d94307570687aedc031e0e8b8b16a6b8cd4f9fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6ad34bef4f0b3613d51557cd327055a2c5311fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ad34bef4f0b3613d51557cd327055a2c5311fd", "html_url": "https://github.com/rust-lang/rust/commit/b6ad34bef4f0b3613d51557cd327055a2c5311fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6ad34bef4f0b3613d51557cd327055a2c5311fd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4cbd43c430ef0d5f63ca7cb86a65a618521e175", "html_url": "https://github.com/rust-lang/rust/commit/e4cbd43c430ef0d5f63ca7cb86a65a618521e175"}], "stats": {"total": 154, "additions": 89, "deletions": 65}, "files": [{"sha": "88800e17affa39713ed0128add522c777f8468bb", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=b6ad34bef4f0b3613d51557cd327055a2c5311fd", "patch": "@@ -68,6 +68,7 @@ const tag_mod_impl: uint = 0x30u;\n \n const tag_item_method: uint = 0x31u;\n const tag_impl_iface: uint = 0x32u;\n+const tag_item_is_intrinsic: uint = 0x33u;\n \n // discriminator value for variants\n const tag_disr_val: uint = 0x34u;"}, {"sha": "088367038364e1af085cf9519aeb11bc14d04a91", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=b6ad34bef4f0b3613d51557cd327055a2c5311fd", "patch": "@@ -19,6 +19,7 @@ export get_type;\n export get_impl_iface;\n export get_impl_method;\n export get_item_path;\n+export item_is_intrinsic;\n export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n@@ -134,6 +135,11 @@ fn get_impl_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n     decoder::get_impl_method(cdata, def.node, mname)\n }\n \n+fn item_is_intrinsic(cstore: cstore::cstore, def: ast::def_id) -> bool {\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::item_is_intrinsic(cdata, def.node)\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "70c771b85c1e7b2913d2a46b422761cb3df855e4", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b6ad34bef4f0b3613d51557cd327055a2c5311fd", "patch": "@@ -34,6 +34,7 @@ export get_iface_methods;\n export get_crate_module_paths;\n export get_item_path;\n export maybe_get_item_ast;\n+export item_is_intrinsic;\n \n // Used internally by astencode:\n export translate_def_id;\n@@ -272,6 +273,13 @@ fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     option::get(found)\n }\n \n+fn item_is_intrinsic(cdata: cmd, id: ast::node_id) -> bool {\n+    let intrinsic = false;\n+    ebml::tagged_docs(lookup_item(id, cdata.data), tag_item_is_intrinsic,\n+                      {|_i| intrinsic = true;});\n+    intrinsic\n+}\n+\n fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }"}, {"sha": "fee50a927e6028d2cdfbcccd177bfaf77fa88730", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b6ad34bef4f0b3613d51557cd327055a2c5311fd", "patch": "@@ -502,7 +502,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                nitem: @native_item,\n                                index: @mutable [entry<int>],\n-                               path: ast_map::path) {\n+                               path: ast_map::path, abi: native_abi) {\n     if !ecx.reachable.contains_key(nitem.id) { ret; }\n     *index += [{val: nitem.id, pos: ebml_w.writer.tell()}];\n \n@@ -512,6 +512,10 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n+        if abi == native_abi_rust_intrinsic {\n+            ebml_w.start_tag(tag_item_is_intrinsic);\n+            ebml_w.end_tag();\n+        }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n         encode_path(ebml_w, path, ast_map::path_name(nitem.ident));\n@@ -531,17 +535,19 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         visit_expr: {|_e, _cx, _v|},\n         visit_item: {|i, cx, v|\n             visit::visit_item(i, cx, v);\n-            let path = alt check ecx.ccx.tcx.items.get(i.id) {\n-              ast_map::node_item(_, pt) { pt }\n-            };\n-            encode_info_for_item(ecx, ebml_w, i, index, *path);\n+            alt check ecx.ccx.tcx.items.get(i.id) {\n+              ast_map::node_item(_, pt) {\n+                encode_info_for_item(ecx, ebml_w, i, index, *pt);\n+              }\n+            }\n         },\n         visit_native_item: {|ni, cx, v|\n             visit::visit_native_item(ni, cx, v);\n-            let path = alt check ecx.ccx.tcx.items.get(ni.id) {\n-              ast_map::node_native_item(_, _, pt) { pt }\n-            };\n-            encode_info_for_native_item(ecx, ebml_w, ni, index, *path);\n+            alt check ecx.ccx.tcx.items.get(ni.id) {\n+              ast_map::node_native_item(_, abi, pt) {\n+                encode_info_for_native_item(ecx, ebml_w, ni, index, *pt, abi);\n+              }\n+            }\n         }\n         with *visit::default_visitor()\n     }));"}, {"sha": "f81c24d811e97adb5de1899d4e3d5a7f11121888", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b6ad34bef4f0b3613d51557cd327055a2c5311fd", "patch": "@@ -2136,21 +2136,44 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     }\n }\n \n-fn add_tydesc_params(ccx: crate_ctxt, llfty: TypeRef, n: uint) -> TypeRef {\n-    let out_ty = llvm::LLVMGetReturnType(llfty);\n-    let n_args = llvm::LLVMCountParamTypes(llfty);\n-    let args = vec::init_elt(n_args as uint, 0 as TypeRef);\n-    unsafe { llvm::LLVMGetParamTypes(llfty, vec::unsafe::to_ptr(args)); }\n-    T_fn(vec::slice(args, 0u, first_real_arg) +\n-         vec::init_elt(n, T_ptr(ccx.tydesc_type)) +\n-         vec::tail_n(args, first_real_arg), out_ty)\n-}\n-\n-fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n-                  substs: option<([ty::t], typeck::vtable_res)>)\n+fn lval_intrinsic_fn(bcx: block, val: ValueRef, tys: [ty::t],\n+                     id: ast::node_id) -> lval_maybe_callee {\n+    fn add_tydesc_params(ccx: @crate_ctxt, llfty: TypeRef, n: uint)\n+        -> TypeRef {\n+        let out_ty = llvm::LLVMGetReturnType(llfty);\n+        let n_args = llvm::LLVMCountParamTypes(llfty);\n+        let args = vec::from_elem(n_args as uint, 0 as TypeRef);\n+        unsafe { llvm::LLVMGetParamTypes(llfty, vec::unsafe::to_ptr(args)); }\n+        T_fn(vec::slice(args, 0u, first_real_arg) +\n+             vec::from_elem(n, T_ptr(ccx.tydesc_type)) +\n+             vec::tailn(args, first_real_arg), out_ty)\n+    }\n+\n+    let bcx = bcx, ccx = bcx.ccx();\n+    let tds = vec::map(tys, {|t|\n+        let ti = none, td_res = get_tydesc(bcx, t, ti);\n+        bcx = td_res.bcx;\n+        lazily_emit_all_tydesc_glue(ccx, ti);\n+        td_res.val\n+    });\n+    let llfty = type_of_fn_from_ty(ccx, node_id_type(bcx, id));\n+    let val = PointerCast(bcx, val, T_ptr(add_tydesc_params(\n+        ccx, llfty, tys.len())));\n+    {bcx: bcx, val: val, kind: owned, env: null_env, tds: some(tds)}\n+}\n+\n+fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n+    -> lval_maybe_callee {\n+    let vts = option::map(bcx.ccx().maps.vtable_map.find(id), {|vts|\n+        impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n+    });\n+    lval_static_fn_inner(bcx, fn_id, id, node_id_type_params(bcx, id), vts)\n+}\n+\n+fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n+                        tys: [ty::t], vtables: option<typeck::vtable_res>)\n     -> lval_maybe_callee {\n-    let bcx = bcx, ccx = bcx.ccx(), tcx = ccx.tcx;\n-    let tys = node_id_type_params(bcx, id);\n+    let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let tpt = ty::lookup_item_type(tcx, fn_id);\n \n     // Check whether this fn has an inlined copy and, if so, redirect fn_id to\n@@ -2159,32 +2182,15 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         maybe_instantiate_inline(ccx, fn_id)\n     } else { fn_id };\n \n-    if fn_id.crate == ast::local_crate {\n-        let (tys, vtables) = alt substs {\n-          some((tys, vts)) { (tys, some(vts)) }\n-          none { (tys, option::map(ccx.maps.vtable_map.find(id), {|vts|\n-                           impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)})) }\n-        };\n-        if tys.len() > 0u {\n-            let {val, must_cast, intrinsic} = monomorphic_fn(ccx, fn_id, tys,\n-                                                             vtables);\n-            let tds = none;\n-            if intrinsic {\n-                tds = some(vec::map(tys, {|t|\n-                    let ti = none, td_res = get_tydesc(bcx, t, ti);\n-                    bcx = td_res.bcx;\n-                    lazily_emit_all_tydesc_glue(ccx, ti);\n-                    td_res.val\n-                }));\n-                let llfty = type_of_fn_from_ty(ccx, node_id_type(bcx, id));\n-                val = PointerCast(bcx, val, T_ptr(add_tydesc_params(\n-                    ccx, llfty, tys.len())));\n-            } else if must_cast {\n-                val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n-                    ccx, node_id_type(bcx, id))));\n-            }\n-            ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: tds};\n+    if fn_id.crate == ast::local_crate && tys.len() > 0u {\n+        let {val, must_cast, intrinsic} = monomorphic_fn(ccx, fn_id, tys,\n+                                                         vtables);\n+        if intrinsic { ret lval_intrinsic_fn(bcx, val, tys, id); }\n+        if must_cast {\n+            val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n+                ccx, node_id_type(bcx, id))));\n         }\n+        ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: none};\n     }\n \n     let val = if fn_id.crate == ast::local_crate {\n@@ -2197,6 +2203,9 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n     if tys.len() > 0u {\n         // This is supposed to be an external native function.\n         // Unfortunately, I found no easy/cheap way to assert that.\n+        if csearch::item_is_intrinsic(ccx.sess.cstore, fn_id) {\n+            ret lval_intrinsic_fn(bcx, val, tys, id);\n+        }\n         val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n             ccx, node_id_type(bcx, id))));\n     }\n@@ -2287,12 +2296,12 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n     let ccx = cx.ccx();\n     alt def {\n       ast::def_fn(did, _) {\n-        ret lval_static_fn(cx, did, id, none);\n+        ret lval_static_fn(cx, did, id);\n       }\n       ast::def_variant(tid, vid) {\n         if ty::enum_variant_with_id(ccx.tcx, tid, vid).args.len() > 0u {\n             // N-ary variant.\n-            ret lval_static_fn(cx, vid, id, none);\n+            ret lval_static_fn(cx, vid, id);\n         } else {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n@@ -2766,7 +2775,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n         let llargs = args_res.args;\n         option::may(f_res.tds) {|vals|\n             llargs = vec::slice(llargs, 0u, first_real_arg) + vals +\n-                vec::tail_n(llargs, first_real_arg);\n+                vec::tailn(llargs, first_real_arg);\n         }\n \n         let llretslot = args_res.retslot;"}, {"sha": "3486de0dc900849a7b5afae8d6bd676206e67e13", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6ad34bef4f0b3613d51557cd327055a2c5311fd/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b6ad34bef4f0b3613d51557cd327055a2c5311fd", "patch": "@@ -48,7 +48,9 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n     -> lval_maybe_callee {\n     alt origin {\n       typeck::method_static(did) {\n-        trans_static_callee(bcx, callee_id, self, did, none)\n+        let {bcx, val} = trans_self_arg(bcx, self);\n+        {env: self_env(val, node_id_type(bcx, self.id))\n+         with lval_static_fn(bcx, did, callee_id)}\n       }\n       typeck::method_param(iid, off, p, b) {\n         alt check bcx.fcx.param_substs {\n@@ -64,16 +66,6 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n     }\n }\n \n-// Method callee where the method is statically known\n-fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n-                       base: @ast::expr, did: ast::def_id,\n-                       substs: option<([ty::t], typeck::vtable_res)>)\n-    -> lval_maybe_callee {\n-    let {bcx, val} = trans_self_arg(bcx, base);\n-    {env: self_env(val, node_id_type(bcx, base.id))\n-     with lval_static_fn(bcx, did, callee_id, substs)}\n-}\n-\n fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n                        callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n@@ -122,11 +114,13 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n         let node_substs = node_id_type_params(bcx, callee_id);\n         let ty_substs = impl_substs +\n             vec::tailn(node_substs, node_substs.len() - n_m_tps);\n-        ret trans_static_callee(bcx, callee_id, base, mth_id,\n-                                some((ty_substs, sub_origins)));\n+        let {bcx, val} = trans_self_arg(bcx, base);\n+        {env: self_env(val, node_id_type(bcx, base.id))\n+         with lval_static_fn_inner(bcx, mth_id, callee_id, ty_substs,\n+                                   some(sub_origins))}\n       }\n       typeck::vtable_iface(iid, tps) {\n-        ret trans_iface_callee(bcx, base, callee_id, n_method);\n+        trans_iface_callee(bcx, base, callee_id, n_method)\n       }\n       typeck::vtable_param(n_param, n_bound) {\n         fail \"vtable_param left in monomorphized function's vtable substs\";"}]}