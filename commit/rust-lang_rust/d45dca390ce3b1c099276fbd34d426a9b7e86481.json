{"sha": "d45dca390ce3b1c099276fbd34d426a9b7e86481", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NWRjYTM5MGNlM2IxYzA5OTI3NmZiZDM0ZDQyNmE5YjdlODY0ODE=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-03-30T20:49:33Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-03-31T17:42:20Z"}, "message": "Use Place directly, it's Copy", "tree": {"sha": "d3426f7e80c5323504c8fe785a7cdfa97b7a6840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3426f7e80c5323504c8fe785a7cdfa97b7a6840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45dca390ce3b1c099276fbd34d426a9b7e86481", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAl6DgPwACgkQgTGiTgx5\n76/PaRAAtXbKn6oSnLEOwNfGxgS1SqZv4O5WMSloOhjFsrtrbl/LKPU3BRBz8DMc\nfRn8/isN1aC0kzLnB/qjbHDn9VsyhF012MvT1+y1aiOasN19Bd38N8vBx9oW84cu\nftZEM4hJ7q3hp67TXjLy42Mm3s/RtWnxCnWnklLkTZ5GrZkyTVnNqo0xjO0GBKPQ\n3FRWnudjHCsU9JLqCM7nSuT3J3YwulhQtr/H90fLvMN2Gz/L1d0Kfb+8uEUhp1vI\nR28Kb1BK6R/HCa6p3iBzFH6VNyyAXYNYDqnZMscIioblI/HQ4xpfuCFFgmXBzTeQ\niGS2qNXRCzHTElz3rE798dTb65s8yeF4Jb2+nxdaR8rpRIkNYU2DgtoogVaIY0rj\nLdLBNKxG5sIZ5gHDPYmqe5AWym921J0NKTAWOyYg28NeLr/znyVIX+lYzgQ3/2+V\nAyJNUc380uL9n56yaW5+RuFWGeWhI8byfwlnDSXXn3HWMnfJX31efajle0M5/xnQ\nRyvsG9w7KAeRDicrvdM4h8ag3LNqMrFFsol4GqmRFFIANxbYpz9x6xOpzUt7CloQ\n844v0YDOgXJTttyDcjDS1tS7vWb11tfddLuyevOu4kMOTF9pOX7zEAX/4nzT91uU\n9/d+1KgLuZwnJn7PSNjq2vD/aAPrJn/8r4eE80D3Tegi5RC+rM0=\n=4RWp\n-----END PGP SIGNATURE-----", "payload": "tree d3426f7e80c5323504c8fe785a7cdfa97b7a6840\nparent 75ff3110ac6d8a0259023b83fd20d7ab295f8dd6\nauthor Santiago Pastorino <spastorino@gmail.com> 1585601373 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1585676540 -0300\n\nUse Place directly, it's Copy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45dca390ce3b1c099276fbd34d426a9b7e86481", "html_url": "https://github.com/rust-lang/rust/commit/d45dca390ce3b1c099276fbd34d426a9b7e86481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45dca390ce3b1c099276fbd34d426a9b7e86481/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "html_url": "https://github.com/rust-lang/rust/commit/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6"}], "stats": {"total": 182, "additions": 88, "deletions": 94}, "files": [{"sha": "7242bbcd2eb8fcfaccbc101b15ec55127ae4c8e6", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n             let idx = self.idx_vec.push(borrow);\n             self.location_map.insert(location, idx);\n \n-            self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n+            self.insert_as_pending_if_two_phase(location, assigned_place, kind, idx);\n \n             self.local_map.entry(borrowed_place.local).or_default().insert(idx);\n         }"}, {"sha": "e0420d974fbdf3cdc93d35e8a43d5210c487a251", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -114,7 +114,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n     fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         // When we see `X = ...`, then kill borrows of\n         // `(*X).foo` and so forth.\n-        self.record_killed_borrows_for_place(place, location);\n+        self.record_killed_borrows_for_place(*place, location);\n \n         self.super_assign(place, rvalue, location);\n     }\n@@ -139,7 +139,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n \n         // A `Call` terminator's return value can be a local which has borrows,\n         // so we need to record those as `killed` as well.\n-        if let TerminatorKind::Call { ref destination, .. } = terminator.kind {\n+        if let TerminatorKind::Call { destination, .. } = terminator.kind {\n             if let Some((place, _)) = destination {\n                 self.record_killed_borrows_for_place(place, location);\n             }\n@@ -177,7 +177,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n \n     /// When recording facts for Polonius, records the borrows on the specified place\n     /// as `killed`. For example, when assigning to a local, or on a call's return destination.\n-    fn record_killed_borrows_for_place(&mut self, place: &Place<'tcx>, location: Location) {\n+    fn record_killed_borrows_for_place(&mut self, place: Place<'tcx>, location: Location) {\n         if let Some(all_facts) = self.all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n \n@@ -217,7 +217,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n                                 self.body,\n-                                &self.borrow_set.borrows[borrow_index].borrowed_place,\n+                                self.borrow_set.borrows[borrow_index].borrowed_place,\n                                 place,\n                                 places_conflict::PlaceConflictBias::NoOverlap,\n                             );"}, {"sha": "563dfe3544e7d3f4cd1ede56b55fc5d4e67fca0b", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -247,7 +247,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_move_out_while_borrowed(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         debug!(\n@@ -291,7 +291,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_use_while_mutably_borrowed(\n         &mut self,\n         location: Location,\n-        (place, _span): (&Place<'tcx>, Span),\n+        (place, _span): (Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n@@ -330,7 +330,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_conflicting_borrow(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -347,7 +347,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         let (desc_place, msg_place, msg_borrow, union_type_name) =\n-            self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n+            self.describe_place_for_conflicting_borrow(place, issued_borrow.borrowed_place);\n \n         let explanation = self.explain_why_borrow_contains_point(location, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() { \"second \" } else { \"\" };\n@@ -584,8 +584,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// >  mutable (via `a.u.s.b`) [E0502]\n     pub(in crate::borrow_check) fn describe_place_for_conflicting_borrow(\n         &self,\n-        first_borrowed_place: &Place<'tcx>,\n-        second_borrowed_place: &Place<'tcx>,\n+        first_borrowed_place: Place<'tcx>,\n+        second_borrowed_place: Place<'tcx>,\n     ) -> (String, String, String, String) {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n@@ -615,13 +615,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     cursor = proj_base;\n \n                     match elem {\n-                        ProjectionElem::Field(field, _)\n-                            if union_ty(*local, proj_base).is_some() =>\n-                        {\n-                            return Some((\n-                                PlaceRef { local: *local, projection: proj_base },\n-                                field,\n-                            ));\n+                        ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n+                            return Some((PlaceRef { local, projection: proj_base }, field));\n                         }\n                         _ => {}\n                     }\n@@ -631,7 +626,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { local, ref projection } = *second_borrowed_place;\n+                let Place { local, ref projection } = second_borrowed_place;\n \n                 let mut cursor = &projection[..];\n                 while let [proj_base @ .., elem] = cursor {\n@@ -682,7 +677,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n         debug!(\n@@ -967,7 +962,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n-        (place, drop_span): (&Place<'tcx>, Span),\n+        (place, drop_span): (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n         dropped_ty: Ty<'tcx>,\n     ) {\n@@ -1379,7 +1374,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n@@ -1432,9 +1427,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(in crate::borrow_check) fn report_illegal_reassignment(\n         &mut self,\n         _location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         assigned_span: Span,\n-        err_place: &Place<'tcx>,\n+        err_place: Place<'tcx>,\n     ) {\n         let (from_arg, local_decl, local_name) = match err_place.as_local() {\n             Some(local) => ("}, {"sha": "7340e88f19b3783ea01f613a90a190fa9e405eda", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -286,7 +286,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n-        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n+        kind_place: Option<(WriteKind, Place<'tcx>)>,\n     ) -> BorrowExplanation {\n         debug!(\n             \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\","}, {"sha": "35edd3d803db93460d2693205c94800c56110a10", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -22,7 +22,7 @@ pub(crate) enum AccessKind {\n impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(crate) fn report_mutability_error(\n         &mut self,\n-        access_place: &Place<'tcx>,\n+        access_place: Place<'tcx>,\n         span: Span,\n         the_place_err: PlaceRef<'tcx>,\n         error_access: AccessKind,"}, {"sha": "05d21a15a5677ea3d0d8f4acbeea571e8c6033e8", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -56,33 +56,33 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         self.check_activations(location);\n \n-        match statement.kind {\n-            StatementKind::Assign(box (ref lhs, ref rhs)) => {\n+        match &statement.kind {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n                 self.consume_rvalue(location, rhs);\n \n-                self.mutate_place(location, lhs, Shallow(None), JustWrite);\n+                self.mutate_place(location, *lhs, Shallow(None), JustWrite);\n             }\n             StatementKind::FakeRead(_, _) => {\n                 // Only relevant for initialized/liveness/safety checks.\n             }\n-            StatementKind::SetDiscriminant { ref place, variant_index: _ } => {\n-                self.mutate_place(location, place, Shallow(None), JustWrite);\n+            StatementKind::SetDiscriminant { place, variant_index: _ } => {\n+                self.mutate_place(location, **place, Shallow(None), JustWrite);\n             }\n-            StatementKind::LlvmInlineAsm(ref asm) => {\n+            StatementKind::LlvmInlineAsm(asm) => {\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n                             location,\n-                            output,\n+                            *output,\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                         );\n                     } else {\n                         self.mutate_place(\n                             location,\n-                            output,\n+                            *output,\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                         );\n@@ -102,7 +102,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n-                    &Place::from(local),\n+                    Place::from(*local),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n@@ -119,36 +119,36 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n-            TerminatorKind::Drop { location: ref drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { location: drop_place, target: _, unwind: _ } => {\n                 self.access_place(\n                     location,\n-                    drop_place,\n+                    *drop_place,\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: ref drop_place,\n+                location: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.mutate_place(location, drop_place, Deep, JustWrite);\n+                self.mutate_place(location, *drop_place, Deep, JustWrite);\n                 self.consume_operand(location, new_value);\n             }\n             TerminatorKind::Call {\n                 ref func,\n                 ref args,\n-                ref destination,\n+                destination,\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n                 self.consume_operand(location, func);\n                 for arg in args {\n                     self.consume_operand(location, arg);\n                 }\n-                if let Some((ref dest, _ /*bb*/)) = *destination {\n-                    self.mutate_place(location, dest, Deep, JustWrite);\n+                if let Some((dest, _ /*bb*/)) = destination {\n+                    self.mutate_place(location, *dest, Deep, JustWrite);\n                 }\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n@@ -171,7 +171,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     }\n                 }\n \n-                self.mutate_place(location, resume_arg, Deep, JustWrite);\n+                self.mutate_place(location, *resume_arg, Deep, JustWrite);\n             }\n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n                 // Invalidate all borrows of local places\n@@ -201,7 +201,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     fn mutate_place(\n         &mut self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         kind: AccessDepth,\n         _mode: MutateMode,\n     ) {\n@@ -216,15 +216,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     /// Simulates consumption of an operand.\n     fn consume_operand(&mut self, location: Location, operand: &Operand<'tcx>) {\n         match *operand {\n-            Operand::Copy(ref place) => {\n+            Operand::Copy(place) => {\n                 self.access_place(\n                     location,\n                     place,\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n             }\n-            Operand::Move(ref place) => {\n+            Operand::Move(place) => {\n                 self.access_place(\n                     location,\n                     place,\n@@ -239,7 +239,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     // Simulates consumption of an rvalue\n     fn consume_rvalue(&mut self, location: Location, rvalue: &Rvalue<'tcx>) {\n         match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n+            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -258,7 +258,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n-            Rvalue::AddressOf(mutability, ref place) => {\n+            Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -279,7 +279,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, operand)\n             }\n \n-            Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n+            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -313,7 +313,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     fn access_place(\n         &mut self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         kind: (AccessDepth, ReadOrWrite),\n         _is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n@@ -325,7 +325,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n     ) {\n@@ -413,7 +413,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n             self.access_place(\n                 location,\n-                &borrow.borrowed_place,\n+                borrow.borrowed_place,\n                 (Deep, Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index)),\n                 LocalMutationIsAllowed::No,\n             );"}, {"sha": "bff39f87c171e9dc8f5488a3e8694589c9b43b91", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -308,8 +308,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n     for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n-        let mut initial_diag =\n-            mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n+        let mut initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);\n \n         let scope = mbcx.body.source_info(location).scope;\n         let lint_root = match &mbcx.body.source_scopes[scope].local_data {\n@@ -523,11 +522,11 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n \n         self.check_activations(location, span, flow_state);\n \n-        match stmt.kind {\n-            StatementKind::Assign(box (ref lhs, ref rhs)) => {\n+        match &stmt.kind {\n+            StatementKind::Assign(box (lhs, ref rhs)) => {\n                 self.consume_rvalue(location, (rhs, span), flow_state);\n \n-                self.mutate_place(location, (lhs, span), Shallow(None), JustWrite, flow_state);\n+                self.mutate_place(location, (*lhs, span), Shallow(None), JustWrite, flow_state);\n             }\n             StatementKind::FakeRead(_, box ref place) => {\n                 // Read for match doesn't access any memory and is used to\n@@ -547,8 +546,8 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                     flow_state,\n                 );\n             }\n-            StatementKind::SetDiscriminant { ref place, variant_index: _ } => {\n-                self.mutate_place(location, (place, span), Shallow(None), JustWrite, flow_state);\n+            StatementKind::SetDiscriminant { place, variant_index: _ } => {\n+                self.mutate_place(location, (**place, span), Shallow(None), JustWrite, flow_state);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n@@ -557,7 +556,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n                             location,\n-                            (output, o.span),\n+                            (*output, o.span),\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                             flow_state,\n@@ -571,7 +570,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                     } else {\n                         self.mutate_place(\n                             location,\n-                            (output, o.span),\n+                            (*output, o.span),\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                             flow_state,\n@@ -592,7 +591,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     location,\n-                    (&Place::from(local), span),\n+                    (Place::from(*local), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n@@ -638,14 +637,14 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n \n                 self.access_place(\n                     loc,\n-                    (drop_place, span),\n+                    (*drop_place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: ref drop_place,\n+                location: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,\n@@ -664,7 +663,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 for arg in args {\n                     self.consume_operand(loc, (arg, span), flow_state);\n                 }\n-                if let Some((ref dest, _ /*bb*/)) = *destination {\n+                if let Some((dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(loc, (dest, span), Deep, JustWrite, flow_state);\n                 }\n             }\n@@ -677,7 +676,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, ref resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n                 self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n@@ -884,7 +883,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn access_place(\n         &mut self,\n         location: Location,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         kind: (AccessDepth, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -905,7 +904,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Check is_empty() first because it's the common case, and doing that\n         // way we avoid the clone() call.\n         if !self.access_place_error_reported.is_empty()\n-            && self.access_place_error_reported.contains(&(*place_span.0, place_span.1))\n+            && self.access_place_error_reported.contains(&(place_span.0, place_span.1))\n         {\n             debug!(\n                 \"access_place: suppressing error place_span=`{:?}` kind=`{:?}`\",\n@@ -933,14 +932,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if conflict_error || mutability_error {\n             debug!(\"access_place: logging error place_span=`{:?}` kind=`{:?}`\", place_span, kind);\n \n-            self.access_place_error_reported.insert((*place_span.0, place_span.1));\n+            self.access_place_error_reported.insert((place_span.0, place_span.1));\n         }\n     }\n \n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -1043,7 +1042,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // these sepately so that we only emit a warning if borrow\n                     // checking was otherwise successful.\n                     this.reservation_warnings\n-                        .insert(bi, (*place_span.0, place_span.1, location, bk, borrow.clone()));\n+                        .insert(bi, (place_span.0, place_span.1, location, bk, borrow.clone()));\n \n                     // Don't suppress actual errors.\n                     Control::Continue\n@@ -1100,7 +1099,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn mutate_place(\n         &mut self,\n         location: Location,\n-        place_span: (&'cx Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -1150,7 +1149,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n+            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -1188,7 +1187,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::AddressOf(mutability, ref place) => {\n+            Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -1222,7 +1221,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.consume_operand(location, (operand, span), flow_state)\n             }\n \n-            Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n+            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -1361,7 +1360,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *operand {\n-            Operand::Copy(ref place) => {\n+            Operand::Copy(place) => {\n                 // copy of place: check if this is \"copy of frozen path\"\n                 // (FIXME: see check_loans.rs)\n                 self.access_place(\n@@ -1380,7 +1379,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     flow_state,\n                 );\n             }\n-            Operand::Move(ref place) => {\n+            Operand::Move(place) => {\n                 // move of place: check if this is move of already borrowed path\n                 self.access_place(\n                     location,\n@@ -1411,7 +1410,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         span: Span,\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n-        let place = &borrow.borrowed_place;\n+        let place = borrow.borrowed_place;\n         let mut root_place = PlaceRef { local: place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n@@ -1491,7 +1490,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             self.access_place(\n                 location,\n-                (&borrow.borrowed_place, span),\n+                (borrow.borrowed_place, span),\n                 (Deep, Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index)),\n                 LocalMutationIsAllowed::No,\n                 flow_state,\n@@ -1506,7 +1505,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         local: Local,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", local);\n@@ -1730,7 +1729,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_assigned_path_is_moved(\n         &mut self,\n         location: Location,\n-        (place, span): (&'cx Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n@@ -1903,7 +1902,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns `true` if an error is reported.\n     fn check_access_permissions(\n         &mut self,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (Place<'tcx>, Span),\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'tcx>,"}, {"sha": "e1cbdc43256ef62f2e19ae6ff8b4cb2e3f221562", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -27,7 +27,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n-    access_place: (AccessDepth, &Place<'tcx>),\n+    access_place: (AccessDepth, Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,\n     candidates: I,\n     mut op: F,\n@@ -48,7 +48,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n         if places_conflict::borrow_conflicts_with_place(\n             tcx,\n             body,\n-            &borrowed.borrowed_place,\n+            borrowed.borrowed_place,\n             borrowed.kind,\n             place.as_ref(),\n             access,"}, {"sha": "d48df6a91095e02cbd47e06839d5f6eba2f05c6e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -24,8 +24,8 @@ crate enum PlaceConflictBias {\n crate fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_place: &Place<'tcx>,\n-    access_place: &Place<'tcx>,\n+    borrow_place: Place<'tcx>,\n+    access_place: Place<'tcx>,\n     bias: PlaceConflictBias,\n ) -> bool {\n     borrow_conflicts_with_place(\n@@ -46,7 +46,7 @@ crate fn places_conflict<'tcx>(\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_place: &Place<'tcx>,\n+    borrow_place: Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: PlaceRef<'tcx>,\n     access: AccessDepth,\n@@ -71,7 +71,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_place: &Place<'tcx>,\n+    borrow_place: Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: PlaceRef<'tcx>,\n     access: AccessDepth,"}, {"sha": "43f985946aaac4429079e9a3830964e77103d05b", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dca390ce3b1c099276fbd34d426a9b7e86481/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=d45dca390ce3b1c099276fbd34d426a9b7e86481", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n \n     /// Kill any borrows that conflict with `place`.\n-    fn kill_borrows_on_place(&self, trans: &mut impl GenKill<BorrowIndex>, place: &Place<'tcx>) {\n+    fn kill_borrows_on_place(&self, trans: &mut impl GenKill<BorrowIndex>, place: Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n         let other_borrows_of_local = self\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             places_conflict(\n                 self.tcx,\n                 self.body,\n-                &self.borrow_set.borrows[i].borrowed_place,\n+                self.borrow_set.borrows[i].borrowed_place,\n                 place,\n                 PlaceConflictBias::NoOverlap,\n             )\n@@ -262,8 +262,8 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         location: Location,\n     ) {\n         match stmt.kind {\n-            mir::StatementKind::Assign(box (ref lhs, ref rhs)) => {\n-                if let mir::Rvalue::Ref(_, _, ref place) = *rhs {\n+            mir::StatementKind::Assign(box (lhs, ref rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, place) = *rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,\n@@ -286,13 +286,13 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, &Place::from(local));\n+                self.kill_borrows_on_place(trans, Place::from(local));\n             }\n \n             mir::StatementKind::LlvmInlineAsm(ref asm) => {\n                 for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n-                        self.kill_borrows_on_place(trans, output);\n+                        self.kill_borrows_on_place(trans, *output);\n                     }\n                 }\n             }"}]}