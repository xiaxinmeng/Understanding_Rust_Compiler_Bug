{"sha": "8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOTViMGE2Zjk4YmM1OGY5YThiMzljYWE4YzY4MWQxNTAwYzJlOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-09T08:50:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-09T08:50:03Z"}, "message": "Auto merge of #31282 - pczarn:mir-trans-builder, r=nagisa\n\nCloses #31003", "tree": {"sha": "30ece25535e2244dbd7030c89b25a6f387c77fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ece25535e2244dbd7030c89b25a6f387c77fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "html_url": "https://github.com/rust-lang/rust/commit/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d410b8d2afc17dd129a498e3304e3c4fe221a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d410b8d2afc17dd129a498e3304e3c4fe221a94", "html_url": "https://github.com/rust-lang/rust/commit/0d410b8d2afc17dd129a498e3304e3c4fe221a94"}, {"sha": "38fa06bc9528d88b2eaf2b082514368a96654f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/38fa06bc9528d88b2eaf2b082514368a96654f3e", "html_url": "https://github.com/rust-lang/rust/commit/38fa06bc9528d88b2eaf2b082514368a96654f3e"}], "stats": {"total": 850, "additions": 515, "deletions": 335}, "files": [{"sha": "57e69a0efa95e6b1587ff8c8bd1947f49c3a20d2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -988,7 +988,7 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n }\n \n pub fn avoid_invoke(bcx: Block) -> bool {\n-    bcx.sess().no_landing_pads() || bcx.lpad.borrow().is_some()\n+    bcx.sess().no_landing_pads() || bcx.lpad().is_some()\n }\n \n pub fn need_invoke(bcx: Block) -> bool {\n@@ -1616,6 +1616,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         param_substs: param_substs,\n         span: sp,\n         block_arena: block_arena,\n+        lpad_arena: TypedArena::new(),\n         ccx: ccx,\n         debug_context: debug_context,\n         scopes: RefCell::new(Vec::new()),\n@@ -2003,7 +2004,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut bcx = init_function(&fcx, false, output_type);\n \n     if attributes.iter().any(|item| item.check_name(\"rustc_mir\")) {\n-        mir::trans_mir(bcx);\n+        mir::trans_mir(bcx.build());\n         fcx.cleanup();\n         return;\n     }"}, {"sha": "ce541c8d411bb94bf3872f893bbf6c497d26b5b6", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -150,8 +150,7 @@ pub fn Invoke(cx: Block,\n            cx.val_to_string(fn_),\n            args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().join(\", \"));\n     debug_loc.apply(cx.fcx);\n-    let lpad = cx.lpad.borrow();\n-    let bundle = lpad.as_ref().and_then(|b| b.bundle());\n+    let bundle = cx.lpad().and_then(|b| b.bundle());\n     B(cx).invoke(fn_, args, then, catch, bundle, attributes)\n }\n \n@@ -916,8 +915,7 @@ pub fn Call(cx: Block,\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n-    let lpad = cx.lpad.borrow();\n-    let bundle = lpad.as_ref().and_then(|b| b.bundle());\n+    let bundle = cx.lpad.get().and_then(|b| b.bundle());\n     B(cx).call(fn_, args, bundle, attributes)\n }\n \n@@ -932,8 +930,7 @@ pub fn CallWithConv(cx: Block,\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n-    let lpad = cx.lpad.borrow();\n-    let bundle = lpad.as_ref().and_then(|b| b.bundle());\n+    let bundle = cx.lpad.get().and_then(|b| b.bundle());\n     B(cx).call_with_conv(fn_, args, conv, bundle, attributes)\n }\n "}, {"sha": "683d5e0ead452436c0be3bdf935ee0168a805302", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -1054,11 +1054,11 @@ impl EarlyExitLabel {\n         match *self {\n             UnwindExit(UnwindKind::CleanupPad(..)) => {\n                 let pad = build::CleanupPad(bcx, None, &[]);\n-                *bcx.lpad.borrow_mut() = Some(LandingPad::msvc(pad));\n+                bcx.lpad.set(Some(bcx.fcx.lpad_arena.alloc(LandingPad::msvc(pad))));\n                 UnwindExit(UnwindKind::CleanupPad(pad))\n             }\n             UnwindExit(UnwindKind::LandingPad) => {\n-                *bcx.lpad.borrow_mut() = Some(LandingPad::gnu());\n+                bcx.lpad.set(Some(bcx.fcx.lpad_arena.alloc(LandingPad::gnu())));\n                 *self\n             }\n             label => label,"}, {"sha": "ec33046e5d914c6414e9ff77e8a131c3afe03734", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -26,6 +26,7 @@ use middle::lang_items::LangItem;\n use middle::subst::{self, Substs};\n use trans::base;\n use trans::build;\n+use trans::builder::Builder;\n use trans::callee;\n use trans::cleanup;\n use trans::consts;\n@@ -45,6 +46,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n+use std::ops::Deref;\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::vec::Vec;\n@@ -365,6 +367,9 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // The arena that blocks are allocated from.\n     pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n+    // The arena that landing pads are allocated from.\n+    pub lpad_arena: TypedArena<LandingPad>,\n+\n     // This function's enclosing crate context.\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n \n@@ -582,7 +587,7 @@ pub struct BlockS<'blk, 'tcx: 'blk> {\n \n     // If this block part of a landing pad, then this is `Some` indicating what\n     // kind of landing pad its in, otherwise this is none.\n-    pub lpad: RefCell<Option<LandingPad>>,\n+    pub lpad: Cell<Option<&'blk LandingPad>>,\n \n     // AST node-id associated with this block, if any. Used for\n     // debugging purposes only.\n@@ -604,7 +609,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n-            lpad: RefCell::new(None),\n+            lpad: Cell::new(None),\n             opt_node_id: opt_node_id,\n             fcx: fcx\n         })\n@@ -613,11 +618,18 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n         self.fcx.ccx\n     }\n+    pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n+        self.fcx\n+    }\n     pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n+    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n+        self.lpad.get()\n+    }\n+\n     pub fn mir(&self) -> &'blk Mir<'tcx> {\n         self.fcx.mir()\n     }\n@@ -659,6 +671,109 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n                                          self.fcx.param_substs,\n                                          value)\n     }\n+\n+    pub fn build(&'blk self) -> BlockAndBuilder<'blk, 'tcx> {\n+        BlockAndBuilder::new(self, OwnedBuilder::new_with_ccx(self.ccx()))\n+    }\n+}\n+\n+pub struct OwnedBuilder<'blk, 'tcx: 'blk> {\n+    builder: Builder<'blk, 'tcx>\n+}\n+\n+impl<'blk, 'tcx> OwnedBuilder<'blk, 'tcx> {\n+    pub fn new_with_ccx(ccx: &'blk CrateContext<'blk, 'tcx>) -> Self {\n+        // Create a fresh builder from the crate context.\n+        let llbuilder = unsafe {\n+            llvm::LLVMCreateBuilderInContext(ccx.llcx())\n+        };\n+        OwnedBuilder {\n+            builder: Builder {\n+                llbuilder: llbuilder,\n+                ccx: ccx,\n+            }\n+        }\n+    }\n+}\n+\n+impl<'blk, 'tcx> Drop for OwnedBuilder<'blk, 'tcx> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMDisposeBuilder(self.builder.llbuilder);\n+        }\n+    }\n+}\n+\n+pub struct BlockAndBuilder<'blk, 'tcx: 'blk> {\n+    bcx: Block<'blk, 'tcx>,\n+    owned_builder: OwnedBuilder<'blk, 'tcx>,\n+}\n+\n+impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n+    pub fn new(bcx: Block<'blk, 'tcx>, owned_builder: OwnedBuilder<'blk, 'tcx>) -> Self {\n+        // Set the builder's position to this block's end.\n+        owned_builder.builder.position_at_end(bcx.llbb);\n+        BlockAndBuilder {\n+            bcx: bcx,\n+            owned_builder: owned_builder,\n+        }\n+    }\n+\n+    pub fn with_block<F, R>(&self, f: F) -> R\n+        where F: FnOnce(Block<'blk, 'tcx>) -> R\n+    {\n+        let result = f(self.bcx);\n+        self.position_at_end(self.bcx.llbb);\n+        result\n+    }\n+\n+    pub fn map_block<F>(self, f: F) -> Self\n+        where F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>\n+    {\n+        let BlockAndBuilder { bcx, owned_builder } = self;\n+        let bcx = f(bcx);\n+        BlockAndBuilder::new(bcx, owned_builder)\n+    }\n+\n+    // Methods delegated to bcx\n+\n+    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+        self.bcx.ccx()\n+    }\n+    pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n+        self.bcx.fcx()\n+    }\n+    pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n+        self.bcx.tcx()\n+    }\n+    pub fn sess(&self) -> &'blk Session {\n+        self.bcx.sess()\n+    }\n+\n+    pub fn llbb(&self) -> BasicBlockRef {\n+        self.bcx.llbb\n+    }\n+\n+    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+        self.bcx.mir()\n+    }\n+\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n+        self.bcx.val_to_string(val)\n+    }\n+\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T: TypeFoldable<'tcx>\n+    {\n+        self.bcx.monomorphize(value)\n+    }\n+}\n+\n+impl<'blk, 'tcx> Deref for BlockAndBuilder<'blk, 'tcx> {\n+    type Target = Builder<'blk, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.owned_builder.builder\n+    }\n }\n \n /// A structure representing an active landing pad for the duration of a basic"}, {"sha": "b3b8214a9a70d5c076aaca91f8c1a5e2ec807efd", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 104, "deletions": 95, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -16,7 +16,7 @@ use trans::adt;\n use trans::attributes;\n use trans::base;\n use trans::build;\n-use trans::common::{self, Block, LandingPad};\n+use trans::common::{self, Block, BlockAndBuilder};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n use trans::foreign;\n@@ -42,94 +42,98 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         match *data.terminator() {\n             mir::Terminator::Goto { target } => {\n-                build::Br(bcx, self.llblock(target), DebugLoc::None)\n+                bcx.br(self.llblock(target));\n             }\n \n             mir::Terminator::If { ref cond, targets: (true_bb, false_bb) } => {\n-                let cond = self.trans_operand(bcx, cond);\n+                let cond = self.trans_operand(&bcx, cond);\n                 let lltrue = self.llblock(true_bb);\n                 let llfalse = self.llblock(false_bb);\n-                build::CondBr(bcx, cond.immediate(), lltrue, llfalse, DebugLoc::None);\n+                bcx.cond_br(cond.immediate(), lltrue, llfalse);\n             }\n \n             mir::Terminator::Switch { ref discr, ref adt_def, ref targets } => {\n-                let discr_lvalue = self.trans_lvalue(bcx, discr);\n+                let discr_lvalue = self.trans_lvalue(&bcx, discr);\n                 let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                let discr = adt::trans_get_discr(bcx, &repr, discr_lvalue.llval,\n-                                                 None, true);\n+                let discr = bcx.with_block(|bcx|\n+                    adt::trans_get_discr(bcx, &repr, discr_lvalue.llval, None, true)\n+                );\n \n                 // The else branch of the Switch can't be hit, so branch to an unreachable\n                 // instruction so LLVM knows that\n                 let unreachable_blk = self.unreachable_block();\n-                let switch = build::Switch(bcx, discr, unreachable_blk.llbb, targets.len());\n+                let switch = bcx.switch(discr, unreachable_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n-                    let llval = adt::trans_case(bcx, &*repr, Disr::from(adt_variant.disr_val));\n+                    let llval = bcx.with_block(|bcx|\n+                        adt::trans_case(bcx, &*repr, Disr::from(adt_variant.disr_val))\n+                    );\n                     let llbb = self.llblock(*target);\n-\n                     build::AddCase(switch, llval, llbb)\n                 }\n             }\n \n             mir::Terminator::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n-                let discr = build::Load(bcx, self.trans_lvalue(bcx, discr).llval);\n-                let switch = build::Switch(bcx, discr, self.llblock(*otherwise), values.len());\n+                let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n+                let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let llval = self.trans_constval(bcx, value, switch_ty).immediate();\n+                    let llval = self.trans_constval(&bcx, value, switch_ty).immediate();\n                     let llbb = self.llblock(*target);\n                     build::AddCase(switch, llval, llbb)\n                 }\n             }\n \n             mir::Terminator::Resume => {\n-                let ps = self.get_personality_slot(bcx);\n-                let lp = build::Load(bcx, ps);\n-                base::call_lifetime_end(bcx, ps);\n-                base::trans_unwind_resume(bcx, lp);\n+                let ps = self.get_personality_slot(&bcx);\n+                let lp = bcx.load(ps);\n+                bcx.with_block(|bcx| {\n+                    base::call_lifetime_end(bcx, ps);\n+                    base::trans_unwind_resume(bcx, lp);\n+                });\n             }\n \n             mir::Terminator::Return => {\n                 let return_ty = bcx.monomorphize(&self.mir.return_ty);\n-                base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n+                bcx.with_block(|bcx| {\n+                    base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n+                })\n             }\n \n             mir::Terminator::Drop { ref value, target, unwind } => {\n-                let lvalue = self.trans_lvalue(bcx, value);\n+                let lvalue = self.trans_lvalue(&bcx, value);\n                 let ty = lvalue.ty.to_ty(bcx.tcx());\n                 // Double check for necessity to drop\n                 if !glue::type_needs_drop(bcx.tcx(), ty) {\n-                    build::Br(bcx, self.llblock(target), DebugLoc::None);\n+                    bcx.br(self.llblock(target));\n                     return;\n                 }\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n                 let drop_ty = glue::get_drop_glue_type(bcx.ccx(), ty);\n                 let llvalue = if drop_ty != ty {\n-                    build::PointerCast(bcx, lvalue.llval,\n-                                       type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n+                    bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n                 } else {\n                     lvalue.llval\n                 };\n                 if let Some(unwind) = unwind {\n                     let uwbcx = self.bcx(unwind);\n                     let unwind = self.make_landing_pad(uwbcx);\n-                    build::Invoke(bcx,\n-                                  drop_fn,\n-                                  &[llvalue],\n-                                  self.llblock(target),\n-                                  unwind.llbb,\n-                                  None,\n-                                  DebugLoc::None);\n+                    bcx.invoke(drop_fn,\n+                               &[llvalue],\n+                               self.llblock(target),\n+                               unwind.llbb(),\n+                               None,\n+                               None);\n                 } else {\n-                    build::Call(bcx, drop_fn, &[llvalue], None, DebugLoc::None);\n-                    build::Br(bcx, self.llblock(target), DebugLoc::None);\n+                    bcx.call(drop_fn, &[llvalue], None, None);\n+                    bcx.br(self.llblock(target));\n                 }\n             }\n \n             mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n-                let callee = self.trans_operand(bcx, func);\n+                let callee = self.trans_operand(&bcx, func);\n                 let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n                 let debugloc = DebugLoc::None;\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n@@ -149,7 +153,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Prepare the return value destination\n                 let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n-                    let dest = self.trans_lvalue(bcx, d);\n+                    let dest = self.trans_lvalue(&bcx, d);\n                     let ret_ty = dest.ty.to_ty(bcx.tcx());\n                     if !is_foreign && type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n                         llargs.push(dest.llval);\n@@ -163,7 +167,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Process the rest of the args.\n                 for arg in args {\n-                    let operand = self.trans_operand(bcx, arg);\n+                    let operand = self.trans_operand(&bcx, arg);\n                     match operand.val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n                         FatPtr(b, e) => {\n@@ -176,38 +180,37 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 }\n \n+                let avoid_invoke = bcx.with_block(|bcx| base::avoid_invoke(bcx));\n                 // Many different ways to call a function handled here\n-                match (is_foreign, base::avoid_invoke(bcx), cleanup, destination) {\n+                match (is_foreign, avoid_invoke, cleanup, destination) {\n                     // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n                     (false, false, &Some(cleanup), &None) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n-                        build::Invoke(bcx,\n-                                      callee.immediate(),\n-                                      &llargs[..],\n-                                      unreachable_blk.llbb,\n-                                      landingpad.llbb,\n-                                      Some(attrs),\n-                                      debugloc);\n+                        bcx.invoke(callee.immediate(),\n+                                   &llargs[..],\n+                                   unreachable_blk.llbb,\n+                                   landingpad.llbb(),\n+                                   None,\n+                                   Some(attrs));\n                     },\n                     (false, false, &Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let (target, postinvoke) = if must_copy_dest {\n-                            (bcx.fcx.new_block(\"\", None), Some(self.bcx(success)))\n+                            (bcx.fcx().new_block(\"\", None).build(), Some(self.bcx(success)))\n                         } else {\n                             (self.bcx(success), None)\n                         };\n-                        let invokeret = build::Invoke(bcx,\n-                                                      callee.immediate(),\n-                                                      &llargs[..],\n-                                                      target.llbb,\n-                                                      landingpad.llbb,\n-                                                      Some(attrs),\n-                                                      debugloc);\n+                        let invokeret = bcx.invoke(callee.immediate(),\n+                                                   &llargs[..],\n+                                                   target.llbb(),\n+                                                   landingpad.llbb(),\n+                                                   None,\n+                                                   Some(attrs));\n                         if let Some(postinvoketarget) = postinvoke {\n-                            // We translate the copy into a temoprary block. The temporary block is\n+                            // We translate the copy into a temporary block. The temporary block is\n                             // necessary because the current block has already been terminated (by\n                             // `invoke`) and we cannot really translate into the target block\n                             // because:\n@@ -233,89 +236,95 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             //                               ; immediate precedesors\n                             let (ret_dest, ret_ty) = ret_dest_ty\n                                 .expect(\"return destination and type not set\");\n-                            base::store_ty(target, invokeret, ret_dest.llval, ret_ty);\n-                            build::Br(target, postinvoketarget.llbb, debugloc);\n+                            target.with_block(|target| {\n+                                base::store_ty(target, invokeret, ret_dest.llval, ret_ty);\n+                            });\n+                            target.br(postinvoketarget.llbb());\n                         }\n                     },\n                     (false, _, _, &None) => {\n-                        build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n-                        build::Unreachable(bcx);\n+                        bcx.call(callee.immediate(), &llargs[..], None, Some(attrs));\n+                        bcx.unreachable();\n                     }\n                     (false, _, _, &Some((_, target))) => {\n-                        let llret = build::Call(bcx,\n-                                                callee.immediate(),\n-                                                &llargs[..],\n-                                                Some(attrs),\n-                                                debugloc);\n+                        let llret = bcx.call(callee.immediate(),\n+                                             &llargs[..],\n+                                             None,\n+                                             Some(attrs));\n                         if must_copy_dest {\n                             let (ret_dest, ret_ty) = ret_dest_ty\n                                 .expect(\"return destination and type not set\");\n-                            base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n+                            bcx.with_block(|bcx| {\n+                                base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n+                            });\n                         }\n-                        build::Br(bcx, self.llblock(target), debugloc);\n+                        bcx.br(self.llblock(target));\n                     }\n                     // Foreign functions\n                     (true, _, _, destination) => {\n                         let (dest, _) = ret_dest_ty\n                             .expect(\"return destination is not set\");\n-                        bcx = foreign::trans_native_call(bcx,\n-                                                   callee.ty,\n-                                                   callee.immediate(),\n-                                                   dest.llval,\n-                                                   &llargs[..],\n-                                                   arg_tys,\n-                                                   debugloc);\n+                        bcx = bcx.map_block(|bcx| {\n+                            foreign::trans_native_call(bcx,\n+                                                       callee.ty,\n+                                                       callee.immediate(),\n+                                                       dest.llval,\n+                                                       &llargs[..],\n+                                                       arg_tys,\n+                                                       debugloc)\n+                        });\n                         if let Some((_, target)) = *destination {\n-                            build::Br(bcx, self.llblock(target), debugloc);\n+                            bcx.br(self.llblock(target));\n                         }\n                     },\n                 }\n             }\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bcx: Block<'bcx, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx();\n         if let Some(slot) = self.llpersonalityslot {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = base::alloca(bcx, llretty, \"personalityslot\");\n-            self.llpersonalityslot = Some(slot);\n-            base::call_lifetime_start(bcx, slot);\n-            slot\n+            bcx.with_block(|bcx| {\n+                let slot = base::alloca(bcx, llretty, \"personalityslot\");\n+                self.llpersonalityslot = Some(slot);\n+                base::call_lifetime_start(bcx, slot);\n+                slot\n+            })\n         }\n     }\n \n-    fn make_landing_pad(&mut self, cleanup: Block<'bcx, 'tcx>) -> Block<'bcx, 'tcx> {\n-        let bcx = cleanup.fcx.new_block(\"cleanup\", None);\n+    fn make_landing_pad(&mut self,\n+                        cleanup: BlockAndBuilder<'bcx, 'tcx>)\n+                        -> BlockAndBuilder<'bcx, 'tcx>\n+    {\n         // FIXME(#30941) this doesn't handle msvc-style exceptions\n-        *bcx.lpad.borrow_mut() = Some(LandingPad::gnu());\n+        let bcx = self.fcx.new_block(\"cleanup\", None).build();\n         let ccx = bcx.ccx();\n-        let llpersonality = bcx.fcx.eh_personality();\n+        let llpersonality = self.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = build::LandingPad(bcx, llretty, llpersonality, 1);\n-        build::SetCleanup(bcx, llretval);\n-        let slot = self.get_personality_slot(bcx);\n-        build::Store(bcx, llretval, slot);\n-        build::Br(bcx, cleanup.llbb, DebugLoc::None);\n+        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n+        bcx.set_cleanup(llretval);\n+        let slot = self.get_personality_slot(&bcx);\n+        bcx.store(llretval, slot);\n+        bcx.br(cleanup.llbb());\n         bcx\n     }\n \n     fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n-        match self.unreachable_block {\n-            Some(b) => b,\n-            None => {\n-                let bl = self.fcx.new_block(\"unreachable\", None);\n-                build::Unreachable(bl);\n-                self.unreachable_block = Some(bl);\n-                bl\n-            }\n-        }\n+        self.unreachable_block.unwrap_or_else(|| {\n+            let bl = self.fcx.new_block(\"unreachable\", None);\n+            bl.build().unreachable();\n+            self.unreachable_block = Some(bl);\n+            bl\n+        })\n     }\n \n-    fn bcx(&self, bb: mir::BasicBlock) -> Block<'bcx, 'tcx> {\n-        self.blocks[bb.index()]\n+    fn bcx(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'bcx, 'tcx> {\n+        self.blocks[bb.index()].build()\n     }\n \n     fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {"}, {"sha": "7f03069385fec747cd6f514b93fed24d3b5234d2", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -14,7 +14,8 @@ use middle::subst::Substs;\n use middle::ty::{Ty, TypeFoldable};\n use rustc::middle::const_eval::ConstVal;\n use rustc::mir::repr as mir;\n-use trans::common::{self, Block, C_bool, C_bytes, C_floating_f64, C_integral, C_str_slice};\n+use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n+                    C_str_slice};\n use trans::consts;\n use trans::expr;\n use trans::type_of;\n@@ -25,13 +26,13 @@ use super::MirContext;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constval(&mut self,\n-                          bcx: Block<'bcx, 'tcx>,\n+                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                           cv: &ConstVal,\n                           ty: Ty<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n         let ccx = bcx.ccx();\n-        let val = self.trans_constval_inner(bcx, cv, ty, bcx.fcx.param_substs);\n+        let val = self.trans_constval_inner(bcx, cv, ty, bcx.fcx().param_substs);\n         let val = if common::type_is_immediate(ccx, ty) {\n             OperandValue::Immediate(val)\n         } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n@@ -52,7 +53,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     /// Translate ConstVal into a bare LLVM ValueRef.\n     fn trans_constval_inner(&mut self,\n-                            bcx: common::Block<'bcx, 'tcx>,\n+                            bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                             cv: &ConstVal,\n                             ty: Ty<'tcx>,\n                             param_substs: &'tcx Substs<'tcx>)\n@@ -70,15 +71,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ConstVal::Struct(id) | ConstVal::Tuple(id) |\n             ConstVal::Array(id, _) | ConstVal::Repeat(id, _) => {\n                 let expr = bcx.tcx().map.expect_expr(id);\n-                expr::trans(bcx, expr).datum.val\n+                bcx.with_block(|bcx| {\n+                    expr::trans(bcx, expr).datum.val\n+                })\n             },\n             ConstVal::Function(did) =>\n                 self.trans_fn_ref(bcx, ty, param_substs, did).immediate()\n         }\n     }\n \n     pub fn trans_constant(&mut self,\n-                          bcx: Block<'bcx, 'tcx>,\n+                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {"}, {"sha": "36bbbce7ec46d482408107f27ce489203317d4a1", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::const_eval;\n use rustc::middle::def_id::DefId;\n use rustc::middle::traits;\n use rustc::mir::repr::ItemKind;\n-use trans::common::{Block, fulfill_obligation};\n+use trans::common::{BlockAndBuilder, fulfill_obligation};\n use trans::base;\n use trans::closure;\n use trans::expr;\n@@ -32,7 +32,7 @@ use super::operand::{OperandRef, OperandValue};\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     /// Translate reference to item.\n     pub fn trans_item_ref(&mut self,\n-                          bcx: Block<'bcx, 'tcx>,\n+                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           kind: ItemKind,\n                           substs: &'tcx Substs<'tcx>,\n@@ -53,7 +53,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             .expect(\"def was const, but lookup_const_by_id failed\");\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n-                let d = expr::trans(bcx, expr);\n+                let d = bcx.with_block(|bcx| {\n+                    expr::trans(bcx, expr)\n+                });\n                 OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n             }\n         }\n@@ -66,7 +68,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     ///\n     /// This is an adaptation of callee::trans_fn_ref_with_substs.\n     pub fn trans_fn_ref(&mut self,\n-                        bcx: Block<'bcx, 'tcx>,\n+                        bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         ty: Ty<'tcx>,\n                         substs: &'tcx Substs<'tcx>,\n                         did: DefId)\n@@ -101,7 +103,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     ///\n     /// This is an adaptation of meth::trans_static_method_callee\n     pub fn trans_trait_method(&mut self,\n-                              bcx: Block<'bcx, 'tcx>,\n+                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               ty: Ty<'tcx>,\n                               method_id: DefId,\n                               trait_id: DefId,"}, {"sha": "002584f51c6d731aa2871af85a83df9c1c438965", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -14,9 +14,7 @@ use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::adt;\n use trans::base;\n-use trans::build;\n-use trans::common::{self, Block};\n-use trans::debuginfo::DebugLoc;\n+use trans::common::{self, BlockAndBuilder};\n use trans::machine;\n use trans::type_of;\n use llvm;\n@@ -43,20 +41,20 @@ impl<'tcx> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n-    pub fn alloca<'bcx>(bcx: Block<'bcx, 'tcx>,\n+    pub fn alloca<'bcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         ty: Ty<'tcx>,\n                         name: &str)\n                         -> LvalueRef<'tcx>\n     {\n         assert!(!ty.has_erasable_regions());\n-        let lltemp = base::alloc_ty(bcx, ty, name);\n+        let lltemp = bcx.with_block(|bcx| base::alloc_ty(bcx, ty, name));\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn lvalue_len(&mut self,\n-                      bcx: Block<'bcx, 'tcx>,\n+                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                       lvalue: LvalueRef<'tcx>)\n                       -> ValueRef {\n         match lvalue.ty.to_ty(bcx.tcx()).sty {\n@@ -70,13 +68,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_lvalue(&mut self,\n-                        bcx: Block<'bcx, 'tcx>,\n+                        bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n-        let fcx = bcx.fcx;\n-        let ccx = fcx.ccx;\n+        let fcx = bcx.fcx();\n+        let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n         match *lvalue {\n             mir::Lvalue::Var(index) => self.vars[index as usize],\n@@ -97,7 +95,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n                 let return_ty = fn_return_ty.unwrap();\n                 let llval = if !common::return_type_is_void(bcx.ccx(), return_ty) {\n-                    fcx.get_ret_slot(bcx, fn_return_ty, \"\")\n+                    bcx.with_block(|bcx| {\n+                        fcx.get_ret_slot(bcx, fn_return_ty, \"\")\n+                    })\n                 } else {\n                     // This is a void return; that is, there\u2019s no place to store the value and\n                     // there cannot really be one (or storing into it doesn\u2019t make sense, anyway).\n@@ -117,12 +117,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n-                        if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n-                            (base::load_ty(bcx, tr_base.llval, base_ty),\n-                             ptr::null_mut())\n-                        } else {\n-                            base::load_fat_ptr(bcx, tr_base.llval, base_ty)\n-                        }\n+                        bcx.with_block(|bcx| {\n+                            if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                                (base::load_ty(bcx, tr_base.llval, base_ty),\n+                                 ptr::null_mut())\n+                            } else {\n+                                base::load_fat_ptr(bcx, tr_base.llval, base_ty)\n+                            }\n+                        })\n                     }\n                     mir::ProjectionElem::Field(ref field) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n@@ -138,18 +140,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         } else {\n                             adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n                         };\n-                        (adt::trans_field_ptr(bcx, &base_repr, base, Disr(discr), field.index()),\n-                         if is_sized {\n-                             ptr::null_mut()\n-                         } else {\n-                             tr_base.llextra\n-                         })\n+                        let llprojected = bcx.with_block(|bcx| {\n+                            adt::trans_field_ptr(bcx, &base_repr, base, Disr(discr), field.index())\n+                        });\n+                        let llextra = if is_sized {\n+                            ptr::null_mut()\n+                        } else {\n+                            tr_base.llextra\n+                        };\n+                        (llprojected, llextra)\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n                         let llindex = self.prepare_index(bcx, index.immediate());\n                         let zero = common::C_uint(bcx.ccx(), 0u64);\n-                        (build::InBoundsGEP(bcx, tr_base.llval, &[zero, llindex]),\n+                        (bcx.inbounds_gep(tr_base.llval, &[zero, llindex]),\n                          ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n@@ -158,18 +163,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let lloffset = common::C_u32(bcx.ccx(), offset);\n                         let llindex = self.prepare_index(bcx, lloffset);\n                         let zero = common::C_uint(bcx.ccx(), 0u64);\n-                        (build::InBoundsGEP(bcx, tr_base.llval, &[zero, llindex]),\n+                        (bcx.inbounds_gep(tr_base.llval, &[zero, llindex]),\n                          ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = common::C_u32(bcx.ccx(), offset);\n                         let lllen = self.lvalue_len(bcx, tr_base);\n-                        let llindex = build::Sub(bcx, lllen, lloffset, DebugLoc::None);\n+                        let llindex = bcx.sub(lllen, lloffset);\n                         let llindex = self.prepare_index(bcx, llindex);\n                         let zero = common::C_uint(bcx.ccx(), 0u64);\n-                        (build::InBoundsGEP(bcx, tr_base.llval, &[zero, llindex]),\n+                        (bcx.inbounds_gep(tr_base.llval, &[zero, llindex]),\n                          ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n@@ -190,17 +195,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     ///\n     /// nmatsakis: is this still necessary? Not sure.\n     fn prepare_index(&mut self,\n-                     bcx: Block<'bcx, 'tcx>,\n+                     bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                      llindex: ValueRef)\n                      -> ValueRef\n     {\n         let ccx = bcx.ccx();\n         let index_size = machine::llbitsize_of_real(bcx.ccx(), common::val_ty(llindex));\n         let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type());\n         if index_size < int_size {\n-            build::ZExt(bcx, llindex, ccx.int_type())\n+            bcx.zext(llindex, ccx.int_type())\n         } else if index_size > int_size {\n-            build::Trunc(bcx, llindex, ccx.int_type())\n+            bcx.trunc(llindex, ccx.int_type())\n         } else {\n             llindex\n         }"}, {"sha": "972340e7f5afd9e44d2cf0e6fdd414e6b5aee098", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -13,9 +13,7 @@ use llvm::{self, ValueRef};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n-use trans::build;\n-use trans::common::{self, Block, LandingPad};\n-use trans::debuginfo::DebugLoc;\n+use trans::common::{self, Block, BlockAndBuilder};\n use trans::expr;\n use trans::type_of;\n \n@@ -79,26 +77,28 @@ enum TempRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n-    let fcx = bcx.fcx;\n+pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n+    let fcx = bcx.fcx();\n     let mir = bcx.mir();\n \n     let mir_blocks = bcx.mir().all_basic_blocks();\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n-    let lvalue_temps = analyze::lvalue_temps(bcx, mir);\n+    let lvalue_temps = bcx.with_block(|bcx| {\n+      analyze::lvalue_temps(bcx, mir)\n+    });\n \n     // Allocate variable and temp allocas\n     let vars = mir.var_decls.iter()\n                             .map(|decl| (bcx.monomorphize(&decl.ty), decl.name))\n-                            .map(|(mty, name)| LvalueRef::alloca(bcx, mty, &name.as_str()))\n+                            .map(|(mty, name)| LvalueRef::alloca(&bcx, mty, &name.as_str()))\n                             .collect();\n     let temps = mir.temp_decls.iter()\n                               .map(|decl| bcx.monomorphize(&decl.ty))\n                               .enumerate()\n                               .map(|(i, mty)| if lvalue_temps.contains(i) {\n-                                  TempRef::Lvalue(LvalueRef::alloca(bcx,\n+                                  TempRef::Lvalue(LvalueRef::alloca(&bcx,\n                                                                     mty,\n                                                                     &format!(\"temp{:?}\", i)))\n                               } else {\n@@ -108,24 +108,20 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(bcx, mir);\n+    let args = arg_value_refs(&bcx, mir);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'bcx,'tcx>> =\n         mir_blocks.iter()\n                   .map(|&bb|{\n-                      let bcx = fcx.new_block(&format!(\"{:?}\", bb), None);\n                       // FIXME(#30941) this doesn't handle msvc-style exceptions\n-                      if mir.basic_block_data(bb).is_cleanup {\n-                          *bcx.lpad.borrow_mut() = Some(LandingPad::gnu())\n-                      }\n-                      bcx\n+                      fcx.new_block(&format!(\"{:?}\", bb), None)\n                   })\n                   .collect();\n \n     // Branch to the START block\n     let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n-    build::Br(bcx, start_bcx.llbb, DebugLoc::None);\n+    bcx.br(start_bcx.llbb);\n \n     let mut mircx = MirContext {\n         mir: mir,\n@@ -147,11 +143,11 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n-fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n+fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>)\n                               -> Vec<LvalueRef<'tcx>> {\n     // FIXME tupled_args? I think I'd rather that mapping is done in MIR land though\n-    let fcx = bcx.fcx;\n+    let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = fcx.arg_offset() as c_uint;\n     mir.arg_decls\n@@ -174,18 +170,23 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n                let lldata = llvm::get_param(fcx.llfn, idx);\n                let llextra = llvm::get_param(fcx.llfn, idx + 1);\n                idx += 2;\n-               let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-               build::Store(bcx, lldata, expr::get_dataptr(bcx, lltemp));\n-               build::Store(bcx, llextra, expr::get_meta(bcx, lltemp));\n+               let (lltemp, dataptr, meta) = bcx.with_block(|bcx| {\n+                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+                   (lltemp, expr::get_dataptr(bcx, lltemp), expr::get_meta(bcx, lltemp))\n+               });\n+               bcx.store(lldata, dataptr);\n+               bcx.store(llextra, meta);\n                lltemp\n            } else {\n                // otherwise, arg is passed by value, so make a\n                // temporary and store it there\n                let llarg = llvm::get_param(fcx.llfn, idx);\n                idx += 1;\n-               let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-               base::store_ty(bcx, llarg, lltemp, arg_ty);\n-               lltemp\n+               bcx.with_block(|bcx| {\n+                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+                   base::store_ty(bcx, llarg, lltemp, arg_ty);\n+                   lltemp\n+               })\n            };\n            LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n        })"}, {"sha": "d0eaaeef057710b697c5c968d46a6dfc5a1669cf", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -12,7 +12,7 @@ use llvm::ValueRef;\n use rustc::middle::ty::{Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use trans::base;\n-use trans::common::{self, Block};\n+use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n \n use super::{MirContext, TempRef};\n@@ -37,8 +37,9 @@ pub enum OperandValue {\n ///\n /// NOTE: unless you know a value's type exactly, you should not\n /// generate LLVM opcodes acting on it and instead act via methods,\n-/// to avoid nasty edge cases. In particular, using `build::Store`\n-/// directly is sure to cause problems - use `store_operand` instead.\n+/// to avoid nasty edge cases. In particular, using `Builder.store`\n+/// directly is sure to cause problems -- use `MirContext.store_operand`\n+/// instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n     // The value.\n@@ -58,7 +59,7 @@ impl<'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn repr<'bcx>(self, bcx: Block<'bcx, 'tcx>) -> String {\n+    pub fn repr<'bcx>(self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> String {\n         match self.val {\n             OperandValue::Ref(r) => {\n                 format!(\"OperandRef(Ref({}) @ {:?})\",\n@@ -90,7 +91,7 @@ impl<'tcx> OperandRef<'tcx> {\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_operand(&mut self,\n-                         bcx: Block<'bcx, 'tcx>,\n+                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -124,10 +125,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                        ty);\n                 let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n                     datum::ByValue => {\n-                        OperandValue::Immediate(base::load_ty(bcx, tr_lvalue.llval, ty))\n+                        bcx.with_block(|bcx| {\n+                            OperandValue::Immediate(base::load_ty(bcx, tr_lvalue.llval, ty))\n+                        })\n                     }\n                     datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                        let (lldata, llextra) = base::load_fat_ptr(bcx, tr_lvalue.llval, ty);\n+                        let (lldata, llextra) = bcx.with_block(|bcx| {\n+                            base::load_fat_ptr(bcx, tr_lvalue.llval, ty)\n+                        });\n                         OperandValue::FatPtr(lldata, llextra)\n                     }\n                     datum::ByRef => OperandValue::Ref(tr_lvalue.llval)\n@@ -148,7 +153,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_operand_into(&mut self,\n-                              bcx: Block<'bcx, 'tcx>,\n+                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               lldest: ValueRef,\n                               operand: &mir::Operand<'tcx>)\n     {\n@@ -164,11 +169,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn store_operand(&mut self,\n-                         bcx: Block<'bcx, 'tcx>,\n+                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>)\n     {\n         debug!(\"store_operand: operand={}\", operand.repr(bcx));\n+        bcx.with_block(|bcx| {\n+            self.store_operand_direct(bcx, lldest, operand)\n+        })\n+    }\n+\n+    pub fn store_operand_direct(&mut self,\n+                                bcx: Block<'bcx, 'tcx>,\n+                                lldest: ValueRef,\n+                                operand: OperandRef<'tcx>)\n+    {\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n         if common::type_is_zero_size(bcx.ccx(), operand.ty) {"}, {"sha": "ab0c299af05ce8fe8c2f6cd0563ceed6231e3504", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 184, "deletions": 152, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -15,8 +15,7 @@ use rustc::mir::repr as mir;\n \n use trans::asm;\n use trans::base;\n-use trans::build;\n-use trans::common::{self, Block, Result};\n+use trans::common::{self, BlockAndBuilder, Result};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n@@ -33,18 +32,18 @@ use super::lvalue::LvalueRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n-                        bcx: Block<'bcx, 'tcx>,\n+                        bcx: BlockAndBuilder<'bcx, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> Block<'bcx, 'tcx>\n+                        -> BlockAndBuilder<'bcx, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={}, rvalue={:?})\",\n                bcx.val_to_string(dest.llval),\n                rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                self.trans_operand_into(bcx, dest.llval, operand);\n+                self.trans_operand_into(&bcx, dest.llval, operand);\n                 bcx\n             }\n \n@@ -53,47 +52,51 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(bcx, dest.llval, temp);\n+                    self.store_operand(&bcx, dest.llval, temp);\n                     return bcx;\n                 }\n \n                 // Unsize of a nontrivial struct. I would prefer for\n                 // this to be eliminated by MIR translation, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.trans_operand(bcx, operand);\n-                match operand.val {\n-                    OperandValue::FatPtr(..) => unreachable!(),\n-                    OperandValue::Immediate(llval) => {\n-                        // unsize from an immediate structure. We don't\n-                        // really need a temporary alloca here, but\n-                        // avoiding it would require us to have\n-                        // `coerce_unsized_into` use extractvalue to\n-                        // index into the struct, and this case isn't\n-                        // important enough for it.\n-                        debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let lltemp = base::alloc_ty(bcx, operand.ty, \"__unsize_temp\");\n-                        base::store_ty(bcx, llval, lltemp, operand.ty);\n-                        base::coerce_unsized_into(bcx,\n-                                                  lltemp, operand.ty,\n-                                                  dest.llval, cast_ty);\n-                    }\n-                    OperandValue::Ref(llref) => {\n-                        base::coerce_unsized_into(bcx,\n-                                                  llref, operand.ty,\n-                                                  dest.llval, cast_ty);\n+                let operand = self.trans_operand(&bcx, operand);\n+                bcx.with_block(|bcx| {\n+                    match operand.val {\n+                        OperandValue::FatPtr(..) => unreachable!(),\n+                        OperandValue::Immediate(llval) => {\n+                            // unsize from an immediate structure. We don't\n+                            // really need a temporary alloca here, but\n+                            // avoiding it would require us to have\n+                            // `coerce_unsized_into` use extractvalue to\n+                            // index into the struct, and this case isn't\n+                            // important enough for it.\n+                            debug!(\"trans_rvalue: creating ugly alloca\");\n+                            let lltemp = base::alloc_ty(bcx, operand.ty, \"__unsize_temp\");\n+                            base::store_ty(bcx, llval, lltemp, operand.ty);\n+                            base::coerce_unsized_into(bcx,\n+                                                      lltemp, operand.ty,\n+                                                      dest.llval, cast_ty);\n+                        }\n+                        OperandValue::Ref(llref) => {\n+                            base::coerce_unsized_into(bcx,\n+                                                      llref, operand.ty,\n+                                                      dest.llval, cast_ty);\n+                        }\n                     }\n-                }\n+                });\n                 bcx\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n-                let elem = self.trans_operand(bcx, elem);\n-                let size = self.trans_constval(bcx, &count.value, count.ty).immediate();\n-                let base = expr::get_dataptr(bcx, dest.llval);\n-                tvec::iter_vec_raw(bcx, base, elem.ty, size, |bcx, llslot, _| {\n-                    self.store_operand(bcx, llslot, elem);\n-                    bcx\n+                let elem = self.trans_operand(&bcx, elem);\n+                let size = self.trans_constval(&bcx, &count.value, count.ty).immediate();\n+                bcx.map_block(|block| {\n+                    let base = expr::get_dataptr(block, dest.llval);\n+                    tvec::iter_vec_raw(block, base, elem.ty, size, |block, llslot, _| {\n+                        self.store_operand_direct(block, llslot, elem);\n+                        block\n+                    })\n                 })\n             }\n \n@@ -102,27 +105,31 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     mir::AggregateKind::Adt(adt_def, index, _) => {\n                         let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n                         let disr = Disr::from(adt_def.variants[index].disr_val);\n-                        adt::trans_set_discr(bcx, &*repr, dest.llval, Disr::from(disr));\n+                        bcx.with_block(|bcx| {\n+                            adt::trans_set_discr(bcx, &*repr, dest.llval, Disr::from(disr));\n+                        });\n                         for (i, operand) in operands.iter().enumerate() {\n-                            let op = self.trans_operand(bcx, operand);\n+                            let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n-                                let lldest_i = adt::trans_field_ptr(bcx, &*repr, val, disr, i);\n-                                self.store_operand(bcx, lldest_i, op);\n+                                let lldest_i = bcx.with_block(|bcx| {\n+                                    adt::trans_field_ptr(bcx, &*repr, val, disr, i)\n+                                });\n+                                self.store_operand(&bcx, lldest_i, op);\n                             }\n                         }\n                     },\n                     _ => {\n                         for (i, operand) in operands.iter().enumerate() {\n-                            let op = self.trans_operand(bcx, operand);\n+                            let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 // Note: perhaps this should be StructGep, but\n                                 // note that in some cases the values here will\n                                 // not be structs but arrays.\n-                                let dest = build::GEPi(bcx, dest.llval, &[0, i]);\n-                                self.store_operand(bcx, dest, op);\n+                                let dest = bcx.gepi(dest.llval, &[0, i]);\n+                                self.store_operand(&bcx, dest, op);\n                             }\n                         }\n                     }\n@@ -132,49 +139,54 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Slice { ref input, from_start, from_end } => {\n                 let ccx = bcx.ccx();\n-                let input = self.trans_lvalue(bcx, input);\n-                let (llbase, lllen) = tvec::get_base_and_len(bcx,\n-                                                             input.llval,\n-                                                             input.ty.to_ty(bcx.tcx()));\n-                let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n+                let input = self.trans_lvalue(&bcx, input);\n+                let (llbase, lllen) = bcx.with_block(|bcx| {\n+                    tvec::get_base_and_len(bcx,\n+                                           input.llval,\n+                                           input.ty.to_ty(bcx.tcx()))\n+                });\n+                let llbase1 = bcx.gepi(llbase, &[from_start]);\n                 let adj = common::C_uint(ccx, from_start + from_end);\n-                let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n-                let lladdrdest = expr::get_dataptr(bcx, dest.llval);\n-                build::Store(bcx, llbase1, lladdrdest);\n-                let llmetadest = expr::get_meta(bcx, dest.llval);\n-                build::Store(bcx, lllen1, llmetadest);\n+                let lllen1 = bcx.sub(lllen, adj);\n+                let (lladdrdest, llmetadest) = bcx.with_block(|bcx| {\n+                    (expr::get_dataptr(bcx, dest.llval), expr::get_meta(bcx, dest.llval))\n+                });\n+                bcx.store(llbase1, lladdrdest);\n+                bcx.store(lllen1, llmetadest);\n                 bcx\n             }\n \n             mir::Rvalue::InlineAsm(ref inline_asm) => {\n-                asm::trans_inline_asm(bcx, inline_asm)\n+                bcx.map_block(|bcx| {\n+                    asm::trans_inline_asm(bcx, inline_asm)\n+                })\n             }\n \n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(bcx, dest.llval, temp);\n+                self.store_operand(&bcx, dest.llval, temp);\n                 bcx\n             }\n         }\n     }\n \n     pub fn trans_rvalue_operand(&mut self,\n-                                bcx: Block<'bcx, 'tcx>,\n+                                bcx: BlockAndBuilder<'bcx, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (Block<'bcx, 'tcx>, OperandRef<'tcx>)\n+                                -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let operand = self.trans_operand(bcx, operand);\n+                let operand = self.trans_operand(&bcx, operand);\n                 (bcx, operand)\n             }\n \n             mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n-                let operand = self.trans_operand(bcx, operand);\n-                debug!(\"cast operand is {}\", operand.repr(bcx));\n+                let operand = self.trans_operand(&bcx, operand);\n+                debug!(\"cast operand is {}\", operand.repr(&bcx));\n                 let cast_ty = bcx.monomorphize(&cast_ty);\n \n                 let val = match *kind {\n@@ -199,15 +211,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n-                                let (lldata, llextra) =\n+                                let (lldata, llextra) = bcx.with_block(|bcx| {\n                                     base::unsize_thin_ptr(bcx, lldata,\n-                                                          operand.ty, cast_ty);\n+                                                          operand.ty, cast_ty)\n+                                });\n                                 OperandValue::FatPtr(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n                                 bcx.sess().bug(\n                                     &format!(\"by-ref operand {} in trans_rvalue_operand\",\n-                                             operand.repr(bcx)));\n+                                             operand.repr(&bcx)));\n                             }\n                         }\n                     }\n@@ -220,8 +233,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let (llval, ll_t_in, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n                             let llval = operand.immediate();\n-                            let discr = adt::trans_get_discr(bcx, &*repr, llval,\n-                                                             None, true);\n+                            let discr = bcx.with_block(|bcx| {\n+                                adt::trans_get_discr(bcx, &*repr, llval, None, true)\n+                            });\n                             (discr, common::val_ty(discr), adt::is_discr_signed(&*repr))\n                         } else {\n                             (operand.immediate(), ll_t_in, operand.ty.is_signed())\n@@ -232,43 +246,43 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 let srcsz = ll_t_in.int_width();\n                                 let dstsz = ll_t_out.int_width();\n                                 if srcsz == dstsz {\n-                                    build::BitCast(bcx, llval, ll_t_out)\n+                                    bcx.bitcast(llval, ll_t_out)\n                                 } else if srcsz > dstsz {\n-                                    build::Trunc(bcx, llval, ll_t_out)\n+                                    bcx.trunc(llval, ll_t_out)\n                                 } else if signed {\n-                                    build::SExt(bcx, llval, ll_t_out)\n+                                    bcx.sext(llval, ll_t_out)\n                                 } else {\n-                                    build::ZExt(bcx, llval, ll_t_out)\n+                                    bcx.zext(llval, ll_t_out)\n                                 }\n                             }\n                             (CastTy::Float, CastTy::Float) => {\n                                 let srcsz = ll_t_in.float_width();\n                                 let dstsz = ll_t_out.float_width();\n                                 if dstsz > srcsz {\n-                                    build::FPExt(bcx, llval, ll_t_out)\n+                                    bcx.fpext(llval, ll_t_out)\n                                 } else if srcsz > dstsz {\n-                                    build::FPTrunc(bcx, llval, ll_t_out)\n+                                    bcx.fptrunc(llval, ll_t_out)\n                                 } else {\n                                     llval\n                                 }\n                             }\n                             (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                             (CastTy::FnPtr, CastTy::Ptr(_)) |\n                             (CastTy::RPtr(_), CastTy::Ptr(_)) =>\n-                                build::PointerCast(bcx, llval, ll_t_out),\n+                                bcx.pointercast(llval, ll_t_out),\n                             (CastTy::Ptr(_), CastTy::Int(_)) |\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n-                                build::PtrToInt(bcx, llval, ll_t_out),\n+                                bcx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) =>\n-                                build::IntToPtr(bcx, llval, ll_t_out),\n+                                bcx.inttoptr(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Float) if signed =>\n-                                build::SIToFP(bcx, llval, ll_t_out),\n+                                bcx.sitofp(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Float) =>\n-                                build::UIToFP(bcx, llval, ll_t_out),\n+                                bcx.uitofp(llval, ll_t_out),\n                             (CastTy::Float, CastTy::Int(IntTy::I)) =>\n-                                build::FPToSI(bcx, llval, ll_t_out),\n+                                bcx.fptosi(llval, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n-                                build::FPToUI(bcx, llval, ll_t_out),\n+                                bcx.fptoui(llval, ll_t_out),\n                             _ => bcx.ccx().sess().bug(\n                                 &format!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n                             )\n@@ -282,28 +296,29 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n-                                let data_cast = build::PointerCast(bcx, data_ptr, ll_cft[0]);\n+                                let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n                                 assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n                                 OperandValue::FatPtr(data_cast, meta_ptr)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llval = build::PointerCast(bcx, data_ptr, ll_cast_ty);\n+                                let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n                             panic!(\"Unexpected non-FatPtr operand\")\n                         }\n                     }\n                 };\n-                (bcx, OperandRef {\n+                let operand = OperandRef {\n                     val: val,\n                     ty: cast_ty\n-                })\n+                };\n+                (bcx, operand)\n             }\n \n             mir::Rvalue::Ref(_, bk, ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n \n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n                 let ref_ty = bcx.tcx().mk_ref(\n@@ -313,66 +328,70 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                if common::type_is_sized(bcx.tcx(), ty) {\n-                    (bcx, OperandRef {\n+                let operand = if common::type_is_sized(bcx.tcx(), ty) {\n+                    OperandRef {\n                         val: OperandValue::Immediate(tr_lvalue.llval),\n                         ty: ref_ty,\n-                    })\n+                    }\n                 } else {\n-                    (bcx, OperandRef {\n+                    OperandRef {\n                         val: OperandValue::FatPtr(tr_lvalue.llval,\n                                                   tr_lvalue.llextra),\n                         ty: ref_ty,\n-                    })\n-                }\n+                    }\n+                };\n+                (bcx, operand)\n             }\n \n             mir::Rvalue::Len(ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                (bcx, OperandRef {\n-                    val: OperandValue::Immediate(self.lvalue_len(bcx, tr_lvalue)),\n+                let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n+                let operand = OperandRef {\n+                    val: OperandValue::Immediate(self.lvalue_len(&bcx, tr_lvalue)),\n                     ty: bcx.tcx().types.usize,\n-                })\n+                };\n+                (bcx, operand)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.trans_operand(bcx, lhs);\n-                let rhs = self.trans_operand(bcx, rhs);\n+                let lhs = self.trans_operand(&bcx, lhs);\n+                let rhs = self.trans_operand(&bcx, rhs);\n                 let llresult = if common::type_is_fat_ptr(bcx.tcx(), lhs.ty) {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::FatPtr(lhs_addr, lhs_extra),\n                          OperandValue::FatPtr(rhs_addr, rhs_extra)) => {\n-                            base::compare_fat_ptrs(bcx,\n-                                                   lhs_addr, lhs_extra,\n-                                                   rhs_addr, rhs_extra,\n-                                                   lhs.ty, op.to_hir_binop(),\n-                                                   DebugLoc::None)\n+                            bcx.with_block(|bcx| {\n+                                base::compare_fat_ptrs(bcx,\n+                                                       lhs_addr, lhs_extra,\n+                                                       rhs_addr, rhs_extra,\n+                                                       lhs.ty, op.to_hir_binop(),\n+                                                       DebugLoc::None)\n+                            })\n                         }\n                         _ => unreachable!()\n                     }\n \n                 } else {\n-                    self.trans_scalar_binop(bcx, op,\n+                    self.trans_scalar_binop(&bcx, op,\n                                             lhs.immediate(), rhs.immediate(),\n-                                            lhs.ty, DebugLoc::None)\n+                                            lhs.ty)\n                 };\n-                (bcx, OperandRef {\n+                let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n                     ty: self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty),\n-                })\n+                };\n+                (bcx, operand)\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.trans_operand(bcx, operand);\n+                let operand = self.trans_operand(&bcx, operand);\n                 let lloperand = operand.immediate();\n                 let is_float = operand.ty.is_fp();\n-                let debug_loc = DebugLoc::None;\n                 let llval = match op {\n-                    mir::UnOp::Not => build::Not(bcx, lloperand, debug_loc),\n+                    mir::UnOp::Not => bcx.not(lloperand),\n                     mir::UnOp::Neg => if is_float {\n-                        build::FNeg(bcx, lloperand, debug_loc)\n+                        bcx.fneg(lloperand)\n                     } else {\n-                        build::Neg(bcx, lloperand, debug_loc)\n+                        bcx.neg(lloperand)\n                     }\n                 };\n                 (bcx, OperandRef {\n@@ -389,16 +408,22 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let llalign = common::C_uint(bcx.ccx(), align);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n-                let Result { bcx, val: llval } = base::malloc_raw_dyn(bcx,\n-                                                                      llty_ptr,\n-                                                                      box_ty,\n-                                                                      llsize,\n-                                                                      llalign,\n-                                                                      DebugLoc::None);\n-                (bcx, OperandRef {\n-                    val: OperandValue::Immediate(llval),\n+                let mut llval = None;\n+                let bcx = bcx.map_block(|bcx| {\n+                    let Result { bcx, val } = base::malloc_raw_dyn(bcx,\n+                                                                   llty_ptr,\n+                                                                   box_ty,\n+                                                                   llsize,\n+                                                                   llalign,\n+                                                                   DebugLoc::None);\n+                    llval = Some(val);\n+                    bcx\n+                });\n+                let operand = OperandRef {\n+                    val: OperandValue::Immediate(llval.unwrap()),\n                     ty: box_ty,\n-                })\n+                };\n+                (bcx, operand)\n             }\n \n             mir::Rvalue::Repeat(..) |\n@@ -411,36 +436,35 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n-                              bcx: Block<'bcx, 'tcx>,\n+                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n-                              input_ty: Ty<'tcx>,\n-                              debug_loc: DebugLoc) -> ValueRef {\n+                              input_ty: Ty<'tcx>) -> ValueRef {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n         match op {\n             mir::BinOp::Add => if is_float {\n-                build::FAdd(bcx, lhs, rhs, debug_loc)\n+                bcx.fadd(lhs, rhs)\n             } else {\n-                build::Add(bcx, lhs, rhs, debug_loc)\n+                bcx.add(lhs, rhs)\n             },\n             mir::BinOp::Sub => if is_float {\n-                build::FSub(bcx, lhs, rhs, debug_loc)\n+                bcx.fsub(lhs, rhs)\n             } else {\n-                build::Sub(bcx, lhs, rhs, debug_loc)\n+                bcx.sub(lhs, rhs)\n             },\n             mir::BinOp::Mul => if is_float {\n-                build::FMul(bcx, lhs, rhs, debug_loc)\n+                bcx.fmul(lhs, rhs)\n             } else {\n-                build::Mul(bcx, lhs, rhs, debug_loc)\n+                bcx.mul(lhs, rhs)\n             },\n             mir::BinOp::Div => if is_float {\n-                build::FDiv(bcx, lhs, rhs, debug_loc)\n+                bcx.fdiv(lhs, rhs)\n             } else if is_signed {\n-                build::SDiv(bcx, lhs, rhs, debug_loc)\n+                bcx.sdiv(lhs, rhs)\n             } else {\n-                build::UDiv(bcx, lhs, rhs, debug_loc)\n+                bcx.udiv(lhs, rhs)\n             },\n             mir::BinOp::Rem => if is_float {\n                 // LLVM currently always lowers the `frem` instructions appropriate\n@@ -471,39 +495,47 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n                                                     tcx.types.f64);\n                     if input_ty == tcx.types.f32 {\n-                        let lllhs = build::FPExt(bcx, lhs, f64t);\n-                        let llrhs = build::FPExt(bcx, rhs, f64t);\n-                        let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n-                                                None, debug_loc);\n-                        build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n+                        let lllhs = bcx.fpext(lhs, f64t);\n+                        let llrhs = bcx.fpext(rhs, f64t);\n+                        let llres = bcx.call(llfn, &[lllhs, llrhs], None, None);\n+                        bcx.fptrunc(llres, Type::f32(bcx.ccx()))\n                     } else {\n-                        build::Call(bcx, llfn, &[lhs, rhs],\n-                                    None, debug_loc)\n+                        bcx.call(llfn, &[lhs, rhs], None, None)\n                     }\n                 } else {\n-                    build::FRem(bcx, lhs, rhs, debug_loc)\n+                    bcx.frem(lhs, rhs)\n                 }\n             } else if is_signed {\n-                build::SRem(bcx, lhs, rhs, debug_loc)\n+                bcx.srem(lhs, rhs)\n             } else {\n-                build::URem(bcx, lhs, rhs, debug_loc)\n+                bcx.urem(lhs, rhs)\n             },\n-            mir::BinOp::BitOr => build::Or(bcx, lhs, rhs, debug_loc),\n-            mir::BinOp::BitAnd => build::And(bcx, lhs, rhs, debug_loc),\n-            mir::BinOp::BitXor => build::Xor(bcx, lhs, rhs, debug_loc),\n-            mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n-                                                              lhs,\n-                                                              rhs,\n-                                                              debug_loc),\n-            mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n-                                                              input_ty,\n-                                                              lhs,\n-                                                              rhs,\n-                                                              debug_loc),\n+            mir::BinOp::BitOr => bcx.or(lhs, rhs),\n+            mir::BinOp::BitAnd => bcx.and(lhs, rhs),\n+            mir::BinOp::BitXor => bcx.xor(lhs, rhs),\n+            mir::BinOp::Shl => {\n+                bcx.with_block(|bcx| {\n+                    common::build_unchecked_lshift(bcx,\n+                                                   lhs,\n+                                                   rhs,\n+                                                   DebugLoc::None)\n+                })\n+            }\n+            mir::BinOp::Shr => {\n+                bcx.with_block(|bcx| {\n+                    common::build_unchecked_rshift(bcx,\n+                                                   input_ty,\n+                                                   lhs,\n+                                                   rhs,\n+                                                   DebugLoc::None)\n+                })\n+            }\n             mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n-                base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n-                                           op.to_hir_binop(), debug_loc)\n+                bcx.with_block(|bcx| {\n+                    base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n+                                               op.to_hir_binop(), DebugLoc::None)\n+                })\n             }\n         }\n     }"}, {"sha": "0307fd649c83554c9e2669b4a8d1ab531978ad85", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=8b95b0a6f98bc58f9a8b39caa8c681d1500c2e9b", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use rustc::mir::repr as mir;\n-use trans::common::Block;\n+use trans::common::BlockAndBuilder;\n \n use super::MirContext;\n use super::TempRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_statement(&mut self,\n-                           bcx: Block<'bcx, 'tcx>,\n+                           bcx: BlockAndBuilder<'bcx, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> Block<'bcx, 'tcx> {\n+                           -> BlockAndBuilder<'bcx, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n         match statement.kind {\n@@ -43,7 +43,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     }\n                     _ => {\n-                        let tr_dest = self.trans_lvalue(bcx, lvalue);\n+                        let tr_dest = self.trans_lvalue(&bcx, lvalue);\n                         self.trans_rvalue(bcx, tr_dest, rvalue)\n                     }\n                 }"}]}