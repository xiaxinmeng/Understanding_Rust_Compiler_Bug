{"sha": "6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNWU2M2E0OGMzYmU3ZGUyZmFmOTE0YzJhOWUxOTRmZjdjZWRlOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-29T09:42:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-29T09:42:40Z"}, "message": "Auto merge of #50526 - moxian:just-fix, r=alexcrichton\n\nAdd a fallback for stacktrace printing for older Windows versions.\n\nSome time ago we switched stack inspection functions of dbghelp.dll to their newer alternatives that also capture inlined context.\nUnfortunately, said new alternatives are not present in older dbghelp.dll versions.\nIn particular Windows 7 at the time of writing has dbghelp.dll version 6.1.7601 from 2010, that lacks StackWalkEx and friends.\n\nTested on my Windows 7 - both msvc and gnu versions produce a readable stacktrace.\n\nFixes #50138", "tree": {"sha": "c596cdfcdc083b157c7ea18d2bd416f151dcd24d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c596cdfcdc083b157c7ea18d2bd416f151dcd24d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "html_url": "https://github.com/rust-lang/rust/commit/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eb6969c6a2efba9e59544bc18b4d96a9f2b2504", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb6969c6a2efba9e59544bc18b4d96a9f2b2504", "html_url": "https://github.com/rust-lang/rust/commit/2eb6969c6a2efba9e59544bc18b4d96a9f2b2504"}, {"sha": "be7f619870085121bdd7911aa882c35e70aedb8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/be7f619870085121bdd7911aa882c35e70aedb8a", "html_url": "https://github.com/rust-lang/rust/commit/be7f619870085121bdd7911aa882c35e70aedb8a"}], "stats": {"total": 499, "additions": 398, "deletions": 101}, "files": [{"sha": "7ef4e203571b28e6624138655fd58252de1bb403", "filename": "src/libstd/sys/windows/backtrace/mod.rs", "status": "modified", "additions": 210, "deletions": 63, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -46,110 +46,257 @@ mod printing;\n #[path = \"backtrace_gnu.rs\"]\n pub mod gnu;\n \n-pub use self::printing::{resolve_symname, foreach_symbol_fileline};\n+pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n+use self::printing::{load_printing_fns_64, load_printing_fns_ex};\n \n-pub fn unwind_backtrace(frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n+pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n     let dbghelp = DynamicLibrary::open(\"dbghelp.dll\")?;\n \n     // Fetch the symbols necessary from dbghelp.dll\n     let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn)?;\n     let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn)?;\n-    let StackWalkEx = sym!(dbghelp, \"StackWalkEx\", StackWalkExFn)?;\n+\n+    // StackWalkEx might not be present and we'll fall back to StackWalk64\n+    let sw_var = match sym!(dbghelp, \"StackWalkEx\", StackWalkExFn) {\n+        Ok(StackWalkEx) => {\n+            StackWalkVariant::StackWalkEx(StackWalkEx, load_printing_fns_ex(&dbghelp)?)\n+        }\n+        Err(e) => match sym!(dbghelp, \"StackWalk64\", StackWalk64Fn) {\n+            Ok(StackWalk64) => {\n+                StackWalkVariant::StackWalk64(StackWalk64, load_printing_fns_64(&dbghelp)?)\n+            }\n+            Err(..) => return Err(e),\n+        },\n+    };\n \n     // Allocate necessary structures for doing the stack walk\n     let process = unsafe { c::GetCurrentProcess() };\n-    let thread = unsafe { c::GetCurrentThread() };\n-    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n-    unsafe { c::RtlCaptureContext(&mut context) };\n-    let mut frame: c::STACKFRAME_EX = unsafe { mem::zeroed() };\n-    frame.StackFrameSize = mem::size_of_val(&frame) as c::DWORD;\n-    let image = init_frame(&mut frame, &context);\n \n     let backtrace_context = BacktraceContext {\n         handle: process,\n         SymCleanup,\n+        StackWalkVariant: sw_var,\n         dbghelp,\n     };\n \n     // Initialize this process's symbols\n     let ret = unsafe { SymInitialize(process, ptr::null_mut(), c::TRUE) };\n     if ret != c::TRUE {\n-        return Ok((0, backtrace_context))\n+        return Ok((0, backtrace_context));\n     }\n \n     // And now that we're done with all the setup, do the stack walking!\n+    match backtrace_context.StackWalkVariant {\n+        StackWalkVariant::StackWalkEx(StackWalkEx, _) => {\n+            set_frames(StackWalkEx, frames).map(|i| (i, backtrace_context))\n+        }\n+\n+        StackWalkVariant::StackWalk64(StackWalk64, _) => {\n+            set_frames(StackWalk64, frames).map(|i| (i, backtrace_context))\n+        }\n+    }\n+}\n+\n+fn set_frames<W: StackWalker>(StackWalk: W, frames: &mut [Frame]) -> io::Result<usize> {\n+    let process = unsafe { c::GetCurrentProcess() };\n+    let thread = unsafe { c::GetCurrentProcess() };\n+    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n+    unsafe { c::RtlCaptureContext(&mut context) };\n+    let mut frame = W::Item::new();\n+    let image = frame.init(&context);\n+\n     let mut i = 0;\n-    unsafe {\n-        while i < frames.len() &&\n-              StackWalkEx(image, process, thread, &mut frame, &mut context,\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          0) == c::TRUE\n-        {\n-            let addr = (frame.AddrPC.Offset - 1) as *const u8;\n-\n-            frames[i] = Frame {\n-                symbol_addr: addr,\n-                exact_position: addr,\n-                inline_context: frame.InlineFrameContext,\n-            };\n-            i += 1;\n+    while i < frames.len()\n+        && StackWalk.walk(image, process, thread, &mut frame, &mut context) == c::TRUE\n+    {\n+        let addr = frame.get_addr();\n+        frames[i] = Frame {\n+            symbol_addr: addr,\n+            exact_position: addr,\n+            inline_context: 0,\n+        };\n+\n+        i += 1\n+    }\n+    Ok(i)\n+}\n+\n+type SymInitializeFn = unsafe extern \"system\" fn(c::HANDLE, *mut c_void, c::BOOL) -> c::BOOL;\n+type SymCleanupFn = unsafe extern \"system\" fn(c::HANDLE) -> c::BOOL;\n+\n+type StackWalkExFn = unsafe extern \"system\" fn(\n+    c::DWORD,\n+    c::HANDLE,\n+    c::HANDLE,\n+    *mut c::STACKFRAME_EX,\n+    *mut c::CONTEXT,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+    c::DWORD,\n+) -> c::BOOL;\n+\n+type StackWalk64Fn = unsafe extern \"system\" fn(\n+    c::DWORD,\n+    c::HANDLE,\n+    c::HANDLE,\n+    *mut c::STACKFRAME64,\n+    *mut c::CONTEXT,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+    *mut c_void,\n+) -> c::BOOL;\n+\n+trait StackWalker {\n+    type Item: StackFrame;\n+\n+    fn walk(&self, c::DWORD, c::HANDLE, c::HANDLE, &mut Self::Item, &mut c::CONTEXT) -> c::BOOL;\n+}\n+\n+impl StackWalker for StackWalkExFn {\n+    type Item = c::STACKFRAME_EX;\n+    fn walk(\n+        &self,\n+        image: c::DWORD,\n+        process: c::HANDLE,\n+        thread: c::HANDLE,\n+        frame: &mut Self::Item,\n+        context: &mut c::CONTEXT,\n+    ) -> c::BOOL {\n+        unsafe {\n+            self(\n+                image,\n+                process,\n+                thread,\n+                frame,\n+                context,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                0,\n+            )\n         }\n     }\n+}\n \n-    Ok((i, backtrace_context))\n+impl StackWalker for StackWalk64Fn {\n+    type Item = c::STACKFRAME64;\n+    fn walk(\n+        &self,\n+        image: c::DWORD,\n+        process: c::HANDLE,\n+        thread: c::HANDLE,\n+        frame: &mut Self::Item,\n+        context: &mut c::CONTEXT,\n+    ) -> c::BOOL {\n+        unsafe {\n+            self(\n+                image,\n+                process,\n+                thread,\n+                frame,\n+                context,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            )\n+        }\n+    }\n }\n \n-type SymInitializeFn =\n-    unsafe extern \"system\" fn(c::HANDLE, *mut c_void,\n-                              c::BOOL) -> c::BOOL;\n-type SymCleanupFn =\n-    unsafe extern \"system\" fn(c::HANDLE) -> c::BOOL;\n-\n-type StackWalkExFn =\n-    unsafe extern \"system\" fn(c::DWORD, c::HANDLE, c::HANDLE,\n-                              *mut c::STACKFRAME_EX, *mut c::CONTEXT,\n-                              *mut c_void, *mut c_void,\n-                              *mut c_void, *mut c_void, c::DWORD) -> c::BOOL;\n-\n-#[cfg(target_arch = \"x86\")]\n-fn init_frame(frame: &mut c::STACKFRAME_EX,\n-              ctx: &c::CONTEXT) -> c::DWORD {\n-    frame.AddrPC.Offset = ctx.Eip as u64;\n-    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrStack.Offset = ctx.Esp as u64;\n-    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrFrame.Offset = ctx.Ebp as u64;\n-    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    c::IMAGE_FILE_MACHINE_I386\n+trait StackFrame {\n+    fn new() -> Self;\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD;\n+    fn get_addr(&self) -> *const u8;\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n-fn init_frame(frame: &mut c::STACKFRAME_EX,\n-              ctx: &c::CONTEXT) -> c::DWORD {\n-    frame.AddrPC.Offset = ctx.Rip as u64;\n-    frame.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrStack.Offset = ctx.Rsp as u64;\n-    frame.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    frame.AddrFrame.Offset = ctx.Rbp as u64;\n-    frame.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n-    c::IMAGE_FILE_MACHINE_AMD64\n+impl StackFrame for c::STACKFRAME_EX {\n+    fn new() -> c::STACKFRAME_EX {\n+        unsafe { mem::zeroed() }\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Eip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Esp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Ebp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_I386\n+    }\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Rip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Rsp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Rbp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_AMD64\n+    }\n+\n+    fn get_addr(&self) -> *const u8 {\n+        (self.AddrPC.Offset - 1) as *const u8\n+    }\n+}\n+\n+impl StackFrame for c::STACKFRAME64 {\n+    fn new() -> c::STACKFRAME64 {\n+        unsafe { mem::zeroed() }\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Eip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Esp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Ebp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_I386\n+    }\n+    #[cfg(target_arch = \"x86_64\")]\n+    fn init(&mut self, ctx: &c::CONTEXT) -> c::DWORD {\n+        self.AddrPC.Offset = ctx.Rip as u64;\n+        self.AddrPC.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrStack.Offset = ctx.Rsp as u64;\n+        self.AddrStack.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        self.AddrFrame.Offset = ctx.Rbp as u64;\n+        self.AddrFrame.Mode = c::ADDRESS_MODE::AddrModeFlat;\n+        c::IMAGE_FILE_MACHINE_AMD64\n+    }\n+\n+    fn get_addr(&self) -> *const u8 {\n+        (self.AddrPC.Offset - 1) as *const u8\n+    }\n+}\n+\n+enum StackWalkVariant {\n+    StackWalkEx(StackWalkExFn, printing::PrintingFnsEx),\n+    StackWalk64(StackWalk64Fn, printing::PrintingFns64),\n }\n \n pub struct BacktraceContext {\n     handle: c::HANDLE,\n     SymCleanup: SymCleanupFn,\n     // Only used in printing for msvc and not gnu\n+    // The gnu version is effectively a ZST dummy.\n+    #[allow(dead_code)]\n+    StackWalkVariant: StackWalkVariant,\n+    // keeping DynamycLibrary loaded until its functions no longer needed\n     #[allow(dead_code)]\n     dbghelp: DynamicLibrary,\n }\n \n impl Drop for BacktraceContext {\n     fn drop(&mut self) {\n-        unsafe { (self.SymCleanup)(self.handle); }\n+        unsafe {\n+            (self.SymCleanup)(self.handle);\n+        }\n     }\n }"}, {"sha": "251d5028aeaa6eb551f1c5d1b120c83c5b7e6adb", "filename": "src/libstd/sys/windows/backtrace/printing/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmod.rs?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -15,6 +15,20 @@ mod printing;\n #[cfg(target_env = \"gnu\")]\n mod printing {\n     pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n+\n+    // dummy functions to mirror those present in msvc version.\n+    use sys::dynamic_lib::DynamicLibrary;\n+    use io;\n+    pub struct PrintingFnsEx {}\n+    pub struct PrintingFns64 {}\n+    pub fn load_printing_fns_ex(_: &DynamicLibrary) -> io::Result<PrintingFnsEx> {\n+        Ok(PrintingFnsEx{})\n+    }\n+    pub fn load_printing_fns_64(_: &DynamicLibrary) -> io::Result<PrintingFns64> {\n+        Ok(PrintingFns64{})\n+    }\n }\n \n pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n+pub use self::printing::{load_printing_fns_ex, load_printing_fns_64,\n+                         PrintingFnsEx, PrintingFns64};"}, {"sha": "c8b946bf13ad1d899fee77824cc790db3ed50fb0", "filename": "src/libstd/sys/windows/backtrace/printing/msvc.rs", "status": "modified", "additions": 158, "deletions": 38, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -10,29 +10,108 @@\n \n use ffi::CStr;\n use io;\n-use libc::{c_ulong, c_char};\n+use libc::{c_char, c_ulong};\n use mem;\n-use sys::c;\n use sys::backtrace::BacktraceContext;\n+use sys::backtrace::StackWalkVariant;\n+use sys::c;\n+use sys::dynamic_lib::DynamicLibrary;\n use sys_common::backtrace::Frame;\n \n+// Structs holding printing functions and loaders for them\n+// Two versions depending on whether dbghelp.dll has StackWalkEx or not\n+// (the former being in newer Windows versions, the older being in Win7 and before)\n+pub struct PrintingFnsEx {\n+    resolve_symname: SymFromInlineContextFn,\n+    sym_get_line: SymGetLineFromInlineContextFn,\n+}\n+pub struct PrintingFns64 {\n+    resolve_symname: SymFromAddrFn,\n+    sym_get_line: SymGetLineFromAddr64Fn,\n+}\n+\n+pub fn load_printing_fns_ex(dbghelp: &DynamicLibrary) -> io::Result<PrintingFnsEx> {\n+    Ok(PrintingFnsEx {\n+        resolve_symname: sym!(dbghelp, \"SymFromInlineContext\", SymFromInlineContextFn)?,\n+        sym_get_line: sym!(\n+            dbghelp,\n+            \"SymGetLineFromInlineContext\",\n+            SymGetLineFromInlineContextFn\n+        )?,\n+    })\n+}\n+pub fn load_printing_fns_64(dbghelp: &DynamicLibrary) -> io::Result<PrintingFns64> {\n+    Ok(PrintingFns64 {\n+        resolve_symname: sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn)?,\n+        sym_get_line: sym!(dbghelp, \"SymGetLineFromAddr64\", SymGetLineFromAddr64Fn)?,\n+    })\n+}\n+\n+type SymFromAddrFn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n type SymFromInlineContextFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG,\n-                              *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n-type SymGetLineFromInlineContextFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG,\n-                              u64, *mut c::DWORD, *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n+\n+type SymGetLineFromAddr64Fn =\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u32, *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n+type SymGetLineFromInlineContextFn = unsafe extern \"system\" fn(\n+    c::HANDLE,\n+    u64,\n+    c::ULONG,\n+    u64,\n+    *mut c::DWORD,\n+    *mut c::IMAGEHLP_LINE64,\n+) -> c::BOOL;\n \n /// Converts a pointer to symbol to its string value.\n-pub fn resolve_symname<F>(frame: Frame,\n-                          callback: F,\n-                          context: &BacktraceContext) -> io::Result<()>\n-    where F: FnOnce(Option<&str>) -> io::Result<()>\n+pub fn resolve_symname<F>(frame: Frame, callback: F, context: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n {\n-    let SymFromInlineContext = sym!(&context.dbghelp,\n-                                    \"SymFromInlineContext\",\n-                                    SymFromInlineContextFn)?;\n+    match context.StackWalkVariant {\n+        StackWalkVariant::StackWalkEx(_, ref fns) => resolve_symname_internal(\n+            |process: c::HANDLE,\n+             symbol_address: u64,\n+             inline_context: c::ULONG,\n+             info: *mut c::SYMBOL_INFO| unsafe {\n+                let mut displacement = 0u64;\n+                (fns.resolve_symname)(\n+                    process,\n+                    symbol_address,\n+                    inline_context,\n+                    &mut displacement,\n+                    info,\n+                )\n+            },\n+            frame,\n+            callback,\n+            context,\n+        ),\n+        StackWalkVariant::StackWalk64(_, ref fns) => resolve_symname_internal(\n+            |process: c::HANDLE,\n+             symbol_address: u64,\n+             _inline_context: c::ULONG,\n+             info: *mut c::SYMBOL_INFO| unsafe {\n+                let mut displacement = 0u64;\n+                (fns.resolve_symname)(process, symbol_address, &mut displacement, info)\n+            },\n+            frame,\n+            callback,\n+            context,\n+        ),\n+    }\n+}\n \n+fn resolve_symname_internal<F, R>(\n+    mut symbol_resolver: R,\n+    frame: Frame,\n+    callback: F,\n+    context: &BacktraceContext,\n+) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n+    R: FnMut(c::HANDLE, u64, c::ULONG, *mut c::SYMBOL_INFO) -> c::BOOL,\n+{\n     unsafe {\n         let mut info: c::SYMBOL_INFO = mem::zeroed();\n         info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n@@ -41,14 +120,13 @@ pub fn resolve_symname<F>(frame: Frame,\n         // due to struct alignment.\n         info.SizeOfStruct = 88;\n \n-        let mut displacement = 0u64;\n-        let ret = SymFromInlineContext(context.handle,\n-                                       frame.symbol_addr as u64,\n-                                       frame.inline_context,\n-                                       &mut displacement,\n-                                       &mut info);\n-        let valid_range = if ret == c::TRUE &&\n-                             frame.symbol_addr as usize >= info.Address as usize {\n+        let ret = symbol_resolver(\n+            context.handle,\n+            frame.symbol_addr as u64,\n+            frame.inline_context,\n+            &mut info,\n+        );\n+        let valid_range = if ret == c::TRUE && frame.symbol_addr as usize >= info.Address as usize {\n             if info.Size != 0 {\n                 (frame.symbol_addr as usize) < info.Address as usize + info.Size as usize\n             } else {\n@@ -67,30 +145,72 @@ pub fn resolve_symname<F>(frame: Frame,\n     }\n }\n \n-pub fn foreach_symbol_fileline<F>(frame: Frame,\n-                                  mut f: F,\n-                                  context: &BacktraceContext)\n-    -> io::Result<bool>\n-    where F: FnMut(&[u8], u32) -> io::Result<()>\n+pub fn foreach_symbol_fileline<F>(\n+    frame: Frame,\n+    callback: F,\n+    context: &BacktraceContext,\n+) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n {\n-    let SymGetLineFromInlineContext = sym!(&context.dbghelp,\n-                                    \"SymGetLineFromInlineContext\",\n-                                    SymGetLineFromInlineContextFn)?;\n+    match context.StackWalkVariant {\n+        StackWalkVariant::StackWalkEx(_, ref fns) => foreach_symbol_fileline_iternal(\n+            |process: c::HANDLE,\n+             frame_address: u64,\n+             inline_context: c::ULONG,\n+             line: *mut c::IMAGEHLP_LINE64| unsafe {\n+                let mut displacement = 0u32;\n+                (fns.sym_get_line)(\n+                    process,\n+                    frame_address,\n+                    inline_context,\n+                    0,\n+                    &mut displacement,\n+                    line,\n+                )\n+            },\n+            frame,\n+            callback,\n+            context,\n+        ),\n+        StackWalkVariant::StackWalk64(_, ref fns) => foreach_symbol_fileline_iternal(\n+            |process: c::HANDLE,\n+             frame_address: u64,\n+             _inline_context: c::ULONG,\n+             line: *mut c::IMAGEHLP_LINE64| unsafe {\n+                let mut displacement = 0u32;\n+                (fns.sym_get_line)(process, frame_address, &mut displacement, line)\n+            },\n+            frame,\n+            callback,\n+            context,\n+        ),\n+    }\n+}\n \n+fn foreach_symbol_fileline_iternal<F, G>(\n+    mut line_getter: G,\n+    frame: Frame,\n+    mut callback: F,\n+    context: &BacktraceContext,\n+) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n+    G: FnMut(c::HANDLE, u64, c::ULONG, *mut c::IMAGEHLP_LINE64) -> c::BOOL,\n+{\n     unsafe {\n         let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n         line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n \n-        let mut displacement = 0u32;\n-        let ret = SymGetLineFromInlineContext(context.handle,\n-                                              frame.exact_position as u64,\n-                                              frame.inline_context,\n-                                              0,\n-                                              &mut displacement,\n-                                              &mut line);\n+        let ret = line_getter(\n+            context.handle,\n+            frame.exact_position as u64,\n+            frame.inline_context,\n+            &mut line,\n+        );\n         if ret == c::TRUE {\n             let name = CStr::from_ptr(line.Filename).to_bytes();\n-            f(name, line.LineNumber as u32)?;\n+            callback(name, line.LineNumber as u32)?;\n         }\n         Ok(false)\n     }"}, {"sha": "30aba2f400f2f8059fd6680105833d5f0d77d827", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -635,6 +635,22 @@ pub struct STACKFRAME_EX {\n     pub InlineFrameContext: DWORD,\n }\n \n+#[repr(C)]\n+#[cfg(feature = \"backtrace\")]\n+pub struct STACKFRAME64 {\n+    pub AddrPC: ADDRESS64,\n+    pub AddrReturn: ADDRESS64,\n+    pub AddrFrame: ADDRESS64,\n+    pub AddrStack: ADDRESS64,\n+    pub AddrBStore: ADDRESS64,\n+    pub FuncTableEntry: *mut c_void,\n+    pub Params: [u64; 4],\n+    pub Far: BOOL,\n+    pub Virtual: BOOL,\n+    pub Reserved: [u64; 3],\n+    pub KdHelp: KDHELP64,\n+}\n+\n #[repr(C)]\n #[cfg(feature = \"backtrace\")]\n pub struct KDHELP64 {"}]}