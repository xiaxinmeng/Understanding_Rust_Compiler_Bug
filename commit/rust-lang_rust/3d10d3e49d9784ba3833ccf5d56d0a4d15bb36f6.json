{"sha": "3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMTBkM2U0OWQ5Nzg0YmEzODMzY2NmNWQ1NmQwYTRkMTViYjM2ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T21:43:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T21:43:28Z"}, "message": "Auto merge of #79521 - ssomers:btree_cleanup_2, r=Mark-Simulacrum\n\nBTreeMap: relax the explicit borrow rule to make code shorter and safer\n\nExpressions like `.reborrow_mut().into_len_mut()` are annoyingly long, and kind of dangerous for the reason `reborrow_mut()` is unsafe. By relaxing the single rule, we no longer have to make an exception for functions with a `borrow` name and functions like `as_leaf_mut`. This is largely restoring the declaration style of the btree::node API about a year ago, but with more explanation and consistency.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "3a7b8aafc02ed8876aa538d63175a42f6ff69d5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a7b8aafc02ed8876aa538d63175a42f6ff69d5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "html_url": "https://github.com/rust-lang/rust/commit/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9c43cf98cfe1c369045399929cb098155b8374", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9c43cf98cfe1c369045399929cb098155b8374", "html_url": "https://github.com/rust-lang/rust/commit/7f9c43cf98cfe1c369045399929cb098155b8374"}, {"sha": "29114ff0fb79f63f14ba1958e745324cedc13b2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/29114ff0fb79f63f14ba1958e745324cedc13b2d", "html_url": "https://github.com/rust-lang/rust/commit/29114ff0fb79f63f14ba1958e745324cedc13b2d"}], "stats": {"total": 214, "additions": 108, "deletions": 106}, "files": [{"sha": "735213363f60d1b3cf9984c9e78af67c4222d4ca", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "patch": "@@ -248,7 +248,7 @@ where\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n         match search::search_tree::<marker::Mut<'_>, K, (), K>(root_node, &key) {\n-            Found(handle) => Some(mem::replace(handle.into_key_mut(), key)),\n+            Found(mut kv) => Some(mem::replace(kv.key_mut(), key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, dormant_map, _marker: PhantomData }.insert(());\n                 None"}, {"sha": "a3ff83561f1be00c1e0429b72c0556b0ee5594c7", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 107, "deletions": 105, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=3d10d3e49d9784ba3833ccf5d56d0a4d15bb36f6", "patch": "@@ -239,17 +239,16 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n /// - We cannot get implicit coercion from say `Mut<'a>` to `Immut<'a>`.\n ///   Therefore, we have to explicitly call `reborrow` on a more powerfull\n ///   `NodeRef` in order to reach a method like `key_at`.\n-/// - All methods on `NodeRef` that return some kind of reference, except\n-///   `reborrow` and `reborrow_mut`, take `self` by value and not by reference.\n-///   This avoids silently returning a second reference somewhere in the tree.\n-///   That is irrelevant when `BorrowType` is `Immut<'a>`, but the rule does\n-///   no harm because we make those `NodeRef` implicitly `Copy`.\n-///   The rule also avoids implicitly returning the lifetime of `&self`,\n-///   instead of the lifetime carried by `BorrowType`.\n-///   An exception to this rule are the insert functions.\n-/// - Given the above, we need a `reborrow_mut` to explicitly copy a `Mut<'a>`\n-///   `NodeRef` whenever we want to invoke a method returning an extra reference\n-///   somewhere in the tree.\n+///\n+/// All methods on `NodeRef` that return some kind of reference, either:\n+/// - Take `self` by value, and return the lifetime carried by `BorrowType`.\n+///   Sometimes, to invoke such a method, we need to call `reborrow_mut`.\n+/// - Take `self` by reference, and (implicitly) return that reference's\n+///   lifetime, instead of the lifetime carried by `BorrowType`. That way,\n+///   the borrow checker guarantees that the `NodeRef` remains borrowed as long\n+///   as the returned reference is used.\n+///   The methods supporting insert bend this rule by returning a raw pointer,\n+///   i.e., a reference without any lifetime.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels that the node and the level of leaves are apart, a\n     /// constant of the node that cannot be entirely described by `Type`, and that\n@@ -305,9 +304,9 @@ impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Offers exclusive access to the data of an internal node.\n-    fn as_internal_mut(this: &mut Self) -> &'a mut InternalNode<K, V> {\n-        let ptr = Self::as_internal_ptr(this);\n+    /// Borrows exclusive access to the data of an internal node.\n+    fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n+        let ptr = Self::as_internal_ptr(self);\n         unsafe { &mut *ptr }\n     }\n }\n@@ -355,7 +354,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// The node has more than `idx` initialized elements.\n     pub unsafe fn key_at(self, idx: usize) -> &'a K {\n         debug_assert!(idx < self.len());\n-        unsafe { Self::as_leaf(&self).keys.get_unchecked(idx).assume_init_ref() }\n+        unsafe { self.into_leaf().keys.get_unchecked(idx).assume_init_ref() }\n     }\n \n     /// Exposes one of the values stored in the node.\n@@ -364,7 +363,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// The node has more than `idx` initialized elements.\n     unsafe fn val_at(self, idx: usize) -> &'a V {\n         debug_assert!(idx < self.len());\n-        unsafe { Self::as_leaf(&self).vals.get_unchecked(idx).assume_init_ref() }\n+        unsafe { self.into_leaf().vals.get_unchecked(idx).assume_init_ref() }\n     }\n }\n \n@@ -431,8 +430,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// Exposes the leaf portion of any leaf or internal node in an immutable tree.\n-    fn as_leaf(this: &Self) -> &'a LeafNode<K, V> {\n-        let ptr = Self::as_leaf_ptr(this);\n+    fn into_leaf(self) -> &'a LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(&self);\n         // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n         unsafe { &*ptr }\n     }\n@@ -489,42 +488,49 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n+    /// Borrows exclusive access to the leaf portion of any leaf or internal node.\n+    fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(self);\n+        // SAFETY: we have exclusive access to the entire node.\n+        unsafe { &mut *ptr }\n+    }\n+\n     /// Offers exclusive access to the leaf portion of any leaf or internal node.\n-    fn as_leaf_mut(this: &mut Self) -> &'a mut LeafNode<K, V> {\n-        let ptr = Self::as_leaf_ptr(this);\n+    fn into_leaf_mut(mut self) -> &'a mut LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(&mut self);\n         // SAFETY: we have exclusive access to the entire node.\n         unsafe { &mut *ptr }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Offers exclusive access to a part of the key storage area.\n+    /// Borrows exclusive access to an element of the key storage area.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<K> {\n+    unsafe fn key_area_mut_at(&mut self, idx: usize) -> &mut MaybeUninit<K> {\n         debug_assert!(idx < self.len());\n-        unsafe { Self::as_leaf_mut(&mut self).keys.get_unchecked_mut(idx) }\n+        unsafe { self.as_leaf_mut().keys.get_unchecked_mut(idx) }\n     }\n \n-    /// Offers exclusive access to a part of the value storage area.\n+    /// Borrows exclusive access to an element of the value storage area.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn into_val_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<V> {\n+    unsafe fn val_area_mut_at(&mut self, idx: usize) -> &mut MaybeUninit<V> {\n         debug_assert!(idx < self.len());\n-        unsafe { Self::as_leaf_mut(&mut self).vals.get_unchecked_mut(idx) }\n+        unsafe { self.as_leaf_mut().vals.get_unchecked_mut(idx) }\n     }\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Offers exclusive access to a part of the storage area for edge contents.\n+    /// Borrows exclusive access to an element of the storage area for edge contents.\n     ///\n     /// # Safety\n     /// The node has at least `idx` initialized elements.\n-    unsafe fn into_edge_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<BoxedNode<K, V>> {\n+    unsafe fn edge_area_mut_at(&mut self, idx: usize) -> &mut MaybeUninit<BoxedNode<K, V>> {\n         debug_assert!(idx <= self.len());\n-        unsafe { Self::as_internal_mut(&mut self).edges.get_unchecked_mut(idx) }\n+        unsafe { self.as_internal_mut().edges.get_unchecked_mut(idx) }\n     }\n }\n \n@@ -533,14 +539,14 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// regardless of the node's current length,\n     /// having exclusive access to the entire node.\n     unsafe fn key_area(self) -> &'a [MaybeUninit<K>] {\n-        Self::as_leaf(&self).keys.as_slice()\n+        self.into_leaf().keys.as_slice()\n     }\n \n     /// Exposes the entire value storage area in the node,\n     /// regardless of the node's current length,\n     /// having exclusive access to the entire node.\n     unsafe fn val_area(self) -> &'a [MaybeUninit<V>] {\n-        Self::as_leaf(&self).vals.as_slice()\n+        self.into_leaf().vals.as_slice()\n     }\n }\n \n@@ -554,33 +560,33 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Offers exclusive access to a sized slice of key storage area in the node.\n-    unsafe fn into_key_area_slice(mut self) -> &'a mut [MaybeUninit<K>] {\n+    /// Borrows exclusive access to a sized slice of key storage area in the node.\n+    unsafe fn key_area_slice(&mut self) -> &mut [MaybeUninit<K>] {\n         let len = self.len();\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the key slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { Self::as_leaf_mut(&mut self).keys.get_unchecked_mut(..len) }\n+        unsafe { self.as_leaf_mut().keys.get_unchecked_mut(..len) }\n     }\n \n-    /// Offers exclusive access to a sized slice of value storage area in the node.\n-    unsafe fn into_val_area_slice(mut self) -> &'a mut [MaybeUninit<V>] {\n+    /// Borrows exclusive access to a sized slice of value storage area in the node.\n+    unsafe fn val_area_slice(&mut self) -> &mut [MaybeUninit<V>] {\n         let len = self.len();\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the value slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { Self::as_leaf_mut(&mut self).vals.get_unchecked_mut(..len) }\n+        unsafe { self.as_leaf_mut().vals.get_unchecked_mut(..len) }\n     }\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Offers exclusive access to a sized slice of storage area for edge contents in the node.\n-    unsafe fn into_edge_area_slice(mut self) -> &'a mut [MaybeUninit<BoxedNode<K, V>>] {\n+    /// Borrows exclusive access to a sized slice of storage area for edge contents in the node.\n+    unsafe fn edge_area_slice(&mut self) -> &mut [MaybeUninit<BoxedNode<K, V>>] {\n         let len = self.len();\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the edge slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { Self::as_internal_mut(&mut self).edges.get_unchecked_mut(..len + 1) }\n+        unsafe { self.as_internal_mut().edges.get_unchecked_mut(..len + 1) }\n     }\n }\n \n@@ -604,9 +610,9 @@ impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Exposes exclusive access to the length of the node.\n-    pub fn into_len_mut(mut self) -> &'a mut u16 {\n-        &mut (*Self::as_leaf_mut(&mut self)).len\n+    /// Borrows exclusive access to the length of the node.\n+    pub fn len_mut(&mut self) -> &mut u16 {\n+        &mut self.as_leaf_mut().len\n     }\n }\n \n@@ -623,21 +629,22 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Clears the root's link to its parent edge.\n     fn clear_parent_link(&mut self) {\n-        let leaf = NodeRef::as_leaf_mut(&mut self.borrow_mut());\n+        let mut root_node = self.borrow_mut();\n+        let leaf = root_node.as_leaf_mut();\n         leaf.parent = None;\n     }\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key-value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n-        let len = unsafe { self.reborrow_mut().into_len_mut() };\n+        let len = self.len_mut();\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n-            self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n+            self.key_area_mut_at(idx).write(key);\n+            self.val_area_mut_at(idx).write(val);\n         }\n     }\n \n@@ -646,9 +653,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         assert!(self.len() < CAPACITY);\n \n         unsafe {\n-            *self.reborrow_mut().into_len_mut() += 1;\n-            slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n-            slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n+            *self.len_mut() += 1;\n+            slice_insert(self.key_area_slice(), 0, key);\n+            slice_insert(self.val_area_slice(), 0, val);\n         }\n     }\n }\n@@ -675,14 +682,14 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n \n-        let len = unsafe { self.reborrow_mut().into_len_mut() };\n+        let len = self.len_mut();\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n-            self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n-            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.node);\n+            self.key_area_mut_at(idx).write(key);\n+            self.val_area_mut_at(idx).write(val);\n+            self.edge_area_mut_at(idx + 1).write(edge.node);\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -694,10 +701,10 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(self.len() < CAPACITY);\n \n         unsafe {\n-            *self.reborrow_mut().into_len_mut() += 1;\n-            slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n-            slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n-            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.node);\n+            *self.len_mut() += 1;\n+            slice_insert(self.key_area_slice(), 0, key);\n+            slice_insert(self.val_area_slice(), 0, val);\n+            slice_insert(self.edge_area_slice(), 0, edge.node);\n         }\n \n         self.correct_all_childrens_parent_links();\n@@ -728,7 +735,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n             };\n \n-            *self.reborrow_mut().into_len_mut() -= 1;\n+            *self.len_mut() -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -742,12 +749,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let old_len = self.len();\n \n         unsafe {\n-            let key = slice_remove(self.reborrow_mut().into_key_area_slice(), 0);\n-            let val = slice_remove(self.reborrow_mut().into_val_area_slice(), 0);\n+            let key = slice_remove(self.key_area_slice(), 0);\n+            let val = slice_remove(self.val_area_slice(), 0);\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let node = slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n+                    let node = slice_remove(internal.edge_area_slice(), 0);\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -759,14 +766,14 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n             };\n \n-            *self.reborrow_mut().into_len_mut() -= 1;\n+            *self.len_mut() -= 1;\n \n             (key, val, edge)\n         }\n     }\n \n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n-        let leaf = Self::as_leaf_mut(&mut self);\n+        let leaf = self.as_leaf_mut();\n         let keys = MaybeUninit::slice_as_mut_ptr(&mut leaf.keys);\n         let vals = MaybeUninit::slice_as_mut_ptr(&mut leaf.vals);\n         (keys, vals)\n@@ -970,11 +977,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n-            *self.node.reborrow_mut().into_len_mut() += 1;\n-            slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n-            slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n+            *self.node.len_mut() += 1;\n+            slice_insert(self.node.key_area_slice(), self.idx, key);\n+            slice_insert(self.node.val_area_slice(), self.idx, val);\n \n-            self.node.reborrow_mut().into_val_area_mut_at(self.idx).assume_init_mut()\n+            self.node.val_area_mut_at(self.idx).assume_init_mut()\n         }\n     }\n }\n@@ -1028,10 +1035,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n-            *self.node.reborrow_mut().into_len_mut() += 1;\n-            slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n-            slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n-            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, edge.node);\n+            *self.node.len_mut() += 1;\n+            slice_insert(self.node.key_area_slice(), self.idx, key);\n+            slice_insert(self.node.val_area_slice(), self.idx, val);\n+            slice_insert(self.node.edge_area_slice(), self.idx + 1, edge.node);\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1134,12 +1141,13 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeTyp\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n-    pub fn into_key_mut(self) -> &'a mut K {\n-        unsafe { self.node.into_key_area_mut_at(self.idx).assume_init_mut() }\n+    pub fn key_mut(&mut self) -> &mut K {\n+        unsafe { self.node.key_area_mut_at(self.idx).assume_init_mut() }\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n-        unsafe { self.node.into_val_area_mut_at(self.idx).assume_init_mut() }\n+        let leaf = self.node.into_leaf_mut();\n+        unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() }\n     }\n }\n \n@@ -1154,7 +1162,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         // We cannot call separate key and value methods, because calling the second one\n         // invalidates the reference returned by the first.\n         unsafe {\n-            let leaf = NodeRef::as_leaf_mut(&mut self.node.reborrow_mut());\n+            let leaf = self.node.as_leaf_mut();\n             let key = leaf.keys.get_unchecked_mut(self.idx).assume_init_mut();\n             let val = leaf.vals.get_unchecked_mut(self.idx).assume_init_mut();\n             (key, val)\n@@ -1196,7 +1204,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n                 new_len,\n             );\n \n-            *self.node.reborrow_mut().into_len_mut() = self.idx as u16;\n+            *self.node.len_mut() = self.idx as u16;\n             (k, v)\n         }\n     }\n@@ -1227,9 +1235,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         mut self,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         unsafe {\n-            let k = slice_remove(self.node.reborrow_mut().into_key_area_slice(), self.idx);\n-            let v = slice_remove(self.node.reborrow_mut().into_val_area_slice(), self.idx);\n-            *self.node.reborrow_mut().into_len_mut() -= 1;\n+            let k = slice_remove(self.node.key_area_slice(), self.idx);\n+            let v = slice_remove(self.node.val_area_slice(), self.idx);\n+            *self.node.len_mut() -= 1;\n             ((k, v), self.left_edge())\n         }\n     }\n@@ -1374,29 +1382,27 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         });\n \n         unsafe {\n-            *left_node.reborrow_mut().into_len_mut() = new_left_len as u16;\n+            *left_node.len_mut() = new_left_len as u16;\n \n-            let parent_key =\n-                slice_remove(parent_node.reborrow_mut().into_key_area_slice(), parent_idx);\n-            left_node.reborrow_mut().into_key_area_mut_at(old_left_len).write(parent_key);\n+            let parent_key = slice_remove(parent_node.key_area_slice(), parent_idx);\n+            left_node.key_area_mut_at(old_left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n                 right_node.reborrow().key_area().as_ptr(),\n-                left_node.reborrow_mut().into_key_area_slice().as_mut_ptr().add(old_left_len + 1),\n+                left_node.key_area_slice().as_mut_ptr().add(old_left_len + 1),\n                 right_len,\n             );\n \n-            let parent_val =\n-                slice_remove(parent_node.reborrow_mut().into_val_area_slice(), parent_idx);\n-            left_node.reborrow_mut().into_val_area_mut_at(old_left_len).write(parent_val);\n+            let parent_val = slice_remove(parent_node.val_area_slice(), parent_idx);\n+            left_node.val_area_mut_at(old_left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n                 right_node.reborrow().val_area().as_ptr(),\n-                left_node.reborrow_mut().into_val_area_slice().as_mut_ptr().add(old_left_len + 1),\n+                left_node.val_area_slice().as_mut_ptr().add(old_left_len + 1),\n                 right_len,\n             );\n \n-            slice_remove(&mut parent_node.reborrow_mut().into_edge_area_slice(), parent_idx + 1);\n+            slice_remove(&mut parent_node.edge_area_slice(), parent_idx + 1);\n             parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);\n-            *parent_node.reborrow_mut().into_len_mut() -= 1;\n+            *parent_node.len_mut() -= 1;\n \n             if parent_node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n@@ -1405,11 +1411,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 let right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n                     right_node.reborrow().edge_area().as_ptr(),\n-                    left_node\n-                        .reborrow_mut()\n-                        .into_edge_area_slice()\n-                        .as_mut_ptr()\n-                        .add(old_left_len + 1),\n+                    left_node.edge_area_slice().as_mut_ptr().add(old_left_len + 1),\n                     right_len + 1,\n                 );\n \n@@ -1511,14 +1513,14 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            *left_node.reborrow_mut().into_len_mut() -= count as u16;\n-            *right_node.reborrow_mut().into_len_mut() += count as u16;\n+            *left_node.len_mut() -= count as u16;\n+            *right_node.len_mut() += count as u16;\n \n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n                     let left = left.reborrow();\n-                    let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n+                    let right_edges = right.edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n                     right.correct_childrens_parent_links(count..count + old_right_len + 1);\n \n@@ -1569,16 +1571,16 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n \n-            *left_node.reborrow_mut().into_len_mut() += count as u16;\n-            *right_node.reborrow_mut().into_len_mut() -= count as u16;\n+            *left_node.len_mut() += count as u16;\n+            *right_node.len_mut() -= count as u16;\n \n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Steal edges.\n                     move_edges(right.reborrow(), 0, left, old_left_len + 1, count);\n \n                     // Fill gap where stolen edges used to be.\n-                    let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n+                    let right_edges = right.edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n@@ -1612,7 +1614,7 @@ unsafe fn move_edges<'a, K: 'a, V: 'a>(\n ) {\n     unsafe {\n         let source_ptr = source.edge_area().as_ptr();\n-        let dest_ptr = dest.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n+        let dest_ptr = dest.edge_area_slice().as_mut_ptr();\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }\n@@ -1708,8 +1710,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n                 move_kv(left_kv, new_left_len, right_kv, 0, new_right_len);\n \n-                *left_node.reborrow_mut().into_len_mut() = new_left_len as u16;\n-                *right_node.reborrow_mut().into_len_mut() = new_right_len as u16;\n+                *left_node.len_mut() = new_left_len as u16;\n+                *right_node.len_mut() = new_right_len as u16;\n \n                 match (left_node.force(), right_node.force()) {\n                     (ForceResult::Internal(left), ForceResult::Internal(right)) => {"}]}