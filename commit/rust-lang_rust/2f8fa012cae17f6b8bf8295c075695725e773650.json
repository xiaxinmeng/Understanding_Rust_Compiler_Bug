{"sha": "2f8fa012cae17f6b8bf8295c075695725e773650", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmOGZhMDEyY2FlMTdmNmI4YmY4Mjk1YzA3NTY5NTcyNWU3NzM2NTA=", "commit": {"author": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-02-28T19:44:54Z"}, "committer": {"name": "Giacomo Stevanato", "email": "giaco.stevanato@gmail.com", "date": "2021-02-28T22:21:18Z"}, "message": "Use identifier's span in unused lint", "tree": {"sha": "e12b9f7d7d95c4ebc9d1592bea79d77e4d113a2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e12b9f7d7d95c4ebc9d1592bea79d77e4d113a2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f8fa012cae17f6b8bf8295c075695725e773650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8fa012cae17f6b8bf8295c075695725e773650", "html_url": "https://github.com/rust-lang/rust/commit/2f8fa012cae17f6b8bf8295c075695725e773650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f8fa012cae17f6b8bf8295c075695725e773650/comments", "author": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SkiFire13", "id": 9020423, "node_id": "MDQ6VXNlcjkwMjA0MjM=", "avatar_url": "https://avatars.githubusercontent.com/u/9020423?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SkiFire13", "html_url": "https://github.com/SkiFire13", "followers_url": "https://api.github.com/users/SkiFire13/followers", "following_url": "https://api.github.com/users/SkiFire13/following{/other_user}", "gists_url": "https://api.github.com/users/SkiFire13/gists{/gist_id}", "starred_url": "https://api.github.com/users/SkiFire13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SkiFire13/subscriptions", "organizations_url": "https://api.github.com/users/SkiFire13/orgs", "repos_url": "https://api.github.com/users/SkiFire13/repos", "events_url": "https://api.github.com/users/SkiFire13/events{/privacy}", "received_events_url": "https://api.github.com/users/SkiFire13/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "573a697a6197abaad5a2d7208dbf1bbc77f4dcf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/573a697a6197abaad5a2d7208dbf1bbc77f4dcf3", "html_url": "https://github.com/rust-lang/rust/commit/573a697a6197abaad5a2d7208dbf1bbc77f4dcf3"}], "stats": {"total": 109, "additions": 66, "deletions": 43}, "files": [{"sha": "a96f3323744304c572eeed9dc4d13060d47f47d4", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 66, "deletions": 43, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2f8fa012cae17f6b8bf8295c075695725e773650/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8fa012cae17f6b8bf8295c075695725e773650/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=2f8fa012cae17f6b8bf8295c075695725e773650", "patch": "@@ -1494,12 +1494,13 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         // bindings, and we also consider the first pattern to be the \"authoritative\" set of ids.\n         // However, we should take the ids and spans of variables with the same name from the later\n         // patterns so the suggestions to prefix with underscores will apply to those too.\n-        let mut vars: FxIndexMap<Symbol, (LiveNode, Variable, Vec<(HirId, Span)>)> = <_>::default();\n+        let mut vars: FxIndexMap<Symbol, (LiveNode, Variable, Vec<(HirId, Span, Span)>)> =\n+            <_>::default();\n \n         pat.each_binding(|_, hir_id, pat_sp, ident| {\n             let ln = entry_ln.unwrap_or_else(|| self.live_node(hir_id, pat_sp));\n             let var = self.variable(hir_id, ident.span);\n-            let id_and_sp = (hir_id, pat_sp);\n+            let id_and_sp = (hir_id, pat_sp, ident.span);\n             vars.entry(self.ir.variable_name(var))\n                 .and_modify(|(.., hir_ids_and_spans)| hir_ids_and_spans.push(id_and_sp))\n                 .or_insert_with(|| (ln, var, vec![id_and_sp]));\n@@ -1508,15 +1509,21 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         for (_, (ln, var, hir_ids_and_spans)) in vars {\n             if self.used_on_entry(ln, var) {\n                 let id = hir_ids_and_spans[0].0;\n-                let spans = hir_ids_and_spans.into_iter().map(|(_, sp)| sp).collect();\n+                let spans =\n+                    hir_ids_and_spans.into_iter().map(|(_, _, ident_span)| ident_span).collect();\n                 on_used_on_entry(spans, id, ln, var);\n             } else {\n                 self.report_unused(hir_ids_and_spans, ln, var);\n             }\n         }\n     }\n \n-    fn report_unused(&self, hir_ids_and_spans: Vec<(HirId, Span)>, ln: LiveNode, var: Variable) {\n+    fn report_unused(\n+        &self,\n+        hir_ids_and_spans: Vec<(HirId, Span, Span)>,\n+        ln: LiveNode,\n+        var: Variable,\n+    ) {\n         let first_hir_id = hir_ids_and_spans[0].0;\n \n         if let Some(name) = self.should_warn(var).filter(|name| name != \"self\") {\n@@ -1530,62 +1537,78 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 self.ir.tcx.struct_span_lint_hir(\n                     lint::builtin::UNUSED_VARIABLES,\n                     first_hir_id,\n-                    hir_ids_and_spans.into_iter().map(|(_, sp)| sp).collect::<Vec<_>>(),\n+                    hir_ids_and_spans\n+                        .into_iter()\n+                        .map(|(_, _, ident_span)| ident_span)\n+                        .collect::<Vec<_>>(),\n                     |lint| {\n                         lint.build(&format!(\"variable `{}` is assigned to, but never used\", name))\n                             .note(&format!(\"consider using `_{}` instead\", name))\n                             .emit();\n                     },\n                 )\n             } else {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_VARIABLES,\n-                    first_hir_id,\n-                    hir_ids_and_spans.iter().map(|(_, sp)| *sp).collect::<Vec<_>>(),\n-                    |lint| {\n-                        let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n-\n-                        let (shorthands, non_shorthands): (Vec<_>, Vec<_>) =\n-                            hir_ids_and_spans.into_iter().partition(|(hir_id, span)| {\n-                                let var = self.variable(*hir_id, *span);\n-                                self.ir.variable_is_shorthand(var)\n-                            });\n-\n-                        let mut shorthands = shorthands\n-                            .into_iter()\n-                            .map(|(_, span)| (span, format!(\"{}: _\", name)))\n-                            .collect::<Vec<_>>();\n-\n-                        // If we have both shorthand and non-shorthand, prefer the \"try ignoring\n-                        // the field\" message, and suggest `_` for the non-shorthands. If we only\n-                        // have non-shorthand, then prefix with an underscore instead.\n-                        if !shorthands.is_empty() {\n-                            shorthands.extend(\n-                                non_shorthands\n-                                    .into_iter()\n-                                    .map(|(_, span)| (span, \"_\".to_string()))\n-                                    .collect::<Vec<_>>(),\n-                            );\n+                let (shorthands, non_shorthands): (Vec<_>, Vec<_>) =\n+                    hir_ids_and_spans.iter().copied().partition(|(hir_id, _, ident_span)| {\n+                        let var = self.variable(*hir_id, *ident_span);\n+                        self.ir.variable_is_shorthand(var)\n+                    });\n \n+                // If we have both shorthand and non-shorthand, prefer the \"try ignoring\n+                // the field\" message, and suggest `_` for the non-shorthands. If we only\n+                // have non-shorthand, then prefix with an underscore instead.\n+                if !shorthands.is_empty() {\n+                    let shorthands = shorthands\n+                        .into_iter()\n+                        .map(|(_, pat_span, _)| (pat_span, format!(\"{}: _\", name)))\n+                        .chain(\n+                            non_shorthands\n+                                .into_iter()\n+                                .map(|(_, pat_span, _)| (pat_span, \"_\".to_string())),\n+                        )\n+                        .collect::<Vec<_>>();\n+\n+                    self.ir.tcx.struct_span_lint_hir(\n+                        lint::builtin::UNUSED_VARIABLES,\n+                        first_hir_id,\n+                        hir_ids_and_spans\n+                            .iter()\n+                            .map(|(_, pat_span, _)| *pat_span)\n+                            .collect::<Vec<_>>(),\n+                        |lint| {\n+                            let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n                             err.multipart_suggestion(\n                                 \"try ignoring the field\",\n                                 shorthands,\n                                 Applicability::MachineApplicable,\n                             );\n-                        } else {\n+                            err.emit()\n+                        },\n+                    );\n+                } else {\n+                    let non_shorthands = non_shorthands\n+                        .into_iter()\n+                        .map(|(_, _, ident_span)| (ident_span, format!(\"_{}\", name)))\n+                        .collect::<Vec<_>>();\n+\n+                    self.ir.tcx.struct_span_lint_hir(\n+                        lint::builtin::UNUSED_VARIABLES,\n+                        first_hir_id,\n+                        hir_ids_and_spans\n+                            .iter()\n+                            .map(|(_, _, ident_span)| *ident_span)\n+                            .collect::<Vec<_>>(),\n+                        |lint| {\n+                            let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n                             err.multipart_suggestion(\n                                 \"if this is intentional, prefix it with an underscore\",\n-                                non_shorthands\n-                                    .into_iter()\n-                                    .map(|(_, span)| (span, format!(\"_{}\", name)))\n-                                    .collect::<Vec<_>>(),\n+                                non_shorthands,\n                                 Applicability::MachineApplicable,\n                             );\n-                        }\n-\n-                        err.emit()\n-                    },\n-                );\n+                            err.emit()\n+                        },\n+                    );\n+                }\n             }\n         }\n     }"}]}