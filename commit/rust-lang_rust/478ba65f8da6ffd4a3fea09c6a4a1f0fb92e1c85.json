{"sha": "478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OGJhNjVmOGRhNmZmZDRhM2ZlYTA5YzZhNGExZjBmYjkyZTFjODU=", "commit": {"author": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-01-15T14:50:49Z"}, "committer": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-01-15T14:50:49Z"}, "message": "Manage check state updates in main_loop to reduce lock contention", "tree": {"sha": "7406f354ac2f5ade2f0437a418cc172f76d861b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7406f354ac2f5ade2f0437a418cc172f76d861b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "html_url": "https://github.com/rust-lang/rust/commit/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/comments", "author": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdb13dade970d730468cab80ab62837124b08195", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdb13dade970d730468cab80ab62837124b08195", "html_url": "https://github.com/rust-lang/rust/commit/fdb13dade970d730468cab80ab62837124b08195"}], "stats": {"total": 108, "additions": 64, "deletions": 44}, "files": [{"sha": "76fdc0031fc69755efc36ea86ce178ad7d1cf579", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "patch": "@@ -38,30 +38,29 @@ pub struct CheckOptions {\n #[derive(Debug)]\n pub struct CheckWatcher {\n     pub task_recv: Receiver<CheckTask>,\n-    pub shared: Arc<RwLock<CheckWatcherSharedState>>,\n+    pub state: Arc<RwLock<CheckState>>,\n     cmd_send: Option<Sender<CheckCommand>>,\n     handle: Option<JoinHandle<()>>,\n }\n \n impl CheckWatcher {\n     pub fn new(options: &CheckOptions, workspace_root: PathBuf) -> CheckWatcher {\n         let options = options.clone();\n-        let shared = Arc::new(RwLock::new(CheckWatcherSharedState::new()));\n+        let state = Arc::new(RwLock::new(CheckState::new()));\n \n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n-        let shared_ = shared.clone();\n         let handle = std::thread::spawn(move || {\n-            let mut check = CheckWatcherState::new(options, workspace_root, shared_);\n+            let mut check = CheckWatcherState::new(options, workspace_root);\n             check.run(&task_send, &cmd_recv);\n         });\n-        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), shared }\n+        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), state }\n     }\n \n     /// Returns a CheckWatcher that doesn't actually do anything\n     pub fn dummy() -> CheckWatcher {\n-        let shared = Arc::new(RwLock::new(CheckWatcherSharedState::new()));\n-        CheckWatcher { task_recv: never(), cmd_send: None, handle: None, shared }\n+        let state = Arc::new(RwLock::new(CheckState::new()));\n+        CheckWatcher { task_recv: never(), cmd_send: None, handle: None, state }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n@@ -89,30 +88,26 @@ impl std::ops::Drop for CheckWatcher {\n }\n \n #[derive(Debug)]\n-pub struct CheckWatcherSharedState {\n+pub struct CheckState {\n     diagnostic_collection: HashMap<Url, Vec<Diagnostic>>,\n     suggested_fix_collection: HashMap<Url, Vec<SuggestedFix>>,\n }\n \n-impl CheckWatcherSharedState {\n-    fn new() -> CheckWatcherSharedState {\n-        CheckWatcherSharedState {\n+impl CheckState {\n+    fn new() -> CheckState {\n+        CheckState {\n             diagnostic_collection: HashMap::new(),\n             suggested_fix_collection: HashMap::new(),\n         }\n     }\n \n     /// Clear the cached diagnostics, and schedule updating diagnostics by the\n     /// server, to clear stale results.\n-    pub fn clear(&mut self, task_send: &Sender<CheckTask>) {\n+    pub fn clear(&mut self) -> Vec<Url> {\n         let cleared_files: Vec<Url> = self.diagnostic_collection.keys().cloned().collect();\n-\n         self.diagnostic_collection.clear();\n         self.suggested_fix_collection.clear();\n-\n-        for uri in cleared_files {\n-            task_send.send(CheckTask::Update(uri.clone())).unwrap();\n-        }\n+        cleared_files\n     }\n \n     pub fn diagnostics_for(&self, uri: &Url) -> Option<&[Diagnostic]> {\n@@ -123,6 +118,13 @@ impl CheckWatcherSharedState {\n         self.suggested_fix_collection.get(uri).map(|d| d.as_slice())\n     }\n \n+    pub fn add_diagnostic_with_fixes(&mut self, file_uri: Url, diagnostic: DiagnosticWithFixes) {\n+        for fix in diagnostic.suggested_fixes {\n+            self.add_suggested_fix_for_diagnostic(fix, &diagnostic.diagnostic);\n+        }\n+        self.add_diagnostic(file_uri, diagnostic.diagnostic);\n+    }\n+\n     fn add_diagnostic(&mut self, file_uri: Url, diagnostic: Diagnostic) {\n         let diagnostics = self.diagnostic_collection.entry(file_uri).or_default();\n \n@@ -158,8 +160,11 @@ impl CheckWatcherSharedState {\n \n #[derive(Debug)]\n pub enum CheckTask {\n-    /// Request a update of the given files diagnostics\n-    Update(Url),\n+    /// Request a clearing of all cached diagnostics from the check watcher\n+    ClearDiagnostics,\n+\n+    /// Request adding a diagnostic with fixes included to a file\n+    AddDiagnostic(Url, DiagnosticWithFixes),\n \n     /// Request check progress notification to client\n     Status(WorkDoneProgress),\n@@ -175,21 +180,15 @@ struct CheckWatcherState {\n     workspace_root: PathBuf,\n     watcher: WatchThread,\n     last_update_req: Option<Instant>,\n-    shared: Arc<RwLock<CheckWatcherSharedState>>,\n }\n \n impl CheckWatcherState {\n-    fn new(\n-        options: CheckOptions,\n-        workspace_root: PathBuf,\n-        shared: Arc<RwLock<CheckWatcherSharedState>>,\n-    ) -> CheckWatcherState {\n+    fn new(options: CheckOptions, workspace_root: PathBuf) -> CheckWatcherState {\n         CheckWatcherState {\n             options,\n             workspace_root,\n             watcher: WatchThread::dummy(),\n             last_update_req: None,\n-            shared,\n         }\n     }\n \n@@ -215,7 +214,7 @@ impl CheckWatcherState {\n \n             if self.should_recheck() {\n                 self.last_update_req.take();\n-                self.shared.write().clear(task_send);\n+                task_send.send(CheckTask::ClearDiagnostics).unwrap();\n \n                 // By replacing the watcher, we drop the previous one which\n                 // causes it to shut down automatically.\n@@ -240,7 +239,7 @@ impl CheckWatcherState {\n         }\n     }\n \n-    fn handle_message(&mut self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n+    fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n                 task_send\n@@ -279,18 +278,9 @@ impl CheckWatcherState {\n                     };\n \n                 let MappedRustDiagnostic { location, diagnostic, suggested_fixes } = map_result;\n-                let file_uri = location.uri.clone();\n \n-                if !suggested_fixes.is_empty() {\n-                    for suggested_fix in suggested_fixes {\n-                        self.shared\n-                            .write()\n-                            .add_suggested_fix_for_diagnostic(suggested_fix, &diagnostic);\n-                    }\n-                }\n-                self.shared.write().add_diagnostic(file_uri, diagnostic);\n-\n-                task_send.send(CheckTask::Update(location.uri)).unwrap();\n+                let diagnostic = DiagnosticWithFixes { diagnostic, suggested_fixes };\n+                task_send.send(CheckTask::AddDiagnostic(location.uri, diagnostic)).unwrap();\n             }\n \n             CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n@@ -299,6 +289,12 @@ impl CheckWatcherState {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct DiagnosticWithFixes {\n+    diagnostic: Diagnostic,\n+    suggested_fixes: Vec<SuggestedFix>,\n+}\n+\n /// WatchThread exists to wrap around the communication needed to be able to\n /// run `cargo check` without blocking. Currently the Rust standard library\n /// doesn't provide a way to read sub-process output without blocking, so we"}, {"sha": "e087c4f7e4cd1b5803feddc51a601cc521e1be14", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "patch": "@@ -337,18 +337,42 @@ fn loop_turn(\n             loop_state.in_flight_libraries -= 1;\n         }\n         Event::CheckWatcher(task) => match task {\n-            CheckTask::Update(uri) => {\n+            CheckTask::ClearDiagnostics => {\n+                let cleared_files = world_state.check_watcher.state.write().clear();\n+\n+                // Send updated diagnostics for each cleared file\n+                for url in cleared_files {\n+                    let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n+                    if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n+                        let params = handlers::publish_diagnostics(\n+                            &world_state.snapshot(),\n+                            FileId(file_id.0),\n+                        )?;\n+                        let not = notification_new::<req::PublishDiagnostics>(params);\n+                        task_sender.send(Task::Notify(not)).unwrap();\n+                    }\n+                }\n+            }\n+\n+            CheckTask::AddDiagnostic(url, diagnostic) => {\n+                world_state\n+                    .check_watcher\n+                    .state\n+                    .write()\n+                    .add_diagnostic_with_fixes(url.clone(), diagnostic);\n+\n                 // We manually send a diagnostic update when the watcher asks\n                 // us to, to avoid the issue of having to change the file to\n                 // receive updated diagnostics.\n-                let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n+                let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n                 if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n                     let params =\n                         handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n                     let not = notification_new::<req::PublishDiagnostics>(params);\n                     task_sender.send(Task::Notify(not)).unwrap();\n                 }\n             }\n+\n             CheckTask::Status(progress) => {\n                 let params = req::ProgressParams {\n                     token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),"}, {"sha": "7a3030a51aea47727e9de0451d2ef2ec754d23c6", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=478ba65f8da6ffd4a3fea09c6a4a1f0fb92e1c85", "patch": "@@ -13,7 +13,7 @@ use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n use ra_cargo_watch::{\n-    url_from_path_with_drive_lowercasing, CheckOptions, CheckWatcher, CheckWatcherSharedState,\n+    url_from_path_with_drive_lowercasing, CheckOptions, CheckState, CheckWatcher,\n };\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n@@ -64,7 +64,7 @@ pub struct WorldSnapshot {\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n-    pub check_watcher: Arc<RwLock<CheckWatcherSharedState>>,\n+    pub check_watcher: Arc<RwLock<CheckState>>,\n }\n \n impl WorldState {\n@@ -220,7 +220,7 @@ impl WorldState {\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n-            check_watcher: self.check_watcher.shared.clone(),\n+            check_watcher: self.check_watcher.state.clone(),\n         }\n     }\n "}]}