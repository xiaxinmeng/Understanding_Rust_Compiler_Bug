{"sha": "c3d9a730b748a3c8bf673b88a265faad67ec7d9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZDlhNzMwYjc0OGEzYzhiZjY3M2I4OGEyNjVmYWFkNjdlYzdkOWQ=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-06-07T17:05:01Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-16T22:26:57Z"}, "message": "Don't panic on fake IDs", "tree": {"sha": "8b23243d4751e43391a94f24b472b126dd8173ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b23243d4751e43391a94f24b472b126dd8173ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d9a730b748a3c8bf673b88a265faad67ec7d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d9a730b748a3c8bf673b88a265faad67ec7d9d", "html_url": "https://github.com/rust-lang/rust/commit/c3d9a730b748a3c8bf673b88a265faad67ec7d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d9a730b748a3c8bf673b88a265faad67ec7d9d/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69bd13f233d2cf5ceaf358f69c8e0902f79be73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/69bd13f233d2cf5ceaf358f69c8e0902f79be73c", "html_url": "https://github.com/rust-lang/rust/commit/69bd13f233d2cf5ceaf358f69c8e0902f79be73c"}], "stats": {"total": 112, "additions": 11, "deletions": 101}, "files": [{"sha": "65b852f1d619c48dd859e5342451df3d7e2c8168", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 101, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c3d9a730b748a3c8bf673b88a265faad67ec7d9d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d9a730b748a3c8bf673b88a265faad67ec7d9d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=c3d9a730b748a3c8bf673b88a265faad67ec7d9d", "patch": "@@ -175,94 +175,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         let cx = self.cx;\n \n-        // In case this is a re-export, try to resolve the docs relative to the original module.\n-        // Since we don't document `use` statements,\n-        // we don't have to consider the case where an item is documented in both the original module and the current module.\n-        /*\n-        let mut module_id = None;\n-        if let Some(item) = item_opt {\n-            debug!(\"resolving {:?} with item kind {:?}\", path_str, item.inner);\n-            if let ItemEnum::ImportItem(import) = &item.inner {\n-                if let Import::Simple(_, source) = import {\n-                    if let Some(def_id) = source.did {\n-                        use crate::rustc_middle::ty::DefIdTree;\n-\n-                        //let mut current_id = def_id;\n-                        if cx.tcx.def_kind(def_id) == DefKind::Mod {\n-                            module_id = Some(def_id);\n-                            debug!(\"found parent module {:?} for use statement\", def_id);\n-                        //break;\n-                        } else {\n-                            debug!(\n-                                \"not a module: {:?} (maybe an associated item?)\",\n-                                cx.tcx.def_kind(def_id)\n-                            );\n-                        }\n-\n-                    /*\n-                    // For associated items, the parent module might be multiple nodes above\n-                    while let Some(parent) = cx.tcx.parent(current_id) {\n-                        if cx.tcx.def_kind(parent) == DefKind::Mod {\n-                            parent_id = Some(parent);\n-                            debug!(\"found parent module {:?} for use statement\", parent);\n-                            break;\n-                        }\n-                        current_id = parent;\n-                    }\n-                    */\n-                    } else {\n-                        debug!(\"no def id found\");\n-                    }\n-                } else {\n-                    debug!(\"glob imports not handled for intra-doc links\");\n-                }\n-            } else {\n-                //debug!(\"item.inner not an import ({:?})\", item.inner);\n-            }\n-            /*\n-            if let Some(reexport) = item.reexport {\n-                use crate::rustc_middle::ty::DefIdTree;\n-\n-                let mut current_id = reexport;\n-                // For associated items, the parent module might be multiple nodes above\n-                while let Some(parent) = cx.tcx.parent(current_id) {\n-                    if cx.tcx.def_kind(parent) == DefKind::Mod {\n-                        parent_id = Some(parent);\n-                        debug!(\"found parent module {:?} for use statement\", parent);\n-                        break;\n-                    }\n-                    current_id = parent;\n-                }\n-            }\n-            */\n-            /*\n-            if let ItemKind::Use(path, use_kind) = item.kind {\n-                if use_kind == UseKind::Single {\n-                    match path.res {\n-                        Res::Def(def_kind, def_id) => {\n-                            use crate::rustc_middle::ty::DefIdTree;\n-\n-                            let mut current_id = def_id;\n-                            // For associated items, the parent module might be multiple nodes above\n-                            while let Some(parent) = cx.tcx.parent(current_id) {\n-                                if cx.tcx.def_kind(parent) == DefKind::Mod {\n-                                    parent_id = Some(parent);\n-                                    debug!(\"found parent module {:?} for use statement\", parent);\n-                                    break;\n-                                }\n-                                current_id = parent;\n-                            }\n-                        }\n-                        _ => debug!(\"use {:?} was not a definition, not treating as cross-crate\", item.name),\n-                    }\n-                } else {\n-                    debug!(\"don't know how to resolve multiple imports for {:?}, not treating as cross-crate\", path);\n-                }\n-            }\n-            */\n-        }\n-        */\n-\n         // In case we're in a module, try to resolve the relative path.\n         if parent_id.is_none() {\n             let id = self.mod_ids.last().cloned();\n@@ -549,19 +461,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             None\n         };\n \n-        // FIXME: get the resolver to work with non-local resolve scopes.\n         use rustc_middle::ty::DefIdTree;\n-        let parent_node = self.cx.tcx.parent(item.def_id);\n-        /*\n-        let parent_node = self.cx.as_local_hir_id(item.def_id).and_then(|hir_id| {\n-            // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n-            // current `resolve()` implementation.\n-            match self.cx.as_local_hir_id(self.cx.tcx.parent_module(hir_id).to_def_id()).unwrap() {\n-                id if id != hir_id => Some(id),\n-                _ => None,\n-            }\n-        });\n-        */\n+        let parent_node = if item.is_fake() {\n+            // FIXME: is this correct?\n+            None\n+        } else {\n+            self.cx.tcx.parent(item.def_id)\n+        };\n \n         if parent_node.is_some() {\n             debug!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n@@ -572,7 +478,11 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 if item.attrs.inner_docs {\n                     if item_hir_id.unwrap() != hir::CRATE_HIR_ID { item.name.clone() } else { None }\n                 } else {\n-                    match parent_node.or(self.mod_ids.last().map(|&local| self.cx.tcx.hir().local_def_id(local).to_def_id())) {\n+                    match parent_node.or(self\n+                        .mod_ids\n+                        .last()\n+                        .map(|&local| self.cx.tcx.hir().local_def_id(local).to_def_id()))\n+                    {\n                         Some(parent) if !parent.is_top_level_module() => {\n                             // FIXME: can we pull the parent module's name from elsewhere?\n                             Some(self.cx.tcx.item_name(parent).to_string())"}]}