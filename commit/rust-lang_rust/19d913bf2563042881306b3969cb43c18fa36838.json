{"sha": "19d913bf2563042881306b3969cb43c18fa36838", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZDkxM2JmMjU2MzA0Mjg4MTMwNmIzOTY5Y2I0M2MxOGZhMzY4Mzg=", "commit": {"author": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-03-22T08:24:42Z"}, "committer": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-03-24T22:58:37Z"}, "message": "Prefer lifetime suggestion over generic error", "tree": {"sha": "ed40928e3b584cde6c45f363a645c856233dd6ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed40928e3b584cde6c45f363a645c856233dd6ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19d913bf2563042881306b3969cb43c18fa36838", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19d913bf2563042881306b3969cb43c18fa36838", "html_url": "https://github.com/rust-lang/rust/commit/19d913bf2563042881306b3969cb43c18fa36838", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19d913bf2563042881306b3969cb43c18fa36838/comments", "author": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f430c44262cc4965ece75835204ef8b60b4d604", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f430c44262cc4965ece75835204ef8b60b4d604", "html_url": "https://github.com/rust-lang/rust/commit/6f430c44262cc4965ece75835204ef8b60b4d604"}], "stats": {"total": 32, "additions": 29, "deletions": 3}, "files": [{"sha": "83ca7ea7dfbd4f46f218db98a424f047807d9942", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19d913bf2563042881306b3969cb43c18fa36838/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d913bf2563042881306b3969cb43c18fa36838/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=19d913bf2563042881306b3969cb43c18fa36838", "patch": "@@ -195,13 +195,15 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n     // failed (so the return value of this method should not be used)\n     fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n                       -> Vec<RegionResolutionError> {\n+        debug!(\"process_errors()\");\n         let mut var_origins = Vec::new();\n         let mut trace_origins = Vec::new();\n         let mut same_regions = Vec::new();\n         let mut processed_errors = Vec::new();\n         for error in errors.iter() {\n             match *error {\n                 ConcreteFailure(origin, sub, sup) => {\n+                    debug!(\"processing ConcreteFailure\")\n                     let trace = match origin {\n                         infer::Subtype(trace) => Some(trace),\n                         _ => None,\n@@ -218,6 +220,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     }\n                 }\n                 SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n+                    debug!(\"processing SubSupConflict\")\n                     match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n                         Some(ref same_frs) => {\n                             var_origins.push(var_origin);\n@@ -237,10 +240,13 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                 // declaration, we want to make sure that they are, in fact,\n                 // from the same scope\n                 if sr.scope_id != common_scope_id {\n+                    debug!(\"returning empty result from process_errors because\n+                            {} != {}\", sr.scope_id, common_scope_id);\n                     return vec!();\n                 }\n             }\n             let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n+            debug!(\"errors processed: {:?}\", pe);\n             processed_errors.push(pe);\n         }\n         return processed_errors;\n@@ -256,6 +262,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n+            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n                     if fr1.scope_id != fr2.scope_id {\n@@ -284,7 +291,10 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     },\n                     _ => None\n                 },\n-                None => None\n+                None => {\n+                    debug!(\"no parent node of scope_id {}\", scope_id)\n+                    None\n+                }\n             }\n         }\n "}, {"sha": "8322612ba8f254c723277a4443c814a37a88b10f", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19d913bf2563042881306b3969cb43c18fa36838/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d913bf2563042881306b3969cb43c18fa36838/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=19d913bf2563042881306b3969cb43c18fa36838", "patch": "@@ -1117,17 +1117,33 @@ impl<'a> RegionVarBindings<'a> {\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let (lower_bounds, lower_dup) =\n+        let (mut lower_bounds, lower_dup) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n                                           graph::Incoming, dup_vec);\n-        let (upper_bounds, upper_dup) =\n+        let (mut upper_bounds, upper_dup) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n                                           graph::Outgoing, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n         }\n \n+        // We place free regions first because we are special casing\n+        // SubSupConflict(ReFree, ReFree) when reporting error, and so\n+        // the user will more likely get a specific suggestion.\n+        fn free_regions_first(a: &RegionAndOrigin,\n+                              b: &RegionAndOrigin)\n+                              -> Ordering {\n+            match (a.region, b.region) {\n+                (ReFree(..), ReFree(..)) => Equal,\n+                (ReFree(..), _) => Less,\n+                (_, ReFree(..)) => Greater,\n+                (_, _) => Equal,\n+            }\n+        }\n+        lower_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n+        upper_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n+\n         for lower_bound in lower_bounds.iter() {\n             for upper_bound in upper_bounds.iter() {\n                 if !self.is_subregion_of(lower_bound.region,"}]}