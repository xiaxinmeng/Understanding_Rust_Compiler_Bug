{"sha": "467f2ea6531437d7cbc51712ba01886f41e2cf40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2N2YyZWE2NTMxNDM3ZDdjYmM1MTcxMmJhMDE4ODZmNDFlMmNmNDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T10:05:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:50:32Z"}, "message": "extract lexical region resolution into its own sub-module", "tree": {"sha": "5167475422b28aa28c6e21b5089d9f7d64946a18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5167475422b28aa28c6e21b5089d9f7d64946a18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467f2ea6531437d7cbc51712ba01886f41e2cf40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467f2ea6531437d7cbc51712ba01886f41e2cf40", "html_url": "https://github.com/rust-lang/rust/commit/467f2ea6531437d7cbc51712ba01886f41e2cf40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467f2ea6531437d7cbc51712ba01886f41e2cf40/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efa09dbea5bd886389f994d511e502422b8d5149", "url": "https://api.github.com/repos/rust-lang/rust/commits/efa09dbea5bd886389f994d511e502422b8d5149", "html_url": "https://github.com/rust-lang/rust/commit/efa09dbea5bd886389f994d511e502422b8d5149"}], "stats": {"total": 1431, "additions": 743, "deletions": 688}, "files": [{"sha": "f32cd45a7409a0a2f77e96d606695bca75906807", "filename": "src/librustc/infer/region_inference/lexical_resolve.rs", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/467f2ea6531437d7cbc51712ba01886f41e2cf40/src%2Flibrustc%2Finfer%2Fregion_inference%2Flexical_resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467f2ea6531437d7cbc51712ba01886f41e2cf40/src%2Flibrustc%2Finfer%2Fregion_inference%2Flexical_resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Flexical_resolve.rs?ref=467f2ea6531437d7cbc51712ba01886f41e2cf40", "patch": "@@ -0,0 +1,730 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The code to do lexical region resolution.\n+\n+use infer::SubregionOrigin;\n+use infer::region_inference::graphviz;\n+use infer::region_inference::Constraint;\n+use infer::region_inference::Constraint::*;\n+use infer::region_inference::RegionVarBindings;\n+use infer::region_inference::RegionResolutionError;\n+use infer::region_inference::VarValue;\n+use infer::region_inference::VerifyBound;\n+use middle::free_region::RegionRelations;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n+use std::fmt;\n+use std::u32;\n+use ty::{self, TyCtxt};\n+use ty::{Region, RegionVid};\n+use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n+use ty::{ReLateBound, ReScope, ReVar, ReSkolemized};\n+\n+struct RegionAndOrigin<'tcx> {\n+    region: Region<'tcx>,\n+    origin: SubregionOrigin<'tcx>,\n+}\n+\n+type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n+\n+impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n+    /// This function performs the actual region resolution.  It must be\n+    /// called after all constraints have been added.  It performs a\n+    /// fixed-point iteration to find region values which satisfy all\n+    /// constraints, assuming such values can be found; if they cannot,\n+    /// errors are reported.\n+    pub fn resolve_regions(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n+        debug!(\"RegionVarBindings: resolve_regions()\");\n+        let mut errors = vec![];\n+        let v = self.infer_variable_values(region_rels, &mut errors);\n+        *self.values.borrow_mut() = Some(v);\n+        errors\n+    }\n+\n+    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n+        match *self.values.borrow() {\n+            None => span_bug!(\n+                (*self.var_origins.borrow())[rid.index as usize].span(),\n+                \"attempt to resolve region variable before values have \\\n+                 been computed!\"\n+            ),\n+            Some(ref values) => {\n+                let r = lookup(self.tcx, values, rid);\n+                debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n+                r\n+            }\n+        }\n+    }\n+\n+    fn lub_concrete_regions(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n+        match (a, b) {\n+            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n+                bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n+            }\n+\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n+            }\n+\n+            (&ReEmpty, r) | (r, &ReEmpty) => {\n+                r // everything lives longer than empty\n+            }\n+\n+            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n+                span_bug!(\n+                    (*self.var_origins.borrow())[v_id.index as usize].span(),\n+                    \"lub_concrete_regions invoked with non-concrete \\\n+                     regions: {:?}, {:?}\",\n+                    a,\n+                    b\n+                );\n+            }\n+\n+            (&ReEarlyBound(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(_)) => {\n+                // A \"free\" region can be interpreted as \"some region\n+                // at least as big as fr.scope\".  So, we can\n+                // reasonably compare free regions and scopes:\n+                let fr_scope = match (a, b) {\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        region_rels.region_scope_tree.early_free_scope(self.tcx, br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        region_rels.region_scope_tree.free_scope(self.tcx, fr)\n+                    }\n+                    _ => bug!(),\n+                };\n+                let r_id = region_rels\n+                    .region_scope_tree\n+                    .nearest_common_ancestor(fr_scope, s_id);\n+                if r_id == fr_scope {\n+                    // if the free region's scope `fr.scope` is bigger than\n+                    // the scope region `s_id`, then the LUB is the free\n+                    // region itself:\n+                    match (a, b) {\n+                        (_, &ReScope(_)) => return a,\n+                        (&ReScope(_), _) => return b,\n+                        _ => bug!(),\n+                    }\n+                }\n+\n+                // otherwise, we don't know what the free region is,\n+                // so we must conservatively say the LUB is static:\n+                self.tcx.types.re_static\n+            }\n+\n+            (&ReScope(a_id), &ReScope(b_id)) => {\n+                // The region corresponding to an outer block is a\n+                // subtype of the region corresponding to an inner\n+                // block.\n+                let lub = region_rels\n+                    .region_scope_tree\n+                    .nearest_common_ancestor(a_id, b_id);\n+                self.tcx.mk_region(ReScope(lub))\n+            }\n+\n+            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReEarlyBound(_)) |\n+            (&ReEarlyBound(_), &ReFree(_)) |\n+            (&ReFree(_), &ReFree(_)) => region_rels.lub_free_regions(a, b),\n+\n+            // For these types, we cannot define any additional\n+            // relationship:\n+            (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n+                a\n+            } else {\n+                self.tcx.types.re_static\n+            },\n+        }\n+    }\n+\n+    fn infer_variable_values(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) -> Vec<VarValue<'tcx>> {\n+        let mut var_data = self.construct_var_data();\n+\n+        // Dorky hack to cause `dump_constraints` to only get called\n+        // if debug mode is enabled:\n+        debug!(\n+            \"----() End constraint listing (context={:?}) {:?}---\",\n+            region_rels.context,\n+            self.dump_constraints(region_rels)\n+        );\n+        graphviz::maybe_print_constraints_for(self, region_rels);\n+\n+        let graph = self.construct_graph();\n+        self.expand_givens(&graph);\n+        self.expansion(region_rels, &mut var_data);\n+        self.collect_errors(region_rels, &mut var_data, errors);\n+        self.collect_var_errors(region_rels, &var_data, &graph, errors);\n+        var_data\n+    }\n+\n+    fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n+        (0..self.num_vars() as usize)\n+            .map(|_| VarValue::Value(self.tcx.types.re_empty))\n+            .collect()\n+    }\n+\n+    fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n+        debug!(\n+            \"----() Start constraint listing (context={:?}) ()----\",\n+            free_regions.context\n+        );\n+        for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n+            debug!(\"Constraint {} => {:?}\", idx, constraint);\n+        }\n+    }\n+\n+    fn expand_givens(&self, graph: &RegionGraph) {\n+        // Givens are a kind of horrible hack to account for\n+        // constraints like 'c <= '0 that are known to hold due to\n+        // closure signatures (see the comment above on the `givens`\n+        // field). They should go away. But until they do, the role\n+        // of this fn is to account for the transitive nature:\n+        //\n+        //     Given 'c <= '0\n+        //     and   '0 <= '1\n+        //     then  'c <= '1\n+\n+        let mut givens = self.givens.borrow_mut();\n+        let seeds: Vec<_> = givens.iter().cloned().collect();\n+        for (r, vid) in seeds {\n+            let seed_index = NodeIndex(vid.index as usize);\n+            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n+                let succ_index = succ_index.0 as u32;\n+                if succ_index < self.num_vars() {\n+                    let succ_vid = RegionVid { index: succ_index };\n+                    givens.insert((r, succ_vid));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn expansion(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        var_values: &mut [VarValue<'tcx>],\n+    ) {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n+            debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n+            match *constraint {\n+                ConstrainRegSubVar(a_region, b_vid) => {\n+                    let b_data = &mut var_values[b_vid.index as usize];\n+                    self.expand_node(region_rels, a_region, b_vid, b_data)\n+                }\n+                ConstrainVarSubVar(a_vid, b_vid) => match var_values[a_vid.index as usize] {\n+                    VarValue::ErrorValue => false,\n+                    VarValue::Value(a_region) => {\n+                        let b_node = &mut var_values[b_vid.index as usize];\n+                        self.expand_node(region_rels, a_region, b_vid, b_node)\n+                    }\n+                },\n+                ConstrainRegSubReg(..) | ConstrainVarSubReg(..) => {\n+                    // These constraints are checked after expansion\n+                    // is done, in `collect_errors`.\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n+    fn expand_node(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        a_region: Region<'tcx>,\n+        b_vid: RegionVid,\n+        b_data: &mut VarValue<'tcx>,\n+    ) -> bool {\n+        debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n+\n+        // Check if this relationship is implied by a given.\n+        match *a_region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                if self.givens.borrow().contains(&(a_region, b_vid)) {\n+                    debug!(\"given\");\n+                    return false;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match *b_data {\n+            VarValue::Value(cur_region) => {\n+                let lub = self.lub_concrete_regions(region_rels, a_region, cur_region);\n+                if lub == cur_region {\n+                    return false;\n+                }\n+\n+                debug!(\n+                    \"Expanding value of {:?} from {:?} to {:?}\",\n+                    b_vid,\n+                    cur_region,\n+                    lub\n+                );\n+\n+                *b_data = VarValue::Value(lub);\n+                return true;\n+            }\n+\n+            VarValue::ErrorValue => {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    /// After expansion is complete, go and check upper bounds (i.e.,\n+    /// cases where the region cannot grow larger than a fixed point)\n+    /// and check that they are satisfied.\n+    fn collect_errors(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        var_data: &mut Vec<VarValue<'tcx>>,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) {\n+        let constraints = self.constraints.borrow();\n+        for (constraint, origin) in constraints.iter() {\n+            debug!(\n+                \"collect_errors: constraint={:?} origin={:?}\",\n+                constraint,\n+                origin\n+            );\n+            match *constraint {\n+                ConstrainRegSubVar(..) | ConstrainVarSubVar(..) => {\n+                    // Expansion will ensure that these constraints hold. Ignore.\n+                }\n+\n+                ConstrainRegSubReg(sub, sup) => {\n+                    if region_rels.is_subregion_of(sub, sup) {\n+                        continue;\n+                    }\n+\n+                    debug!(\n+                        \"collect_errors: region error at {:?}: \\\n+                         cannot verify that {:?} <= {:?}\",\n+                        origin,\n+                        sub,\n+                        sup\n+                    );\n+\n+                    errors.push(RegionResolutionError::ConcreteFailure((*origin).clone(), sub, sup));\n+                }\n+\n+                ConstrainVarSubReg(a_vid, b_region) => {\n+                    let a_data = &mut var_data[a_vid.index as usize];\n+                    debug!(\"contraction: {:?} == {:?}, {:?}\", a_vid, a_data, b_region);\n+\n+                    let a_region = match *a_data {\n+                        VarValue::ErrorValue => continue,\n+                        VarValue::Value(a_region) => a_region,\n+                    };\n+\n+                    // Do not report these errors immediately:\n+                    // instead, set the variable value to error and\n+                    // collect them later.\n+                    if !region_rels.is_subregion_of(a_region, b_region) {\n+                        debug!(\n+                            \"collect_errors: region error at {:?}: \\\n+                             cannot verify that {:?}={:?} <= {:?}\",\n+                            origin,\n+                            a_vid,\n+                            a_region,\n+                            b_region\n+                        );\n+                        *a_data = VarValue::ErrorValue;\n+                    }\n+                }\n+            }\n+        }\n+\n+        for verify in self.verifys.borrow().iter() {\n+            debug!(\"collect_errors: verify={:?}\", verify);\n+            let sub = normalize(self.tcx, var_data, verify.region);\n+\n+            // This was an inference variable which didn't get\n+            // constrained, therefore it can be assume to hold.\n+            if let ty::ReEmpty = *sub {\n+                continue;\n+            }\n+\n+            if verify.bound.is_met(region_rels, var_data, sub) {\n+                continue;\n+            }\n+\n+            debug!(\n+                \"collect_errors: region error at {:?}: \\\n+                 cannot verify that {:?} <= {:?}\",\n+                verify.origin,\n+                verify.region,\n+                verify.bound\n+            );\n+\n+            errors.push(RegionResolutionError::GenericBoundFailure(\n+                verify.origin.clone(),\n+                verify.kind.clone(),\n+                sub,\n+            ));\n+        }\n+    }\n+\n+    /// Go over the variables that were declared to be error variables\n+    /// and create a `RegionResolutionError` for each of them.\n+    fn collect_var_errors(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        var_data: &[VarValue<'tcx>],\n+        graph: &RegionGraph<'tcx>,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) {\n+        debug!(\"collect_var_errors\");\n+\n+        // This is the best way that I have found to suppress\n+        // duplicate and related errors. Basically we keep a set of\n+        // flags for every node. Whenever an error occurs, we will\n+        // walk some portion of the graph looking to find pairs of\n+        // conflicting regions to report to the user. As we walk, we\n+        // trip the flags from false to true, and if we find that\n+        // we've already reported an error involving any particular\n+        // node we just stop and don't report the current error.  The\n+        // idea is to report errors that derive from independent\n+        // regions of the graph, but not those that derive from\n+        // overlapping locations.\n+        let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n+\n+        for idx in 0..self.num_vars() as usize {\n+            match var_data[idx] {\n+                VarValue::Value(_) => { /* Inference successful */ }\n+                VarValue::ErrorValue => {\n+                    /* Inference impossible, this value contains\n+                       inconsistent constraints.\n+\n+                       I think that in this case we should report an\n+                       error now---unlike the case above, we can't\n+                       wait to see whether the user needs the result\n+                       of this variable.  The reason is that the mere\n+                       existence of this variable implies that the\n+                       region graph is inconsistent, whether or not it\n+                       is used.\n+\n+                       For example, we may have created a region\n+                       variable that is the GLB of two other regions\n+                       which do not have a GLB.  Even if that variable\n+                       is not used, it implies that those two regions\n+                       *should* have a GLB.\n+\n+                       At least I think this is true. It may be that\n+                       the mere existence of a conflict in a region variable\n+                       that is not used is not a problem, so if this rule\n+                       starts to create problems we'll have to revisit\n+                       this portion of the code and think hard about it. =) */\n+\n+                    let node_vid = RegionVid { index: idx as u32 };\n+                    self.collect_error_for_expanding_node(\n+                        region_rels,\n+                        graph,\n+                        &mut dup_vec,\n+                        node_vid,\n+                        errors,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn construct_graph(&self) -> RegionGraph<'tcx> {\n+        let num_vars = self.num_vars();\n+\n+        let constraints = self.constraints.borrow();\n+\n+        let mut graph = graph::Graph::new();\n+\n+        for _ in 0..num_vars {\n+            graph.add_node(());\n+        }\n+\n+        // Issue #30438: two distinct dummy nodes, one for incoming\n+        // edges (dummy_source) and another for outgoing edges\n+        // (dummy_sink). In `dummy -> a -> b -> dummy`, using one\n+        // dummy node leads one to think (erroneously) there exists a\n+        // path from `b` to `a`. Two dummy nodes sidesteps the issue.\n+        let dummy_source = graph.add_node(());\n+        let dummy_sink = graph.add_node(());\n+\n+        for (constraint, _) in constraints.iter() {\n+            match *constraint {\n+                ConstrainVarSubVar(a_id, b_id) => {\n+                    graph.add_edge(\n+                        NodeIndex(a_id.index as usize),\n+                        NodeIndex(b_id.index as usize),\n+                        *constraint,\n+                    );\n+                }\n+                ConstrainRegSubVar(_, b_id) => {\n+                    graph.add_edge(dummy_source, NodeIndex(b_id.index as usize), *constraint);\n+                }\n+                ConstrainVarSubReg(a_id, _) => {\n+                    graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n+                }\n+                ConstrainRegSubReg(..) => {\n+                    // this would be an edge from `dummy_source` to\n+                    // `dummy_sink`; just ignore it.\n+                }\n+            }\n+        }\n+\n+        return graph;\n+    }\n+\n+    fn collect_error_for_expanding_node(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        graph: &RegionGraph<'tcx>,\n+        dup_vec: &mut [u32],\n+        node_idx: RegionVid,\n+        errors: &mut Vec<RegionResolutionError<'tcx>>,\n+    ) {\n+        // Errors in expanding nodes result from a lower-bound that is\n+        // not contained by an upper-bound.\n+        let (mut lower_bounds, lower_dup) =\n+            self.collect_concrete_regions(graph, node_idx, graph::INCOMING, dup_vec);\n+        let (mut upper_bounds, upper_dup) =\n+            self.collect_concrete_regions(graph, node_idx, graph::OUTGOING, dup_vec);\n+\n+        if lower_dup || upper_dup {\n+            return;\n+        }\n+\n+        // We place free regions first because we are special casing\n+        // SubSupConflict(ReFree, ReFree) when reporting error, and so\n+        // the user will more likely get a specific suggestion.\n+        fn region_order_key(x: &RegionAndOrigin) -> u8 {\n+            match *x.region {\n+                ReEarlyBound(_) => 0,\n+                ReFree(_) => 1,\n+                _ => 2,\n+            }\n+        }\n+        lower_bounds.sort_by_key(region_order_key);\n+        upper_bounds.sort_by_key(region_order_key);\n+\n+        for lower_bound in &lower_bounds {\n+            for upper_bound in &upper_bounds {\n+                if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n+                    let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n+                    debug!(\n+                        \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n+                         sup: {:?}\",\n+                        origin,\n+                        node_idx,\n+                        lower_bound.region,\n+                        upper_bound.region\n+                    );\n+                    errors.push(RegionResolutionError::SubSupConflict(\n+                        origin,\n+                        lower_bound.origin.clone(),\n+                        lower_bound.region,\n+                        upper_bound.origin.clone(),\n+                        upper_bound.region,\n+                    ));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        span_bug!(\n+            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n+            \"collect_error_for_expanding_node() could not find \\\n+             error for var {:?}, lower_bounds={:?}, \\\n+             upper_bounds={:?}\",\n+            node_idx,\n+            lower_bounds,\n+            upper_bounds\n+        );\n+    }\n+\n+    fn collect_concrete_regions(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        orig_node_idx: RegionVid,\n+        dir: Direction,\n+        dup_vec: &mut [u32],\n+    ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+        struct WalkState<'tcx> {\n+            set: FxHashSet<RegionVid>,\n+            stack: Vec<RegionVid>,\n+            result: Vec<RegionAndOrigin<'tcx>>,\n+            dup_found: bool,\n+        }\n+        let mut state = WalkState {\n+            set: FxHashSet(),\n+            stack: vec![orig_node_idx],\n+            result: Vec::new(),\n+            dup_found: false,\n+        };\n+        state.set.insert(orig_node_idx);\n+\n+        // to start off the process, walk the source node in the\n+        // direction specified\n+        process_edges(self, &mut state, graph, orig_node_idx, dir);\n+\n+        while !state.stack.is_empty() {\n+            let node_idx = state.stack.pop().unwrap();\n+\n+            // check whether we've visited this node on some previous walk\n+            if dup_vec[node_idx.index as usize] == u32::MAX {\n+                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n+                state.dup_found = true;\n+            }\n+\n+            debug!(\n+                \"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n+                orig_node_idx,\n+                node_idx\n+            );\n+\n+            process_edges(self, &mut state, graph, node_idx, dir);\n+        }\n+\n+        let WalkState {\n+            result, dup_found, ..\n+        } = state;\n+        return (result, dup_found);\n+\n+        fn process_edges<'a, 'gcx, 'tcx>(\n+            this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+            state: &mut WalkState<'tcx>,\n+            graph: &RegionGraph<'tcx>,\n+            source_vid: RegionVid,\n+            dir: Direction,\n+        ) {\n+            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n+\n+            let source_node_index = NodeIndex(source_vid.index as usize);\n+            for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n+                match edge.data {\n+                    ConstrainVarSubVar(from_vid, to_vid) => {\n+                        let opp_vid = if from_vid == source_vid {\n+                            to_vid\n+                        } else {\n+                            from_vid\n+                        };\n+                        if state.set.insert(opp_vid) {\n+                            state.stack.push(opp_vid);\n+                        }\n+                    }\n+\n+                    ConstrainRegSubVar(region, _) | ConstrainVarSubReg(_, region) => {\n+                        state.result.push(RegionAndOrigin {\n+                            region,\n+                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n+                        });\n+                    }\n+\n+                    ConstrainRegSubReg(..) => panic!(\n+                        \"cannot reach reg-sub-reg edge in region inference \\\n+                         post-processing\"\n+                    ),\n+                }\n+            }\n+        }\n+    }\n+\n+    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n+    where\n+        F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool,\n+    {\n+        let mut iteration = 0;\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            iteration += 1;\n+            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n+            for (constraint, origin) in self.constraints.borrow().iter() {\n+                let edge_changed = body(constraint, origin);\n+                if edge_changed {\n+                    debug!(\"Updated due to constraint {:?}\", constraint);\n+                    changed = true;\n+                }\n+            }\n+        }\n+        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n+    }\n+}\n+\n+fn normalize<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    values: &Vec<VarValue<'tcx>>,\n+    r: ty::Region<'tcx>,\n+) -> ty::Region<'tcx> {\n+    match *r {\n+        ty::ReVar(rid) => lookup(tcx, values, rid),\n+        _ => r,\n+    }\n+}\n+\n+fn lookup<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    values: &Vec<VarValue<'tcx>>,\n+    rid: ty::RegionVid,\n+) -> ty::Region<'tcx> {\n+    match values[rid.index as usize] {\n+        VarValue::Value(r) => r,\n+        VarValue::ErrorValue => tcx.types.re_static, // Previously reported error.\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n+    }\n+}\n+\n+\n+impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n+    fn is_met(\n+        &self,\n+        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        var_values: &Vec<VarValue<'tcx>>,\n+        min: ty::Region<'tcx>,\n+    ) -> bool {\n+        let tcx = region_rels.tcx;\n+        match self {\n+            &VerifyBound::AnyRegion(ref rs) => rs.iter()\n+                .map(|&r| normalize(tcx, var_values, r))\n+                .any(|r| region_rels.is_subregion_of(min, r)),\n+\n+            &VerifyBound::AllRegions(ref rs) => rs.iter()\n+                .map(|&r| normalize(tcx, var_values, r))\n+                .all(|r| region_rels.is_subregion_of(min, r)),\n+\n+            &VerifyBound::AnyBound(ref bs) => {\n+                bs.iter().any(|b| b.is_met(region_rels, var_values, min))\n+            }\n+\n+            &VerifyBound::AllBounds(ref bs) => {\n+                bs.iter().all(|b| b.is_met(region_rels, var_values, min))\n+            }\n+        }\n+    }\n+}"}, {"sha": "59e9c4d3d0011822b6a07b81125232931768a101", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 688, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/467f2ea6531437d7cbc51712ba01886f41e2cf40/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467f2ea6531437d7cbc51712ba01886f41e2cf40/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=467f2ea6531437d7cbc51712ba01886f41e2cf40", "patch": "@@ -20,20 +20,19 @@ use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use middle::free_region::RegionRelations;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n-use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n-use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n+use ty::ReStatic;\n+use ty::{ReLateBound, ReVar, ReSkolemized, BrFresh};\n \n use std::collections::BTreeMap;\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem;\n use std::u32;\n \n+mod lexical_resolve;\n mod graphviz;\n \n /// A constraint that influences the inference process.\n@@ -63,10 +62,10 @@ pub enum Constraint<'tcx> {\n /// step doesn't influence inference).\n #[derive(Debug)]\n pub struct Verify<'tcx> {\n-    kind: GenericKind<'tcx>,\n-    origin: SubregionOrigin<'tcx>,\n-    region: Region<'tcx>,\n-    bound: VerifyBound<'tcx>,\n+    pub kind: GenericKind<'tcx>,\n+    pub origin: SubregionOrigin<'tcx>,\n+    pub region: Region<'tcx>,\n+    pub bound: VerifyBound<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -178,6 +177,12 @@ pub enum ProcessedErrorOrigin<'tcx> {\n     VariableFailure(RegionVariableOrigin),\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum VarValue<'tcx> {\n+    Value(Region<'tcx>),\n+    ErrorValue,\n+}\n+\n pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -803,21 +808,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        match *self.values.borrow() {\n-            None => {\n-                span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n-                          \"attempt to resolve region variable before values have \\\n-                           been computed!\")\n-            }\n-            Some(ref values) => {\n-                let r = lookup(self.tcx, values, rid);\n-                debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n-                r\n-            }\n-        }\n-    }\n-\n     pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n         let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n         self.tcx.mk_region(ty::ReVar(vid))\n@@ -892,644 +882,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         debug!(\"tainted: result={:?}\", taint_set.regions);\n         return taint_set.into_set();\n     }\n-\n-    /// This function performs the actual region resolution.  It must be\n-    /// called after all constraints have been added.  It performs a\n-    /// fixed-point iteration to find region values which satisfy all\n-    /// constraints, assuming such values can be found; if they cannot,\n-    /// errors are reported.\n-    pub fn resolve_regions(&self,\n-                           region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n-                           -> Vec<RegionResolutionError<'tcx>> {\n-        debug!(\"RegionVarBindings: resolve_regions()\");\n-        let mut errors = vec![];\n-        let v = self.infer_variable_values(region_rels, &mut errors);\n-        *self.values.borrow_mut() = Some(v);\n-        errors\n-    }\n-\n-    fn lub_concrete_regions(&self,\n-                            region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                            a: Region<'tcx>,\n-                            b: Region<'tcx>)\n-                            -> Region<'tcx> {\n-        match (a, b) {\n-            (&ReLateBound(..), _) |\n-            (_, &ReLateBound(..)) |\n-            (&ReErased, _) |\n-            (_, &ReErased) => {\n-                bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n-            }\n-\n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n-            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n-                span_bug!((*self.var_origins.borrow())[v_id.index as usize].span(),\n-                          \"lub_concrete_regions invoked with non-concrete \\\n-                           regions: {:?}, {:?}\",\n-                          a,\n-                          b);\n-            }\n-\n-            (&ReEarlyBound(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(_)) => {\n-                // A \"free\" region can be interpreted as \"some region\n-                // at least as big as fr.scope\".  So, we can\n-                // reasonably compare free regions and scopes:\n-                let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        region_rels.region_scope_tree.early_free_scope(self.tcx, br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        region_rels.region_scope_tree.free_scope(self.tcx, fr)\n-                    }\n-                    _ => bug!()\n-                };\n-                let r_id = region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n-                if r_id == fr_scope {\n-                    // if the free region's scope `fr.scope` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    match (a, b) {\n-                        (_, &ReScope(_)) => return a,\n-                        (&ReScope(_), _) => return b,\n-                        _ => bug!()\n-                    }\n-                }\n-\n-                // otherwise, we don't know what the free region is,\n-                // so we must conservatively say the LUB is static:\n-                self.tcx.types.re_static\n-            }\n-\n-            (&ReScope(a_id), &ReScope(b_id)) => {\n-                // The region corresponding to an outer block is a\n-                // subtype of the region corresponding to an inner\n-                // block.\n-                let lub = region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                self.tcx.mk_region(ReScope(lub))\n-            }\n-\n-            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n-            (&ReFree(_), &ReEarlyBound(_)) |\n-            (&ReEarlyBound(_), &ReFree(_)) |\n-            (&ReFree(_), &ReFree(_)) => {\n-                region_rels.lub_free_regions(a, b)\n-            }\n-\n-            // For these types, we cannot define any additional\n-            // relationship:\n-            (&ReSkolemized(..), _) |\n-            (_, &ReSkolemized(..)) => {\n-                if a == b {\n-                    a\n-                } else {\n-                    self.tcx.types.re_static\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum VarValue<'tcx> {\n-    Value(Region<'tcx>),\n-    ErrorValue,\n-}\n-\n-struct RegionAndOrigin<'tcx> {\n-    region: Region<'tcx>,\n-    origin: SubregionOrigin<'tcx>,\n-}\n-\n-type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n-\n-impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n-    fn infer_variable_values(&self,\n-                             region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n-                             -> Vec<VarValue<'tcx>> {\n-        let mut var_data = self.construct_var_data();\n-\n-        // Dorky hack to cause `dump_constraints` to only get called\n-        // if debug mode is enabled:\n-        debug!(\"----() End constraint listing (context={:?}) {:?}---\",\n-               region_rels.context,\n-               self.dump_constraints(region_rels));\n-        graphviz::maybe_print_constraints_for(self, region_rels);\n-\n-        let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n-        self.expansion(region_rels, &mut var_data);\n-        self.collect_errors(region_rels, &mut var_data, errors);\n-        self.collect_var_errors(region_rels, &var_data, &graph, errors);\n-        var_data\n-    }\n-\n-    fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n-        (0..self.num_vars() as usize)\n-            .map(|_| Value(self.tcx.types.re_empty))\n-            .collect()\n-    }\n-\n-    fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n-        debug!(\"----() Start constraint listing (context={:?}) ()----\",\n-               free_regions.context);\n-        for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n-            debug!(\"Constraint {} => {:?}\", idx, constraint);\n-        }\n-    }\n-\n-    fn expand_givens(&self, graph: &RegionGraph) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let mut givens = self.givens.borrow_mut();\n-        let seeds: Vec<_> = givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            let seed_index = NodeIndex(vid.index as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0 as u32;\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid { index: succ_index };\n-                    givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn expansion(&self,\n-                 region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                 var_values: &mut [VarValue<'tcx>]) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n-            debug!(\"expansion: constraint={:?} origin={:?}\",\n-                   constraint, origin);\n-            match *constraint {\n-                ConstrainRegSubVar(a_region, b_vid) => {\n-                    let b_data = &mut var_values[b_vid.index as usize];\n-                    self.expand_node(region_rels, a_region, b_vid, b_data)\n-                }\n-                ConstrainVarSubVar(a_vid, b_vid) => {\n-                    match var_values[a_vid.index as usize] {\n-                        ErrorValue => false,\n-                        Value(a_region) => {\n-                            let b_node = &mut var_values[b_vid.index as usize];\n-                            self.expand_node(region_rels, a_region, b_vid, b_node)\n-                        }\n-                    }\n-                }\n-                ConstrainRegSubReg(..) |\n-                ConstrainVarSubReg(..) => {\n-                    // These constraints are checked after expansion\n-                    // is done, in `collect_errors`.\n-                    false\n-                }\n-            }\n-        })\n-    }\n-\n-    fn expand_node(&self,\n-                   region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                   a_region: Region<'tcx>,\n-                   b_vid: RegionVid,\n-                   b_data: &mut VarValue<'tcx>)\n-                   -> bool {\n-        debug!(\"expand_node({:?}, {:?} == {:?})\",\n-               a_region,\n-               b_vid,\n-               b_data);\n-\n-        // Check if this relationship is implied by a given.\n-        match *a_region {\n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(_) => {\n-                if self.givens.borrow().contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match *b_data {\n-            Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(region_rels, a_region, cur_region);\n-                if lub == cur_region {\n-                    return false;\n-                }\n-\n-                debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n-                       b_vid,\n-                       cur_region,\n-                       lub);\n-\n-                *b_data = Value(lub);\n-                return true;\n-            }\n-\n-            ErrorValue => {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    /// After expansion is complete, go and check upper bounds (i.e.,\n-    /// cases where the region cannot grow larger than a fixed point)\n-    /// and check that they are satisfied.\n-    fn collect_errors(&self,\n-                      region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                      var_data: &mut Vec<VarValue<'tcx>>,\n-                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        let constraints = self.constraints.borrow();\n-        for (constraint, origin) in constraints.iter() {\n-            debug!(\"collect_errors: constraint={:?} origin={:?}\",\n-                   constraint, origin);\n-            match *constraint {\n-                ConstrainRegSubVar(..) |\n-                ConstrainVarSubVar(..) => {\n-                    // Expansion will ensure that these constraints hold. Ignore.\n-                }\n-\n-                ConstrainRegSubReg(sub, sup) => {\n-                    if region_rels.is_subregion_of(sub, sup) {\n-                        continue;\n-                    }\n-\n-                    debug!(\"collect_errors: region error at {:?}: \\\n-                            cannot verify that {:?} <= {:?}\",\n-                           origin,\n-                           sub,\n-                           sup);\n-\n-                    errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n-                }\n-\n-                ConstrainVarSubReg(a_vid, b_region) => {\n-                    let a_data = &mut var_data[a_vid.index as usize];\n-                    debug!(\"contraction: {:?} == {:?}, {:?}\",\n-                           a_vid,\n-                           a_data,\n-                           b_region);\n-\n-                    let a_region = match *a_data {\n-                        ErrorValue => continue,\n-                        Value(a_region) => a_region,\n-                    };\n-\n-                    // Do not report these errors immediately:\n-                    // instead, set the variable value to error and\n-                    // collect them later.\n-                    if !region_rels.is_subregion_of(a_region, b_region) {\n-                        debug!(\"collect_errors: region error at {:?}: \\\n-                                cannot verify that {:?}={:?} <= {:?}\",\n-                               origin,\n-                               a_vid,\n-                               a_region,\n-                               b_region);\n-                        *a_data = ErrorValue;\n-                    }\n-                }\n-            }\n-        }\n-\n-        for verify in self.verifys.borrow().iter() {\n-            debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = normalize(self.tcx, var_data, verify.region);\n-\n-            // This was an inference variable which didn't get\n-            // constrained, therefore it can be assume to hold.\n-            if let ty::ReEmpty = *sub {\n-                continue;\n-            }\n-\n-            if verify.bound.is_met(region_rels, var_data, sub) {\n-                continue;\n-            }\n-\n-            debug!(\"collect_errors: region error at {:?}: \\\n-                    cannot verify that {:?} <= {:?}\",\n-                   verify.origin,\n-                   verify.region,\n-                   verify.bound);\n-\n-            errors.push(GenericBoundFailure(verify.origin.clone(),\n-                                            verify.kind.clone(),\n-                                            sub));\n-        }\n-    }\n-\n-    /// Go over the variables that were declared to be error variables\n-    /// and create a `RegionResolutionError` for each of them.\n-    fn collect_var_errors(&self,\n-                          region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                          var_data: &[VarValue<'tcx>],\n-                          graph: &RegionGraph<'tcx>,\n-                          errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        debug!(\"collect_var_errors\");\n-\n-        // This is the best way that I have found to suppress\n-        // duplicate and related errors. Basically we keep a set of\n-        // flags for every node. Whenever an error occurs, we will\n-        // walk some portion of the graph looking to find pairs of\n-        // conflicting regions to report to the user. As we walk, we\n-        // trip the flags from false to true, and if we find that\n-        // we've already reported an error involving any particular\n-        // node we just stop and don't report the current error.  The\n-        // idea is to report errors that derive from independent\n-        // regions of the graph, but not those that derive from\n-        // overlapping locations.\n-        let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n-\n-        for idx in 0..self.num_vars() as usize {\n-            match var_data[idx] {\n-                Value(_) => {\n-                    /* Inference successful */\n-                }\n-                ErrorValue => {\n-                    /* Inference impossible, this value contains\n-                       inconsistent constraints.\n-\n-                       I think that in this case we should report an\n-                       error now---unlike the case above, we can't\n-                       wait to see whether the user needs the result\n-                       of this variable.  The reason is that the mere\n-                       existence of this variable implies that the\n-                       region graph is inconsistent, whether or not it\n-                       is used.\n-\n-                       For example, we may have created a region\n-                       variable that is the GLB of two other regions\n-                       which do not have a GLB.  Even if that variable\n-                       is not used, it implies that those two regions\n-                       *should* have a GLB.\n-\n-                       At least I think this is true. It may be that\n-                       the mere existence of a conflict in a region variable\n-                       that is not used is not a problem, so if this rule\n-                       starts to create problems we'll have to revisit\n-                       this portion of the code and think hard about it. =) */\n-\n-                    let node_vid = RegionVid { index: idx as u32 };\n-                    self.collect_error_for_expanding_node(region_rels,\n-                                                          graph,\n-                                                          &mut dup_vec,\n-                                                          node_vid,\n-                                                          errors);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn construct_graph(&self) -> RegionGraph<'tcx> {\n-        let num_vars = self.num_vars();\n-\n-        let constraints = self.constraints.borrow();\n-\n-        let mut graph = graph::Graph::new();\n-\n-        for _ in 0..num_vars {\n-            graph.add_node(());\n-        }\n-\n-        // Issue #30438: two distinct dummy nodes, one for incoming\n-        // edges (dummy_source) and another for outgoing edges\n-        // (dummy_sink). In `dummy -> a -> b -> dummy`, using one\n-        // dummy node leads one to think (erroneously) there exists a\n-        // path from `b` to `a`. Two dummy nodes sidesteps the issue.\n-        let dummy_source = graph.add_node(());\n-        let dummy_sink = graph.add_node(());\n-\n-        for (constraint, _) in constraints.iter() {\n-            match *constraint {\n-                ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.index as usize),\n-                                   NodeIndex(b_id.index as usize),\n-                                   *constraint);\n-                }\n-                ConstrainRegSubVar(_, b_id) => {\n-                    graph.add_edge(dummy_source, NodeIndex(b_id.index as usize), *constraint);\n-                }\n-                ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n-                }\n-                ConstrainRegSubReg(..) => {\n-                    // this would be an edge from `dummy_source` to\n-                    // `dummy_sink`; just ignore it.\n-                }\n-            }\n-        }\n-\n-        return graph;\n-    }\n-\n-    fn collect_error_for_expanding_node(&self,\n-                                        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                                        graph: &RegionGraph<'tcx>,\n-                                        dup_vec: &mut [u32],\n-                                        node_idx: RegionVid,\n-                                        errors: &mut Vec<RegionResolutionError<'tcx>>) {\n-        // Errors in expanding nodes result from a lower-bound that is\n-        // not contained by an upper-bound.\n-        let (mut lower_bounds, lower_dup) = self.collect_concrete_regions(graph,\n-                                                                          node_idx,\n-                                                                          graph::INCOMING,\n-                                                                          dup_vec);\n-        let (mut upper_bounds, upper_dup) = self.collect_concrete_regions(graph,\n-                                                                          node_idx,\n-                                                                          graph::OUTGOING,\n-                                                                          dup_vec);\n-\n-        if lower_dup || upper_dup {\n-            return;\n-        }\n-\n-        // We place free regions first because we are special casing\n-        // SubSupConflict(ReFree, ReFree) when reporting error, and so\n-        // the user will more likely get a specific suggestion.\n-        fn region_order_key(x: &RegionAndOrigin) -> u8 {\n-            match *x.region {\n-                ReEarlyBound(_) => 0,\n-                ReFree(_) => 1,\n-                _ => 2\n-            }\n-        }\n-        lower_bounds.sort_by_key(region_order_key);\n-        upper_bounds.sort_by_key(region_order_key);\n-\n-        for lower_bound in &lower_bounds {\n-            for upper_bound in &upper_bounds {\n-                if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n-                    let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n-                    debug!(\"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n-                            sup: {:?}\",\n-                           origin,\n-                           node_idx,\n-                           lower_bound.region,\n-                           upper_bound.region);\n-                    errors.push(SubSupConflict(origin,\n-                                               lower_bound.origin.clone(),\n-                                               lower_bound.region,\n-                                               upper_bound.origin.clone(),\n-                                               upper_bound.region));\n-                    return;\n-                }\n-            }\n-        }\n-\n-        span_bug!((*self.var_origins.borrow())[node_idx.index as usize].span(),\n-                  \"collect_error_for_expanding_node() could not find \\\n-                   error for var {:?}, lower_bounds={:?}, \\\n-                   upper_bounds={:?}\",\n-                  node_idx,\n-                  lower_bounds,\n-                  upper_bounds);\n-    }\n-\n-    fn collect_concrete_regions(&self,\n-                                graph: &RegionGraph<'tcx>,\n-                                orig_node_idx: RegionVid,\n-                                dir: Direction,\n-                                dup_vec: &mut [u32])\n-                                -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n-        struct WalkState<'tcx> {\n-            set: FxHashSet<RegionVid>,\n-            stack: Vec<RegionVid>,\n-            result: Vec<RegionAndOrigin<'tcx>>,\n-            dup_found: bool,\n-        }\n-        let mut state = WalkState {\n-            set: FxHashSet(),\n-            stack: vec![orig_node_idx],\n-            result: Vec::new(),\n-            dup_found: false,\n-        };\n-        state.set.insert(orig_node_idx);\n-\n-        // to start off the process, walk the source node in the\n-        // direction specified\n-        process_edges(self, &mut state, graph, orig_node_idx, dir);\n-\n-        while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop().unwrap();\n-\n-            // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index as usize] == u32::MAX {\n-                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n-                state.dup_found = true;\n-            }\n-\n-            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                   orig_node_idx,\n-                   node_idx);\n-\n-            process_edges(self, &mut state, graph, node_idx, dir);\n-        }\n-\n-        let WalkState {result, dup_found, ..} = state;\n-        return (result, dup_found);\n-\n-        fn process_edges<'a, 'gcx, 'tcx>(this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n-                                         state: &mut WalkState<'tcx>,\n-                                         graph: &RegionGraph<'tcx>,\n-                                         source_vid: RegionVid,\n-                                         dir: Direction) {\n-            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n-\n-            let source_node_index = NodeIndex(source_vid.index as usize);\n-            for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n-                match edge.data {\n-                    ConstrainVarSubVar(from_vid, to_vid) => {\n-                        let opp_vid = if from_vid == source_vid {\n-                            to_vid\n-                        } else {\n-                            from_vid\n-                        };\n-                        if state.set.insert(opp_vid) {\n-                            state.stack.push(opp_vid);\n-                        }\n-                    }\n-\n-                    ConstrainRegSubVar(region, _) |\n-                    ConstrainVarSubReg(_, region) => {\n-                        state.result.push(RegionAndOrigin {\n-                            region,\n-                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n-                        });\n-                    }\n-\n-                    ConstrainRegSubReg(..) => {\n-                        panic!(\"cannot reach reg-sub-reg edge in region inference \\\n-                                post-processing\")\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool\n-    {\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, origin) in self.constraints.borrow().iter() {\n-                let edge_changed = body(constraint, origin);\n-                if edge_changed {\n-                    debug!(\"Updated due to constraint {:?}\", constraint);\n-                    changed = true;\n-                }\n-            }\n-        }\n-        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n-    }\n-\n-}\n-\n-fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             values: &Vec<VarValue<'tcx>>,\n-                             r: ty::Region<'tcx>)\n-                             -> ty::Region<'tcx> {\n-    match *r {\n-        ty::ReVar(rid) => lookup(tcx, values, rid),\n-        _ => r,\n-    }\n-}\n-\n-fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                          values: &Vec<VarValue<'tcx>>,\n-                          rid: ty::RegionVid)\n-                          -> ty::Region<'tcx> {\n-    match values[rid.index as usize] {\n-        Value(r) => r,\n-        ErrorValue => tcx.types.re_static, // Previously reported error.\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n-    }\n }\n \n impl fmt::Debug for RegionSnapshot {\n@@ -1618,31 +970,4 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n             VerifyBound::AllBounds(vec![self, vb])\n         }\n     }\n-\n-    fn is_met(&self,\n-              region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-              var_values: &Vec<VarValue<'tcx>>,\n-              min: ty::Region<'tcx>)\n-              -> bool {\n-        let tcx = region_rels.tcx;\n-        match self {\n-            &VerifyBound::AnyRegion(ref rs) =>\n-                rs.iter()\n-                  .map(|&r| normalize(tcx, var_values, r))\n-                  .any(|r| region_rels.is_subregion_of(min, r)),\n-\n-            &VerifyBound::AllRegions(ref rs) =>\n-                rs.iter()\n-                  .map(|&r| normalize(tcx, var_values, r))\n-                  .all(|r| region_rels.is_subregion_of(min, r)),\n-\n-            &VerifyBound::AnyBound(ref bs) =>\n-                bs.iter()\n-                  .any(|b| b.is_met(region_rels, var_values, min)),\n-\n-            &VerifyBound::AllBounds(ref bs) =>\n-                bs.iter()\n-                  .all(|b| b.is_met(region_rels, var_values, min)),\n-        }\n-    }\n }"}]}