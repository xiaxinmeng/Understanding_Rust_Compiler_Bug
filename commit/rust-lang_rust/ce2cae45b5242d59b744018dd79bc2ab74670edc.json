{"sha": "ce2cae45b5242d59b744018dd79bc2ab74670edc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMmNhZTQ1YjUyNDJkNTliNzQ0MDE4ZGQ3OWJjMmFiNzQ2NzBlZGM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-15T20:02:34Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-16T16:58:17Z"}, "message": "Rename Substs -> Substitution", "tree": {"sha": "dc4ed41e25efae7b6f76fcf18b6b6eb68170e7a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc4ed41e25efae7b6f76fcf18b6b6eb68170e7a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce2cae45b5242d59b744018dd79bc2ab74670edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2cae45b5242d59b744018dd79bc2ab74670edc", "html_url": "https://github.com/rust-lang/rust/commit/ce2cae45b5242d59b744018dd79bc2ab74670edc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce2cae45b5242d59b744018dd79bc2ab74670edc/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00c80b208bcbe52b13bbd03cb62e24b2d2075edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/00c80b208bcbe52b13bbd03cb62e24b2d2075edf", "html_url": "https://github.com/rust-lang/rust/commit/00c80b208bcbe52b13bbd03cb62e24b2d2075edf"}], "stats": {"total": 322, "additions": 167, "deletions": 155}, "files": [{"sha": "9f6d7be48393a6c1e8e375d71383011b6e3ef5d9", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{self, NameOwner};\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasVisibility, LifetimeParam,\n-    Module, Static, Struct, Substs, Trait, Type, TypeAlias, TypeParam, Union, Variant,\n+    Module, Static, Struct, Substitution, Trait, Type, TypeAlias, TypeParam, Union, Variant,\n };\n \n impl HirDisplay for Function {\n@@ -235,7 +235,7 @@ impl HirDisplay for TypeParam {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write!(f, \"{}\", self.name(f.db))?;\n         let bounds = f.db.generic_predicates_for_param(self.id);\n-        let substs = Substs::type_params(f.db, self.id.parent);\n+        let substs = Substitution::type_params(f.db, self.id.parent);\n         let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n         if !(predicates.is_empty() || f.omit_verbose_types()) {\n             write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;"}, {"sha": "12dd5fb383db5636e471339da3bae15416021b3c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -57,8 +57,8 @@ use hir_ty::{\n     to_assoc_type_id,\n     traits::{FnTrait, Solution, SolutionVariables},\n     AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n-    InEnvironment, Interner, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, Ty,\n-    TyDefId, TyKind, TyVariableKind,\n+    InEnvironment, Interner, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substitution,\n+    Ty, TyDefId, TyKind, TyVariableKind,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -518,7 +518,7 @@ impl Field {\n             VariantDef::Union(it) => it.id.into(),\n             VariantDef::Variant(it) => it.parent.id.into(),\n         };\n-        let substs = Substs::type_params(db, generic_def_id);\n+        let substs = Substitution::type_params(db, generic_def_id);\n         let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n         Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n     }\n@@ -1471,7 +1471,7 @@ impl TypeParam {\n         let resolver = self.id.parent.resolver(db.upcast());\n         let krate = self.id.parent.module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n-        let subst = Substs::type_params(db, self.id.parent);\n+        let subst = Substitution::type_params(db, self.id.parent);\n         let ty = ty.subst(&subst.prefix(local_idx));\n         Some(Type::new_with_resolver_inner(db, krate, &resolver, ty))\n     }\n@@ -1674,7 +1674,7 @@ impl Type {\n         krate: CrateId,\n         def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n     ) -> Type {\n-        let substs = Substs::build_for_def(db, def).fill_with_unknown().build();\n+        let substs = Substitution::build_for_def(db, def).fill_with_unknown().build();\n         let ty = db.ty(def.into()).subst(&substs);\n         Type::new(db, krate, def, ty)\n     }\n@@ -1754,7 +1754,7 @@ impl Type {\n     pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n         let trait_ref = hir_ty::TraitRef {\n             trait_: trait_.id,\n-            substs: Substs::build_for_def(db, trait_.id)\n+            substs: Substitution::build_for_def(db, trait_.id)\n                 .push(self.ty.value.clone())\n                 .fill(args.iter().map(|t| t.ty.value.clone()))\n                 .build(),\n@@ -1778,7 +1778,7 @@ impl Type {\n         args: &[Type],\n         alias: TypeAlias,\n     ) -> Option<Type> {\n-        let subst = Substs::build_for_def(db, trait_.id)\n+        let subst = Substitution::build_for_def(db, trait_.id)\n             .push(self.ty.value.clone())\n             .fill(args.iter().map(|t| t.ty.value.clone()))\n             .build();\n@@ -2045,7 +2045,7 @@ impl Type {\n         fn walk_substs(\n             db: &dyn HirDatabase,\n             type_: &Type,\n-            substs: &Substs,\n+            substs: &Substitution,\n             cb: &mut impl FnMut(Type),\n         ) {\n             for ty in substs.iter() {"}, {"sha": "117f32a9e197d4ac05852d2f75ef45d8ed0a427b", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -20,7 +20,7 @@ use hir_def::{\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use hir_ty::{\n     diagnostics::{record_literal_missing_fields, record_pattern_missing_fields},\n-    InferenceResult, Substs,\n+    InferenceResult, Substitution,\n };\n use syntax::{\n     ast::{self, AstNode},\n@@ -329,7 +329,7 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         krate: CrateId,\n-        substs: &Substs,\n+        substs: &Substitution,\n         variant: VariantId,\n         missing_fields: Vec<LocalFieldId>,\n     ) -> Vec<(Field, Type)> {"}, {"sha": "bd2ff5d38a89ddce3f972868d65f2965e04dd9de", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     to_assoc_type_id,\n     traits::{InEnvironment, Solution},\n     utils::generics,\n-    BoundVar, Canonical, DebruijnIndex, Interner, Obligation, Substs, TraitRef, Ty, TyKind,\n+    BoundVar, Canonical, DebruijnIndex, Interner, Obligation, Substitution, TraitRef, Ty, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -65,7 +65,7 @@ fn deref_by_trait(\n     // FIXME make the Canonical / bound var handling nicer\n \n     let parameters =\n-        Substs::build_for_generics(&generic_params).push(ty.value.value.clone()).build();\n+        Substitution::build_for_generics(&generic_params).push(ty.value.value.clone()).build();\n \n     // Check that the type implements Deref at all\n     let trait_ref = TraitRef { trait_: deref_trait, substs: parameters.clone() };"}, {"sha": "7ce0f864c76bee034a6cc6b388f41ea7c6f1d9d1", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     db::HirDatabase, from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, primitive,\n     to_assoc_type_id, traits::chalk::from_chalk, utils::generics, AdtId, AliasTy, CallableDefId,\n     CallableSig, GenericPredicate, ImplTraitId, Interner, Lifetime, Obligation, OpaqueTy,\n-    ProjectionTy, Scalar, Substs, TraitRef, Ty, TyKind,\n+    ProjectionTy, Scalar, Substitution, TraitRef, Ty, TyKind,\n };\n \n pub struct HirFormatter<'a> {\n@@ -562,7 +562,7 @@ impl HirDisplay for Ty {\n                     }\n                     TypeParamProvenance::ArgumentImplTrait => {\n                         let bounds = f.db.generic_predicates_for_param(id);\n-                        let substs = Substs::type_params_for_generics(f.db, &generics);\n+                        let substs = Substitution::type_params_for_generics(f.db, &generics);\n                         write_bounds_like_dyn_trait_with_prefix(\n                             \"impl\",\n                             &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),"}, {"sha": "2610c92795dbad3b9a56b1a335151930fd814efa", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -38,7 +38,7 @@ use syntax::SmolStr;\n \n use super::{\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n+    InEnvironment, ProjectionTy, Substitution, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n@@ -390,7 +390,7 @@ impl<'a> InferenceContext<'a> {\n                     _ => panic!(\"resolve_associated_type called with non-associated type\"),\n                 };\n                 let ty = self.table.new_type_var();\n-                let substs = Substs::build_for_def(self.db, res_assoc_ty)\n+                let substs = Substitution::build_for_def(self.db, res_assoc_ty)\n                     .push(inner_ty)\n                     .fill(params.iter().cloned())\n                     .build();\n@@ -469,7 +469,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n-                let substs = Substs::type_params_for_generics(self.db, &generics);\n+                let substs = Substitution::type_params_for_generics(self.db, &generics);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n                 match unresolved {\n                     None => {\n@@ -496,7 +496,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             TypeNs::TypeAliasId(it) => {\n-                let substs = Substs::build_for_def(self.db, it)\n+                let substs = Substitution::build_for_def(self.db, it)\n                     .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                     .build();\n                 let ty = self.db.ty(it.into()).subst(&substs);"}, {"sha": "b1f98c507d18bf659855b967e17e5abb97c95e0f", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -7,7 +7,9 @@\n use chalk_ir::{Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{autoderef, traits::Solution, Interner, Obligation, Substs, TraitRef, Ty, TyKind};\n+use crate::{\n+    autoderef, traits::Solution, Interner, Obligation, Substitution, TraitRef, Ty, TyKind,\n+};\n \n use super::{InEnvironment, InferenceContext};\n \n@@ -134,7 +136,7 @@ impl<'a> InferenceContext<'a> {\n             return None;\n         }\n \n-        let substs = Substs::build_for_generics(&generic_params)\n+        let substs = Substitution::build_for_generics(&generic_params)\n             .push(from_ty.clone())\n             .push(to_ty.clone())\n             .build();"}, {"sha": "0be8c5a90216c4703507b753e6c237a409e36a59", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -21,8 +21,8 @@ use crate::{\n     to_assoc_type_id,\n     traits::{chalk::from_chalk, FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, Interner, Obligation, Rawness, Scalar, Substs,\n-    TraitRef, Ty, TyKind,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, Interner, Obligation, Rawness, Scalar,\n+    Substitution, TraitRef, Ty, TyKind,\n };\n \n use super::{\n@@ -77,7 +77,7 @@ impl<'a> InferenceContext<'a> {\n             return None;\n         }\n \n-        let mut param_builder = Substs::builder(num_args);\n+        let mut param_builder = Substitution::builder(num_args);\n         let mut arg_tys = vec![];\n         for _ in 0..num_args {\n             let arg = self.table.new_type_var();\n@@ -87,7 +87,7 @@ impl<'a> InferenceContext<'a> {\n         let parameters = param_builder.build();\n         let arg_ty = TyKind::Tuple(num_args, parameters).intern(&Interner);\n         let substs =\n-            Substs::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n+            Substitution::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n \n         let trait_env = Arc::clone(&self.trait_env);\n         let implements_fn_trait =\n@@ -181,7 +181,7 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr(*body, &Expectation::none());\n                 let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n-                TyKind::OpaqueType(opaque_ty_id, Substs::single(inner_ty)).intern(&Interner)\n+                TyKind::OpaqueType(opaque_ty_id, Substitution::single(inner_ty)).intern(&Interner)\n             }\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n@@ -262,12 +262,12 @@ impl<'a> InferenceContext<'a> {\n                 let sig_ty = TyKind::Function(FnPointer {\n                     num_args: sig_tys.len() - 1,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n-                    substs: Substs(sig_tys.clone().into()),\n+                    substs: Substitution(sig_tys.clone().into()),\n                 })\n                 .intern(&Interner);\n                 let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n                 let closure_ty =\n-                    TyKind::Closure(closure_id, Substs::single(sig_ty)).intern(&Interner);\n+                    TyKind::Closure(closure_id, Substitution::single(sig_ty)).intern(&Interner);\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -402,7 +402,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.unify(&ty, &expected.ty);\n \n-                let substs = ty.substs().cloned().unwrap_or_else(Substs::empty);\n+                let substs = ty.substs().cloned().unwrap_or_else(Substitution::empty);\n                 let field_types = def_id.map(|it| self.db.field_types(it)).unwrap_or_default();\n                 let variant_data = def_id.map(|it| variant_data(self.db.upcast(), it));\n                 for field in fields.iter() {\n@@ -511,7 +511,8 @@ impl<'a> InferenceContext<'a> {\n             Expr::Box { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 if let Some(box_) = self.resolve_boxed_box() {\n-                    let mut sb = Substs::builder(generics(self.db.upcast(), box_.into()).len());\n+                    let mut sb =\n+                        Substitution::builder(generics(self.db.upcast(), box_.into()).len());\n                     sb = sb.push(inner_ty);\n                     match self.db.generic_defaults(box_.into()).as_ref() {\n                         [_, alloc_ty, ..] if !alloc_ty.value.is_unknown() => {\n@@ -610,31 +611,31 @@ impl<'a> InferenceContext<'a> {\n                 let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n                 match (range_type, lhs_ty, rhs_ty) {\n                     (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n-                        Some(adt) => Ty::adt_ty(adt, Substs::empty()),\n+                        Some(adt) => Ty::adt_ty(adt, Substitution::empty()),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n-                        Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n+                        Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, None, Some(ty)) => {\n                         match self.resolve_range_to_inclusive() {\n-                            Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n+                            Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n                             None => self.err_ty(),\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n-                        Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n+                        Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, Some(_), Some(ty)) => {\n                         match self.resolve_range_inclusive() {\n-                            Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n+                            Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n                             None => self.err_ty(),\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n-                        Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n+                        Some(adt) => Ty::adt_ty(adt, Substitution::single(ty)),\n                         None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, _, None) => self.err_ty(),\n@@ -681,7 +682,7 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                TyKind::Tuple(tys.len(), Substs(tys.into())).intern(&Interner)\n+                TyKind::Tuple(tys.len(), Substitution(tys.into())).intern(&Interner)\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match expected.ty.interned(&Interner) {\n@@ -887,7 +888,7 @@ impl<'a> InferenceContext<'a> {\n         def_generics: Option<Generics>,\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n-    ) -> Substs {\n+    ) -> Substitution {\n         let (parent_params, self_params, type_params, impl_trait_params) =\n             def_generics.as_ref().map_or((0, 0, 0, 0), |g| g.provenance_split());\n         assert_eq!(self_params, 0); // method shouldn't have another Self param\n@@ -926,7 +927,7 @@ impl<'a> InferenceContext<'a> {\n             substs.push(self.err_ty());\n         }\n         assert_eq!(substs.len(), total_len);\n-        Substs(substs.into())\n+        Substitution(substs.into())\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {"}, {"sha": "befa0d69b079872458987236f3dfc18b4cc58641", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -12,7 +12,9 @@ use hir_def::{\n use hir_expand::name::Name;\n \n use super::{BindingMode, Expectation, InferenceContext};\n-use crate::{lower::lower_to_chalk_mutability, utils::variant_data, Interner, Substs, Ty, TyKind};\n+use crate::{\n+    lower::lower_to_chalk_mutability, utils::variant_data, Interner, Substitution, Ty, TyKind,\n+};\n \n impl<'a> InferenceContext<'a> {\n     fn infer_tuple_struct_pat(\n@@ -31,7 +33,7 @@ impl<'a> InferenceContext<'a> {\n         }\n         self.unify(&ty, expected);\n \n-        let substs = ty.substs().cloned().unwrap_or_else(Substs::empty);\n+        let substs = ty.substs().cloned().unwrap_or_else(Substitution::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n@@ -70,7 +72,7 @@ impl<'a> InferenceContext<'a> {\n \n         self.unify(&ty, expected);\n \n-        let substs = ty.substs().cloned().unwrap_or_else(Substs::empty);\n+        let substs = ty.substs().cloned().unwrap_or_else(Substitution::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         for subpat in subpats {\n@@ -138,7 +140,7 @@ impl<'a> InferenceContext<'a> {\n                 inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n                 inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n \n-                TyKind::Tuple(inner_tys.len(), Substs(inner_tys.into())).intern(&Interner)\n+                TyKind::Tuple(inner_tys.len(), Substitution(inner_tys.into())).intern(&Interner)\n             }\n             Pat::Or(ref pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -237,7 +239,7 @@ impl<'a> InferenceContext<'a> {\n                     };\n \n                     let inner_ty = self.infer_pat(*inner, &inner_expected, default_bm);\n-                    Ty::adt_ty(box_adt, Substs::single(inner_ty))\n+                    Ty::adt_ty(box_adt, Substitution::single(inner_ty))\n                 }\n                 None => self.err_ty(),\n             },"}, {"sha": "ea01d623872be5947c220e45ce2f572ee3137bb8", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -9,7 +9,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{method_resolution, Interner, Substs, Ty, TyKind, ValueTyDefId};\n+use crate::{method_resolution, Interner, Substitution, Ty, TyKind, ValueTyDefId};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n@@ -79,7 +79,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             ValueNs::ImplSelf(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n-                let substs = Substs::type_params_for_generics(self.db, &generics);\n+                let substs = Substitution::type_params_for_generics(self.db, &generics);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n                     let ty = self.db.value_ty(struct_id.into()).subst(&substs);\n@@ -94,10 +94,10 @@ impl<'a> InferenceContext<'a> {\n \n         let ty = self.db.value_ty(typable);\n         // self_subst is just for the parent\n-        let parent_substs = self_subst.unwrap_or_else(Substs::empty);\n+        let parent_substs = self_subst.unwrap_or_else(Substitution::empty);\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let full_substs = Substs::builder(substs.len())\n+        let full_substs = Substitution::builder(substs.len())\n             .use_parent_substs(&parent_substs)\n             .fill(substs.0[parent_substs.len()..].iter().cloned())\n             .build();\n@@ -111,7 +111,7 @@ impl<'a> InferenceContext<'a> {\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n+    ) -> Option<(ValueNs, Option<Substitution>)> {\n         assert!(remaining_index < path.segments().len());\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n@@ -164,7 +164,7 @@ impl<'a> InferenceContext<'a> {\n         trait_ref: TraitRef,\n         segment: PathSegment<'_>,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n+    ) -> Option<(ValueNs, Option<Substitution>)> {\n         let trait_ = trait_ref.trait_;\n         let item =\n             self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id)).find_map(|item| {\n@@ -208,7 +208,7 @@ impl<'a> InferenceContext<'a> {\n         ty: Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n+    ) -> Option<(ValueNs, Option<Substitution>)> {\n         if let TyKind::Unknown = ty.interned(&Interner) {\n             return None;\n         }\n@@ -241,7 +241,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let substs = match container {\n                     AssocContainerId::ImplId(impl_id) => {\n-                        let impl_substs = Substs::build_for_def(self.db, impl_id)\n+                        let impl_substs = Substitution::build_for_def(self.db, impl_id)\n                             .fill(iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let impl_self_ty = self.db.impl_self_ty(impl_id).subst(&impl_substs);\n@@ -250,7 +250,7 @@ impl<'a> InferenceContext<'a> {\n                     }\n                     AssocContainerId::TraitId(trait_) => {\n                         // we're picking this method\n-                        let trait_substs = Substs::build_for_def(self.db, trait_)\n+                        let trait_substs = Substitution::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n@@ -274,7 +274,7 @@ impl<'a> InferenceContext<'a> {\n         ty: &Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n+    ) -> Option<(ValueNs, Option<Substitution>)> {\n         let (enum_id, subst) = match ty.as_adt() {\n             Some((AdtId::EnumId(e), subst)) => (e, subst),\n             _ => return None,"}, {"sha": "b2d4f67b313f6d461d311c8b718a30755981ef4b", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -8,7 +8,7 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use super::{InferenceContext, Obligation};\n use crate::{\n     BoundVar, Canonical, DebruijnIndex, FnPointer, GenericPredicate, InEnvironment, InferenceVar,\n-    Interner, Scalar, Substs, Ty, TyKind, TypeWalk,\n+    Interner, Scalar, Substitution, Ty, TyKind, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -123,10 +123,10 @@ impl<T> Canonicalized<T> {\n     pub(super) fn apply_solution(\n         &self,\n         ctx: &mut InferenceContext<'_>,\n-        solution: Canonical<Substs>,\n+        solution: Canonical<Substitution>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substs(\n+        let new_vars = Substitution(\n             solution\n                 .kinds\n                 .iter()\n@@ -147,9 +147,9 @@ impl<T> Canonicalized<T> {\n     }\n }\n \n-pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n+pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     let mut table = InferenceTable::new();\n-    let vars = Substs(\n+    let vars = Substitution(\n         tys.kinds\n             .iter()\n             // we always use type vars here because we want everything to\n@@ -173,7 +173,7 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n         }\n     }\n     Some(\n-        Substs::builder(tys.kinds.len())\n+        Substitution::builder(tys.kinds.len())\n             .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n             .build(),\n     )\n@@ -264,8 +264,8 @@ impl InferenceTable {\n \n     pub(crate) fn unify_substs(\n         &mut self,\n-        substs1: &Substs,\n-        substs2: &Substs,\n+        substs1: &Substitution,\n+        substs2: &Substitution,\n         depth: usize,\n     ) -> bool {\n         substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))"}, {"sha": "52b498ff70ed8f2fb987c489b39fa8a2fafaabb2", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -67,7 +67,7 @@ pub enum Lifetime {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct OpaqueTy {\n     pub opaque_ty_id: OpaqueTyId,\n-    pub substitution: Substs,\n+    pub substitution: Substitution,\n }\n \n /// A \"projection\" type corresponds to an (unnormalized)\n@@ -76,7 +76,7 @@ pub struct OpaqueTy {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ProjectionTy {\n     pub associated_ty_id: AssocTypeId,\n-    pub substitution: Substs,\n+    pub substitution: Substitution,\n }\n \n impl ProjectionTy {\n@@ -112,7 +112,7 @@ pub type FnSig = chalk_ir::FnSig<Interner>;\n pub struct FnPointer {\n     pub num_args: usize,\n     pub sig: FnSig,\n-    pub substs: Substs,\n+    pub substs: Substitution,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -137,19 +137,19 @@ pub enum AliasTy {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum TyKind {\n     /// Structures, enumerations and unions.\n-    Adt(AdtId<Interner>, Substs),\n+    Adt(AdtId<Interner>, Substitution),\n \n     /// Represents an associated item like `Iterator::Item`.  This is used\n     /// when we have tried to normalize a projection like `T::Item` but\n     /// couldn't find a better representation.  In that case, we generate\n     /// an **application type** like `(Iterator::Item)<T>`.\n-    AssociatedType(AssocTypeId, Substs),\n+    AssociatedType(AssocTypeId, Substitution),\n \n     /// a scalar type like `bool` or `u32`\n     Scalar(Scalar),\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple(usize, Substs),\n+    Tuple(usize, Substitution),\n \n     /// An array with the given length. Written as `[T; n]`.\n     Array(Ty),\n@@ -169,7 +169,7 @@ pub enum TyKind {\n     /// analogous to the `AssociatedType` type constructor.\n     /// It is also used as the type of async block, with one type parameter\n     /// representing the Future::Output type.\n-    OpaqueType(OpaqueTyId, Substs),\n+    OpaqueType(OpaqueTyId, Substitution),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type, which is output (for a function\n@@ -183,7 +183,7 @@ pub enum TyKind {\n     /// fn foo() -> i32 { 1 }\n     /// let bar = foo; // bar: fn() -> i32 {foo}\n     /// ```\n-    FnDef(FnDefId, Substs),\n+    FnDef(FnDefId, Substitution),\n \n     /// The pointee of a string slice. Written as `str`.\n     Str,\n@@ -195,7 +195,7 @@ pub enum TyKind {\n     ///\n     /// The closure signature is stored in a `FnPtr` type in the first type\n     /// parameter.\n-    Closure(ClosureId, Substs),\n+    Closure(ClosureId, Substitution),\n \n     /// Represents a foreign type declared in external blocks.\n     ForeignType(ForeignDefId),\n@@ -273,9 +273,9 @@ impl Ty {\n \n /// A list of substitutions for generic parameters.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Substs(SmallVec<[Ty; 2]>);\n+pub struct Substitution(SmallVec<[Ty; 2]>);\n \n-impl TypeWalk for Substs {\n+impl TypeWalk for Substitution {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         for t in self.0.iter() {\n             t.walk(f);\n@@ -293,29 +293,29 @@ impl TypeWalk for Substs {\n     }\n }\n \n-impl Substs {\n+impl Substitution {\n     pub fn interned(&self, _: &Interner) -> &[Ty] {\n         &self.0\n     }\n \n-    pub fn empty() -> Substs {\n-        Substs(SmallVec::new())\n+    pub fn empty() -> Substitution {\n+        Substitution(SmallVec::new())\n     }\n \n-    pub fn single(ty: Ty) -> Substs {\n-        Substs({\n+    pub fn single(ty: Ty) -> Substitution {\n+        Substitution({\n             let mut v = SmallVec::new();\n             v.push(ty);\n             v\n         })\n     }\n \n-    pub fn prefix(&self, n: usize) -> Substs {\n-        Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n+    pub fn prefix(&self, n: usize) -> Substitution {\n+        Substitution(self.0[..std::cmp::min(self.0.len(), n)].into())\n     }\n \n-    pub fn suffix(&self, n: usize) -> Substs {\n-        Substs(self.0[self.0.len() - std::cmp::min(self.0.len(), n)..].into())\n+    pub fn suffix(&self, n: usize) -> Substitution {\n+        Substitution(self.0[self.0.len() - std::cmp::min(self.0.len(), n)..].into())\n     }\n \n     pub fn as_single(&self) -> &Ty {\n@@ -326,15 +326,15 @@ impl Substs {\n     }\n \n     pub fn from_iter(_interner: &Interner, elements: impl IntoIterator<Item = Ty>) -> Self {\n-        Substs(elements.into_iter().collect())\n+        Substitution(elements.into_iter().collect())\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n     pub(crate) fn type_params_for_generics(\n         db: &dyn HirDatabase,\n         generic_params: &Generics,\n-    ) -> Substs {\n-        Substs(\n+    ) -> Substitution {\n+        Substitution(\n             generic_params\n                 .iter()\n                 .map(|(id, _)| TyKind::Placeholder(to_placeholder_idx(db, id)).intern(&Interner))\n@@ -343,14 +343,14 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn type_params(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substs {\n+    pub fn type_params(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n         let params = generics(db.upcast(), def.into());\n-        Substs::type_params_for_generics(db, &params)\n+        Substitution::type_params_for_generics(db, &params)\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n-    pub(crate) fn bound_vars(generic_params: &Generics, debruijn: DebruijnIndex) -> Substs {\n-        Substs(\n+    pub(crate) fn bound_vars(generic_params: &Generics, debruijn: DebruijnIndex) -> Substitution {\n+        Substitution(\n             generic_params\n                 .iter()\n                 .enumerate()\n@@ -363,11 +363,11 @@ impl Substs {\n         let def = def.into();\n         let params = generics(db.upcast(), def);\n         let param_count = params.len();\n-        Substs::builder(param_count)\n+        Substitution::builder(param_count)\n     }\n \n     pub(crate) fn build_for_generics(generic_params: &Generics) -> SubstsBuilder {\n-        Substs::builder(generic_params.len())\n+        Substitution::builder(generic_params.len())\n     }\n \n     fn builder(param_count: usize) -> SubstsBuilder {\n@@ -387,9 +387,9 @@ pub struct SubstsBuilder {\n }\n \n impl SubstsBuilder {\n-    pub fn build(self) -> Substs {\n+    pub fn build(self) -> Substitution {\n         assert_eq!(self.vec.len(), self.param_count);\n-        Substs(self.vec.into())\n+        Substitution(self.vec.into())\n     }\n \n     pub fn push(mut self, ty: Ty) -> Self {\n@@ -418,15 +418,15 @@ impl SubstsBuilder {\n         self\n     }\n \n-    pub fn use_parent_substs(mut self, parent_substs: &Substs) -> Self {\n+    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n         assert!(self.vec.is_empty());\n         assert!(parent_substs.len() <= self.param_count);\n         self.vec.extend(parent_substs.iter().cloned());\n         self\n     }\n }\n \n-impl Deref for Substs {\n+impl Deref for Substitution {\n     type Target = [Ty];\n \n     fn deref(&self) -> &[Ty] {\n@@ -466,13 +466,13 @@ impl<T: Clone> Binders<&T> {\n \n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n-    pub fn subst(self, subst: &Substs) -> T {\n+    pub fn subst(self, subst: &Substitution) -> T {\n         assert_eq!(subst.len(), self.num_binders);\n         self.value.subst_bound_vars(subst)\n     }\n \n     /// Substitutes just a prefix of the variables (shifting the rest).\n-    pub fn subst_prefix(self, subst: &Substs) -> Binders<T> {\n+    pub fn subst_prefix(self, subst: &Substitution) -> Binders<T> {\n         assert!(subst.len() < self.num_binders);\n         Binders::new(self.num_binders - subst.len(), self.value.subst_bound_vars(subst))\n     }\n@@ -498,7 +498,7 @@ impl<T: TypeWalk> TypeWalk for Binders<T> {\n pub struct TraitRef {\n     /// FIXME name?\n     pub trait_: TraitId,\n-    pub substs: Substs,\n+    pub substs: Substitution,\n }\n \n impl TraitRef {\n@@ -618,7 +618,7 @@ impl CallableSig {\n         }\n     }\n \n-    pub fn from_substs(substs: &Substs) -> CallableSig {\n+    pub fn from_substs(substs: &Substitution) -> CallableSig {\n         CallableSig { params_and_return: substs.iter().cloned().collect(), is_varargs: false }\n     }\n \n@@ -651,18 +651,18 @@ impl TypeWalk for CallableSig {\n \n impl Ty {\n     pub fn unit() -> Self {\n-        TyKind::Tuple(0, Substs::empty()).intern(&Interner)\n+        TyKind::Tuple(0, Substitution::empty()).intern(&Interner)\n     }\n \n-    pub fn adt_ty(adt: hir_def::AdtId, substs: Substs) -> Ty {\n+    pub fn adt_ty(adt: hir_def::AdtId, substs: Substitution) -> Ty {\n         TyKind::Adt(AdtId(adt), substs).intern(&Interner)\n     }\n \n     pub fn fn_ptr(sig: CallableSig) -> Self {\n         TyKind::Function(FnPointer {\n             num_args: sig.params().len(),\n             sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n-            substs: Substs::from_iter(&Interner, sig.params_and_return.iter().cloned()),\n+            substs: Substitution::from_iter(&Interner, sig.params_and_return.iter().cloned()),\n         })\n         .intern(&Interner)\n     }\n@@ -709,14 +709,14 @@ impl Ty {\n         t\n     }\n \n-    pub fn as_adt(&self) -> Option<(hir_def::AdtId, &Substs)> {\n+    pub fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n         match self.interned(&Interner) {\n             TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n             _ => None,\n         }\n     }\n \n-    pub fn as_tuple(&self) -> Option<&Substs> {\n+    pub fn as_tuple(&self) -> Option<&Substitution> {\n         match self.interned(&Interner) {\n             TyKind::Tuple(_, substs) => Some(substs),\n             _ => None,\n@@ -828,7 +828,7 @@ impl Ty {\n \n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n-    pub fn substs(&self) -> Option<&Substs> {\n+    pub fn substs(&self) -> Option<&Substitution> {\n         match self.interned(&Interner) {\n             TyKind::Adt(_, substs)\n             | TyKind::FnDef(_, substs)\n@@ -841,7 +841,7 @@ impl Ty {\n         }\n     }\n \n-    fn substs_mut(&mut self) -> Option<&mut Substs> {\n+    fn substs_mut(&mut self) -> Option<&mut Substitution> {\n         match self.interned_mut() {\n             TyKind::Adt(_, substs)\n             | TyKind::FnDef(_, substs)\n@@ -869,7 +869,7 @@ impl Ty {\n                             // So just provide the Future trait.\n                             let impl_bound = GenericPredicate::Implemented(TraitRef {\n                                 trait_: future_trait,\n-                                substs: Substs::empty(),\n+                                substs: Substitution::empty(),\n                             });\n                             Some(vec![impl_bound])\n                         } else {\n@@ -992,15 +992,15 @@ pub trait TypeWalk {\n     }\n \n     /// Substitutes `TyKind::Bound` vars with the given substitution.\n-    fn subst_bound_vars(self, substs: &Substs) -> Self\n+    fn subst_bound_vars(self, substs: &Substitution) -> Self\n     where\n         Self: Sized,\n     {\n         self.subst_bound_vars_at_depth(substs, DebruijnIndex::INNERMOST)\n     }\n \n     /// Substitutes `TyKind::Bound` vars with the given substitution.\n-    fn subst_bound_vars_at_depth(mut self, substs: &Substs, depth: DebruijnIndex) -> Self\n+    fn subst_bound_vars_at_depth(mut self, substs: &Substitution, depth: DebruijnIndex) -> Self\n     where\n         Self: Sized,\n     {"}, {"sha": "462882b2b30767b125f4f0b556e2e0ee1b73a077", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -35,7 +35,7 @@ use crate::{\n     },\n     AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, FnPointer, FnSig, GenericPredicate,\n     ImplTraitId, OpaqueTy, PolyFnSig, ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait,\n-    ReturnTypeImplTraits, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n+    ReturnTypeImplTraits, Substitution, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n };\n \n #[derive(Debug)]\n@@ -151,7 +151,7 @@ impl<'a> TyLoweringContext<'a> {\n             TypeRef::Never => TyKind::Never.intern(&Interner),\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner.iter().map(|tr| self.lower_ty(tr));\n-                TyKind::Tuple(inner_tys.len(), Substs::from_iter(&Interner, inner_tys))\n+                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(&Interner, inner_tys))\n                     .intern(&Interner)\n             }\n             TypeRef::Path(path) => {\n@@ -177,7 +177,7 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::Placeholder => TyKind::Unknown.intern(&Interner),\n             TypeRef::Fn(params, is_varargs) => {\n-                let substs = Substs(params.iter().map(|tr| self.lower_ty(tr)).collect());\n+                let substs = Substitution(params.iter().map(|tr| self.lower_ty(tr)).collect());\n                 TyKind::Function(FnPointer {\n                     num_args: substs.len() - 1,\n                     sig: FnSig { abi: (), safety: Safety::Safe, variadic: *is_varargs },\n@@ -228,7 +228,7 @@ impl<'a> TyLoweringContext<'a> {\n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n-                        let parameters = Substs::bound_vars(&generics, self.in_binders);\n+                        let parameters = Substitution::bound_vars(&generics, self.in_binders);\n                         TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                             opaque_ty_id,\n                             substitution: parameters,\n@@ -398,10 +398,10 @@ impl<'a> TyLoweringContext<'a> {\n                 let generics = generics(self.db.upcast(), impl_id.into());\n                 let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n-                        Substs::type_params_for_generics(self.db, &generics)\n+                        Substitution::type_params_for_generics(self.db, &generics)\n                     }\n                     TypeParamLoweringMode::Variable => {\n-                        Substs::bound_vars(&generics, self.in_binders)\n+                        Substitution::bound_vars(&generics, self.in_binders)\n                     }\n                 };\n                 self.db.impl_self_ty(impl_id).subst(&substs)\n@@ -410,10 +410,10 @@ impl<'a> TyLoweringContext<'a> {\n                 let generics = generics(self.db.upcast(), adt.into());\n                 let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n-                        Substs::type_params_for_generics(self.db, &generics)\n+                        Substitution::type_params_for_generics(self.db, &generics)\n                     }\n                     TypeParamLoweringMode::Variable => {\n-                        Substs::bound_vars(&generics, self.in_binders)\n+                        Substitution::bound_vars(&generics, self.in_binders)\n                     }\n                 };\n                 self.db.ty(adt.into()).subst(&substs)\n@@ -464,7 +464,7 @@ impl<'a> TyLoweringContext<'a> {\n                             TypeParamLoweringMode::Placeholder => {\n                                 // if we're lowering to placeholders, we have to put\n                                 // them in now\n-                                let s = Substs::type_params(\n+                                let s = Substitution::type_params(\n                                     self.db,\n                                     self.resolver.generic_def().expect(\n                                         \"there should be generics if there's a generic param\",\n@@ -522,7 +522,7 @@ impl<'a> TyLoweringContext<'a> {\n         // special-case enum variants\n         resolved: ValueTyDefId,\n         infer_args: bool,\n-    ) -> Substs {\n+    ) -> Substitution {\n         let last = path.segments().last().expect(\"path should have at least one segment\");\n         let (segment, generic_def) = match resolved {\n             ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n@@ -553,7 +553,7 @@ impl<'a> TyLoweringContext<'a> {\n         segment: PathSegment<'_>,\n         def_generic: Option<GenericDefId>,\n         infer_args: bool,\n-    ) -> Substs {\n+    ) -> Substitution {\n         let mut substs = Vec::new();\n         let def_generics = def_generic.map(|def| generics(self.db.upcast(), def));\n \n@@ -601,7 +601,7 @@ impl<'a> TyLoweringContext<'a> {\n \n                 for default_ty in defaults.iter().skip(substs.len()) {\n                     // each default can depend on the previous parameters\n-                    let substs_so_far = Substs(substs.clone().into());\n+                    let substs_so_far = Substitution(substs.clone().into());\n                     substs.push(default_ty.clone().subst(&substs_so_far));\n                 }\n             }\n@@ -614,7 +614,7 @@ impl<'a> TyLoweringContext<'a> {\n         }\n         assert_eq!(substs.len(), total_len);\n \n-        Substs(substs.into())\n+        Substitution(substs.into())\n     }\n \n     fn lower_trait_ref_from_path(\n@@ -656,7 +656,11 @@ impl<'a> TyLoweringContext<'a> {\n         self.lower_trait_ref_from_path(path, explicit_self_ty)\n     }\n \n-    fn trait_ref_substs_from_path(&self, segment: PathSegment<'_>, resolved: TraitId) -> Substs {\n+    fn trait_ref_substs_from_path(\n+        &self,\n+        segment: PathSegment<'_>,\n+        resolved: TraitId,\n+    ) -> Substitution {\n         self.substs_from_path_segment(segment, Some(resolved.into()), false)\n     }\n \n@@ -817,7 +821,7 @@ pub fn associated_type_shorthand_candidates<R>(\n                 {\n                     let trait_ref = TraitRef {\n                         trait_: trait_id,\n-                        substs: Substs::bound_vars(&generics, DebruijnIndex::INNERMOST),\n+                        substs: Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST),\n                     };\n                     traits_.push(trait_ref);\n                 }\n@@ -945,7 +949,7 @@ pub(crate) fn trait_environment_query(\n         // function default implementations (and hypothetical code\n         // inside consts or type aliases)\n         cov_mark::hit!(trait_self_implements_self);\n-        let substs = Substs::type_params(db, trait_id);\n+        let substs = Substitution::type_params(db, trait_id);\n         let trait_ref = TraitRef { trait_: trait_id, substs };\n         let pred = GenericPredicate::Implemented(trait_ref);\n         let program_clause: chalk_ir::ProgramClause<Interner> =\n@@ -1033,7 +1037,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n /// function body.\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n-    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(\n         substs.len(),\n         TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(&Interner),\n@@ -1078,7 +1082,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n         return type_for_adt(db, def.into());\n     }\n     let generics = generics(db.upcast(), def.into());\n-    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(\n         substs.len(),\n         TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(&Interner),\n@@ -1105,7 +1109,7 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n         return type_for_adt(db, def.parent.into());\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n-    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(\n         substs.len(),\n         TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(&Interner),\n@@ -1114,7 +1118,7 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), adt.into());\n-    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+    let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(substs.len(), Ty::adt_ty(adt, substs))\n }\n \n@@ -1126,7 +1130,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     if db.type_alias_data(t).is_extern {\n         Binders::new(0, TyKind::ForeignType(crate::to_foreign_def_id(t)).intern(&Interner))\n     } else {\n-        let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n+        let substs = Substitution::bound_vars(&generics, DebruijnIndex::INNERMOST);\n         let type_ref = &db.type_alias_data(t).type_ref;\n         let inner = ctx.lower_ty(type_ref.as_ref().unwrap_or(&TypeRef::Error));\n         Binders::new(substs.len(), inner)"}, {"sha": "943d3339b3494e75f3eb431f7cbec74a98c5973c", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     primitive::{self, FloatTy, IntTy, UintTy},\n     utils::all_super_traits,\n     AdtId, Canonical, DebruijnIndex, FnPointer, FnSig, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n+    Scalar, Substitution, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -672,10 +672,10 @@ pub(crate) fn inherent_impl_substs(\n     db: &dyn HirDatabase,\n     impl_id: ImplId,\n     self_ty: &Canonical<Ty>,\n-) -> Option<Substs> {\n+) -> Option<Substitution> {\n     // we create a var for each type parameter of the impl; we need to keep in\n     // mind here that `self_ty` might have vars of its own\n-    let vars = Substs::build_for_def(db, impl_id)\n+    let vars = Substitution::build_for_def(db, impl_id)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.kinds.len())\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n@@ -693,7 +693,7 @@ pub(crate) fn inherent_impl_substs(\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n /// num_vars_to_keep) by `TyKind::Unknown`.\n-fn fallback_bound_vars(s: Substs, num_vars_to_keep: usize) -> Substs {\n+fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution {\n     s.fold_binders(\n         &mut |ty, binders| {\n             if let TyKind::BoundVar(bound) = ty.interned(&Interner) {\n@@ -716,13 +716,13 @@ fn transform_receiver_ty(\n     self_ty: &Canonical<Ty>,\n ) -> Option<Ty> {\n     let substs = match function_id.lookup(db.upcast()).container {\n-        AssocContainerId::TraitId(_) => Substs::build_for_def(db, function_id)\n+        AssocContainerId::TraitId(_) => Substitution::build_for_def(db, function_id)\n             .push(self_ty.value.clone())\n             .fill_with_unknown()\n             .build(),\n         AssocContainerId::ImplId(impl_id) => {\n             let impl_substs = inherent_impl_substs(db, impl_id, &self_ty)?;\n-            Substs::build_for_def(db, function_id)\n+            Substitution::build_for_def(db, function_id)\n                 .use_parent_substs(&impl_substs)\n                 .fill_with_unknown()\n                 .build()\n@@ -768,7 +768,7 @@ fn generic_implements_goal(\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::Obligation>> {\n     let mut kinds = self_ty.kinds.to_vec();\n-    let substs = super::Substs::build_for_def(db, trait_)\n+    let substs = super::Substitution::build_for_def(db, trait_)\n         .push(self_ty.value)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();"}, {"sha": "40eb1034ecfb3b2fe663bf962d0994b72764afb3", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -8,7 +8,7 @@ use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n use hir_def::{lang_item::LangItemTarget, TraitId};\n use stdx::panic_context;\n \n-use crate::{db::HirDatabase, DebruijnIndex, Substs};\n+use crate::{db::HirDatabase, DebruijnIndex, Substitution};\n \n use super::{\n     Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TyKind, TypeWalk,\n@@ -252,7 +252,7 @@ fn solution_from_chalk(\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct SolutionVariables(pub Canonical<Substs>);\n+pub struct SolutionVariables(pub Canonical<Substitution>);\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n /// A (possible) solution for a proposed goal."}, {"sha": "bef6e7e9c01cf16c87640bdb291ee24e45db1649", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     to_assoc_type_id,\n     utils::generics,\n     BoundVar, CallableDefId, CallableSig, DebruijnIndex, FnDefId, GenericPredicate,\n-    ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TyKind,\n+    ProjectionPredicate, ProjectionTy, Substitution, TraitRef, Ty, TyKind,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,\n@@ -221,7 +221,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     let impl_bound = GenericPredicate::Implemented(TraitRef {\n                         trait_: future_trait,\n                         // Self type as the first parameter.\n-                        substs: Substs::single(\n+                        substs: Substitution::single(\n                             TyKind::BoundVar(BoundVar {\n                                 debruijn: DebruijnIndex::INNERMOST,\n                                 index: 0,\n@@ -236,7 +236,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                         projection_ty: ProjectionTy {\n                             associated_ty_id: to_assoc_type_id(future_output),\n                             // Self type as the first parameter.\n-                            substitution: Substs::single(\n+                            substitution: Substitution::single(\n                                 TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n                                     .intern(&Interner),\n                             ),\n@@ -313,7 +313,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Substitution<Interner> {\n-        Substs::empty().to_chalk(self.db)\n+        Substitution::empty().to_chalk(self.db)\n     }\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n@@ -392,7 +392,7 @@ pub(crate) fn associated_ty_data_query(\n     // Lower bounds -- we could/should maybe move this to a separate query in `lower`\n     let type_alias_data = db.type_alias_data(type_alias);\n     let generic_params = generics(db.upcast(), type_alias.into());\n-    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n@@ -427,7 +427,7 @@ pub(crate) fn trait_datum_query(\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n     let generic_params = generics(db.upcast(), trait_.into());\n-    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let flags = rust_ir::TraitFlags {\n         auto: trait_data.is_auto,\n         upstream: trait_.lookup(db.upcast()).container.krate() != krate,\n@@ -496,7 +496,7 @@ pub(crate) fn struct_datum_query(\n     let upstream = adt_id.module(db.upcast()).krate() != krate;\n     let where_clauses = {\n         let generic_params = generics(db.upcast(), adt_id.into());\n-        let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+        let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n         convert_where_clauses(db, adt_id.into(), &bound_vars)\n     };\n     let flags = rust_ir::AdtFlags {\n@@ -545,7 +545,7 @@ fn impl_def_datum(\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db.upcast(), impl_id.into());\n-    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let trait_ = trait_ref.trait_;\n     let impl_type = if impl_id.lookup(db.upcast()).container.krate() == krate {\n         rust_ir::ImplType::Local\n@@ -635,7 +635,7 @@ pub(crate) fn fn_def_datum_query(\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n     let sig = db.callable_item_signature(callable_def);\n-    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let bound_vars = Substitution::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n     let bound = rust_ir::FnDefDatumBound {\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway"}, {"sha": "524814f4331462798c14d983e13affefd495e450", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2cae45b5242d59b744018dd79bc2ab74670edc/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=ce2cae45b5242d59b744018dd79bc2ab74670edc", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     primitive::UintTy,\n     traits::{Canonical, Obligation},\n     AliasTy, CallableDefId, FnPointer, GenericPredicate, InEnvironment, OpaqueTy,\n-    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitRef, Ty,\n+    ProjectionPredicate, ProjectionTy, Scalar, Substitution, TraitRef, Ty,\n };\n \n use super::interner::*;\n@@ -134,7 +134,7 @@ impl ToChalk for Ty {\n                 ..\n             }) => {\n                 assert_eq!(num_binders, 0);\n-                let substs: Substs = from_chalk(\n+                let substs: Substitution = from_chalk(\n                     db,\n                     substitution.0.shifted_out(&Interner).expect(\"fn ptr should have no binders\"),\n                 );\n@@ -213,22 +213,25 @@ fn array_to_chalk(db: &dyn HirDatabase, ty: Ty) -> chalk_ir::Ty<Interner> {\n     chalk_ir::TyKind::Array(arg, const_).intern(&Interner)\n }\n \n-impl ToChalk for Substs {\n+impl ToChalk for Substitution {\n     type Chalk = chalk_ir::Substitution<Interner>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Substitution<Interner> {\n         chalk_ir::Substitution::from_iter(&Interner, self.iter().map(|ty| ty.clone().to_chalk(db)))\n     }\n \n-    fn from_chalk(db: &dyn HirDatabase, parameters: chalk_ir::Substitution<Interner>) -> Substs {\n+    fn from_chalk(\n+        db: &dyn HirDatabase,\n+        parameters: chalk_ir::Substitution<Interner>,\n+    ) -> Substitution {\n         let tys = parameters\n             .iter(&Interner)\n             .map(|p| match p.ty(&Interner) {\n                 Some(ty) => from_chalk(db, ty.clone()),\n                 None => unimplemented!(),\n             })\n             .collect();\n-        Substs(tys)\n+        Substitution(tys)\n     }\n }\n \n@@ -489,7 +492,7 @@ where\n pub(super) fn convert_where_clauses(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n-    substs: &Substs,\n+    substs: &Substitution,\n ) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());"}]}