{"sha": "0504d7e57bf536dabbb738b5b0d268a266d30659", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MDRkN2U1N2JmNTM2ZGFiYmI3MzhiNWIwZDI2OGEyNjZkMzA2NTk=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-02T16:34:00Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-02T21:20:57Z"}, "message": "std: Speed up str::is_utf8\n\nUse unchecked vec indexing since the vector bounds are checked by the\nloop. Iterators are not easy to use in this case since we skip 1-4 bytes\neach lap. This part of the commit speeds up is_utf8 for ASCII input.\n\nCheck codepoint ranges by checking the byte ranges manually instead of\ncomputing a full decoding for multibyte encodings. This is easy to read\nand corresponds to the UTF-8 syntax in the RFC.\n\nNo changes to what we accept. A comment notes that surrogate halves are\naccepted.\n\nBefore:\n\n\ttest str::bench::is_utf8_100_ascii ... bench: 165 ns/iter (+/- 3)\n\ttest str::bench::is_utf8_100_multibyte ... bench: 218 ns/iter (+/- 5)\n\nAfter:\n\ttest str::bench::is_utf8_100_ascii ... bench: 130 ns/iter (+/- 1)\n\ttest str::bench::is_utf8_100_multibyte ... bench: 156 ns/iter (+/- 3)", "tree": {"sha": "b5beb1a13b3840166b1167fc8699aa7d55dd614a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5beb1a13b3840166b1167fc8699aa7d55dd614a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0504d7e57bf536dabbb738b5b0d268a266d30659", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0504d7e57bf536dabbb738b5b0d268a266d30659", "html_url": "https://github.com/rust-lang/rust/commit/0504d7e57bf536dabbb738b5b0d268a266d30659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0504d7e57bf536dabbb738b5b0d268a266d30659/comments", "author": null, "committer": null, "parents": [{"sha": "2460170e6aea8dd7aa3e316456047baf18f2f680", "url": "https://api.github.com/repos/rust-lang/rust/commits/2460170e6aea8dd7aa3e316456047baf18f2f680", "html_url": "https://github.com/rust-lang/rust/commit/2460170e6aea8dd7aa3e316456047baf18f2f680"}], "stats": {"total": 102, "additions": 67, "deletions": 35}, "files": [{"sha": "4acece782844769d2616e7b029e870a0fa039315", "filename": "src/libstd/str.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0504d7e57bf536dabbb738b5b0d268a266d30659/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0504d7e57bf536dabbb738b5b0d268a266d30659/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0504d7e57bf536dabbb738b5b0d268a266d30659", "patch": "@@ -564,51 +564,63 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n Section: Misc\n */\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte(\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n-)\n-\n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte(\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n-)\n-\n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n     let total = v.len();\n+    fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+        unsafe { *xs.unsafe_ref(i) }\n+    }\n     while i < total {\n-        if v[i] < 128u8 {\n+        let v_i = unsafe_get(v, i);\n+        if v_i < 128u8 {\n             i += 1u;\n         } else {\n-            let w = utf8_char_width(v[i]);\n+            let w = utf8_char_width(v_i);\n             if w == 0u { return false; }\n \n             let nexti = i + w;\n             if nexti > total { return false; }\n-            // 1. Make sure the correct number of continuation bytes are present\n-            // 2. Check codepoint ranges (deny overlong encodings)\n-            //    2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n-            //    3-byte encoding is for codepoints  \\u0800 to  \\uffff\n-            //    4-byte encoding is for codepoints \\u10000 to \\u10ffff\n-\n-            //    2-byte encodings are correct if the width and continuation match up\n-            if v[i + 1] & 192u8 != TAG_CONT_U8 { return false; }\n-            if w > 2 {\n-                let mut ch;\n-                ch = utf8_first_byte!(v[i], w);\n-                ch = utf8_acc_cont_byte!(ch, v[i + 1]);\n-                if v[i + 2] & 192u8 != TAG_CONT_U8 { return false; }\n-                ch = utf8_acc_cont_byte!(ch, v[i + 2]);\n-                if w == 3 && ch < MAX_TWO_B { return false; }\n-                if w > 3 {\n-                    if v[i + 3] & 192u8 != TAG_CONT_U8 { return false; }\n-                    ch = utf8_acc_cont_byte!(ch, v[i + 3]);\n-                    if ch < MAX_THREE_B || ch >= MAX_UNICODE { return false; }\n-                }\n+\n+            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //        first  E0 A0 80     last EF BF BF\n+            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            // UTF8-tail   = %x80-BF\n+            // --\n+            // This code allows surrogate pairs: \\uD800 to \\uDFFF -> ED A0 80 to ED BF BF\n+            match w {\n+                2 => if unsafe_get(v, i + 1) & 192u8 != TAG_CONT_U8 {\n+                    return false\n+                },\n+                3 => match (v_i,\n+                            unsafe_get(v, i + 1),\n+                            unsafe_get(v, i + 2) & 192u8) {\n+                    (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) => (),\n+                    (0xE1 .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n+                    _ => return false,\n+                },\n+                _ => match (v_i,\n+                            unsafe_get(v, i + 1),\n+                            unsafe_get(v, i + 2) & 192u8,\n+                            unsafe_get(v, i + 3) & 192u8) {\n+                    (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n+                    (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n+                    (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => (),\n+                    _ => return false,\n+                },\n             }\n \n             i = nexti;\n@@ -756,6 +768,18 @@ pub struct CharRange {\n     next: uint\n }\n \n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n+)\n+\n // UTF-8 tags and ranges\n priv static TAG_CONT_U8: u8 = 128u8;\n priv static TAG_CONT: uint = 128u;\n@@ -2833,13 +2857,21 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_utf8_deny_overlong() {\n+    fn test_is_utf8() {\n         assert!(!is_utf8([0xc0, 0x80]));\n         assert!(!is_utf8([0xc0, 0xae]));\n         assert!(!is_utf8([0xe0, 0x80, 0x80]));\n         assert!(!is_utf8([0xe0, 0x80, 0xaf]));\n         assert!(!is_utf8([0xe0, 0x81, 0x81]));\n         assert!(!is_utf8([0xf0, 0x82, 0x82, 0xac]));\n+        assert!(!is_utf8([0xf4, 0x90, 0x80, 0x80]));\n+\n+        assert!(is_utf8([0xC2, 0x80]));\n+        assert!(is_utf8([0xDF, 0xBF]));\n+        assert!(is_utf8([0xE0, 0xA0, 0x80]));\n+        assert!(is_utf8([0xEF, 0xBF, 0xBF]));\n+        assert!(is_utf8([0xF0, 0x90, 0x80, 0x80]));\n+        assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n "}]}