{"sha": "7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNTAwZmMwYTAzNTRhYjcyZjBkNzZjY2FlNmZhZThjMmVlNWU2MmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-29T02:31:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-29T02:48:33Z"}, "message": "Replace common::new_seq_hash with an adapter around std::smallintmap\n\nIt would be better to either convert ast_map to use smallintmap or make\nsmallintmap and hashmap follow the same interface, but I don't feel up to\nit just now. Closes #585.", "tree": {"sha": "52ed9be9d81c70d04344713ea4caefba9789aa32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52ed9be9d81c70d04344713ea4caefba9789aa32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d", "html_url": "https://github.com/rust-lang/rust/commit/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b5d34aa9ac5c82e08c82b6e865c3b697299f65d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5d34aa9ac5c82e08c82b6e865c3b697299f65d", "html_url": "https://github.com/rust-lang/rust/commit/7b5d34aa9ac5c82e08c82b6e865c3b697299f65d"}], "stats": {"total": 172, "additions": 69, "deletions": 103}, "files": [{"sha": "eeee41493458ec76d78120f339e3444e91e06233", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d", "patch": "@@ -1,3 +1,5 @@\n+import std::smallintmap;\n+import std::option;\n import front::ast::*;\n import visit::vt;\n \n@@ -11,7 +13,10 @@ tag ast_node {\n type map = std::map::hashmap[node_id, ast_node];\n \n fn map_crate(&crate c) -> map {\n-    auto map = util::common::new_seq_int_hash[ast_node]();\n+    // FIXME: This is using an adapter to convert the smallintmap\n+    // interface to the hashmap interface. It would be better to just\n+    // convert everything to use the smallintmap.\n+    auto map = new_smallintmap_int_adapter[ast_node]();\n \n     auto v_map = @rec(visit_item=bind map_item(map, _, _, _),\n                       visit_native_item=bind map_native_item(map, _, _, _),\n@@ -42,6 +47,69 @@ fn map_expr(&map map, &@expr ex, &() e, &vt[()] v) {\n     visit::visit_expr(ex, e, v);\n }\n \n+fn new_smallintmap_int_adapter[V]() -> std::map::hashmap[int, V] {\n+    auto key_idx = fn(&int key) -> uint { key as uint };\n+    auto idx_key = fn(&uint idx) -> int { idx as int };\n+    ret new_smallintmap_adapter(key_idx, idx_key);\n+}\n+\n+// This creates an object with the hashmap interface backed\n+// by the smallintmap type, because I don't want to go through\n+// the entire codebase adapting all the callsites to the different\n+// interface.\n+// FIXME: hashmap and smallintmap should support the same interface.\n+fn new_smallintmap_adapter[K, V](fn(&K) -> uint key_idx,\n+                                 fn(&uint) -> K idx_key)\n+    -> std::map::hashmap[K, V] {\n+\n+    obj adapter[K, V](smallintmap::smallintmap[V] map,\n+                      fn(&K) -> uint key_idx,\n+                      fn(&uint) -> K idx_key) {\n+\n+        fn size() -> uint { fail }\n+\n+        fn insert(&K key, &V value) -> bool {\n+            auto exists = smallintmap::contains_key(map, key_idx(key));\n+            smallintmap::insert(map, key_idx(key), value);\n+            ret !exists;\n+        }\n+\n+        fn contains_key(&K key) -> bool {\n+            ret smallintmap::contains_key(map, key_idx(key));\n+        }\n+\n+        fn get(&K key) -> V {\n+            ret smallintmap::get(map, key_idx(key));\n+        }\n+\n+        fn find(&K key) -> option::t[V] {\n+            ret smallintmap::find(map, key_idx(key));\n+        }\n+\n+        fn remove(&K key) -> option::t[V] { fail }\n+\n+        fn rehash() { fail }\n+\n+        iter items() -> @tup(K, V) {\n+            auto idx = 0u;\n+            for (option::t[V] item in map.v) {\n+                alt (item) {\n+                    case (option::some(?elt)) {\n+                        auto value = elt;\n+                        auto key = idx_key(idx);\n+                        put @tup(key, value);\n+                    }\n+                    case (option::none) { }\n+                }\n+                idx += 1u;\n+            }\n+        }\n+    }\n+\n+    auto map = smallintmap::mk[V]();\n+    ret adapter(map, key_idx, idx_key);\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "302eec6f52c6131a2e995074002e4b836b8a5277", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=7c500fc0a0354ab72f0d76ccae6fae8c2ee5e62d", "patch": "@@ -105,108 +105,6 @@ fn new_uint_hash[V]() -> std::map::hashmap[uint, V] {\n     ret std::map::mk_hashmap[uint, V](hasher, eqer);\n }\n \n-fn new_seq_hash[K, V](fn(&K) -> uint key_idx,\n-                      fn(&uint) -> K idx_key) -> std::map::hashmap[K, V] {\n-    fn ensure_size[V](&mutable vec[mutable option::t[V]] bkts, uint idx) {\n-        auto bkt_len = vec::len(bkts);\n-        if (idx >= bkt_len) {\n-            auto needed = idx - bkt_len + 1u;\n-            auto new = vec::init_elt_mut(option::none[V], needed);\n-            bkts += new;\n-        }\n-    }\n-\n-    obj seq_hash[K, V](mutable uint nelts,\n-                       mutable vec[mutable option::t[V]] bkts,\n-                       fn(&K) -> uint key_idx,\n-                       fn(&uint) -> K idx_key) {\n-\n-        fn size() -> uint { nelts }\n-\n-        fn insert(&K key, &V value) -> bool {\n-            auto idx = key_idx(key);\n-            ensure_size(bkts, idx);\n-            if (option::is_some(bkts.(idx))) {\n-                bkts.(idx) = option::some(value);\n-                ret false;\n-            } else {\n-                bkts.(idx) = option::some(value);\n-                nelts += 1u;\n-                ret true;\n-            }\n-        }\n-\n-        fn contains_key(&K key) -> bool {\n-            auto idx = key_idx(key);\n-            ensure_size(bkts, idx);\n-            if (option::is_some(bkts.(idx))) {\n-                ret true;\n-            } else {\n-                ret false;\n-            }\n-        }\n-\n-        fn get(&K key) -> V {\n-            ret alt (self.find(key)) {\n-                case (option::some(?v)) { v }\n-                case (_) { fail }\n-            };\n-        }\n-\n-        fn find(&K key) -> option::t[V] {\n-            auto idx = key_idx(key);\n-            ensure_size(bkts, idx);\n-            ret bkts.(idx);\n-        }\n-\n-        fn remove(&K key) -> option::t[V] {\n-            auto idx = key_idx(key);\n-            ensure_size(bkts, idx);\n-            auto val = bkts.(idx);\n-            if (option::is_some(val)) {\n-                bkts.(idx) = option::none;\n-                nelts -= 1u;\n-            }\n-            ret val;\n-        }\n-\n-        fn rehash() { }\n-\n-        iter items() -> @tup(K, V) {\n-            auto idx = 0u;\n-            auto bktsize = vec::len(bkts);\n-            while (idx < bktsize) {\n-                alt (bkts.(idx)) {\n-                    case (option::some(?v)) {\n-                        // FIXME: Appease alias analysis\n-                        auto value = v;\n-                        put @tup(idx_key(idx), value);\n-                    }\n-                    case (_) { }\n-                }\n-                idx += 1u;\n-            }\n-        }\n-    }\n-\n-    let vec[mutable option::t[V]] bkts = [mutable];\n-    ret seq_hash[K, V](0u, bkts, key_idx, idx_key);\n-}\n-\n-// A specialized map for keys that are sequential ints\n-fn new_seq_int_hash[V]() -> std::map::hashmap[int, V] {\n-    auto key_idx = fn(&int key) -> uint { key as uint };\n-    auto idx_key = fn(&uint idx) -> int { idx as int };\n-    ret new_seq_hash(key_idx, idx_key);\n-}\n-\n-// A specialized map for keys that are sequential uints\n-fn new_seq_uint_hash[V]() -> std::map::hashmap[uint, V] {\n-    auto key_idx = fn(&uint key) -> uint { key };\n-    auto idx_key = fn(&uint idx) -> uint { idx };\n-    ret new_seq_hash(key_idx, idx_key);\n-}\n-\n fn istr(int i) -> str { ret int::to_str(i, 10u); }\n \n fn uistr(uint i) -> str { ret uint::to_str(i, 10u); }"}]}