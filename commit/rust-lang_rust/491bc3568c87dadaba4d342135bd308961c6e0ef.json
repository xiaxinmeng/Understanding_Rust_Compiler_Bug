{"sha": "491bc3568c87dadaba4d342135bd308961c6e0ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MWJjMzU2OGM4N2RhZGFiYTRkMzQyMTM1YmQzMDg5NjFjNmUwZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T20:36:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-25T20:36:14Z"}, "message": "auto merge of #8745 : brson/rust/metadata, r=cmr\n\nThis does two things: 1) stops compressing metadata, 2) stops copying the metadata section, instead holding a reference to the buffer returned by the LLVM section iterator.\r\n\r\nNot compressing metadata requires something like 7x the storage space, but makes running tests about 9% faster. This has been a time improvement on all platforms I've tested, including windows. I considered leaving compression as an option but it doesn't seem to be worth the complexity since we don't currently have any use cases where we need to save that space.\r\n\r\nIn order to avoid copying the metadata section I had to hack up extra::ebml a bit to support unsafe buffers. We should probably move it into librustc so that it can evolve to support the compiler without worrying about having a crummy interface.\r\n\r\nr? @graydon", "tree": {"sha": "d3d99d9c97e2de40a5f16cd0c2ca9feee9cdf891", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3d99d9c97e2de40a5f16cd0c2ca9feee9cdf891"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/491bc3568c87dadaba4d342135bd308961c6e0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/491bc3568c87dadaba4d342135bd308961c6e0ef", "html_url": "https://github.com/rust-lang/rust/commit/491bc3568c87dadaba4d342135bd308961c6e0ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/491bc3568c87dadaba4d342135bd308961c6e0ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05f1bbba16912f63b562a7847801823872f89ec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/05f1bbba16912f63b562a7847801823872f89ec6", "html_url": "https://github.com/rust-lang/rust/commit/05f1bbba16912f63b562a7847801823872f89ec6"}, {"sha": "022f188a08b11234b2a5fbce3484d233625371c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/022f188a08b11234b2a5fbce3484d233625371c1", "html_url": "https://github.com/rust-lang/rust/commit/022f188a08b11234b2a5fbce3484d233625371c1"}], "stats": {"total": 223, "additions": 133, "deletions": 90}, "files": [{"sha": "ed3042a1e71d70e156919e950369f3066920da87", "filename": "configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/configure", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -381,7 +381,8 @@ opt mingw-cross 0 \"cross-compile for win32 using mingw\"\n opt clang 0 \"prefer clang to gcc for building the runtime\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n-opt pax-flags 0 \"apply PaX flags to rustc binaries (required for GRSecurity/PaX-patched kernels)\"\n+opt pax-flags 0 \"apply PaX flags to rustc binaries (required for GRSecurity/PaX-patched\n+ kernels)\"\n valopt prefix \"/usr/local\" \"set installation prefix\"\n valopt local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt llvm-root \"\" \"set LLVM root\""}, {"sha": "560bcccae8056acd535a52a52913a0b8cc6d48b4", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -12,6 +12,8 @@\n \n \n use std::str;\n+use std::cast;\n+use std::vec;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n@@ -29,9 +31,42 @@ struct EbmlState {\n     data_pos: uint,\n }\n \n+#[deriving(Clone)]\n+pub enum EbmlData {\n+    SafeData(@~[u8]),\n+    UnsafeData(*u8, uint)\n+}\n+\n+impl EbmlData {\n+    #[inline]\n+    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [u8] {\n+        match *self {\n+            SafeData(@ref v) => v.slice(start, end),\n+            UnsafeData(buf, len) => unsafe {\n+                do vec::raw::buf_as_slice(buf, len) |s| {\n+                    cast::transmute(s.slice(start, end))\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        self.slice(0, self.len())\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> uint {\n+        match *self {\n+            SafeData(@ref v) => v.len(),\n+            UnsafeData(_, len) => len\n+        }\n+    }\n+}\n+\n #[deriving(Clone)]\n pub struct Doc {\n-    data: @~[u8],\n+    data: EbmlData,\n     start: uint,\n     end: uint,\n }\n@@ -185,24 +220,28 @@ pub mod reader {\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {\n-        Doc { data: data, start: 0u, end: data.len() }\n+        Doc { data: SafeData(data), start: 0u, end: data.len() }\n+    }\n+\n+    pub fn unsafe_Doc(buf: *u8, len: uint) -> Doc {\n+        Doc { data: UnsafeData(buf, len), start: 0u, end: len }\n     }\n \n-    pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n-        let elt_tag = vuint_at(*data, start);\n-        let elt_size = vuint_at(*data, elt_tag.next);\n+    pub fn doc_at(data: &EbmlData, start: uint) -> TaggedDoc {\n+        let elt_tag = vuint_at(data.as_slice(), start);\n+        let elt_size = vuint_at(data.as_slice(), elt_tag.next);\n         let end = elt_size.next + elt_size.val;\n         TaggedDoc {\n             tag: elt_tag.val,\n-            doc: Doc { data: data, start: elt_size.next, end: end }\n+            doc: Doc { data: data.clone(), start: elt_size.next, end: end }\n         }\n     }\n \n     pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data.as_slice(), pos);\n+            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -225,8 +264,8 @@ pub mod reader {\n     pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data.as_slice(), pos);\n+            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -239,8 +278,8 @@ pub mod reader {\n     pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data.as_slice(), pos);\n+            let elt_size = vuint_at(d.data.as_slice(), elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -260,22 +299,22 @@ pub mod reader {\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1u);\n-        (*d.data)[d.start]\n+        d.data.as_slice()[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+        io::u64_from_be_bytes(d.data.as_slice(), d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+        io::u64_from_be_bytes(d.data.as_slice(), d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        io::u64_from_be_bytes(*d.data, d.start, 8u)\n+        io::u64_from_be_bytes(d.data.as_slice(), d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -298,8 +337,7 @@ pub mod reader {\n     impl Decoder {\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    doc_at(self.parent.data, self.pos);\n+                let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(&self.parent.data, self.pos);\n \n                 if r_tag == (EsLabel as uint) {\n                     self.pos = r_doc.end;\n@@ -316,8 +354,7 @@ pub mod reader {\n             if self.pos >= self.parent.end {\n                 fail!(\"no more documents in current node!\");\n             }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(&self.parent.data, self.pos);\n             debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                    self.parent.start,\n                    self.parent.end,"}, {"sha": "1771a11adef139ed23cdeb366b9fff87b76a7e88", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -763,7 +763,7 @@ pub fn build_session_options(binary: @str,\n         parse_only: parse_only,\n         no_trans: no_trans,\n         debugging_opts: debugging_opts,\n-        android_cross_path: android_cross_path\n+        android_cross_path: android_cross_path,\n     };\n     return sopts;\n }"}, {"sha": "f43c089d331eb256299153bfba00c128a07890fb", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -15,6 +15,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n+use metadata::loader::MetadataSection;\n \n use std::hashmap::HashMap;\n use syntax::ast;\n@@ -308,7 +309,7 @@ fn resolve_crate(e: @mut Env,\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: @mut Env, cdata: MetadataSection) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "bc6b3d30d4325ff35096514cc86cadc2d7f25f34", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -188,7 +188,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                       def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+    let all_items = reader::get_doc(decoder::section_to_ebml_doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "4150894e1d2b7b975adb22554cc29f80e665e814", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -15,6 +15,7 @@\n \n use metadata::cstore;\n use metadata::decoder;\n+use metadata::loader::MetadataSection;\n \n use std::hashmap::HashMap;\n use extra;\n@@ -29,7 +30,7 @@ pub type cnum_map = @mut HashMap<ast::CrateNum, ast::CrateNum>;\n \n pub struct crate_metadata {\n     name: @str,\n-    data: @~[u8],\n+    data: MetadataSection,\n     cnum_map: cnum_map,\n     cnum: ast::CrateNum\n }"}, {"sha": "f3476a9963d0cca7aec912812dfc24cd2c56af10", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -20,6 +20,7 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n+use metadata::loader::{MetadataSection, UnsafeSection};\n use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n@@ -56,16 +57,16 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n-    let tagged_doc = reader::doc_at(d.data, pos);\n+    let pos = io::u64_from_be_bytes(d.data.as_slice(), hash_pos, 4) as uint;\n+    let tagged_doc = reader::doc_at(&d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        let pos = io::u64_from_be_bytes(elt.data.as_slice(), elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n-            ret = Some(reader::doc_at(d.data, pos).doc);\n+            ret = Some(reader::doc_at(&d.data, pos).doc);\n             false\n         } else {\n             true\n@@ -96,8 +97,8 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n-    let items = reader::get_doc(reader::Doc(data), tag_items);\n+fn lookup_item(item_id: int, data: MetadataSection) -> ebml::Doc {\n+    let items = reader::get_doc(section_to_ebml_doc(data), tag_items);\n     find_item(item_id, items)\n }\n \n@@ -215,13 +216,13 @@ fn variant_disr_val(d: ebml::Doc) -> Option<uint> {\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+    parse_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n-    parse_bare_fn_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+    parse_bare_fn_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n@@ -230,7 +231,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            cdata: cmd) -> Option<ty::t>\n {\n     do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n-        parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+        parse_ty_data(tp.data.as_slice(), cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n     }\n }\n@@ -241,7 +242,7 @@ pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n-    parse_trait_ref_data(*doc.data, cdata.cnum, doc.start, tcx,\n+    parse_trait_ref_data(doc.data.as_slice(), cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n@@ -256,7 +257,7 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n     let mut bounds = ~[];\n     do reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n-            *p.data, p.start, cdata.cnum, tcx,\n+            p.data.as_slice(), p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n         true\n@@ -359,7 +360,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::def_id) ->\n+pub fn lookup_def(cnum: ast::CrateNum, data: MetadataSection, did_: ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let did = ast::def_id { crate: cnum, node: did_.node };\n@@ -418,7 +419,7 @@ pub fn get_region_param(cdata: cmd, id: ast::NodeId)\n     return item_ty_region_param(item);\n }\n \n-pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n+pub fn get_type_param_count(data: MetadataSection, id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n@@ -449,7 +450,7 @@ pub fn get_impl_vtables(cdata: cmd,\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                        name: ast::ident) -> Option<ast::def_id> {\n-    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+    let items = reader::get_doc(section_to_ebml_doc(cdata.data), tag_items);\n     let mut found = None;\n     do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n@@ -461,7 +462,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n     found\n }\n \n-pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n+pub fn get_symbol(data: MetadataSection, id: ast::NodeId) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -482,7 +483,7 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n-    let root = reader::Doc(cdata.data);\n+    let root = section_to_ebml_doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -577,10 +578,10 @@ impl<'self> EachItemContext<'self> {\n     fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n         // This item might not be in this crate. If it's not, look it up.\n         let items = if def_id.crate == self.cdata.cnum {\n-            reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n+            reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n         } else {\n             let crate_data = (self.get_crate_data)(def_id.crate);\n-            let root = reader::Doc(crate_data.data);\n+            let root = section_to_ebml_doc(crate_data.data);\n             reader::get_doc(root, tag_items)\n         };\n \n@@ -606,10 +607,10 @@ impl<'self> EachItemContext<'self> {\n             // a reexport.\n             let other_crates_items = if child_def_id.crate ==\n                     self.cdata.cnum {\n-                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n+                reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n             } else {\n                 let crate_data = (self.get_crate_data)(child_def_id.crate);\n-                let root = reader::Doc(crate_data.data);\n+                let root = section_to_ebml_doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n@@ -673,10 +674,10 @@ impl<'self> EachItemContext<'self> {\n \n             // This reexport may be in yet another crate.\n             let other_crates_items = if def_id.crate == self.cdata.cnum {\n-                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n+                reader::get_doc(section_to_ebml_doc(self.cdata.data), tag_items)\n             } else {\n                 let crate_data = (self.get_crate_data)(def_id.crate);\n-                let root = reader::Doc(crate_data.data);\n+                let root = section_to_ebml_doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n@@ -708,7 +709,7 @@ pub fn each_path(intr: @ident_interner,\n     // make fast. It's the source of most of the performance problems when\n     // compiling small crates.\n \n-    let root_doc = reader::Doc(cdata.data);\n+    let root_doc = section_to_ebml_doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -768,7 +769,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n-    let items = reader::get_doc(reader::Doc(data), tag_items);\n+    let items = reader::get_doc(section_to_ebml_doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[@ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -1206,8 +1207,14 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     out.write_str(\"\\n\\n\");\n }\n \n-pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n-    return get_attributes(reader::Doc(data));\n+pub fn get_crate_attributes(data: MetadataSection) -> ~[ast::Attribute] {\n+    return get_attributes(section_to_ebml_doc(data));\n+}\n+\n+pub fn section_to_ebml_doc(data: MetadataSection) -> ebml::Doc {\n+    match data {\n+        UnsafeSection(_, buf, len) => reader::unsafe_Doc(buf, len)\n+    }\n }\n \n #[deriving(Clone)]\n@@ -1218,9 +1225,9 @@ pub struct crate_dep {\n     hash: @str\n }\n \n-pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n+pub fn get_crate_deps(data: MetadataSection) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = reader::Doc(data);\n+    let cratedoc = section_to_ebml_doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n@@ -1238,7 +1245,7 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n+fn list_crate_deps(data: MetadataSection, out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n@@ -1251,13 +1258,13 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> @str {\n-    let cratedoc = reader::Doc(data);\n+pub fn get_crate_hash(data: MetadataSection) -> @str {\n+    let cratedoc = section_to_ebml_doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     hashdoc.as_str_slice().to_managed()\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> @str {\n+pub fn get_crate_vers(data: MetadataSection) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n@@ -1282,10 +1289,10 @@ fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n     };\n }\n \n-pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n+pub fn list_crate_metadata(intr: @ident_interner, bytes: MetadataSection,\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = reader::Doc(bytes);\n+    let md = section_to_ebml_doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(bytes, out);\n }\n@@ -1307,7 +1314,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n }\n \n pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n-    let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n+    let link_args = reader::get_doc(section_to_ebml_doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n     do reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n         result.push(arg_doc.as_str());"}, {"sha": "bd7442472fe40db3d0cf68f77d5a21103902594b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -26,7 +26,6 @@ use std::hashmap::{HashMap, HashSet};\n use std::io;\n use std::str;\n use std::vec;\n-use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n use syntax::abi::AbiSet;\n@@ -1570,7 +1569,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x75, //'u' as u8,\n       0x73, //'s' as u8,\n       0x74, //'t' as u8,\n-      0, 0, 0, 1 ];\n+      0, 0, 0, 2 ];\n \n pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     let wr = @io::BytesWriter::new();\n@@ -1683,8 +1682,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     let writer_bytes: &mut ~[u8] = wr.bytes;\n \n-    metadata_encoding_version.to_owned() +\n-        flate::deflate_bytes(*writer_bytes)\n+    return metadata_encoding_version.to_owned() + *writer_bytes;\n }\n \n // Get the encoded string for a type"}, {"sha": "182acc68b1ee56f9009203b0c0eaa91c6f660924", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -11,7 +11,7 @@\n //! Finds crate binaries and loads their metadata\n \n \n-use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n+use lib::llvm::{False, llvm, mk_object_file, mk_section_iter, ObjectFile};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::FileSearch;\n@@ -32,7 +32,6 @@ use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::ptr;\n use std::str;\n use std::vec;\n-use extra::flate;\n \n pub enum os {\n     os_macos,\n@@ -54,7 +53,14 @@ pub struct Context {\n     intr: @ident_interner\n }\n \n-pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n+#[deriving(Clone)]\n+pub enum MetadataSection {\n+    // A pointer to the object file metadata section, along with\n+    // the ObjectFile handle that keeps it from being destructed\n+    UnsafeSection(@ObjectFile, *u8, uint)\n+}\n+\n+pub fn load_library_crate(cx: &Context) -> (~str, MetadataSection) {\n     match find_library_crate(cx) {\n       Some(t) => t,\n       None => {\n@@ -65,7 +71,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     }\n }\n \n-fn find_library_crate(cx: &Context) -> Option<(~str, @~[u8])> {\n+fn find_library_crate(cx: &Context) -> Option<(~str, MetadataSection)> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n@@ -87,7 +93,7 @@ fn find_library_crate_aux(\n     cx: &Context,\n     (prefix, suffix): (~str, ~str),\n     filesearch: @filesearch::FileSearch\n-) -> Option<(~str, @~[u8])> {\n+) -> Option<(~str, MetadataSection)> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n     let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n@@ -171,7 +177,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n     }\n }\n \n-fn crate_matches(crate_data: @~[u8],\n+fn crate_matches(crate_data: MetadataSection,\n                  metas: &[@ast::MetaItem],\n                  hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n@@ -197,25 +203,24 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n }\n \n fn get_metadata_section(os: os,\n-                        filename: &Path) -> Option<@~[u8]> {\n+                        filename: &Path) -> Option<MetadataSection> {\n     unsafe {\n         let mb = do filename.with_c_str |buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         };\n-        if mb as int == 0 { return option::None::<@~[u8]>; }\n-        let of = match mk_object_file(mb) {\n+        if mb as int == 0 { return None; }\n+        let of = @match mk_object_file(mb) {\n             option::Some(of) => of,\n-            _ => return option::None::<@~[u8]>\n+            _ => return None\n         };\n-        let si = mk_section_iter(of.llof);\n+        let si = mk_section_iter((*of).llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n             debug!(\"get_metadata_section: name %s\", name);\n             if name == read_meta_section_name(os) {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-                let mut found = None;\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking %u bytes of metadata-version stamp\",\n@@ -229,19 +234,12 @@ fn get_metadata_section(os: os,\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n-                debug!(\"inflating %u bytes of compressed metadata\",\n-                       csz - vlen);\n-                do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n-                    let inflated = flate::inflate_bytes(bytes);\n-                    found = Some(@(inflated));\n-                }\n-                if found != None {\n-                    return found;\n-                }\n+\n+                return Some(UnsafeSection(of, cvbuf1, csz-vlen))\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return option::None::<@~[u8]>;\n+        return None;\n     }\n }\n "}, {"sha": "791be656d4bcb04de2413f41be269cc0a9710859", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491bc3568c87dadaba4d342135bd308961c6e0ef/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=491bc3568c87dadaba4d342135bd308961c6e0ef", "patch": "@@ -1022,7 +1022,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n         do self.read_opaque |_, doc| {\n             tydecode::parse_ty_data(\n-                *doc.data,\n+                doc.data.as_slice(),\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n@@ -1044,7 +1044,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n         return do self.read_opaque |this, doc| {\n             let ty = tydecode::parse_ty_data(\n-                *doc.data,\n+                doc.data.as_slice(),\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n@@ -1060,7 +1060,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n             for i in range(doc.start, doc.end) {\n-                str.push_char(doc.data[i] as char);\n+                str.push_char(doc.data.as_slice()[i] as char);\n             }\n             str\n         }\n@@ -1074,7 +1074,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                            -> ty::TypeParameterDef {\n         do self.read_opaque |this, doc| {\n             tydecode::parse_type_param_def_data(\n-                *doc.data,\n+                doc.data.as_slice(),\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,"}]}