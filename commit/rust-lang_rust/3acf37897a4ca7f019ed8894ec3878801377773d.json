{"sha": "3acf37897a4ca7f019ed8894ec3878801377773d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhY2YzNzg5N2E0Y2E3ZjAxOWVkODg5NGVjMzg3ODgwMTM3Nzc3M2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-19T10:01:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-19T10:01:28Z"}, "message": "auto merge of #6595 : bjz/rust/core-tuple, r=thestinger", "tree": {"sha": "fd06bde4d700526455b2f0214dec44c98d31bbb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd06bde4d700526455b2f0214dec44c98d31bbb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3acf37897a4ca7f019ed8894ec3878801377773d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3acf37897a4ca7f019ed8894ec3878801377773d", "html_url": "https://github.com/rust-lang/rust/commit/3acf37897a4ca7f019ed8894ec3878801377773d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3acf37897a4ca7f019ed8894ec3878801377773d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c7750ca640e2153892307510d6cce015b766bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c7750ca640e2153892307510d6cce015b766bd", "html_url": "https://github.com/rust-lang/rust/commit/99c7750ca640e2153892307510d6cce015b766bd"}, {"sha": "3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae", "html_url": "https://github.com/rust-lang/rust/commit/3a11ddb1b2a0807e1c3dc9a9a6afc1d578286bae"}], "stats": {"total": 571, "additions": 293, "deletions": 278}, "files": [{"sha": "58d0c40efa070db218f04f8e8f96cc5e0a1f9c65", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3acf37897a4ca7f019ed8894ec3878801377773d/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3acf37897a4ca7f019ed8894ec3878801377773d/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=3acf37897a4ca7f019ed8894ec3878801377773d", "patch": "@@ -53,8 +53,12 @@ pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n-pub use tuple::{Tuple2, Tuple3, Tuple4, Tuple5, Tuple6, Tuple7, Tuple8, Tuple9};\n-pub use tuple::{Tuple10, Tuple11, Tuple12};\n+pub use tuple::{CloneableTuple2, CloneableTuple3, CloneableTuple4, CloneableTuple5};\n+pub use tuple::{CloneableTuple6, CloneableTuple7, CloneableTuple8, CloneableTuple9};\n+pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};\n+pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTuple5};\n+pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n+pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};"}, {"sha": "639df89a3776f8532dfeb16a217d7ac1951eec27", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 287, "deletions": 276, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/3acf37897a4ca7f019ed8894ec3878801377773d/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3acf37897a4ca7f019ed8894ec3878801377773d/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=3acf37897a4ca7f019ed8894ec3878801377773d", "patch": "@@ -10,13 +10,10 @@\n \n //! Operations on tuples\n \n-use clone::Clone;\n use kinds::Copy;\n use vec;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n-\n-pub use self::getters::*;\n+pub use self::inner::*;\n \n pub trait CopyableTuple<T, U> {\n     fn first(&self) -> T;\n@@ -25,36 +22,28 @@ pub trait CopyableTuple<T, U> {\n }\n \n impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n-\n     /// Return the first element of self\n     #[inline(always)]\n     fn first(&self) -> T {\n-        let (t, _) = *self;\n-        return t;\n+        match *self {\n+            (t, _) => t,\n+        }\n     }\n \n     /// Return the second element of self\n     #[inline(always)]\n     fn second(&self) -> U {\n-        let (_, u) = *self;\n-        return u;\n+        match *self {\n+            (_, u) => u,\n+        }\n     }\n \n     /// Return the results of swapping the two elements of self\n     #[inline(always)]\n     fn swap(&self) -> (U, T) {\n-        let (t, u) = *self;\n-        return (u, t);\n-    }\n-\n-}\n-\n-impl<T:Clone,U:Clone> Clone for (T, U) {\n-    fn clone(&self) -> (T, U) {\n-        let (a, b) = match *self {\n-            (ref a, ref b) => (a, b)\n-        };\n-        (a.clone(), b.clone())\n+        match *self {\n+            (t, u) => (u, t),\n+        }\n     }\n }\n \n@@ -104,7 +93,6 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n }\n \n impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n-\n     #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n@@ -124,305 +112,328 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n     }\n }\n \n-#[cfg(not(test))]\n-impl<A:Eq> Eq for (A,) {\n-    #[inline(always)]\n-    fn eq(&self, other: &(A,)) -> bool {\n-        match (*self) {\n-            (ref self_a,) => match other {\n-                &(ref other_a,) => {\n-                    (*self_a).eq(other_a)\n-                }\n-            }\n+// macro for implementing n-ary tuple functions and operations\n+\n+macro_rules! tuple_impls {\n+    ($(\n+        ($cloneable_trait:ident, $immutable_trait:ident) {\n+            $(($get_fn:ident, $get_ref_fn:ident) -> $T:ident {\n+                $get_pattern:pat => $ret:expr\n+            })+\n         }\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &(A,)) -> bool { !(*self).eq(other) }\n-}\n+    )+) => {\n+        pub mod inner {\n+            use clone::Clone;\n+            #[cfg(not(test))] use cmp::*;\n+\n+            $(\n+                pub trait $cloneable_trait<$($T),+> {\n+                    $(fn $get_fn(&self) -> $T;)+\n+                }\n \n-#[cfg(not(test))]\n-impl<A:Ord> Ord for (A,) {\n-    #[inline(always)]\n-    fn lt(&self, other: &(A,)) -> bool {\n-        match (*self) {\n-            (ref self_a,) => {\n-                match (*other) {\n-                    (ref other_a,) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        return false;\n+                impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T),+) {\n+                    $(\n+                        #[inline(always)]\n+                        fn $get_fn(&self) -> $T {\n+                            self.$get_ref_fn().clone()\n+                        }\n+                    )+\n+                }\n+\n+                pub trait $immutable_trait<$($T),+> {\n+                    $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n+                }\n+\n+                impl<$($T),+> $immutable_trait<$($T),+> for ($($T),+) {\n+                    $(\n+                        #[inline(always)]\n+                        fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n+                            match *self { $get_pattern => $ret }\n+                        }\n+                    )+\n+                }\n+\n+                impl<$($T:Clone),+> Clone for ($($T),+) {\n+                    fn clone(&self) -> ($($T),+) {\n+                        ($(self.$get_ref_fn().clone()),+)\n                     }\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn le(&self, other: &(A,)) -> bool { !other.lt(&(*self)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &(A,)) -> bool { !self.lt(other) }\n-    #[inline(always)]\n-    fn gt(&self, other: &(A,)) -> bool { other.lt(&(*self))  }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Eq,B:Eq> Eq for (A, B) {\n-    #[inline(always)]\n-    fn eq(&self, other: &(A, B)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b) => match other {\n-                &(ref other_a, ref other_b) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n+                #[cfg(not(test))]\n+                impl<$($T:Eq),+> Eq for ($($T),+) {\n+                    #[inline(always)]\n+                    fn eq(&self, other: &($($T),+)) -> bool {\n+                        $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n+                    }\n+                    #[inline(always)]\n+                    fn ne(&self, other: &($($T),+)) -> bool {\n+                        !(*self == *other)\n+                    }\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Ord,B:Ord> Ord for (A, B) {\n-    #[inline(always)]\n-    fn lt(&self, other: &(A, B)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        return false;\n+                #[cfg(not(test))]\n+                impl<$($T:TotalEq),+> TotalEq for ($($T),+) {\n+                    #[inline(always)]\n+                    fn equals(&self, other: &($($T),+)) -> bool {\n+                        $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n                     }\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n-    #[inline(always)]\n-    fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n-    #[inline(always)]\n-    fn eq(&self, other: &(A, B, C)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b, ref self_c) => match other {\n-                &(ref other_a, ref other_b, ref other_c) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n-                        && (*self_c).eq(other_c)\n+                #[cfg(not(test))]\n+                impl<$($T:Ord),+> Ord for ($($T),+) {\n+                    #[inline(always)]\n+                    fn lt(&self, other: &($($T),+)) -> bool {\n+                        lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n+                    #[inline(always)]\n+                    fn le(&self, other: &($($T),+)) -> bool { !(*other).lt(&(*self)) }\n+                    #[inline(always)]\n+                    fn ge(&self, other: &($($T),+)) -> bool { !(*self).lt(other) }\n+                    #[inline(always)]\n+                    fn gt(&self, other: &($($T),+)) -> bool { (*other).lt(&(*self)) }\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n-    #[inline(always)]\n-    fn lt(&self, other: &(A, B, C)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b, ref self_c) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b, ref other_c) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        if (*other_b).lt(self_b) { return false; }\n-                        if (*self_c).lt(other_c) { return true; }\n-                        return false;\n+                #[cfg(not(test))]\n+                impl<$($T:TotalOrd),+> TotalOrd for ($($T),+) {\n+                    #[inline]\n+                    fn cmp(&self, other: &($($T),+)) -> Ordering {\n+                        lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                 }\n-            }\n+            )+\n         }\n     }\n-    #[inline(always)]\n-    fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n-    #[inline(always)]\n-    fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n \n-// Tuple element getters\n+// Constructs an expression that performs a lexical less-than\n+// ordering.  The values are interleaved, so the macro invocation for\n+// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_lt!(a1, b1, a2, b2,\n+// a3, b3)` (and similarly for `lexical_cmp`)\n+macro_rules! lexical_lt {\n+    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        if *$a < *$b { true }\n+        else if !(*$b < *$a) { lexical_lt!($($rest_a, $rest_b),+) }\n+        else { false }\n+    };\n+    ($a:expr, $b:expr) => { *$a < *$b };\n+}\n \n-macro_rules! tuple_getters(\n-    ($(\n-        $name:ident {\n-            $(fn $method:ident -> $T:ident { $accessor:pat => $t:expr })+\n+macro_rules! lexical_cmp {\n+    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        match ($a).cmp($b) {\n+            Equal => lexical_cmp!($($rest_a, $rest_b),+),\n+            ordering   => ordering\n         }\n-    )+) => (\n-        pub mod getters {\n-            $(pub trait $name<$($T),+> {\n-                    $(fn $method<'a>(&'a self) -> &'a $T;)+\n-            })+\n+    };\n+    ($a:expr, $b:expr) => { ($a).cmp($b) };\n+}\n \n-            $(impl<$($T),+> $name<$($T),+> for ($($T),+) {\n-                $(\n-                    #[inline(always)]\n-                    fn $method<'a>(&'a self) -> &'a $T {\n-                        match *self {\n-                            $accessor => $t\n-                        }\n-                    }\n-                )+\n-            })+\n-        }\n-    )\n-)\n \n-tuple_getters!(\n-    Tuple2 {\n-        fn n0 -> A { (ref a,_) => a }\n-        fn n1 -> B { (_,ref b) => b }\n+tuple_impls! {\n+    (CloneableTuple2, ImmutableTuple2) {\n+        (n0, n0_ref) -> A { (ref a,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b) => b }\n     }\n \n-    Tuple3 {\n-        fn n0 -> A { (ref a,_,_) => a }\n-        fn n1 -> B { (_,ref b,_) => b }\n-        fn n2 -> C { (_,_,ref c) => c }\n+    (CloneableTuple3, ImmutableTuple3) {\n+        (n0, n0_ref) -> A { (ref a,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c) => c }\n     }\n \n-    Tuple4 {\n-        fn n0 -> A { (ref a,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_) => c }\n-        fn n3 -> D { (_,_,_,ref d) => d }\n+    (CloneableTuple4, ImmutableTuple4) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d) => d }\n     }\n \n-    Tuple5 {\n-        fn n0 -> A { (ref a,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e) => e }\n+    (CloneableTuple5, ImmutableTuple5) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d,_) => d }\n+        (n4, n4_ref) -> E { (_,_,_,_,ref e) => e }\n     }\n \n-    Tuple6 {\n-        fn n0 -> A { (ref a,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f) => f }\n+    (CloneableTuple6, ImmutableTuple6) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_,_,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d,_,_) => d }\n+        (n4, n4_ref) -> E { (_,_,_,_,ref e,_) => e }\n+        (n5, n5_ref) -> F { (_,_,_,_,_,ref f) => f }\n     }\n \n-    Tuple7 {\n-        fn n0 -> A { (ref a,_,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f,_) => f }\n-        fn n6 -> G { (_,_,_,_,_,_,ref g) => g }\n+    (CloneableTuple7, ImmutableTuple7) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_,_,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_,_,_,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d,_,_,_) => d }\n+        (n4, n4_ref) -> E { (_,_,_,_,ref e,_,_) => e }\n+        (n5, n5_ref) -> F { (_,_,_,_,_,ref f,_) => f }\n+        (n6, n6_ref) -> G { (_,_,_,_,_,_,ref g) => g }\n     }\n \n-    Tuple8 {\n-        fn n0 -> A { (ref a,_,_,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_,_,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f,_,_) => f }\n-        fn n6 -> G { (_,_,_,_,_,_,ref g,_) => g }\n-        fn n7 -> H { (_,_,_,_,_,_,_,ref h) => h }\n+    (CloneableTuple8, ImmutableTuple8) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_,_,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_,_,_,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_,_,_,_,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d,_,_,_,_) => d }\n+        (n4, n4_ref) -> E { (_,_,_,_,ref e,_,_,_) => e }\n+        (n5, n5_ref) -> F { (_,_,_,_,_,ref f,_,_) => f }\n+        (n6, n6_ref) -> G { (_,_,_,_,_,_,ref g,_) => g }\n+        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,ref h) => h }\n     }\n \n-    Tuple9 {\n-        fn n0 -> A { (ref a,_,_,_,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_,_,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_,_,_,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f,_,_,_) => f }\n-        fn n6 -> G { (_,_,_,_,_,_,ref g,_,_) => g }\n-        fn n7 -> H { (_,_,_,_,_,_,_,ref h,_) => h }\n-        fn n8 -> I { (_,_,_,_,_,_,_,_,ref i) => i }\n+    (CloneableTuple9, ImmutableTuple9) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_,_,_,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_,_,_,_,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_,_,_,_,_,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d,_,_,_,_,_) => d }\n+        (n4, n4_ref) -> E { (_,_,_,_,ref e,_,_,_,_) => e }\n+        (n5, n5_ref) -> F { (_,_,_,_,_,ref f,_,_,_) => f }\n+        (n6, n6_ref) -> G { (_,_,_,_,_,_,ref g,_,_) => g }\n+        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,ref h,_) => h }\n+        (n8, n8_ref) -> I { (_,_,_,_,_,_,_,_,ref i) => i }\n     }\n \n-    Tuple10 {\n-        fn n0 -> A { (ref a,_,_,_,_,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_,_,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_,_,_,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_,_,_,_,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f,_,_,_,_) => f }\n-        fn n6 -> G { (_,_,_,_,_,_,ref g,_,_,_) => g }\n-        fn n7 -> H { (_,_,_,_,_,_,_,ref h,_,_) => h }\n-        fn n8 -> I { (_,_,_,_,_,_,_,_,ref i,_) => i }\n-        fn n9 -> J { (_,_,_,_,_,_,_,_,_,ref j) => j }\n+    (CloneableTuple10, ImmutableTuple10) {\n+        (n0, n0_ref) -> A { (ref a,_,_,_,_,_,_,_,_,_) => a }\n+        (n1, n1_ref) -> B { (_,ref b,_,_,_,_,_,_,_,_) => b }\n+        (n2, n2_ref) -> C { (_,_,ref c,_,_,_,_,_,_,_) => c }\n+        (n3, n3_ref) -> D { (_,_,_,ref d,_,_,_,_,_,_) => d }\n+        (n4, n4_ref) -> E { (_,_,_,_,ref e,_,_,_,_,_) => e }\n+        (n5, n5_ref) -> F { (_,_,_,_,_,ref f,_,_,_,_) => f }\n+        (n6, n6_ref) -> G { (_,_,_,_,_,_,ref g,_,_,_) => g }\n+        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,ref h,_,_) => h }\n+        (n8, n8_ref) -> I { (_,_,_,_,_,_,_,_,ref i,_) => i }\n+        (n9, n9_ref) -> J { (_,_,_,_,_,_,_,_,_,ref j) => j }\n     }\n \n-    Tuple11 {\n-        fn n0 -> A { (ref a,_,_,_,_,_,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_,_,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_,_,_,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_,_,_,_,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_,_,_,_,_,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f,_,_,_,_,_) => f }\n-        fn n6 -> G { (_,_,_,_,_,_,ref g,_,_,_,_) => g }\n-        fn n7 -> H { (_,_,_,_,_,_,_,ref h,_,_,_) => h }\n-        fn n8 -> I { (_,_,_,_,_,_,_,_,ref i,_,_) => i }\n-        fn n9 -> J { (_,_,_,_,_,_,_,_,_,ref j,_) => j }\n-        fn n10 -> K { (_,_,_,_,_,_,_,_,_,_,ref k) => k }\n+    (CloneableTuple11, ImmutableTuple11) {\n+        (n0,  n0_ref)  -> A { (ref a,_,_,_,_,_,_,_,_,_,_) => a }\n+        (n1,  n1_ref)  -> B { (_,ref b,_,_,_,_,_,_,_,_,_) => b }\n+        (n2,  n2_ref)  -> C { (_,_,ref c,_,_,_,_,_,_,_,_) => c }\n+        (n3,  n3_ref)  -> D { (_,_,_,ref d,_,_,_,_,_,_,_) => d }\n+        (n4,  n4_ref)  -> E { (_,_,_,_,ref e,_,_,_,_,_,_) => e }\n+        (n5,  n5_ref)  -> F { (_,_,_,_,_,ref f,_,_,_,_,_) => f }\n+        (n6,  n6_ref)  -> G { (_,_,_,_,_,_,ref g,_,_,_,_) => g }\n+        (n7,  n7_ref)  -> H { (_,_,_,_,_,_,_,ref h,_,_,_) => h }\n+        (n8,  n8_ref)  -> I { (_,_,_,_,_,_,_,_,ref i,_,_) => i }\n+        (n9,  n9_ref)  -> J { (_,_,_,_,_,_,_,_,_,ref j,_) => j }\n+        (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,ref k) => k }\n     }\n \n-    Tuple12 {\n-        fn n0 -> A { (ref a,_,_,_,_,_,_,_,_,_,_,_) => a }\n-        fn n1 -> B { (_,ref b,_,_,_,_,_,_,_,_,_,_) => b }\n-        fn n2 -> C { (_,_,ref c,_,_,_,_,_,_,_,_,_) => c }\n-        fn n3 -> D { (_,_,_,ref d,_,_,_,_,_,_,_,_) => d }\n-        fn n4 -> E { (_,_,_,_,ref e,_,_,_,_,_,_,_) => e }\n-        fn n5 -> F { (_,_,_,_,_,ref f,_,_,_,_,_,_) => f }\n-        fn n6 -> G { (_,_,_,_,_,_,ref g,_,_,_,_,_) => g }\n-        fn n7 -> H { (_,_,_,_,_,_,_,ref h,_,_,_,_) => h }\n-        fn n8 -> I { (_,_,_,_,_,_,_,_,ref i,_,_,_) => i }\n-        fn n9 -> J { (_,_,_,_,_,_,_,_,_,ref j,_,_) => j }\n-        fn n10 -> K { (_,_,_,_,_,_,_,_,_,_,ref k,_) => k }\n-        fn n11 -> L { (_,_,_,_,_,_,_,_,_,_,_,ref l) => l }\n+    (CloneableTuple12, ImmutableTuple12) {\n+        (n0,  n0_ref)  -> A { (ref a,_,_,_,_,_,_,_,_,_,_,_) => a }\n+        (n1,  n1_ref)  -> B { (_,ref b,_,_,_,_,_,_,_,_,_,_) => b }\n+        (n2,  n2_ref)  -> C { (_,_,ref c,_,_,_,_,_,_,_,_,_) => c }\n+        (n3,  n3_ref)  -> D { (_,_,_,ref d,_,_,_,_,_,_,_,_) => d }\n+        (n4,  n4_ref)  -> E { (_,_,_,_,ref e,_,_,_,_,_,_,_) => e }\n+        (n5,  n5_ref)  -> F { (_,_,_,_,_,ref f,_,_,_,_,_,_) => f }\n+        (n6,  n6_ref)  -> G { (_,_,_,_,_,_,ref g,_,_,_,_,_) => g }\n+        (n7,  n7_ref)  -> H { (_,_,_,_,_,_,_,ref h,_,_,_,_) => h }\n+        (n8,  n8_ref)  -> I { (_,_,_,_,_,_,_,_,ref i,_,_,_) => i }\n+        (n9,  n9_ref)  -> J { (_,_,_,_,_,_,_,_,_,ref j,_,_) => j }\n+        (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,ref k,_) => k }\n+        (n11, n11_ref) -> L { (_,_,_,_,_,_,_,_,_,_,_,ref l) => l }\n     }\n-)\n-\n-#[test]\n-fn test_tuple_ref() {\n-    let x = (~\"foo\", ~\"bar\");\n-    assert_eq!(x.first_ref(), &~\"foo\");\n-    assert_eq!(x.second_ref(), &~\"bar\");\n }\n \n-#[test]\n-#[allow(non_implicitly_copyable_typarams)]\n-fn test_tuple() {\n-    assert_eq!((948, 4039.48).first(), 948);\n-    assert_eq!((34.5, ~\"foo\").second(), ~\"foo\");\n-    assert_eq!(('a', 2).swap(), (2, 'a'));\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use clone::Clone;\n+    use cmp::*;\n+\n+    #[test]\n+    fn test_tuple_ref() {\n+        let x = (~\"foo\", ~\"bar\");\n+        assert_eq!(x.first_ref(), &~\"foo\");\n+        assert_eq!(x.second_ref(), &~\"bar\");\n+    }\n \n-#[test]\n-fn test_clone() {\n-    let a = (1, ~\"2\");\n-    let b = a.clone();\n-    assert_eq!(a.first(), b.first());\n-    assert_eq!(a.second(), b.second());\n-}\n+    #[test]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_tuple() {\n+        assert_eq!((948, 4039.48).first(), 948);\n+        assert_eq!((34.5, ~\"foo\").second(), ~\"foo\");\n+        assert_eq!(('a', 2).swap(), (2, 'a'));\n+    }\n \n-#[test]\n-fn test_n_tuple() {\n-    let t = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n-    assert_eq!(*t.n0(), 0u8);\n-    assert_eq!(*t.n1(), 1u16);\n-    assert_eq!(*t.n2(), 2u32);\n-    assert_eq!(*t.n3(), 3u64);\n-    assert_eq!(*t.n4(), 4u);\n-    assert_eq!(*t.n5(), 5i8);\n-    assert_eq!(*t.n6(), 6i16);\n-    assert_eq!(*t.n7(), 7i32);\n-    assert_eq!(*t.n8(), 8i64);\n-    assert_eq!(*t.n9(), 9i);\n-    assert_eq!(*t.n10(), 10f32);\n-    assert_eq!(*t.n11(), 11f64);\n+    #[test]\n+    fn test_clone() {\n+        let a = (1, ~\"2\");\n+        let b = a.clone();\n+        assert_eq!(a.first(), b.first());\n+        assert_eq!(a.second(), b.second());\n+    }\n+\n+    #[test]\n+    fn test_n_tuple() {\n+        let t = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n+        assert_eq!(t.n0(), 0u8);\n+        assert_eq!(t.n1(), 1u16);\n+        assert_eq!(t.n2(), 2u32);\n+        assert_eq!(t.n3(), 3u64);\n+        assert_eq!(t.n4(), 4u);\n+        assert_eq!(t.n5(), 5i8);\n+        assert_eq!(t.n6(), 6i16);\n+        assert_eq!(t.n7(), 7i32);\n+        assert_eq!(t.n8(), 8i64);\n+        assert_eq!(t.n9(), 9i);\n+        assert_eq!(t.n10(), 10f32);\n+        assert_eq!(t.n11(), 11f64);\n+\n+        assert_eq!(t.n0_ref(), &0u8);\n+        assert_eq!(t.n1_ref(), &1u16);\n+        assert_eq!(t.n2_ref(), &2u32);\n+        assert_eq!(t.n3_ref(), &3u64);\n+        assert_eq!(t.n4_ref(), &4u);\n+        assert_eq!(t.n5_ref(), &5i8);\n+        assert_eq!(t.n6_ref(), &6i16);\n+        assert_eq!(t.n7_ref(), &7i32);\n+        assert_eq!(t.n8_ref(), &8i64);\n+        assert_eq!(t.n9_ref(), &9i);\n+        assert_eq!(t.n10_ref(), &10f32);\n+        assert_eq!(t.n11_ref(), &11f64);\n+    }\n+\n+    #[test]\n+    fn test_tuple_cmp() {\n+        let small = (1u, 2u, 3u), big = (3u, 2u, 1u);\n+\n+        // Eq\n+        assert_eq!(small, small);\n+        assert_eq!(big, big);\n+        assert!(small != big);\n+        assert!(big != small);\n+\n+        // Ord\n+        assert!(small < big);\n+        assert!(!(small < small));\n+        assert!(!(big < small));\n+        assert!(!(big < big));\n+\n+        assert!(small <= small);\n+        assert!(big <= big);\n+\n+        assert!(big > small);\n+        assert!(small >= small);\n+        assert!(big >= small);\n+        assert!(big >= big);\n+\n+        // TotalEq\n+        assert!(small.equals(&small));\n+        assert!(big.equals(&big));\n+        assert!(!small.equals(&big));\n+        assert!(!big.equals(&small));\n+\n+        // TotalOrd\n+        assert_eq!(small.cmp(&small), Equal);\n+        assert_eq!(big.cmp(&big), Equal);\n+        assert_eq!(small.cmp(&big), Less);\n+        assert_eq!(big.cmp(&small), Greater);\n+    }\n }"}]}