{"sha": "d4039c55c9ef392261aeaba6c14ae81f5098139a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MDM5YzU1YzllZjM5MjI2MWFlYWJhNmMxNGFlODFmNTA5ODEzOWE=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-19T20:17:52Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-19T20:17:52Z"}, "message": "wip emit errors during AbstractConst building", "tree": {"sha": "2410cee065ffcbfee00ecd3f070be82d6c20062c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2410cee065ffcbfee00ecd3f070be82d6c20062c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4039c55c9ef392261aeaba6c14ae81f5098139a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4039c55c9ef392261aeaba6c14ae81f5098139a", "html_url": "https://github.com/rust-lang/rust/commit/d4039c55c9ef392261aeaba6c14ae81f5098139a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4039c55c9ef392261aeaba6c14ae81f5098139a/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59fb88d061544a035f3043b47594b34789204cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/59fb88d061544a035f3043b47594b34789204cee", "html_url": "https://github.com/rust-lang/rust/commit/59fb88d061544a035f3043b47594b34789204cee"}], "stats": {"total": 205, "additions": 125, "deletions": 80}, "files": [{"sha": "72d54a26b01d4469350c351559bb5f3f2757aadf", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d4039c55c9ef392261aeaba6c14ae81f5098139a", "patch": "@@ -11,6 +11,7 @@ use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n+use rustc_errors::ErrorReported;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -1201,13 +1202,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         self.root\n             .tables\n             .mir_abstract_consts\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n-            .map_or(None, |v| Some(v.decode((self, tcx))))\n+            .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }\n \n     fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {"}, {"sha": "3500ec7455429f2becc5654056b1754ea8033855", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d4039c55c9ef392261aeaba6c14ae81f5098139a", "patch": "@@ -1117,7 +1117,7 @@ impl EncodeContext<'a, 'tcx> {\n             }\n \n             let abstract_const = self.tcx.mir_abstract_const(def_id);\n-            if let Some(abstract_const) = abstract_const {\n+            if let Ok(Some(abstract_const)) = abstract_const {\n                 record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n             }\n         }"}, {"sha": "86fb0664a5c62ad670ead224a1c50458b70b385f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d4039c55c9ef392261aeaba6c14ae81f5098139a", "patch": "@@ -247,15 +247,15 @@ rustc_queries! {\n         /// Try to build an abstract representation of the given constant.\n         query mir_abstract_const(\n             key: DefId\n-        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n             desc {\n                 |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n             }\n         }\n         /// Try to build an abstract representation of the given constant.\n         query mir_abstract_const_of_const_arg(\n             key: (LocalDefId, DefId)\n-        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n             desc {\n                 |tcx|\n                 \"building an abstract representation for the const argument {}\","}, {"sha": "a53075448eddc5980b20dc1ac9331ff94b71b357", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=d4039c55c9ef392261aeaba6c14ae81f5098139a", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n+#![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n #![recursion_limit = \"512\"] // For rustdoc"}, {"sha": "6c0c1df1b530f927f778c2abcf04ff2503a6817c", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 118, "deletions": 75, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4039c55c9ef392261aeaba6c14ae81f5098139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=d4039c55c9ef392261aeaba6c14ae81f5098139a", "patch": "@@ -8,6 +8,7 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `mir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -31,7 +32,9 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs) {\n+        if let Some(ct) =\n+            AbstractConst::new(infcx.tcx, def, substs).map_err(ErrorHandled::Reported)?\n+        {\n             for pred in param_env.caller_bounds() {\n                 match pred.skip_binders() {\n                     ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n@@ -40,6 +43,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                             debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n                             return Ok(());\n                         } else if AbstractConst::new(infcx.tcx, b_def, b_substs)\n+                            .map_err(ErrorHandled::Reported)?\n                             .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n                         {\n                             debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n@@ -114,15 +118,15 @@ impl AbstractConst<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<DefId>,\n         substs: SubstsRef<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n         let inner = match (def.did.as_local(), def.const_param_did) {\n             (Some(did), Some(param_did)) => {\n                 tcx.mir_abstract_const_of_const_arg((did, param_did))?\n             }\n             _ => tcx.mir_abstract_const(def.did)?,\n         };\n \n-        Some(AbstractConst { inner, substs })\n+        Ok(inner.map(|inner| AbstractConst { inner, substs }))\n     }\n \n     #[inline]\n@@ -148,53 +152,85 @@ struct AbstractConstBuilder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>) -> Option<AbstractConstBuilder<'a, 'tcx>> {\n-        // We only allow consts without control flow, so\n-        // we check for cycles here which simplifies the\n-        // rest of this implementation.\n-        if body.is_cfg_cyclic() {\n-            return None;\n+    fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n+        let mut err =\n+            self.tcx.sess.struct_span_err(self.body.span, \"overly complex generic constant\");\n+        if let Some(span) = span {\n+            err.span_note(span, msg);\n+        } else {\n+            err.note(msg);\n         }\n+        err.help(\"consider moving this anonymous constant into a `const` function\").emit();\n \n-        // We don't have to look at concrete constants, as we\n-        // can just evaluate them.\n-        if !body.is_polymorphic {\n-            return None;\n-        }\n+        Err(ErrorReported)\n+    }\n \n-        Some(AbstractConstBuilder {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorReported> {\n+        let mut builder = AbstractConstBuilder {\n             tcx,\n             body,\n             nodes: IndexVec::new(),\n             locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n             checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n-        })\n+        };\n+\n+        // We don't have to look at concrete constants, as we\n+        // can just evaluate them.\n+        if !body.is_polymorphic {\n+            return Ok(None);\n+        }\n+\n+        // We only allow consts without control flow, so\n+        // we check for cycles here which simplifies the\n+        // rest of this implementation.\n+        if body.is_cfg_cyclic() {\n+            builder.error(None, \"cyclic anonymous constants are forbidden\")?;\n+        }\n+\n+        Ok(Some(builder))\n     }\n-    fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n-        debug!(\"operand_to_node: op={:?}\", op);\n+\n+    fn place_to_local(\n+        &mut self,\n+        span: Span,\n+        p: &mir::Place<'tcx>,\n+    ) -> Result<mir::Local, ErrorReported> {\n         const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n+        // Do not allow any projections.\n+        //\n+        // One exception are field accesses on the result of checked operations,\n+        // which are required to support things like `1 + 2`.\n+        if let Some(p) = p.as_local() {\n+            debug_assert!(!self.checked_op_locals.contains(p));\n+            Ok(p)\n+        } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n+            // Only allow field accesses if the given local\n+            // contains the result of a checked operation.\n+            if self.checked_op_locals.contains(p.local) {\n+                Ok(p.local)\n+            } else {\n+                self.error(Some(span), \"unsupported projection\")?;\n+            }\n+        } else {\n+            self.error(Some(span), \"unsupported projection\")?;\n+        }\n+    }\n+\n+    fn operand_to_node(\n+        &mut self,\n+        span: Span,\n+        op: &mir::Operand<'tcx>,\n+    ) -> Result<NodeId, ErrorReported> {\n+        debug!(\"operand_to_node: op={:?}\", op);\n         match op {\n             mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                // Do not allow any projections.\n-                //\n-                // One exception are field accesses on the result of checked operations,\n-                // which are required to support things like `1 + 2`.\n-                if let Some(p) = p.as_local() {\n-                    debug_assert!(!self.checked_op_locals.contains(p));\n-                    Some(self.locals[p])\n-                } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow field accesses if the given local\n-                    // contains the result of a checked operation.\n-                    if self.checked_op_locals.contains(p.local) {\n-                        Some(self.locals[p.local])\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n+                let local = self.place_to_local(span, p)?;\n+                Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Some(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n         }\n     }\n \n@@ -217,44 +253,45 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Option<()> {\n+    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = place.as_local()?;\n+                let local = self.place_to_local(stmt.source_info.span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] = self.operand_to_node(operand)?;\n-                        Some(())\n+                        self.locals[local] =\n+                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(lhs)?;\n-                        let rhs = self.operand_to_node(rhs)?;\n+                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n+                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n                         self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n-                            Some(())\n+                            Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(lhs)?;\n-                        let rhs = self.operand_to_node(rhs)?;\n+                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n+                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n                         self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         self.checked_op_locals.insert(local);\n-                        Some(())\n+                        Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(operand)?;\n+                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n                         self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n-                        Some(())\n+                        Ok(())\n                     }\n-                    _ => None,\n+                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Some(()),\n-            _ => None,\n+            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Ok(()),\n+            _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n         }\n     }\n \n@@ -266,11 +303,11 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     fn build_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n-    ) -> Option<Option<mir::BasicBlock>> {\n+    ) -> Result<Option<mir::BasicBlock>, ErrorReported> {\n         debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n         match terminator.kind {\n-            TerminatorKind::Goto { target } => Some(Some(target)),\n-            TerminatorKind::Return => Some(None),\n+            TerminatorKind::Goto { target } => Ok(Some(target)),\n+            TerminatorKind::Return => Ok(None),\n             TerminatorKind::Call {\n                 ref func,\n                 ref args,\n@@ -288,17 +325,17 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 //\n                 // This is currently fairly irrelevant as it requires `const Trait`s.\n                 from_hir_call: true,\n-                fn_span: _,\n+                fn_span,\n             } => {\n-                let local = place.as_local()?;\n-                let func = self.operand_to_node(func)?;\n+                let local = self.place_to_local(fn_span, place)?;\n+                let func = self.operand_to_node(fn_span, func)?;\n                 let args = self.tcx.arena.alloc_from_iter(\n                     args.iter()\n-                        .map(|arg| self.operand_to_node(arg))\n-                        .collect::<Option<Vec<NodeId>>>()?,\n+                        .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n+                        .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n                 self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n-                Some(Some(target))\n+                Ok(Some(target))\n             }\n             // We only allow asserts for checked operations.\n             //\n@@ -315,19 +352,19 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n-                        return Some(Some(target));\n+                        return Ok(Some(target));\n                     }\n                 }\n \n-                None\n+                self.error(Some(terminator.source_info.span), \"unsupported assertion\")?;\n             }\n-            _ => None,\n+            _ => self.error(Some(terminator.source_info.span), \"unsupported terminator\")?,\n         }\n     }\n \n     /// Builds the abstract const by walking the mir from start to finish\n     /// and bailing out when encountering an unsupported operation.\n-    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n+    fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n         let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n         // We checked for a cyclic cfg above, so this should terminate.\n         loop {\n@@ -339,7 +376,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Some(self.tcx.arena.alloc_from_iter(self.nodes));\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n             }\n         }\n     }\n@@ -349,7 +386,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n pub(super) fn mir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Option<&'tcx [Node<'tcx>]> {\n+) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n     if tcx.features().const_evaluatable_checked {\n         match tcx.def_kind(def.did) {\n             // FIXME(const_evaluatable_checked): We currently only do this for anonymous constants,\n@@ -358,12 +395,12 @@ pub(super) fn mir_abstract_const<'tcx>(\n             //\n             // Right now we do neither of that and simply always fail to unify them.\n             DefKind::AnonConst => (),\n-            _ => return None,\n+            _ => return Ok(None),\n         }\n         let body = tcx.mir_const(def).borrow();\n-        AbstractConstBuilder::new(tcx, &body)?.build()\n+        AbstractConstBuilder::new(tcx, &body)?.map(AbstractConstBuilder::build).transpose()\n     } else {\n-        None\n+        Ok(None)\n     }\n }\n \n@@ -374,13 +411,19 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n         (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n     ),\n ) -> bool {\n-    if let Some(a) = AbstractConst::new(tcx, a, a_substs) {\n-        if let Some(b) = AbstractConst::new(tcx, b, b_substs) {\n-            return try_unify(tcx, a, b);\n+    (|| {\n+        if let Some(a) = AbstractConst::new(tcx, a, a_substs)? {\n+            if let Some(b) = AbstractConst::new(tcx, b, b_substs)? {\n+                return Ok(try_unify(tcx, a, b));\n+            }\n         }\n-    }\n \n-    false\n+        Ok(false)\n+    })()\n+    .unwrap_or_else(|ErrorReported| true)\n+    // FIXME(const_evaluatable_checked): We should instead have this\n+    // method return the resulting `ty::Const` and return `ConstKind::Error`\n+    // on `Error`.\n }\n \n /// Tries to unify two abstract constants using structural equality."}]}