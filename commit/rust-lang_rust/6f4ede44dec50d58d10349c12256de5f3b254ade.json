{"sha": "6f4ede44dec50d58d10349c12256de5f3b254ade", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNGVkZTQ0ZGVjNTBkNThkMTAzNDljMTIyNTZkZTVmM2IyNTRhZGU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T22:52:18Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-14T05:34:40Z"}, "message": "Rollup merge of #30801 - Amanieu:oom_print, r=alexcrichton\n\nThis adds the ability to override the default OOM behavior by setting a handler function. This is used by libstd to print a message when running out of memory instead of crashing with an obscure \"illegal hardware instruction\" error (at least on Linux).\n\nFixes #14674", "tree": {"sha": "fe09a4d3960574d5d861f52031c2aa1555d780c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe09a4d3960574d5d861f52031c2aa1555d780c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f4ede44dec50d58d10349c12256de5f3b254ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f4ede44dec50d58d10349c12256de5f3b254ade", "html_url": "https://github.com/rust-lang/rust/commit/6f4ede44dec50d58d10349c12256de5f3b254ade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f4ede44dec50d58d10349c12256de5f3b254ade/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6581563f7a7cafd40d17eb1921726febc10f8628", "url": "https://api.github.com/repos/rust-lang/rust/commits/6581563f7a7cafd40d17eb1921726febc10f8628", "html_url": "https://github.com/rust-lang/rust/commit/6581563f7a7cafd40d17eb1921726febc10f8628"}, {"sha": "98bef2b81823483a23beef48c7999a67206d261d", "url": "https://api.github.com/repos/rust-lang/rust/commits/98bef2b81823483a23beef48c7999a67206d261d", "html_url": "https://github.com/rust-lang/rust/commit/98bef2b81823483a23beef48c7999a67206d261d"}], "stats": {"total": 109, "additions": 92, "deletions": 17}, "files": [{"sha": "ffa0ec4917cb3ef02fba42e1cc9171a0124ad576", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6f4ede44dec50d58d10349c12256de5f3b254ade", "patch": "@@ -92,6 +92,7 @@\n #![feature(unsize)]\n #![feature(drop_in_place)]\n #![feature(fn_traits)]\n+#![feature(const_fn)]\n \n #![feature(needs_allocator)]\n \n@@ -134,15 +135,6 @@ mod boxed_test;\n pub mod arc;\n pub mod rc;\n pub mod raw_vec;\n+pub mod oom;\n \n-/// Common out-of-memory routine\n-#[cold]\n-#[inline(never)]\n-#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-           issue = \"27700\")]\n-pub fn oom() -> ! {\n-    // FIXME(#14674): This really needs to do something other than just abort\n-    //                here, but any printing done must be *guaranteed* to not\n-    //                allocate.\n-    unsafe { core::intrinsics::abort() }\n-}\n+pub use oom::oom;"}, {"sha": "d355d59185eb4850311f808835835400978fc756", "filename": "src/liballoc/oom.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Fliballoc%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Fliballoc%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Foom.rs?ref=6f4ede44dec50d58d10349c12256de5f3b254ade", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::sync::atomic::{AtomicPtr, Ordering};\n+use core::mem;\n+use core::intrinsics;\n+\n+static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(default_oom_handler as *mut ());\n+\n+fn default_oom_handler() -> ! {\n+    // The default handler can't do much more since we can't assume the presence\n+    // of libc or any way of printing an error message.\n+    unsafe { intrinsics::abort() }\n+}\n+\n+/// Common out-of-memory routine\n+#[cold]\n+#[inline(never)]\n+#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n+           issue = \"27700\")]\n+pub fn oom() -> ! {\n+    let value = OOM_HANDLER.load(Ordering::SeqCst);\n+    let handler: fn() -> ! = unsafe { mem::transmute(value) };\n+    handler();\n+}\n+\n+/// Set a custom handler for out-of-memory conditions\n+///\n+/// To avoid recursive OOM failures, it is critical that the OOM handler does\n+/// not allocate any memory itself.\n+#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n+           issue = \"27700\")]\n+pub fn set_oom_handler(handler: fn() -> !) {\n+    OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n+}"}, {"sha": "8561ecd9c4cb92d9e21952fe65167c03b9ad9ab5", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=6f4ede44dec50d58d10349c12256de5f3b254ade", "patch": "@@ -206,7 +206,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n     // debugger provides a useable stacktrace.\n     if panics >= 3 {\n         util::dumb_print(format_args!(\"thread panicked while processing \\\n-                                       panic. aborting.\"));\n+                                       panic. aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n     }\n \n@@ -232,7 +232,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the thread cleanly.\n         util::dumb_print(format_args!(\"thread panicked while panicking. \\\n-                                       aborting.\"));\n+                                       aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n     }\n }"}, {"sha": "b7a6b7650d54079de57495659ba7684dc697264a", "filename": "src/libstd/sys/common/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs?ref=6f4ede44dec50d58d10349c12256de5f3b254ade", "patch": "@@ -35,12 +35,12 @@ pub fn dumb_print(args: fmt::Arguments) {\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {\n-    dumb_print(format_args!(\"fatal runtime error: {}\", args));\n+    dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n     unsafe { intrinsics::abort(); }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms\n pub unsafe fn report_overflow() {\n-    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\",\n+    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\\n\",\n                             thread::current().name().unwrap_or(\"<unknown>\")));\n }"}, {"sha": "9771b057d8d21f5bfac77a38cbb71b5130e5c899", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=6f4ede44dec50d58d10349c12256de5f3b254ade", "patch": "@@ -15,6 +15,7 @@ use io::{self, ErrorKind};\n use libc;\n use num::One;\n use ops::Neg;\n+use alloc::oom;\n \n #[cfg(target_os = \"android\")]   pub use os::android as platform;\n #[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n@@ -45,6 +46,22 @@ pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n+// A nicer handler for out-of-memory situations than the default one. This one\n+// prints a message to stderr before aborting. It is critical that this code\n+// does not allocate any memory since we are in an OOM situation. Any errors are\n+// ignored while printing since there's nothing we can do about them and we are\n+// about to exit anyways.\n+fn oom_handler() -> ! {\n+    use intrinsics;\n+    let msg = \"fatal runtime error: out of memory\\n\";\n+    unsafe {\n+        libc::write(libc::STDERR_FILENO,\n+                    msg.as_ptr() as *const libc::c_void,\n+                    msg.len() as libc::size_t);\n+        intrinsics::abort();\n+    }\n+}\n+\n #[cfg(not(any(target_os = \"nacl\", test)))]\n pub fn init() {\n     use libc::signal;\n@@ -58,10 +75,14 @@ pub fn init() {\n     unsafe {\n         assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n     }\n+\n+    oom::set_oom_handler(oom_handler);\n }\n \n #[cfg(all(target_os = \"nacl\", not(test)))]\n-pub fn init() { }\n+pub fn init() {\n+    oom::set_oom_handler(oom_handler);\n+}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {"}, {"sha": "16c4ae8257c132d7018e018fcab09c682f8f8db6", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4ede44dec50d58d10349c12256de5f3b254ade/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=6f4ede44dec50d58d10349c12256de5f3b254ade", "patch": "@@ -20,6 +20,7 @@ use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n+use alloc::oom;\n \n #[macro_use] pub mod compat;\n \n@@ -42,7 +43,26 @@ pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n-pub fn init() {}\n+// See comment in sys/unix/mod.rs\n+fn oom_handler() -> ! {\n+    use intrinsics;\n+    use ptr;\n+    let msg = \"fatal runtime error: out of memory\\n\";\n+    unsafe {\n+        // WriteFile silently fails if it is passed an invalid handle, so there\n+        // is no need to check the result of GetStdHandle.\n+        c::WriteFile(c::GetStdHandle(c::STD_ERROR_HANDLE),\n+                     msg.as_ptr() as c::LPVOID,\n+                     msg.len() as c::DWORD,\n+                     ptr::null_mut(),\n+                     ptr::null_mut());\n+        intrinsics::abort();\n+    }\n+}\n+\n+pub fn init() {\n+    oom::set_oom_handler(oom_handler);\n+}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as c::DWORD {"}]}