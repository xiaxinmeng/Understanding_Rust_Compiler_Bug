{"sha": "93eaf15646e980a5e578eb58f295b9a066b7560f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZWFmMTU2NDZlOTgwYTVlNTc4ZWI1OGYyOTViOWEwNjZiNzU2MGY=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-08-27T10:00:21Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-09-01T12:02:45Z"}, "message": "Add SessionDiagnostic derive macro.\n\nCo-authored-by: Oliver Scherer <github35764891676564198441@oli-obk.de>", "tree": {"sha": "a2a46163cc4783c99e3218c29179a6fd9ad26343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2a46163cc4783c99e3218c29179a6fd9ad26343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93eaf15646e980a5e578eb58f295b9a066b7560f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93eaf15646e980a5e578eb58f295b9a066b7560f", "html_url": "https://github.com/rust-lang/rust/commit/93eaf15646e980a5e578eb58f295b9a066b7560f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93eaf15646e980a5e578eb58f295b9a066b7560f/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f1bbf5ee014cdad5d95f13266b177d89cc40d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1bbf5ee014cdad5d95f13266b177d89cc40d89", "html_url": "https://github.com/rust-lang/rust/commit/6f1bbf5ee014cdad5d95f13266b177d89cc40d89"}], "stats": {"total": 1116, "additions": 1106, "deletions": 10}, "files": [{"sha": "a500549fb53fb3b10464de50d3b1b793e1af0a67", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -4086,6 +4086,7 @@ dependencies = [\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "5c28839c9b7e4a3249d958a89aa39d7a70fe84e2", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -1,3 +1,4 @@\n+#![feature(proc_macro_diagnostic)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n@@ -9,6 +10,7 @@ mod hash_stable;\n mod lift;\n mod query;\n mod serialize;\n+mod session_diagnostic;\n mod symbols;\n mod type_foldable;\n \n@@ -36,3 +38,14 @@ decl_derive!([MetadataDecodable] => serialize::meta_decodable_derive);\n decl_derive!([MetadataEncodable] => serialize::meta_encodable_derive);\n decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_foldable_derive);\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);\n+decl_derive!(\n+    [SessionDiagnostic, attributes(\n+        message,\n+        lint,\n+        error,\n+        label,\n+        suggestion,\n+        suggestion_short,\n+        suggestion_hidden,\n+        suggestion_verbose)] => session_diagnostic::session_diagnostic_derive\n+);"}, {"sha": "396de77d5eee027b68ce06fecb90c8569a27ae61", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -0,0 +1,665 @@\n+#![deny(unused_must_use)]\n+use quote::format_ident;\n+use quote::quote;\n+\n+use proc_macro::Diagnostic;\n+use syn::spanned::Spanned;\n+\n+use std::collections::{HashMap, HashSet};\n+\n+/// Implements #[derive(SessionDiagnostic)], which allows for errors to be specified as a struct, independent\n+/// from the actual diagnostics emitting code.\n+/// ```ignore (pseudo-rust)\n+/// # extern crate rustc_errors;\n+/// # use rustc_errors::Applicability;\n+/// # extern crate rustc_span;\n+/// # use rustc_span::{symbol::Ident, Span};\n+/// # extern crate rust_middle;\n+/// # use rustc_middle::ty::Ty;\n+/// #[derive(SessionDiagnostic)]\n+/// #[code = \"E0505\"]\n+/// #[error = \"cannot move out of {name} because it is borrowed\"]\n+/// pub struct MoveOutOfBorrowError<'tcx> {\n+///     pub name: Ident,\n+///     pub ty: Ty<'tcx>,\n+///     #[label = \"cannot move out of borrow\"]\n+///     pub span: Span,\n+///     #[label = \"`{ty}` first borrowed here\"]\n+///     pub other_span: Span,\n+///     #[suggestion(message = \"consider cloning here\", code = \"{name}.clone()\")]\n+///     pub opt_sugg: Option<(Span, Applicability)>\n+/// }\n+/// ```\n+/// Then, later, to emit the error:\n+///\n+/// ```ignore (pseudo-rust)\n+/// sess.emit_err(MoveOutOfBorrowError {\n+///     expected,\n+///     actual,\n+///     span,\n+///     other_span,\n+///     opt_sugg: Some(suggestion, Applicability::MachineApplicable),\n+/// });\n+/// ```\n+pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    // Names for the diagnostic we build and the session we build it from.\n+    let diag = format_ident!(\"diag\");\n+    let sess = format_ident!(\"sess\");\n+\n+    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n+}\n+\n+// Checks whether the type name of `ty` matches `name`.\n+//\n+// Given some struct at a::b::c::Foo, this will return true for c::Foo, b::c::Foo, or\n+// a::b::c::Foo. This reasonably allows qualified names to be used in the macro.\n+fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n+    if let syn::Type::Path(ty) = ty {\n+        ty.path\n+            .segments\n+            .iter()\n+            .map(|s| s.ident.to_string())\n+            .rev()\n+            .zip(name.iter().rev())\n+            .all(|(x, y)| &x.as_str() == y)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// The central struct for constructing the as_error method from an annotated struct.\n+struct SessionDiagnosticDerive<'a> {\n+    structure: synstructure::Structure<'a>,\n+    builder: SessionDiagnosticDeriveBuilder<'a>,\n+}\n+\n+impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n+    fn from(e: syn::Error) -> Self {\n+        SessionDiagnosticDeriveError::SynError(e)\n+    }\n+}\n+\n+/// Equivalent to rustc:errors::diagnostic::DiagnosticId, except stores the quoted expression to\n+/// initialise the code with.\n+enum DiagnosticId {\n+    Error(proc_macro2::TokenStream),\n+    Lint(proc_macro2::TokenStream),\n+}\n+\n+#[derive(Debug)]\n+enum SessionDiagnosticDeriveError {\n+    SynError(syn::Error),\n+    ErrorHandled,\n+}\n+\n+impl SessionDiagnosticDeriveError {\n+    fn to_compile_error(self) -> proc_macro2::TokenStream {\n+        match self {\n+            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n+            SessionDiagnosticDeriveError::ErrorHandled => {\n+                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n+                // error has already been emitted to the compiler.\n+                quote! {\n+                    unreachable!()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnostic {\n+    Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n+}\n+\n+/// For methods that return a Result<_, SessionDiagnosticDeriveError>: emit a diagnostic on\n+/// span $span with msg $msg (and, optionally, perform additional decoration using the FnOnce\n+/// passed in `diag`). Then, return Err(ErrorHandled).\n+macro_rules! throw_span_err {\n+    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n+    ($span:expr, $msg:expr, $f:expr) => {{\n+        return Err(_throw_span_err($span, $msg, $f));\n+    }};\n+}\n+\n+/// When possible, prefer using throw_span_err! over using this function directly. This only exists\n+/// as a function to constrain `f` to an impl FnOnce.\n+fn _throw_span_err(\n+    span: impl proc_macro::MultiSpan,\n+    msg: &str,\n+    f: impl FnOnce(proc_macro::Diagnostic) -> proc_macro::Diagnostic,\n+) -> SessionDiagnosticDeriveError {\n+    let diag = span_err(span, msg);\n+    f(diag).emit();\n+    SessionDiagnosticDeriveError::ErrorHandled\n+}\n+\n+impl<'a> SessionDiagnosticDerive<'a> {\n+    fn new(diag: syn::Ident, sess: syn::Ident, structure: synstructure::Structure<'a>) -> Self {\n+        // Build the mapping of field names to fields. This allows attributes to peek values from\n+        // other fields.\n+        let mut fields_map = HashMap::new();\n+\n+        // Convenience bindings.\n+        let ast = structure.ast();\n+\n+        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n+            for field in fields.iter() {\n+                if let Some(ident) = &field.ident {\n+                    fields_map.insert(ident.to_string(), field);\n+                }\n+            }\n+        }\n+\n+        Self {\n+            builder: SessionDiagnosticDeriveBuilder { diag, sess, fields: fields_map, kind: None },\n+            structure,\n+        }\n+    }\n+    fn into_tokens(self) -> proc_macro2::TokenStream {\n+        let SessionDiagnosticDerive { structure, mut builder } = self;\n+\n+        let ast = structure.ast();\n+        let attrs = &ast.attrs;\n+\n+        let implementation = {\n+            if let syn::Data::Struct(..) = ast.data {\n+                let preamble = {\n+                    let preamble = attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_structure_code(attr)\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+                    quote! {\n+                        #(#preamble)*;\n+                    }\n+                };\n+\n+                let body = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    let result = field.attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_field_code(\n+                                attr,\n+                                FieldInfo {\n+                                    vis: &field.vis,\n+                                    binding: field_binding,\n+                                    ty: &field.ty,\n+                                    span: &field.span(),\n+                                },\n+                            )\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+                    return quote! {\n+                        #(#result);*\n+                    };\n+                });\n+                // Finally, putting it altogether.\n+                match builder.kind {\n+                    None => {\n+                        span_err(ast.span().unwrap(), \"`code` not specified\")\n+                        .help(\"use the [code = \\\"...\\\"] attribute to set this diagnostic's error code \")\n+                        .emit();\n+                        SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+                    }\n+                    Some((kind, _)) => match kind {\n+                        DiagnosticId::Lint(_lint) => todo!(),\n+                        DiagnosticId::Error(code) => {\n+                            let (diag, sess) = (&builder.diag, &builder.sess);\n+                            quote! {\n+                                let mut #diag = #sess.struct_err_with_code(\"\", rustc_errors::DiagnosticId::Error(#code));\n+                                #preamble\n+                                match self {\n+                                    #body\n+                                }\n+                                #diag\n+                            }\n+                        }\n+                    },\n+                }\n+            } else {\n+                span_err(\n+                    ast.span().unwrap(),\n+                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n+                )\n+                .emit();\n+                SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+            }\n+        };\n+\n+        let sess = &builder.sess;\n+        structure.gen_impl(quote! {\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess>\n+                    for @Self\n+            {\n+                fn into_diagnostic(\n+                    self,\n+                    #sess: &'__session_diagnostic_sess rustc_session::Session\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess> {\n+                    #implementation\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the generate_*\n+/// methods from walking the attributes themselves.\n+struct FieldInfo<'a> {\n+    vis: &'a syn::Visibility,\n+    binding: &'a synstructure::BindingInfo<'a>,\n+    ty: &'a syn::Type,\n+    span: &'a proc_macro2::Span,\n+}\n+\n+/// Tracks persistent information required for building up the individual calls to diagnostic\n+/// methods for the final generated method. This is a separate struct to SessionDerive only to be\n+/// able to destructure and split self.builder and the self.structure up to avoid a double mut\n+/// borrow later on.\n+struct SessionDiagnosticDeriveBuilder<'a> {\n+    /// Name of the session parameter that's passed in to the as_error method.\n+    sess: syn::Ident,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, &'a syn::Field>,\n+\n+    /// The identifier to use for the generated DiagnosticBuilder instance.\n+    diag: syn::Ident,\n+\n+    /// Whether this is a lint or an error. This dictates how the diag will be initialised. Span\n+    /// stores at what Span the kind was first set at (for error reporting purposes, if the kind\n+    /// was multiply specified).\n+    kind: Option<(DiagnosticId, proc_macro2::Span)>,\n+}\n+\n+impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n+    fn generate_structure_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        Ok(match attr.parse_meta()? {\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                let formatted_str = self.build_format(&s.value(), attr.span());\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_str();\n+                match name {\n+                    \"message\" => {\n+                        let diag = &self.diag;\n+                        quote! {\n+                            #diag.set_primary_message(#formatted_str);\n+                        }\n+                    }\n+                    attr @ \"error\" | attr @ \"lint\" => {\n+                        self.set_kind_once(\n+                            if attr == \"error\" {\n+                                DiagnosticId::Error(formatted_str)\n+                            } else if attr == \"lint\" {\n+                                DiagnosticId::Lint(formatted_str)\n+                            } else {\n+                                unreachable!()\n+                            },\n+                            s.span(),\n+                        )?;\n+                        // This attribute is only allowed to be applied once, and the attribute\n+                        // will be set in the initialisation code.\n+                        quote! {}\n+                    }\n+                    other => throw_span_err!(\n+                        attr.span().unwrap(),\n+                        &format!(\n+                            \"`#[{} = ...]` is not a valid SessionDiagnostic struct attribute\",\n+                            other\n+                        )\n+                    ),\n+                }\n+            }\n+            _ => todo!(\"unhandled meta kind\"),\n+        })\n+    }\n+\n+    #[must_use]\n+    fn set_kind_once(\n+        &mut self,\n+        kind: DiagnosticId,\n+        span: proc_macro2::Span,\n+    ) -> Result<(), SessionDiagnosticDeriveError> {\n+        if self.kind.is_none() {\n+            self.kind = Some((kind, span));\n+            Ok(())\n+        } else {\n+            let kind_str = |kind: &DiagnosticId| match kind {\n+                DiagnosticId::Lint(..) => \"lint\",\n+                DiagnosticId::Error(..) => \"error\",\n+            };\n+\n+            let existing_kind = kind_str(&self.kind.as_ref().unwrap().0);\n+            let this_kind = kind_str(&kind);\n+\n+            let msg = if this_kind == existing_kind {\n+                format!(\"`{}` specified multiple times\", existing_kind)\n+            } else {\n+                format!(\"`{}` specified when `{}` was already specified\", this_kind, existing_kind)\n+            };\n+            throw_span_err!(span.unwrap(), &msg);\n+        }\n+    }\n+\n+    fn generate_field_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        let field_binding = &info.binding.binding;\n+\n+        let option_ty = option_inner_ty(&info.ty);\n+\n+        let generated_code = self.generate_non_option_field_code(\n+            attr,\n+            FieldInfo {\n+                vis: info.vis,\n+                binding: info.binding,\n+                ty: option_ty.unwrap_or(&info.ty),\n+                span: info.span,\n+            },\n+        )?;\n+        Ok(if option_ty.is_none() {\n+            quote! { #generated_code }\n+        } else {\n+            quote! {\n+                if let Some(#field_binding) = #field_binding {\n+                    #generated_code\n+                }\n+            }\n+        })\n+    }\n+\n+    fn generate_non_option_field_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+        let field_binding = &info.binding.binding;\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        // At this point, we need to dispatch based on the attribute key + the\n+        // type.\n+        let meta = attr.parse_meta()?;\n+        Ok(match meta {\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                let formatted_str = self.build_format(&s.value(), attr.span());\n+                match name {\n+                    \"message\" => {\n+                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                            quote! {\n+                                #diag.set_span(*#field_binding);\n+                                #diag.set_primary_message(#formatted_str);\n+                            }\n+                        } else {\n+                            throw_span_err!(\n+                                attr.span().unwrap(),\n+                                \"the `#[message = \\\"...\\\"]` attribute can only be applied to fields of type Span\"\n+                            );\n+                        }\n+                    }\n+                    \"label\" => {\n+                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                            quote! {\n+                                #diag.span_label(*#field_binding, #formatted_str);\n+                            }\n+                        } else {\n+                            throw_span_err!(\n+                                attr.span().unwrap(),\n+                                \"The `#[label = ...]` attribute can only be applied to fields of type Span\"\n+                            );\n+                        }\n+                    }\n+                    other => throw_span_err!(\n+                        attr.span().unwrap(),\n+                        &format!(\n+                            \"`#[{} = ...]` is not a valid SessionDiagnostic field attribute\",\n+                            other\n+                        )\n+                    ),\n+                }\n+            }\n+            syn::Meta::List(list) => {\n+                match list.path.segments.iter().last().unwrap().ident.to_string().as_str() {\n+                    suggestion_kind @ \"suggestion\"\n+                    | suggestion_kind @ \"suggestion_short\"\n+                    | suggestion_kind @ \"suggestion_hidden\"\n+                    | suggestion_kind @ \"suggestion_verbose\" => {\n+                        // For suggest, we need to ensure we are running on a (Span,\n+                        // Applicability) pair.\n+                        let (span, applicability) = (|| match &info.ty {\n+                            ty @ syn::Type::Path(..)\n+                                if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) =>\n+                            {\n+                                let binding = &info.binding.binding;\n+                                Ok((\n+                                    quote!(*#binding),\n+                                    quote!(rustc_errors::Applicability::Unspecified),\n+                                ))\n+                            }\n+                            syn::Type::Tuple(tup) => {\n+                                let mut span_idx = None;\n+                                let mut applicability_idx = None;\n+                                for (idx, elem) in tup.elems.iter().enumerate() {\n+                                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                                        if span_idx.is_none() {\n+                                            span_idx = Some(syn::Index::from(idx));\n+                                        } else {\n+                                            throw_span_err!(\n+                                                info.span.clone().unwrap(),\n+                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Span\"\n+                                            );\n+                                        }\n+                                    } else if type_matches_path(\n+                                        elem,\n+                                        &[\"rustc_errors\", \"Applicability\"],\n+                                    ) {\n+                                        if applicability_idx.is_none() {\n+                                            applicability_idx = Some(syn::Index::from(idx));\n+                                        } else {\n+                                            throw_span_err!(\n+                                                info.span.clone().unwrap(),\n+                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                                            );\n+                                        }\n+                                    }\n+                                }\n+                                if let Some(span_idx) = span_idx {\n+                                    let binding = &info.binding.binding;\n+                                    let span = quote!(#binding.#span_idx);\n+                                    let applicability = applicability_idx\n+                                        .map(\n+                                            |applicability_idx| quote!(#binding.#applicability_idx),\n+                                        )\n+                                        .unwrap_or(quote!(\n+                                            rustc_errors::Applicability::Unspecified\n+                                        ));\n+                                    return Ok((span, applicability));\n+                                }\n+                                throw_span_err!(\n+                                    info.span.clone().unwrap(),\n+                                    \"wrong types for suggestion\",\n+                                    |diag| {\n+                                        diag.help(\"#[suggestion(...)] on a tuple field must be applied to fields of type (Span, Applicability)\")\n+                                    }\n+                                );\n+                            }\n+                            _ => throw_span_err!(\n+                                info.span.clone().unwrap(),\n+                                \"wrong field type for suggestion\",\n+                                |diag| {\n+                                    diag.help(\"#[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\")\n+                                }\n+                            ),\n+                        })()?;\n+                        // Now read the key-value pairs.\n+                        let mut msg = None;\n+                        let mut code = None;\n+\n+                        for arg in list.nested.iter() {\n+                            if let syn::NestedMeta::Meta(syn::Meta::NameValue(arg_name_value)) = arg\n+                            {\n+                                if let syn::MetaNameValue { lit: syn::Lit::Str(s), .. } =\n+                                    arg_name_value\n+                                {\n+                                    let name = arg_name_value\n+                                        .path\n+                                        .segments\n+                                        .last()\n+                                        .unwrap()\n+                                        .ident\n+                                        .to_string();\n+                                    let name = name.as_str();\n+                                    let formatted_str = self.build_format(&s.value(), arg.span());\n+                                    match name {\n+                                        \"message\" => {\n+                                            msg = Some(formatted_str);\n+                                        }\n+                                        \"code\" => {\n+                                            code = Some(formatted_str);\n+                                        }\n+                                        other => throw_span_err!(\n+                                            arg.span().unwrap(),\n+                                            &format!(\n+                                                \"`{}` is not a valid key for `#[suggestion(...)]`\",\n+                                                other\n+                                            )\n+                                        ),\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        let msg = if let Some(msg) = msg {\n+                            quote!(#msg.as_str())\n+                        } else {\n+                            throw_span_err!(\n+                                list.span().unwrap(),\n+                                \"missing suggestion message\",\n+                                |diag| {\n+                                    diag.help(\"provide a suggestion message using #[suggestion(message = \\\"...\\\")]\")\n+                                }\n+                            );\n+                        };\n+                        let code = code.unwrap_or_else(|| quote! { String::new() });\n+                        // Now build it out:\n+                        let suggestion_method = format_ident!(\"span_{}\", suggestion_kind);\n+                        quote! {\n+                            #diag.#suggestion_method(#span, #msg, #code, #applicability);\n+                        }\n+                    }\n+                    other => throw_span_err!(\n+                        list.span().unwrap(),\n+                        &format!(\"invalid annotation list `#[{}(...)]`\", other)\n+                    ),\n+                }\n+            }\n+            _ => panic!(\"unhandled meta kind\"),\n+        })\n+    }\n+\n+    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n+    /// reference fields in the format string. Take this, for example:\n+    /// ```ignore (not-usage-example)\n+    /// struct Point {\n+    ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    /// ```\n+    /// We want to automatically pick up that {x} refers `self.x` and {y} refers to `self.y`, then\n+    /// generate this call to format!:\n+    /// ```ignore (not-usage-example)\n+    /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n+    /// ```\n+    /// This function builds the entire call to format!.\n+    fn build_format(&self, input: &String, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n+        let mut referenced_fields: HashSet<String> = HashSet::new();\n+\n+        // At this point, we can start parsing the format string.\n+        let mut it = input.chars().peekable();\n+        // Once the start of a format string has been found, process the format string and spit out\n+        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so the\n+        // next call to `it.next()` retrieves the next character.\n+        while let Some(c) = it.next() {\n+            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n+                #[must_use]\n+                let mut eat_argument = || -> Option<String> {\n+                    let mut result = String::new();\n+                    // Format specifiers look like\n+                    // format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                    while let Some(c) = it.next() {\n+                        result.push(c);\n+                        let next = *it.peek().unwrap_or(&'\\0');\n+                        if next == '}' {\n+                            break;\n+                        } else if next == ':' {\n+                            // Eat the ':' character.\n+                            assert_eq!(it.next().unwrap(), ':');\n+                            break;\n+                        }\n+                    }\n+                    // Eat until (and including) the matching '}'\n+                    while it.next()? != '}' {\n+                        continue;\n+                    }\n+                    Some(result)\n+                };\n+\n+                if let Some(referenced_field) = eat_argument() {\n+                    referenced_fields.insert(referenced_field);\n+                }\n+            }\n+        }\n+        // At this point, `referenced_fields` contains a set of the unique fields that were\n+        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n+        // string parameters:\n+        let args = referenced_fields.into_iter().map(|field: String| {\n+            let field_ident = format_ident!(\"{}\", field);\n+            let value = if self.fields.contains_key(&field) {\n+                quote! {\n+                    &self.#field_ident\n+                }\n+            } else {\n+                // This field doesn't exist. Emit a diagnostic.\n+                Diagnostic::spanned(\n+                    span.unwrap(),\n+                    proc_macro::Level::Error,\n+                    format!(\"`{}` doesn't refer to a field on this type\", field),\n+                )\n+                .emit();\n+                quote! {\n+                    \"{#field}\"\n+                }\n+            };\n+            quote! {\n+                #field_ident = #value\n+            }\n+        });\n+        quote! {\n+            format!(#input #(,#args)*)\n+        }\n+    }\n+}\n+\n+/// If `ty` is an Option, returns Some(inner type). Else, returns None.\n+fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n+    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+        if let syn::Type::Path(ty_path) = ty {\n+            let path = &ty_path.path;\n+            let ty = path.segments.iter().last().unwrap();\n+            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n+                if bracketed.args.len() == 1 {\n+                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    None\n+}"}, {"sha": "05780d2e0c40b5c249a5384ceb943d50c43a7399", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -237,6 +237,14 @@ enum DiagnosticBuilderMethod {\n                             // Add more variants as needed to support one-time diagnostics.\n }\n \n+/// Trait implemented by error types. This should not be implemented manually. Instead, use\n+/// `#[derive(SessionDiagnostic)]` -- see [rustc_macros::SessionDiagnostic].\n+pub trait SessionDiagnostic<'a> {\n+    /// Write out as a diagnostic out of `sess`.\n+    #[must_use]\n+    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a>;\n+}\n+\n /// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n /// emitting the same message more than once.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -392,6 +400,9 @@ impl Session {\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n     }\n+    pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) {\n+        err.into_diagnostic(self).emit()\n+    }\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()\n     }"}, {"sha": "08f4e4a31109871a6b1a177be7cf034431a255ba", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -18,6 +18,7 @@ use crate::astconv::{AstConv, SizedByDefault};\n use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n+use crate::errors;\n use crate::middle::resolve_lifetime as rl;\n use rustc_ast as ast;\n use rustc_ast::MetaItemKind;\n@@ -834,16 +835,11 @@ fn convert_variant(\n             let fid = tcx.hir().local_def_id(f.hir_id);\n             let dup_span = seen_fields.get(&f.ident.normalize_to_macros_2_0()).cloned();\n             if let Some(prev_span) = dup_span {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    f.span,\n-                    E0124,\n-                    \"field `{}` is already declared\",\n-                    f.ident\n-                )\n-                .span_label(f.span, \"field already declared\")\n-                .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n-                .emit();\n+                tcx.sess.emit_err(errors::FieldAlreadyDeclared {\n+                    field_name: f.ident,\n+                    span: f.span,\n+                    prev_span,\n+                });\n             } else {\n                 seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }"}, {"sha": "9a9eea4f995f143cbd9940cdf529220414d37586", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -0,0 +1,14 @@\n+//! Errors emitted by typeck.\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{symbol::Ident, Span };\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0124\"]\n+pub struct FieldAlreadyDeclared {\n+    pub field_name: Ident,\n+    #[message = \"field `{field_name}` is already declared\"]\n+    #[label = \"field already declared\"]\n+    pub span: Span,\n+    #[label = \"`{field_name}` first declared here\"]\n+    pub prev_span: Span,\n+}"}, {"sha": "428b4662b84e79348fc46e8aab8e8becaff9c2a6", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -84,6 +84,7 @@ mod check_unused;\n mod coherence;\n mod collect;\n mod constrained_generic_params;\n+mod errors;\n mod impl_wf_check;\n mod mem_categorization;\n mod outlives;"}, {"sha": "7967b32a4a49113ecb12c08910f7b499c1ef7784", "filename": "src/test/ui-fulldeps/session-derive-errors.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -0,0 +1,260 @@\n+// check-fail\n+// Tests error conditions for specifying diagnostics using #[derive(SessionDiagnostic)]\n+\n+#![feature(rustc_private)]\n+#![crate_type = \"lib\"]\n+\n+extern crate rustc_span;\n+use rustc_span::Span;\n+use rustc_span::symbol::Ident;\n+\n+extern crate rustc_macros;\n+use rustc_macros::SessionDiagnostic;\n+\n+extern crate rustc_middle;\n+use rustc_middle::ty::Ty;\n+\n+extern crate rustc_errors;\n+use rustc_errors::Applicability;\n+\n+extern crate rustc_session;\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[error = \"E0123\"]\n+struct Hello {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+//~^ ERROR `#[derive(SessionDiagnostic)]` can only be used on structs\n+enum SessionDiagnosticOnEnum {\n+    Foo,\n+    Bar,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[label = \"This is in the wrong place\"]\n+//~^ ERROR `#[label = ...]` is not a valid SessionDiagnostic struct attribute\n+struct WrongPlace {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct WrongPlaceField {\n+    #[suggestion = \"this is the wrong kind of attribute\"]\n+//~^ ERROR `#[suggestion = ...]` is not a valid SessionDiagnostic field attribute\n+    sp: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[error = \"E0123\"]\n+#[error = \"E0456\"] //~ ERROR `error` specified multiple times\n+struct ErrorSpecifiedTwice {}\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[error = \"E0123\"]\n+#[lint = \"some_useful_lint\"] //~ ERROR `lint` specified when `error` was already specified\n+struct LintSpecifiedAfterError {}\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Some lint message\"]\n+#[error = \"E0123\"]\n+struct LintButHasErrorCode {}\n+\n+#[derive(SessionDiagnostic)]\n+struct ErrorCodeNotProvided {} //~ ERROR `code` not specified\n+\n+// FIXME: Uncomment when emitting lints is supported.\n+/*\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[lint = \"clashing_extern_declarations\"]\n+#[lint = \"improper_ctypes\"] // FIXME: ERROR `lint` specified multiple times\n+struct LintSpecifiedTwice {}\n+\n+#[derive(SessionDiagnostic)]\n+#[lint = \"Some lint message\"]\n+#[message = \"Some error message\"]\n+#[error = \"E0123\"] // ERROR `error` specified when `lint` was already specified\n+struct ErrorSpecifiedAfterLint {}\n+*/\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct ErrorWithField {\n+    name: String,\n+    #[message = \"This error has a field, and references {name}\"]\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct ErrorWithMessageAppliedToField {\n+    #[message = \"this message is applied to a String field\"]\n+    //~^ ERROR the `#[message = \"...\"]` attribute can only be applied to fields of type Span\n+    name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"This error has a field, and references {name}\"]\n+//~^ ERROR `name` doesn't refer to a field on this type\n+struct ErrorWithNonexistentField {\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"This is missing a closing brace: {name\"]\n+//~^ ERROR invalid format string: expected `'}'`\n+struct ErrorMissingClosingBrace {\n+    name: String,\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"This is missing an opening brace: name}\"]\n+//~^ ERROR invalid format string: unmatched `}`\n+struct ErrorMissingOpeningBrace {\n+    name: String,\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"Something something\"]\n+struct LabelOnSpan {\n+    #[label = \"See here\"]\n+    sp: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"Something something\"]\n+struct LabelOnNonSpan {\n+    #[label = \"See here\"]\n+    //~^ ERROR The `#[label = ...]` attribute can only be applied to fields of type Span\n+    id: u32,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct Suggest {\n+    #[suggestion(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion_short(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion_hidden(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion_verbose(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithoutCode {\n+    #[suggestion(message = \"This is a suggestion\")]\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithBadKey {\n+    #[suggestion(nonsense = \"This is nonsense\")]\n+    //~^ ERROR `nonsense` is not a valid key for `#[suggestion(...)]`\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithShorthandMsg {\n+    #[suggestion(msg = \"This is a suggestion\")]\n+    //~^ ERROR `msg` is not a valid key for `#[suggestion(...)]`\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithoutMsg {\n+    #[suggestion(code = \"This is suggested code\")]\n+    //~^ ERROR missing suggestion message\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithTypesSwapped {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    suggestion: (Applicability, Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithWrongTypeApplicabilityOnly {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    //~^ ERROR wrong field type for suggestion\n+    suggestion: Applicability,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithSpanOnly{\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    suggestion: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithDuplicateSpanAndApplicability {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one Span\n+    suggestion: (Span, Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithDuplicateApplicabilityAndSpan {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n+    suggestion: (Applicability, Applicability, Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct WrongKindOfAnnotation {\n+    #[label(\"wrong kind of annotation for label\")]\n+    //~^ ERROR invalid annotation list `#[label(...)]`\n+    z: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"Something something else\"]\n+struct OptionsInErrors {\n+    #[label = \"Label message\"]\n+    label: Option<Span>,\n+    #[suggestion(message = \"suggestion message\")]\n+    opt_sugg: Option<(Span, Applicability)>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0456\"]\n+struct MoveOutOfBorrowError<'tcx> {\n+    name: Ident,\n+    ty: Ty<'tcx>,\n+    #[message = \"cannot move {ty} out of borrow\"]\n+    #[label = \"cannot move out of borrow\"]\n+    span: Span,\n+    #[label = \"`{ty}` first borrowed here\"]\n+    other_span: Span,\n+    #[suggestion(message = \"consider cloning here\", code = \"{name}.clone()\")]\n+    opt_sugg: Option<(Span, Applicability)>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct ErrorWithLifetime<'a> {\n+    #[message = \"Some message that references {name}\"]\n+    span: Span,\n+    name: &'a str,\n+}"}, {"sha": "c1be151f1c1ce5d28f2a41e10d6e00e5f34140f2", "filename": "src/test/ui-fulldeps/session-derive-errors.stderr", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/93eaf15646e980a5e578eb58f295b9a066b7560f/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93eaf15646e980a5e578eb58f295b9a066b7560f/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr?ref=93eaf15646e980a5e578eb58f295b9a066b7560f", "patch": "@@ -0,0 +1,135 @@\n+error: `#[derive(SessionDiagnostic)]` can only be used on structs\n+  --> $DIR/session-derive-errors.rs:28:1\n+   |\n+LL | / #[error = \"E0123\"]\n+LL | |\n+LL | | enum SessionDiagnosticOnEnum {\n+LL | |     Foo,\n+LL | |     Bar,\n+LL | | }\n+   | |_^\n+\n+error: `#[label = ...]` is not a valid SessionDiagnostic struct attribute\n+  --> $DIR/session-derive-errors.rs:37:1\n+   |\n+LL | #[label = \"This is in the wrong place\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[suggestion = ...]` is not a valid SessionDiagnostic field attribute\n+  --> $DIR/session-derive-errors.rs:44:5\n+   |\n+LL |     #[suggestion = \"this is the wrong kind of attribute\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `error` specified multiple times\n+  --> $DIR/session-derive-errors.rs:52:11\n+   |\n+LL | #[error = \"E0456\"]\n+   |           ^^^^^^^\n+\n+error: `lint` specified when `error` was already specified\n+  --> $DIR/session-derive-errors.rs:58:10\n+   |\n+LL | #[lint = \"some_useful_lint\"]\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: `code` not specified\n+  --> $DIR/session-derive-errors.rs:67:1\n+   |\n+LL | struct ErrorCodeNotProvided {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use the [code = \"...\"] attribute to set this diagnostic's error code \n+\n+error: the `#[message = \"...\"]` attribute can only be applied to fields of type Span\n+  --> $DIR/session-derive-errors.rs:95:5\n+   |\n+LL |     #[message = \"this message is applied to a String field\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `name` doesn't refer to a field on this type\n+  --> $DIR/session-derive-errors.rs:102:1\n+   |\n+LL | #[message = \"This error has a field, and references {name}\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/session-derive-errors.rs:110:1\n+   |\n+LL | #[error = \"E0123\"]\n+   |               - because of this opening brace\n+LL | #[message = \"This is missing a closing brace: {name\"]\n+   | ^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/session-derive-errors.rs:119:1\n+   |\n+LL | #[message = \"This is missing an opening brace: name}\"]\n+   | ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: The `#[label = ...]` attribute can only be applied to fields of type Span\n+  --> $DIR/session-derive-errors.rs:138:5\n+   |\n+LL |     #[label = \"See here\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `nonsense` is not a valid key for `#[suggestion(...)]`\n+  --> $DIR/session-derive-errors.rs:163:18\n+   |\n+LL |     #[suggestion(nonsense = \"This is nonsense\")]\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `msg` is not a valid key for `#[suggestion(...)]`\n+  --> $DIR/session-derive-errors.rs:171:18\n+   |\n+LL |     #[suggestion(msg = \"This is a suggestion\")]\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing suggestion message\n+  --> $DIR/session-derive-errors.rs:179:7\n+   |\n+LL |     #[suggestion(code = \"This is suggested code\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: provide a suggestion message using #[suggestion(message = \"...\")]\n+\n+error: wrong field type for suggestion\n+  --> $DIR/session-derive-errors.rs:194:5\n+   |\n+LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | |\n+LL | |     suggestion: Applicability,\n+   | |_____________________________^\n+   |\n+   = help: #[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\n+\n+error: type of field annotated with `#[suggestion(...)]` contains more than one Span\n+  --> $DIR/session-derive-errors.rs:209:5\n+   |\n+LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | |\n+LL | |     suggestion: (Span, Span, Applicability),\n+   | |___________________________________________^\n+\n+error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n+  --> $DIR/session-derive-errors.rs:217:5\n+   |\n+LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | |\n+LL | |     suggestion: (Applicability, Applicability, Span),\n+   | |____________________________________________________^\n+\n+error: invalid annotation list `#[label(...)]`\n+  --> $DIR/session-derive-errors.rs:225:7\n+   |\n+LL |     #[label(\"wrong kind of annotation for label\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 18 previous errors\n+"}]}