{"sha": "454bca514aab74a8c3c746908cac2d9c61300941", "node_id": "C_kwDOAAsO6NoAKDQ1NGJjYTUxNGFhYjc0YThjM2M3NDY5MDhjYWMyZDljNjEzMDA5NDE", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-06T20:53:10Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-06T20:53:10Z"}, "message": "Check `CastKind::Transmute` sizes in a better way\n\nFixes #110005", "tree": {"sha": "366b6b4a468f1c56dd398966ada278e6665f70ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/366b6b4a468f1c56dd398966ada278e6665f70ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/454bca514aab74a8c3c746908cac2d9c61300941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/454bca514aab74a8c3c746908cac2d9c61300941", "html_url": "https://github.com/rust-lang/rust/commit/454bca514aab74a8c3c746908cac2d9c61300941", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/454bca514aab74a8c3c746908cac2d9c61300941/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f6edd3f15f75f0df70027edee2a520820d14217", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6edd3f15f75f0df70027edee2a520820d14217", "html_url": "https://github.com/rust-lang/rust/commit/7f6edd3f15f75f0df70027edee2a520820d14217"}], "stats": {"total": 166, "additions": 134, "deletions": 32}, "files": [{"sha": "b37797fef4ce3d10a6406247e9be3be250174805", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/454bca514aab74a8c3c746908cac2d9c61300941/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454bca514aab74a8c3c746908cac2d9c61300941/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=454bca514aab74a8c3c746908cac2d9c61300941", "patch": "@@ -259,6 +259,31 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n+    /// Returns an `OperandValue` that's generally UB to use in any way.\n+    ///\n+    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n+    /// poison value(s), or a `Ref` containing a poison pointer.\n+    ///\n+    /// Supports sized types only.\n+    pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> OperandValue<V> {\n+        assert!(layout.is_sized());\n+        if bx.cx().is_backend_immediate(layout) {\n+            let ibty = bx.cx().immediate_backend_type(layout);\n+            OperandValue::Immediate(bx.const_poison(ibty))\n+        } else if bx.cx().is_backend_scalar_pair(layout) {\n+            let ibty0 = bx.cx().scalar_pair_element_backend_type(layout, 0, true);\n+            let ibty1 = bx.cx().scalar_pair_element_backend_type(layout, 1, true);\n+            OperandValue::Pair(bx.const_poison(ibty0), bx.const_poison(ibty1))\n+        } else {\n+            let bty = bx.cx().backend_type(layout);\n+            let ptr_bty = bx.cx().type_ptr_to(bty);\n+            OperandValue::Ref(bx.const_poison(ptr_bty), None, layout.align.abi)\n+        }\n+    }\n+\n     pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,"}, {"sha": "6e4c0be12f0838102d63571abda87d7b4638927d", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/454bca514aab74a8c3c746908cac2d9c61300941/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454bca514aab74a8c3c746908cac2d9c61300941/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=454bca514aab74a8c3c746908cac2d9c61300941", "patch": "@@ -158,17 +158,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         debug_assert!(src.layout.is_sized());\n         debug_assert!(dst.layout.is_sized());\n \n-        if src.layout.size != dst.layout.size\n-            || src.layout.abi.is_uninhabited()\n-            || dst.layout.abi.is_uninhabited()\n-        {\n-            // In all of these cases it's UB to run this transmute, but that's\n-            // known statically so might as well trap for it, rather than just\n-            // making it unreachable.\n-            bx.abort();\n-            return;\n-        }\n-\n         if let Some(val) = self.codegen_transmute_operand(bx, src, dst.layout) {\n             val.store(bx, dst);\n             return;\n@@ -202,8 +191,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         operand: OperandRef<'tcx, Bx::Value>,\n         cast: TyAndLayout<'tcx>,\n     ) -> Option<OperandValue<Bx::Value>> {\n-        // Callers already checked that the layout sizes match\n-        debug_assert_eq!(operand.layout.size, cast.size);\n+        // Check for transmutes that are always UB.\n+        if operand.layout.size != cast.size\n+            || operand.layout.abi.is_uninhabited()\n+            || cast.abi.is_uninhabited()\n+        {\n+            if !operand.layout.abi.is_uninhabited() {\n+                // Since this is known statically and the input could have existed\n+                // without already having hit UB, might as well trap for it.\n+                bx.abort();\n+            }\n+\n+            // Because this transmute is UB, return something easy to generate,\n+            // since it's fine that later uses of the value are probably UB.\n+            return Some(OperandValue::poison(bx, cast));\n+        }\n \n         let operand_kind = self.value_kind(operand.layout);\n         let cast_kind = self.value_kind(cast);\n@@ -221,11 +223,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let OperandValueKind::Immediate(in_scalar) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n+                if let OperandValueKind::Immediate(out_scalar) = cast_kind\n+                    && in_scalar.size(self.cx) == out_scalar.size(self.cx)\n+                {\n                     let cast_bty = bx.backend_type(cast);\n-                    Some(OperandValue::Immediate(Self::transmute_immediate(\n-                        bx, imm, in_scalar, out_scalar, cast_bty,\n-                    )))\n+                    Some(OperandValue::Immediate(\n+                        self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n+                    ))\n                 } else {\n                     None\n                 }\n@@ -234,12 +238,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let OperandValueKind::Pair(in_a, in_b) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Pair(out_a, out_b) = cast_kind {\n+                if let OperandValueKind::Pair(out_a, out_b) = cast_kind\n+                    && in_a.size(self.cx) == out_a.size(self.cx)\n+                    && in_b.size(self.cx) == out_b.size(self.cx)\n+                {\n                     let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n                     let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n                     Some(OperandValue::Pair(\n-                        Self::transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n-                        Self::transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n                     ))\n                 } else {\n                     None\n@@ -254,12 +261,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// `to_backend_ty` must be the *non*-immediate backend type (so it will be\n     /// `i8`, not `i1`, for `bool`-like types.)\n     fn transmute_immediate(\n+        &self,\n         bx: &mut Bx,\n         mut imm: Bx::Value,\n         from_scalar: abi::Scalar,\n         to_scalar: abi::Scalar,\n         to_backend_ty: Bx::Type,\n     ) -> Bx::Value {\n+        debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n+\n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n@@ -831,14 +841,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let operand_ty = operand.ty(self.mir, self.cx.tcx());\n                 let cast_layout = self.cx.layout_of(self.monomorphize(cast_ty));\n                 let operand_layout = self.cx.layout_of(self.monomorphize(operand_ty));\n-                if operand_layout.size != cast_layout.size\n-                    || operand_layout.abi.is_uninhabited()\n-                    || cast_layout.abi.is_uninhabited()\n-                {\n-                    // Send UB cases to the full form so the operand version can\n-                    // `bitcast` without worrying about malformed IR.\n-                    return false;\n-                }\n \n                 match (self.value_kind(operand_layout), self.value_kind(cast_layout)) {\n                     // Can always load from a pointer as needed\n@@ -847,9 +849,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Need to generate an `alloc` to get a pointer from an immediate\n                     (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n \n-                    // When we have scalar immediates, we can convert them as needed\n-                    (OperandValueKind::Immediate(..), OperandValueKind::Immediate(..)) |\n-                    (OperandValueKind::Pair(..), OperandValueKind::Pair(..)) => true,\n+                    // When we have scalar immediates, we can only convert things\n+                    // where the sizes match, to avoid endianness questions.\n+                    (OperandValueKind::Immediate(a), OperandValueKind::Immediate(b)) =>\n+                        a.size(self.cx) == b.size(self.cx),\n+                    (OperandValueKind::Pair(a0, a1), OperandValueKind::Pair(b0, b1)) =>\n+                        a0.size(self.cx) == b0.size(self.cx) && a1.size(self.cx) == b1.size(self.cx),\n \n                     // Send mixings between scalars and pairs through the memory route\n                     // FIXME: Maybe this could use insertvalue/extractvalue instead?"}, {"sha": "c2295ca9a0c3c3688fbf3ebae2a5fe44d4be1db5", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/454bca514aab74a8c3c746908cac2d9c61300941/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454bca514aab74a8c3c746908cac2d9c61300941/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=454bca514aab74a8c3c746908cac2d9c61300941", "patch": "@@ -54,6 +54,32 @@ pub unsafe fn check_smaller_size(x: u32) -> u16 {\n     }\n }\n \n+// CHECK-LABEL: @check_smaller_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_smaller_array(x: [u32; 7]) -> [u32; 3] {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_bigger_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_to_uninhabited(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n@@ -71,7 +97,7 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_from_uninhabited(x: BigNever) -> u16 {\n-    // CHECK: call void @llvm.trap\n+    // CHECK: ret i16 poison\n     mir!{\n         {\n             RET = CastTransmute(x);\n@@ -301,3 +327,49 @@ pub unsafe fn check_pair_to_array(x: (i64, u64)) -> [u8; 16] {\n     // CHECK: store i64 %x.1, ptr %{{.+}}, align 1\n     transmute(x)\n }\n+\n+// CHECK-LABEL: @check_heterogeneous_integer_pair(\n+#[no_mangle]\n+pub unsafe fn check_heterogeneous_integer_pair(x: (i32, bool)) -> (bool, u32) {\n+    // CHECK: store i32 %x.0\n+    // CHECK: %[[WIDER:.+]] = zext i1 %x.1 to i8\n+    // CHECK: store i8 %[[WIDER]]\n+\n+    // CHECK: %[[BYTE:.+]] = load i8\n+    // CHECK: trunc i8 %[[BYTE:.+]] to i1\n+    // CHECK: load i32\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_heterogeneous_float_pair(\n+#[no_mangle]\n+pub unsafe fn check_heterogeneous_float_pair(x: (f64, f32)) -> (f32, f64) {\n+    // CHECK: store double %x.0\n+    // CHECK: store float %x.1\n+    // CHECK: %[[A:.+]] = load float\n+    // CHECK: %[[B:.+]] = load double\n+    // CHECK: %[[P:.+]] = insertvalue { float, double } poison, float %[[A]], 0\n+    // CHECK: insertvalue { float, double } %[[P]], double %[[B]], 1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_issue_110005(\n+#[no_mangle]\n+pub unsafe fn check_issue_110005(x: (usize, bool)) -> Option<Box<[u8]>> {\n+    // CHECK: store i64 %x.0\n+    // CHECK: %[[WIDER:.+]] = zext i1 %x.1 to i8\n+    // CHECK: store i8 %[[WIDER]]\n+    // CHECK: load ptr\n+    // CHECK: load i64\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_pair_to_dst_ref(\n+#[no_mangle]\n+pub unsafe fn check_pair_to_dst_ref<'a>(x: (usize, usize)) -> &'a [u8] {\n+    // CHECK: %0 = inttoptr i64 %x.0 to ptr\n+    // CHECK: %1 = insertvalue { ptr, i64 } poison, ptr %0, 0\n+    // CHECK: %2 = insertvalue { ptr, i64 } %1, i64 %x.1, 1\n+    // CHECK: ret { ptr, i64 } %2\n+    transmute(x)\n+}"}]}