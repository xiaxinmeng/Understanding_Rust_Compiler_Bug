{"sha": "667276040feda6db6b4515ae7e82d7f4e1309f30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NzI3NjA0MGZlZGE2ZGI2YjQ1MTVhZTdlODJkN2Y0ZTEzMDlmMzA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-19T20:57:48Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-09-22T21:54:10Z"}, "message": "Remove lies about task scheduling\n\nit's 1:1 by default now, and N:M is on its way out", "tree": {"sha": "6d8ebe9c251550a03a4d8a685598d0a3f8899059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d8ebe9c251550a03a4d8a685598d0a3f8899059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/667276040feda6db6b4515ae7e82d7f4e1309f30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/667276040feda6db6b4515ae7e82d7f4e1309f30", "html_url": "https://github.com/rust-lang/rust/commit/667276040feda6db6b4515ae7e82d7f4e1309f30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/667276040feda6db6b4515ae7e82d7f4e1309f30/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdd511d124523707b20227a7497aced1540add7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd511d124523707b20227a7497aced1540add7e", "html_url": "https://github.com/rust-lang/rust/commit/fdd511d124523707b20227a7497aced1540add7e"}], "stats": {"total": 59, "additions": 11, "deletions": 48}, "files": [{"sha": "67a2e4d4e1b456cc7f96279389de07075364d111", "filename": "src/doc/reference.md", "status": "modified", "additions": 11, "deletions": 48, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/667276040feda6db6b4515ae7e82d7f4e1309f30/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/667276040feda6db6b4515ae7e82d7f4e1309f30/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=667276040feda6db6b4515ae7e82d7f4e1309f30", "patch": "@@ -4041,47 +4041,20 @@ let y = x;\n An executing Rust program consists of a tree of tasks. A Rust _task_ consists\n of an entry function, a stack, a set of outgoing communication channels and\n incoming communication ports, and ownership of some portion of the heap of a\n-single operating-system process. (We expect that many programs will not use\n-channels and ports directly, but will instead use higher-level abstractions\n-provided in standard libraries, such as pipes.)\n-\n-Multiple Rust tasks may coexist in a single operating-system process. The\n-runtime scheduler maps tasks to a certain number of operating-system threads.\n-By default, the scheduler chooses the number of threads based on the number of\n-concurrent physical CPUs detected at startup. It's also possible to override\n-this choice at runtime. When the number of tasks exceeds the number of threads\n-&mdash; which is likely &mdash; the scheduler multiplexes the tasks onto\n-threads.[^mnscheduler]\n-\n-[^mnscheduler]: This is an M:N scheduler, which is known to give suboptimal\n-    results for CPU-bound concurrency problems. In such cases, running with the\n-    same number of threads and tasks can yield better results. Rust has M:N\n-    scheduling in order to support very large numbers of tasks in contexts where\n-    threads are too resource-intensive to use in large number. The cost of\n-    threads varies substantially per operating system, and is sometimes quite\n-    low, so this flexibility is not always worth exploiting.\n+single operating-system process.\n \n ### Communication between tasks\n \n-Rust tasks are isolated and generally unable to interfere with one another's memory directly,\n-except through [`unsafe` code](#unsafe-functions).\n-All contact between tasks is mediated by safe forms of ownership transfer,\n-and data races on memory are prohibited by the type system.\n-\n-Inter-task communication and co-ordination facilities are provided in the\n-standard library. These include:\n-\n-- synchronous and asynchronous communication channels with various\n-  communication topologies\n-- read-only and read-write shared variables with various safe mutual exclusion\n-  patterns\n-- simple locks and semaphores\n-\n-When such facilities carry values, the values are restricted to the [`Send`\n-type-kind](#type-kinds). Restricting communication interfaces to this kind\n-ensures that no references or managed pointers move between tasks. Thus access\n-to an entire data structure can be mediated through its owning \"root\" value; no\n-further locking or copying is required to avoid data races within the\n+Rust tasks are isolated and generally unable to interfere with one another's\n+memory directly, except through [`unsafe` code](#unsafe-functions).  All\n+contact between tasks is mediated by safe forms of ownership transfer, and data\n+races on memory are prohibited by the type system.\n+\n+When you wish to send data between tasks, the values are restricted to the\n+[`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n+kind ensures that no references or managed pointers move between tasks. Thus\n+access to an entire data structure can be mediated through its owning \"root\"\n+value; no further locking or copying is required to avoid data races within the\n substructure of such a value.\n \n ### Task lifecycle\n@@ -4123,16 +4096,6 @@ A task in the *dead* state cannot transition to other states; it exists only to\n have its termination status inspected by other tasks, and/or to await\n reclamation when the last reference to it drops.\n \n-### Task scheduling\n-\n-The currently scheduled task is given a finite *time slice* in which to\n-execute, after which it is *descheduled* at a loop-edge or similar preemption\n-point, and another task within is scheduled, pseudo-randomly.\n-\n-An executing task can yield control at any time, by making a library call to\n-`std::task::yield`, which deschedules it immediately. Entering any other\n-non-executing state (blocked, dead) similarly deschedules the task.\n-\n # Runtime services, linkage and debugging\n \n The Rust _runtime_ is a relatively compact collection of C++ and Rust code that"}]}