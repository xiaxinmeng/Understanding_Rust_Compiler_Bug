{"sha": "ca1e379090d0aa27d4fb8b71210311d96c174e7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMWUzNzkwOTBkMGFhMjdkNGZiOGI3MTIxMDMxMWQ5NmMxNzRlN2M=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-13T16:21:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-13T16:21:40Z"}, "message": "Rollup merge of #57102 - davidtwco:issue-57100, r=nikomatsakis\n\nNLL: Add union justifications to conflicting borrows.\n\nFixes #57100.\n\nThis PR adds justifications to error messages for conflicting borrows of union fields.\n\nWhere previously an error message would say ``cannot borrow `u.b` as mutable..``, it now says ``cannot borrow `u` (via `u.b`) as mutable..``.\n\nr? @pnkfelix", "tree": {"sha": "66ec598a378419a4f72e46d62857e0a8f0ebddbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66ec598a378419a4f72e46d62857e0a8f0ebddbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca1e379090d0aa27d4fb8b71210311d96c174e7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcO2WUCRBK7hj4Ov3rIwAAdHIIAIDgW8IUo8VT0Q1sgRl/FqZX\nFRd6hffVsUKfZSQtFozRqGI3eRca80EViFBgEIKEMfWyJHcuOJYUaaXgVQLbqztQ\nBOyVTWIVqC9tigTC4geIgCxZ8/8UUrHEaMsWXPwXaMyDllI6tJsb0WuGAkG3V6w/\nuNUeHngJkq9bq10lkjWUNefWE/1PUNYZqWMA7oA5phA91mvO9gDhA+TFTESHaoHm\nYi+9gZ7eXZKy2zzhBulKLHGvz3h8hdeMT//1D4WWZE7OKP5nf0k5Xgu1YdfQBMjK\nAdgkVextraly7VgDO314DYkPSw80a9jvLsw51Ht++Yw6xSx3x35NyXtnW+FcEkM=\n=gA35\n-----END PGP SIGNATURE-----\n", "payload": "tree 66ec598a378419a4f72e46d62857e0a8f0ebddbf\nparent b1200a29b07dddb9c05b99166c7b676b6f2dbb4b\nparent c2b477c19af9c5b8241e3d37a9d8a9cf1616750f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547396500 +0100\ncommitter GitHub <noreply@github.com> 1547396500 +0100\n\nRollup merge of #57102 - davidtwco:issue-57100, r=nikomatsakis\n\nNLL: Add union justifications to conflicting borrows.\n\nFixes #57100.\n\nThis PR adds justifications to error messages for conflicting borrows of union fields.\n\nWhere previously an error message would say ``cannot borrow `u.b` as mutable..``, it now says ``cannot borrow `u` (via `u.b`) as mutable..``.\n\nr? @pnkfelix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1e379090d0aa27d4fb8b71210311d96c174e7c", "html_url": "https://github.com/rust-lang/rust/commit/ca1e379090d0aa27d4fb8b71210311d96c174e7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca1e379090d0aa27d4fb8b71210311d96c174e7c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1200a29b07dddb9c05b99166c7b676b6f2dbb4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1200a29b07dddb9c05b99166c7b676b6f2dbb4b", "html_url": "https://github.com/rust-lang/rust/commit/b1200a29b07dddb9c05b99166c7b676b6f2dbb4b"}, {"sha": "c2b477c19af9c5b8241e3d37a9d8a9cf1616750f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b477c19af9c5b8241e3d37a9d8a9cf1616750f", "html_url": "https://github.com/rust-lang/rust/commit/c2b477c19af9c5b8241e3d37a9d8a9cf1616750f"}], "stats": {"total": 519, "additions": 366, "deletions": 153}, "files": [{"sha": "cafb29ed99a416b886d7289db2f70200b3c636cc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -557,12 +557,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 if new_loan.loan_path.has_fork(&old_loan.loan_path) && common.is_some() {\n                     let nl = self.bccx.loan_path_to_string(&common.unwrap());\n                     let ol = nl.clone();\n-                    let new_loan_msg = format!(\" (via `{}`)\",\n-                                               self.bccx.loan_path_to_string(\n-                                                   &new_loan.loan_path));\n-                    let old_loan_msg = format!(\" (via `{}`)\",\n-                                               self.bccx.loan_path_to_string(\n-                                                   &old_loan.loan_path));\n+                    let new_loan_msg = self.bccx.loan_path_to_string(&new_loan.loan_path);\n+                    let old_loan_msg = self.bccx.loan_path_to_string(&old_loan.loan_path);\n                     (nl, ol, new_loan_msg, old_loan_msg)\n                 } else {\n                     (self.bccx.loan_path_to_string(&new_loan.loan_path),"}, {"sha": "233db12b03001967b728223f2759258cf51d80c9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 116, "deletions": 10, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -327,10 +327,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"closure\"\n         };\n \n-        let desc_place = self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n-        let tcx = self.infcx.tcx;\n-\n-        let first_borrow_desc;\n+        let (desc_place, msg_place, msg_borrow, union_type_name) =\n+            self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n \n         let explanation = self.explain_why_borrow_contains_point(context, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() {\n@@ -340,6 +338,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         };\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let tcx = self.infcx.tcx;\n+        let first_borrow_desc;\n         let mut err = match (\n             gen_borrow_kind,\n             \"immutable\",\n@@ -353,12 +353,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n-                    \"\",\n+                    &msg_place,\n                     lft,\n                     issued_span,\n                     \"it\",\n                     rgt,\n-                    \"\",\n+                    &msg_borrow,\n                     None,\n                     Origin::Mir,\n                 )\n@@ -368,12 +368,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n-                    \"\",\n+                    &msg_place,\n                     lft,\n                     issued_span,\n                     \"it\",\n                     rgt,\n-                    \"\",\n+                    &msg_borrow,\n                     None,\n                     Origin::Mir,\n                 )\n@@ -384,9 +384,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 tcx.cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n-                    \"\",\n+                    &msg_place,\n                     issued_span,\n-                    \"\",\n+                    &msg_borrow,\n                     None,\n                     Origin::Mir,\n                 )\n@@ -510,12 +510,118 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n+        if union_type_name != \"\" {\n+            err.note(&format!(\n+                \"`{}` is a field of the union `{}`, so it overlaps the field `{}`\",\n+                msg_place, union_type_name, msg_borrow,\n+            ));\n+        }\n+\n         explanation\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, first_borrow_desc);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    /// Returns the description of the root place for a conflicting borrow and the full\n+    /// descriptions of the places that caused the conflict.\n+    ///\n+    /// In the simplest case, where there are no unions involved, if a mutable borrow of `x` is\n+    /// attempted while a shared borrow is live, then this function will return:\n+    ///\n+    ///     (\"x\", \"\", \"\")\n+    ///\n+    /// In the simple union case, if a mutable borrow of a union field `x.z` is attempted while\n+    /// a shared borrow of another field `x.y`, then this function will return:\n+    ///\n+    ///     (\"x\", \"x.z\", \"x.y\")\n+    ///\n+    /// In the more complex union case, where the union is a field of a struct, then if a mutable\n+    /// borrow of a union field in a struct `x.u.z` is attempted while a shared borrow of\n+    /// another field `x.u.y`, then this function will return:\n+    ///\n+    ///     (\"x.u\", \"x.u.z\", \"x.u.y\")\n+    ///\n+    /// This is used when creating error messages like below:\n+    ///\n+    /// >  cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n+    /// >  mutable (via `a.u.s.b`) [E0502]\n+    pub(super) fn describe_place_for_conflicting_borrow(\n+        &self,\n+        first_borrowed_place: &Place<'tcx>,\n+        second_borrowed_place: &Place<'tcx>,\n+    ) -> (String, String, String, String) {\n+        // Define a small closure that we can use to check if the type of a place\n+        // is a union.\n+        let is_union = |place: &Place<'tcx>| -> bool {\n+            place.ty(self.mir, self.infcx.tcx)\n+                .to_ty(self.infcx.tcx)\n+                .ty_adt_def()\n+                .map(|adt| adt.is_union())\n+                .unwrap_or(false)\n+        };\n+\n+        // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n+        // code duplication (particularly around returning an empty description in the failure\n+        // case).\n+        Some(())\n+            .filter(|_| {\n+                // If we have a conflicting borrow of the same place, then we don't want to add\n+                // an extraneous \"via x.y\" to our diagnostics, so filter out this case.\n+                first_borrowed_place != second_borrowed_place\n+            })\n+            .and_then(|_| {\n+                // We're going to want to traverse the first borrowed place to see if we can find\n+                // field access to a union. If we find that, then we will keep the place of the\n+                // union being accessed and the field that was being accessed so we can check the\n+                // second borrowed place for the same union and a access to a different field.\n+                let mut current = first_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if is_union(base) => {\n+                            return Some((base, field));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .and_then(|(target_base, target_field)| {\n+                // With the place of a union and a field access into it, we traverse the second\n+                // borrowed place and look for a access to a different field of the same union.\n+                let mut current = second_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if {\n+                            is_union(base) && field != target_field && base == target_base\n+                        } => {\n+                            let desc_base = self.describe_place(base)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_first = self.describe_place(first_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_second = self.describe_place(second_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+\n+                            // Also compute the name of the union type, eg. `Foo` so we\n+                            // can add a helpful note with it.\n+                            let ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+\n+                            return Some((desc_base, desc_first, desc_second, ty.to_string()));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .unwrap_or_else(|| {\n+                // If we didn't find a field access into a union, or both places match, then\n+                // only return the description of the first place.\n+                let desc_place = self.describe_place(first_borrowed_place)\n+                    .unwrap_or_else(|| \"_\".to_owned());\n+                (desc_place, \"\".to_string(), \"\".to_string(), \"\".to_string())\n+            })\n+    }\n+\n     /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n     ///\n     /// This means that some data referenced by `borrow` needs to live"}, {"sha": "7ad73aaa3f9a958a7ff81a51d86d1d4ca5cf0d01", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -138,13 +138,15 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_load_end_span: Option<Span>,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n+        let via = |msg: &str|\n+            if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0499,\n             \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n             desc,\n-            opt_via,\n+            via(opt_via),\n             OGN = o\n         );\n         if old_loan_span == new_loan_span {\n@@ -164,11 +166,11 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         } else {\n             err.span_label(\n                 old_loan_span,\n-                format!(\"first mutable borrow occurs here{}\", old_opt_via),\n+                format!(\"first mutable borrow occurs here{}\", via(old_opt_via)),\n             );\n             err.span_label(\n                 new_loan_span,\n-                format!(\"second mutable borrow occurs here{}\", opt_via),\n+                format!(\"second mutable borrow occurs here{}\", via(opt_via)),\n             );\n             if let Some(old_load_end_span) = old_load_end_span {\n                 err.span_label(old_load_end_span, \"first borrow ends here\");\n@@ -292,27 +294,46 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_load_end_span: Option<Span>,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n+        let via = |msg: &str|\n+            if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0502,\n-            \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n+            \"cannot borrow `{}`{} as {} because {} is also borrowed \\\n+             as {}{}{OGN}\",\n             desc_new,\n-            msg_new,\n+            via(msg_new),\n             kind_new,\n             noun_old,\n             kind_old,\n-            msg_old,\n+            via(msg_old),\n             OGN = o\n         );\n-        err.span_label(span, format!(\"{} borrow occurs here{}\", kind_new, msg_new));\n-        err.span_label(\n-            old_span,\n-            format!(\"{} borrow occurs here{}\", kind_old, msg_old),\n-        );\n+\n+        if msg_new == \"\" {\n+            // If `msg_new` is empty, then this isn't a borrow of a union field.\n+            err.span_label(span, format!(\"{} borrow occurs here\", kind_new));\n+            err.span_label(old_span, format!(\"{} borrow occurs here\", kind_old));\n+        } else {\n+            // If `msg_new` isn't empty, then this a borrow of a union field.\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"{} borrow of `{}` -- which overlaps with `{}` -- occurs here\",\n+                    kind_new, msg_new, msg_old,\n+                )\n+            );\n+            err.span_label(\n+                old_span,\n+                format!(\"{} borrow occurs here{}\", kind_old, via(msg_old)),\n+            );\n+        }\n+\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n         }\n+\n         self.cancel_if_wrong_origin(err, o)\n     }\n "}, {"sha": "e116cb70c1c311499e9a4699a2facf3fb967e9dd", "filename": "src/test/ui/borrowck/borrowck-borrow-from-owned-ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -138,7 +138,7 @@ error[E0502]: cannot borrow `foo` (via `foo.bar2`) as immutable because `foo` is\n LL |     let bar1 = &mut foo.bar1;\n    |                     -------- mutable borrow occurs here (via `foo.bar1`)\n LL |     let _foo1 = &foo.bar2; //~ ERROR cannot borrow\n-   |                  ^^^^^^^^ immutable borrow occurs here (via `foo.bar2`)\n+   |                  ^^^^^^^^ immutable borrow of `foo.bar2` -- which overlaps with `foo.bar1` -- occurs here\n LL |     *bar1;\n LL | }\n    | - mutable borrow ends here"}, {"sha": "236064da3e8b6ed409eb3dd2543acf4919c19e2b", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.ast.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.ast.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -61,7 +61,7 @@ error[E0502]: cannot borrow `a` (via `a.y`) as immutable because `a` is also bor\n LL |     let _x = &mut a.x;\n    |                   --- mutable borrow occurs here (via `a.x`)\n LL |     let _y = &a.y; //[ast]~ ERROR cannot borrow\n-   |               ^^^ immutable borrow occurs here (via `a.y`)\n+   |               ^^^ immutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n ...\n LL | }\n    | - mutable borrow ends here\n@@ -72,7 +72,7 @@ error[E0502]: cannot borrow `a` (via `a.y`) as mutable because `a` is also borro\n LL |     let _x = &a.x;\n    |               --- immutable borrow occurs here (via `a.x`)\n LL |     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n-   |                   ^^^ mutable borrow occurs here (via `a.y`)\n+   |                   ^^^ mutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n ...\n LL | }\n    | - immutable borrow ends here"}, {"sha": "e72048d0ea4bc66ed949be508f99c1d31640ce6e", "filename": "src/test/ui/borrowck/borrowck-box-insensitivity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-box-insensitivity.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -83,14 +83,14 @@ fn borrow_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n     let _y = &a.y; //[ast]~ ERROR cannot borrow\n-    //[ast]~^ immutable borrow occurs here (via `a.y`)\n+    //[ast]~^ immutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n     use_mut(_x);\n }\n fn mut_borrow_after_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &a.x;\n     let _y = &mut a.y; //[ast]~ ERROR cannot borrow\n-    //[ast]~^ mutable borrow occurs here (via `a.y`)\n+    //[ast]~^ mutable borrow of `a.y` -- which overlaps with `a.x` -- occurs here\n     use_imm(_x);\n }\n fn copy_after_move_nested() {"}, {"sha": "5cba30b43b8a0b5774bb74bcb8456e501e76f36b", "filename": "src/test/ui/borrowck/borrowck-union-borrow.nll.stderr", "status": "renamed", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.nll.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -1,132 +1,127 @@\n error[E0502]: cannot borrow `u.a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-union-borrow.rs:27:23\n+  --> $DIR/borrowck-union-borrow.rs:25:23\n    |\n LL |             let ra = &u.a;\n    |                      ---- immutable borrow occurs here\n-LL |             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+LL |             let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n    |                       ^^^^^^^^ mutable borrow occurs here\n-LL |                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n LL |             drop(ra);\n    |                  -- immutable borrow later used here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:33:13\n+  --> $DIR/borrowck-union-borrow.rs:30:13\n    |\n LL |             let ra = &u.a;\n    |                      ---- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n LL |             drop(ra);\n    |                  -- borrow later used here\n \n-error[E0502]: cannot borrow `u.b` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-union-borrow.rs:50:23\n+error[E0502]: cannot borrow `u` (via `u.b`) as mutable because it is also borrowed as immutable (via `u.a`)\n+  --> $DIR/borrowck-union-borrow.rs:46:23\n    |\n LL |             let ra = &u.a;\n-   |                      ---- immutable borrow occurs here\n-LL |             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-   |                       ^^^^^^^^ mutable borrow occurs here\n-LL |                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n+   |                      ---- immutable borrow occurs here (via `u.a`)\n+LL |             let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+   |                       ^^^^^^^^ mutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n LL |             drop(ra);\n    |                  -- immutable borrow later used here\n+   |\n+   = note: `u.b` is a field of the union `U`, so it overlaps the field `u.a`\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:56:13\n+  --> $DIR/borrowck-union-borrow.rs:51:13\n    |\n LL |             let ra = &u.a;\n    |                      ---- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n LL |             drop(ra);\n    |                  -- borrow later used here\n \n error[E0502]: cannot borrow `u.a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-union-borrow.rs:63:22\n+  --> $DIR/borrowck-union-borrow.rs:57:22\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- mutable borrow occurs here\n-LL |             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+LL |             let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n    |                      ^^^^ immutable borrow occurs here\n-LL |                          //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n LL |             drop(rma);\n    |                  --- mutable borrow later used here\n \n error[E0503]: cannot use `u.a` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:69:21\n+  --> $DIR/borrowck-union-borrow.rs:62:21\n    |\n LL |             let ra = &mut u.a;\n    |                      -------- borrow of `u.a` occurs here\n-LL |             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+LL |             let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n    |                     ^^^ use of borrowed `u.a`\n-LL |                          //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n LL |             drop(ra);\n    |                  -- borrow later used here\n \n error[E0499]: cannot borrow `u.a` as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:75:24\n+  --> $DIR/borrowck-union-borrow.rs:67:24\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- first mutable borrow occurs here\n-LL |             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+LL |             let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n    |                        ^^^^^^^^ second mutable borrow occurs here\n-LL |                                  //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time\n LL |             drop(rma);\n    |                  --- first borrow later used here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:81:13\n+  --> $DIR/borrowck-union-borrow.rs:72:13\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n LL |             drop(rma);\n    |                  --- borrow later used here\n \n-error[E0502]: cannot borrow `u.b` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-union-borrow.rs:88:22\n+error[E0502]: cannot borrow `u` (via `u.b`) as immutable because it is also borrowed as mutable (via `u.a`)\n+  --> $DIR/borrowck-union-borrow.rs:78:22\n    |\n LL |             let rma = &mut u.a;\n-   |                       -------- mutable borrow occurs here\n-LL |             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-   |                      ^^^^ immutable borrow occurs here\n-LL |                            //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n+   |                       -------- mutable borrow occurs here (via `u.a`)\n+LL |             let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+   |                      ^^^^ immutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n LL |             drop(rma);\n    |                  --- mutable borrow later used here\n+   |\n+   = note: `u.b` is a field of the union `U`, so it overlaps the field `u.a`\n \n error[E0503]: cannot use `u.b` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:94:21\n+  --> $DIR/borrowck-union-borrow.rs:83:21\n    |\n LL |             let ra = &mut u.a;\n    |                      -------- borrow of `u.a` occurs here\n-LL |             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n+LL |             let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n    |                     ^^^ use of borrowed `u.a`\n-...\n+LL | \n LL |             drop(ra);\n    |                  -- borrow later used here\n \n-error[E0499]: cannot borrow `u.b` as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:101:24\n+error[E0499]: cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+  --> $DIR/borrowck-union-borrow.rs:89:24\n    |\n LL |             let rma = &mut u.a;\n-   |                       -------- first mutable borrow occurs here\n-LL |             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-   |                        ^^^^^^^^ second mutable borrow occurs here\n-LL |                                  //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n+   |                       -------- first mutable borrow occurs here (via `u.a`)\n+LL |             let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+   |                        ^^^^^^^^ second mutable borrow occurs here (via `u.b`)\n LL |             drop(rma);\n    |                  --- first borrow later used here\n+   |\n+   = note: `u.b` is a field of the union `U`, so it overlaps the field `u.a`\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:107:13\n+  --> $DIR/borrowck-union-borrow.rs:94:13\n    |\n LL |             let rma = &mut u.a;\n    |                       -------- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n-LL |                      //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n LL |             drop(rma);\n    |                  --- borrow later used here\n ", "previous_filename": "src/test/ui/borrowck/borrowck-union-borrow.ast.nll.stderr"}, {"sha": "8afc0be8b55c523800d0fc0cd3000a1f6cb71a74", "filename": "src/test/ui/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -1,6 +1,4 @@\n // ignore-tidy-linelength\n-// revisions: ast mir\n-//[mir]compile-flags: -Z borrowck=mir\n \n #[derive(Clone, Copy)]\n union U {\n@@ -24,14 +22,12 @@ fn main() {\n         }\n         {\n             let ra = &u.a;\n-            let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n-                                //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+            let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n             drop(ra);\n         }\n         {\n             let ra = &u.a;\n-            u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n+            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n             drop(ra);\n         }\n         // Imm borrow, other field\n@@ -47,65 +43,55 @@ fn main() {\n         }\n         {\n             let ra = &u.a;\n-            let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-                                //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n+            let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n             drop(ra);\n         }\n         {\n             let ra = &u.a;\n-            u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n+            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n             drop(ra);\n         }\n         // Mut borrow, same field\n         {\n             let rma = &mut u.a;\n-            let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n-                         //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+            let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n             drop(rma);\n         }\n         {\n             let ra = &mut u.a;\n-            let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n-                         //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n+            let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n             drop(ra);\n         }\n         {\n             let rma = &mut u.a;\n-            let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n-                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time\n+            let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n             drop(rma);\n         }\n         {\n             let rma = &mut u.a;\n-            u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n+            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n             drop(rma);\n         }\n         // Mut borrow, other field\n         {\n             let rma = &mut u.a;\n-            let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-                           //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n+            let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n             drop(rma);\n         }\n         {\n             let ra = &mut u.a;\n-            let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n-                         //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed\n+            let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n \n             drop(ra);\n         }\n         {\n             let rma = &mut u.a;\n-            let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n+            let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n             drop(rma);\n         }\n         {\n             let rma = &mut u.a;\n-            u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n+            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n             drop(rma);\n         }\n     }"}, {"sha": "ef6a331eda04c0eabf6a1dd98137ad69ddfdb9f8", "filename": "src/test/ui/borrowck/borrowck-union-borrow.stderr", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-borrow.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -1,115 +1,115 @@\n error[E0502]: cannot borrow `u.a` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-union-borrow.rs:27:28\n+  --> $DIR/borrowck-union-borrow.rs:25:28\n    |\n LL |             let ra = &u.a;\n    |                       --- immutable borrow occurs here\n-LL |             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+LL |             let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n    |                            ^^^ mutable borrow occurs here\n-...\n+LL |             drop(ra);\n LL |         }\n    |         - immutable borrow ends here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:33:13\n+  --> $DIR/borrowck-union-borrow.rs:30:13\n    |\n LL |             let ra = &u.a;\n    |                       --- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n \n error[E0502]: cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-  --> $DIR/borrowck-union-borrow.rs:50:28\n+  --> $DIR/borrowck-union-borrow.rs:46:28\n    |\n LL |             let ra = &u.a;\n    |                       --- immutable borrow occurs here (via `u.a`)\n-LL |             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-   |                            ^^^ mutable borrow occurs here (via `u.b`)\n-...\n+LL |             let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+   |                            ^^^ mutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n+LL |             drop(ra);\n LL |         }\n    |         - immutable borrow ends here\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:56:13\n+  --> $DIR/borrowck-union-borrow.rs:51:13\n    |\n LL |             let ra = &u.a;\n    |                       --- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n \n error[E0502]: cannot borrow `u.a` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-union-borrow.rs:63:23\n+  --> $DIR/borrowck-union-borrow.rs:57:23\n    |\n LL |             let rma = &mut u.a;\n    |                            --- mutable borrow occurs here\n-LL |             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+LL |             let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n    |                       ^^^ immutable borrow occurs here\n-...\n+LL |             drop(rma);\n LL |         }\n    |         - mutable borrow ends here\n \n error[E0503]: cannot use `u.a` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:69:17\n+  --> $DIR/borrowck-union-borrow.rs:62:17\n    |\n LL |             let ra = &mut u.a;\n    |                           --- borrow of `u.a` occurs here\n-LL |             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+LL |             let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n    |                 ^ use of borrowed `u.a`\n \n error[E0499]: cannot borrow `u.a` as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:75:29\n+  --> $DIR/borrowck-union-borrow.rs:67:29\n    |\n LL |             let rma = &mut u.a;\n    |                            --- first mutable borrow occurs here\n-LL |             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+LL |             let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n    |                             ^^^ second mutable borrow occurs here\n-...\n+LL |             drop(rma);\n LL |         }\n    |         - first borrow ends here\n \n error[E0506]: cannot assign to `u.a` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:81:13\n+  --> $DIR/borrowck-union-borrow.rs:72:13\n    |\n LL |             let rma = &mut u.a;\n    |                            --- borrow of `u.a` occurs here\n-LL |             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+LL |             u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.a` occurs here\n \n error[E0502]: cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-  --> $DIR/borrowck-union-borrow.rs:88:23\n+  --> $DIR/borrowck-union-borrow.rs:78:23\n    |\n LL |             let rma = &mut u.a;\n    |                            --- mutable borrow occurs here (via `u.a`)\n-LL |             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-   |                       ^^^ immutable borrow occurs here (via `u.b`)\n-...\n+LL |             let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+   |                       ^^^ immutable borrow of `u.b` -- which overlaps with `u.a` -- occurs here\n+LL |             drop(rma);\n LL |         }\n    |         - mutable borrow ends here\n \n error[E0503]: cannot use `u.b` because it was mutably borrowed\n-  --> $DIR/borrowck-union-borrow.rs:94:17\n+  --> $DIR/borrowck-union-borrow.rs:83:17\n    |\n LL |             let ra = &mut u.a;\n    |                           --- borrow of `u.a` occurs here\n-LL |             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n+LL |             let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n    |                 ^ use of borrowed `u.a`\n \n error[E0499]: cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-  --> $DIR/borrowck-union-borrow.rs:101:29\n+  --> $DIR/borrowck-union-borrow.rs:89:29\n    |\n LL |             let rma = &mut u.a;\n    |                            --- first mutable borrow occurs here (via `u.a`)\n-LL |             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+LL |             let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n    |                             ^^^ second mutable borrow occurs here (via `u.b`)\n-...\n+LL |             drop(rma);\n LL |         }\n    |         - first borrow ends here\n \n error[E0506]: cannot assign to `u.b` because it is borrowed\n-  --> $DIR/borrowck-union-borrow.rs:107:13\n+  --> $DIR/borrowck-union-borrow.rs:94:13\n    |\n LL |             let rma = &mut u.a;\n    |                            --- borrow of `u.b` occurs here\n-LL |             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+LL |             u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n    |             ^^^^^^^ assignment to borrowed `u.b` occurs here\n \n error: aborting due to 12 previous errors", "previous_filename": "src/test/ui/borrowck/borrowck-union-borrow.ast.stderr"}, {"sha": "823f2c747d686b3a8c819d2b348e0e86a8cc13a0", "filename": "src/test/ui/issues/issue-17263.ast.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fissues%2Fissue-17263.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fissues%2Fissue-17263.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17263.ast.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -13,7 +13,7 @@ error[E0502]: cannot borrow `foo` (via `foo.b`) as immutable because `foo` is al\n   --> $DIR/issue-17263.rs:21:32\n    |\n LL |     let (c, d) = (&mut foo.a, &foo.b);\n-   |                        -----   ^^^^^ immutable borrow occurs here (via `foo.b`)\n+   |                        -----   ^^^^^ immutable borrow of `foo.b` -- which overlaps with `foo.a` -- occurs here\n    |                        |\n    |                        mutable borrow occurs here (via `foo.a`)\n ..."}, {"sha": "22ea254a769e842d64dc1a690031127a43267dbe", "filename": "src/test/ui/issues/issue-45157.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fissues%2Fissue-45157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fissues%2Fissue-45157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45157.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -1,6 +1,8 @@\n #![allow(unused)]\n #![feature(nll)]\n \n+// ignore-tidy-linelength\n+\n #[derive(Clone, Copy, Default)]\n struct S {\n     a: u8,\n@@ -25,8 +27,7 @@ fn main() {\n         *mref = 22;\n \n         let nref = &u.z.c;\n-        //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+        //~^ ERROR cannot borrow `u` (via `u.z.c`) as immutable because it is also borrowed as mutable (via `u.s.a`) [E0502]\n         println!(\"{} {}\", mref, nref)\n     }\n }\n-"}, {"sha": "3b15a8dbd9ef86f92635d4240dfd556a232ece48", "filename": "src/test/ui/issues/issue-45157.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fissues%2Fissue-45157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fissues%2Fissue-45157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45157.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -1,14 +1,16 @@\n-error[E0502]: cannot borrow `u.z.c` as immutable because it is also borrowed as mutable\n-  --> $DIR/issue-45157.rs:27:20\n+error[E0502]: cannot borrow `u` (via `u.z.c`) as immutable because it is also borrowed as mutable (via `u.s.a`)\n+  --> $DIR/issue-45157.rs:29:20\n    |\n LL |         let mref = &mut u.s.a;\n-   |                    ---------- mutable borrow occurs here\n+   |                    ---------- mutable borrow occurs here (via `u.s.a`)\n ...\n LL |         let nref = &u.z.c;\n-   |                    ^^^^^^ immutable borrow occurs here\n-LL |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+   |                    ^^^^^^ immutable borrow of `u.z.c` -- which overlaps with `u.s.a` -- occurs here\n+LL |         //~^ ERROR cannot borrow `u` (via `u.z.c`) as immutable because it is also borrowed as mutable (via `u.s.a`) [E0502]\n LL |         println!(\"{} {}\", mref, nref)\n    |                           ---- mutable borrow later used here\n+   |\n+   = note: `u.z.c` is a field of the union `U`, so it overlaps the field `u.s.a`\n \n error: aborting due to previous error\n "}, {"sha": "f669fe00956ef5047bb2fcdc4f7b3f24a228b398", "filename": "src/test/ui/nll/issue-57100.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -0,0 +1,69 @@\n+#![allow(unused)]\n+#![feature(nll)]\n+\n+// ignore-tidy-linelength\n+\n+// This tests the error messages for borrows of union fields when the unions are embedded in other\n+// structs or unions.\n+\n+#[derive(Clone, Copy, Default)]\n+struct Leaf {\n+    l1_u8: u8,\n+    l2_u8: u8,\n+}\n+\n+#[derive(Clone, Copy)]\n+union First {\n+    f1_leaf: Leaf,\n+    f2_leaf: Leaf,\n+    f3_union: Second,\n+}\n+\n+#[derive(Clone, Copy)]\n+union Second {\n+    s1_leaf: Leaf,\n+    s2_leaf: Leaf,\n+}\n+\n+struct Root {\n+    r1_u8: u8,\n+    r2_union: First,\n+}\n+\n+// Borrow a different field of the nested union.\n+fn nested_union() {\n+    unsafe {\n+        let mut r = Root {\n+            r1_u8: 3,\n+            r2_union: First { f3_union: Second { s2_leaf: Leaf { l1_u8: 8, l2_u8: 4 } } }\n+        };\n+\n+        let mref = &mut r.r2_union.f3_union.s1_leaf.l1_u8;\n+        //                                  ^^^^^^^\n+        *mref = 22;\n+        let nref = &r.r2_union.f3_union.s2_leaf.l1_u8;\n+        //                              ^^^^^^^\n+        //~^^ ERROR cannot borrow `r.r2_union.f3_union` (via `r.r2_union.f3_union.s2_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f3_union.s1_leaf.l1_u8`) [E0502]\n+        println!(\"{} {}\", mref, nref)\n+    }\n+}\n+\n+// Borrow a different field of the first union.\n+fn first_union() {\n+    unsafe {\n+        let mut r = Root {\n+            r1_u8: 3,\n+            r2_union: First { f3_union: Second { s2_leaf: Leaf { l1_u8: 8, l2_u8: 4 } } }\n+        };\n+\n+        let mref = &mut r.r2_union.f2_leaf.l1_u8;\n+        //                         ^^^^^^^\n+        *mref = 22;\n+        let nref = &r.r2_union.f1_leaf.l1_u8;\n+        //                     ^^^^^^^\n+        //~^^ ERROR cannot borrow `r.r2_union` (via `r.r2_union.f1_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f2_leaf.l1_u8`) [E0502]\n+        println!(\"{} {}\", mref, nref)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5d5c86c34875c2af9b6cc0ef966f01907de55acd", "filename": "src/test/ui/nll/issue-57100.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -0,0 +1,31 @@\n+error[E0502]: cannot borrow `r.r2_union.f3_union` (via `r.r2_union.f3_union.s2_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f3_union.s1_leaf.l1_u8`)\n+  --> $DIR/issue-57100.rs:44:20\n+   |\n+LL |         let mref = &mut r.r2_union.f3_union.s1_leaf.l1_u8;\n+   |                    -------------------------------------- mutable borrow occurs here (via `r.r2_union.f3_union.s1_leaf.l1_u8`)\n+...\n+LL |         let nref = &r.r2_union.f3_union.s2_leaf.l1_u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow of `r.r2_union.f3_union.s2_leaf.l1_u8` -- which overlaps with `r.r2_union.f3_union.s1_leaf.l1_u8` -- occurs here\n+...\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- mutable borrow later used here\n+   |\n+   = note: `r.r2_union.f3_union.s2_leaf.l1_u8` is a field of the union `Second`, so it overlaps the field `r.r2_union.f3_union.s1_leaf.l1_u8`\n+\n+error[E0502]: cannot borrow `r.r2_union` (via `r.r2_union.f1_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f2_leaf.l1_u8`)\n+  --> $DIR/issue-57100.rs:62:20\n+   |\n+LL |         let mref = &mut r.r2_union.f2_leaf.l1_u8;\n+   |                    ----------------------------- mutable borrow occurs here (via `r.r2_union.f2_leaf.l1_u8`)\n+...\n+LL |         let nref = &r.r2_union.f1_leaf.l1_u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow of `r.r2_union.f1_leaf.l1_u8` -- which overlaps with `r.r2_union.f2_leaf.l1_u8` -- occurs here\n+...\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- mutable borrow later used here\n+   |\n+   = note: `r.r2_union.f1_leaf.l1_u8` is a field of the union `First`, so it overlaps the field `r.r2_union.f2_leaf.l1_u8`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "848c3d9bdb017caf607aea607654a35ab57199be", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.nll.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -1,12 +1,14 @@\n-error[E0502]: cannot borrow `u.y` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:15:13\n    |\n LL |     let a = &mut u.x.0;\n-   |             ---------- mutable borrow occurs here\n+   |             ---------- mutable borrow occurs here (via `u.x.0`)\n LL |     let b = &u.y; //~ ERROR cannot borrow `u.y`\n-   |             ^^^^ immutable borrow occurs here\n+   |             ^^^^ immutable borrow of `u.y` -- which overlaps with `u.x.0` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n+   |\n+   = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0`\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:22:13\n@@ -18,15 +20,17 @@ LL |     let b = u.y; //~ ERROR use of moved value: `u.y`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0502]: cannot borrow `u.y` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:28:13\n    |\n LL |     let a = &mut (u.x.0).0;\n-   |             -------------- mutable borrow occurs here\n+   |             -------------- mutable borrow occurs here (via `u.x.0.0`)\n LL |     let b = &u.y; //~ ERROR cannot borrow `u.y`\n-   |             ^^^^ immutable borrow occurs here\n+   |             ^^^^ immutable borrow of `u.y` -- which overlaps with `u.x.0.0` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n+   |\n+   = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0.0`\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:35:13\n@@ -38,15 +42,17 @@ LL |     let b = u.y; //~ ERROR use of moved value: `u.y`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0502]: cannot borrow `u.x` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `*u.y`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n    |\n LL |     let a = &mut *u.y;\n-   |             --------- mutable borrow occurs here\n+   |             --------- mutable borrow occurs here (via `*u.y`)\n LL |     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n-   |             ^^^^ immutable borrow occurs here\n+   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n+   |\n+   = note: `u.x` is a field of the union `U`, so it overlaps the field `*u.y`\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:48:13"}, {"sha": "9058707e505168bfc0f6c8db7c837c6ce694975b", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca1e379090d0aa27d4fb8b71210311d96c174e7c/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr?ref=ca1e379090d0aa27d4fb8b71210311d96c174e7c", "patch": "@@ -46,7 +46,7 @@ error[E0502]: cannot borrow `u` (via `u.x`) as immutable because `u` is also bor\n LL |     let a = &mut *u.y;\n    |                  ---- mutable borrow occurs here (via `*u.y`)\n LL |     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n-   |              ^^^ immutable borrow occurs here (via `u.x`)\n+   |              ^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n LL |     use_borrow(a);\n LL | }\n    | - mutable borrow ends here"}]}