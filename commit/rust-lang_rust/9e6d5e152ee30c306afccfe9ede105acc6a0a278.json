{"sha": "9e6d5e152ee30c306afccfe9ede105acc6a0a278", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNmQ1ZTE1MmVlMzBjMzA2YWZjY2ZlOWVkZTEwNWFjYzZhMGEyNzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-24T01:37:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-02T00:43:54Z"}, "message": "Defer reasoning about region relationships until after regionck.\n\nThis patch makes error handling for region inference failures more\nuniform by not reporting *any* region errors until the reigon inference\nstep. This requires threading through more information about what\ncaused a region constraint, so that we can still give informative\nerror messages.\n\nI have only taken partial advantage of this information: when region\ninference fails, we still report the same error we always did, despite\nthe fact that we now know precisely what caused the various constriants\nand what the region variable represents, which we did not know before.\n\nThis change is required not only to improve error messages but\nbecause the region hierarchy is not in fact fully known until regionck,\nbecause it is not clear where closure bodies fit in (our current\ntreatment is unsound). Moreover, the relationships between free variables\ncannot be fully determined until type inference is otherwise complete.\n\ncc #3238.", "tree": {"sha": "fd519c4b413ea2adb645c87843fb039d1b22bf54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd519c4b413ea2adb645c87843fb039d1b22bf54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e6d5e152ee30c306afccfe9ede105acc6a0a278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e6d5e152ee30c306afccfe9ede105acc6a0a278", "html_url": "https://github.com/rust-lang/rust/commit/9e6d5e152ee30c306afccfe9ede105acc6a0a278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e6d5e152ee30c306afccfe9ede105acc6a0a278/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e482856d76fba8d31ee114d4fb74f8c18f63e73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e482856d76fba8d31ee114d4fb74f8c18f63e73c", "html_url": "https://github.com/rust-lang/rust/commit/e482856d76fba8d31ee114d4fb74f8c18f63e73c"}], "stats": {"total": 1733, "additions": 1211, "deletions": 522}, "files": [{"sha": "351d09b7ce5c27ba30a5d5520d26fe0ddb9c1c4a", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -15,6 +15,7 @@ use middle::typeck::check::demand;\n use middle::typeck::check::{check_block, check_expr_has_type, FnCtxt};\n use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n+use middle::typeck::infer;\n use middle::typeck::require_same_types;\n \n use std::hashmap::{HashMap, HashSet};\n@@ -38,8 +39,6 @@ pub fn check_match(fcx: @mut FnCtxt,\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n-            match_region: ty::re_scope(expr.id),\n-            block_region: ty::re_scope(arm.body.node.id)\n         };\n \n         for arm.pats.iter().advance |p| { check_pat(&pcx, *p, pattern_ty);}\n@@ -93,8 +92,6 @@ pub fn check_match(fcx: @mut FnCtxt,\n pub struct pat_ctxt {\n     fcx: @mut FnCtxt,\n     map: PatIdMap,\n-    match_region: ty::Region, // Region for the match as a whole\n-    block_region: ty::Region, // Region for the block of the arm\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n@@ -442,8 +439,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             // then the type of x is &M T where M is the mutability\n             // and T is the expected type\n             let region_var =\n-                fcx.infcx().next_region_var_with_lb(\n-                    pat.span, pcx.block_region);\n+                fcx.infcx().next_region_var(\n+                    infer::PatternRegion(pat.span));\n             let mt = ty::mt {ty: expected, mutbl: mutbl};\n             let region_ty = ty::mk_rptr(tcx, region_var, mt);\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n@@ -544,9 +541,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         let default_region_var =\n-            fcx.infcx().next_region_var_with_lb(\n-                pat.span, pcx.block_region\n-            );\n+            fcx.infcx().next_region_var(\n+                infer::PatternRegion(pat.span));\n \n         let (elt_type, region_var) = match structure_of(\n           fcx, pat.span, expected"}, {"sha": "cf29d3f7f1f57ef7c2a00fd1be91edb949771b51", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -35,7 +35,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n                        ty_a: ty::t, ty_b: ty::t,\n                        handle_err: &fn(span, ty::t, ty::t, &ty::type_err)) {\n     // n.b.: order of actual, expected is reversed\n-    match infer::mk_subty(fcx.infcx(), b_is_expected, sp,\n+    match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {\n       result::Ok(()) => { /* ok */ }\n       result::Err(ref err) => {\n@@ -45,7 +45,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n }\n \n pub fn eqtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n-    match infer::mk_eqty(fcx.infcx(), false, sp, actual, expected) {\n+    match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n             fcx.report_mismatched_types(sp, expected, actual, err);"}, {"sha": "ee61399113a434fcd5dbb5cda873ce32315e52f2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -619,14 +619,18 @@ impl<'self> LookupContext<'self> {\n                      autoref: None}))\n             }\n             ty::ty_rptr(_, self_mt) => {\n-                let region = self.infcx().next_region_var_nb(self.expr.span);\n+                let region =\n+                    self.infcx().next_region_var(\n+                        infer::Autoref(self.expr.span));\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n                      autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n             }\n             ty::ty_evec(self_mt, vstore_slice(_)) => {\n-                let region = self.infcx().next_region_var_nb(self.expr.span);\n+                let region =\n+                    self.infcx().next_region_var(\n+                        infer::Autoref(self.expr.span));\n                 (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n@@ -758,7 +762,9 @@ impl<'self> LookupContext<'self> {\n         -> Option<method_map_entry> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n-        let region = self.infcx().next_region_var_nb(self.expr.span);\n+        let region =\n+            self.infcx().next_region_var(\n+                infer::Autoref(self.expr.span));\n         for mutbls.iter().advance |mutbl| {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n@@ -970,7 +976,8 @@ impl<'self> LookupContext<'self> {\n         let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n-                |_br| self.fcx.infcx().next_region_var_nb(self.expr.span));\n+                |br| self.fcx.infcx().next_region_var(\n+                    infer::BoundRegionInFnCall(self.expr.span, br)));\n         let transformed_self_ty = opt_transformed_self_ty.get();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n@@ -982,7 +989,7 @@ impl<'self> LookupContext<'self> {\n         // variables to unify etc).  Since we checked beforehand, and\n         // nothing has changed in the meantime, this unification\n         // should never fail.\n-        match self.fcx.mk_subty(false, self.self_expr.span,\n+        match self.fcx.mk_subty(false, infer::Misc(self.self_expr.span),\n                                 rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => (),\n             result::Err(_) => {"}, {"sha": "b397181ddca6cf8bfdb7d2c9330fd4a09fafd577", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -467,8 +467,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             let pcx = pat_ctxt {\n                 fcx: fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n-                match_region: region,\n-                block_region: region,\n             };\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n@@ -686,9 +684,14 @@ impl FnCtxt {\n                     result::Ok(self.block_region())\n                 } else {\n                     result::Err(RegionError {\n-                        msg: fmt!(\"named region `%s` not in scope here\",\n-                                  bound_region_ptr_to_str(self.tcx(), br)),\n-                        replacement: self.infcx().next_region_var_nb(span)\n+                        msg: {\n+                            fmt!(\"named region `%s` not in scope here\",\n+                                 bound_region_to_str(self.tcx(), br))\n+                        },\n+                        replacement: {\n+                            self.infcx().next_region_var(\n+                                infer::BoundRegionError(span))\n+                        }\n                     })\n                 }\n             }\n@@ -698,7 +701,7 @@ impl FnCtxt {\n \n impl region_scope for FnCtxt {\n     fn anon_region(&self, span: span) -> Result<ty::Region, RegionError> {\n-        result::Ok(self.infcx().next_region_var_nb(span))\n+        result::Ok(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n     fn self_region(&self, span: span) -> Result<ty::Region, RegionError> {\n         self.search_in_scope_regions(span, ty::br_self)\n@@ -845,21 +848,28 @@ impl FnCtxt {\n \n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n-                    span: span,\n+                    origin: infer::SubtypeOrigin,\n                     sub: ty::t,\n                     sup: ty::t)\n                     -> Result<(), ty::type_err> {\n-        infer::mk_subty(self.infcx(), a_is_expected, span, sub, sup)\n+        infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn can_mk_subty(&self, sub: ty::t, sup: ty::t)\n                         -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    pub fn mk_assignty(&self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n+    pub fn mk_assignty(&self,\n+                       expr: @ast::expr,\n+                       sub: ty::t,\n+                       sup: ty::t)\n                        -> Result<(), ty::type_err> {\n-        match infer::mk_coercety(self.infcx(), false, expr.span, sub, sup) {\n+        match infer::mk_coercety(self.infcx(),\n+                                 false,\n+                                 infer::ExprAssignable(expr),\n+                                 sub,\n+                                 sup) {\n             Ok(None) => result::Ok(()),\n             Err(ref e) => result::Err((*e)),\n             Ok(Some(adjustment)) => {\n@@ -876,20 +886,19 @@ impl FnCtxt {\n \n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n-                   span: span,\n+                   origin: infer::SubtypeOrigin,\n                    sub: ty::t,\n                    sup: ty::t)\n                    -> Result<(), ty::type_err> {\n-        infer::mk_eqty(self.infcx(), a_is_expected, span, sub, sup)\n+        infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn mk_subr(&self,\n                    a_is_expected: bool,\n-                   span: span,\n+                   origin: infer::SubregionOrigin,\n                    sub: ty::Region,\n-                   sup: ty::Region)\n-                   -> Result<(), ty::type_err> {\n-        infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n+                   sup: ty::Region) {\n+        infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R)\n@@ -905,7 +914,9 @@ impl FnCtxt {\n                                        rp: Option<ty::region_variance>,\n                                        span: span)\n                                        -> Option<ty::Region> {\n-        rp.map(|_rp| self.infcx().next_region_var_nb(span))\n+        rp.map(\n+            |_| self.infcx().next_region_var(\n+                infer::BoundRegionInTypeOrImpl(span)))\n     }\n \n     pub fn type_error_message(&self,\n@@ -1089,7 +1100,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     };\n \n     let self_r = if region_param.is_some() {\n-        Some(vcx.infcx.next_region_var_nb(location_info.span))\n+        Some(vcx.infcx.next_region_var(\n+            infer::BoundRegionInTypeOrImpl(location_info.span)))\n     } else {\n         None\n     };\n@@ -1352,7 +1364,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let (_, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 fcx.tcx(), @Nil, None, &fn_sig,\n-                |_br| fcx.infcx().next_region_var_nb(call_expr.span));\n+                |br| fcx.infcx().next_region_var(\n+                    infer::BoundRegionInFnCall(call_expr.span, br)));\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n@@ -2085,7 +2098,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n         let inner_ty = match expected_sty {\n             Some(ty::ty_closure(ref fty)) => {\n-                match fcx.mk_subty(false, expr.span,\n+                match fcx.mk_subty(false, infer::Misc(expr.span),\n                                    fty.sig.output, ty::mk_bool()) {\n                     result::Ok(_) => {\n                         ty::mk_closure(tcx, ty::ClosureTy {\n@@ -2395,7 +2408,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // Finally, borrowck is charged with guaranteeing that the\n         // value whose address was taken can actually be made to live\n         // as long as it needs to live.\n-        let region = fcx.infcx().next_region_var_nb(expr.span);\n+        let region = fcx.infcx().next_region_var(\n+            infer::AddrOfRegion(expr.span));\n \n         let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n@@ -2437,7 +2451,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           Some(t) =>  t, None => fcx.ret_ty\n         };\n         match expr_opt {\n-          None => match fcx.mk_eqty(false, expr.span,\n+          None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n             result::Ok(_) => { /* fall through */ }\n             result::Err(_) => {\n@@ -2686,7 +2700,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 let el = ty::sequence_element_type(fcx.tcx(),\n                                                                    t1);\n                                 infer::mk_eqty(fcx.infcx(), false,\n-                                               sp, el, t2).is_ok()\n+                                               infer::Misc(sp), el, t2).is_ok()\n                             }\n                         }\n \n@@ -2907,8 +2921,6 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n-        match_region: region,\n-        block_region: region,\n     };\n     _match::check_pat(&pcx, local.node.pat, t);\n     let pat_ty = fcx.node_ty(local.node.pat.id);\n@@ -3412,7 +3424,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n         ast::expr_vstore_uniq => ty::vstore_uniq,\n         ast::expr_vstore_box | ast::expr_vstore_mut_box => ty::vstore_box,\n         ast::expr_vstore_slice | ast::expr_vstore_mut_slice => {\n-            let r = fcx.infcx().next_region_var_nb(e.span);\n+            let r = fcx.infcx().next_region_var(infer::AddrOfSlice(e.span));\n             ty::vstore_slice(r)\n         }\n     }"}, {"sha": "2e41649e4dbb2a0123d95b1b267bd50741669019", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 47, "deletions": 135, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n+/*!\n \n The region check is a final pass that runs over the AST after we have\n inferred the type constraints but before we have actually finalized\n@@ -35,7 +35,9 @@ use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n-use util::ppaux::{note_and_explain_region, ty_to_str, region_to_str};\n+use middle::typeck::infer;\n+use util::ppaux::{note_and_explain_region, ty_to_str,\n+                  region_to_str};\n use middle::pat_util;\n \n use std::result;\n@@ -224,7 +226,9 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n         // variable's type enclose at least the variable's scope.\n \n         let encl_region = tcx.region_maps.encl_region(id);\n-        constrain_regions_in_type_of_node(rcx, id, encl_region, span);\n+        constrain_regions_in_type_of_node(\n+            rcx, id, encl_region,\n+            infer::BindingTypeIsNotValidAtDecl(span));\n     }\n }\n \n@@ -298,7 +302,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n                         //\n                         // FIXME(#6268) remove to support nested method calls\n                         constrain_regions_in_type_of_node(\n-                            rcx, expr.id, ty::re_scope(expr.id), expr.span);\n+                            rcx, expr.id, ty::re_scope(expr.id),\n+                            infer::AutoBorrow(expr.span));\n                     }\n                 }\n                 _ => {}\n@@ -361,8 +366,11 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             match ty::get(target_ty).sty {\n                 ty::ty_trait(_, _, ty::RegionTraitStore(trait_region), _, _) => {\n                     let source_ty = rcx.fcx.expr_ty(source);\n-                    constrain_regions_in_type(rcx, trait_region,\n-                                              expr.span, source_ty);\n+                    constrain_regions_in_type(\n+                        rcx,\n+                        trait_region,\n+                        infer::RelateObjectBound(expr.span),\n+                        source_ty);\n                 }\n                 _ => ()\n             }\n@@ -379,7 +387,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            constrain_regions_in_type(rcx, ty::re_scope(expr.id), expr.span, ty0);\n+            constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n+                                      infer::AddrOf(expr.span), ty0);\n         }\n \n         ast::expr_match(discr, ref arms) => {\n@@ -418,20 +427,8 @@ fn constrain_callee(rcx: @mut Rcx,\n     match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(*) => { }\n         ty::ty_closure(ref closure_ty) => {\n-            match rcx.fcx.mk_subr(true, callee_expr.span,\n-                                  call_region, closure_ty.region) {\n-                result::Err(_) => {\n-                    tcx.sess.span_err(\n-                        callee_expr.span,\n-                        fmt!(\"cannot invoke closure outside of its lifetime\"));\n-                    note_and_explain_region(\n-                        tcx,\n-                        \"the closure is only valid for \",\n-                        closure_ty.region,\n-                        \"\");\n-                }\n-                result::Ok(_) => {}\n-            }\n+            rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n+                            call_region, closure_ty.region);\n         }\n         _ => {\n             // this should not happen, but it does if the program is\n@@ -479,7 +476,8 @@ fn constrain_call(rcx: @mut Rcx,\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n-            rcx, arg_expr.id, callee_region, arg_expr.span);\n+            rcx, arg_expr.id, callee_region,\n+            infer::CallArg(arg_expr.span));\n \n         // unfortunately, there are two means of taking implicit\n         // references, and we need to propagate constraints as a\n@@ -493,7 +491,7 @@ fn constrain_call(rcx: @mut Rcx,\n     // as loop above, but for receiver\n     for receiver.iter().advance |&r| {\n         constrain_regions_in_type_of_node(\n-            rcx, r.id, callee_region, r.span);\n+            rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n             guarantor::for_by_ref(rcx, r, callee_scope);\n         }\n@@ -502,7 +500,8 @@ fn constrain_call(rcx: @mut Rcx,\n     // constrain regions that may appear in the return type to be\n     // valid for the function call:\n     constrain_regions_in_type(\n-        rcx, callee_region, call_expr.span, fn_sig.output);\n+        rcx, callee_region, infer::CallReturn(call_expr.span),\n+        fn_sig.output);\n }\n \n fn constrain_derefs(rcx: @mut Rcx,\n@@ -545,20 +544,8 @@ pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n                                      deref_span: span,\n                                      minimum_lifetime: ty::Region,\n                                      maximum_lifetime: ty::Region) {\n-    match rcx.fcx.mk_subr(true, deref_span,\n-                          minimum_lifetime, maximum_lifetime) {\n-        result::Ok(*) => {}\n-        result::Err(*) => {\n-            rcx.tcx().sess.span_err(\n-                deref_span,\n-                fmt!(\"dereference of reference outside its lifetime\"));\n-            note_and_explain_region(\n-                rcx.tcx(),\n-                \"the reference is only valid for \",\n-                maximum_lifetime,\n-                \"\");\n-        }\n-    }\n+    rcx.fcx.mk_subr(true, infer::DerefPointer(deref_span),\n+                    minimum_lifetime, maximum_lifetime)\n }\n \n \n@@ -581,19 +568,8 @@ fn constrain_index(rcx: @mut Rcx,\n     match ty::get(indexed_ty).sty {\n         ty::ty_estr(ty::vstore_slice(r_ptr)) |\n         ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n-            match rcx.fcx.mk_subr(true, index_expr.span, r_index_expr, r_ptr) {\n-                result::Ok(*) => {}\n-                result::Err(*) => {\n-                    tcx.sess.span_err(\n-                        index_expr.span,\n-                        fmt!(\"index of slice outside its lifetime\"));\n-                    note_and_explain_region(\n-                        tcx,\n-                        \"the slice is only valid for \",\n-                        r_ptr,\n-                        \"\");\n-                }\n-            }\n+            rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n+                            r_index_expr, r_ptr);\n         }\n \n         _ => {}\n@@ -616,33 +592,16 @@ fn constrain_free_variables(rcx: @mut Rcx,\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n         debug!(\"en_region = %s\", en_region.repr(tcx));\n-        match rcx.fcx.mk_subr(true, freevar.span,\n-                              region, en_region) {\n-          result::Ok(()) => {}\n-          result::Err(_) => {\n-            tcx.sess.span_err(\n-                freevar.span,\n-                \"captured variable does not outlive the enclosing closure\");\n-            note_and_explain_region(\n-                tcx,\n-                \"captured variable is valid for \",\n-                en_region,\n-                \"\");\n-            note_and_explain_region(\n-                tcx,\n-                \"closure is valid for \",\n-                region,\n-                \"\");\n-          }\n-        }\n+        rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n+                        region, en_region);\n     }\n }\n \n fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n     id: ast::node_id,\n     minimum_lifetime: ty::Region,\n-    span: span) -> bool\n+    origin: infer::SubregionOrigin) -> bool\n {\n     //! Guarantees that any lifetimes which appear in the type of\n     //! the node `id` (after applying adjustments) are valid for at\n@@ -655,18 +614,18 @@ fn constrain_regions_in_type_of_node(\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n     let adjustment = rcx.fcx.inh.adjustments.find_copy(&id);\n-    let ty = ty::adjust_ty(tcx, span, ty0, adjustment);\n+    let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty=%s, ty0=%s, id=%d, minimum_lifetime=%?, adjustment=%?)\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n            id, minimum_lifetime, adjustment);\n-    constrain_regions_in_type(rcx, minimum_lifetime, span, ty)\n+    constrain_regions_in_type(rcx, minimum_lifetime, origin, ty)\n }\n \n fn constrain_regions_in_type(\n     rcx: @mut Rcx,\n     minimum_lifetime: ty::Region,\n-    span: span,\n+    origin: infer::SubregionOrigin,\n     ty: ty::t) -> bool\n {\n     /*!\n@@ -700,40 +659,14 @@ fn constrain_regions_in_type(\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n             // constrained by `minimum_lifetime` as they are placeholders\n             // for regions that are as-yet-unknown.\n+        } else if r_sub == minimum_lifetime {\n+            rcx.fcx.mk_subr(\n+                true, origin,\n+                r_sub, r_sup);\n         } else {\n-            match rcx.fcx.mk_subr(true, span, r_sub, r_sup) {\n-                result::Err(_) => {\n-                    if r_sub == minimum_lifetime {\n-                        tcx.sess.span_err(\n-                            span,\n-                            fmt!(\"reference is not valid outside of its lifetime\"));\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"the reference is only valid for \",\n-                            r_sup,\n-                            \"\");\n-                    } else {\n-                        tcx.sess.span_err(\n-                            span,\n-                            fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n-                                  the data it references\",\n-                                 rcx.fcx.infcx().ty_to_str(ty)));\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"the pointer is valid for \",\n-                            r_sub,\n-                            \"\");\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"but the referenced data is only valid for \",\n-                            r_sup,\n-                            \"\");\n-                    }\n-                    rcx.errors_reported += 1u;\n-                }\n-                result::Ok(()) => {\n-                }\n-            }\n+            rcx.fcx.mk_subr(\n+                true, infer::ReferenceOutlivesReferent(ty, origin.span()),\n+                r_sub, r_sup);\n         }\n     }\n \n@@ -788,8 +721,9 @@ pub mod guarantor {\n      */\n \n \n-    use middle::typeck::check::regionck::{Rcx, infallibly_mk_subr};\n+    use middle::typeck::check::regionck::Rcx;\n     use middle::typeck::check::regionck::mk_subregion_due_to_derefence;\n+    use middle::typeck::infer;\n     use middle::ty;\n     use syntax::ast;\n     use syntax::codemap::span;\n@@ -869,9 +803,11 @@ pub mod guarantor {\n             rcx: @mut Rcx,\n             expr: @ast::expr,\n             sub_region: ty::Region,\n-            sup_region: Option<ty::Region>) {\n+            sup_region: Option<ty::Region>)\n+        {\n             for sup_region.iter().advance |r| {\n-                infallibly_mk_subr(rcx, true, expr.span, sub_region, *r);\n+                rcx.fcx.mk_subr(true, infer::Reborrow(expr.span),\n+                                sub_region, *r);\n             }\n         }\n     }\n@@ -929,7 +865,7 @@ pub mod guarantor {\n             let tcx = rcx.fcx.ccx.tcx;\n             debug!(\"rptr_ty=%s\", ty_to_str(tcx, rptr_ty));\n             let r = ty::ty_region(tcx, span, rptr_ty);\n-            infallibly_mk_subr(rcx, true, span, r, bound);\n+            rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n         }\n     }\n \n@@ -1259,27 +1195,3 @@ pub mod guarantor {\n     }\n \n }\n-\n-pub fn infallibly_mk_subr(rcx: @mut Rcx,\n-                          a_is_expected: bool,\n-                          span: span,\n-                          a: ty::Region,\n-                          b: ty::Region) {\n-    /*!\n-     * Constrains `a` to be a subregion of `b`.  In many cases, we\n-     * know that this can never yield an error due to the way that\n-     * region inferencing works.  Therefore just report a bug if we\n-     * ever see `Err(_)`.\n-     */\n-\n-    match rcx.fcx.mk_subr(a_is_expected, span, a, b) {\n-        result::Ok(()) => {}\n-        result::Err(e) => {\n-            rcx.fcx.ccx.tcx.sess.span_bug(\n-                span,\n-                fmt!(\"Supposedly infallible attempt to \\\n-                      make %? < %? failed: %?\",\n-                     a, b, e));\n-        }\n-    }\n-}"}, {"sha": "d9086334439610d57025d4e19f26f2e8e173407f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -101,18 +101,18 @@ fn lookup_vtables(vcx: &VtableContext,\n \n             // Substitute the values of the type parameters that may\n             // appear in the bound.\n-            let trait_ref = (*trait_ref).subst(tcx, substs);\n+            let trait_ref = trait_ref.subst(tcx, substs);\n \n             debug!(\"after subst: %s\", trait_ref.repr(tcx));\n \n-            match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n+            match lookup_vtable(vcx, location_info, *ty, trait_ref, is_early) {\n                 Some(vtable) => param_result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n                         location_info.span,\n                         fmt!(\"failed to find an implementation of \\\n                               trait %s for %s\",\n-                             vcx.infcx.trait_ref_to_str(&trait_ref),\n+                             vcx.infcx.trait_ref_to_str(trait_ref),\n                              vcx.infcx.ty_to_str(*ty)));\n                 }\n             }\n@@ -152,8 +152,8 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n \n fn relate_trait_refs(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n-                     act_trait_ref: &ty::TraitRef,\n-                     exp_trait_ref: &ty::TraitRef)\n+                     act_trait_ref: @ty::TraitRef,\n+                     exp_trait_ref: @ty::TraitRef)\n {\n     /*!\n      *\n@@ -162,8 +162,11 @@ fn relate_trait_refs(vcx: &VtableContext,\n      * error otherwise.\n      */\n \n-    match infer::mk_sub_trait_refs(vcx.infcx, false, location_info.span,\n-                                   act_trait_ref, exp_trait_ref)\n+    match infer::mk_sub_trait_refs(vcx.infcx,\n+                                   false,\n+                                   infer::RelateTraitRefs(location_info.span),\n+                                   act_trait_ref,\n+                                   exp_trait_ref)\n     {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n@@ -191,7 +194,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n fn lookup_vtable(vcx: &VtableContext,\n                  location_info: &LocationInfo,\n                  ty: ty::t,\n-                 trait_ref: &ty::TraitRef,\n+                 trait_ref: @ty::TraitRef,\n                  is_early: bool)\n     -> Option<vtable_origin>\n {\n@@ -304,7 +307,8 @@ fn lookup_vtable(vcx: &VtableContext,\n                             } = impl_self_ty(vcx, location_info, im.did);\n                             match infer::mk_subty(vcx.infcx,\n                                                   false,\n-                                                  location_info.span,\n+                                                  infer::RelateSelfType(\n+                                                      location_info.span),\n                                                   ty,\n                                                   for_ty) {\n                                 result::Err(_) => loop,\n@@ -337,11 +341,10 @@ fn lookup_vtable(vcx: &VtableContext,\n                                    vcx.infcx.trait_ref_to_str(trait_ref),\n                                    vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n-                            let of_trait_ref =\n-                                (*of_trait_ref).subst(tcx, &substs);\n+                            let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n                             relate_trait_refs(\n                                 vcx, location_info,\n-                                &of_trait_ref, trait_ref);\n+                                of_trait_ref, trait_ref);\n \n                             // Recall that trait_ref -- the trait type\n                             // we're casting to -- is the trait with\n@@ -450,7 +453,7 @@ fn fixup_ty(vcx: &VtableContext,\n fn connect_trait_tps(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      impl_substs: &ty::substs,\n-                     trait_ref: &ty::TraitRef,\n+                     trait_ref: @ty::TraitRef,\n                      impl_did: ast::def_id)\n {\n     let tcx = vcx.tcx();\n@@ -461,8 +464,8 @@ fn connect_trait_tps(vcx: &VtableContext,\n                                   \"connect_trait_tps invoked on a type impl\")\n     };\n \n-    let impl_trait_ref = (*impl_trait_ref).subst(tcx, impl_substs);\n-    relate_trait_refs(vcx, location_info, &impl_trait_ref, trait_ref);\n+    let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+    relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n }\n \n fn insert_vtables(fcx: @mut FnCtxt,\n@@ -581,7 +584,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                               ccx: fcx.ccx,\n                               infcx: fcx.infcx()\n                           };\n-                          let target_trait_ref = ty::TraitRef {\n+                          let target_trait_ref = @ty::TraitRef {\n                               def_id: target_def_id,\n                               substs: ty::substs {\n                                   tps: copy target_substs.tps,\n@@ -593,7 +596,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                               lookup_vtable(&vcx,\n                                             location_info,\n                                             mt.ty,\n-                                            &target_trait_ref,\n+                                            target_trait_ref,\n                                             is_early);\n                           match vtable_opt {\n                               Some(vtable) => {\n@@ -622,7 +625,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                ty::RegionTraitStore(rb)) => {\n                                   infer::mk_subr(fcx.infcx(),\n                                                  false,\n-                                                 ex.span,\n+                                                 infer::RelateObjectBound(\n+                                                     ex.span),\n                                                  rb,\n                                                  ra);\n                               }"}, {"sha": "24ac63ac7b079d34423f5413b561952065eae4b8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -36,6 +36,7 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n+use middle::typeck::infer;\n use syntax::ast::{crate, def_id, def_struct, def_ty};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n use syntax::ast::{local_crate, method, trait_ref, ty_path};\n@@ -546,10 +547,10 @@ impl CoherenceChecker {\n     pub fn universally_quantify_polytype(&self,\n                                          polytype: ty_param_bounds_and_ty)\n                                          -> UniversalQuantificationResult {\n-        // NDM--this span is bogus.\n         let self_region =\n             polytype.generics.region_param.map(\n-                |_r| self.inference_context.next_region_var_nb(dummy_sp()));\n+                |_| self.inference_context.next_region_var(\n+                    infer::BoundRegionInCoherence));\n \n         let bounds_count = polytype.generics.type_param_defs.len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n@@ -580,11 +581,9 @@ impl CoherenceChecker {\n                                                 b: &'a\n                                                 UniversalQuantificationResult)\n                                                 -> bool {\n-        let mut might_unify = true;\n-        let _ = do self.inference_context.probe {\n-            let result = self.inference_context.sub(true, dummy_sp())\n-                                               .tys(a.monotype, b.monotype);\n-            if result.is_ok() {\n+        match infer::can_mk_subty(self.inference_context,\n+                                  a.monotype, b.monotype) {\n+            Ok(_) => {\n                 // Check to ensure that each parameter binding respected its\n                 // kind bounds.\n                 let xs = [a, b];\n@@ -604,8 +603,7 @@ impl CoherenceChecker {\n                                         self.inference_context.tcx,\n                                         resolved_ty)\n                                     {\n-                                        might_unify = false;\n-                                        break;\n+                                        return false;\n                                     }\n                                 }\n                                 Err(*) => {\n@@ -615,13 +613,13 @@ impl CoherenceChecker {\n                         }\n                     }\n                 }\n-            } else {\n-                might_unify = false;\n+                true\n             }\n \n-            result\n-        };\n-        might_unify\n+            Err(_) => {\n+                false\n+            }\n+        }\n     }\n \n     pub fn get_self_type_for_implementation(&self, implementation: @Impl)"}, {"sha": "de05aca61caf52bbcb9bd94c21c1e1b1d6b90d93", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -615,7 +615,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     };\n     debug!(\"trait_fty (post-subst): %s\", trait_fty.repr(tcx));\n \n-    match infer::mk_subty(infcx, false, cm.span, impl_fty, trait_fty) {\n+    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n+                          impl_fty, trait_fty) {\n         result::Ok(()) => {}\n         result::Err(ref terr) => {\n             tcx.sess.span_err("}, {"sha": "03d243797b32d1818017fd2f2daca9fa913978b1", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -70,7 +70,7 @@ use middle::ty::{AutoDerefRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n use middle::ty::{mt};\n use middle::ty;\n-use middle::typeck::infer::{CoerceResult, resolve_type};\n+use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::CombineFields;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n@@ -165,7 +165,7 @@ impl Coerce {\n             }\n             Err(e) => {\n                 self.infcx.tcx.sess.span_bug(\n-                    self.span,\n+                    self.trace.origin.span(),\n                     fmt!(\"Failed to resolve even without \\\n                           any force options: %?\", e));\n             }\n@@ -189,7 +189,7 @@ impl Coerce {\n         // yield.\n \n         let sub = Sub(**self);\n-        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n \n         let inner_ty = match *sty_a {\n             ty::ty_box(mt_a) => mt_a.ty,\n@@ -227,7 +227,7 @@ impl Coerce {\n             }\n         };\n \n-        let r_a = self.infcx.next_region_var_nb(self.span);\n+        let r_a = self.infcx.next_region_var(Coercion(self.trace));\n         let a_borrowed = ty::mk_estr(self.infcx.tcx, vstore_slice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n@@ -247,7 +247,7 @@ impl Coerce {\n                b.inf_str(self.infcx));\n \n         let sub = Sub(**self);\n-        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n         let ty_inner = match *sty_a {\n             ty::ty_evec(mt, _) => mt.ty,\n             _ => {\n@@ -285,7 +285,7 @@ impl Coerce {\n             }\n         };\n \n-        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n         let a_borrowed = ty::mk_closure(\n             self.infcx.tcx,\n             ty::ClosureTy {"}, {"sha": "8af454774b8283a686e4e26602af5501707f9b0d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -65,6 +65,7 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{InferCtxtMethods};\n use middle::typeck::infer::{InferCtxt, cres, ures};\n+use middle::typeck::infer::{SubtypeOrigin, SubtypeTrace};\n use util::common::indent;\n \n use std::result::{iter_vec2, map_vec2};\n@@ -79,7 +80,7 @@ pub trait Combine {\n     fn infcx(&self) -> @mut InferCtxt;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n-    fn span(&self) -> span;\n+    fn trace(&self) -> SubtypeTrace;\n \n     fn sub(&self) -> Sub;\n     fn lub(&self) -> Lub;\n@@ -121,7 +122,7 @@ pub trait Combine {\n pub struct CombineFields {\n     infcx: @mut InferCtxt,\n     a_is_expected: bool,\n-    span: span,\n+    trace: SubtypeTrace,\n }\n \n pub fn expected_found<C:Combine,T>("}, {"sha": "079a01beaa14f63ffa36604a543d9f2d436cd0b0", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -0,0 +1,434 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Error Reporting Code for the inference engine\n+\n+Because of the way inference, and in particular region inference,\n+works, it often happens that errors are not detected until far after\n+the relevant line of code has been type-checked. Therefore, there is\n+an elaborate system to track why a particular constraint in the\n+inference graph arose so that we can explain to the user what gave\n+rise to a patricular error.\n+\n+The basis of the system are the \"origin\" types. An \"origin\" is the\n+reason that a constraint or inference variable arose. There are\n+different \"origin\" enums for different kinds of constraints/variables\n+(e.g., `SubtypeOrigin`, `RegionVariableOrigin`). An origin always has\n+a span, but also more information so that we can generate a meaningful\n+error message.\n+\n+Having a catalogue of all the different reasons an error can arise is\n+also useful for other reasons, like cross-referencing FAQs etc, though\n+we are not really taking advantage of this yet.\n+\n+# Region Inference\n+\n+Region inference is particularly tricky because it always succeeds \"in\n+the moment\" and simply registers a constraint. Then, at the end, we\n+can compute the full graph and report errors, so we need to be able to\n+store and later report what gave rise to the conflicting constraints.\n+\n+# Subtype Trace\n+\n+Determing whether `T1 <: T2` often involves a number of subtypes and\n+subconstraints along the way. A \"SubtypeTrace\" is an extended version\n+of an origin that traces the types and other values that were being\n+compared. It is not necessarily comprehensive (in fact, at the time of\n+this writing it only tracks the root values being compared) but I'd\n+like to extend it to include significant \"waypoints\". For example, if\n+you are comparing `(T1, T2) <: (T3, T4)`, and the problem is that `T2\n+<: T4` fails, I'd like the trace to include enough information to say\n+\"in the 2nd element of the tuple\". Similarly, failures when comparing\n+arguments or return types in fn types should be able to cite the\n+specific position, etc.\n+\n+# Reality vs plan\n+\n+Of course, there is still a LOT of code in typeck that has yet to be\n+ported to this system, and which relies on string concatenation at the\n+time of error detection.\n+\n+*/\n+\n+use core::prelude::*;\n+use middle::ty;\n+use middle::ty::Region;\n+use middle::typeck::infer;\n+use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::SubtypeTrace;\n+use middle::typeck::infer::SubtypeOrigin;\n+use middle::typeck::infer::SubregionOrigin;\n+use middle::typeck::infer::RegionVariableOrigin;\n+use middle::typeck::infer::Types;\n+use middle::typeck::infer::TraitRefs;\n+use middle::typeck::infer::ValuePairs;\n+use middle::typeck::infer::region_inference::RegionResolutionError;\n+use middle::typeck::infer::region_inference::ConcreteFailure;\n+use middle::typeck::infer::region_inference::SubSupConflict;\n+use middle::typeck::infer::region_inference::SupSupConflict;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n+use util::ppaux::UserString;\n+use util::ppaux::note_and_explain_region;\n+\n+impl InferCtxt {\n+    pub fn report_region_errors(@mut self,\n+                                errors: &OptVec<RegionResolutionError>) {\n+        for errors.each |error| {\n+            match *error {\n+                ConcreteFailure(origin, sub, sup) => {\n+                    self.report_concrete_failure(origin, sub, sup);\n+                }\n+\n+                SubSupConflict(var_origin,\n+                               sub_origin, sub_r,\n+                               sup_origin, sup_r) => {\n+                    self.report_sub_sup_conflict(var_origin,\n+                                                 sub_origin, sub_r,\n+                                                 sup_origin, sup_r);\n+                }\n+\n+                SupSupConflict(var_origin,\n+                               origin1, r1,\n+                               origin2, r2) => {\n+                    self.report_sup_sup_conflict(var_origin,\n+                                                 origin1, r1,\n+                                                 origin2, r2);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn report_and_explain_type_error(@mut self,\n+                                     trace: SubtypeTrace,\n+                                     terr: &ty::type_err) {\n+        let tcx = self.tcx;\n+\n+        let expected_found_str = match self.values_str(&trace.values) {\n+            Some(v) => v,\n+            None => {\n+                return; /* derived error */\n+            }\n+        };\n+\n+        let message_root_str = match trace.origin {\n+            infer::Misc(_) => \"mismatched types\",\n+            infer::MethodCompatCheck(_) => \"method not compatible with trait\",\n+            infer::ExprAssignable(_) => \"mismatched types\",\n+            infer::RelateTraitRefs(_) => \"mismatched traits\",\n+            infer::RelateSelfType(_) => \"mismatched types\"\n+        };\n+\n+        self.tcx.sess.span_err(\n+            trace.origin.span(),\n+            fmt!(\"%s: %s (%s)\",\n+                 message_root_str,\n+                 expected_found_str,\n+                 ty::type_err_to_str(tcx, terr)));\n+\n+        ty::note_and_explain_type_err(self.tcx, terr);\n+    }\n+\n+    fn values_str(@mut self, values: &ValuePairs) -> Option<~str> {\n+        /*!\n+         * Returns a string of the form \"expected `%s` but found `%s`\",\n+         * or None if this is a derived error.\n+         */\n+        match *values {\n+            infer::Types(ref exp_found) => {\n+                self.expected_found_str(exp_found)\n+            }\n+            infer::TraitRefs(ref exp_found) => {\n+                self.expected_found_str(exp_found)\n+            }\n+        }\n+    }\n+\n+    fn expected_found_str<T:UserString+Resolvable>(\n+        @mut self,\n+        exp_found: &ty::expected_found<T>)\n+        -> Option<~str>\n+    {\n+        let expected = exp_found.expected.resolve(self);\n+        if expected.contains_error() {\n+            return None;\n+        }\n+\n+        let found = exp_found.found.resolve(self);\n+        if found.contains_error() {\n+            return None;\n+        }\n+\n+        Some(fmt!(\"expected `%s` but found `%s`\",\n+                  expected.user_string(self.tcx),\n+                  found.user_string(self.tcx)))\n+    }\n+\n+    fn report_concrete_failure(@mut self,\n+                               origin: SubregionOrigin,\n+                               sub: Region,\n+                               sup: Region) {\n+        match origin {\n+            infer::Subtype(trace) => {\n+                let terr = ty::terr_regions_does_not_outlive(sub, sup);\n+                self.report_and_explain_type_error(trace, &terr);\n+            }\n+            infer::Reborrow(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of borrowed pointer outlines \\\n+                     lifetime of borrowed content...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...the borrowed pointer is valid for \",\n+                    sub,\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...but the borrowed content is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"cannot invoke closure outside of its lifetime\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the closure is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::DerefPointer(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"dereference of reference outside its lifetime\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the reference is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::FreeVariable(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"captured variable does not outlive the enclosing closure\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"captured variable is valid for \",\n+                    sup,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"closure is valid for \",\n+                    sub,\n+                    \"\");\n+            }\n+            infer::IndexSlice(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"index of slice outside its lifetime\"));\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the slice is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of the source pointer does not outlive \\\n+                     lifetime bound of the object type\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"object type is valid for \",\n+                    sub,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"source pointer is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::CallRcvr(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of method receiver does not outlive \\\n+                     the method call\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the receiver is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::CallArg(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of function argument does not outlive \\\n+                     the function call\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the function argument is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::CallReturn(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of return value does not outlive \\\n+                     the function call\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the return value is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::AddrOf(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"borrowed pointer is not valid \\\n+                     at the time of borrow\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the borrow is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"automatically borrowed pointer is not valid \\\n+                     at the time of borrow\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the automatic borrow is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of variable does not enclose its declaration\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the variable is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                self.tcx.sess.span_err(\n+                    origin.span(),\n+                    fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n+                          the data it references\",\n+                         ty.user_string(self.tcx)));\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the pointer is valid for \",\n+                    sub,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"but the referenced data is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+        }\n+    }\n+\n+    fn report_sub_sup_conflict(@mut self,\n+                               var_origin: RegionVariableOrigin,\n+                               sub_origin: SubregionOrigin,\n+                               sub_region: Region,\n+                               sup_origin: SubregionOrigin,\n+                               sup_region: Region) {\n+        self.tcx.sess.span_err(\n+            var_origin.span(),\n+            fmt!(\"cannot infer an appropriate lifetime \\\n+                  due to conflicting requirements\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"first, the lifetime cannot outlive \",\n+            sup_region,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            sup_origin.span(),\n+            fmt!(\"...due to the following expression\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"but, the lifetime must be valid for \",\n+            sub_region,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            sub_origin.span(),\n+            fmt!(\"...due to the following expression\"));\n+    }\n+\n+    fn report_sup_sup_conflict(@mut self,\n+                               var_origin: RegionVariableOrigin,\n+                               origin1: SubregionOrigin,\n+                               region1: Region,\n+                               origin2: SubregionOrigin,\n+                               region2: Region) {\n+        self.tcx.sess.span_err(\n+            var_origin.span(),\n+            fmt!(\"cannot infer an appropriate lifetime \\\n+                  due to conflicting requirements\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"first, the lifetime must be contained by \",\n+            region1,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            origin1.span(),\n+            fmt!(\"...due to the following expression\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"but, the lifetime must also be contained by \",\n+            region2,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            origin2.span(),\n+            fmt!(\"...due to the following expression\"));\n+    }\n+}\n+\n+trait Resolvable {\n+    fn resolve(&self, infcx: @mut InferCtxt) -> Self;\n+    fn contains_error(&self) -> bool;\n+}\n+\n+impl Resolvable for ty::t {\n+    fn resolve(&self, infcx: @mut InferCtxt) -> ty::t {\n+        infcx.resolve_type_vars_if_possible(*self)\n+    }\n+    fn contains_error(&self) -> bool {\n+        ty::type_is_error(*self)\n+    }\n+}\n+\n+impl Resolvable for @ty::TraitRef {\n+    fn resolve(&self, infcx: @mut InferCtxt) -> @ty::TraitRef {\n+        @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n+    }\n+    fn contains_error(&self) -> bool {\n+        ty::trait_ref_contains_error(*self)\n+    }\n+}\n+"}, {"sha": "46ccfd24eb56fcd7aa6ce4a7b77f13540a20ed5d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -18,6 +18,7 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n+use middle::typeck::infer::{SubtypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n use syntax::ast;\n@@ -37,7 +38,7 @@ impl Combine for Glb {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn span(&self) -> span { self.span }\n+    fn trace(&self) -> SubtypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }\n@@ -127,9 +128,7 @@ impl Combine for Glb {\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n \n-        do indent {\n-            self.infcx.region_vars.glb_regions(self.span, a, b)\n-        }\n+        Ok(self.infcx.region_vars.glb_regions(Subtype(self.trace), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n@@ -181,11 +180,11 @@ impl Combine for Glb {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, a);\n+                self.trace, a);\n         let a_vars = var_ids(self, a_isr);\n         let (b_with_fresh, b_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, b);\n+                self.trace, b);\n         let b_vars = var_ids(self, b_isr);\n \n         // Collect constraints.\n@@ -277,7 +276,7 @@ impl Combine for Glb {\n             }\n \n             this.infcx.tcx.sess.span_bug(\n-                this.span,\n+                this.trace.origin.span(),\n                 fmt!(\"could not find original bound region for %?\", r));\n         }\n "}, {"sha": "b1a6aefd17949830c481313d31fe47f95fbe0e06", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -530,7 +530,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n             ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n-                    this.span(),\n+                    this.trace().origin.span(),\n                     fmt!(\"Found non-region-vid: %?\", r));\n             }\n         }"}, {"sha": "5d896bdadba7e20be5c5b41559269cfec3bf4190", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -19,6 +19,7 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n+use middle::typeck::infer::{SubtypeTrace, Subtype};\n use middle::typeck::isr_alist;\n use util::common::indent;\n use util::ppaux::mt_to_str;\n@@ -44,7 +45,7 @@ impl Combine for Lub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn span(&self) -> span { self.span }\n+    fn trace(&self) -> SubtypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }\n@@ -119,9 +120,7 @@ impl Combine for Lub {\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n \n-        do indent {\n-            self.infcx.region_vars.lub_regions(self.span, a, b)\n-        }\n+        Ok(self.infcx.region_vars.lub_regions(Subtype(self.trace), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -137,10 +136,10 @@ impl Combine for Lub {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, a);\n+                self.trace, a);\n         let (b_with_fresh, _) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, b);\n+                self.trace, b);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n@@ -196,7 +195,7 @@ impl Combine for Lub {\n             }\n \n             this.infcx.tcx.sess.span_bug(\n-                this.span,\n+                this.trace.origin.span(),\n                 fmt!(\"Region %? is not associated with \\\n                       any bound region from A!\", r0));\n         }"}, {"sha": "29f24f2ce9a7122731d6fcdb3bd6df087f00cab8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 308, "deletions": 57, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -264,7 +264,8 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::isr_alist;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str};\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n+                  UserString};\n \n use std::result;\n use std::vec;\n@@ -286,6 +287,7 @@ pub mod sub;\n pub mod to_str;\n pub mod unify;\n pub mod coercion;\n+pub mod error_reporting;\n \n pub type Bound<T> = Option<T>;\n pub struct Bounds<T> {\n@@ -319,6 +321,127 @@ pub struct InferCtxt {\n     region_vars: RegionVarBindings,\n }\n \n+/// Why did we require that the two types be related?\n+///\n+/// See `error_reporting.rs` for more details\n+pub enum SubtypeOrigin {\n+    // Not yet categorized in a better way\n+    Misc(span),\n+\n+    // Checking that method of impl is compatible with trait\n+    MethodCompatCheck(span),\n+\n+    // Checking that this expression can be assigned where it needs to be\n+    ExprAssignable(@ast::expr),\n+\n+    // Relating trait refs when resolving vtables\n+    RelateTraitRefs(span),\n+\n+    // Relating trait refs when resolving vtables\n+    RelateSelfType(span),\n+}\n+\n+/// See `error_reporting.rs` for more details\n+pub enum ValuePairs {\n+    Types(ty::expected_found<ty::t>),\n+    TraitRefs(ty::expected_found<@ty::TraitRef>),\n+}\n+\n+/// The trace designates the path through inference that we took to\n+/// encounter an error or subtyping constraint.\n+///\n+/// See `error_reporting.rs` for more details.\n+pub struct SubtypeTrace {\n+    origin: SubtypeOrigin,\n+    values: ValuePairs,\n+}\n+\n+/// The origin of a `r1 <= r2` constraint.\n+///\n+/// See `error_reporting.rs` for more details\n+pub enum SubregionOrigin {\n+    // Arose from a subtyping relation\n+    Subtype(SubtypeTrace),\n+\n+    // Invocation of closure must be within its lifetime\n+    InvokeClosure(span),\n+\n+    // Dereference of borrowed pointer must be within its lifetime\n+    DerefPointer(span),\n+\n+    // Closure bound must not outlive captured free variables\n+    FreeVariable(span),\n+\n+    // Index into slice must be within its lifetime\n+    IndexSlice(span),\n+\n+    // When casting `&'a T` to an `&'b Trait` object,\n+    // relating `'a` to `'b`\n+    RelateObjectBound(span),\n+\n+    // Creating a pointer `b` to contents of another borrowed pointer\n+    Reborrow(span),\n+\n+    // (&'a &'b T) where a >= b\n+    ReferenceOutlivesReferent(ty::t, span),\n+\n+    // A `ref b` whose region does not enclose the decl site\n+    BindingTypeIsNotValidAtDecl(span),\n+\n+    // Regions appearing in a method receiver must outlive method call\n+    CallRcvr(span),\n+\n+    // Regions appearing in a function argument must outlive func call\n+    CallArg(span),\n+\n+    // Region in return type of invoked fn must enclose call\n+    CallReturn(span),\n+\n+    // Region resulting from a `&` expr must enclose the `&` expr\n+    AddrOf(span),\n+\n+    // An auto-borrow that does not enclose the expr where it occurs\n+    AutoBorrow(span),\n+}\n+\n+/// Reasons to create a region inference variable\n+///\n+/// See `error_reporting.rs` for more details\n+pub enum RegionVariableOrigin {\n+    // Region variables created for ill-categorized reasons,\n+    // mostly indicates places in need of refactoring\n+    MiscVariable(span),\n+\n+    // Regions created by a `&P` or `[...]` pattern\n+    PatternRegion(span),\n+\n+    // Regions created by `&` operator\n+    AddrOfRegion(span),\n+\n+    // Regions created by `&[...]` literal\n+    AddrOfSlice(span),\n+\n+    // Regions created as part of an autoref of a method receiver\n+    Autoref(span),\n+\n+    // Regions created as part of an automatic coercion\n+    Coercion(SubtypeTrace),\n+\n+    // Region variables created for bound regions\n+    // in a function or method that is called\n+    BoundRegionInFnCall(span, ty::bound_region),\n+\n+    // Region variables created for bound regions\n+    // when doing subtyping/lub/glb computations\n+    BoundRegionInFnType(span, ty::bound_region),\n+\n+    BoundRegionInTypeOrImpl(span),\n+\n+    BoundRegionInCoherence,\n+\n+    BoundRegionError(span),\n+}\n+\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_ty(TyVid),\n@@ -366,14 +489,18 @@ pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n \n pub fn mk_subty(cx: @mut InferCtxt,\n                 a_is_expected: bool,\n-                span: span,\n+                origin: SubtypeOrigin,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n     debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            cx.sub(a_is_expected, span).tys(a, b)\n+            let trace = SubtypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            cx.sub(a_is_expected, trace).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -382,67 +509,90 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            cx.sub(true, codemap::dummy_sp()).tys(a, b)\n+            let trace = SubtypeTrace {\n+                origin: Misc(codemap::dummy_sp()),\n+                values: Types(expected_found(true, a, b))\n+            };\n+            cx.sub(true, trace).tys(a, b)\n         }\n     }.to_ures()\n }\n \n pub fn mk_subr(cx: @mut InferCtxt,\n                a_is_expected: bool,\n-               span: span,\n+               origin: SubregionOrigin,\n                a: ty::Region,\n-               b: ty::Region)\n-            -> ures {\n+               b: ty::Region) {\n     debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n-            cx.sub(a_is_expected, span).regions(a, b)\n-        }\n-    }.to_ures()\n+    cx.region_vars.start_snapshot();\n+    cx.region_vars.make_subregion(origin, a, b);\n+    cx.region_vars.commit();\n }\n \n pub fn mk_eqty(cx: @mut InferCtxt,\n                a_is_expected: bool,\n-               span: span,\n+               origin: SubtypeOrigin,\n                a: ty::t,\n                b: ty::t)\n             -> ures {\n     debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let suber = cx.sub(a_is_expected, span);\n+            let trace = SubtypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            let suber = cx.sub(a_is_expected, trace);\n             eq_tys(&suber, a, b)\n         }\n     }.to_ures()\n }\n \n pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n                          a_is_expected: bool,\n-                         span: span,\n-                         a: &ty::TraitRef,\n-                         b: &ty::TraitRef)\n+                         origin: SubtypeOrigin,\n+                         a: @ty::TraitRef,\n+                         b: @ty::TraitRef)\n     -> ures\n {\n     debug!(\"mk_sub_trait_refs(%s <: %s)\",\n            a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let suber = cx.sub(a_is_expected, span);\n+            let trace = SubtypeTrace {\n+                origin: origin,\n+                values: TraitRefs(expected_found(a_is_expected, a, b))\n+            };\n+            let suber = cx.sub(a_is_expected, trace);\n             suber.trait_refs(a, b)\n         }\n     }.to_ures()\n }\n \n+fn expected_found<T>(a_is_expected: bool,\n+                     a: T,\n+                     b: T) -> ty::expected_found<T> {\n+    if a_is_expected {\n+        ty::expected_found {expected: a, found: b}\n+    } else {\n+        ty::expected_found {expected: b, found: a}\n+    }\n+}\n+\n pub fn mk_coercety(cx: @mut InferCtxt,\n                    a_is_expected: bool,\n-                   span: span,\n+                   origin: SubtypeOrigin,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n     debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            Coerce(cx.combine_fields(a_is_expected, span)).tys(a, b)\n+            let trace = SubtypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            Coerce(cx.combine_fields(a_is_expected, trace)).tys(a, b)\n         }\n     }\n }\n@@ -451,8 +601,11 @@ pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            let span = codemap::dummy_sp();\n-            Coerce(cx.combine_fields(true, span)).tys(a, b)\n+            let trace = SubtypeTrace {\n+                origin: Misc(codemap::dummy_sp()),\n+                values: Types(expected_found(true, a, b))\n+            };\n+            Coerce(cx.combine_fields(true, trace)).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -535,15 +688,17 @@ struct Snapshot {\n }\n \n impl InferCtxt {\n-    pub fn combine_fields(@mut self, a_is_expected: bool, span: span)\n+    pub fn combine_fields(@mut self,\n+                          a_is_expected: bool,\n+                          trace: SubtypeTrace)\n                           -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n-                       span: span}\n+                       trace: trace}\n     }\n \n-    pub fn sub(@mut self, a_is_expected: bool, span: span) -> Sub {\n-        Sub(self.combine_fields(a_is_expected, span))\n+    pub fn sub(@mut self, a_is_expected: bool, trace: SubtypeTrace) -> Sub {\n+        Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n@@ -663,31 +818,13 @@ impl InferCtxt {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    pub fn next_region_var_nb(&mut self, span: span) -> ty::Region {\n-        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n-    }\n-\n-    pub fn next_region_var_with_lb(&mut self,\n-                                   span: span,\n-                                   lb_region: ty::Region)\n-                                   -> ty::Region {\n-        let region_var = self.next_region_var_nb(span);\n-\n-        // add lb_region as a lower bound on the newly built variable\n-        assert!(self.region_vars.make_subregion(span,\n-                                                     lb_region,\n-                                                     region_var).is_ok());\n-\n-        return region_var;\n+    pub fn next_region_var(&mut self, origin: RegionVariableOrigin) -> ty::Region {\n+        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n-    pub fn next_region_var(&mut self, span: span, scope_id: ast::node_id)\n-                           -> ty::Region {\n-        self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n-    }\n-\n-    pub fn resolve_regions(&mut self) {\n-        self.region_vars.resolve_regions();\n+    pub fn resolve_regions(@mut self) {\n+        let errors = self.region_vars.resolve_regions();\n+        self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n     pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n@@ -809,17 +946,13 @@ impl InferCtxt {\n     }\n \n     pub fn replace_bound_regions_with_fresh_regions(&mut self,\n-                                                    span: span,\n+                                                    trace: SubtypeTrace,\n                                                     fsig: &ty::FnSig)\n-                                                    -> (ty::FnSig,\n-                                                        isr_alist) {\n+                                                    -> (ty::FnSig, isr_alist) {\n         let(isr, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n-                // N.B.: The name of the bound region doesn't have anything to\n-                // do with the region variable that's created for it.  The\n-                // only thing we're doing with `br` here is using it in the\n-                // debug message.\n-                let rvar = self.next_region_var_nb(span);\n+                let rvar = self.next_region_var(\n+                    BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region %s maps to %?\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n@@ -838,3 +971,121 @@ pub fn fold_regions_in_sig(\n         ty::fold_regions(tcx, t, |r, in_fn| fldr(r, in_fn))\n     }\n }\n+\n+impl SubtypeTrace {\n+    pub fn span(&self) -> span {\n+        self.origin.span()\n+    }\n+}\n+\n+impl Repr for SubtypeTrace {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"SubtypeTrace(%s)\", self.origin.repr(tcx))\n+    }\n+}\n+\n+impl SubtypeOrigin {\n+    pub fn span(&self) -> span {\n+        match *self {\n+            MethodCompatCheck(span) => span,\n+            ExprAssignable(expr) => expr.span,\n+            Misc(span) => span,\n+            RelateTraitRefs(span) => span,\n+            RelateSelfType(span) => span,\n+        }\n+    }\n+}\n+\n+impl Repr for SubtypeOrigin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            MethodCompatCheck(a) => fmt!(\"MethodCompatCheck(%s)\", a.repr(tcx)),\n+            ExprAssignable(a) => fmt!(\"ExprAssignable(%s)\", a.repr(tcx)),\n+            Misc(a) => fmt!(\"Misc(%s)\", a.repr(tcx)),\n+            RelateTraitRefs(a) => fmt!(\"RelateTraitRefs(%s)\", a.repr(tcx)),\n+            RelateSelfType(a) => fmt!(\"RelateSelfType(%s)\", a.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl SubregionOrigin {\n+    pub fn span(&self) -> span {\n+        match *self {\n+            Subtype(a) => a.span(),\n+            InvokeClosure(a) => a,\n+            DerefPointer(a) => a,\n+            FreeVariable(a) => a,\n+            IndexSlice(a) => a,\n+            RelateObjectBound(a) => a,\n+            Reborrow(a) => a,\n+            ReferenceOutlivesReferent(_, a) => a,\n+            BindingTypeIsNotValidAtDecl(a) => a,\n+            CallRcvr(a) => a,\n+            CallArg(a) => a,\n+            CallReturn(a) => a,\n+            AddrOf(a) => a,\n+            AutoBorrow(a) => a,\n+        }\n+    }\n+}\n+\n+impl Repr for SubregionOrigin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            Subtype(a) => fmt!(\"Subtype(%s)\", a.repr(tcx)),\n+            InvokeClosure(a) => fmt!(\"InvokeClosure(%s)\", a.repr(tcx)),\n+            DerefPointer(a) => fmt!(\"DerefPointer(%s)\", a.repr(tcx)),\n+            FreeVariable(a) => fmt!(\"FreeVariable(%s)\", a.repr(tcx)),\n+            IndexSlice(a) => fmt!(\"IndexSlice(%s)\", a.repr(tcx)),\n+            RelateObjectBound(a) => fmt!(\"RelateObjectBound(%s)\", a.repr(tcx)),\n+            Reborrow(a) => fmt!(\"Reborrow(%s)\", a.repr(tcx)),\n+            ReferenceOutlivesReferent(_, a) => fmt!(\"ReferenceOutlivesReferent(%s)\", a.repr(tcx)),\n+            BindingTypeIsNotValidAtDecl(a) => fmt!(\"BindingTypeIsNotValidAtDecl(%s)\", a.repr(tcx)),\n+            CallRcvr(a) => fmt!(\"CallRcvr(%s)\", a.repr(tcx)),\n+            CallArg(a) => fmt!(\"CallArg(%s)\", a.repr(tcx)),\n+            CallReturn(a) => fmt!(\"CallReturn(%s)\", a.repr(tcx)),\n+            AddrOf(a) => fmt!(\"AddrOf(%s)\", a.repr(tcx)),\n+            AutoBorrow(a) => fmt!(\"AutoBorrow(%s)\", a.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl RegionVariableOrigin {\n+    pub fn span(&self) -> span {\n+        match *self {\n+            MiscVariable(a) => a,\n+            PatternRegion(a) => a,\n+            AddrOfRegion(a) => a,\n+            AddrOfSlice(a) => a,\n+            Autoref(a) => a,\n+            Coercion(a) => a.span(),\n+            BoundRegionInFnCall(a, _) => a,\n+            BoundRegionInFnType(a, _) => a,\n+            BoundRegionInTypeOrImpl(a) => a,\n+            BoundRegionInCoherence => codemap::dummy_sp(),\n+            BoundRegionError(a) => a,\n+        }\n+    }\n+}\n+\n+impl Repr for RegionVariableOrigin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            MiscVariable(a) => fmt!(\"MiscVariable(%s)\", a.repr(tcx)),\n+            PatternRegion(a) => fmt!(\"PatternRegion(%s)\", a.repr(tcx)),\n+            AddrOfRegion(a) => fmt!(\"AddrOfRegion(%s)\", a.repr(tcx)),\n+            AddrOfSlice(a) => fmt!(\"AddrOfSlice(%s)\", a.repr(tcx)),\n+            Autoref(a) => fmt!(\"Autoref(%s)\", a.repr(tcx)),\n+            Coercion(a) => fmt!(\"Coercion(%s)\", a.repr(tcx)),\n+            BoundRegionInFnCall(a, b) => fmt!(\"BoundRegionInFnCall(%s,%s)\",\n+                                              a.repr(tcx), b.repr(tcx)),\n+            BoundRegionInFnType(a, b) => fmt!(\"BoundRegionInFnType(%s,%s)\",\n+                                              a.repr(tcx), b.repr(tcx)),\n+            BoundRegionInTypeOrImpl(a) => fmt!(\"BoundRegionInTypeOrImpl(%s)\",\n+                                               a.repr(tcx)),\n+            BoundRegionInCoherence => fmt!(\"BoundRegionInCoherence\"),\n+            BoundRegionError(a) => fmt!(\"BoundRegionError(%s)\", a.repr(tcx)),\n+        }\n+    }\n+}\n+"}, {"sha": "82fbb6b8ce7e650010e18046ec09e2b069971cbf", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 244, "deletions": 201, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -542,15 +542,19 @@ use middle::ty::{FreeRegion, Region, RegionVid};\n use middle::ty::{re_empty, re_static, re_infer, re_free, re_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n+use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n+use middle::typeck::infer;\n use util::common::indenter;\n-use util::ppaux::note_and_explain_region;\n+use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::Cell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n use syntax::codemap::span;\n use syntax::ast;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n \n #[deriving(Eq,IterBytes)]\n enum Constraint {\n@@ -576,12 +580,37 @@ enum CombineMapType {\n     Lub, Glb\n }\n \n+pub enum RegionResolutionError {\n+    /// `ConcreteFailure(o, a, b)`:\n+    ///\n+    /// `o` requires that `a <= b`, but this does not hold\n+    ConcreteFailure(SubregionOrigin, Region, Region),\n+\n+    /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n+    ///\n+    /// Could not infer a value for `v` because `sub_r <= v` (due to\n+    /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n+    /// `sub_r <= sup_r` does not hold.\n+    SubSupConflict(RegionVariableOrigin,\n+                   SubregionOrigin, Region,\n+                   SubregionOrigin, Region),\n+\n+    /// `SupSupConflict(v, origin1, r1, origin2, r2)`:\n+    ///\n+    /// Could not infer a value for `v` because `v <= r1` (due to\n+    /// `origin1`) and `v <= r2` (due to `origin2`) and\n+    /// `r1` and `r2` have no intersection.\n+    SupSupConflict(RegionVariableOrigin,\n+                   SubregionOrigin, Region,\n+                   SubregionOrigin, Region),\n+}\n+\n type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_spans: ~[span],\n-    constraints: HashMap<Constraint, span>,\n+    var_origins: ~[RegionVariableOrigin],\n+    constraints: HashMap<Constraint, SubregionOrigin>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n     skolemization_count: uint,\n@@ -606,7 +635,7 @@ pub struct RegionVarBindings {\n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_spans: ~[],\n+        var_origins: ~[],\n         values: Cell::new_empty(),\n         constraints: HashMap::new(),\n         lubs: HashMap::new(),\n@@ -647,8 +676,8 @@ impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                assert_eq!(self.var_spans.len(), vid.to_uint() + 1);\n-                self.var_spans.pop();\n+                assert_eq!(self.var_origins.len(), vid.to_uint() + 1);\n+                self.var_origins.pop();\n               }\n               AddConstraint(ref constraint) => {\n                 self.constraints.remove(constraint);\n@@ -664,18 +693,18 @@ impl RegionVarBindings {\n     }\n \n     pub fn num_vars(&mut self) -> uint {\n-        self.var_spans.len()\n+        self.var_origins.len()\n     }\n \n-    pub fn new_region_var(&mut self, span: span) -> RegionVid {\n+    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n-        self.var_spans.push(span);\n+        self.var_origins.push(origin);\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n-        debug!(\"created new region variable %? with span %?\",\n-               vid, self.tcx.sess.codemap.span_to_str(span));\n+        debug!(\"created new region variable %? with origin %?\",\n+               vid, origin.repr(self.tcx));\n         return vid;\n     }\n \n@@ -705,109 +734,106 @@ impl RegionVarBindings {\n         re_bound(br_fresh(sc))\n     }\n \n-    pub fn add_constraint(&mut self, constraint: Constraint, span: span) {\n+    pub fn add_constraint(&mut self,\n+                          constraint: Constraint,\n+                          origin: SubregionOrigin) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n \n-        if self.constraints.insert(constraint, span) {\n+        if self.constraints.insert(constraint, origin) {\n             if self.in_snapshot() {\n                 self.undo_log.push(AddConstraint(constraint));\n             }\n         }\n     }\n \n-    pub fn make_subregion(&mut self, span: span, sub: Region, sup: Region)\n-                          -> cres<()> {\n+    pub fn make_subregion(&mut self,\n+                          origin: SubregionOrigin,\n+                          sub: Region,\n+                          sup: Region) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n         match (sub, sup) {\n           (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n-            self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), span);\n-            Ok(())\n+            self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n           }\n           (r, re_infer(ReVar(sup_id))) => {\n-            self.add_constraint(ConstrainRegSubVar(r, sup_id), span);\n-            Ok(())\n+            self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n           }\n           (re_infer(ReVar(sub_id)), r) => {\n-            self.add_constraint(ConstrainVarSubReg(sub_id, r), span);\n-            Ok(())\n+            self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n           (re_bound(br), _) => {\n             self.tcx.sess.span_bug(\n-                span,\n+                origin.span(),\n                 fmt!(\"Cannot relate bound region as subregion: %?\", br));\n           }\n           (_, re_bound(br)) => {\n             self.tcx.sess.span_bug(\n-                span,\n+                origin.span(),\n                 fmt!(\"Cannot relate bound region as superregion: %?\", br));\n           }\n           _ => {\n-            if self.is_subregion_of(sub, sup) {\n-                Ok(())\n-            } else {\n-                Err(ty::terr_regions_does_not_outlive(sub, sup))\n-            }\n+            self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n           }\n         }\n     }\n \n-    pub fn lub_regions(&mut self, span: span, a: Region, b: Region)\n-                       -> cres<Region> {\n+    pub fn lub_regions(&mut self,\n+                       origin: SubregionOrigin,\n+                       a: Region,\n+                       b: Region)\n+                       -> Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n-          (re_static, _) | (_, re_static) => {\n-            Ok(re_static) // nothing lives longer than static\n-          }\n-\n-          (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n-            self.combine_vars(\n-                Lub, a, b, span,\n-                |this, old_r, new_r| this.make_subregion(span, old_r, new_r))\n-          }\n+            (re_static, _) | (_, re_static) => {\n+                re_static // nothing lives longer than static\n+            }\n \n-          _ => {\n-            Ok(self.lub_concrete_regions(a, b))\n-          }\n+            _ => {\n+                self.combine_vars(\n+                    Lub, a, b, origin,\n+                    |this, old_r, new_r|\n+                    this.make_subregion(origin, old_r, new_r))\n+            }\n         }\n     }\n \n-    pub fn glb_regions(&mut self, span: span, a: Region, b: Region)\n-                       -> cres<Region> {\n+    pub fn glb_regions(&mut self,\n+                       origin: SubregionOrigin,\n+                       a: Region,\n+                       b: Region)\n+                       -> Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n         match (a, b) {\n-          (re_static, r) | (r, re_static) => {\n-            // static lives longer than everything else\n-            Ok(r)\n-          }\n-\n-          (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n-            self.combine_vars(\n-                Glb, a, b, span,\n-                |this, old_r, new_r| this.make_subregion(span, new_r, old_r))\n-          }\n+            (re_static, r) | (r, re_static) => {\n+                // static lives longer than everything else\n+                r\n+            }\n \n-          _ => {\n-            self.glb_concrete_regions(a, b)\n-          }\n+            _ => {\n+                self.combine_vars(\n+                    Glb, a, b, origin,\n+                    |this, old_r, new_r|\n+                    this.make_subregion(origin, new_r, old_r))\n+            }\n         }\n     }\n \n     pub fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n-                self.var_spans[rid.to_uint()],\n+                self.var_origins[rid.to_uint()].span(),\n                 fmt!(\"Attempt to resolve region variable before values have \\\n                       been computed!\"));\n         }\n@@ -830,46 +856,41 @@ impl RegionVarBindings {\n         }\n     }\n \n+    fn combine_map<'a>(&'a mut self,\n+                       t: CombineMapType)\n+                       -> &'a mut CombineMap\n+    {\n+        match t {\n+            Glb => &mut self.glbs,\n+            Lub => &mut self.lubs,\n+        }\n+    }\n+\n     pub fn combine_vars(&mut self,\n                         t: CombineMapType,\n                         a: Region,\n                         b: Region,\n-                        span: span,\n+                        origin: SubregionOrigin,\n                         relate: &fn(this: &mut RegionVarBindings,\n                                     old_r: Region,\n-                                    new_r: Region) -> cres<()>)\n-                        -> cres<Region> {\n+                                    new_r: Region))\n+                        -> Region {\n         let vars = TwoRegions { a: a, b: b };\n-        let c;\n-        {\n-            // FIXME (#3850): shouldn't need a scope, nor should this need to be\n-            //                done twice to get the maps out\n-            {\n-                let combines = match t {\n-                    Glb => &self.glbs, Lub => &self.lubs\n-                };\n-                match combines.find(&vars) {\n-                  Some(&c) => return Ok(re_infer(ReVar(c))),\n-                  None => ()\n-                }\n-            }\n-            c = self.new_region_var(span);\n-            {\n-                let combines = match t {\n-                    Glb => &mut self.glbs, Lub => &mut self.lubs\n-                };\n-                combines.insert(vars, c);\n+        match self.combine_map(t).find(&vars) {\n+            Some(&c) => {\n+                return re_infer(ReVar(c));\n             }\n+            None => {}\n         }\n+        let c = self.new_region_var(infer::MiscVariable(origin.span()));\n+        self.combine_map(t).insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.push(AddCombination(t, vars));\n         }\n-        do relate(self, a, re_infer(ReVar(c))).then {\n-            do relate(self, b, re_infer(ReVar(c))).then {\n-                debug!(\"combine_vars() c=%?\", c);\n-                Ok(re_infer(ReVar(c)))\n-            }\n-        }\n+        relate(self, a, re_infer(ReVar(c)));\n+        relate(self, b, re_infer(ReVar(c)));\n+        debug!(\"combine_vars() c=%?\", c);\n+        re_infer(ReVar(c))\n     }\n \n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n@@ -924,18 +945,21 @@ impl RegionVarBindings {\n                     AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n                         Some((re_infer(ReVar(*a)), *b))\n                     }\n+                    AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        Some((a, b))\n+                    }\n                     _ => {\n                         None\n                     }\n                 };\n \n                 match regs {\n                     None => {}\n-                    Some((ref r1, ref r2)) => {\n+                    Some((r1, r2)) => {\n                         result_set =\n-                            consider_adding_edge(result_set, &r, r1, r2);\n+                            consider_adding_edge(result_set, r, r1, r2);\n                         result_set =\n-                            consider_adding_edge(result_set, &r, r2, r1);\n+                            consider_adding_edge(result_set, r, r2, r1);\n                     }\n                 }\n \n@@ -948,14 +972,14 @@ impl RegionVarBindings {\n         return result_set;\n \n         fn consider_adding_edge(result_set: ~[Region],\n-                                r: &Region,\n-                                r1: &Region,\n-                                r2: &Region) -> ~[Region]\n+                                r: Region,\n+                                r1: Region,\n+                                r2: Region) -> ~[Region]\n         {\n             let mut result_set = result_set;\n-            if *r == *r1 { // Clearly, this is potentially inefficient.\n+            if r == r1 { // Clearly, this is potentially inefficient.\n                 if !result_set.iter().any_(|x| x == r2) {\n-                    result_set.push(*r2);\n+                    result_set.push(r2);\n                 }\n             }\n             return result_set;\n@@ -969,10 +993,12 @@ impl RegionVarBindings {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    pub fn resolve_regions(&mut self) {\n+    pub fn resolve_regions(&mut self) -> OptVec<RegionResolutionError> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n-        let v = self.infer_variable_values();\n+        let mut errors = opt_vec::Empty;\n+        let v = self.infer_variable_values(&mut errors);\n         self.values.put_back(v);\n+        errors\n     }\n }\n \n@@ -994,7 +1020,7 @@ impl RegionVarBindings {\n \n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_spans[v_id.to_uint()],\n+                self.var_origins[v_id.to_uint()].span(),\n                 fmt!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: %?, %?\", a, b));\n           }\n@@ -1096,7 +1122,7 @@ impl RegionVarBindings {\n             (re_infer(ReVar(v_id)), _) |\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_spans[v_id.to_uint()],\n+                    self.var_origins[v_id.to_uint()].span(),\n                     fmt!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: %?, %?\", a, b));\n             }\n@@ -1173,9 +1199,11 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn report_type_error(&mut self, span: span, terr: &ty::type_err) {\n+    fn report_type_error(&mut self,\n+                         origin: SubregionOrigin,\n+                         terr: &ty::type_err) {\n         let terr_str = ty::type_err_to_str(self.tcx, terr);\n-        self.tcx.sess.span_err(span, terr_str);\n+        self.tcx.sess.span_err(origin.span(), terr_str);\n     }\n \n     fn intersect_scopes(&self,\n@@ -1210,7 +1238,7 @@ enum Classification { Expanding, Contracting }\n enum GraphNodeValue { NoValue, Value(Region), ErrorValue }\n \n struct GraphNode {\n-    span: span,\n+    origin: RegionVariableOrigin,\n     classification: Classification,\n     value: GraphNodeValue,\n     head_edge: [uint, ..2],\n@@ -1219,28 +1247,30 @@ struct GraphNode {\n struct GraphEdge {\n     next_edge: [uint, ..2],\n     constraint: Constraint,\n-    span: span,\n }\n \n struct Graph {\n     nodes: ~[GraphNode],\n     edges: ~[GraphEdge],\n }\n \n-struct SpannedRegion {\n+struct RegionAndOrigin {\n     region: Region,\n-    span: span,\n+    origin: SubregionOrigin,\n }\n \n impl RegionVarBindings {\n-    pub fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n+    fn infer_variable_values(&mut self,\n+                             errors: &mut OptVec<RegionResolutionError>)\n+                             -> ~[GraphNodeValue] {\n         let mut graph = self.construct_graph();\n         self.expansion(&mut graph);\n         self.contraction(&mut graph);\n-        self.extract_values_and_report_conflicts(&graph)\n+        self.collect_concrete_region_errors(&graph, errors);\n+        self.extract_values_and_collect_conflicts(&graph, errors)\n     }\n \n-    pub fn construct_graph(&mut self) -> Graph {\n+    fn construct_graph(&mut self) -> Graph {\n         let num_vars = self.num_vars();\n         let num_edges = self.constraints.len();\n \n@@ -1251,19 +1281,18 @@ impl RegionVarBindings {\n                 // those nodes that have a concrete region predecessor to\n                 // Expanding.\n                 classification: Contracting,\n-                span: self.var_spans[var_idx],\n+                origin: self.var_origins[var_idx],\n                 value: NoValue,\n                 head_edge: [uint::max_value, uint::max_value]\n             }\n         });\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.iter().advance |(constraint, span)| {\n+        for self.constraints.iter().advance |(constraint, _)| {\n             edges.push(GraphEdge {\n                 next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,\n-                span: *span\n             });\n         }\n \n@@ -1284,6 +1313,10 @@ impl RegionVarBindings {\n               ConstrainVarSubReg(a_id, _) => {\n                 insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n               }\n+              ConstrainRegSubReg(*) => {\n+                  // Relations between two concrete regions do not\n+                  // require an edge in the graph.\n+              }\n             }\n         }\n \n@@ -1305,7 +1338,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn expansion(&mut self, graph: &mut Graph) {\n+    fn expansion(&mut self, graph: &mut Graph) {\n         do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n@@ -1325,15 +1358,19 @@ impl RegionVarBindings {\n                 // This is a contraction constraint.  Ignore it.\n                 false\n               }\n+              ConstrainRegSubReg(*) => {\n+                // No region variables involved. Ignore.\n+                false\n+              }\n             }\n         }\n     }\n \n-    pub fn expand_node(&mut self,\n-                       a_region: Region,\n-                       b_vid: RegionVid,\n-                       b_node: &mut GraphNode)\n-                       -> bool {\n+    fn expand_node(&mut self,\n+                   a_region: Region,\n+                   b_vid: RegionVid,\n+                   b_node: &mut GraphNode)\n+                   -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n                a_region, b_vid, b_node.value);\n \n@@ -1365,7 +1402,8 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn contraction(&mut self, graph: &mut Graph) {\n+    fn contraction(&mut self,\n+                   graph: &mut Graph) {\n         do iterate_until_fixed_point(~\"Contraction\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(*) => {\n@@ -1385,15 +1423,19 @@ impl RegionVarBindings {\n                 let a_node = &mut nodes[a_vid.to_uint()];\n                 self.contract_node(a_vid, a_node, b_region)\n               }\n+              ConstrainRegSubReg(*) => {\n+                // No region variables involved. Ignore.\n+                false\n+              }\n             }\n         }\n     }\n \n-    pub fn contract_node(&mut self,\n-                         a_vid: RegionVid,\n-                         a_node: &mut GraphNode,\n-                         b_region: Region)\n-                         -> bool {\n+    fn contract_node(&mut self,\n+                     a_vid: RegionVid,\n+                     a_node: &mut GraphNode,\n+                     b_region: Region)\n+                     -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n                a_vid, a_node.value, a_node.classification, b_region);\n \n@@ -1461,9 +1503,42 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn extract_values_and_report_conflicts(&mut self, graph: &Graph)\n-                                               -> ~[GraphNodeValue] {\n-        debug!(\"extract_values_and_report_conflicts()\");\n+    fn collect_concrete_region_errors(\n+        &mut self,\n+        graph: &Graph,\n+        errors: &mut OptVec<RegionResolutionError>)\n+    {\n+        let num_edges = graph.edges.len();\n+        for uint::range(0, num_edges) |edge_idx| {\n+            let edge = &graph.edges[edge_idx];\n+            let origin = self.constraints.get_copy(&edge.constraint);\n+\n+            let (sub, sup) = match edge.constraint {\n+                ConstrainVarSubVar(*) |\n+                ConstrainRegSubVar(*) |\n+                ConstrainVarSubReg(*) => {\n+                    loop;\n+                }\n+                ConstrainRegSubReg(sub, sup) => {\n+                    (sub, sup)\n+                }\n+            };\n+\n+            if self.is_subregion_of(sub, sup) {\n+                loop;\n+            }\n+\n+            errors.push(ConcreteFailure(origin, sub, sup));\n+        }\n+    }\n+\n+    fn extract_values_and_collect_conflicts(\n+        &mut self,\n+        graph: &Graph,\n+        errors: &mut OptVec<RegionResolutionError>)\n+        -> ~[GraphNodeValue]\n+    {\n+        debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1516,12 +1591,12 @@ impl RegionVarBindings {\n                     let node_vid = RegionVid { id: idx };\n                     match node.classification {\n                         Expanding => {\n-                            self.report_error_for_expanding_node(\n-                                graph, dup_vec, node_vid);\n+                            self.collect_error_for_expanding_node(\n+                                graph, dup_vec, node_vid, errors);\n                         }\n                         Contracting => {\n-                            self.report_error_for_contracting_node(\n-                                graph, dup_vec, node_vid);\n+                            self.collect_error_for_contracting_node(\n+                                graph, dup_vec, node_vid, errors);\n                         }\n                     }\n                 }\n@@ -1531,10 +1606,13 @@ impl RegionVarBindings {\n         }).collect()\n     }\n \n-    pub fn report_error_for_expanding_node(&mut self,\n-                                           graph: &Graph,\n-                                           dup_vec: &mut [uint],\n-                                           node_idx: RegionVid) {\n+    fn collect_error_for_expanding_node(\n+        &mut self,\n+        graph: &Graph,\n+        dup_vec: &mut [uint],\n+        node_idx: RegionVid,\n+        errors: &mut OptVec<RegionResolutionError>)\n+    {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (lower_bounds, lower_dup) =\n@@ -1550,50 +1628,33 @@ impl RegionVarBindings {\n             for upper_bounds.iter().advance |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n-\n-                    self.tcx.sess.span_err(\n-                        self.var_spans[node_idx.to_uint()],\n-                        fmt!(\"cannot infer an appropriate lifetime \\\n-                              due to conflicting requirements\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"first, the lifetime cannot outlive \",\n-                        upper_bound.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        upper_bound.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"but, the lifetime must be valid for \",\n+                    errors.push(SubSupConflict(\n+                        self.var_origins[node_idx.to_uint()],\n+                        lower_bound.origin,\n                         lower_bound.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        lower_bound.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n+                        upper_bound.origin,\n+                        upper_bound.region));\n                     return;\n                 }\n             }\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_spans[node_idx.to_uint()],\n-            fmt!(\"report_error_for_expanding_node() could not find error \\\n+            self.var_origins[node_idx.to_uint()].span(),\n+            fmt!(\"collect_error_for_expanding_node() could not find error \\\n                   for var %?, lower_bounds=%s, upper_bounds=%s\",\n                  node_idx,\n                  lower_bounds.map(|x| x.region).repr(self.tcx),\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    pub fn report_error_for_contracting_node(&mut self,\n-                                             graph: &Graph,\n-                                             dup_vec: &mut [uint],\n-                                             node_idx: RegionVid) {\n+    fn collect_error_for_contracting_node(\n+        &mut self,\n+        graph: &Graph,\n+        dup_vec: &mut [uint],\n+        node_idx: RegionVid,\n+        errors: &mut OptVec<RegionResolutionError>)\n+    {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n@@ -1609,56 +1670,36 @@ impl RegionVarBindings {\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n                   Err(_) => {\n-\n-                    self.tcx.sess.span_err(\n-                        self.var_spans[node_idx.to_uint()],\n-                        fmt!(\"cannot infer an appropriate lifetime \\\n-                              due to conflicting requirements\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"first, the lifetime must be contained by \",\n+                    errors.push(SupSupConflict(\n+                        self.var_origins[node_idx.to_uint()],\n+                        upper_bound_1.origin,\n                         upper_bound_1.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        upper_bound_1.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"but, the lifetime must also be contained by \",\n-                        upper_bound_2.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        upper_bound_2.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n+                        upper_bound_2.origin,\n+                        upper_bound_2.region));\n                     return;\n                   }\n                 }\n             }\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_spans[node_idx.to_uint()],\n-            fmt!(\"report_error_for_contracting_node() could not find error \\\n+            self.var_origins[node_idx.to_uint()].span(),\n+            fmt!(\"collect_error_for_contracting_node() could not find error \\\n                   for var %?, upper_bounds=%s\",\n                  node_idx,\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    pub fn collect_concrete_regions(&mut self,\n-                                    graph: &Graph,\n-                                    orig_node_idx: RegionVid,\n-                                    dir: Direction,\n-                                    dup_vec: &mut [uint])\n-                                    -> (~[SpannedRegion], bool) {\n+    fn collect_concrete_regions(&mut self,\n+                                graph: &Graph,\n+                                orig_node_idx: RegionVid,\n+                                dir: Direction,\n+                                dup_vec: &mut [uint])\n+                                -> (~[RegionAndOrigin], bool) {\n         struct WalkState {\n             set: HashSet<RegionVid>,\n             stack: ~[RegionVid],\n-            result: ~[SpannedRegion],\n+            result: ~[RegionAndOrigin],\n             dup_found: bool\n         }\n         let mut state = WalkState {\n@@ -1720,17 +1761,19 @@ impl RegionVarBindings {\n \n                     ConstrainRegSubVar(region, _) |\n                     ConstrainVarSubReg(_, region) => {\n-                        state.result.push(SpannedRegion {\n+                        state.result.push(RegionAndOrigin {\n                             region: region,\n-                            span: edge.span\n+                            origin: this.constraints.get_copy(&edge.constraint)\n                         });\n                     }\n+\n+                    ConstrainRegSubReg(*) => {}\n                 }\n             }\n         }\n     }\n \n-    pub fn each_edge(&mut self,\n+    pub fn each_edge(&self,\n                      graph: &Graph,\n                      node_idx: RegionVid,\n                      dir: Direction,"}, {"sha": "ea66f8601af4a68733dce505f5736e774c8b3ff9", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n+use middle::typeck::infer::{SubtypeTrace, Subtype};\n use util::common::{indent, indenter};\n use util::ppaux::bound_region_to_str;\n \n@@ -36,7 +37,7 @@ impl Combine for Sub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn span(&self) -> span { self.span }\n+    fn trace(&self) -> SubtypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }\n@@ -62,12 +63,8 @@ impl Combine for Sub {\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n-        do indent {\n-            match self.infcx.region_vars.make_subregion(self.span, a, b) {\n-              Ok(()) => Ok(a),\n-              Err(ref e) => Err((*e))\n-            }\n-        }\n+        self.infcx.region_vars.make_subregion(Subtype(self.trace), a, b);\n+        Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n@@ -170,7 +167,7 @@ impl Combine for Sub {\n         // region variable.\n         let (a_sig, _) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, a);\n+                self.trace, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region."}, {"sha": "bbcfc73853a1e00d292ae078b3ec18afb214c4ea", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -263,7 +263,7 @@ pub fn require_same_types(\n       }\n     }\n \n-    match infer::mk_eqty(l_infcx, t1_is_expected, span, t1, t2) {\n+    match infer::mk_eqty(l_infcx, t1_is_expected, infer::Misc(span), t1, t2) {\n         result::Ok(()) => true,\n         result::Err(ref terr) => {\n             l_tcx.sess.span_err(span, msg() + \": \" +"}, {"sha": "1a0cdd6fa64fad484879a63decb8213213445cff", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -608,6 +608,12 @@ impl Repr for @ast::pat {\n     }\n }\n \n+impl Repr for ty::bound_region {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        bound_region_to_str(tcx, *self)\n+    }\n+}\n+\n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         region_to_str(tcx, \"\", false, *self)\n@@ -793,6 +799,19 @@ impl Repr for ty::BuiltinBounds {\n     }\n }\n \n+impl Repr for span {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        tcx.sess.codemap.span_to_str(*self)\n+    }\n+}\n+\n+impl<A:UserString> UserString for @A {\n+    fn user_string(&self, tcx: ctxt) -> ~str {\n+        let this: &A = &**self;\n+        this.user_string(tcx)\n+    }\n+}\n+\n impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {"}, {"sha": "b00b701191e2ec43eeb4b49a8942ac6ec9560a02", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of return value does not outlive the function call\n extern mod extra;\n use extra::arc;\n fn main() {"}, {"sha": "001e6cf922f67e0977168b4e933c6fa50b0be030", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n extern mod extra;\n use extra::arc;\n fn main() {\n     let x = ~arc::RWARC(1);\n-    let mut y = None;\n+    let mut y = None; //~ ERROR lifetime of variable does not enclose its declaration\n     do x.write |one| {\n         y = Some(one);\n     }\n     *y.unwrap() = 2;\n+    //~^ ERROR lifetime of return value does not outlive the function call\n+    //~^^ ERROR dereference of reference outside its lifetime\n }"}, {"sha": "59e899dbbf2ef23dc9b857af11fa84bde3b355d9", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::arc;\n fn main() {"}, {"sha": "2599fb4dfa0c7e7c4e66724c65e8aae55ef1618e", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::arc;\n fn main() {"}, {"sha": "4ee824d1d49ad6cd6a6d999018e6603f4ac36305", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -1,6 +1,4 @@\n-extern mod extra;\n-\n-fn main() {\n+pub fn main() {\n     let foo = ~3;\n     let _pfoo = &foo;\n     let _f: @fn() -> int = || *foo + 5;"}, {"sha": "33e122867bb3d0e0795748e515344e47b78e04d0", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -23,13 +23,13 @@ fn main() {\n     // Error results because the type of is inferred to be\n     // @repeat<&'blk int> where blk is the lifetime of the block below.\n \n-    let y = { //~ ERROR reference is not valid\n+    let y = { //~ ERROR lifetime of variable does not enclose its declaration\n         let x: &'blk int = &3;\n         repeater(@x)\n     };\n-    assert!(3 == *(y.get())); //~ ERROR dereference of reference outside its lifetime\n-    //~^ ERROR reference is not valid outside of its lifetime\n-    //~^^ ERROR reference is not valid outside of its lifetime\n-    //~^^^ ERROR reference is not valid outside of its lifetime\n+    assert!(3 == *(y.get()));\n+    //~^ ERROR dereference of reference outside its lifetime\n+    //~^^ ERROR automatically borrowed pointer is not valid at the time of borrow\n+    //~^^^ ERROR lifetime of return value does not outlive the function call\n     //~^^^^ ERROR cannot infer an appropriate lifetime\n }"}, {"sha": "f92ea7f18cec408436b200ace868eb041a1b0a01", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -16,11 +16,13 @@ struct an_enum<'self>(&'self int);\n struct a_class<'self> { x:&'self int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n-    return e; //~ ERROR mismatched types: expected `an_enum<'b>` but found `an_enum<'a>`\n+    return e; //~ ERROR mismatched types: expected `an_enum<'b> ` but found `an_enum<'a> `\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n-    return e; //~ ERROR mismatched types: expected `a_class<'b>` but found `a_class<'a>`\n+    return e; //~ ERROR mismatched types: expected `a_class<'b> ` but found `a_class<'a> `\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn a_fn4<'a,'b>() {"}, {"sha": "305aa68528493f52cc7706ef6ce691e7762ad576", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -15,6 +15,6 @@ fn with_int(f: &fn(x: &int)) {\n \n fn main() {\n     let mut x = None;\n-         //~^ ERROR reference is not valid outside of its lifetime\n+         //~^ ERROR lifetime of variable does not enclose its declaration\n     with_int(|y| x = Some(y));\n }"}, {"sha": "5b6dc1b2f4fb48b11db5dba500fd12b01d12ae7d", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -23,7 +23,7 @@ fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n }\n \n fn return_it() -> int {\n-    with(|o| o) //~ ERROR reference is not valid outside of its lifetime\n+    with(|o| o) //~ ERROR lifetime of function argument does not outlive the function call\n }\n \n fn main() {"}, {"sha": "488d1f3940d6e6655a1a28348f4616dc5752ed5a", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -20,7 +20,10 @@ struct not_parameterized2 {\n     g: @fn()\n }\n \n-fn take1(p: parameterized1) -> parameterized1 { p } //~ ERROR mismatched types\n+fn take1(p: parameterized1) -> parameterized1 { p }\n+//~^ ERROR mismatched types\n+//~^^ ERROR cannot infer an appropriate lifetime\n+\n fn take3(p: not_parameterized1) -> not_parameterized1 { p }\n fn take4(p: not_parameterized2) -> not_parameterized2 { p }\n "}, {"sha": "c33ca2dab2ee004ea5b6fa7fc66c4a7be5bb155a", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -22,6 +22,7 @@ fn to_same_lifetime<'r>(bi: covariant<'r>) {\n \n fn to_shorter_lifetime<'r>(bi: covariant<'r>) {\n     let bj: covariant<'blk> = bi; //~ ERROR mismatched types\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn to_longer_lifetime<'r>(bi: covariant<'r>) -> covariant<'static> {"}, {"sha": "fa853b82d9ebd05badc774ea2ec771542ff4c419", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -23,6 +23,11 @@ struct indirect2<'self> {\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n fn take_indirect1(p: indirect1) -> indirect1 { p }\n+\n fn take_indirect2(p: indirect2) -> indirect2 { p } //~ ERROR mismatched types\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n fn main() {}"}, {"sha": "0b4aa44010bdc35fa16666f1b017adc7408fdc5d", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -30,6 +30,7 @@ impl<'self> set_f<'self> for c<'self> {\n \n     fn set_f_bad(&self, b: @b) {\n         self.f = b; //~ ERROR mismatched types: expected `@@&'self int` but found `@@&int`\n+        //~^ ERROR cannot infer an appropriate lifetime\n     }\n }\n "}, {"sha": "244e9cc06a1acd54f52a3fb7a68286087f809e90", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -22,6 +22,7 @@ fn nested<'x>(x: &'x int) {\n \n     ignore::<&fn<'z>(&'z int) -> &'z int>(|z| {\n         if false { return x; }  //~ ERROR mismatched types\n+        //~^ ERROR cannot infer an appropriate lifetime\n         if false { return ay; }\n         return z;\n     });"}, {"sha": "542711687190e23c8ad5292700cca0a5dd99d9d6", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -18,6 +18,8 @@ fn with<'a, R>(f: &fn(x: &'a int) -> R) -> R {\n \n fn return_it<'a>() -> &'a int {\n     with(|o| o) //~ ERROR mismatched types\n+        //~^ ERROR lifetime of return value does not outlive the function call\n+        //~^^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "4d646aa364a40c677a4e32d9b6eef8966a6ddd22", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -21,6 +21,8 @@ fn with<R>(f: &fn(x: &int) -> R) -> R {\n \n fn return_it() -> &int {\n     with(|o| o) //~ ERROR mismatched types\n+        //~^ ERROR lifetime of return value does not outlive the function call\n+        //~^^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "2006027e79707009756eb3180cb1f79834ebb273", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::sync;\n "}, {"sha": "4108201f911592a588550117bca436e3cfde88c1", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of method receiver does not outlive the method call\n extern mod extra;\n use extra::sync;\n fn main() {"}, {"sha": "43b4d9aabb87678ad088b054dda0c85134947f3f", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::sync;\n fn main() {"}, {"sha": "15af7be5246872b72aec7d978b7dd60f156682af", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6d5e152ee30c306afccfe9ede105acc6a0a278/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=9e6d5e152ee30c306afccfe9ede105acc6a0a278", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::sync;\n fn main() {"}]}