{"sha": "c66c4533d115635dae58108f8e6fa03ef4ff511e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NmM0NTMzZDExNTYzNWRhZTU4MTA4ZjhlNmZhMDNlZjRmZjUxMWU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-09-29T02:53:35Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-09-30T19:54:53Z"}, "message": "Migrate Item \u27a1 ItemType function to method.", "tree": {"sha": "efd9a914ab75ce5b92072b936cdf644ed4f15d1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efd9a914ab75ce5b92072b936cdf644ed4f15d1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c66c4533d115635dae58108f8e6fa03ef4ff511e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c66c4533d115635dae58108f8e6fa03ef4ff511e", "html_url": "https://github.com/rust-lang/rust/commit/c66c4533d115635dae58108f8e6fa03ef4ff511e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c66c4533d115635dae58108f8e6fa03ef4ff511e/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea65ab6c7e96bf38c291ed7192137e6b96772687", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea65ab6c7e96bf38c291ed7192137e6b96772687", "html_url": "https://github.com/rust-lang/rust/commit/ea65ab6c7e96bf38c291ed7192137e6b96772687"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "da0f6bd995ae3bc7b4de3b75e538c8e8123bb7f3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c66c4533d115635dae58108f8e6fa03ef4ff511e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66c4533d115635dae58108f8e6fa03ef4ff511e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c66c4533d115635dae58108f8e6fa03ef4ff511e", "patch": "@@ -283,34 +283,34 @@ impl Item {\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        ItemType::from(self) == ItemType::Module\n+        self.type_() == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        ItemType::from(self) == ItemType::Trait\n+        self.type_() == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        ItemType::from(self) == ItemType::Struct\n+        self.type_() == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        ItemType::from(self) == ItemType::Module\n+        self.type_() == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        ItemType::from(self) == ItemType::Function\n+        self.type_() == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        ItemType::from(self) == ItemType::AssociatedType\n+        self.type_() == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        ItemType::from(self) == ItemType::AssociatedConst\n+        self.type_() == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        ItemType::from(self) == ItemType::Method\n+        self.type_() == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        ItemType::from(self) == ItemType::TyMethod\n+        self.type_() == ItemType::TyMethod\n     }\n     pub fn is_primitive(&self) -> bool {\n-        ItemType::from(self) == ItemType::Primitive\n+        self.type_() == ItemType::Primitive\n     }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n@@ -342,6 +342,11 @@ impl Item {\n     pub fn stable_since(&self) -> Option<&str> {\n         self.stability.as_ref().map(|s| &s.since[..])\n     }\n+\n+    /// Returns a documentation-level item type from the item.\n+    pub fn type_(&self) -> ItemType {\n+        ItemType::from(self)\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "9c0071816e7cf23ba5bc9ac96ba7d44ce77850a8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c66c4533d115635dae58108f8e6fa03ef4ff511e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66c4533d115635dae58108f8e6fa03ef4ff511e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c66c4533d115635dae58108f8e6fa03ef4ff511e", "patch": "@@ -591,7 +591,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_impl_items {\n         if let Some(&(ref fqp, _)) = paths.get(&did) {\n             search_index.push(IndexItem {\n-                ty: item_type(item),\n+                ty: item.type_(),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -835,11 +835,6 @@ fn mkdir(path: &Path) -> io::Result<()> {\n     }\n }\n \n-/// Returns a documentation-level item type from the item.\n-fn item_type(item: &clean::Item) -> ItemType {\n-    ItemType::from(item)\n-}\n-\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree. Each component in the cleaned path will be passed as an\n@@ -1075,7 +1070,7 @@ impl DocFolder for Cache {\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n-                            ty: item_type(&item),\n+                            ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -1122,7 +1117,7 @@ impl DocFolder for Cache {\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), item_type(&item)));\n+                                      (self.stack.clone(), item.type_()));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -1135,7 +1130,7 @@ impl DocFolder for Cache {\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n                 self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                item_type(&item)));\n+                                                item.type_()));\n             }\n \n             _ => {}\n@@ -1304,7 +1299,7 @@ impl Context {\n             title.push_str(it.name.as_ref().unwrap());\n         }\n         title.push_str(\" - Rust\");\n-        let tyname = item_type(it).css_class();\n+        let tyname = it.type_().css_class();\n         let desc = if it.is_crate() {\n             format!(\"API documentation for the Rust `{}` crate.\",\n                     self.shared.layout.krate)\n@@ -1407,7 +1402,7 @@ impl Context {\n             // buf will be empty if the item is stripped and there is no redirect for it\n             if !buf.is_empty() {\n                 let name = item.name.as_ref().unwrap();\n-                let item_type = item_type(&item);\n+                let item_type = item.type_();\n                 let file_name = &item_path(item_type, name);\n                 let joint_dst = self.dst.join(file_name);\n                 try_err!(fs::create_dir_all(&self.dst), &self.dst);\n@@ -1444,7 +1439,7 @@ impl Context {\n         for item in &m.items {\n             if maybe_ignore_item(item) { continue }\n \n-            let short = item_type(item).css_class();\n+            let short = item.type_().css_class();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -1541,7 +1536,7 @@ impl<'a> Item<'a> {\n             }\n             Some(format!(\"{path}{file}?gotosrc={goto}\",\n                          path = path,\n-                         file = item_path(item_type(self.item), external_path.last().unwrap()),\n+                         file = item_path(self.item.type_(), external_path.last().unwrap()),\n                          goto = self.item.def_id.index.as_usize()))\n         }\n     }\n@@ -1586,7 +1581,7 @@ impl<'a> fmt::Display for Item<'a> {\n             }\n         }\n         write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-               item_type(self.item), self.item.name.as_ref().unwrap())?;\n+               self.item.type_(), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n@@ -1739,8 +1734,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     }\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n-        let ty1 = item_type(i1);\n-        let ty2 = item_type(i2);\n+        let ty1 = i1.type_();\n+        let ty2 = i2.type_();\n         if ty1 != ty2 {\n             return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n         }\n@@ -1764,7 +1759,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             continue;\n         }\n \n-        let myty = Some(item_type(myitem));\n+        let myty = Some(myitem.type_());\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n             // Put `extern crate` and `use` re-exports in the same section.\n             curty = myty;\n@@ -1851,9 +1846,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n                        docs = shorter(Some(&Markdown(doc_value).to_string())),\n-                       class = item_type(myitem),\n+                       class = myitem.type_(),\n                        stab = myitem.stability_class(),\n-                       href = item_path(item_type(myitem), myitem.name.as_ref().unwrap()),\n+                       href = item_path(myitem.type_(), myitem.name.as_ref().unwrap()),\n                        title = full_path(cx, myitem))?;\n             }\n         }\n@@ -2059,7 +2054,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n-        let item_type = item_type(m);\n+        let item_type = m.type_();\n         let id = derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n         write!(w, \"<h3 id='{id}' class='method stab {stab}'>\\\n@@ -2145,7 +2140,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = item_type(it).css_class(),\n+           ty = it.type_().css_class(),\n            name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n@@ -2154,7 +2149,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     use html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n-    let ty = match item_type(it) {\n+    let ty = match it.type_() {\n         Typedef | AssociatedType => AssociatedType,\n         s@_ => s,\n     };\n@@ -2232,7 +2227,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               link: AssocItemLink)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", item_type(meth), name);\n+        let anchor = format!(\"#{}.{}\", meth.type_(), name);\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n             AssocItemLink::Anchor(None) => anchor,\n@@ -2740,7 +2735,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                      link: AssocItemLink, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n                      trait_: Option<&clean::Trait>) -> fmt::Result {\n-        let item_type = item_type(item);\n+        let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n         let render_method_item: bool = match render_mode {\n@@ -2932,7 +2927,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                    relpath: '{path}'\\\n                 }};</script>\",\n                name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-               ty = item_type(it).css_class(),\n+               ty = it.type_().css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path"}]}