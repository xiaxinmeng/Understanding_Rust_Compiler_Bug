{"sha": "a2c56de7643c3b989c703758f0fb9f426403bca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYzU2ZGU3NjQzYzNiOTg5YzcwMzc1OGYwZmI5ZjQyNjQwM2JjYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-12T21:21:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-12T21:21:06Z"}, "message": "Auto merge of #32112 - alexcrichton:fix-issues, r=aturon\n\nstd: Fix tracking issues and clean deprecated APIs\n\nThis PR fixes up a number of discrepancies found with tracking issues (some closed, some needed new ones, etc), and also cleans out all pre-1.8 deprecated APIs. The big beast here was dealing with `std::dynamic_lib`, and via many applications of a large hammer it's now out of the standard library.", "tree": {"sha": "6d93e86dd597e0b71632332a141269e6729837ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d93e86dd597e0b71632332a141269e6729837ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2c56de7643c3b989c703758f0fb9f426403bca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c56de7643c3b989c703758f0fb9f426403bca2", "html_url": "https://github.com/rust-lang/rust/commit/a2c56de7643c3b989c703758f0fb9f426403bca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2c56de7643c3b989c703758f0fb9f426403bca2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8788ffc670e981a195c771ab3c8530c72eb119d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8788ffc670e981a195c771ab3c8530c72eb119d7", "html_url": "https://github.com/rust-lang/rust/commit/8788ffc670e981a195c771ab3c8530c72eb119d7"}, {"sha": "b53764c73bd722ea22142bace6249d5950066253", "url": "https://api.github.com/repos/rust-lang/rust/commits/b53764c73bd722ea22142bace6249d5950066253", "html_url": "https://github.com/rust-lang/rust/commit/b53764c73bd722ea22142bace6249d5950066253"}], "stats": {"total": 2953, "additions": 476, "deletions": 2477}, "files": [{"sha": "74c02d00a0af1a090306e9b8681c3bd7bf555837", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -11,7 +11,6 @@\n #![crate_type = \"bin\"]\n \n #![feature(box_syntax)]\n-#![feature(dynamic_lib)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(str_char)]"}, {"sha": "f418edf66866e83f0c97d3af8fcc367484c01b33", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,25 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n-\n-use std::dynamic_lib::DynamicLibrary;\n+use std::env;\n+use std::ffi::OsString;\n use std::io::prelude::*;\n use std::path::PathBuf;\n use std::process::{ExitStatus, Command, Child, Output, Stdio};\n \n fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n-    let mut path = DynamicLibrary::search_path();\n+    let var = if cfg!(windows) {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    };\n+    let mut path = env::split_paths(&env::var_os(var).unwrap_or(OsString::new()))\n+                       .collect::<Vec<_>>();\n     if let Some(p) = aux_path {\n         path.insert(0, PathBuf::from(p))\n     }\n     path.insert(0, PathBuf::from(lib_path));\n \n     // Add the new dylib search path var\n-    let var = DynamicLibrary::envvar();\n-    let newpath = DynamicLibrary::create_path(&path);\n+    let newpath = env::join_paths(&path).unwrap();\n     cmd.env(var, newpath);\n }\n "}, {"sha": "7bdf9eaccc3239df362284f6970f35301b605282", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -525,14 +525,14 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n /// }\n /// ```\n #[rustc_paren_sugar]\n-#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n+#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"28796\")]\n pub trait FnBox<A> {\n     type Output;\n \n     fn call_box(self: Box<Self>, args: A) -> Self::Output;\n }\n \n-#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n+#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"28796\")]\n impl<A, F> FnBox<A> for F where F: FnOnce<A>\n {\n     type Output = F::Output;\n@@ -542,7 +542,7 @@ impl<A, F> FnBox<A> for F where F: FnOnce<A>\n     }\n }\n \n-#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n+#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"28796\")]\n impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n     type Output = R;\n \n@@ -551,7 +551,7 @@ impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n     }\n }\n \n-#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n+#[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"28796\")]\n impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n     type Output = R;\n "}, {"sha": "b299b786b35a8057e8703ce7bb216fa248c0551a", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 467, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -32,7 +32,6 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(heap_api)]\n-#![feature(raw)]\n #![feature(heap_api)]\n #![feature(staged_api)]\n #![feature(dropck_parametricity)]\n@@ -48,326 +47,10 @@ use std::intrinsics;\n use std::marker::{PhantomData, Send};\n use std::mem;\n use std::ptr;\n-use std::slice;\n \n use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n-struct Chunk {\n-    data: RawVec<u8>,\n-    /// Index of the first unused byte.\n-    fill: Cell<usize>,\n-    /// Indicates whether objects with destructors are stored in this chunk.\n-    is_copy: Cell<bool>,\n-}\n-\n-impl Chunk {\n-    fn new(size: usize, is_copy: bool) -> Chunk {\n-        Chunk {\n-            data: RawVec::with_capacity(size),\n-            fill: Cell::new(0),\n-            is_copy: Cell::new(is_copy),\n-        }\n-    }\n-\n-    fn capacity(&self) -> usize {\n-        self.data.cap()\n-    }\n-\n-    unsafe fn as_ptr(&self) -> *const u8 {\n-        self.data.ptr()\n-    }\n-\n-    // Walk down a chunk, running the destructors for any objects stored\n-    // in it.\n-    unsafe fn destroy(&self) {\n-        let mut idx = 0;\n-        let buf = self.as_ptr();\n-        let fill = self.fill.get();\n-\n-        while idx < fill {\n-            let tydesc_data = buf.offset(idx as isize) as *const usize;\n-            let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n-            let (size, align) = ((*tydesc).size, (*tydesc).align);\n-\n-            let after_tydesc = idx + mem::size_of::<*const TyDesc>();\n-\n-            let start = round_up(after_tydesc, align);\n-\n-            if is_done {\n-                ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n-            }\n-\n-            // Find where the next tydesc lives\n-            idx = round_up(start + size, mem::align_of::<*const TyDesc>());\n-        }\n-    }\n-}\n-\n-/// A slower reflection-based arena that can allocate objects of any type.\n-///\n-/// This arena uses `RawVec<u8>` as a backing store to allocate objects from.\n-/// For each allocated object, the arena stores a pointer to the type descriptor\n-/// followed by the object (potentially with alignment padding after each\n-/// element). When the arena is destroyed, it iterates through all of its\n-/// chunks, and uses the tydesc information to trace through the objects,\n-/// calling the destructors on them. One subtle point that needs to be\n-/// addressed is how to handle panics while running the user provided\n-/// initializer function. It is important to not run the destructor on\n-/// uninitialized objects, but how to detect them is somewhat subtle. Since\n-/// `alloc()` can be invoked recursively, it is not sufficient to simply exclude\n-/// the most recent object. To solve this without requiring extra space, we\n-/// use the low order bit of the tydesc pointer to encode whether the object\n-/// it describes has been fully initialized.\n-///\n-/// As an optimization, objects with destructors are stored in different chunks\n-/// than objects without destructors. This reduces overhead when initializing\n-/// plain-old-data (`Copy` types) and means we don't need to waste time running\n-/// their destructors.\n-#[unstable(feature = \"rustc_private\",\n-           reason = \"Private to rustc\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.6.0-dev\", reason =\n-\"The reflection-based arena is superseded by the any-arena crate\")]\n-pub struct Arena<'longer_than_self> {\n-    // The heads are separated out from the list as a unbenchmarked\n-    // microoptimization, to avoid needing to case on the list to access a head.\n-    head: RefCell<Chunk>,\n-    copy_head: RefCell<Chunk>,\n-    chunks: RefCell<Vec<Chunk>>,\n-    _marker: PhantomData<*mut &'longer_than_self ()>,\n-}\n-\n-impl<'a> Arena<'a> {\n-    /// Allocates a new Arena with 32 bytes preallocated.\n-    pub fn new() -> Arena<'a> {\n-        Arena::new_with_size(32)\n-    }\n-\n-    /// Allocates a new Arena with `initial_size` bytes preallocated.\n-    pub fn new_with_size(initial_size: usize) -> Arena<'a> {\n-        Arena {\n-            head: RefCell::new(Chunk::new(initial_size, false)),\n-            copy_head: RefCell::new(Chunk::new(initial_size, true)),\n-            chunks: RefCell::new(Vec::new()),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<'longer_than_self> Drop for Arena<'longer_than_self> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            self.head.borrow().destroy();\n-            for chunk in self.chunks.borrow().iter() {\n-                if !chunk.is_copy.get() {\n-                    chunk.destroy();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[inline]\n-fn round_up(base: usize, align: usize) -> usize {\n-    (base.checked_add(align - 1)).unwrap() & !(align - 1)\n-}\n-\n-// We encode whether the object a tydesc describes has been\n-// initialized in the arena in the low bit of the tydesc pointer. This\n-// is necessary in order to properly do cleanup if a panic occurs\n-// during an initializer.\n-#[inline]\n-fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> usize {\n-    p as usize | (is_done as usize)\n-}\n-#[inline]\n-fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n-    ((p & !1) as *const TyDesc, p & 1 == 1)\n-}\n-\n-// HACK(eddyb) TyDesc replacement using a trait object vtable.\n-// This could be replaced in the future with a custom DST layout,\n-// or `&'static (drop_glue, size, align)` created by a `const fn`.\n-// Requirements:\n-// * rvalue promotion (issue #1056)\n-// * mem::{size_of, align_of} must be const fns\n-struct TyDesc {\n-    drop_glue: fn(*const i8),\n-    size: usize,\n-    align: usize,\n-}\n-\n-trait AllTypes {\n-    fn dummy(&self) {}\n-}\n-\n-impl<T: ?Sized> AllTypes for T {}\n-\n-unsafe fn get_tydesc<T>() -> *const TyDesc {\n-    use std::raw::TraitObject;\n-\n-    let ptr = &*(heap::EMPTY as *const T);\n-\n-    // Can use any trait that is implemented for all types.\n-    let obj = mem::transmute::<&AllTypes, TraitObject>(ptr);\n-    obj.vtable as *const TyDesc\n-}\n-\n-impl<'longer_than_self> Arena<'longer_than_self> {\n-    // Grows a given chunk and returns `false`, or replaces it with a bigger\n-    // chunk and returns `true`.\n-    // This method is shared by both parts of the arena.\n-    #[cold]\n-    fn alloc_grow(&self, head: &mut Chunk, used_cap: usize, n_bytes: usize) -> bool {\n-        if head.data.reserve_in_place(used_cap, n_bytes) {\n-            // In-place reallocation succeeded.\n-            false\n-        } else {\n-            // Allocate a new chunk.\n-            let new_min_chunk_size = cmp::max(n_bytes, head.capacity());\n-            let new_chunk = Chunk::new((new_min_chunk_size + 1).next_power_of_two(), false);\n-            let old_chunk = mem::replace(head, new_chunk);\n-            if old_chunk.fill.get() != 0 {\n-                self.chunks.borrow_mut().push(old_chunk);\n-            }\n-            true\n-        }\n-    }\n-\n-    // Functions for the copyable part of the arena.\n-\n-    #[inline]\n-    fn alloc_copy_inner(&self, n_bytes: usize, align: usize) -> *const u8 {\n-        let mut copy_head = self.copy_head.borrow_mut();\n-        let fill = copy_head.fill.get();\n-        let mut start = round_up(fill, align);\n-        let mut end = start + n_bytes;\n-\n-        if end > copy_head.capacity() {\n-            if self.alloc_grow(&mut *copy_head, fill, end - fill) {\n-                // Continuing with a newly allocated chunk\n-                start = 0;\n-                end = n_bytes;\n-                copy_head.is_copy.set(true);\n-            }\n-        }\n-\n-        copy_head.fill.set(end);\n-\n-        unsafe { copy_head.as_ptr().offset(start as isize) }\n-    }\n-\n-    #[inline]\n-    fn alloc_copy<T, F>(&self, op: F) -> &mut T\n-        where F: FnOnce() -> T\n-    {\n-        unsafe {\n-            let ptr = self.alloc_copy_inner(mem::size_of::<T>(), mem::align_of::<T>());\n-            let ptr = ptr as *mut T;\n-            ptr::write(&mut (*ptr), op());\n-            &mut *ptr\n-        }\n-    }\n-\n-    // Functions for the non-copyable part of the arena.\n-\n-    #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n-        let mut head = self.head.borrow_mut();\n-        let fill = head.fill.get();\n-\n-        let mut tydesc_start = fill;\n-        let after_tydesc = fill + mem::size_of::<*const TyDesc>();\n-        let mut start = round_up(after_tydesc, align);\n-        let mut end = round_up(start + n_bytes, mem::align_of::<*const TyDesc>());\n-\n-        if end > head.capacity() {\n-            if self.alloc_grow(&mut *head, tydesc_start, end - tydesc_start) {\n-                // Continuing with a newly allocated chunk\n-                tydesc_start = 0;\n-                start = round_up(mem::size_of::<*const TyDesc>(), align);\n-                end = round_up(start + n_bytes, mem::align_of::<*const TyDesc>());\n-            }\n-        }\n-\n-        head.fill.set(end);\n-\n-        unsafe {\n-            let buf = head.as_ptr();\n-            (buf.offset(tydesc_start as isize),\n-             buf.offset(start as isize))\n-        }\n-    }\n-\n-    #[inline]\n-    fn alloc_noncopy<T, F>(&self, op: F) -> &mut T\n-        where F: FnOnce() -> T\n-    {\n-        unsafe {\n-            let tydesc = get_tydesc::<T>();\n-            let (ty_ptr, ptr) = self.alloc_noncopy_inner(mem::size_of::<T>(), mem::align_of::<T>());\n-            let ty_ptr = ty_ptr as *mut usize;\n-            let ptr = ptr as *mut T;\n-            // Write in our tydesc along with a bit indicating that it\n-            // has *not* been initialized yet.\n-            *ty_ptr = bitpack_tydesc_ptr(tydesc, false);\n-            // Actually initialize it\n-            ptr::write(&mut (*ptr), op());\n-            // Now that we are done, update the tydesc to indicate that\n-            // the object is there.\n-            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n-\n-            &mut *ptr\n-        }\n-    }\n-\n-    /// Allocates a new item in the arena, using `op` to initialize the value,\n-    /// and returns a reference to it.\n-    #[inline]\n-    pub fn alloc<T: 'longer_than_self, F>(&self, op: F) -> &mut T\n-        where F: FnOnce() -> T\n-    {\n-        unsafe {\n-            if intrinsics::needs_drop::<T>() {\n-                self.alloc_noncopy(op)\n-            } else {\n-                self.alloc_copy(op)\n-            }\n-        }\n-    }\n-\n-    /// Allocates a slice of bytes of requested length. The bytes are not guaranteed to be zero\n-    /// if the arena has previously been cleared.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the requested length is too large and causes overflow.\n-    pub fn alloc_bytes(&self, len: usize) -> &mut [u8] {\n-        unsafe {\n-            // Check for overflow.\n-            self.copy_head.borrow().fill.get().checked_add(len).expect(\"length overflow\");\n-            let ptr = self.alloc_copy_inner(len, 1);\n-            intrinsics::assume(!ptr.is_null());\n-            slice::from_raw_parts_mut(ptr as *mut _, len)\n-        }\n-    }\n-\n-    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n-    pub fn clear(&mut self) {\n-        unsafe {\n-            self.head.borrow().destroy();\n-            self.head.borrow().fill.set(0);\n-            self.copy_head.borrow().fill.set(0);\n-            for chunk in self.chunks.borrow().iter() {\n-                if !chunk.is_copy.get() {\n-                    chunk.destroy();\n-                }\n-            }\n-            self.chunks.borrow_mut().clear();\n-        }\n-    }\n-}\n-\n /// A faster arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n@@ -566,9 +249,8 @@ unsafe impl<T: Send> Send for TypedArena<T> {}\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n-    use super::{Arena, TypedArena};\n+    use super::TypedArena;\n     use std::cell::Cell;\n-    use std::rc::Rc;\n \n     #[allow(dead_code)]\n     #[derive(Debug, Eq, PartialEq)]\n@@ -642,12 +324,6 @@ mod tests {\n         })\n     }\n \n-    #[bench]\n-    pub fn bench_copy_old_arena(b: &mut Bencher) {\n-        let arena = Arena::new();\n-        b.iter(|| arena.alloc(|| Point { x: 1, y: 2, z: 3 }))\n-    }\n-\n     #[allow(dead_code)]\n     struct Noncopy {\n         string: String,\n@@ -673,22 +349,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    pub fn test_arena_zero_sized() {\n-        let arena = Arena::new();\n-        let mut points = vec![];\n-        for _ in 0..1000 {\n-            for _ in 0..100 {\n-                arena.alloc(|| ());\n-            }\n-            let point = arena.alloc(|| Point { x: 1, y: 2, z: 3 });\n-            points.push(point);\n-        }\n-        for point in &points {\n-            assert_eq!(**point, Point { x: 1, y: 2, z: 3 });\n-        }\n-    }\n-\n     #[test]\n     pub fn test_typed_arena_clear() {\n         let mut arena = TypedArena::new();\n@@ -700,66 +360,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    pub fn test_arena_clear() {\n-        let mut arena = Arena::new();\n-        for _ in 0..10 {\n-            arena.clear();\n-            for _ in 0..10000 {\n-                arena.alloc(|| Point { x: 1, y: 2, z: 3 });\n-                arena.alloc(|| {\n-                    Noncopy {\n-                        string: \"hello world\".to_string(),\n-                        array: vec![],\n-                    }\n-                });\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_arena_alloc_bytes() {\n-        let arena = Arena::new();\n-        for i in 0..10000 {\n-            arena.alloc(|| Point { x: 1, y: 2, z: 3 });\n-            for byte in arena.alloc_bytes(i % 42).iter_mut() {\n-                *byte = i as u8;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_arena_destructors() {\n-        let arena = Arena::new();\n-        for i in 0..10 {\n-            // Arena allocate something with drop glue to make sure it\n-            // doesn't leak.\n-            arena.alloc(|| Rc::new(i));\n-            // Allocate something with funny size and alignment, to keep\n-            // things interesting.\n-            arena.alloc(|| [0u8, 1u8, 2u8]);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_arena_destructors_fail() {\n-        let arena = Arena::new();\n-        // Put some stuff in the arena.\n-        for i in 0..10 {\n-            // Arena allocate something with drop glue to make sure it\n-            // doesn't leak.\n-            arena.alloc(|| Rc::new(i));\n-            // Allocate something with funny size and alignment, to keep\n-            // things interesting.\n-            arena.alloc(|| [0u8, 1, 2]);\n-        }\n-        // Now, panic while allocating\n-        arena.alloc::<Rc<i32>, _>(|| {\n-            panic!();\n-        });\n-    }\n-\n     // Drop tests\n \n     struct DropCounter<'a> {\n@@ -772,40 +372,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_arena_drop_count() {\n-        let counter = Cell::new(0);\n-        {\n-            let arena = Arena::new();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(|| DropCounter { count: &counter });\n-                // Allocate something with funny size and alignment, to keep\n-                // things interesting.\n-                arena.alloc(|| [0u8, 1u8, 2u8]);\n-            }\n-            // dropping\n-        };\n-        assert_eq!(counter.get(), 100);\n-    }\n-\n-    #[test]\n-    fn test_arena_drop_on_clear() {\n-        let counter = Cell::new(0);\n-        for i in 0..10 {\n-            let mut arena = Arena::new();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(|| DropCounter { count: &counter });\n-                // Allocate something with funny size and alignment, to keep\n-                // things interesting.\n-                arena.alloc(|| [0u8, 1u8, 2u8]);\n-            }\n-            arena.clear();\n-            assert_eq!(counter.get(), i * 100 + 100);\n-        }\n-    }\n-\n     #[test]\n     fn test_typed_arena_drop_count() {\n         let counter = Cell::new(0);\n@@ -845,25 +411,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_arena_drop_small_count() {\n-        DROP_COUNTER.with(|c| c.set(0));\n-        {\n-            let arena = Arena::new();\n-            for _ in 0..10 {\n-                for _ in 0..10 {\n-                    // Allocate something with drop glue to make sure it doesn't leak.\n-                    arena.alloc(|| SmallDroppable);\n-                }\n-                // Allocate something with funny size and alignment, to keep\n-                // things interesting.\n-                arena.alloc(|| [0u8, 1u8, 2u8]);\n-            }\n-            // dropping\n-        };\n-        assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n-    }\n-\n     #[test]\n     fn test_typed_arena_drop_small_count() {\n         DROP_COUNTER.with(|c| c.set(0));\n@@ -898,17 +445,4 @@ mod tests {\n             });\n         })\n     }\n-\n-    #[bench]\n-    pub fn bench_noncopy_old_arena(b: &mut Bencher) {\n-        let arena = Arena::new();\n-        b.iter(|| {\n-            arena.alloc(|| {\n-                Noncopy {\n-                    string: \"hello world\".to_string(),\n-                    array: vec![1, 2, 3, 4, 5],\n-                }\n-            })\n-        })\n-    }\n }"}, {"sha": "0e92676cf971b30cc787be60f515386a4ef04e0e", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -244,24 +244,6 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned {\n     }\n }\n \n-/// Trait for moving into a `Cow`.\n-#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n-           issue = \"27735\")]\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"conflicts with Into, may return with specialization\")]\n-pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n-    /// Moves `self` into `Cow`\n-    fn into_cow(self) -> Cow<'a, B>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n-    fn into_cow(self) -> Cow<'a, B> {\n-        self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {"}, {"sha": "0c66c0564c3ea2ca879d6eaefee4442ca641f830", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -81,13 +81,13 @@ pub trait CLike {\n     fn from_usize(usize) -> Self;\n }\n \n-#[allow(deprecated)]\n fn bit<E: CLike>(e: &E) -> usize {\n-    use core::usize;\n+    use core::mem;\n     let value = e.to_usize();\n-    assert!(value < usize::BITS,\n+    let bits = mem::size_of::<usize>() * 8;\n+    assert!(value < bits,\n             \"EnumSet only supports up to {} variants.\",\n-            usize::BITS - 1);\n+            bits - 1);\n     1 << value\n }\n "}, {"sha": "e30e0b213afa161eb3da80c251349bd90af865f7", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -491,10 +491,6 @@ pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{ArgumentV1, Arguments, write};\n-#[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-#[allow(deprecated)]\n-pub use core::fmt::{radix, Radix, RadixFmt};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n "}, {"sha": "a6be81c91bbf1b45d85ae917a83fcb8eb83440ff", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -38,18 +38,15 @@\n #![feature(decode_utf16)]\n #![feature(dropck_parametricity)]\n #![feature(fmt_internals)]\n-#![feature(fmt_radix)]\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n #![feature(iter_arith)]\n #![feature(lang_items)]\n #![feature(nonzero)]\n-#![feature(num_bits_bytes)]\n #![feature(pattern)]\n #![feature(placement_in)]\n #![feature(placement_new_protocol)]\n #![feature(shared)]\n-#![feature(slice_bytes)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(step_by)]"}, {"sha": "6a7944bc9a27602e1126ec5489fb007f6e672281", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -1232,7 +1232,7 @@ mod tests {\n         m.append(&mut n);\n         check_links(&m);\n         let mut sum = v;\n-        sum.push_all(&u);\n+        sum.extend_from_slice(&u);\n         assert_eq!(sum.len(), m.len());\n         for elt in sum {\n             assert_eq!(m.pop_front(), Some(elt))"}, {"sha": "8fa594c967cf7c0c54715706c0fdc09a57270cb2", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -104,9 +104,6 @@ pub use core::slice::{Iter, IterMut};\n pub use core::slice::{SplitMut, ChunksMut, Split};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n-#[unstable(feature = \"slice_bytes\", issue = \"27740\")]\n-#[allow(deprecated)]\n-pub use core::slice::bytes;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n "}, {"sha": "beb12ff58afdb8dc677dd034a9210d2f637995e1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -66,8 +66,7 @@ use core::str::pattern::Pattern;\n use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use rustc_unicode::str as unicode_str;\n \n-#[allow(deprecated)]\n-use borrow::{Cow, IntoCow};\n+use borrow::Cow;\n use range::RangeArgument;\n use str::{self, FromStr, Utf8Error, Chars};\n use vec::Vec;\n@@ -1838,26 +1837,6 @@ impl Into<Vec<u8>> for String {\n     }\n }\n \n-#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n-           issue= \"27735\")]\n-#[allow(deprecated)]\n-impl IntoCow<'static, str> for String {\n-    #[inline]\n-    fn into_cow(self) -> Cow<'static, str> {\n-        Cow::Owned(self)\n-    }\n-}\n-\n-#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n-           issue = \"27735\")]\n-#[allow(deprecated)]\n-impl<'a> IntoCow<'a, str> for &'a str {\n-    #[inline]\n-    fn into_cow(self) -> Cow<'a, str> {\n-        Cow::Borrowed(self)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "4f4eae67e37cd5fa01021c85d40c912676645fcf", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -63,6 +63,7 @@ use alloc::boxed::Box;\n use alloc::heap::EMPTY;\n use alloc::raw_vec::RawVec;\n use borrow::ToOwned;\n+use borrow::Cow;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n@@ -74,9 +75,6 @@ use core::ops;\n use core::ptr;\n use core::slice;\n \n-#[allow(deprecated)]\n-use borrow::{Cow, IntoCow};\n-\n use super::range::RangeArgument;\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector.'\n@@ -967,17 +965,6 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    #[allow(missing_docs)]\n-    #[inline]\n-    #[unstable(feature = \"vec_push_all\",\n-               reason = \"likely to be replaced by a more optimized extend\",\n-               issue = \"27744\")]\n-    #[rustc_deprecated(reason = \"renamed to extend_from_slice\",\n-                       since = \"1.6.0\")]\n-    pub fn push_all(&mut self, other: &[T]) {\n-        self.extend_from_slice(other)\n-    }\n-\n     /// Appends all elements in a slice to the `Vec`.\n     ///\n     /// Iterates over the slice `other`, clones each element, and then appends\n@@ -1598,22 +1585,6 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a, T: 'a> IntoCow<'a, [T]> for Vec<T> where T: Clone {\n-    fn into_cow(self) -> Cow<'a, [T]> {\n-        Cow::Owned(self)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n-    fn into_cow(self) -> Cow<'a, [T]> {\n-        Cow::Borrowed(self)\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Iterators\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "3596b8306a8b1822afd0fd3c0c88083f7e210166", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -24,7 +24,6 @@\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(set_recovery)]\n-#![feature(slice_bytes)]\n #![feature(step_by)]\n #![feature(str_char)]\n #![feature(str_escape)]"}, {"sha": "56741f0e5951e4d1d7e197dd3879e9319b4ce251", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -865,18 +865,6 @@ fn test_vec_default() {\n     t!(Vec<i32>);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_bytes_set_memory() {\n-    use std::slice::bytes::MutableByteVector;\n-\n-    let mut values = [1,2,3,4,5];\n-    values[0..5].set_memory(0xAB);\n-    assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-    values[2..4].set_memory(0xFF);\n-    assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n-}\n-\n #[test]\n #[should_panic]\n fn test_overflow_does_not_cause_segfault() {"}, {"sha": "abae121ea7f53e21836b29de8cb6b533d1917186", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -255,7 +255,7 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n #[doc(hidden)]\n #[unstable(feature = \"core_char_ext\",\n            reason = \"the stable interface is `impl char` in later crate\",\n-           issue = \"27701\")]\n+           issue = \"32110\")]\n pub trait CharExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_digit(self, radix: u32) -> bool;"}, {"sha": "b562e658b62db8c1c619cfe55d76d87619550e4d", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -124,15 +124,17 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n pub struct DebugTuple<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n     result: fmt::Result,\n-    has_fields: bool,\n+    fields: usize,\n+    empty_name: bool,\n }\n \n pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugTuple {\n         fmt: fmt,\n         result: result,\n-        has_fields: false,\n+        fields: 0,\n+        empty_name: name.is_empty(),\n     }\n }\n \n@@ -141,7 +143,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn field(&mut self, value: &fmt::Debug) -> &mut DebugTuple<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n-            let (prefix, space) = if self.has_fields {\n+            let (prefix, space) = if self.fields > 0 {\n                 (\",\", \" \")\n             } else {\n                 (\"(\", \"\")\n@@ -155,20 +157,22 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n             }\n         });\n \n-        self.has_fields = true;\n+        self.fields += 1;\n         self\n     }\n \n     /// Finishes output and returns any error encountered.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n-        if self.has_fields {\n+        if self.fields > 0 {\n             self.result = self.result.and_then(|_| {\n                 if self.is_pretty() {\n-                    self.fmt.write_str(\"\\n)\")\n-                } else {\n-                    self.fmt.write_str(\")\")\n+                    try!(self.fmt.write_str(\"\\n\"));\n+                }\n+                if self.fields == 1 && self.empty_name {\n+                    try!(self.fmt.write_str(\",\"));\n                 }\n+                self.fmt.write_str(\")\")\n             });\n         }\n         self.result\n@@ -177,14 +181,6 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     fn is_pretty(&self) -> bool {\n         self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n     }\n-\n-    /// Returns the wrapped `Formatter`.\n-    #[unstable(feature = \"debug_builder_formatter\", reason = \"recently added\",\n-               issue = \"27782\")]\n-    #[rustc_deprecated(since = \"1.7.0\", reason = \"will be removed\")]\n-    pub fn formatter(&mut self) -> &mut fmt::Formatter<'b> {\n-        &mut self.fmt\n-    }\n }\n \n struct DebugInner<'a, 'b: 'a> {"}, {"sha": "7f7bfe73c51e4f363785050df10af67ee843584a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -36,18 +36,6 @@ pub enum Alignment {\n     Unknown,\n }\n \n-#[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-#[allow(deprecated)]\n-pub use self::num::radix;\n-#[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-#[allow(deprecated)]\n-pub use self::num::Radix;\n-#[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-#[allow(deprecated)]\n-pub use self::num::RadixFmt;\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n \n@@ -1561,16 +1549,10 @@ macro_rules! tuple {\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 let mut builder = f.debug_tuple(\"\");\n                 let ($(ref $name,)*) = *self;\n-                let mut n = 0;\n                 $(\n                     builder.field($name);\n-                    n += 1;\n                 )*\n \n-                if n == 1 {\n-                    try!(write!(builder.formatter(), \",\"));\n-                }\n-\n                 builder.finish()\n             }\n         }"}, {"sha": "a944c996c1a1e7532e0aeebde83bbbfc05c182e8", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -140,81 +140,6 @@ radix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n                              x @ 10 ... 15 => b'A' + (x - 10) }\n \n-/// A radix with in the range of `2..36`.\n-#[derive(Clone, Copy, PartialEq)]\n-#[unstable(feature = \"fmt_radix\",\n-           reason = \"may be renamed or move to a different module\",\n-           issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-pub struct Radix {\n-    base: u8,\n-}\n-\n-impl Radix {\n-    fn new(base: u8) -> Radix {\n-        assert!(2 <= base && base <= 36,\n-                \"the base must be in the range of 2..36: {}\",\n-                base);\n-        Radix { base: base }\n-    }\n-}\n-\n-impl GenericRadix for Radix {\n-    fn base(&self) -> u8 {\n-        self.base\n-    }\n-    fn digit(&self, x: u8) -> u8 {\n-        match x {\n-            x @  0 ... 9 => b'0' + x,\n-            x if x < self.base() => b'a' + (x - 10),\n-            x => panic!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n-        }\n-    }\n-}\n-\n-/// A helper type for formatting radixes.\n-#[unstable(feature = \"fmt_radix\",\n-           reason = \"may be renamed or move to a different module\",\n-           issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-#[derive(Copy, Clone)]\n-pub struct RadixFmt<T, R>(T, R);\n-\n-/// Constructs a radix formatter in the range of `2..36`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(fmt_radix)]\n-///\n-/// use std::fmt::radix;\n-/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n-/// ```\n-#[unstable(feature = \"fmt_radix\",\n-           reason = \"may be renamed or move to a different module\",\n-           issue = \"27728\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n-pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n-    RadixFmt(x, Radix::new(base))\n-}\n-\n-macro_rules! radix_fmt {\n-    ($T:ty as $U:ty, $fmt:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl fmt::Debug for RadixFmt<$T, Radix> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::Display::fmt(self, f)\n-            }\n-        }\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl fmt::Display for RadixFmt<$T, Radix> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n-            }\n-        }\n-    }\n-}\n-\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -243,14 +168,12 @@ macro_rules! integer {\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n-        radix_fmt! { $Int as $Int, fmt_int }\n         debug! { $Int }\n \n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n         int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n-        radix_fmt! { $Uint as $Uint, fmt_int }\n         debug! { $Uint }\n     }\n }"}, {"sha": "3c219692bc48de8b5981937d283f41198a93b169", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -238,30 +238,6 @@ impl<H> Default for BuildHasherDefault<H> {\n     }\n }\n \n-// The HashState trait is super deprecated, but it's here to have the blanket\n-// impl that goes from HashState -> BuildHasher\n-\n-/// Deprecated, renamed to `BuildHasher`\n-#[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-           issue = \"27713\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"support moved to std::hash and \\\n-                                              renamed to BuildHasher\")]\n-pub trait HashState {\n-    /// Type of the hasher that will be created.\n-    type Hasher: Hasher;\n-\n-    /// Creates a new hasher based on the given state of this object.\n-    fn hasher(&self) -> Self::Hasher;\n-}\n-\n-#[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-           issue = \"27713\")]\n-#[allow(deprecated)]\n-impl<T: HashState> BuildHasher for T {\n-    type Hasher = T::Hasher;\n-    fn build_hasher(&self) -> T::Hasher { self.hasher() }\n-}\n-\n //////////////////////////////////////////////////////////////////////////////\n \n mod impls {"}, {"sha": "def44e1a9ceba56c1e13c37b8a5324a32675ce07", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -1922,19 +1922,6 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n-    #[allow(missing_docs)]\n-    #[inline]\n-    #[unstable(feature = \"iter_cmp\",\n-               reason = \"may want to produce an Ordering directly; see #15311\",\n-               issue = \"27724\")]\n-    #[rustc_deprecated(reason = \"renamed to max_by_key\", since = \"1.6.0\")]\n-    fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n-        Self: Sized,\n-        F: FnMut(&Self::Item) -> B,\n-    {\n-        self.max_by_key(f)\n-    }\n-\n     /// Returns the element that gives the maximum value from the\n     /// specified function.\n     ///\n@@ -1960,19 +1947,6 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n-    #[inline]\n-    #[allow(missing_docs)]\n-    #[unstable(feature = \"iter_cmp\",\n-               reason = \"may want to produce an Ordering directly; see #15311\",\n-               issue = \"27724\")]\n-    #[rustc_deprecated(reason = \"renamed to min_by_key\", since = \"1.6.0\")]\n-    fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n-        Self: Sized,\n-        F: FnMut(&Self::Item) -> B,\n-    {\n-        self.min_by_key(f)\n-    }\n-\n     /// Returns the element that gives the minimum value from the\n     /// specified function.\n     ///\n@@ -3679,7 +3653,7 @@ impl<I: Iterator> Peekable<I> {\n     ///\n     /// assert_eq!(iter.is_empty(), true);\n     /// ```\n-    #[unstable(feature = \"peekable_is_empty\", issue = \"27701\")]\n+    #[unstable(feature = \"peekable_is_empty\", issue = \"32111\")]\n     #[inline]\n     pub fn is_empty(&mut self) -> bool {\n         self.peek().is_none()"}, {"sha": "c24eaa3eabc754956e1ef4027328b813632b941e", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -141,7 +141,7 @@ pub mod consts {\n \n #[unstable(feature = \"core_float\",\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n-           issue = \"27702\")]\n+           issue = \"32110\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "beeee80902525f16c0684bda05e2debc1832d99f", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -141,7 +141,7 @@ pub mod consts {\n \n #[unstable(feature = \"core_float\",\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n-           issue = \"27702\")]\n+           issue = \"32110\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "42349257ab71c23415eb2edcfb49bbc13c9d6aca", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -12,25 +12,6 @@\n \n macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `mem::size_of` function.\n-#[unstable(feature = \"num_bits_bytes\",\n-           reason = \"may want to be an associated function\",\n-           issue = \"27753\")]\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"will be replaced via const fn or associated constants\")]\n-#[allow(missing_docs)]\n-pub const BITS : usize = $bits;\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `mem::size_of` function.\n-#[unstable(feature = \"num_bits_bytes\",\n-           reason = \"may want to be an associated function\",\n-           issue = \"27753\")]\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"will be replaced via const fn or associated constants\")]\n-#[allow(missing_docs)]\n-pub const BYTES : usize = ($bits / 8);\n-\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5a2a043d6f1b8ce7ae0a38054e6d1267d0825ac7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -41,7 +41,7 @@ use slice::SliceExt;\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Default)]\n pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n-pub mod wrapping;\n+mod wrapping;\n \n // All these modules are technically private and only exposed for libcoretest:\n pub mod flt2dec;\n@@ -2209,7 +2209,7 @@ pub enum FpCategory {\n #[doc(hidden)]\n #[unstable(feature = \"core_float\",\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n-           issue = \"27702\")]\n+           issue = \"32110\")]\n pub trait Float: Sized {\n     /// Returns the NaN value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\","}, {"sha": "6479836cbe1179361a8c468d100fde73ed91c2d5", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -12,21 +12,6 @@\n \n macro_rules! uint_module { ($T:ty, $bits:expr) => (\n \n-#[unstable(feature = \"num_bits_bytes\",\n-           reason = \"may want to be an associated function\",\n-           issue = \"27753\")]\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"will be replaced via const fn or associated constants\")]\n-#[allow(missing_docs)]\n-pub const BITS : usize = $bits;\n-#[unstable(feature = \"num_bits_bytes\",\n-           reason = \"may want to be an associated function\",\n-           issue = \"27753\")]\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"will be replaced via const fn or associated constants\")]\n-#[allow(missing_docs)]\n-pub const BYTES : usize = ($bits / 8);\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_docs)]\n pub const MIN: $T = 0 as $T;"}, {"sha": "e28a36af2f32202cca3b8a9e9c34bbe95611f651", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 5, "deletions": 146, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,34 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_docs)]\n-#![unstable(feature = \"old_wrapping\", reason = \"may be removed or relocated\",\n-            issue = \"27755\")]\n-\n-use intrinsics::{add_with_overflow, sub_with_overflow, mul_with_overflow};\n-\n use super::Wrapping;\n \n use ops::*;\n \n-use ::{i8, i16, i32, i64, isize};\n-\n-#[unstable(feature = \"old_wrapping\", reason = \"may be removed or relocated\",\n-           issue = \"27755\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to inherent methods\")]\n-pub trait OverflowingOps {\n-    fn overflowing_add(self, rhs: Self) -> (Self, bool);\n-    fn overflowing_sub(self, rhs: Self) -> (Self, bool);\n-    fn overflowing_mul(self, rhs: Self) -> (Self, bool);\n-\n-    fn overflowing_div(self, rhs: Self) -> (Self, bool);\n-    fn overflowing_rem(self, rhs: Self) -> (Self, bool);\n-    fn overflowing_neg(self) -> (Self, bool);\n-\n-    fn overflowing_shl(self, rhs: u32) -> (Self, bool);\n-    fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n-}\n-\n macro_rules! sh_impl_signed {\n     ($t:ident, $f:ident) => (\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -52,7 +28,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n \n-        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shl_assign(&mut self, other: $f) {\n@@ -74,7 +50,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n \n-        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shr_assign(&mut self, other: $f) {\n@@ -96,7 +72,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n \n-        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shl_assign(&mut self, other: $f) {\n@@ -114,7 +90,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n \n-        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shr_assign(&mut self, other: $f) {\n@@ -218,7 +194,7 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n-        #[unstable(feature = \"wrapping_impls\", reason = \"recently added\", issue = \"30524\")]\n+        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl Rem for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n@@ -331,120 +307,3 @@ mod shift_max {\n     pub const u64: u32 = i64;\n     pub use self::platform::usize;\n }\n-\n-macro_rules! signed_overflowing_impl {\n-    ($($t:ident)*) => ($(\n-        #[allow(deprecated)]\n-        impl OverflowingOps for $t {\n-            #[inline(always)]\n-            fn overflowing_add(self, rhs: $t) -> ($t, bool) {\n-                unsafe {\n-                    add_with_overflow(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn overflowing_sub(self, rhs: $t) -> ($t, bool) {\n-                unsafe {\n-                    sub_with_overflow(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn overflowing_mul(self, rhs: $t) -> ($t, bool) {\n-                unsafe {\n-                    mul_with_overflow(self, rhs)\n-                }\n-            }\n-\n-            #[inline(always)]\n-            fn overflowing_div(self, rhs: $t) -> ($t, bool) {\n-                if self == $t::MIN && rhs == -1 {\n-                    (self, true)\n-                } else {\n-                    (self/rhs, false)\n-                }\n-            }\n-            #[inline(always)]\n-            fn overflowing_rem(self, rhs: $t) -> ($t, bool) {\n-                if self == $t::MIN && rhs == -1 {\n-                    (0, true)\n-                } else {\n-                    (self % rhs, false)\n-                }\n-            }\n-\n-            #[inline(always)]\n-            fn overflowing_shl(self, rhs: u32) -> ($t, bool) {\n-                (self << (rhs & self::shift_max::$t),\n-                 (rhs > self::shift_max::$t))\n-            }\n-            #[inline(always)]\n-            fn overflowing_shr(self, rhs: u32) -> ($t, bool) {\n-                (self >> (rhs & self::shift_max::$t),\n-                 (rhs > self::shift_max::$t))\n-            }\n-\n-            #[inline(always)]\n-            fn overflowing_neg(self) -> ($t, bool) {\n-                if self == $t::MIN {\n-                    ($t::MIN, true)\n-                } else {\n-                    (-self, false)\n-                }\n-            }\n-        }\n-    )*)\n-}\n-\n-macro_rules! unsigned_overflowing_impl {\n-    ($($t:ident)*) => ($(\n-        #[allow(deprecated)]\n-        impl OverflowingOps for $t {\n-            #[inline(always)]\n-            fn overflowing_add(self, rhs: $t) -> ($t, bool) {\n-                unsafe {\n-                    add_with_overflow(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn overflowing_sub(self, rhs: $t) -> ($t, bool) {\n-                unsafe {\n-                    sub_with_overflow(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn overflowing_mul(self, rhs: $t) -> ($t, bool) {\n-                unsafe {\n-                    mul_with_overflow(self, rhs)\n-                }\n-            }\n-\n-            #[inline(always)]\n-            fn overflowing_div(self, rhs: $t) -> ($t, bool) {\n-                (self/rhs, false)\n-            }\n-            #[inline(always)]\n-            fn overflowing_rem(self, rhs: $t) -> ($t, bool) {\n-                (self % rhs, false)\n-            }\n-\n-            #[inline(always)]\n-            fn overflowing_shl(self, rhs: u32) -> ($t, bool) {\n-                (self << (rhs & self::shift_max::$t),\n-                 (rhs > self::shift_max::$t))\n-            }\n-            #[inline(always)]\n-            fn overflowing_shr(self, rhs: u32) -> ($t, bool) {\n-                (self >> (rhs & self::shift_max::$t),\n-                 (rhs > self::shift_max::$t))\n-            }\n-\n-            #[inline(always)]\n-            fn overflowing_neg(self) -> ($t, bool) {\n-                ((!self).wrapping_add(1), true)\n-            }\n-        }\n-    )*)\n-}\n-\n-signed_overflowing_impl! { i8 i16 i32 i64 isize }\n-unsigned_overflowing_impl! { u8 u16 u32 u64 usize }"}, {"sha": "6e0e972fa0c83b49235d9865343d3e1024d06171", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -61,7 +61,7 @@ use raw::Slice as RawSlice;\n /// Extension methods for slices.\n #[unstable(feature = \"core_slice_ext\",\n            reason = \"stable interface provided by `impl [T]` in later crates\",\n-           issue = \"27701\")]\n+           issue = \"32110\")]\n #[allow(missing_docs)] // documented elsewhere\n pub trait SliceExt {\n     type Item;\n@@ -182,7 +182,7 @@ macro_rules! slice_ref {\n \n #[unstable(feature = \"core_slice_ext\",\n            reason = \"stable interface provided by `impl [T]` in later crates\",\n-           issue = \"27701\")]\n+           issue = \"32110\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -1552,52 +1552,6 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     mem::transmute(RawSlice { data: p, len: len })\n }\n \n-//\n-// Submodules\n-//\n-\n-/// Operations on `[u8]`.\n-#[unstable(feature = \"slice_bytes\", reason = \"needs review\",\n-           issue = \"27740\")]\n-#[rustc_deprecated(reason = \"unidiomatic functions not pulling their weight\",\n-                   since = \"1.6.0\")]\n-#[allow(deprecated)]\n-pub mod bytes {\n-    use ptr;\n-    use slice::SliceExt;\n-\n-    /// A trait for operations on mutable `[u8]`s.\n-    pub trait MutableByteVector {\n-        /// Sets all bytes of the receiver to the given value.\n-        fn set_memory(&mut self, value: u8);\n-    }\n-\n-    impl MutableByteVector for [u8] {\n-        #[inline]\n-        fn set_memory(&mut self, value: u8) {\n-            unsafe { ptr::write_bytes(self.as_mut_ptr(), value, self.len()) };\n-        }\n-    }\n-\n-    /// Copies data from `src` to `dst`\n-    ///\n-    /// Panics if the length of `dst` is less than the length of `src`.\n-    #[inline]\n-    pub fn copy_memory(src: &[u8], dst: &mut [u8]) {\n-        let len_src = src.len();\n-        assert!(dst.len() >= len_src);\n-        // `dst` is unaliasable, so we know statically it doesn't overlap\n-        // with `src`.\n-        unsafe {\n-            ptr::copy_nonoverlapping(src.as_ptr(),\n-                                     dst.as_mut_ptr(),\n-                                     len_src);\n-        }\n-    }\n-}\n-\n-\n-\n //\n // Boilerplate traits\n //"}, {"sha": "f9d1902bea7a7cfe43030c3d940061fdffe88c2a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -1561,7 +1561,7 @@ mod traits {\n #[doc(hidden)]\n #[unstable(feature = \"core_str_ext\",\n            reason = \"stable interface provided by `impl str` in later crates\",\n-           issue = \"27701\")]\n+           issue = \"32110\")]\n pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here."}, {"sha": "4ddedd9100486ea8640a712a390310f89b7305a2", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -150,107 +150,3 @@ fn test_format_int_twos_complement() {\n     assert!(format!(\"{}\", i32::MIN) == \"-2147483648\");\n     assert!(format!(\"{}\", i64::MIN) == \"-9223372036854775808\");\n }\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_format_radix() {\n-    use core::fmt::radix;\n-    assert!(format!(\"{:04}\", radix(3, 2)) == \"0011\");\n-    assert!(format!(\"{}\", radix(55, 36)) == \"1j\");\n-}\n-\n-#[test]\n-#[should_panic]\n-#[allow(deprecated)]\n-fn test_radix_base_too_large() {\n-    use core::fmt::radix;\n-    let _ = radix(55, 37);\n-}\n-\n-#[allow(deprecated)]\n-mod u32 {\n-    use test::Bencher;\n-    use core::fmt::radix;\n-    use std::__rand::{thread_rng, Rng};\n-    use std::io::{Write, sink};\n-\n-    #[bench]\n-    fn format_bin(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<u32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_oct(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<u32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_dec(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<u32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_hex(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<u32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_show(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<u32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_base_36(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<u32>(), 36)) })\n-    }\n-}\n-\n-#[allow(deprecated)]\n-mod i32 {\n-    use test::Bencher;\n-    use core::fmt::radix;\n-    use std::__rand::{thread_rng, Rng};\n-    use std::io::{Write, sink};\n-\n-    #[bench]\n-    fn format_bin(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<i32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_oct(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<i32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_dec(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<i32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_hex(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<i32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_show(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<i32>()) })\n-    }\n-\n-    #[bench]\n-    fn format_base_36(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<i32>(), 36)) })\n-    }\n-}"}, {"sha": "506f9e9b7a5764ddac10ec74bce14c94d220aa93", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -24,8 +24,6 @@\n #![feature(fixed_size_array)]\n #![feature(float_extras)]\n #![feature(flt2dec)]\n-#![feature(fmt_radix)]\n-#![feature(iter_arith)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]"}, {"sha": "1cc008c5ee9cebd69c5120d7f2bd6bab5e8b13dd", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -27,7 +27,7 @@\n #![feature(libc)]\n #![feature(staged_api)]\n #![feature(unique)]\n-#![cfg_attr(test, feature(rustc_private, rand, vec_push_all))]\n+#![cfg_attr(test, feature(rustc_private, rand))]\n \n #[cfg(test)]\n #[macro_use]\n@@ -173,7 +173,7 @@ mod tests {\n         for _ in 0..20 {\n             let mut input = vec![];\n             for _ in 0..2000 {\n-                input.push_all(r.choose(&words).unwrap());\n+                input.extend_from_slice(r.choose(&words).unwrap());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());"}, {"sha": "e651f5bc1829be40319d6f8626e8decaf9dc448d", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -30,7 +30,6 @@\n             issue = \"27703\")]\n #![feature(core_float)]\n #![feature(core_intrinsics)]\n-#![feature(num_bits_bytes)]\n #![feature(staged_api)]\n #![feature(step_by)]\n #![feature(custom_attribute)]"}, {"sha": "1185ad25485bd32ca3efbe67dd32871ed1c7025d", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -11,15 +11,14 @@\n //! The implementations of `Rand` for the built-in types.\n \n use core::char;\n-use core::isize;\n-use core::usize;\n+use core::mem;\n \n use {Rand, Rng};\n \n impl Rand for isize {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> isize {\n-        if isize::BITS == 32 {\n+        if mem::size_of::<isize>() == 4 {\n             rng.gen::<i32>() as isize\n         } else {\n             rng.gen::<i64>() as isize\n@@ -58,7 +57,7 @@ impl Rand for i64 {\n impl Rand for usize {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> usize {\n-        if usize::BITS == 32 {\n+        if mem::size_of::<usize>() == 4 {\n             rng.gen::<u32>() as usize\n         } else {\n             rng.gen::<u64>() as usize"}, {"sha": "2f86262afbe22604acb97fc2d730be2e19a5324a", "filename": "src/librustc_back/dynamic_lib.rs", "status": "renamed", "additions": 76, "deletions": 160, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_back%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_back%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fdynamic_lib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -12,46 +12,22 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![unstable(feature = \"dynamic_lib\",\n-            reason = \"API has not been scrutinized and is highly likely to \\\n-                      either disappear or change\",\n-            issue = \"27810\")]\n-#![allow(missing_docs)]\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-\n-use env;\n-use ffi::{CString, OsString};\n-use path::{Path, PathBuf};\n-\n-#[unstable(feature = \"dynamic_lib\",\n-           reason = \"API has not been scrutinized and is highly likely to \\\n-                     either disappear or change\",\n-           issue = \"27810\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with 'dylib' on crates.io\")]\n+use std::env;\n+use std::ffi::{CString, OsString};\n+use std::path::{Path, PathBuf};\n+\n pub struct DynamicLibrary {\n     handle: *mut u8\n }\n \n impl Drop for DynamicLibrary {\n     fn drop(&mut self) {\n-        match dl::check_for_errors_in(|| {\n-            unsafe {\n-                dl::close(self.handle)\n-            }\n-        }) {\n-            Ok(()) => {},\n-            Err(str) => panic!(\"{}\", str)\n+        unsafe {\n+            dl::close(self.handle)\n         }\n     }\n }\n \n-#[unstable(feature = \"dynamic_lib\",\n-           reason = \"API has not been scrutinized and is highly likely to \\\n-                     either disappear or change\",\n-           issue = \"27810\")]\n-#[rustc_deprecated(since = \"1.5.0\", reason = \"replaced with 'dylib' on crates.io\")]\n impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n@@ -116,9 +92,7 @@ impl DynamicLibrary {\n         // T but that feature is still unimplemented\n \n         let raw_string = CString::new(symbol).unwrap();\n-        let maybe_symbol_value = dl::check_for_errors_in(|| {\n-            dl::symbol(self.handle, raw_string.as_ptr())\n-        });\n+        let maybe_symbol_value = dl::symbol(self.handle, raw_string.as_ptr());\n \n         // The value must not be constructed if there is an error so\n         // the destructor does not run.\n@@ -129,19 +103,18 @@ impl DynamicLibrary {\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"ios\"), not(target_os = \"nacl\")))]\n+#[cfg(test)]\n mod tests {\n     use super::*;\n-    use prelude::v1::*;\n     use libc;\n-    use mem;\n+    use std::mem;\n \n     #[test]\n-    #[cfg_attr(any(windows,\n-                   target_os = \"android\",  // FIXME #10379\n-                   target_env = \"musl\"), ignore)]\n-    #[allow(deprecated)]\n     fn test_loading_cosine() {\n+        if cfg!(windows) {\n+            return\n+        }\n+\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n         let libm = match DynamicLibrary::open(None) {\n@@ -166,17 +139,12 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(any(target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n-    #[allow(deprecated)]\n     fn test_errors_do_not_crash() {\n-        use path::Path;\n+        use std::path::Path;\n+\n+        if !cfg!(unix) {\n+            return\n+        }\n \n         // Open /dev/null as a library to get an error, and make sure\n         // that only causes an error, and not a crash.\n@@ -188,24 +156,13 @@ mod tests {\n     }\n }\n \n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\",\n-          target_os = \"emscripten\"))]\n+#[cfg(unix)]\n mod dl {\n-    use prelude::v1::*;\n-\n-    use ffi::{CStr, OsStr};\n-    use str;\n     use libc;\n-    use ptr;\n+    use std::ffi::{CStr, OsStr, CString};\n+    use std::os::unix::prelude::*;\n+    use std::ptr;\n+    use std::str;\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n@@ -221,7 +178,7 @@ mod dl {\n     const LAZY: libc::c_int = 1;\n \n     unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n-        let s = filename.to_cstring().unwrap();\n+        let s = CString::new(filename.as_bytes()).unwrap();\n         libc::dlopen(s.as_ptr(), LAZY) as *mut u8\n     }\n \n@@ -232,7 +189,7 @@ mod dl {\n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n         F: FnOnce() -> T,\n     {\n-        use sync::StaticMutex;\n+        use std::sync::StaticMutex;\n         static LOCK: StaticMutex = StaticMutex::new();\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n@@ -255,144 +212,103 @@ mod dl {\n     }\n \n     pub unsafe fn symbol(handle: *mut u8,\n-                         symbol: *const libc::c_char) -> *mut u8 {\n-        libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n+                         symbol: *const libc::c_char)\n+                         -> Result<*mut u8, String> {\n+        check_for_errors_in(|| {\n+            libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n+        })\n     }\n     pub unsafe fn close(handle: *mut u8) {\n         libc::dlclose(handle as *mut libc::c_void); ()\n     }\n }\n \n-#[cfg(target_os = \"windows\")]\n+#[cfg(windows)]\n mod dl {\n-    use prelude::v1::*;\n-\n-    use ffi::OsStr;\n-    use libc;\n-    use os::windows::prelude::*;\n-    use ptr;\n-    use sys::c;\n-    use sys::os;\n+    use std::ffi::OsStr;\n+    use std::io;\n+    use std::os::windows::prelude::*;\n+    use std::ptr;\n+\n+    use libc::{c_uint, c_void, c_char};\n+\n+    type DWORD = u32;\n+    type HMODULE = *mut u8;\n+    type BOOL = i32;\n+    type LPCWSTR = *const u16;\n+    type LPCSTR = *const i8;\n+\n+    extern \"system\" {\n+        fn SetThreadErrorMode(dwNewMode: DWORD,\n+                              lpOldMode: *mut DWORD) -> c_uint;\n+        fn LoadLibraryW(name: LPCWSTR) -> HMODULE;\n+        fn GetModuleHandleExW(dwFlags: DWORD,\n+                              name: LPCWSTR,\n+                              handle: *mut HMODULE) -> BOOL;\n+        fn GetProcAddress(handle: HMODULE,\n+                          name: LPCSTR) -> *mut c_void;\n+        fn FreeLibrary(handle: HMODULE) -> BOOL;\n+    }\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n-        let mut use_thread_mode = true;\n         let prev_error_mode = unsafe {\n             // SEM_FAILCRITICALERRORS 0x01\n             let new_error_mode = 1;\n             let mut prev_error_mode = 0;\n-            // Windows >= 7 supports thread error mode.\n-            let result = c::SetThreadErrorMode(new_error_mode,\n-                                               &mut prev_error_mode);\n+            let result = SetThreadErrorMode(new_error_mode,\n+                                            &mut prev_error_mode);\n             if result == 0 {\n-                let err = os::errno();\n-                if err == c::ERROR_CALL_NOT_IMPLEMENTED as i32 {\n-                    use_thread_mode = false;\n-                    // SetThreadErrorMode not found. use fallback solution:\n-                    // SetErrorMode() Note that SetErrorMode is process-wide so\n-                    // this can cause race condition!  However, since even\n-                    // Windows APIs do not care of such problem (#20650), we\n-                    // just assume SetErrorMode race is not a great deal.\n-                    prev_error_mode = c::SetErrorMode(new_error_mode);\n-                }\n+                return Err(io::Error::last_os_error().to_string())\n             }\n             prev_error_mode\n         };\n \n-        unsafe {\n-            c::SetLastError(0);\n-        }\n-\n         let result = match filename {\n             Some(filename) => {\n                 let filename_str: Vec<_> =\n                     filename.encode_wide().chain(Some(0)).collect();\n                 let result = unsafe {\n-                    c::LoadLibraryW(filename_str.as_ptr())\n+                    LoadLibraryW(filename_str.as_ptr())\n                 };\n-                // beware: Vec/String may change errno during drop!\n-                // so we get error here.\n-                if result == ptr::null_mut() {\n-                    let errno = os::errno();\n-                    Err(os::error_string(errno))\n-                } else {\n-                    Ok(result as *mut u8)\n-                }\n+                ptr_result(result)\n             }\n             None => {\n                 let mut handle = ptr::null_mut();\n                 let succeeded = unsafe {\n-                    c::GetModuleHandleExW(0 as c::DWORD, ptr::null(),\n-                                          &mut handle)\n+                    GetModuleHandleExW(0 as DWORD, ptr::null(), &mut handle)\n                 };\n-                if succeeded == c::FALSE {\n-                    let errno = os::errno();\n-                    Err(os::error_string(errno))\n+                if succeeded == 0 {\n+                    Err(io::Error::last_os_error().to_string())\n                 } else {\n                     Ok(handle as *mut u8)\n                 }\n             }\n         };\n \n         unsafe {\n-            if use_thread_mode {\n-                c::SetThreadErrorMode(prev_error_mode, ptr::null_mut());\n-            } else {\n-                c::SetErrorMode(prev_error_mode);\n-            }\n+            SetThreadErrorMode(prev_error_mode, ptr::null_mut());\n         }\n \n         result\n     }\n \n-    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n-        F: FnOnce() -> T,\n-    {\n-        unsafe {\n-            c::SetLastError(0);\n-\n-            let result = f();\n-\n-            let error = os::errno();\n-            if 0 == error {\n-                Ok(result)\n-            } else {\n-                Err(format!(\"Error code {}\", error))\n-            }\n-        }\n+    pub unsafe fn symbol(handle: *mut u8,\n+                         symbol: *const c_char)\n+                         -> Result<*mut u8, String> {\n+        let ptr = GetProcAddress(handle as HMODULE, symbol) as *mut u8;\n+        ptr_result(ptr)\n     }\n \n-    pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 {\n-        c::GetProcAddress(handle as c::HMODULE, symbol) as *mut u8\n-    }\n     pub unsafe fn close(handle: *mut u8) {\n-        c::FreeLibrary(handle as c::HMODULE);\n-    }\n-}\n-\n-#[cfg(target_os = \"nacl\")]\n-pub mod dl {\n-    use ffi::OsStr;\n-    use ptr;\n-    use result::Result;\n-    use result::Result::Err;\n-    use libc;\n-    use string::String;\n-    use ops::FnOnce;\n-    use option::Option;\n-\n-    pub fn open(_filename: Option<&OsStr>) -> Result<*mut u8, String> {\n-        Err(format!(\"NaCl + Newlib doesn't impl loading shared objects\"))\n+        FreeLibrary(handle as HMODULE);\n     }\n \n-    pub fn check_for_errors_in<T, F>(_f: F) -> Result<T, String>\n-        where F: FnOnce() -> T,\n-    {\n-        Err(format!(\"NaCl doesn't support shared objects\"))\n-    }\n-\n-    pub unsafe fn symbol(_handle: *mut u8, _symbol: *const libc::c_char) -> *mut u8 {\n-        ptr::null_mut()\n+    fn ptr_result<T>(ptr: *mut T) -> Result<*mut T, String> {\n+        if ptr.is_null() {\n+            Err(io::Error::last_os_error().to_string())\n+        } else {\n+            Ok(ptr)\n+        }\n     }\n-    pub unsafe fn close(_handle: *mut u8) { }\n }", "previous_filename": "src/libstd/dynamic_lib.rs"}, {"sha": "2b677d665d4f3355ed013bb12abad9a72a9d0aac", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -31,12 +31,14 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(box_syntax)]\n+#![feature(const_fn)]\n #![feature(copy_from_slice)]\n #![feature(libc)]\n #![feature(rand)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(step_by)]\n+#![cfg_attr(unix, feature(static_mutex))]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;\n@@ -53,3 +55,4 @@ pub mod sha2;\n pub mod svh;\n pub mod target;\n pub mod slice;\n+pub mod dynamic_lib;"}, {"sha": "89fa0df0306fbc941f38c8143ef9ff413739efd1", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_front = { path = \"../librustc_front\" }\n rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "8de26083910685d764ab255ae996f5a5d6b69f71", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -59,7 +59,6 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n-#![feature(dynamic_lib)]\n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -69,6 +68,7 @@\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n extern crate rustc;\n+extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_metadata;\n extern crate rustc_mir;"}, {"sha": "a950198a4e4f79a772a08a779df264ed544eec40", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -103,12 +103,11 @@ impl<'a> PluginLoader<'a> {\n     }\n \n     // Dynamically link a registrar function into the compiler process.\n-    #[allow(deprecated)]\n     fn dylink_registrar(&mut self,\n                         span: Span,\n                         path: PathBuf,\n                         symbol: String) -> PluginRegistrarFun {\n-        use std::dynamic_lib::DynamicLibrary;\n+        use rustc_back::dynamic_lib::DynamicLibrary;\n \n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(&path);"}, {"sha": "8a0ad987e2107e695178132eaeaf7e91c609cd74", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -20,7 +20,6 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(dynamic_lib)]\n #![feature(libc)]\n #![feature(recover)]\n #![feature(rustc_private)]"}, {"sha": "83ce3e61ab281af14801bbc6afaa9757794813c7", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -12,12 +12,13 @@\n \n use clean;\n \n-use std::dynamic_lib as dl;\n use serialize::json;\n use std::mem;\n use std::string::String;\n use std::path::PathBuf;\n \n+use rustc_back::dynamic_lib as dl;\n+\n pub type PluginJson = Option<(String, json::Json)>;\n pub type PluginResult = (clean::Crate, PluginJson);\n pub type PluginCallback = fn (clean::Crate) -> PluginResult;"}, {"sha": "129039b1a06fd3f09b8628b75886faff0ec1cdeb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n-\n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n-use std::dynamic_lib::DynamicLibrary;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -32,6 +29,7 @@ use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n use rustc_front::lowering::{lower_crate, LoweringContext};\n+use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use rustc_metadata::cstore::CStore;"}, {"sha": "ec5629038a4db781e39f09ad2a5c2f717555e254", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -592,15 +592,6 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Deprecated, renamed to `with_hasher`\n-    #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    #[rustc_deprecated(since = \"1.7.0\", reason = \"renamed to with_hasher\")]\n-    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n-        HashMap::with_hasher(hash_state)\n-    }\n-\n     /// Creates an empty HashMap with space for at least `capacity`\n     /// elements, using `hasher` to hash the keys.\n     ///\n@@ -634,17 +625,6 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Deprecated, renamed to `with_capacity_and_hasher`\n-    #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    #[rustc_deprecated(since = \"1.7.0\",\n-                       reason = \"renamed to with_capacity_and_hasher\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashMap<K, V, S> {\n-        HashMap::with_capacity_and_hasher(capacity, hash_state)\n-    }\n-\n     /// Returns a reference to the map's hasher.\n     #[unstable(feature = \"hashmap_public_hasher\", reason = \"don't want to make insta-stable\",\n                issue = \"31262\")]"}, {"sha": "7a22bec5a3f89a3c7f3593b284ca33effc5d37ff", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -14,7 +14,6 @@ mod bench;\n mod table;\n pub mod map;\n pub mod set;\n-pub mod state;\n \n trait Recover<Q: ?Sized> {\n     type Key;"}, {"sha": "8415395579725815cfe52625a3f8e75d77f89321", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -200,26 +200,6 @@ impl<T, S> HashSet<T, S>\n         self.map.hasher()\n     }\n \n-    /// Deprecated, renamed to `with_hasher`\n-    #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    #[rustc_deprecated(since = \"1.7.0\", reason = \"renamed to with_hasher\")]\n-    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n-        HashSet::with_hasher(hash_state)\n-    }\n-\n-    /// Deprecated, renamed to `with_capacity_and_hasher`\n-    #[inline]\n-    #[unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-               issue = \"27713\")]\n-    #[rustc_deprecated(since = \"1.7.0\",\n-                       reason = \"renamed to with_capacity_and_hasher\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashSet<T, S> {\n-        HashSet::with_capacity_and_hasher(capacity, hash_state)\n-    }\n-\n     /// Returns the number of elements the set can hold without reallocating.\n     ///\n     /// # Examples"}, {"sha": "167aca083038ef948caeb368239c3620ddb81715", "filename": "src/libstd/collections/hash/state.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8788ffc670e981a195c771ab3c8530c72eb119d7/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8788ffc670e981a195c771ab3c8530c72eb119d7/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=8788ffc670e981a195c771ab3c8530c72eb119d7", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"hashmap_hasher\", reason = \"hasher stuff is unclear\",\n-            issue = \"27713\")]\n-#![rustc_deprecated(since = \"1.7.0\", reason = \"support moved to std::hash\")]\n-#![allow(deprecated)]\n-\n-use clone::Clone;\n-use default::Default;\n-use hash;\n-use marker;\n-\n-pub use hash::HashState;\n-\n-/// A structure which is a factory for instances of `Hasher` which implement the\n-/// default trait.\n-///\n-/// This struct is 0-sized and does not need construction.\n-pub struct DefaultState<H>(marker::PhantomData<H>);\n-\n-impl<H: Default + hash::Hasher> HashState for DefaultState<H> {\n-    type Hasher = H;\n-    fn hasher(&self) -> H { Default::default() }\n-}\n-\n-impl<H> Clone for DefaultState<H> {\n-    fn clone(&self) -> DefaultState<H> { DefaultState(marker::PhantomData) }\n-}\n-\n-impl<H> Default for DefaultState<H> {\n-    fn default() -> DefaultState<H> { DefaultState(marker::PhantomData) }\n-}"}, {"sha": "4de442fd3a19955a1b23894ca6ab43b39035e4e7", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -442,13 +442,3 @@ pub mod hash_set {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::hash::set::*;\n }\n-\n-/// Experimental support for providing custom hash algorithms to a HashMap and\n-/// HashSet.\n-#[unstable(feature = \"hashmap_hasher\", reason = \"module was recently added\",\n-           issue = \"27713\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"support moved to std::hash\")]\n-#[allow(deprecated)]\n-pub mod hash_state {\n-    pub use super::hash::state::*;\n-}"}, {"sha": "46f2d3a64181b1bf6fd0a14b95e7eed0e2ac4db4", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use borrow::{Borrow, Cow, ToOwned};\n-use ffi::CString;\n use fmt::{self, Debug};\n use mem;\n use string::String;\n@@ -56,22 +55,6 @@ impl OsString {\n         OsString { inner: Buf::from_string(String::new()) }\n     }\n \n-    /// Constructs an `OsString` from a byte sequence.\n-    ///\n-    /// # Platform behavior\n-    ///\n-    /// On Unix systems, any byte sequence can be successfully\n-    /// converted into an `OsString`.\n-    ///\n-    /// On Windows system, only UTF-8 byte sequences will successfully\n-    /// convert; non UTF-8 data will produce `None`.\n-    #[unstable(feature = \"convert\", reason = \"recently added\", issue = \"27704\")]\n-    #[rustc_deprecated(reason = \"RFC was closed, hides subtle Windows semantics\",\n-                       since = \"1.6.0\")]\n-    pub fn from_bytes<B>(bytes: B) -> Option<OsString> where B: Into<Vec<u8>> {\n-        Self::_from_bytes(bytes.into())\n-    }\n-\n     #[cfg(unix)]\n     fn _from_bytes(vec: Vec<u8>) -> Option<OsString> {\n         use os::unix::ffi::OsStringExt;\n@@ -294,41 +277,6 @@ impl OsStr {\n         OsString { inner: self.inner.to_owned() }\n     }\n \n-    /// Yields this `OsStr` as a byte slice.\n-    ///\n-    /// # Platform behavior\n-    ///\n-    /// On Unix systems, this is a no-op.\n-    ///\n-    /// On Windows systems, this returns `None` unless the `OsStr` is\n-    /// valid Unicode, in which case it produces UTF-8-encoded\n-    /// data. This may entail checking validity.\n-    #[unstable(feature = \"convert\", reason = \"recently added\", issue = \"27704\")]\n-    #[rustc_deprecated(reason = \"RFC was closed, hides subtle Windows semantics\",\n-                       since = \"1.6.0\")]\n-    pub fn to_bytes(&self) -> Option<&[u8]> {\n-        if cfg!(windows) {\n-            self.to_str().map(|s| s.as_bytes())\n-        } else {\n-            Some(self.bytes())\n-        }\n-    }\n-\n-    /// Creates a `CString` containing this `OsStr` data.\n-    ///\n-    /// Fails if the `OsStr` contains interior nulls.\n-    ///\n-    /// This is a convenience for creating a `CString` from\n-    /// `self.to_bytes()`, and inherits the platform behavior of the\n-    /// `to_bytes` method.\n-    #[unstable(feature = \"convert\", reason = \"recently added\", issue = \"27704\")]\n-    #[rustc_deprecated(reason = \"RFC was closed, hides subtle Windows semantics\",\n-                       since = \"1.6.0\")]\n-    #[allow(deprecated)]\n-    pub fn to_cstring(&self) -> Option<CString> {\n-        self.to_bytes().and_then(|b| CString::new(b).ok())\n-    }\n-\n     /// Checks whether the `OsStr` is empty.\n     #[unstable(feature = \"osstring_simple_functions\",\n                reason = \"recently added\", issue = \"29453\")]"}, {"sha": "b98344b01a7a3bd9f9d92252f2702e3b5b64eaea", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 101, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -85,19 +85,6 @@ pub struct ReadDir(fs_imp::ReadDir);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DirEntry(fs_imp::DirEntry);\n \n-/// An iterator that recursively walks over the contents of a directory.\n-#[unstable(feature = \"fs_walk\",\n-           reason = \"the precise semantics and defaults for a recursive walk \\\n-                     may change and this may end up accounting for files such \\\n-                     as symlinks differently\",\n-           issue = \"27707\")]\n-#[rustc_deprecated(reason = \"superceded by the walkdir crate\",\n-                   since = \"1.6.0\")]\n-pub struct WalkDir {\n-    cur: Option<ReadDir>,\n-    stack: Vec<io::Result<ReadDir>>,\n-}\n-\n /// Options and flags which can be used to configure how a file is opened.\n ///\n /// This builder exposes the ability to configure how a `File` is opened and\n@@ -1345,7 +1332,7 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// use std::fs::{self, DirEntry};\n /// use std::path::Path;\n ///\n-/// // one possible implementation of fs::walk_dir only visiting files\n+/// // one possible implementation of walking a directory only visiting files\n /// fn visit_dirs(dir: &Path, cb: &Fn(&DirEntry)) -> io::Result<()> {\n ///     if try!(fs::metadata(dir)).is_dir() {\n ///         for entry in try!(fs::read_dir(dir)) {\n@@ -1365,64 +1352,6 @@ pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n     fs_imp::readdir(path.as_ref()).map(ReadDir)\n }\n \n-/// Returns an iterator that will recursively walk the directory structure\n-/// rooted at `path`.\n-///\n-/// The path given will not be iterated over, and this will perform iteration in\n-/// some top-down order.  The contents of unreadable subdirectories are ignored.\n-///\n-/// The iterator will yield instances of `io::Result<DirEntry>`. New errors may\n-/// be encountered after an iterator is initially constructed.\n-#[unstable(feature = \"fs_walk\",\n-           reason = \"the precise semantics and defaults for a recursive walk \\\n-                     may change and this may end up accounting for files such \\\n-                     as symlinks differently\",\n-           issue = \"27707\")]\n-#[rustc_deprecated(reason = \"superceded by the walkdir crate\",\n-                   since = \"1.6.0\")]\n-#[allow(deprecated)]\n-pub fn walk_dir<P: AsRef<Path>>(path: P) -> io::Result<WalkDir> {\n-    _walk_dir(path.as_ref())\n-}\n-\n-#[allow(deprecated)]\n-fn _walk_dir(path: &Path) -> io::Result<WalkDir> {\n-    let start = try!(read_dir(path));\n-    Ok(WalkDir { cur: Some(start), stack: Vec::new() })\n-}\n-\n-#[unstable(feature = \"fs_walk\", issue = \"27707\")]\n-#[rustc_deprecated(reason = \"superceded by the walkdir crate\",\n-                   since = \"1.6.0\")]\n-#[allow(deprecated)]\n-impl Iterator for WalkDir {\n-    type Item = io::Result<DirEntry>;\n-\n-    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        loop {\n-            if let Some(ref mut cur) = self.cur {\n-                match cur.next() {\n-                    Some(Err(e)) => return Some(Err(e)),\n-                    Some(Ok(next)) => {\n-                        let path = next.path();\n-                        if path.is_dir() {\n-                            self.stack.push(read_dir(&*path));\n-                        }\n-                        return Some(Ok(next))\n-                    }\n-                    None => {}\n-                }\n-            }\n-            self.cur = None;\n-            match self.stack.pop() {\n-                Some(Err(e)) => return Some(Err(e)),\n-                Some(Ok(next)) => self.cur = Some(next),\n-                None => return None,\n-            }\n-        }\n-    }\n-}\n-\n /// Changes the permissions found on a file or a directory.\n ///\n /// # Platform-specific behavior\n@@ -1865,35 +1794,6 @@ mod tests {\n         check!(fs::remove_dir(dir));\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn file_test_walk_dir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"walk_dir\");\n-        check!(fs::create_dir(dir));\n-\n-        let dir1 = &dir.join(\"01/02/03\");\n-        check!(fs::create_dir_all(dir1));\n-        check!(File::create(&dir1.join(\"04\")));\n-\n-        let dir2 = &dir.join(\"11/12/13\");\n-        check!(fs::create_dir_all(dir2));\n-        check!(File::create(&dir2.join(\"14\")));\n-\n-        let files = check!(fs::walk_dir(dir));\n-        let mut cur = [0; 2];\n-        for f in files {\n-            let f = f.unwrap().path();\n-            let stem = f.file_stem().unwrap().to_str().unwrap();\n-            let root = stem.as_bytes()[0] - b'0';\n-            let name = stem.as_bytes()[1] - b'0';\n-            assert!(cur[root as usize] < name);\n-            cur[root as usize] = name;\n-        }\n-\n-        check!(fs::remove_dir_all(dir));\n-    }\n-\n     #[test]\n     fn mkdir_path_already_exists_error() {\n         let tmpdir = tmpdir();"}, {"sha": "9a605fc7bbff48c1080c50948a588c883b09451e", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -150,12 +150,6 @@ pub enum ErrorKind {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Other,\n \n-    #[allow(missing_docs)]\n-    #[unstable(feature = \"read_exact_old\", reason = \"recently added\",\n-               issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.6.0\", reason = \"renamed to UnexpectedEof\")]\n-    UnexpectedEOF,\n-\n     /// An error returned when an operation could not be completed because an\n     /// \"end of file\" was reached prematurely.\n     ///\n@@ -311,7 +305,6 @@ impl fmt::Display for Error {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl error::Error for Error {\n-    #[allow(deprecated)] // remove with UnexpectedEOF\n     fn description(&self) -> &str {\n         match self.repr {\n             Repr::Os(..) => match self.kind() {\n@@ -332,7 +325,6 @@ impl error::Error for Error {\n                 ErrorKind::WriteZero => \"write zero\",\n                 ErrorKind::Interrupted => \"operation interrupted\",\n                 ErrorKind::Other => \"other os error\",\n-                ErrorKind::UnexpectedEOF => \"unexpected end of file\",\n                 ErrorKind::UnexpectedEof => \"unexpected end of file\",\n                 ErrorKind::__Nonexhaustive => unreachable!()\n             },"}, {"sha": "60a720efb7984dd41d08175349c42102ef6b7424", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -811,49 +811,6 @@ pub trait Read {\n     fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n         Take { inner: self, limit: limit }\n     }\n-\n-    /// Creates a reader adaptor which will write all read data into the given\n-    /// output stream.\n-    ///\n-    /// Whenever the returned `Read` instance is read it will write the read\n-    /// data to `out`. The current semantics of this implementation imply that\n-    /// a `write` error will not report how much data was initially read.\n-    ///\n-    /// # Examples\n-    ///\n-    /// [`File`][file]s implement `Read`:\n-    ///\n-    /// [file]: ../fs/struct.File.html\n-    ///\n-    /// ```\n-    /// #![feature(io)]\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n-    /// use std::fs::File;\n-    ///\n-    /// # fn foo() -> io::Result<()> {\n-    /// let mut f = try!(File::open(\"foo.txt\"));\n-    /// let mut buffer1 = Vec::with_capacity(10);\n-    /// let mut buffer2 = Vec::with_capacity(10);\n-    ///\n-    /// // write the output to buffer1 as we read\n-    /// let mut handle = f.tee(&mut buffer1);\n-    ///\n-    /// try!(handle.read(&mut buffer2));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n-                                         of where errors happen is currently \\\n-                                         unclear and may change\",\n-               issue = \"27802\")]\n-    #[rustc_deprecated(reason = \"error handling semantics unclear and \\\n-                                 don't seem to have an ergonomic resolution\",\n-                       since = \"1.6.0\")]\n-    #[allow(deprecated)]\n-    fn tee<W: Write>(self, out: W) -> Tee<Self, W> where Self: Sized {\n-        Tee { reader: self, writer: out }\n-    }\n }\n \n /// A trait for objects which are byte-oriented sinks.\n@@ -1089,47 +1046,6 @@ pub trait Write {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n-\n-    /// Creates a new writer which will write all data to both this writer and\n-    /// another writer.\n-    ///\n-    /// All data written to the returned writer will both be written to `self`\n-    /// as well as `other`. Note that the error semantics of the current\n-    /// implementation do not precisely track where errors happen. For example\n-    /// an error on the second call to `write` will not report that the first\n-    /// call to `write` succeeded.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(io)]\n-    /// use std::io::prelude::*;\n-    /// use std::fs::File;\n-    ///\n-    /// # fn foo() -> std::io::Result<()> {\n-    /// let mut buffer1 = try!(File::create(\"foo.txt\"));\n-    /// let mut buffer2 = Vec::new();\n-    ///\n-    /// // write the output to buffer1 as we read\n-    /// let mut handle = buffer1.broadcast(&mut buffer2);\n-    ///\n-    /// try!(handle.write(b\"some bytes\"));\n-    /// # Ok(())\n-    /// # }\n-    /// ```\n-    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n-                                         of where errors happen is currently \\\n-                                         unclear and may change\",\n-               issue = \"27802\")]\n-    #[rustc_deprecated(reason = \"error handling semantics unclear and \\\n-                                 don't seem to have an ergonomic resolution\",\n-                       since = \"1.6.0\")]\n-    #[allow(deprecated)]\n-    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W>\n-        where Self: Sized\n-    {\n-        Broadcast { first: self, second: other }\n-    }\n }\n \n /// The `Seek` trait provides a cursor which can be moved within a stream of\n@@ -1500,41 +1416,6 @@ pub trait BufRead: Read {\n     }\n }\n \n-/// A `Write` adaptor which will write data to multiple locations.\n-///\n-/// This struct is generally created by calling [`broadcast()`][broadcast] on a\n-/// writer. Please see the documentation of `broadcast()` for more details.\n-///\n-/// [broadcast]: trait.Write.html#method.broadcast\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Write::broadcast\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(reason = \"error handling semantics unclear and \\\n-                             don't seem to have an ergonomic resolution\",\n-                   since = \"1.6.0\")]\n-pub struct Broadcast<T, U> {\n-    first: T,\n-    second: U,\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Write::broadcast\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(reason = \"error handling semantics unclear and \\\n-                             don't seem to have an ergonomic resolution\",\n-                   since = \"1.6.0\")]\n-#[allow(deprecated)]\n-impl<T: Write, U: Write> Write for Broadcast<T, U> {\n-    fn write(&mut self, data: &[u8]) -> Result<usize> {\n-        let n = try!(self.first.write(data));\n-        // FIXME: what if the write fails? (we wrote something)\n-        try!(self.second.write_all(&data[..n]));\n-        Ok(n)\n-    }\n-\n-    fn flush(&mut self) -> Result<()> {\n-        self.first.flush().and(self.second.flush())\n-    }\n-}\n-\n /// Adaptor to chain together two readers.\n ///\n /// This struct is generally created by calling [`chain()`][chain] on a reader.\n@@ -1616,37 +1497,6 @@ impl<T: BufRead> BufRead for Take<T> {\n     }\n }\n \n-/// An adaptor which will emit all read data to a specified writer as well.\n-///\n-/// This struct is generally created by calling [`tee()`][tee] on a reader.\n-/// Please see the documentation of `tee()` for more details.\n-///\n-/// [tee]: trait.Read.html#method.tee\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::tee\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(reason = \"error handling semantics unclear and \\\n-                             don't seem to have an ergonomic resolution\",\n-                   since = \"1.6.0\")]\n-pub struct Tee<R, W> {\n-    reader: R,\n-    writer: W,\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::tee\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(reason = \"error handling semantics unclear and \\\n-                             don't seem to have an ergonomic resolution\",\n-                   since = \"1.6.0\")]\n-#[allow(deprecated)]\n-impl<R: Read, W: Write> Read for Tee<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n-        let n = try!(self.reader.read(buf));\n-        // FIXME: what if the write fails? (we read something)\n-        try!(self.writer.write_all(&buf[..n]));\n-        Ok(n)\n-    }\n-}\n-\n /// An iterator over `u8` values of a reader.\n ///\n /// This struct is generally created by calling [`bytes()`][bytes] on a reader."}, {"sha": "fddb095f21e5c4ea5ba49995c64033e938cfb534", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -197,31 +197,4 @@ mod tests {\n         assert_eq!(repeat(4).take(100).bytes().next().unwrap().unwrap(), 4);\n         assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n     }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn tee() {\n-        let mut buf = [0; 10];\n-        {\n-            let mut ptr: &mut [u8] = &mut buf;\n-            assert_eq!(repeat(4).tee(&mut ptr).take(5).read(&mut [0; 10]).unwrap(), 5);\n-        }\n-        assert_eq!(buf, [4, 4, 4, 4, 4, 0, 0, 0, 0, 0]);\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn broadcast() {\n-        let mut buf1 = [0; 10];\n-        let mut buf2 = [0; 10];\n-        {\n-            let mut ptr1: &mut [u8] = &mut buf1;\n-            let mut ptr2: &mut [u8] = &mut buf2;\n-\n-            assert_eq!((&mut ptr1).broadcast(&mut ptr2)\n-                                  .write(&[1, 2, 3]).unwrap(), 3);\n-        }\n-        assert_eq!(buf1, buf2);\n-        assert_eq!(buf1, [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]);\n-    }\n }"}, {"sha": "cd0e3a030bd31d6f92ebfbcdb433afd1c08ba3e1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -418,7 +418,6 @@ pub mod num;\n pub mod thread;\n \n pub mod collections;\n-pub mod dynamic_lib;\n pub mod env;\n pub mod ffi;\n pub mod fs;"}, {"sha": "22332b709ce89666e1760283cc3c54ad2baefc62", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -128,33 +128,3 @@ impl Iterator for LookupHost {\n pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     net_imp::lookup_host(host).map(LookupHost)\n }\n-\n-/// Resolve the given address to a hostname.\n-///\n-/// This function may perform a DNS query to resolve `addr` and may also inspect\n-/// system configuration to resolve the specified address. If the address\n-/// cannot be resolved, it is returned in string format.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// #![feature(lookup_addr)]\n-/// #![feature(ip_addr)]\n-///\n-/// use std::net::{self, Ipv4Addr, IpAddr};\n-///\n-/// let ip_addr = \"8.8.8.8\";\n-/// let addr: Ipv4Addr = ip_addr.parse().unwrap();\n-/// let hostname = net::lookup_addr(&IpAddr::V4(addr)).unwrap();\n-///\n-/// println!(\"{} --> {}\", ip_addr, hostname);\n-/// // Output: 8.8.8.8 --> google-public-dns-a.google.com\n-/// ```\n-#[unstable(feature = \"lookup_addr\", reason = \"recent addition\",\n-           issue = \"27705\")]\n-#[rustc_deprecated(reason = \"ipaddr type is being deprecated\",\n-                   since = \"1.6.0\")]\n-#[allow(deprecated)]\n-pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> {\n-    net_imp::lookup_addr(addr)\n-}"}, {"sha": "1886b4fdf59c6160a660cbd2f76492b1d8e77d25", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -21,7 +21,7 @@ pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::num::{wrapping, Wrapping};\n+pub use core::num::Wrapping;\n \n #[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt;"}, {"sha": "5309cc3c858f6536b9d15dd1378c46d2537c1fbe", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 69, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -100,8 +100,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use ascii::*;\n-#[allow(deprecated)]\n-use borrow::{Borrow, IntoCow, ToOwned, Cow};\n+use borrow::{Borrow, ToOwned, Cow};\n use cmp;\n use error::Error;\n use fmt;\n@@ -781,14 +780,6 @@ impl<'a> Components<'a> {\n             }\n         }\n     }\n-\n-    /// Examine the next component without consuming it.\n-    #[unstable(feature = \"path_components_peek\", issue = \"27727\")]\n-    #[rustc_deprecated(reason = \"use peekable() instead\",\n-                       since = \"1.6.0\")]\n-    pub fn peek(&self) -> Option<Component<'a>> {\n-        self.clone().next()\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1218,22 +1209,6 @@ impl Borrow<Path> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl IntoCow<'static, Path> for PathBuf {\n-    fn into_cow(self) -> Cow<'static, Path> {\n-        Cow::Owned(self)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a> IntoCow<'a, Path> for &'a Path {\n-    fn into_cow(self) -> Cow<'a, Path> {\n-        Cow::Borrowed(self)\n-    }\n-}\n-\n #[stable(feature = \"cow_from_path\", since = \"1.6.0\")]\n impl<'a> From<&'a Path> for Cow<'a, Path> {\n     #[inline]\n@@ -1474,17 +1449,7 @@ impl Path {\n         !self.is_absolute()\n     }\n \n-    /// Returns the *prefix* of a path, if any.\n-    ///\n-    /// Prefixes are relevant only for Windows paths, and consist of volumes\n-    /// like `C:`, UNC prefixes like `\\\\server`, and others described in more\n-    /// detail in `std::os::windows::PathExt`.\n-    #[unstable(feature = \"path_prefix\",\n-               reason = \"uncertain whether to expose this convenience\",\n-               issue = \"27722\")]\n-    #[rustc_deprecated(since = \"1.7.0\",\n-                       reason = \"inspect components().next() instead\")]\n-    pub fn prefix(&self) -> Option<Prefix> {\n+    fn prefix(&self) -> Option<Prefix> {\n         self.components().prefix\n     }\n \n@@ -1566,17 +1531,6 @@ impl Path {\n         })\n     }\n \n-    /// Returns a path that, when joined onto `base`, yields `self`.\n-    ///\n-    /// If `base` is not a prefix of `self` (i.e. `starts_with`\n-    /// returns false), then `relative_from` returns `None`.\n-    #[unstable(feature = \"path_relative_from\", reason = \"see #23284\",\n-               issue = \"23284\")]\n-    #[rustc_deprecated(since = \"1.7.0\", reason = \"renamed to strip_prefix\")]\n-    pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path> {\n-        self._strip_prefix(base.as_ref()).ok()\n-    }\n-\n     /// Returns a path that, when joined onto `base`, yields `self`.\n     ///\n     /// # Errors\n@@ -2236,27 +2190,6 @@ mod tests {\n         );\n     );\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn into_cow() {\n-        use borrow::{Cow, IntoCow};\n-\n-        let static_path = Path::new(\"/home/foo\");\n-        let static_cow_path: Cow<'static, Path> = static_path.into_cow();\n-        let pathbuf = PathBuf::from(\"/home/foo\");\n-\n-        {\n-            let path: &Path = &pathbuf;\n-            let borrowed_cow_path: Cow<Path> = path.into_cow();\n-\n-            assert_eq!(static_cow_path, borrowed_cow_path);\n-        }\n-\n-        let owned_cow_path: Cow<'static, Path> = pathbuf.into_cow();\n-\n-        assert_eq!(static_cow_path, owned_cow_path);\n-    }\n-\n     #[test]\n     fn into() {\n         use borrow::Cow;"}, {"sha": "64468be396f344f2f875fc079aacac2dfbbe5de5", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -167,13 +167,12 @@ impl Condvar {\n     /// returns, regardless of whether the timeout elapsed or not.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::sync::Condvar::wait_timeout`\")]\n-    #[allow(deprecated)]\n     pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)\n                                   -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        unsafe {\n-            let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout_ms(guard, ms)\n-        }\n+        let res = self.wait_timeout(guard, Duration::from_millis(ms as u64));\n+        poison::map_result(res, |(a, b)| {\n+            (a, !b.timed_out())\n+        })\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n@@ -200,30 +199,6 @@ impl Condvar {\n         }\n     }\n \n-    /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n-    ///\n-    /// The semantics of this function are equivalent to `wait_timeout` except\n-    /// that the implementation will repeatedly wait while the duration has not\n-    /// passed and the provided function returns `false`.\n-    #[unstable(feature = \"wait_timeout_with\",\n-               reason = \"unsure if this API is broadly needed or what form it should take\",\n-               issue = \"27748\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"wonky signature and questionable \\\n-                                 implementation didn't justify existence\")]\n-    pub fn wait_timeout_with<'a, T, F>(&self,\n-                                       guard: MutexGuard<'a, T>,\n-                                       dur: Duration,\n-                                       f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n-            where F: FnMut(LockResult<&mut T>) -> bool {\n-        unsafe {\n-            let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout_with(guard, dur, f)\n-        }\n-    }\n-\n     /// Wakes up one blocked thread on this condvar.\n     ///\n     /// If there is a blocked thread on this condition variable, then it will\n@@ -286,26 +261,6 @@ impl StaticCondvar {\n         }\n     }\n \n-    /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n-    ///\n-    /// See `Condvar::wait_timeout`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    #[rustc_deprecated(since = \"1.6.0\",\n-                       reason = \"replaced by `std::sync::StaticCondvar::wait_timeout`\")]\n-    pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n-                                  -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        match self.wait_timeout(guard, Duration::from_millis(ms as u64)) {\n-            Ok((guard, timed_out)) => Ok((guard, !timed_out.timed_out())),\n-            Err(poison) => {\n-                let (guard, timed_out) = poison.into_inner();\n-                Err(PoisonError::new((guard, !timed_out.timed_out())))\n-            }\n-        }\n-    }\n-\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///"}, {"sha": "c20b422d40cf5b907e9f8e3dff3825ca6e3f8d29", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -38,9 +38,6 @@ pub use sys_common::poison::{PoisonError, TryLockError, TryLockResult, LockResul\n pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::semaphore::{Semaphore, SemaphoreGuard};\n \n pub mod mpsc;\n \n@@ -49,4 +46,3 @@ mod condvar;\n mod mutex;\n mod once;\n mod rwlock;\n-mod semaphore;"}, {"sha": "dd76444d3ae02edbbc0064f794b2b43e7f7b6de3", "filename": "src/libstd/sync/semaphore.rs", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/8788ffc670e981a195c771ab3c8530c72eb119d7/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8788ffc670e981a195c771ab3c8530c72eb119d7/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=8788ffc670e981a195c771ab3c8530c72eb119d7", "patch": "@@ -1,226 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"semaphore\",\n-            reason = \"the interaction between semaphores and the acquisition/release \\\n-                      of resources is currently unclear\",\n-            issue = \"27798\")]\n-#![allow(deprecated)]\n-\n-use ops::Drop;\n-use sync::{Mutex, Condvar};\n-\n-/// A counting, blocking, semaphore.\n-///\n-/// Semaphores are a form of atomic counter where access is only granted if the\n-/// counter is a positive value. Each acquisition will block the calling thread\n-/// until the counter is positive, and each release will increment the counter\n-/// and unblock any threads if necessary.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(semaphore)]\n-///\n-/// use std::sync::Semaphore;\n-///\n-/// // Create a semaphore that represents 5 resources\n-/// let sem = Semaphore::new(5);\n-///\n-/// // Acquire one of the resources\n-/// sem.acquire();\n-///\n-/// // Acquire one of the resources for a limited period of time\n-/// {\n-///     let _guard = sem.access();\n-///     // ...\n-/// } // resources is released here\n-///\n-/// // Release our initially acquired resource\n-/// sem.release();\n-/// ```\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"easily confused with system semaphores and not \\\n-                             used enough to pull its weight\")]\n-#[unstable(feature = \"semaphore\",\n-           reason = \"the interaction between semaphores and the acquisition/release \\\n-                     of resources is currently unclear\",\n-           issue = \"27798\")]\n-pub struct Semaphore {\n-    lock: Mutex<isize>,\n-    cvar: Condvar,\n-}\n-\n-/// An RAII guard which will release a resource acquired from a semaphore when\n-/// dropped.\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"easily confused with system semaphores and not \\\n-                             used enough to pull its weight\")]\n-#[unstable(feature = \"semaphore\",\n-           reason = \"the interaction between semaphores and the acquisition/release \\\n-                     of resources is currently unclear\",\n-           issue = \"27798\")]\n-pub struct SemaphoreGuard<'a> {\n-    sem: &'a Semaphore,\n-}\n-\n-#[rustc_deprecated(since = \"1.7.0\",\n-                   reason = \"easily confused with system semaphores and not \\\n-                             used enough to pull its weight\")]\n-#[unstable(feature = \"semaphore\",\n-           reason = \"the interaction between semaphores and the acquisition/release \\\n-                     of resources is currently unclear\",\n-           issue = \"27798\")]\n-impl Semaphore {\n-    /// Creates a new semaphore with the initial count specified.\n-    ///\n-    /// The count specified can be thought of as a number of resources, and a\n-    /// call to `acquire` or `access` will block until at least one resource is\n-    /// available. It is valid to initialize a semaphore with a negative count.\n-    pub fn new(count: isize) -> Semaphore {\n-        Semaphore {\n-            lock: Mutex::new(count),\n-            cvar: Condvar::new(),\n-        }\n-    }\n-\n-    /// Acquires a resource of this semaphore, blocking the current thread until\n-    /// it can do so.\n-    ///\n-    /// This method will block until the internal count of the semaphore is at\n-    /// least 1.\n-    pub fn acquire(&self) {\n-        let mut count = self.lock.lock().unwrap();\n-        while *count <= 0 {\n-            count = self.cvar.wait(count).unwrap();\n-        }\n-        *count -= 1;\n-    }\n-\n-    /// Release a resource from this semaphore.\n-    ///\n-    /// This will increment the number of resources in this semaphore by 1 and\n-    /// will notify any pending waiters in `acquire` or `access` if necessary.\n-    pub fn release(&self) {\n-        *self.lock.lock().unwrap() += 1;\n-        self.cvar.notify_one();\n-    }\n-\n-    /// Acquires a resource of this semaphore, returning an RAII guard to\n-    /// release the semaphore when dropped.\n-    ///\n-    /// This function is semantically equivalent to an `acquire` followed by a\n-    /// `release` when the guard returned is dropped.\n-    pub fn access(&self) -> SemaphoreGuard {\n-        self.acquire();\n-        SemaphoreGuard { sem: self }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Drop for SemaphoreGuard<'a> {\n-    fn drop(&mut self) {\n-        self.sem.release();\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use sync::Arc;\n-    use super::Semaphore;\n-    use sync::mpsc::channel;\n-    use thread;\n-\n-    #[test]\n-    fn test_sem_acquire_release() {\n-        let s = Semaphore::new(1);\n-        s.acquire();\n-        s.release();\n-        s.acquire();\n-    }\n-\n-    #[test]\n-    fn test_sem_basic() {\n-        let s = Semaphore::new(1);\n-        let _g = s.access();\n-    }\n-\n-    #[test]\n-    fn test_sem_as_mutex() {\n-        let s = Arc::new(Semaphore::new(1));\n-        let s2 = s.clone();\n-        let _t = thread::spawn(move|| {\n-            let _g = s2.access();\n-        });\n-        let _g = s.access();\n-    }\n-\n-    #[test]\n-    fn test_sem_as_cvar() {\n-        /* Child waits and parent signals */\n-        let (tx, rx) = channel();\n-        let s = Arc::new(Semaphore::new(0));\n-        let s2 = s.clone();\n-        let _t = thread::spawn(move|| {\n-            s2.acquire();\n-            tx.send(()).unwrap();\n-        });\n-        s.release();\n-        let _ = rx.recv();\n-\n-        /* Parent waits and child signals */\n-        let (tx, rx) = channel();\n-        let s = Arc::new(Semaphore::new(0));\n-        let s2 = s.clone();\n-        let _t = thread::spawn(move|| {\n-            s2.release();\n-            let _ = rx.recv();\n-        });\n-        s.acquire();\n-        tx.send(()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_sem_multi_resource() {\n-        // Parent and child both get in the critical section at the same\n-        // time, and shake hands.\n-        let s = Arc::new(Semaphore::new(2));\n-        let s2 = s.clone();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let _g = s2.access();\n-            let _ = rx2.recv();\n-            tx1.send(()).unwrap();\n-        });\n-        let _g = s.access();\n-        tx2.send(()).unwrap();\n-        rx1.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_sem_runtime_friendly_blocking() {\n-        let s = Arc::new(Semaphore::new(1));\n-        let s2 = s.clone();\n-        let (tx, rx) = channel();\n-        {\n-            let _g = s.access();\n-            thread::spawn(move|| {\n-                tx.send(()).unwrap();\n-                drop(s2.access());\n-                tx.send(()).unwrap();\n-            });\n-            rx.recv().unwrap(); // wait for child to come alive\n-        }\n-        rx.recv().unwrap(); // wait for child to be done\n-    }\n-}"}, {"sha": "42714feb9217e3604d366368c37ff6b9712320db", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -11,15 +11,13 @@\n use prelude::v1::*;\n \n use cmp;\n-use ffi::{CStr, CString};\n+use ffi::CString;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{c_int, c_char, c_void};\n+use libc::{c_int, c_void};\n use mem;\n-#[allow(deprecated)]\n-use net::{SocketAddr, Shutdown, IpAddr, Ipv4Addr, Ipv6Addr};\n+use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n use ptr;\n-use str::from_utf8;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use sys::net::netc as c;\n use sys_common::{AsInner, FromInner, IntoInner};\n@@ -154,34 +152,6 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// lookup_addr\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[allow(deprecated)]\n-pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> {\n-    init();\n-\n-    let saddr = SocketAddr::new(*addr, 0);\n-    let (inner, len) = saddr.into_inner();\n-    let mut hostbuf = [0 as c_char; c::NI_MAXHOST as usize];\n-\n-    let data = unsafe {\n-        try!(cvt_gai(c::getnameinfo(inner, len,\n-                                    hostbuf.as_mut_ptr(),\n-                                    c::NI_MAXHOST,\n-                                    ptr::null_mut(), 0, 0)));\n-\n-        CStr::from_ptr(hostbuf.as_ptr())\n-    };\n-\n-    match from_utf8(data.to_bytes()) {\n-        Ok(name) => Ok(name.to_owned()),\n-        Err(_) => Err(io::Error::new(io::ErrorKind::Other,\n-                                     \"failed to lookup address information\"))\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // TCP streams\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "1793ad0e4459f842e4cbd3b33e9cadcdfb4abf79", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"reentrant_mutex\", reason = \"new API\",\n-            issue = \"27738\")]\n-\n use prelude::v1::*;\n \n use fmt;"}, {"sha": "a1528458860f6754fcb3568ce33b096e6ca1df90", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -15,90 +15,11 @@\n use fs::{self, Permissions, OpenOptions};\n use io;\n use libc;\n-#[allow(deprecated)]\n-use os::unix::raw;\n use path::Path;\n use sys;\n use sys_common::{FromInner, AsInner, AsInnerMut};\n use sys::platform::fs::MetadataExt as UnixMetadataExt;\n \n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const USER_READ: raw::mode_t = 0o400;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const USER_WRITE: raw::mode_t = 0o200;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const USER_EXECUTE: raw::mode_t = 0o100;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const USER_RWX: raw::mode_t = 0o700;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const GROUP_READ: raw::mode_t = 0o040;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const GROUP_WRITE: raw::mode_t = 0o020;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const GROUP_EXECUTE: raw::mode_t = 0o010;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const GROUP_RWX: raw::mode_t = 0o070;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const OTHER_READ: raw::mode_t = 0o004;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const OTHER_WRITE: raw::mode_t = 0o002;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const OTHER_EXECUTE: raw::mode_t = 0o001;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const OTHER_RWX: raw::mode_t = 0o007;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const ALL_READ: raw::mode_t = 0o444;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const ALL_WRITE: raw::mode_t = 0o222;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const ALL_EXECUTE: raw::mode_t = 0o111;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const ALL_RWX: raw::mode_t = 0o777;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const SETUID: raw::mode_t = 0o4000;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const SETGID: raw::mode_t = 0o2000;\n-#[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n-#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n-#[allow(deprecated)]\n-pub const STICKY_BIT: raw::mode_t = 0o1000;\n-\n /// Unix-specific extensions to `Permissions`\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n pub trait PermissionsExt {"}, {"sha": "3cc3a631b89de1c6662fdb0c8d1be576930b8ce7", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -26,22 +26,22 @@\n \n use io::prelude::*;\n \n-use dynamic_lib::DynamicLibrary;\n use io;\n use libc::c_void;\n use mem;\n-use path::Path;\n use ptr;\n use sync::StaticMutex;\n use sys::c;\n+use sys::dynamic_lib::DynamicLibrary;\n \n-macro_rules! sym{ ($lib:expr, $e:expr, $t:ident) => (unsafe {\n-    let lib = $lib;\n-    match lib.symbol($e) {\n-        Ok(f) => $crate::mem::transmute::<*mut u8, $t>(f),\n-        Err(..) => return Ok(())\n-    }\n-}) }\n+macro_rules! sym {\n+    ($lib:expr, $e:expr, $t:ident) => (\n+        match $lib.symbol($e) {\n+            Ok(f) => $crate::mem::transmute::<usize, $t>(f),\n+            Err(..) => return Ok(())\n+        }\n+    )\n+}\n \n #[cfg(target_env = \"msvc\")]\n #[path = \"printing/msvc.rs\"]\n@@ -52,16 +52,16 @@ mod printing;\n mod printing;\n \n type SymInitializeFn =\n-    extern \"system\" fn(c::HANDLE, *mut c_void,\n-                       c::BOOL) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::HANDLE, *mut c_void,\n+                              c::BOOL) -> c::BOOL;\n type SymCleanupFn =\n-    extern \"system\" fn(c::HANDLE) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::HANDLE) -> c::BOOL;\n \n type StackWalk64Fn =\n-    extern \"system\" fn(c::DWORD, c::HANDLE, c::HANDLE,\n-                       *mut c::STACKFRAME64, *mut c::CONTEXT,\n-                       *mut c_void, *mut c_void,\n-                       *mut c_void, *mut c_void) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::DWORD, c::HANDLE, c::HANDLE,\n+                              *mut c::STACKFRAME64, *mut c::CONTEXT,\n+                              *mut c_void, *mut c_void,\n+                              *mut c_void, *mut c_void) -> c::BOOL;\n \n #[cfg(target_arch = \"x86\")]\n pub fn init_frame(frame: &mut c::STACKFRAME64,\n@@ -93,7 +93,9 @@ struct Cleanup {\n }\n \n impl Drop for Cleanup {\n-    fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n+    fn drop(&mut self) {\n+        unsafe { (self.SymCleanup)(self.handle); }\n+    }\n }\n \n pub fn write(w: &mut Write) -> io::Result<()> {\n@@ -102,52 +104,50 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n-    // Open up dbghelp.dll, we don't link to it explicitly because it can't\n-    // always be found. Additionally, it's nice having fewer dependencies.\n-    let path = Path::new(\"dbghelp.dll\");\n-    let dbghelp = match DynamicLibrary::open(Some(&path)) {\n+    let dbghelp = match DynamicLibrary::open(\"dbghelp.dll\") {\n         Ok(lib) => lib,\n         Err(..) => return Ok(()),\n     };\n-\n-    // Fetch the symbols necessary from dbghelp.dll\n-    let SymInitialize = sym!(&dbghelp, \"SymInitialize\", SymInitializeFn);\n-    let SymCleanup = sym!(&dbghelp, \"SymCleanup\", SymCleanupFn);\n-    let StackWalk64 = sym!(&dbghelp, \"StackWalk64\", StackWalk64Fn);\n-\n-    // Allocate necessary structures for doing the stack walk\n-    let process = unsafe { c::GetCurrentProcess() };\n-    let thread = unsafe { c::GetCurrentThread() };\n-    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n-    unsafe { c::RtlCaptureContext(&mut context); }\n-    let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n-    let image = init_frame(&mut frame, &context);\n-\n-    // Initialize this process's symbols\n-    let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n-    if ret != c::TRUE { return Ok(()) }\n-    let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n-\n-    // And now that we're done with all the setup, do the stack walking!\n-    // Start from -1 to avoid printing this stack frame, which will\n-    // always be exactly the same.\n-    let mut i = -1;\n-    try!(write!(w, \"stack backtrace:\\n\"));\n-    while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                      ptr::null_mut(),\n-                      ptr::null_mut(),\n-                      ptr::null_mut(),\n-                      ptr::null_mut()) == c::TRUE {\n-        let addr = frame.AddrPC.Offset;\n-        if addr == frame.AddrReturn.Offset || addr == 0 ||\n-           frame.AddrReturn.Offset == 0 { break }\n-\n-        i += 1;\n-\n-        if i >= 0 {\n-            try!(printing::print(w, i, addr-1, &dbghelp, process));\n+    unsafe {\n+        // Fetch the symbols necessary from dbghelp.dll\n+        let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn);\n+        let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn);\n+        let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n+\n+        // Allocate necessary structures for doing the stack walk\n+        let process = c::GetCurrentProcess();\n+        let thread = c::GetCurrentThread();\n+        let mut context: c::CONTEXT = mem::zeroed();\n+        c::RtlCaptureContext(&mut context);\n+        let mut frame: c::STACKFRAME64 = mem::zeroed();\n+        let image = init_frame(&mut frame, &context);\n+\n+        // Initialize this process's symbols\n+        let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n+        if ret != c::TRUE { return Ok(()) }\n+        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+        // And now that we're done with all the setup, do the stack walking!\n+        // Start from -1 to avoid printing this stack frame, which will\n+        // always be exactly the same.\n+        let mut i = -1;\n+        try!(write!(w, \"stack backtrace:\\n\"));\n+        while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                          ptr::null_mut(),\n+                          ptr::null_mut(),\n+                          ptr::null_mut(),\n+                          ptr::null_mut()) == c::TRUE {\n+            let addr = frame.AddrPC.Offset;\n+            if addr == frame.AddrReturn.Offset || addr == 0 ||\n+               frame.AddrReturn.Offset == 0 { break }\n+\n+            i += 1;\n+\n+            if i >= 0 {\n+                try!(printing::print(w, i, addr - 1, process, &dbghelp));\n+            }\n         }\n-    }\n \n-    Ok(())\n+        Ok(())\n+    }\n }"}, {"sha": "ab24b9e6fd601560e37f5f78e96523ed87442f89", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -154,8 +154,6 @@ pub const WSAESHUTDOWN: c_int = 10058;\n pub const WSAETIMEDOUT: c_int = 10060;\n pub const WSAECONNREFUSED: c_int = 10061;\n \n-pub const NI_MAXHOST: DWORD = 1025;\n-\n pub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n \n pub const TOKEN_READ: DWORD = 0x20008;\n@@ -1099,18 +1097,11 @@ extern \"system\" {\n                        hints: *const ADDRINFOA,\n                        res: *mut *mut ADDRINFOA) -> c_int;\n     pub fn freeaddrinfo(res: *mut ADDRINFOA);\n-    pub fn getnameinfo(sa: *const SOCKADDR, salen: c_int,\n-                       host: *mut c_char, hostlen: DWORD,\n-                       serv: *mut c_char, servlen: DWORD,\n-                       flags: c_int) -> c_int;\n \n     pub fn LoadLibraryW(name: LPCWSTR) -> HMODULE;\n-    pub fn GetModuleHandleExW(dwFlags: DWORD, name: LPCWSTR,\n-                              handle: *mut HMODULE) -> BOOL;\n+    pub fn FreeLibrary(handle: HMODULE) -> BOOL;\n     pub fn GetProcAddress(handle: HMODULE,\n                           name: LPCSTR) -> *mut c_void;\n-    pub fn FreeLibrary(handle: HMODULE) -> BOOL;\n-    pub fn SetErrorMode(uMode: c_uint) -> c_uint;\n     pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n     pub fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n                                 pszContainer: LPCSTR,\n@@ -1177,10 +1168,6 @@ compat_fn! {\n                                      _dwFlags: DWORD) -> DWORD {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }\n-    pub fn SetThreadErrorMode(_dwNewMode: DWORD,\n-                              _lpOldMode: *mut DWORD) -> c_uint {\n-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-    }\n     pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }"}, {"sha": "84cfbe5e72129af46c6eaa494a2bd09c90c2a788", "filename": "src/libstd/sys/windows/dynamic_lib.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+use os::windows::prelude::*;\n+\n+use ffi::{CString, OsStr};\n+use io;\n+use sys::c;\n+\n+pub struct DynamicLibrary {\n+    handle: c::HMODULE,\n+}\n+\n+impl DynamicLibrary {\n+    pub fn open(filename: &str) -> io::Result<DynamicLibrary> {\n+        let filename = OsStr::new(filename)\n+                             .encode_wide()\n+                             .chain(Some(0))\n+                             .collect::<Vec<_>>();\n+        let result = unsafe {\n+            c::LoadLibraryW(filename.as_ptr())\n+        };\n+        if result.is_null() {\n+            Err(io::Error::last_os_error())\n+        } else {\n+            Ok(DynamicLibrary { handle: result })\n+        }\n+    }\n+\n+    pub fn symbol(&self, symbol: &str) -> io::Result<usize> {\n+        let symbol = try!(CString::new(symbol));\n+        unsafe {\n+            match c::GetProcAddress(self.handle, symbol.as_ptr()) as usize {\n+                0 => Err(io::Error::last_os_error()),\n+                n => Ok(n),\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for DynamicLibrary {\n+    fn drop(&mut self) {\n+        unsafe {\n+            c::FreeLibrary(self.handle);\n+        }\n+    }\n+}"}, {"sha": "384940e4dc446edbe0f0101378000b60a431727b", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -24,6 +24,7 @@ use time::Duration;\n pub mod backtrace;\n pub mod c;\n pub mod condvar;\n+pub mod dynamic_lib;\n pub mod ext;\n pub mod fs;\n pub mod handle;"}, {"sha": "be2d5273c07283832abfbee5424f09482210cd70", "filename": "src/libstd/sys/windows/printing/gnu.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,18 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n-\n-use dynamic_lib::DynamicLibrary;\n use io::prelude::*;\n use io;\n-use sys::c;\n use libc::c_void;\n-\n+use sys::c;\n+use sys::dynamic_lib::DynamicLibrary;\n use sys_common::gnu::libbacktrace;\n \n-pub fn print(w: &mut Write, i: isize, addr: u64, _: &DynamicLibrary, _: c::HANDLE)\n-        -> io::Result<()> {\n+pub fn print(w: &mut Write,\n+             i: isize,\n+             addr: u64,\n+             _process: c::HANDLE,\n+             _dbghelp: &DynamicLibrary)\n+              -> io::Result<()> {\n     let addr = addr as usize as *mut c_void;\n     libbacktrace::print(w, i, addr, addr)\n }"}, {"sha": "37aaa1f1b0e9f268d345ca4f017b35548e76b428", "filename": "src/libstd/sys/windows/printing/msvc.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,60 +8,66 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n-\n-use dynamic_lib::DynamicLibrary;\n use ffi::CStr;\n use io::prelude::*;\n use io;\n use libc::{c_ulong, c_int, c_char, c_void};\n use mem;\n use sys::c;\n+use sys::dynamic_lib::DynamicLibrary;\n use sys_common::backtrace::{output, output_fileline};\n \n type SymFromAddrFn =\n-    extern \"system\" fn(c::HANDLE, u64, *mut u64,\n-                       *mut c::SYMBOL_INFO) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u64,\n+                              *mut c::SYMBOL_INFO) -> c::BOOL;\n type SymGetLineFromAddr64Fn =\n-    extern \"system\" fn(c::HANDLE, u64, *mut u32,\n-                       *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n+    unsafe extern \"system\" fn(c::HANDLE, u64, *mut u32,\n+                              *mut c::IMAGEHLP_LINE64) -> c::BOOL;\n \n-pub fn print(w: &mut Write, i: isize, addr: u64, dbghelp: &DynamicLibrary,\n-             process: c::HANDLE) -> io::Result<()> {\n-    let SymFromAddr = sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn);\n-    let SymGetLineFromAddr64 = sym!(dbghelp, \"SymGetLineFromAddr64\", SymGetLineFromAddr64Fn);\n+pub fn print(w: &mut Write,\n+             i: isize,\n+             addr: u64,\n+             process: c::HANDLE,\n+             dbghelp: &DynamicLibrary)\n+              -> io::Result<()> {\n+    unsafe {\n+        let SymFromAddr = sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn);\n+        let SymGetLineFromAddr64 = sym!(dbghelp,\n+                                        \"SymGetLineFromAddr64\",\n+                                        SymGetLineFromAddr64Fn);\n \n-    let mut info: c::SYMBOL_INFO = unsafe { mem::zeroed() };\n-    info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n-    // the struct size in C.  the value is different to\n-    // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-    // due to struct alignment.\n-    info.SizeOfStruct = 88;\n+        let mut info: c::SYMBOL_INFO = mem::zeroed();\n+        info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n+        // the struct size in C.  the value is different to\n+        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+        // due to struct alignment.\n+        info.SizeOfStruct = 88;\n \n-    let mut displacement = 0u64;\n-    let ret = SymFromAddr(process, addr, &mut displacement, &mut info);\n+        let mut displacement = 0u64;\n+        let ret = SymFromAddr(process, addr, &mut displacement, &mut info);\n \n-    let name = if ret == c::TRUE {\n-        let ptr = info.Name.as_ptr() as *const c_char;\n-        Some(unsafe { CStr::from_ptr(ptr).to_bytes() })\n-    } else {\n-        None\n-    };\n+        let name = if ret == c::TRUE {\n+            let ptr = info.Name.as_ptr() as *const c_char;\n+            Some(CStr::from_ptr(ptr).to_bytes())\n+        } else {\n+            None\n+        };\n \n-    try!(output(w, i, addr as usize as *mut c_void, name));\n+        try!(output(w, i, addr as usize as *mut c_void, name));\n \n-    // Now find out the filename and line number\n-    let mut line: c::IMAGEHLP_LINE64 = unsafe { mem::zeroed() };\n-    line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n+        // Now find out the filename and line number\n+        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n+        line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n \n-    let mut displacement = 0u32;\n-    let ret = SymGetLineFromAddr64(process, addr, &mut displacement, &mut line);\n-    if ret == c::TRUE {\n-        output_fileline(w,\n-                        unsafe { CStr::from_ptr(line.Filename).to_bytes() },\n-                        line.LineNumber as c_int,\n-                        false)\n-    } else {\n-        Ok(())\n+        let mut displacement = 0u32;\n+        let ret = SymGetLineFromAddr64(process, addr, &mut displacement, &mut line);\n+        if ret == c::TRUE {\n+            output_fileline(w,\n+                            CStr::from_ptr(line.Filename).to_bytes(),\n+                            line.LineNumber as c_int,\n+                            false)\n+        } else {\n+            Ok(())\n+        }\n     }\n }"}, {"sha": "2cf6c64eab891a86d839974313225daf78f08aca", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -339,40 +339,6 @@ pub fn panicking() -> bool {\n     unwind::panicking()\n }\n \n-/// Invokes a closure, capturing the cause of panic if one occurs.\n-///\n-/// This function will return `Ok` with the closure's result if the closure\n-/// does not panic, and will return `Err(cause)` if the closure panics. The\n-/// `cause` returned is the object with which panic was originally invoked.\n-///\n-/// It is currently undefined behavior to unwind from Rust code into foreign\n-/// code, so this function is particularly useful when Rust is called from\n-/// another language (normally C). This can run arbitrary Rust code, capturing a\n-/// panic and allowing a graceful handling of the error.\n-///\n-/// It is **not** recommended to use this function for a general try/catch\n-/// mechanism. The `Result` type is more appropriate to use for functions that\n-/// can fail on a regular basis.\n-///\n-/// The closure provided is required to adhere to the `'static` bound to ensure\n-/// that it cannot reference data in the parent stack frame, mitigating problems\n-/// with exception safety. Furthermore, a `Send` bound is also required,\n-/// providing the same safety guarantees as `thread::spawn` (ensuring the\n-/// closure is properly isolated from the parent).\n-#[unstable(feature = \"catch_panic\", reason = \"recent API addition\",\n-           issue = \"27719\")]\n-#[rustc_deprecated(since = \"1.6.0\", reason = \"renamed to std::panic::recover\")]\n-pub fn catch_panic<F, R>(f: F) -> Result<R>\n-    where F: FnOnce() -> R + Send + 'static\n-{\n-    let mut result = None;\n-    unsafe {\n-        let result = &mut result;\n-        try!(unwind::try(move || *result = Some(f())))\n-    }\n-    Ok(result.unwrap())\n-}\n-\n /// Puts the current thread to sleep for the specified amount of time.\n ///\n /// The thread may sleep longer than the duration specified due to scheduling"}, {"sha": "7c3240b4a40c4ac61ec5c8c64d4011dfc0062804", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use ops::{Add, Sub, Mul, Div};\n-use time::Instant;\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n@@ -59,21 +58,6 @@ impl Duration {\n         Duration { secs: secs, nanos: nanos }\n     }\n \n-    /// Runs a closure, returning the duration of time it took to run the\n-    /// closure.\n-    #[unstable(feature = \"duration_span\",\n-               reason = \"unsure if this is the right API or whether it should \\\n-                         wait for a more general \\\"moment in time\\\" \\\n-                         abstraction\",\n-               issue = \"27799\")]\n-    #[rustc_deprecated(reason = \"use std::time::Instant instead\",\n-                       since = \"1.6.0\")]\n-    pub fn span<F>(f: F) -> Duration where F: FnOnce() {\n-        let start = Instant::now();\n-        f();\n-        start.elapsed()\n-    }\n-\n     /// Creates a new `Duration` from the specified number of seconds.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     pub fn from_secs(secs: u64) -> Duration {"}, {"sha": "09a2e8ecd876d4c5d074873068896c944a57f75a", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(dynamic_lib)]\n+#![feature(rustc_private)]\n \n // We're testing linkage visibility; the compiler warns us, but we want to\n // do the runtime check that these functions aren't exported.\n #![allow(private_no_mangle_fns)]\n \n-use std::dynamic_lib::DynamicLibrary;\n+extern crate rustc_back;\n+\n+use rustc_back::dynamic_lib::DynamicLibrary;\n \n #[no_mangle]\n pub fn foo() { bar(); }"}, {"sha": "a24515c5160987dcbc16e5cebc698e09326404b4", "filename": "src/test/compile-fail/ufcs-qpath-missing-params.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,7 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::borrow::IntoCow;\n+use std::borrow::Cow;\n+\n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+impl<'a> IntoCow<'a, str> for String {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        Cow::Owned(self)\n+    }\n+}\n \n fn main() {\n     <String as IntoCow>::into_cow(\"foo\".to_string());"}, {"sha": "a1bd1041d145eaa61e3090e4f79979770d0d5df5", "filename": "src/test/run-make/extern-fn-reachable/main.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(dynamic_lib)]\n+#![feature(rustc_private)]\n \n-use std::dynamic_lib::DynamicLibrary;\n+extern crate rustc_back;\n+\n+use rustc_back::dynamic_lib::DynamicLibrary;\n use std::path::Path;\n \n pub fn main() {"}, {"sha": "de89a6f6ad6929ae8fa1303b2a04e22a9bc435dc", "filename": "src/test/run-make/issue-26006/Makefile", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-make%2Fissue-26006%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-make%2Fissue-26006%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-26006%2FMakefile?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -1,16 +1,18 @@\n -include ../tools.mk\n \n+OUT := $(TMPDIR)/out\n+\n ifndef IS_WINDOWS\n all: time\n \n time: libc\n-\tmkdir -p out/time out/time/deps\n-\tln -sf out/libc/liblibc.rlib out/time/deps/\n-\t$(RUSTC) in/time/lib.rs -Ldependency=out/time/deps/\n+\tmkdir -p $(OUT)/time $(OUT)/time/deps\n+\tln -sf $(OUT)/libc/liblibc.rlib $(OUT)/time/deps/\n+\t$(RUSTC) in/time/lib.rs -Ldependency=$(OUT)/time/deps/\n \n libc:\n-\tmkdir -p out/libc\n-\t$(RUSTC) in/libc/lib.rs --crate-name=libc -o out/libc/liblibc.rlib\n+\tmkdir -p $(OUT)/libc\n+\t$(RUSTC) in/libc/lib.rs --crate-name=libc -o $(OUT)/libc/liblibc.rlib\n else\n all:\n endif"}, {"sha": "bf97f12055550e718052c939770180f7a5641889", "filename": "src/test/run-make/json-errors/Makefile", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -1,8 +1,10 @@\n -include ../tools.mk\n \n+LOG := $(TMPDIR)/foo.log\n+\n all:\n \tcp foo.rs $(TMPDIR)\n \tcd $(TMPDIR)\n-\t-$(RUSTC) -Z unstable-options --error-format=json foo.rs 2>foo.log\n-\tgrep -q '{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\\\nAn unresolved name was used. Example of erroneous codes.*\"},\"level\":\"error\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19}\\],\"children\":\\[\\]}' foo.log\n-\tgrep -q '{\"message\":\".*\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\\\nYou tried.*\"},\"level\":\"error\",\"spans\":\\[{.*}\\],\"children\":\\[{\"message\":\"the .*\",\"code\":null,\"level\":\"help\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":0,\"column_end\":0}\\],\"children\":\\[\\]},{\"message\":\"  <u8 as core::ops::Add>\",\"code\":null,\"level\":\"help\",' foo.log\n+\t-$(RUSTC) -Z unstable-options --error-format=json foo.rs 2>$(LOG)\n+\tgrep -q '{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\\\nAn unresolved name was used. Example of erroneous codes.*\"},\"level\":\"error\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19}\\],\"children\":\\[\\]}' $(LOG)\n+\tgrep -q '{\"message\":\".*\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\\\nYou tried.*\"},\"level\":\"error\",\"spans\":\\[{.*}\\],\"children\":\\[{\"message\":\"the .*\",\"code\":null,\"level\":\"help\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":0,\"column_end\":0}\\],\"children\":\\[\\]},{\"message\":\"  <u8 as core::ops::Add>\",\"code\":null,\"level\":\"help\",' $(LOG)"}, {"sha": "e6eaefb0490806e7c4c653cc5472c8f5ac10ef8d", "filename": "src/test/run-pass-fulldeps/linkage-visibility.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass-fulldeps%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass-fulldeps%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flinkage-visibility.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "previous_filename": "src/test/run-pass/linkage-visibility.rs"}, {"sha": "7ac624e6814dbb6c95eeb97ff32c58ef5961ff5c", "filename": "src/test/run-pass-fulldeps/placement-new-arena.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8788ffc670e981a195c771ab3c8530c72eb119d7/src%2Ftest%2Frun-pass-fulldeps%2Fplacement-new-arena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8788ffc670e981a195c771ab3c8530c72eb119d7/src%2Ftest%2Frun-pass-fulldeps%2Fplacement-new-arena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplacement-new-arena.rs?ref=8788ffc670e981a195c771ab3c8530c72eb119d7", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_private)]\n-\n-extern crate arena;\n-use arena::Arena;\n-\n-pub fn main() {\n-    let mut arena = Arena::new();\n-    let p = &mut arena;\n-    let x = p.alloc(|| 4_usize);\n-    println!(\"{}\", *x);\n-    assert_eq!(*x, 4_usize);\n-}"}, {"sha": "8b4a633d61358278058ce578dd7b765b179670ce", "filename": "src/test/run-pass/env-funky-keys.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fenv-funky-keys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fenv-funky-keys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-funky-keys.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -15,15 +15,15 @@\n // ignore-emscripten\n // no-prefer-dynamic\n \n-#![feature(convert)]\n #![feature(libc)]\n \n extern crate libc;\n \n use libc::c_char;\n use libc::execve;\n use std::env;\n-use std::ffi::OsStr;\n+use std::ffi::CString;\n+use std::os::unix::prelude::*;\n use std::ptr;\n \n fn main() {\n@@ -34,8 +34,11 @@ fn main() {\n         return;\n     }\n \n-    let current_exe = env::current_exe().unwrap().into_os_string().to_cstring().unwrap();\n-    let new_env_var = OsStr::new(\"FOOBAR\").to_cstring().unwrap();\n+    let current_exe = CString::new(env::current_exe()\n+                                       .unwrap()\n+                                       .as_os_str()\n+                                       .as_bytes()).unwrap();\n+    let new_env_var = CString::new(\"FOOBAR\").unwrap();\n     let filename: *const c_char = current_exe.as_ptr();\n     let argv: &[*const c_char] = &[filename, filename, ptr::null()];\n     let envp: &[*const c_char] = &[new_env_var.as_ptr(), ptr::null()];"}, {"sha": "1367ab2ed85bdccb61b71779afb5c0aa2f3ad7fa", "filename": "src/test/run-pass/issue-13763.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13763.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -10,15 +10,14 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(num_bits_bytes)]\n-\n-use std::u8;\n+mod u8 {\n+    pub const BITS: usize = 8;\n+}\n \n const NUM: usize = u8::BITS;\n \n struct MyStruct { nums: [usize; 8] }\n \n-\n fn main() {\n     let _s = MyStruct { nums: [0; NUM] };\n }"}, {"sha": "96e77c05ca2bd434c26e503efa3e888b7f9f98a7", "filename": "src/test/run-pass/issue-22577.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22577.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(fs, net, fs_walk)]\n+#![feature(fs, net)]\n \n use std::{fs, net};\n \n@@ -22,7 +22,6 @@ fn main() {\n     assert_both::<fs::Metadata>();\n     assert_both::<fs::ReadDir>();\n     assert_both::<fs::DirEntry>();\n-    assert_send::<fs::WalkDir>();\n     assert_both::<fs::OpenOptions>();\n     assert_both::<fs::Permissions>();\n "}, {"sha": "ba48648df32fb04255bb77d04f663484c6f534e1", "filename": "src/test/run-pass/minmax-stability-issue-23687.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(iter_min_max, cmp_partial, iter_cmp)]\n-\n use std::fmt::Debug;\n use std::cmp::{self, PartialOrd, Ordering};\n \n@@ -43,13 +41,13 @@ fn main() {\n \n     // `min` should return the left when the values are equal\n     assert_eq!(data.iter().min(), Some(&a));\n-    assert_eq!(data.iter().min_by(|a| a.n), Some(&a));\n+    assert_eq!(data.iter().min_by_key(|a| a.n), Some(&a));\n     assert_eq!(cmp::min(a, b), a);\n     assert_eq!(cmp::min(b, a), b);\n \n     // `max` should return the right when the values are equal\n     assert_eq!(data.iter().max(), Some(&f));\n-    assert_eq!(data.iter().max_by(|a| a.n), Some(&f));\n+    assert_eq!(data.iter().max_by_key(|a| a.n), Some(&f));\n     assert_eq!(cmp::max(e, f), f);\n     assert_eq!(cmp::max(f, e), e);\n "}, {"sha": "143759e271561c81d75c540740d5909d3bd8371d", "filename": "src/test/run-pass/num-wrapping.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-wrapping.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -12,7 +12,7 @@\n //\n // Test std::num::Wrapping<T> for {uN, iN, usize, isize}\n \n-#![feature(num_bits_bytes, test)]\n+#![feature(test)]\n \n extern crate test;\n \n@@ -22,9 +22,40 @@ use std::ops::{\n     AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitXorAssign, BitOrAssign, BitAndAssign,\n     Shl, Shr, ShlAssign, ShrAssign\n };\n-use std::{i8, i16, i32, i64, isize, u8, u16, u32, u64, usize};\n use test::black_box;\n \n+macro_rules! int_modules {\n+    ($(($name:ident, $size:expr),)*) => ($(\n+        mod $name {\n+            pub const BITS: usize = $size;\n+            pub use std::$name::*;\n+        }\n+    )*)\n+}\n+\n+int_modules! {\n+    (i8, 8),\n+    (i16, 16),\n+    (i32, 32),\n+    (i64, 64),\n+    (u8, 8),\n+    (u16, 16),\n+    (u32, 32),\n+    (u64, 64),\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+int_modules! {\n+    (isize, 32),\n+    (usize, 32),\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+int_modules! {\n+    (isize, 64),\n+    (usize, 64),\n+}\n+\n fn main() {\n     test_ops();\n     test_op_assigns();"}, {"sha": "2ff2d5a8aa52bd2e968f6a7e45ef071971fc1f78", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,57 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(collections, into_cow)]\n-\n-extern crate collections;\n-\n use std::collections::HashMap;\n-use std::borrow::{Cow, IntoCow};\n+use std::borrow::Cow;\n+\n+use std::borrow::Cow::Borrowed as B;\n+use std::borrow::Cow::Owned as O;\n \n type SendStr = Cow<'static, str>;\n \n-pub fn main() {\n+fn main() {\n     let mut map: HashMap<SendStr, usize> = HashMap::new();\n-    assert!(map.insert(\"foo\".into_cow(), 42).is_none());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n-    assert!(map.insert(\"foo\".into_cow(), 42).is_some());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n+    assert!(map.insert(B(\"foo\"), 42).is_none());\n+    assert!(map.insert(O(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(B(\"foo\"), 42).is_some());\n+    assert!(map.insert(O(\"foo\".to_string()), 42).is_some());\n \n-    assert!(map.insert(\"foo\".into_cow(), 43).is_some());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 44).is_some());\n-    assert!(map.insert(\"foo\".into_cow(), 45).is_some());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 46).is_some());\n+    assert!(map.insert(B(\"foo\"), 43).is_some());\n+    assert!(map.insert(O(\"foo\".to_string()), 44).is_some());\n+    assert!(map.insert(B(\"foo\"), 45).is_some());\n+    assert!(map.insert(O(\"foo\".to_string()), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.get(&\"foo\".to_string().into_cow()), Some(&v));\n-    assert_eq!(map.get(&\"foo\".into_cow()), Some(&v));\n+    assert_eq!(map.get(&O(\"foo\".to_string())), Some(&v));\n+    assert_eq!(map.get(&B(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(\"abc\".into_cow(), a).is_none());\n-    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_none());\n-    assert!(map.insert(\"cde\".into_cow(), c).is_none());\n-    assert!(map.insert(\"def\".to_string().into_cow(), d).is_none());\n+    assert!(map.insert(B(\"abc\"), a).is_none());\n+    assert!(map.insert(O(\"bcd\".to_string()), b).is_none());\n+    assert!(map.insert(B(\"cde\"), c).is_none());\n+    assert!(map.insert(O(\"def\".to_string()), d).is_none());\n \n-    assert!(map.insert(\"abc\".into_cow(), a).is_some());\n-    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_some());\n-    assert!(map.insert(\"cde\".into_cow(), c).is_some());\n-    assert!(map.insert(\"def\".to_string().into_cow(), d).is_some());\n+    assert!(map.insert(B(\"abc\"), a).is_some());\n+    assert!(map.insert(O(\"bcd\".to_string()), b).is_some());\n+    assert!(map.insert(B(\"cde\"), c).is_some());\n+    assert!(map.insert(O(\"def\".to_string()), d).is_some());\n \n-    assert!(map.insert(\"abc\".to_string().into_cow(), a).is_some());\n-    assert!(map.insert(\"bcd\".into_cow(), b).is_some());\n-    assert!(map.insert(\"cde\".to_string().into_cow(), c).is_some());\n-    assert!(map.insert(\"def\".into_cow(), d).is_some());\n+    assert!(map.insert(O(\"abc\".to_string()), a).is_some());\n+    assert!(map.insert(B(\"bcd\"), b).is_some());\n+    assert!(map.insert(O(\"cde\".to_string()), c).is_some());\n+    assert!(map.insert(B(\"def\"), d).is_some());\n \n     assert_eq!(map.get(\"abc\"), Some(&a));\n     assert_eq!(map.get(\"bcd\"), Some(&b));\n     assert_eq!(map.get(\"cde\"), Some(&c));\n     assert_eq!(map.get(\"def\"), Some(&d));\n \n-    assert_eq!(map.get(&\"abc\".into_cow()), Some(&a));\n-    assert_eq!(map.get(&\"bcd\".into_cow()), Some(&b));\n-    assert_eq!(map.get(&\"cde\".into_cow()), Some(&c));\n-    assert_eq!(map.get(&\"def\".into_cow()), Some(&d));\n+    assert_eq!(map.get(&B(\"abc\")), Some(&a));\n+    assert_eq!(map.get(&B(\"bcd\")), Some(&b));\n+    assert_eq!(map.get(&B(\"cde\")), Some(&c));\n+    assert_eq!(map.get(&B(\"def\")), Some(&d));\n }"}, {"sha": "3178dc94598812eaaa0c70399a8d46ed65647acd", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,61 +8,58 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::BTreeMap;\n+use std::borrow::Cow;\n \n-#![feature(collections, into_cow)]\n-\n-extern crate collections;\n-\n-use self::collections::BTreeMap;\n-use std::borrow::{Cow, IntoCow};\n+use std::borrow::Cow::{Owned as O, Borrowed as B};\n \n type SendStr = Cow<'static, str>;\n \n-pub fn main() {\n+fn main() {\n     let mut map: BTreeMap<SendStr, usize> = BTreeMap::new();\n-    assert!(map.insert(\"foo\".into_cow(), 42).is_none());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n-    assert!(map.insert(\"foo\".into_cow(), 42).is_some());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n+    assert!(map.insert(B(\"foo\"), 42).is_none());\n+    assert!(map.insert(O(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(B(\"foo\"), 42).is_some());\n+    assert!(map.insert(O(\"foo\".to_string()), 42).is_some());\n \n-    assert!(map.insert(\"foo\".into_cow(), 43).is_some());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 44).is_some());\n-    assert!(map.insert(\"foo\".into_cow(), 45).is_some());\n-    assert!(map.insert(\"foo\".to_string().into_cow(), 46).is_some());\n+    assert!(map.insert(B(\"foo\"), 43).is_some());\n+    assert!(map.insert(O(\"foo\".to_string()), 44).is_some());\n+    assert!(map.insert(B(\"foo\"), 45).is_some());\n+    assert!(map.insert(O(\"foo\".to_string()), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.get(&\"foo\".to_string().into_cow()), Some(&v));\n-    assert_eq!(map.get(&\"foo\".into_cow()), Some(&v));\n+    assert_eq!(map.get(&O(\"foo\".to_string())), Some(&v));\n+    assert_eq!(map.get(&B(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(\"abc\".into_cow(), a).is_none());\n-    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_none());\n-    assert!(map.insert(\"cde\".into_cow(), c).is_none());\n-    assert!(map.insert(\"def\".to_string().into_cow(), d).is_none());\n+    assert!(map.insert(B(\"abc\"), a).is_none());\n+    assert!(map.insert(O(\"bcd\".to_string()), b).is_none());\n+    assert!(map.insert(B(\"cde\"), c).is_none());\n+    assert!(map.insert(O(\"def\".to_string()), d).is_none());\n \n-    assert!(map.insert(\"abc\".into_cow(), a).is_some());\n-    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_some());\n-    assert!(map.insert(\"cde\".into_cow(), c).is_some());\n-    assert!(map.insert(\"def\".to_string().into_cow(), d).is_some());\n+    assert!(map.insert(B(\"abc\"), a).is_some());\n+    assert!(map.insert(O(\"bcd\".to_string()), b).is_some());\n+    assert!(map.insert(B(\"cde\"), c).is_some());\n+    assert!(map.insert(O(\"def\".to_string()), d).is_some());\n \n-    assert!(map.insert(\"abc\".to_string().into_cow(), a).is_some());\n-    assert!(map.insert(\"bcd\".into_cow(), b).is_some());\n-    assert!(map.insert(\"cde\".to_string().into_cow(), c).is_some());\n-    assert!(map.insert(\"def\".into_cow(), d).is_some());\n+    assert!(map.insert(O(\"abc\".to_string()), a).is_some());\n+    assert!(map.insert(B(\"bcd\"), b).is_some());\n+    assert!(map.insert(O(\"cde\".to_string()), c).is_some());\n+    assert!(map.insert(B(\"def\"), d).is_some());\n \n-    assert_eq!(map.get(&\"abc\".into_cow()), Some(&a));\n-    assert_eq!(map.get(&\"bcd\".into_cow()), Some(&b));\n-    assert_eq!(map.get(&\"cde\".into_cow()), Some(&c));\n-    assert_eq!(map.get(&\"def\".into_cow()), Some(&d));\n+    assert_eq!(map.get(&B(\"abc\")), Some(&a));\n+    assert_eq!(map.get(&B(\"bcd\")), Some(&b));\n+    assert_eq!(map.get(&B(\"cde\")), Some(&c));\n+    assert_eq!(map.get(&B(\"def\")), Some(&d));\n \n-    assert_eq!(map.get(&\"abc\".to_string().into_cow()), Some(&a));\n-    assert_eq!(map.get(&\"bcd\".to_string().into_cow()), Some(&b));\n-    assert_eq!(map.get(&\"cde\".to_string().into_cow()), Some(&c));\n-    assert_eq!(map.get(&\"def\".to_string().into_cow()), Some(&d));\n+    assert_eq!(map.get(&O(\"abc\".to_string())), Some(&a));\n+    assert_eq!(map.get(&O(\"bcd\".to_string())), Some(&b));\n+    assert_eq!(map.get(&O(\"cde\".to_string())), Some(&c));\n+    assert_eq!(map.get(&O(\"def\".to_string())), Some(&d));\n \n-    assert!(map.remove(&\"foo\".into_cow()).is_some());\n+    assert!(map.remove(&B(\"foo\")).is_some());\n     assert_eq!(map.into_iter().map(|(k, v)| format!(\"{}{}\", k, v))\n                               .collect::<Vec<String>>()\n                               .concat(),"}, {"sha": "7332f098b96fa770d62726a759120718dbb92554", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -24,7 +24,6 @@ fn main() {\n     assert_both::<sync::Mutex<()>>();\n     assert_both::<sync::Condvar>();\n     assert_both::<sync::RwLock<()>>();\n-    assert_both::<sync::Semaphore>();\n     assert_both::<sync::Barrier>();\n     assert_both::<sync::Arc<()>>();\n     assert_both::<sync::Weak<()>>();"}, {"sha": "491045564ce222b6f81d2530311feaf5b1d34e66", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(into_cow)]\n-\n-use std::borrow::{Cow, IntoCow};\n+use std::borrow::{Cow, ToOwned};\n use std::default::Default;\n use std::iter::FromIterator;\n use std::ops::Add;\n@@ -25,6 +23,16 @@ pub trait Rand: Default + Sized {\n }\n impl Rand for i32 { }\n \n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+impl<'a> IntoCow<'a, str> for String {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n #[derive(PartialEq, Eq)]\n struct Newt<T>(T);\n "}, {"sha": "5fe9dd60591cef6b3a15f79dc62eca229455c2d9", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(vec_push_all)]\n-\n use std::vec;\n \n pub fn main() {\n     let a: Vec<isize> = vec!(1, 2, 3, 4, 5);\n     let b: Vec<isize> = vec!(6, 7, 8, 9, 0);\n     let mut v: Vec<isize> = a;\n-    v.push_all(&b);\n+    v.extend_from_slice(&b);\n     println!(\"{}\", v[9]);\n     assert_eq!(v[0], 1);\n     assert_eq!(v[7], 8);"}, {"sha": "911bfc7454c2a9992400604cce85ad8ef4be5ec4", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c56de7643c3b989c703758f0fb9f426403bca2/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=a2c56de7643c3b989c703758f0fb9f426403bca2", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(rand, num_bits_bytes)]\n+#![feature(rand)]\n #![feature(const_fn)]\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -47,7 +47,6 @@ impl Drop for DropCounter {\n }\n \n pub fn main() {\n-    assert!(MAX_LEN <= std::usize::BITS);\n     // len can't go above 64.\n     for len in 2..MAX_LEN {\n         for _ in 0..REPEATS {"}]}