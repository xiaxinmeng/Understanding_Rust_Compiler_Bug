{"sha": "e4e2338f97d734624fb21b7972c73288ca04e65e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZTIzMzhmOTdkNzM0NjI0ZmIyMWI3OTcyYzczMjg4Y2EwNGU2NWU=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-23T18:59:38Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-25T18:03:55Z"}, "message": "Fix incorrect repeat sep eating", "tree": {"sha": "0282cab25534ba75976c690e003c7c8a095b3c73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0282cab25534ba75976c690e003c7c8a095b3c73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4e2338f97d734624fb21b7972c73288ca04e65e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e2338f97d734624fb21b7972c73288ca04e65e", "html_url": "https://github.com/rust-lang/rust/commit/e4e2338f97d734624fb21b7972c73288ca04e65e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4e2338f97d734624fb21b7972c73288ca04e65e/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bbd9f43cc217a44445fde91b4b53ca85d78cd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bbd9f43cc217a44445fde91b4b53ca85d78cd92", "html_url": "https://github.com/rust-lang/rust/commit/5bbd9f43cc217a44445fde91b4b53ca85d78cd92"}], "stats": {"total": 328, "additions": 304, "deletions": 24}, "files": [{"sha": "d7b18dd0f54de0ba111145e3303975c8e3a2303b", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 257, "deletions": 1, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/e4e2338f97d734624fb21b7972c73288ca04e65e/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e2338f97d734624fb21b7972c73288ca04e65e/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=e4e2338f97d734624fb21b7972c73288ca04e65e", "patch": "@@ -384,7 +384,7 @@ impl_froms!(TokenTree: Leaf, Subtree);\n \"#,\n         );\n \n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n+        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar ()}\");\n     }\n \n     #[test]\n@@ -1066,4 +1066,260 @@ macro_rules! int_base {\n         \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt :: Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n         );\n     }\n+\n+    #[test]\n+    fn test_generate_pattern_iterators() {\n+        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n+        let rules = create_rules(\n+            r#\"\n+macro_rules! generate_pattern_iterators {        \n+        { double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+        } => {\n+            fn foo(){}\n+        }\n+}\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str )\"#, \n+        \"fn foo () {}\");\n+    }\n+\n+    #[test]\n+    fn test_impl_fn_for_zst() {\n+        // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n+        let rules = create_rules(\n+            r#\"\n+macro_rules! impl_fn_for_zst  {        \n+        {  $( $( #[$attr: meta] )*\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+$body: block; )+\n+        } => {\n+            fn foo(){}\n+        }\n+}\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"\n+impl_fn_for_zst !   { \n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   { \n+         c . escape_debug_ext ( false ) \n+     } ; \n+\n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   { \n+         c . escape_unicode ( ) \n+     } ; \n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   { \n+         c . escape_default ( ) \n+     } ; \n+ }\n+\"#, \n+        \"fn foo () {}\");\n+    }\n+\n+    #[test]\n+    fn test_impl_nonzero_fmt() {\n+        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! impl_nonzero_fmt {\n+            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+                fn foo() {}\n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"impl_nonzero_fmt ! { # [ stable ( feature = \"nonzero\" , since = \"1.28.0\" ) ] ( Debug , Display , Binary , Octal , LowerHex , UpperHex ) for NonZeroU8 }\"#, \n+        \"fn foo () {}\");\n+    }\n+\n+    #[test]\n+    fn test_tuple_impls() {\n+        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n+        let rules = create_rules(\n+            r#\"\n+    macro_rules! tuple_impls {\n+    ($(\n+        $Tuple:ident {\n+            $(($idx:tt) -> $T:ident)+\n+        }\n+    )+) => {\n+        $(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n+                #[inline]\n+                fn eq(&self, other: &($($T,)+)) -> bool {\n+                    $(self.$idx == other.$idx)&&+\n+                }\n+                #[inline]\n+                fn ne(&self, other: &($($T,)+)) -> bool {\n+                    $(self.$idx != other.$idx)||+\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Eq),+> Eq for ($($T,)+) where last_type!($($T,)+): ?Sized {}\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+                    where last_type!($($T,)+): ?Sized {\n+                #[inline]\n+                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                    lexical_partial_cmp!($(self.$idx, other.$idx),+)\n+                }\n+                #[inline]\n+                fn lt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(lt, $(self.$idx, other.$idx),+)\n+                }\n+                #[inline]\n+                fn le(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(le, $(self.$idx, other.$idx),+)\n+                }\n+                #[inline]\n+                fn ge(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(ge, $(self.$idx, other.$idx),+)\n+                }\n+                #[inline]\n+                fn gt(&self, other: &($($T,)+)) -> bool {\n+                    lexical_ord!(gt, $(self.$idx, other.$idx),+)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Ord),+> Ord for ($($T,)+) where last_type!($($T,)+): ?Sized {\n+                #[inline]\n+                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n+                    lexical_cmp!($(self.$idx, other.$idx),+)\n+                }\n+            }\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($T:Default),+> Default for ($($T,)+) {\n+                #[inline]\n+                fn default() -> ($($T,)+) {\n+                    ($({ let x: $T = Default::default(); x},)+)\n+                }\n+            }\n+        )+\n+    }\n+}\"#,\n+        );\n+\n+        assert_expansion(\n+            &rules,\n+            r#\"tuple_impls ! { \n+    Tuple1   { \n+         ( 0 )   ->   A \n+     } \n+     Tuple2   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+     } \n+     Tuple3   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+     } \n+     Tuple4   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+     } \n+     Tuple5   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+     } \n+     Tuple6   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+     } \n+     Tuple7   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+         ( 6 )   ->   G \n+     } \n+     Tuple8   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+         ( 6 )   ->   G \n+         ( 7 )   ->   H \n+     } \n+     Tuple9   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+         ( 6 )   ->   G \n+         ( 7 )   ->   H \n+         ( 8 )   ->   I \n+     } \n+     Tuple10   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+         ( 6 )   ->   G \n+         ( 7 )   ->   H \n+         ( 8 )   ->   I \n+         ( 9 )   ->   J \n+     } \n+     Tuple11   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+         ( 6 )   ->   G \n+         ( 7 )   ->   H \n+         ( 8 )   ->   I \n+         ( 9 )   ->   J \n+         ( 10 )   ->   K \n+     } \n+     Tuple12   { \n+         ( 0 )   ->   A \n+         ( 1 )   ->   B \n+         ( 2 )   ->   C \n+         ( 3 )   ->   D \n+         ( 4 )   ->   E \n+         ( 5 )   ->   F \n+         ( 6 )   ->   G \n+         ( 7 )   ->   H \n+         ( 8 )   ->   I \n+         ( 9 )   ->   J \n+         ( 10 )   ->   K \n+         ( 11 )   ->   L \n+     } \n+}\"#,\n+            \"fn foo () {}\",\n+        );\n+    }\n }"}, {"sha": "91b6db522005ff674180b089fafb5e62ebfe37f6", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e4e2338f97d734624fb21b7972c73288ca04e65e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e2338f97d734624fb21b7972c73288ca04e65e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=e4e2338f97d734624fb21b7972c73288ca04e65e", "patch": "@@ -179,10 +179,10 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                         // Enable followiing code when everything is fixed\n                         // At least we can dogfood itself to not stackoverflow\n                         //\n-                        // \"tt\" => {\n-                        //     let token = input.eat().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                        //     res.inner.insert(text.clone(), Binding::Simple(token.into()));\n-                        // }\n+                        \"tt\" => {\n+                            let token = input.eat().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(token.into()));\n+                        }\n                         \"item\" => {\n                             let item =\n                                 input.eat_item().ok_or(ExpandError::UnexpectedToken)?.clone();\n@@ -226,18 +226,36 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                 // This should be replaced by a propper macro-by-example implementation\n                 let mut limit = 128;\n                 let mut counter = 0;\n-                while let Ok(nested) = match_lhs(subtree, input) {\n-                    counter += 1;\n-                    limit -= 1;\n-                    if limit == 0 {\n-                        break;\n-                    }\n-                    res.push_nested(nested)?;\n-                    if let Some(separator) = *separator {\n-                        if !input.is_eof() {\n-                            if input.eat_punct().map(|p| p.char) != Some(separator) {\n-                                return Err(ExpandError::UnexpectedToken);\n+\n+                let mut memento = input.save();\n+\n+                loop {\n+                    match match_lhs(subtree, input) {\n+                        Ok(nested) => {\n+                            counter += 1;\n+                            limit -= 1;\n+                            if limit == 0 {\n+                                break;\n                             }\n+\n+                            memento = input.save();\n+                            res.push_nested(nested)?;\n+                            if counter == 1 {\n+                                if let crate::RepeatKind::ZeroOrOne = kind {\n+                                    break;\n+                                }\n+                            }\n+\n+                            if let Some(separator) = *separator {\n+                                if input.eat_punct().map(|p| p.char) != Some(separator) {\n+                                    input.rollback(memento);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        Err(_) => {\n+                            input.rollback(memento);\n+                            break;\n                         }\n                     }\n                 }\n@@ -246,10 +264,6 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                     crate::RepeatKind::OneOrMore if counter == 0 => {\n                         return Err(ExpandError::UnexpectedToken);\n                     }\n-                    crate::RepeatKind::ZeroOrOne if counter > 1 => {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-\n                     _ => {}\n                 }\n             }\n@@ -333,10 +347,7 @@ fn expand_tt(\n                 }\n             }\n             nesting.pop().unwrap();\n-\n-            // Dirty hack for remove the last sep\n-            // if it is a \",\" undo the push\n-            if has_sep && repeat.separator.unwrap() == ',' {\n+            if has_sep {\n                 token_trees.pop();\n             }\n "}, {"sha": "87bcf8b0dce598c93dadde6ebe86ead1ea686847", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e4e2338f97d734624fb21b7972c73288ca04e65e/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e2338f97d734624fb21b7972c73288ca04e65e/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=e4e2338f97d734624fb21b7972c73288ca04e65e", "patch": "@@ -7,6 +7,10 @@ pub(crate) struct TtCursor<'a> {\n     pos: usize,\n }\n \n+pub(crate) struct TtCursorMemento {\n+    pos: usize,\n+}\n+\n impl<'a> TtCursor<'a> {\n     pub(crate) fn new(subtree: &'a tt::Subtree) -> TtCursor<'a> {\n         TtCursor { subtree, pos: 0 }\n@@ -157,4 +161,13 @@ impl<'a> TtCursor<'a> {\n             Err(ParseError::Expected(format!(\"`{}`\", char)))\n         }\n     }\n+\n+    #[must_use]\n+    pub(crate) fn save(&self) -> TtCursorMemento {\n+        TtCursorMemento { pos: self.pos }\n+    }\n+\n+    pub(crate) fn rollback(&mut self, memento: TtCursorMemento) {\n+        self.pos = memento.pos;\n+    }\n }"}]}