{"sha": "7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOWYyOWQzMDU4N2Y0NDkyYmZjNGFmNDkxZDJlN2I0ZDliOTMwZTk=", "commit": {"author": {"name": "Brian Cain", "email": "bcain@quicinc.com", "date": "2020-06-09T20:08:28Z"}, "committer": {"name": "Brian Cain", "email": "bcain@quicinc.com", "date": "2020-06-16T13:58:13Z"}, "message": "Add initial asm!() support for hexagon\n\nGPRs only", "tree": {"sha": "7ed8d2f57364ea630e8a34cb3a36bc2bff7bd50a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ed8d2f57364ea630e8a34cb3a36bc2bff7bd50a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "html_url": "https://github.com/rust-lang/rust/commit/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/comments", "author": {"login": "androm3da", "id": 8779799, "node_id": "MDQ6VXNlcjg3Nzk3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8779799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/androm3da", "html_url": "https://github.com/androm3da", "followers_url": "https://api.github.com/users/androm3da/followers", "following_url": "https://api.github.com/users/androm3da/following{/other_user}", "gists_url": "https://api.github.com/users/androm3da/gists{/gist_id}", "starred_url": "https://api.github.com/users/androm3da/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/androm3da/subscriptions", "organizations_url": "https://api.github.com/users/androm3da/orgs", "repos_url": "https://api.github.com/users/androm3da/repos", "events_url": "https://api.github.com/users/androm3da/events{/privacy}", "received_events_url": "https://api.github.com/users/androm3da/received_events", "type": "User", "site_admin": false}, "committer": {"login": "androm3da", "id": 8779799, "node_id": "MDQ6VXNlcjg3Nzk3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8779799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/androm3da", "html_url": "https://github.com/androm3da", "followers_url": "https://api.github.com/users/androm3da/followers", "following_url": "https://api.github.com/users/androm3da/following{/other_user}", "gists_url": "https://api.github.com/users/androm3da/gists{/gist_id}", "starred_url": "https://api.github.com/users/androm3da/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/androm3da/subscriptions", "organizations_url": "https://api.github.com/users/androm3da/orgs", "repos_url": "https://api.github.com/users/androm3da/repos", "events_url": "https://api.github.com/users/androm3da/events{/privacy}", "received_events_url": "https://api.github.com/users/androm3da/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb8674837a9cc5225020e07fc3f164762bb4c11c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8674837a9cc5225020e07fc3f164762bb4c11c", "html_url": "https://github.com/rust-lang/rust/commit/bb8674837a9cc5225020e07fc3f164762bb4c11c"}], "stats": {"total": 267, "additions": 264, "deletions": 3}, "files": [{"sha": "f4220dcd7c1007967e13cab871ccf37ff07604a1", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "patch": "@@ -374,7 +374,7 @@ options := \"options(\" option *[\",\" option] [\",\"] \")\"\n asm := \"asm!(\" format_string *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n ```\n \n-The macro will initially be supported only on ARM, AArch64, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+The macro will initially be supported only on ARM, AArch64, Hexagon, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n [format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n \n@@ -386,7 +386,7 @@ As with format strings, named arguments must appear after positional arguments.\n \n The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n \n-The 4 targets specified in this RFC (x86, ARM, AArch64, RISC-V) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n+The 5 targets specified in this RFC (x86, ARM, AArch64, RISC-V, Hexagon) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n \n [rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795\n \n@@ -473,6 +473,7 @@ Here is the list of currently supported register classes:\n | NVPTX | `reg64` | None\\* | `l` |\n | RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n | RISC-V | `freg` | `f[0-31]` | `f` |\n+| Hexagon | `reg` | `r[0-28]` | `r` |\n \n > **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n >\n@@ -507,6 +508,7 @@ Each register class has constraints on which value types they can be used with.\n | RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V | `freg` | `f` | `f32` |\n | RISC-V | `freg` | `d` | `f64` |\n+| Hexagon | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n \n > **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n \n@@ -563,13 +565,16 @@ Some registers have multiple names. These are all treated by the compiler as ide\n | RISC-V | `f[10-17]` | `fa[0-7]` |\n | RISC-V | `f[18-27]` | `fs[2-11]` |\n | RISC-V | `f[28-31]` | `ft[8-11]` |\n+| Hexagon | `r29` | `sp` |\n+| Hexagon | `r30` | `fr` |\n+| Hexagon | `r31` | `lr` |\n \n Some registers cannot be used for input or output operands:\n \n | Architecture | Unsupported register | Reason |\n | ------------ | -------------------- | ------ |\n | All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n-| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V) | The frame pointer cannot be used as an input or output. |\n+| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V), `fr` (Hexagon) | The frame pointer cannot be used as an input or output. |\n | x86 | `k0` | This is a constant zero register which can't be modified. |\n | x86 | `ip` | This is the program counter, not a real register. |\n | x86 | `mm[0-7]` | MMX registers are not currently supported (but may be in the future). |\n@@ -578,6 +583,7 @@ Some registers cannot be used for input or output operands:\n | ARM | `pc` | This is the program counter, not a real register. |\n | RISC-V | `x0` | This is a constant zero register which can't be modified. |\n | RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n+| Hexagon | `lr` | This is the link register which cannot be used as an input or output. |\n \n ## Template modifiers\n \n@@ -623,6 +629,7 @@ The supported modifiers are a subset of LLVM's (and GCC's) [asm template argumen\n | NVPTX | `reg64` | None | `rd0` | None |\n | RISC-V | `reg` | None | `x1` | None |\n | RISC-V | `freg` | None | `f0` | None |\n+| Hexagon | `reg` | None | `r0` | None |\n \n > Notes:\n > - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register."}, {"sha": "2f9e49591c3811f45195ade7e7caccac3905e5b7", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "patch": "@@ -255,6 +255,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n                 InlineAsmArch::Nvptx64 => {}\n+                InlineAsmArch::Hexagon => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -427,6 +428,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n@@ -472,6 +474,7 @@ fn modifier_to_llvm(\n                 modifier\n             }\n         }\n+        InlineAsmRegClass::Hexagon(_) => None,\n         InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n@@ -523,6 +526,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             cx.type_vector(cx.type_i64(), 2)\n         }\n+        InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),"}, {"sha": "d41941d0b4cd7fe2710d7dda1c5c414a147824be", "filename": "src/librustc_target/asm/hexagon.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Flibrustc_target%2Fasm%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Flibrustc_target%2Fasm%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fhexagon.rs?ref=7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "patch": "@@ -0,0 +1,93 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Hexagon HexagonInlineAsmRegClass {\n+        reg,\n+    }\n+}\n+\n+impl HexagonInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => types! { _: I8, I16, I32, F32; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    Hexagon HexagonInlineAsmReg HexagonInlineAsmRegClass {\n+        r0: reg = [\"r0\"],\n+        r1: reg = [\"r1\"],\n+        r2: reg = [\"r2\"],\n+        r3: reg = [\"r3\"],\n+        r4: reg = [\"r4\"],\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        r10: reg = [\"r10\"],\n+        r11: reg = [\"r11\"],\n+        r12: reg = [\"r12\"],\n+        r13: reg = [\"r13\"],\n+        r14: reg = [\"r14\"],\n+        r15: reg = [\"r15\"],\n+        r16: reg = [\"r16\"],\n+        r17: reg = [\"r17\"],\n+        r18: reg = [\"r18\"],\n+        r19: reg = [\"r19\"],\n+        r20: reg = [\"r20\"],\n+        r21: reg = [\"r21\"],\n+        r22: reg = [\"r22\"],\n+        r23: reg = [\"r23\"],\n+        r24: reg = [\"r24\"],\n+        r25: reg = [\"r25\"],\n+        r26: reg = [\"r26\"],\n+        r27: reg = [\"r27\"],\n+        r28: reg = [\"r28\"],\n+        #error = [\"r29\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r30\", \"fr\"] =>\n+            \"the frame register cannot be used as an operand for inline asm\",\n+        #error = [\"r31\", \"lr\"] =>\n+            \"the link register cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl HexagonInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+\n+    pub fn overlapping_regs(self, mut _cb: impl FnMut(HexagonInlineAsmReg)) {}\n+}"}, {"sha": "834d7c6d381a3b8250d155fd780cad9e755f70db", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "patch": "@@ -148,12 +148,14 @@ macro_rules! types {\n \n mod aarch64;\n mod arm;\n+mod hexagon;\n mod nvptx;\n mod riscv;\n mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n@@ -167,6 +169,7 @@ pub enum InlineAsmArch {\n     RiscV32,\n     RiscV64,\n     Nvptx64,\n+    Hexagon,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -181,6 +184,7 @@ impl FromStr for InlineAsmArch {\n             \"riscv32\" => Ok(Self::RiscV32),\n             \"riscv64\" => Ok(Self::RiscV64),\n             \"nvptx64\" => Ok(Self::Nvptx64),\n+            \"hexagon\" => Ok(Self::Hexagon),\n             _ => Err(()),\n         }\n     }\n@@ -203,6 +207,7 @@ pub enum InlineAsmReg {\n     AArch64(AArch64InlineAsmReg),\n     RiscV(RiscVInlineAsmReg),\n     Nvptx(NvptxInlineAsmReg),\n+    Hexagon(HexagonInlineAsmReg),\n }\n \n impl InlineAsmReg {\n@@ -212,6 +217,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => r.name(),\n             Self::AArch64(r) => r.name(),\n             Self::RiscV(r) => r.name(),\n+            Self::Hexagon(r) => r.name(),\n         }\n     }\n \n@@ -221,6 +227,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => InlineAsmRegClass::Arm(r.reg_class()),\n             Self::AArch64(r) => InlineAsmRegClass::AArch64(r.reg_class()),\n             Self::RiscV(r) => InlineAsmRegClass::RiscV(r.reg_class()),\n+            Self::Hexagon(r) => InlineAsmRegClass::Hexagon(r.reg_class()),\n         }\n     }\n \n@@ -246,6 +253,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Nvptx64 => {\n                 Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, &name)?)\n             }\n+            InlineAsmArch::Hexagon => {\n+                Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, &name)?)\n+            }\n         })\n     }\n \n@@ -262,6 +272,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => r.emit(out, arch, modifier),\n             Self::AArch64(r) => r.emit(out, arch, modifier),\n             Self::RiscV(r) => r.emit(out, arch, modifier),\n+            Self::Hexagon(r) => r.emit(out, arch, modifier),\n         }\n     }\n \n@@ -271,6 +282,7 @@ impl InlineAsmReg {\n             Self::Arm(r) => r.overlapping_regs(|r| cb(Self::Arm(r))),\n             Self::AArch64(_) => cb(self),\n             Self::RiscV(_) => cb(self),\n+            Self::Hexagon(r) => r.overlapping_regs(|r| cb(Self::Hexagon(r))),\n         }\n     }\n }\n@@ -292,6 +304,7 @@ pub enum InlineAsmRegClass {\n     AArch64(AArch64InlineAsmRegClass),\n     RiscV(RiscVInlineAsmRegClass),\n     Nvptx(NvptxInlineAsmRegClass),\n+    Hexagon(HexagonInlineAsmRegClass),\n }\n \n impl InlineAsmRegClass {\n@@ -302,6 +315,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.name(),\n             Self::RiscV(r) => r.name(),\n             Self::Nvptx(r) => r.name(),\n+            Self::Hexagon(r) => r.name(),\n         }\n     }\n \n@@ -315,6 +329,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::AArch64),\n             Self::RiscV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::RiscV),\n             Self::Nvptx(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Nvptx),\n+            Self::Hexagon(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Hexagon),\n         }\n     }\n \n@@ -335,6 +350,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.suggest_modifier(arch, ty),\n             Self::RiscV(r) => r.suggest_modifier(arch, ty),\n             Self::Nvptx(r) => r.suggest_modifier(arch, ty),\n+            Self::Hexagon(r) => r.suggest_modifier(arch, ty),\n         }\n     }\n \n@@ -351,6 +367,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.default_modifier(arch),\n             Self::RiscV(r) => r.default_modifier(arch),\n             Self::Nvptx(r) => r.default_modifier(arch),\n+            Self::Hexagon(r) => r.default_modifier(arch),\n         }\n     }\n \n@@ -366,6 +383,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.supported_types(arch),\n             Self::RiscV(r) => r.supported_types(arch),\n             Self::Nvptx(r) => r.supported_types(arch),\n+            Self::Hexagon(r) => r.supported_types(arch),\n         }\n     }\n \n@@ -384,6 +402,9 @@ impl InlineAsmRegClass {\n                     Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n                 }\n                 InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n+                InlineAsmArch::Hexagon => {\n+                    Self::Hexagon(HexagonInlineAsmRegClass::parse(arch, name)?)\n+                }\n             })\n         })\n     }\n@@ -397,6 +418,7 @@ impl InlineAsmRegClass {\n             Self::AArch64(r) => r.valid_modifiers(arch),\n             Self::RiscV(r) => r.valid_modifiers(arch),\n             Self::Nvptx(r) => r.valid_modifiers(arch),\n+            Self::Hexagon(r) => r.valid_modifiers(arch),\n         }\n     }\n }\n@@ -541,5 +563,10 @@ pub fn allocatable_registers(\n             nvptx::fill_reg_map(arch, has_feature, &mut map);\n             map\n         }\n+        InlineAsmArch::Hexagon => {\n+            let mut map = hexagon::regclass_map();\n+            hexagon::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "ba2d8a363cd4eccd27df9c97ead98d048f45d9ed", "filename": "src/test/assembly/asm/hexagon-types.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9f29d30587f4492bfc4af491d2e7b4d9b930e9/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fhexagon-types.rs?ref=7a9f29d30587f4492bfc4af491d2e7b4d9b930e9", "patch": "@@ -0,0 +1,130 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: --target hexagon-unknown-linux-musl\n+\n+#![feature(no_core, lang_items, rustc_attrs, repr_simd)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(asm_sub_register, non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! stringify {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const i32;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for ptr {}\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: u8;\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            // Hack to avoid function merging\n+            extern \"Rust\" {\n+                fn dont_merge(s: &str);\n+            }\n+            dont_merge(stringify!($func));\n+\n+            let y;\n+            asm!(\"{} = {}\", out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: sym_static:\n+// CHECK: InlineAsm Start\n+// CHECK: r0 = #extern_static\n+// CHECK: InlineAsm End\n+#[no_mangle]\n+pub unsafe fn sym_static() {\n+    // Hack to avoid function merging\n+    extern \"Rust\" {\n+        fn dont_merge(s: &str);\n+    }\n+    dont_merge(stringify!($func));\n+\n+    asm!(\"r0 = #{}\", sym extern_static);\n+}\n+\n+// CHECK-LABEL: sym_fn:\n+// CHECK: InlineAsm Start\n+// CHECK: r0 = #extern_func\n+// CHECK: InlineAsm End\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    // Hack to avoid function merging\n+    extern \"Rust\" {\n+        fn dont_merge(s: &str);\n+    }\n+    dont_merge(stringify!($func));\n+\n+    asm!(\"r0 = #{}\", sym extern_func);\n+}\n+\n+// This is a test for multi-instruction packets,\n+// which require the escaped braces.\n+//\n+// CHECK-LABEL: packet:\n+// CHECK: InlineAsm Start\n+// CHECK: {\n+// CHECK:   r{{[0-9]+}} = r0\n+// CHECK:   memw(r1) = r{{[0-9]+}}\n+// CHECK: }\n+// CHECK: InlineAsm End\n+#[no_mangle]\n+pub unsafe fn packet() {\n+    let val = 1024;\n+    asm!(\"{{\n+        {} = r0\n+        memw(r1) = {}\n+    }}\", out(reg) _, in(reg) &val);\n+}\n+\n+// CHECK-LABEL: ptr:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_ptr ptr reg);\n+\n+// CHECK-LABEL: reg_f32:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_f32 f32 reg);\n+\n+// CHECK-LABEL: reg_i32:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_i32 i32 reg);\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_i8 i8 reg);\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: InlineAsm Start\n+// CHECK: r{{[0-9]+}} = r{{[0-9]+}}\n+// CHECK: InlineAsm End\n+check!(reg_i16 i16 reg);"}]}