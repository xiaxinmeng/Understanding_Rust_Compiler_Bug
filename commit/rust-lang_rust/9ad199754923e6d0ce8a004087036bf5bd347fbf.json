{"sha": "9ad199754923e6d0ce8a004087036bf5bd347fbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZDE5OTc1NDkyM2U2ZDBjZThhMDA0MDg3MDM2YmY1YmQzNDdmYmY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-11T18:29:33Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:57Z"}, "message": "Change the HOF context switchers to pass a BlockedTask instead of a ~Task.", "tree": {"sha": "8be4273c3a051201dfa6f16e990cd187ec2cf49e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8be4273c3a051201dfa6f16e990cd187ec2cf49e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad199754923e6d0ce8a004087036bf5bd347fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad199754923e6d0ce8a004087036bf5bd347fbf", "html_url": "https://github.com/rust-lang/rust/commit/9ad199754923e6d0ce8a004087036bf5bd347fbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad199754923e6d0ce8a004087036bf5bd347fbf/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0101f35f276d0ef1ab841a179d01d0c66a18b38a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0101f35f276d0ef1ab841a179d01d0c66a18b38a", "html_url": "https://github.com/rust-lang/rust/commit/0101f35f276d0ef1ab841a179d01d0c66a18b38a"}], "stats": {"total": 162, "additions": 102, "deletions": 60}, "files": [{"sha": "46c99d21d9d0cda7890f017cb974eb0a2324b35f", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -19,7 +19,7 @@ use option::*;\n use cast;\n use util;\n use ops::Drop;\n-use rt::task::Task;\n+use rt::kill::BlockedTask;\n use kinds::Send;\n use rt::sched::Scheduler;\n use rt::local::Local;\n@@ -30,13 +30,13 @@ use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n use clone::Clone;\n \n-/// A combined refcount / ~Task pointer.\n+/// A combined refcount / BlockedTask-as-uint pointer.\n ///\n /// Can be equal to the following values:\n ///\n /// * 2 - both endpoints are alive\n /// * 1 - either the sender or the receiver is dead, determined by context\n-/// * <ptr> - A pointer to a blocked Task that can be transmuted to ~Task\n+/// * <ptr> - A pointer to a blocked Task (see BlockedTask::cast_{to,from}_uint)\n type State = uint;\n \n static STATE_BOTH: State = 2;\n@@ -137,11 +137,13 @@ impl<T> ChanOne<T> {\n                 }\n                 task_as_state => {\n                     // Port is blocked. Wake it up.\n-                    let recvr: ~Task = cast::transmute(task_as_state);\n-                    let mut sched = Local::take::<Scheduler>();\n-                    rtdebug!(\"rendezvous send\");\n-                    sched.metrics.rendezvous_sends += 1;\n-                    sched.schedule_task(recvr);\n+                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n+                    do recvr.wake().map_consume |woken_task| {\n+                        let mut sched = Local::take::<Scheduler>();\n+                        rtdebug!(\"rendezvous send\");\n+                        sched.metrics.rendezvous_sends += 1;\n+                        sched.schedule_task(woken_task);\n+                    };\n                 }\n             }\n         }\n@@ -177,7 +179,7 @@ impl<T> PortOne<T> {\n                 // an acquire barrier to prevent reordering of the subsequent read\n                 // of the payload. Also issues a release barrier to prevent reordering\n                 // of any previous writes to the task structure.\n-                let task_as_state: State = cast::transmute(task);\n+                let task_as_state = task.cast_to_uint();\n                 let oldstate = (*packet).state.swap(task_as_state, SeqCst);\n                 match oldstate {\n                     STATE_BOTH => {\n@@ -193,8 +195,8 @@ impl<T> PortOne<T> {\n                         // NB: We have to drop back into the scheduler event loop here\n                         // instead of switching immediately back or we could end up\n                         // triggering infinite recursion on the scheduler's stack.\n-                        let task: ~Task = cast::transmute(task_as_state);\n-                        sched.enqueue_task(task);\n+                        let recvr = BlockedTask::cast_from_uint(task_as_state);\n+                        sched.enqueue_blocked_task(recvr);\n                     }\n                     _ => util::unreachable()\n                 }\n@@ -258,9 +260,11 @@ impl<T> Drop for ChanOneHack<T> {\n                 task_as_state => {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     assert!((*this.packet()).payload.is_none());\n-                    let recvr: ~Task = cast::transmute(task_as_state);\n-                    let sched = Local::take::<Scheduler>();\n-                    sched.schedule_task(recvr);\n+                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n+                    do recvr.wake().map_consume |woken_task| {\n+                        let sched = Local::take::<Scheduler>();\n+                        sched.schedule_task(woken_task);\n+                    };\n                 }\n             }\n         }"}, {"sha": "85537f476d4a10fc7af2c8d31494dac9709b22db", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -367,7 +367,7 @@ fn test_context() {\n             let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then() |sched, task| {\n                 assert_eq!(context(), SchedulerContext);\n-                sched.enqueue_task(task);\n+                sched.enqueue_blocked_task(task);\n             }\n         };\n         sched.enqueue_task(task);"}, {"sha": "d8d61806a5bba88501aff2c0df2add4543b435e5", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::*;\n+use either::{Left, Right};\n+use option::{Option, Some, None};\n use sys;\n use cast::transmute;\n use clone::Clone;\n@@ -20,6 +21,7 @@ use super::rtio::{EventLoop, EventLoopObject, RemoteCallbackObject};\n use super::context::Context;\n use super::task::{Task, AnySched, Sched};\n use super::message_queue::MessageQueue;\n+use rt::kill::BlockedTask;\n use rt::local_ptr;\n use rt::local::Local;\n use rt::rtio::RemoteCallback;\n@@ -271,6 +273,14 @@ impl Scheduler {\n         };\n     }\n \n+    /// As enqueue_task, but with the possibility for the blocked task to\n+    /// already have been killed.\n+    pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n+        do blocked_task.wake().map_consume |task| {\n+            self.enqueue_task(task);\n+        };\n+    }\n+\n     // * Scheduler-context operations\n \n     fn interpret_message_queue(~self) -> bool {\n@@ -412,14 +422,26 @@ impl Scheduler {\n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n     pub fn terminate_current_task(~self) {\n-        assert!(self.in_task_context());\n+        let mut this = self;\n+        assert!(this.in_task_context());\n \n         rtdebug!(\"ending running task\");\n \n-        do self.deschedule_running_task_and_then |sched, dead_task| {\n-            let mut dead_task = dead_task;\n-            let coroutine = dead_task.coroutine.take_unwrap();\n-            coroutine.recycle(&mut sched.stack_pool);\n+        // This task is post-cleanup, so it must be unkillable. This sequence\n+        // of descheduling and recycling must not get interrupted by a kill.\n+        // FIXME(#7544): Make this use an inner descheduler, like yield should.\n+        this.current_task.get_mut_ref().death.unkillable += 1;\n+\n+        do this.deschedule_running_task_and_then |sched, dead_task| {\n+            match dead_task.wake() {\n+                Some(dead_task) => {\n+                    let mut dead_task = dead_task;\n+                    dead_task.death.unkillable -= 1; // FIXME(#7544) ugh\n+                    let coroutine = dead_task.coroutine.take_unwrap();\n+                    coroutine.recycle(&mut sched.stack_pool);\n+                }\n+                None => rtabort!(\"dead task killed before recycle\"),\n+            }\n         }\n \n         rtabort!(\"control reached end of task\");\n@@ -440,7 +462,7 @@ impl Scheduler {\n             // here we know we are home, execute now OR we know we\n             // aren't homed, and that this sched doesn't care\n             do this.switch_running_tasks_and_then(task) |sched, last_task| {\n-                sched.enqueue_task(last_task);\n+                sched.enqueue_blocked_task(last_task);\n             }\n         } else if !homed && !this.run_anything {\n             // the task isn't homed, but it can't be run here\n@@ -491,6 +513,13 @@ impl Scheduler {\n         }\n     }\n \n+    pub fn resume_blocked_task_immediately(~self, blocked_task: BlockedTask) {\n+        match blocked_task.wake() {\n+            Some(task) => self.resume_task_immediately(task),\n+            None => Local::put(self),\n+        };\n+    }\n+\n     /// Block a running task, context switch to the scheduler, then pass the\n     /// blocked task to a closure.\n     ///\n@@ -503,7 +532,7 @@ impl Scheduler {\n     /// This passes a Scheduler pointer to the fn after the context switch\n     /// in order to prevent that fn from performing further scheduling operations.\n     /// Doing further scheduling could easily result in infinite recursion.\n-    pub fn deschedule_running_task_and_then(~self, f: &fn(&mut Scheduler, ~Task)) {\n+    pub fn deschedule_running_task_and_then(~self, f: &fn(&mut Scheduler, BlockedTask)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n@@ -512,8 +541,8 @@ impl Scheduler {\n \n         unsafe {\n             let blocked_task = this.current_task.take_unwrap();\n-            let f_fake_region = transmute::<&fn(&mut Scheduler, ~Task),\n-                                            &fn(&mut Scheduler, ~Task)>(f);\n+            let f_fake_region = transmute::<&fn(&mut Scheduler, BlockedTask),\n+                                            &fn(&mut Scheduler, BlockedTask)>(f);\n             let f_opaque = ClosureConverter::from_fn(f_fake_region);\n             this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n         }\n@@ -539,7 +568,7 @@ impl Scheduler {\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n-                                         f: &fn(&mut Scheduler, ~Task)) {\n+                                         f: &fn(&mut Scheduler, BlockedTask)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n@@ -548,8 +577,8 @@ impl Scheduler {\n \n         let old_running_task = this.current_task.take_unwrap();\n         let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, ~Task),\n-                        &fn(&mut Scheduler, ~Task)>(f)\n+            transmute::<&fn(&mut Scheduler, BlockedTask),\n+                        &fn(&mut Scheduler, BlockedTask)>(f)\n         };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n@@ -590,7 +619,15 @@ impl Scheduler {\n         let cleanup_job = self.cleanup_job.take_unwrap();\n         match cleanup_job {\n             DoNothing => { }\n-            GiveTask(task, f) => (f.to_fn())(self, task)\n+            GiveTask(task, f) => {\n+                let f = f.to_fn();\n+                // Task might need to receive a kill signal instead of blocking.\n+                // We can call the \"and_then\" only if it blocks successfully.\n+                match BlockedTask::try_block(task) {\n+                    Left(killed_task) => self.enqueue_task(killed_task),\n+                    Right(blocked_task) => f(self, blocked_task),\n+                }\n+            }\n         }\n     }\n \n@@ -663,12 +700,14 @@ impl SchedHandle {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n+    fn from_fn(&fn(&mut Scheduler, BlockedTask)) -> Self;\n+    fn to_fn(self) -> &fn(&mut Scheduler, BlockedTask);\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) { unsafe { transmute(self) } }\n+    fn from_fn(f: &fn(&mut Scheduler, BlockedTask)) -> UnsafeTaskReceiver {\n+        unsafe { transmute(f) }\n+    }\n+    fn to_fn(self) -> &fn(&mut Scheduler, BlockedTask) { unsafe { transmute(self) } }\n }\n \n \n@@ -928,8 +967,7 @@ mod test {\n                 };\n                 // Context switch directly to the new task\n                 do sched.switch_running_tasks_and_then(task2) |sched, task1| {\n-                    let task1 = Cell::new(task1);\n-                    sched.enqueue_task(task1.take());\n+                    sched.enqueue_blocked_task(task1);\n                 }\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             };\n@@ -980,9 +1018,8 @@ mod test {\n                 let sched = Local::take::<Scheduler>();\n                 assert!(sched.in_task_context());\n                 do sched.deschedule_running_task_and_then() |sched, task| {\n-                    let task = Cell::new(task);\n                     assert!(!sched.in_task_context());\n-                    sched.enqueue_task(task.take());\n+                    sched.enqueue_blocked_task(task);\n                 }\n             };\n             sched.enqueue_task(task);\n@@ -1004,7 +1041,7 @@ mod test {\n                     do sched.event_loop.callback_ms(10) {\n                         rtdebug!(\"in callback\");\n                         let mut sched = Local::take::<Scheduler>();\n-                        sched.enqueue_task(task.take());\n+                        sched.enqueue_blocked_task(task.take());\n                         Local::put(sched);\n                     }\n                 }"}, {"sha": "1562160550a4978e81a2a4ef5ca09eab4aa6da10", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -170,7 +170,7 @@ pub fn spawntask_immediately(f: ~fn()) {\n \n     let sched = Local::take::<Scheduler>();\n     do sched.switch_running_tasks_and_then(task) |sched, task| {\n-        sched.enqueue_task(task);\n+        sched.enqueue_blocked_task(task);\n     }\n }\n \n@@ -214,7 +214,7 @@ pub fn spawntask_random(f: ~fn()) {\n \n     if run_now {\n         do sched.switch_running_tasks_and_then(task) |sched, task| {\n-            sched.enqueue_task(task);\n+            sched.enqueue_blocked_task(task);\n         }\n     } else {\n         sched.enqueue_task(task);\n@@ -284,7 +284,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n \n     let sched = Local::take::<Scheduler>();\n     do sched.switch_running_tasks_and_then(new_task) |sched, old_task| {\n-        sched.enqueue_task(old_task);\n+        sched.enqueue_blocked_task(old_task);\n     }\n \n     rtdebug!(\"enqueued the new task, now waiting on exit_status\");"}, {"sha": "bc223d8f3f70d4bcdf4ac54e14353b45b648fc53", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -18,13 +18,13 @@ use clone::Clone;\n use super::rc::RC;\n use rt::sched::Scheduler;\n use rt::{context, TaskContext, SchedulerContext};\n+use rt::kill::BlockedTask;\n use rt::local::Local;\n-use rt::task::Task;\n use vec::OwnedVector;\n use container::Container;\n \n struct TubeState<T> {\n-    blocked_task: Option<~Task>,\n+    blocked_task: Option<BlockedTask>,\n     buf: ~[T]\n }\n \n@@ -55,7 +55,7 @@ impl<T> Tube<T> {\n                 rtdebug!(\"waking blocked tube\");\n                 let task = (*state).blocked_task.take_unwrap();\n                 let sched = Local::take::<Scheduler>();\n-                sched.resume_task_immediately(task);\n+                sched.resume_blocked_task_immediately(task);\n             }\n         }\n     }\n@@ -111,7 +111,7 @@ mod test {\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n-                sched.enqueue_task(task);\n+                sched.enqueue_blocked_task(task);\n             }\n \n             assert!(tube.recv() == 1);\n@@ -133,7 +133,7 @@ mod test {\n                     // sending will wake it up.\n                     tube_clone.send(1);\n                 }\n-                sched.enqueue_task(task);\n+                sched.enqueue_blocked_task(task);\n             }\n \n             assert!(tube.recv() == 1);\n@@ -168,7 +168,7 @@ mod test {\n                     }\n                 }\n \n-                sched.enqueue_task(task);\n+                sched.enqueue_blocked_task(task);\n             }\n \n             for int::range(0, MAX) |i| {"}, {"sha": "7046afe855133a53850772bd3da836546a39a166", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -227,15 +227,15 @@ impl IoFactory for UvIoFactory {\n \n                     // Context switch\n                     let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_task_immediately(task_cell.take());\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n                 } else {\n                     rtdebug!(\"status is some\");\n                     let task_cell = Cell::new(task_cell.take());\n                     do stream_watcher.close {\n                         let res = Err(uv_error_to_io_error(status.get()));\n                         unsafe { (*result_cell_ptr).put_back(res); }\n                         let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_task_immediately(task_cell.take());\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n                 };\n             }\n@@ -255,7 +255,7 @@ impl IoFactory for UvIoFactory {\n                     let task_cell = Cell::new(task);\n                     do watcher.as_stream().close {\n                         let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_task_immediately(task_cell.take());\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n                 }\n                 Err(uv_error_to_io_error(uverr))\n@@ -273,7 +273,7 @@ impl IoFactory for UvIoFactory {\n                     let task_cell = Cell::new(task);\n                     do watcher.close {\n                         let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_task_immediately(task_cell.take());\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n                 }\n                 Err(uv_error_to_io_error(uverr))\n@@ -309,7 +309,7 @@ impl Drop for UvTcpListener {\n             let task_cell = Cell::new(task);\n             do watcher.as_stream().close {\n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n@@ -372,7 +372,7 @@ impl Drop for UvTcpStream {\n             let task_cell = Cell::new(task);\n             do self.close {\n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n@@ -419,7 +419,7 @@ impl RtioTcpStream for UvTcpStream {\n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -447,7 +447,7 @@ impl RtioTcpStream for UvTcpStream {\n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -473,7 +473,7 @@ impl Drop for UvUdpSocket {\n             let task_cell = Cell::new(task);\n             do self.close {\n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n@@ -513,7 +513,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -540,7 +540,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n                 let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_task_immediately(task_cell.take());\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -678,7 +678,7 @@ fn test_read_and_block() {\n                 // not ready for it\n                 do scheduler.deschedule_running_task_and_then |sched, task| {\n                     let task = Cell::new(task);\n-                    sched.enqueue_task(task.take());\n+                    sched.enqueue_blocked_task(task.take());\n                 }\n             }\n "}, {"sha": "11e2b99d7c0e3b47e29a66e4633e5f20cb46b316", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad199754923e6d0ce8a004087036bf5bd347fbf/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=9ad199754923e6d0ce8a004087036bf5bd347fbf", "patch": "@@ -515,9 +515,10 @@ pub fn yield() {\n             }\n             _ => {\n                 // XXX: What does yield really mean in newsched?\n+                // FIXME(#7544): Optimize this, since we know we won't block.\n                 let sched = Local::take::<Scheduler>();\n                 do sched.deschedule_running_task_and_then |sched, task| {\n-                    sched.enqueue_task(task);\n+                    sched.enqueue_blocked_task(task);\n                 }\n             }\n         }"}]}