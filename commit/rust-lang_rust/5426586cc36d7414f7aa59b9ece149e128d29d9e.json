{"sha": "5426586cc36d7414f7aa59b9ece149e128d29d9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MjY1ODZjYzM2ZDc0MTRmN2FhNTliOWVjZTE0OWUxMjhkMjlkOWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-23T01:16:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-23T01:16:19Z"}, "message": "Rollup merge of #73495 - Lucretiel:wasi-io-impls, r=sfackler\n\nConverted all platform-specific stdin/stdout/stderr implementations to use io:: traits\n\nCurrently, some of the platform-specific standard streams (`src/libstd/sys/*/stdio.rs`) manually implement parts of the `io::Write` interface directly as methods on the struct, rather than by actually implementing the trait. There doesn't seem to be any reason for this, other than an unused advantage of `fn write(&self, ...)` instead of `fn write(&mut self, ...)`.\n\nUnfortunately, this means that those implementations don't have the default-implemented io methods, like `read_exact` and `write_all`. This caused #72705, which adds forwarding methods to the user-facing standard stream implementations, to fail to compile on those platforms.\n\nThis change converts *all* such standard stream structs to use the standard library traits. This change should not cause any breakages, because the changed types are not publicly exported, and in fact are only ever used in `src/libstd/io/stdio.rs`.", "tree": {"sha": "8fd85d4c451b0a15edfd21f2d75320aedb7c7a50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fd85d4c451b0a15edfd21f2d75320aedb7c7a50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5426586cc36d7414f7aa59b9ece149e128d29d9e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe8VfjCRBK7hj4Ov3rIwAAdHIIAAFaAkeZsZWvFrgmZ0A0Lyp5\nDuGadNNdqsAhHP3RmLgQDGM2fkdMNpHJTIYI4F0Z90zXqnc7+puClYlPWpWh3Dpw\nFZxR1rccRBstWO/qr3MjYL/FwhJesWBycpXjnOQAiwjNi26PdYy1Cc6ZBLj88fGf\nJU8a9GzFZK1BizpvNMf34kBDg2eA4BVqzKlL7uWuZT3X834RbrHO7qVrbbbQo8Xi\nTOVgOm3/Nocodl0v+307zG/QB5qUnAr5AnsrauH3EfSS+kQqXD4ubbswL9kk26DQ\ncELlSgY/Cu3/65H6LW/PG5Ik3ZAyUTgyiUNQqEKijHZTMGsz77BJK4r2oPagcMA=\n=hu3t\n-----END PGP SIGNATURE-----\n", "payload": "tree 8fd85d4c451b0a15edfd21f2d75320aedb7c7a50\nparent 6276c135d185e8492e8a2b9db5ca04e51c3293fa\nparent 0094f44a0b54d6ac92f3feaa939d6a3d48cb7475\nauthor Dylan DPC <dylan.dpc@gmail.com> 1592874979 +0200\ncommitter GitHub <noreply@github.com> 1592874979 +0200\n\nRollup merge of #73495 - Lucretiel:wasi-io-impls, r=sfackler\n\nConverted all platform-specific stdin/stdout/stderr implementations to use io:: traits\n\nCurrently, some of the platform-specific standard streams (`src/libstd/sys/*/stdio.rs`) manually implement parts of the `io::Write` interface directly as methods on the struct, rather than by actually implementing the trait. There doesn't seem to be any reason for this, other than an unused advantage of `fn write(&self, ...)` instead of `fn write(&mut self, ...)`.\n\nUnfortunately, this means that those implementations don't have the default-implemented io methods, like `read_exact` and `write_all`. This caused #72705, which adds forwarding methods to the user-facing standard stream implementations, to fail to compile on those platforms.\n\nThis change converts *all* such standard stream structs to use the standard library traits. This change should not cause any breakages, because the changed types are not publicly exported, and in fact are only ever used in `src/libstd/io/stdio.rs`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5426586cc36d7414f7aa59b9ece149e128d29d9e", "html_url": "https://github.com/rust-lang/rust/commit/5426586cc36d7414f7aa59b9ece149e128d29d9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5426586cc36d7414f7aa59b9ece149e128d29d9e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6276c135d185e8492e8a2b9db5ca04e51c3293fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6276c135d185e8492e8a2b9db5ca04e51c3293fa", "html_url": "https://github.com/rust-lang/rust/commit/6276c135d185e8492e8a2b9db5ca04e51c3293fa"}, {"sha": "0094f44a0b54d6ac92f3feaa939d6a3d48cb7475", "url": "https://api.github.com/repos/rust-lang/rust/commits/0094f44a0b54d6ac92f3feaa939d6a3d48cb7475", "html_url": "https://github.com/rust-lang/rust/commit/0094f44a0b54d6ac92f3feaa939d6a3d48cb7475"}], "stats": {"total": 105, "additions": 49, "deletions": 56}, "files": [{"sha": "f3654ee38716c7c54ab09e65f0230606465ba556", "filename": "src/libstd/sys/hermit/stdio.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5426586cc36d7414f7aa59b9ece149e128d29d9e/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5426586cc36d7414f7aa59b9ece149e128d29d9e/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs?ref=5426586cc36d7414f7aa59b9ece149e128d29d9e", "patch": "@@ -10,19 +10,19 @@ impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n         Ok(Stdin)\n     }\n+}\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+impl io::Read for Stdin {\n+    fn read(&mut self, data: &mut [u8]) -> io::Result<usize> {\n         self.read_vectored(&mut [IoSliceMut::new(data)])\n     }\n \n-    pub fn read_vectored(&self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        //ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n-        //    .read(data)\n+    fn read_vectored(&mut self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         Ok(0)\n     }\n \n     #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n+    fn is_read_vectored(&self) -> bool {\n         true\n     }\n }\n@@ -31,8 +31,10 @@ impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout)\n     }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stdout {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let len;\n \n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n@@ -44,7 +46,7 @@ impl Stdout {\n         }\n     }\n \n-    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         let len;\n \n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n@@ -57,11 +59,11 @@ impl Stdout {\n     }\n \n     #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n+    fn is_write_vectored(&self) -> bool {\n         true\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -70,8 +72,10 @@ impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n         Ok(Stderr)\n     }\n+}\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let len;\n \n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n@@ -83,7 +87,7 @@ impl Stderr {\n         }\n     }\n \n-    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         let len;\n \n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n@@ -96,21 +100,12 @@ impl Stderr {\n     }\n \n     #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n+    fn is_write_vectored(&self) -> bool {\n         true\n     }\n \n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl io::Write for Stderr {\n-    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        (&*self).write(data)\n-    }\n     fn flush(&mut self) -> io::Result<()> {\n-        (&*self).flush()\n+        Ok(())\n     }\n }\n "}, {"sha": "78e3911dc4efea33e1edc322a40e54ab7856e2bb", "filename": "src/libstd/sys/wasi/stdio.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5426586cc36d7414f7aa59b9ece149e128d29d9e/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5426586cc36d7414f7aa59b9ece149e128d29d9e/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs?ref=5426586cc36d7414f7aa59b9ece149e128d29d9e", "patch": "@@ -11,85 +11,83 @@ impl Stdin {\n         Ok(Stdin)\n     }\n \n-    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+    #[inline]\n+    pub fn as_raw_fd(&self) -> u32 {\n+        0\n+    }\n+}\n+\n+impl io::Read for Stdin {\n+    fn read(&mut self, data: &mut [u8]) -> io::Result<usize> {\n         self.read_vectored(&mut [IoSliceMut::new(data)])\n     }\n \n-    pub fn read_vectored(&self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+    fn read_vectored(&mut self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).read(data)\n     }\n \n     #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n+    fn is_read_vectored(&self) -> bool {\n         true\n     }\n-\n-    pub fn as_raw_fd(&self) -> u32 {\n-        0\n-    }\n }\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout)\n     }\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+    #[inline]\n+    pub fn as_raw_fd(&self) -> u32 {\n+        1\n+    }\n+}\n+\n+impl io::Write for Stdout {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         self.write_vectored(&[IoSlice::new(data)])\n     }\n \n-    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n         ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n     }\n \n     #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n+    fn is_write_vectored(&self) -> bool {\n         true\n     }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         Ok(())\n     }\n-\n-    pub fn as_raw_fd(&self) -> u32 {\n-        1\n-    }\n }\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n         Ok(Stderr)\n     }\n \n-    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        self.write_vectored(&[IoSlice::new(data)])\n-    }\n-\n-    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n-    }\n-\n     #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n     pub fn as_raw_fd(&self) -> u32 {\n         2\n     }\n }\n \n impl io::Write for Stderr {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-        (&*self).write(data)\n+        self.write_vectored(&[IoSlice::new(data)])\n+    }\n+\n+    fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        (&*self).flush()\n+        Ok(())\n     }\n }\n "}]}