{"sha": "0c89243fd33a7f9f0ef4ddc9796047c646e9a688", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjODkyNDNmZDMzYTdmOWYwZWY0ZGRjOTc5NjA0N2M2NDZlOWE2ODg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-09-07T07:27:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-09-07T15:17:02Z"}, "message": "Fix compiling some rustc crates to wasm\n\nI was dabbling recently seeing what it would take to compile `rustfmt` to the\n`wasm32-unknown-unknown` target and it turns out not much effort is needed!\nCurrently `rustfmt` depends on a few rustc crates published to crates.io, so\nthis commit touches up those crates to compile for wasm themselves. Notably:\n\n* The `rustc_data_structures` crate's `flock` implementation is stubbed out to\n  unconditionally return errors on unsupported platforms.\n* The `rustc_errors` crate is extended to not do any locking for all non-windows\n  platforms.\n\nIn both of these cases if we port the compiler to new platforms the\nfunctionality isn't critical but will be discovered over time as it comes up, so\nthis hopefully doesn't make it too too hard to compile to new platforms!", "tree": {"sha": "8287128376df17143b84e371359b433ef967a1e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8287128376df17143b84e371359b433ef967a1e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c89243fd33a7f9f0ef4ddc9796047c646e9a688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c89243fd33a7f9f0ef4ddc9796047c646e9a688", "html_url": "https://github.com/rust-lang/rust/commit/0c89243fd33a7f9f0ef4ddc9796047c646e9a688", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c89243fd33a7f9f0ef4ddc9796047c646e9a688/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ae11a9c22bc3d1f36d1e964cbfc4522a0e9351e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ae11a9c22bc3d1f36d1e964cbfc4522a0e9351e", "html_url": "https://github.com/rust-lang/rust/commit/2ae11a9c22bc3d1f36d1e964cbfc4522a0e9351e"}], "stats": {"total": 592, "additions": 299, "deletions": 293}, "files": [{"sha": "38ce331051fecc81b029a2bd460a0406963e8644", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 298, "deletions": 292, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/0c89243fd33a7f9f0ef4ddc9796047c646e9a688/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c89243fd33a7f9f0ef4ddc9796047c646e9a688/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=0c89243fd33a7f9f0ef4ddc9796047c646e9a688", "patch": "@@ -15,345 +15,351 @@\n //! librustdoc, it is not production quality at all.\n \n #![allow(non_camel_case_types)]\n-use std::path::Path;\n-\n-pub use self::imp::Lock;\n+#![allow(nonstandard_style)]\n \n-#[cfg(unix)]\n-mod imp {\n-    use std::ffi::{CString, OsStr};\n-    use std::os::unix::prelude::*;\n-    use std::path::Path;\n-    use std::io;\n-    use libc;\n+use std::io;\n+use std::path::Path;\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    mod os {\n+cfg_if! {\n+    if #[cfg(unix)] {\n+        use std::ffi::{CString, OsStr};\n+        use std::os::unix::prelude::*;\n         use libc;\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n-        }\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        mod os {\n+            use libc;\n \n-        pub const F_RDLCK: libc::c_short = 0;\n-        pub const F_WRLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_SETLK: libc::c_int = 6;\n-        pub const F_SETLKW: libc::c_int = 7;\n-    }\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n \n-    #[cfg(target_os = \"freebsd\")]\n-    mod os {\n-        use libc;\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_sysid: libc::c_int,\n+            pub const F_RDLCK: libc::c_short = 0;\n+            pub const F_WRLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_SETLK: libc::c_int = 6;\n+            pub const F_SETLKW: libc::c_int = 7;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_WRLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 12;\n-        pub const F_SETLKW: libc::c_int = 13;\n-    }\n-\n-    #[cfg(any(target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\"))]\n-    mod os {\n-        use libc;\n+        #[cfg(target_os = \"freebsd\")]\n+        mod os {\n+            use libc;\n+\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_sysid: libc::c_int,\n+            }\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_WRLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 12;\n+            pub const F_SETLKW: libc::c_int = 13;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_WRLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 8;\n-        pub const F_SETLKW: libc::c_int = 9;\n-    }\n-\n-    #[cfg(target_os = \"haiku\")]\n-    mod os {\n-        use libc;\n+        #[cfg(any(target_os = \"dragonfly\",\n+                  target_os = \"bitrig\",\n+                  target_os = \"netbsd\",\n+                  target_os = \"openbsd\"))]\n+        mod os {\n+            use libc;\n+\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_WRLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 8;\n+            pub const F_SETLKW: libc::c_int = 9;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 0x0040;\n-        pub const F_UNLCK: libc::c_short = 0x0200;\n-        pub const F_WRLCK: libc::c_short = 0x0400;\n-        pub const F_SETLK: libc::c_int = 0x0080;\n-        pub const F_SETLKW: libc::c_int = 0x0100;\n-    }\n+        #[cfg(target_os = \"haiku\")]\n+        mod os {\n+            use libc;\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    mod os {\n-        use libc;\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n+\n+            pub const F_RDLCK: libc::c_short = 0x0040;\n+            pub const F_UNLCK: libc::c_short = 0x0200;\n+            pub const F_WRLCK: libc::c_short = 0x0400;\n+            pub const F_SETLK: libc::c_int = 0x0080;\n+            pub const F_SETLKW: libc::c_int = 0x0100;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_WRLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 8;\n-        pub const F_SETLKW: libc::c_int = 9;\n-    }\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        mod os {\n+            use libc;\n \n-    #[cfg(target_os = \"solaris\")]\n-    mod os {\n-        use libc;\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_sysid: libc::c_int,\n-            pub l_pid: libc::pid_t,\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n+\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_WRLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 8;\n+            pub const F_SETLKW: libc::c_int = 9;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_WRLCK: libc::c_short = 2;\n-        pub const F_UNLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 6;\n-        pub const F_SETLKW: libc::c_int = 7;\n-    }\n+        #[cfg(target_os = \"solaris\")]\n+        mod os {\n+            use libc;\n+\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_sysid: libc::c_int,\n+                pub l_pid: libc::pid_t,\n+            }\n \n-    #[derive(Debug)]\n-    pub struct Lock {\n-        fd: libc::c_int,\n-    }\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_WRLCK: libc::c_short = 2;\n+            pub const F_UNLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 6;\n+            pub const F_SETLKW: libc::c_int = 7;\n+        }\n \n-    impl Lock {\n-        pub fn new(p: &Path,\n-                   wait: bool,\n-                   create: bool,\n-                   exclusive: bool)\n-                   -> io::Result<Lock> {\n-            let os: &OsStr = p.as_ref();\n-            let buf = CString::new(os.as_bytes()).unwrap();\n-            let open_flags = if create {\n-                libc::O_RDWR | libc::O_CREAT\n-            } else {\n-                libc::O_RDWR\n-            };\n-\n-            let fd = unsafe {\n-                libc::open(buf.as_ptr(), open_flags,\n-                           libc::S_IRWXU as libc::c_int)\n-            };\n-\n-            if fd < 0 {\n-                return Err(io::Error::last_os_error());\n-            }\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            fd: libc::c_int,\n+        }\n \n-            let lock_type = if exclusive {\n-                os::F_WRLCK\n-            } else {\n-                os::F_RDLCK\n-            };\n-\n-            let flock = os::flock {\n-                l_start: 0,\n-                l_len: 0,\n-                l_pid: 0,\n-                l_whence: libc::SEEK_SET as libc::c_short,\n-                l_type: lock_type,\n-                l_sysid: 0,\n-            };\n-            let cmd = if wait { os::F_SETLKW } else { os::F_SETLK };\n-            let ret = unsafe {\n-                libc::fcntl(fd, cmd, &flock)\n-            };\n-            if ret == -1 {\n-                let err = io::Error::last_os_error();\n-                unsafe { libc::close(fd); }\n-                Err(err)\n-            } else {\n-                Ok(Lock { fd: fd })\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                let os: &OsStr = p.as_ref();\n+                let buf = CString::new(os.as_bytes()).unwrap();\n+                let open_flags = if create {\n+                    libc::O_RDWR | libc::O_CREAT\n+                } else {\n+                    libc::O_RDWR\n+                };\n+\n+                let fd = unsafe {\n+                    libc::open(buf.as_ptr(), open_flags,\n+                               libc::S_IRWXU as libc::c_int)\n+                };\n+\n+                if fd < 0 {\n+                    return Err(io::Error::last_os_error());\n+                }\n+\n+                let lock_type = if exclusive {\n+                    os::F_WRLCK\n+                } else {\n+                    os::F_RDLCK\n+                };\n+\n+                let flock = os::flock {\n+                    l_start: 0,\n+                    l_len: 0,\n+                    l_pid: 0,\n+                    l_whence: libc::SEEK_SET as libc::c_short,\n+                    l_type: lock_type,\n+                    l_sysid: 0,\n+                };\n+                let cmd = if wait { os::F_SETLKW } else { os::F_SETLK };\n+                let ret = unsafe {\n+                    libc::fcntl(fd, cmd, &flock)\n+                };\n+                if ret == -1 {\n+                    let err = io::Error::last_os_error();\n+                    unsafe { libc::close(fd); }\n+                    Err(err)\n+                } else {\n+                    Ok(Lock { fd: fd })\n+                }\n             }\n         }\n-    }\n \n-    impl Drop for Lock {\n-        fn drop(&mut self) {\n-            let flock = os::flock {\n-                l_start: 0,\n-                l_len: 0,\n-                l_pid: 0,\n-                l_whence: libc::SEEK_SET as libc::c_short,\n-                l_type: os::F_UNLCK,\n-                l_sysid: 0,\n-            };\n-            unsafe {\n-                libc::fcntl(self.fd, os::F_SETLK, &flock);\n-                libc::close(self.fd);\n+        impl Drop for Lock {\n+            fn drop(&mut self) {\n+                let flock = os::flock {\n+                    l_start: 0,\n+                    l_len: 0,\n+                    l_pid: 0,\n+                    l_whence: libc::SEEK_SET as libc::c_short,\n+                    l_type: os::F_UNLCK,\n+                    l_sysid: 0,\n+                };\n+                unsafe {\n+                    libc::fcntl(self.fd, os::F_SETLK, &flock);\n+                    libc::close(self.fd);\n+                }\n             }\n         }\n-    }\n-}\n+    } else if #[cfg(windows)] {\n+        use std::mem;\n+        use std::os::windows::prelude::*;\n+        use std::os::windows::raw::HANDLE;\n+        use std::fs::{File, OpenOptions};\n+        use std::os::raw::{c_ulong, c_int};\n \n-#[cfg(windows)]\n-#[allow(nonstandard_style)]\n-mod imp {\n-    use std::io;\n-    use std::mem;\n-    use std::os::windows::prelude::*;\n-    use std::os::windows::raw::HANDLE;\n-    use std::path::Path;\n-    use std::fs::{File, OpenOptions};\n-    use std::os::raw::{c_ulong, c_int};\n-\n-    type DWORD = c_ulong;\n-    type BOOL = c_int;\n-    type ULONG_PTR = usize;\n-\n-    type LPOVERLAPPED = *mut OVERLAPPED;\n-    const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x0000_0002;\n-    const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x0000_0001;\n-\n-    const FILE_SHARE_DELETE: DWORD = 0x4;\n-    const FILE_SHARE_READ: DWORD = 0x1;\n-    const FILE_SHARE_WRITE: DWORD = 0x2;\n-\n-    #[repr(C)]\n-    struct OVERLAPPED {\n-        Internal: ULONG_PTR,\n-        InternalHigh: ULONG_PTR,\n-        Offset: DWORD,\n-        OffsetHigh: DWORD,\n-        hEvent: HANDLE,\n-    }\n+        type DWORD = c_ulong;\n+        type BOOL = c_int;\n+        type ULONG_PTR = usize;\n \n-    extern \"system\" {\n-        fn LockFileEx(hFile: HANDLE,\n-                      dwFlags: DWORD,\n-                      dwReserved: DWORD,\n-                      nNumberOfBytesToLockLow: DWORD,\n-                      nNumberOfBytesToLockHigh: DWORD,\n-                      lpOverlapped: LPOVERLAPPED) -> BOOL;\n-    }\n+        type LPOVERLAPPED = *mut OVERLAPPED;\n+        const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x0000_0002;\n+        const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x0000_0001;\n \n-    #[derive(Debug)]\n-    pub struct Lock {\n-        _file: File,\n-    }\n+        const FILE_SHARE_DELETE: DWORD = 0x4;\n+        const FILE_SHARE_READ: DWORD = 0x1;\n+        const FILE_SHARE_WRITE: DWORD = 0x2;\n \n-    impl Lock {\n-        pub fn new(p: &Path,\n-                   wait: bool,\n-                   create: bool,\n-                   exclusive: bool)\n-                   -> io::Result<Lock> {\n-            assert!(p.parent().unwrap().exists(),\n-                \"Parent directory of lock-file must exist: {}\",\n-                p.display());\n-\n-            let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n-\n-            let mut open_options = OpenOptions::new();\n-            open_options.read(true)\n-                        .share_mode(share_mode);\n-\n-            if create {\n-                open_options.create(true)\n-                            .write(true);\n-            }\n+        #[repr(C)]\n+        struct OVERLAPPED {\n+            Internal: ULONG_PTR,\n+            InternalHigh: ULONG_PTR,\n+            Offset: DWORD,\n+            OffsetHigh: DWORD,\n+            hEvent: HANDLE,\n+        }\n \n-            debug!(\"Attempting to open lock file `{}`\", p.display());\n-            let file = match open_options.open(p) {\n-                Ok(file) => {\n-                    debug!(\"Lock file opened successfully\");\n-                    file\n-                }\n-                Err(err) => {\n-                    debug!(\"Error opening lock file: {}\", err);\n-                    return Err(err)\n-                }\n-            };\n+        extern \"system\" {\n+            fn LockFileEx(hFile: HANDLE,\n+                          dwFlags: DWORD,\n+                          dwReserved: DWORD,\n+                          nNumberOfBytesToLockLow: DWORD,\n+                          nNumberOfBytesToLockHigh: DWORD,\n+                          lpOverlapped: LPOVERLAPPED) -> BOOL;\n+        }\n \n-            let ret = unsafe {\n-                let mut overlapped: OVERLAPPED = mem::zeroed();\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            _file: File,\n+        }\n \n-                let mut dwFlags = 0;\n-                if !wait {\n-                    dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                assert!(p.parent().unwrap().exists(),\n+                    \"Parent directory of lock-file must exist: {}\",\n+                    p.display());\n+\n+                let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n+\n+                let mut open_options = OpenOptions::new();\n+                open_options.read(true)\n+                            .share_mode(share_mode);\n+\n+                if create {\n+                    open_options.create(true)\n+                                .write(true);\n                 }\n \n-                if exclusive {\n-                    dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+                debug!(\"Attempting to open lock file `{}`\", p.display());\n+                let file = match open_options.open(p) {\n+                    Ok(file) => {\n+                        debug!(\"Lock file opened successfully\");\n+                        file\n+                    }\n+                    Err(err) => {\n+                        debug!(\"Error opening lock file: {}\", err);\n+                        return Err(err)\n+                    }\n+                };\n+\n+                let ret = unsafe {\n+                    let mut overlapped: OVERLAPPED = mem::zeroed();\n+\n+                    let mut dwFlags = 0;\n+                    if !wait {\n+                        dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+                    }\n+\n+                    if exclusive {\n+                        dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+                    }\n+\n+                    debug!(\"Attempting to acquire lock on lock file `{}`\",\n+                           p.display());\n+                    LockFileEx(file.as_raw_handle(),\n+                               dwFlags,\n+                               0,\n+                               0xFFFF_FFFF,\n+                               0xFFFF_FFFF,\n+                               &mut overlapped)\n+                };\n+                if ret == 0 {\n+                    let err = io::Error::last_os_error();\n+                    debug!(\"Failed acquiring file lock: {}\", err);\n+                    Err(err)\n+                } else {\n+                    debug!(\"Successfully acquired lock.\");\n+                    Ok(Lock { _file: file })\n                 }\n+            }\n+        }\n \n-                debug!(\"Attempting to acquire lock on lock file `{}`\",\n-                       p.display());\n-                LockFileEx(file.as_raw_handle(),\n-                           dwFlags,\n-                           0,\n-                           0xFFFF_FFFF,\n-                           0xFFFF_FFFF,\n-                           &mut overlapped)\n-            };\n-            if ret == 0 {\n-                let err = io::Error::last_os_error();\n-                debug!(\"Failed acquiring file lock: {}\", err);\n-                Err(err)\n-            } else {\n-                debug!(\"Successfully acquired lock.\");\n-                Ok(Lock { _file: file })\n+        // Note that we don't need a Drop impl on the Windows: The file is unlocked\n+        // automatically when it's closed.\n+    } else {\n+        #[derive(Debug)]\n+        pub struct Lock(());\n+\n+        impl Lock {\n+            pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool)\n+                -> io::Result<Lock>\n+            {\n+                let msg = \"file locks not supported on this platform\";\n+                Err(io::Error::new(io::ErrorKind::Other, msg))\n             }\n         }\n     }\n-\n-    // Note that we don't need a Drop impl on the Windows: The file is unlocked\n-    // automatically when it's closed.\n }\n \n-impl imp::Lock {\n+impl Lock {\n     pub fn panicking_new(p: &Path,\n                          wait: bool,\n                          create: bool,"}, {"sha": "ff323073c6235eb40da49f36e75d1e4f82127827", "filename": "src/librustc_errors/lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c89243fd33a7f9f0ef4ddc9796047c646e9a688/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c89243fd33a7f9f0ef4ddc9796047c646e9a688/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=0c89243fd33a7f9f0ef4ddc9796047c646e9a688", "patch": "@@ -109,7 +109,7 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n     }\n }\n \n-#[cfg(unix)]\n+#[cfg(not(windows))]\n pub fn acquire_global_lock(_name: &str) -> Box<dyn Any> {\n     Box::new(())\n }"}]}