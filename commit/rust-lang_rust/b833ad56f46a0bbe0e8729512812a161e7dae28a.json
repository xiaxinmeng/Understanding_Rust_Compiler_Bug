{"sha": "b833ad56f46a0bbe0e8729512812a161e7dae28a", "node_id": "C_kwDOAAsO6NoAKGI4MzNhZDU2ZjQ2YTBiYmUwZTg3Mjk1MTI4MTJhMTYxZTdkYWUyOGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-18T20:26:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-18T20:26:58Z"}, "message": "Auto merge of #104573 - matthiaskrgr:rollup-k36ybtp, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #101162 (Migrate rustc_resolve to use SessionDiagnostic, part # 1)\n - #103386 (Don't allow `CoerceUnsized` into `dyn*` (except for trait upcasting))\n - #103405 (Detect incorrect chaining of if and if let conditions and recover)\n - #103594 (Fix non-associativity of `Instant` math on `aarch64-apple-darwin` targets)\n - #104006 (Add variant_name function to `LangItem`)\n - #104494 (Migrate GUI test to use functions)\n - #104516 (rustdoc: clean up sidebar width CSS)\n - #104550 (fix a typo)\n\nFailed merges:\n\n - #104554 (Use `ErrorGuaranteed::unchecked_claim_error_was_emitted` less)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "06ff2cca21b9852960818c4d0f79b3cac302a54c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06ff2cca21b9852960818c4d0f79b3cac302a54c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b833ad56f46a0bbe0e8729512812a161e7dae28a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b833ad56f46a0bbe0e8729512812a161e7dae28a", "html_url": "https://github.com/rust-lang/rust/commit/b833ad56f46a0bbe0e8729512812a161e7dae28a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b833ad56f46a0bbe0e8729512812a161e7dae28a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70fe5f08fffd16dc20506f7d140e47b074f77964", "url": "https://api.github.com/repos/rust-lang/rust/commits/70fe5f08fffd16dc20506f7d140e47b074f77964", "html_url": "https://github.com/rust-lang/rust/commit/70fe5f08fffd16dc20506f7d140e47b074f77964"}, {"sha": "7e5e520c7daf193bc33f8dd12dfd9ec4ed1f261a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e5e520c7daf193bc33f8dd12dfd9ec4ed1f261a", "html_url": "https://github.com/rust-lang/rust/commit/7e5e520c7daf193bc33f8dd12dfd9ec4ed1f261a"}], "stats": {"total": 1868, "additions": 1281, "deletions": 587}, "files": [{"sha": "d2eeb36f616ee8ba1e7eb9213348be71050f391c", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -4047,6 +4047,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_query_system\","}, {"sha": "1df5bf1a22037fef47d29a92a2b06d9df946b6d4", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -54,6 +54,9 @@ parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n     .suggestion = use `!` to perform bitwise not\n \n+parser_unexpected_if_with_if = unexpected `if` in the condition expression\n+    .suggestion = remove the `if`\n+\n parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n parser_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n parser_unexpected_token_after_not_logical = use `!` to perform logical negation"}, {"sha": "817bb83ed786a6ed3a8267397b5bc0e958da03d1", "filename": "compiler/rustc_error_messages/locales/en-US/resolve.ftl", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fresolve.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fresolve.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fresolve.ftl?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,211 @@\n+resolve_parent_module_reset_for_binding =\n+    parent module is reset for binding\n+\n+resolve_ampersand_used_without_explicit_lifetime_name =\n+    `&` without an explicit lifetime name cannot be used here\n+    .note = explicit lifetime name needed here\n+\n+resolve_underscore_lifetime_name_cannot_be_used_here =\n+    `'_` cannot be used here\n+    .note = `'_` is a reserved lifetime name\n+\n+resolve_crate_may_not_be_imported =\n+    `$crate` may not be imported\n+\n+resolve_crate_root_imports_must_be_named_explicitly =\n+    crate root imports need to be explicitly named: `use crate as name;`\n+\n+resolve_generic_params_from_outer_function =\n+    can't use generic parameters from outer function\n+    .label = use of generic parameter from outer function\n+    .suggestion = try using a local generic parameter instead\n+\n+resolve_self_type_implicitly_declared_by_impl =\n+    `Self` type implicitly declared here, by this `impl`\n+\n+resolve_cannot_use_self_type_here =\n+    can't use `Self` here\n+\n+resolve_use_a_type_here_instead =\n+    use a type here instead\n+\n+resolve_type_param_from_outer_fn =\n+    type parameter from outer function\n+\n+resolve_const_param_from_outer_fn =\n+    const parameter from outer function\n+\n+resolve_try_using_local_generic_parameter =\n+    try using a local generic parameter instead\n+\n+resolve_try_adding_local_generic_param_on_method =\n+    try adding a local generic parameter in this method instead\n+\n+resolve_help_try_using_local_generic_param =\n+    try using a local generic paramter instead\n+\n+resolve_name_is_already_used_as_generic_parameter =\n+    the name `{$name}` is already used for a generic parameter in this item's generic parameters\n+    .label = already used\n+    .first_use_of_name = first use of `{$name}`\n+\n+resolve_method_not_member_of_trait =\n+    method `{$method}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n+\n+resolve_associated_fn_with_similar_name_exists =\n+    there is an associated function with a similar name\n+\n+resolve_type_not_member_of_trait =\n+    type `{$type_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n+\n+resolve_associated_type_with_similar_name_exists =\n+    there is an associated type with a similar name\n+\n+resolve_const_not_member_of_trait =\n+    const `{$const_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n+\n+resolve_associated_const_with_similar_name_exists =\n+    there is an associated constant with a similar name\n+\n+resolve_variable_bound_with_different_mode =\n+    variable `{$variable_name}` is bound inconsistently across alternatives separated by `|`\n+    .label = bound in different ways\n+    .first_binding_span = first binding\n+\n+resolve_ident_bound_more_than_once_in_parameter_list =\n+    identifier `{$identifier}` is bound more than once in this parameter list\n+    .label = used as parameter more than once\n+\n+resolve_ident_bound_more_than_once_in_same_pattern =\n+    identifier `{$identifier}` is bound more than once in the same pattern\n+    .label = used in a pattern more than once\n+\n+resolve_undeclared_label =\n+    use of undeclared label `{$name}`\n+    .label = undeclared label `{$name}`\n+\n+resolve_label_with_similar_name_reachable =\n+    a label with a similar name is reachable\n+\n+resolve_try_using_similarly_named_label =\n+    try using similarly named label\n+\n+resolve_unreachable_label_with_similar_name_exists =\n+    a label with a similar name exists but is unreachable\n+\n+resolve_self_import_can_only_appear_once_in_the_list =\n+    `self` import can only appear once in an import list\n+    .label = can only appear once in an import list\n+\n+resolve_self_import_only_in_import_list_with_non_empty_prefix =\n+    `self` import can only appear in an import list with a non-empty prefix\n+    .label = can only appear in an import list with a non-empty prefix\n+\n+resolve_cannot_capture_dynamic_environment_in_fn_item =\n+    can't capture dynamic environment in a fn item\n+    .help = use the `|| {\"{\"} ... {\"}\"}` closure form instead\n+\n+resolve_attempt_to_use_non_constant_value_in_constant =\n+    attempt to use a non-constant value in a constant\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion =\n+    consider using `{$suggestion}` instead of `{$current}`\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion =\n+    non-constant value\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion =\n+    this would need to be a `{$suggestion}`\n+\n+resolve_self_imports_only_allowed_within =\n+    `self` imports are only allowed within a {\"{\"} {\"}\"} list\n+\n+resolve_self_imports_only_allowed_within_suggestion =\n+    consider importing the module directly\n+\n+resolve_self_imports_only_allowed_within_multipart_suggestion =\n+    alternatively, use the multi-path `use` syntax to import `self`\n+\n+resolve_binding_shadows_something_unacceptable =\n+    {$shadowing_binding}s cannot shadow {$shadowed_binding}s\n+    .label = cannot be named the same as {$article} {$shadowed_binding}\n+    .label_shadowed_binding = the {$shadowed_binding} `{$name}` is {$participle} here\n+\n+resolve_binding_shadows_something_unacceptable_suggestion =\n+    try specify the pattern arguments\n+\n+resolve_forward_declared_generic_param =\n+    generic parameters with a default cannot use forward declared identifiers\n+    .label = defaulted generic parameters cannot be forward declared\n+\n+resolve_param_in_ty_of_const_param =\n+    the type of const parameters must not depend on other generic parameters\n+    .label = the type must not depend on the parameter `{$name}`\n+\n+resolve_self_in_generic_param_default =\n+    generic parameters cannot use `Self` in their defaults\n+    .label = `Self` in generic parameter default\n+\n+resolve_param_in_non_trivial_anon_const =\n+    generic parameters may not be used in const operations\n+    .label = cannot perform const operation using `{$name}`\n+\n+resolve_param_in_non_trivial_anon_const_help =\n+    use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+\n+resolve_param_in_non_trivial_anon_const_sub_type =\n+    type parameters may not be used in const expressions\n+\n+resolve_param_in_non_trivial_anon_const_sub_non_type =\n+    const parameters may only be used as standalone arguments, i.e. `{$name}`\n+\n+resolve_unreachable_label =\n+    use of unreachable label `{$name}`\n+    .label = unreachable label `{$name}`\n+    .label_definition_span = unreachable label defined here\n+    .note = labels are unreachable through functions, closures, async blocks and modules\n+\n+resolve_unreachable_label_suggestion_use_similarly_named =\n+    try using similarly named label\n+\n+resolve_unreachable_label_similar_name_reachable =\n+    a label with a similar name is reachable\n+\n+resolve_unreachable_label_similar_name_unreachable =\n+    a label with a similar name exists but is also unreachable\n+\n+resolve_trait_impl_mismatch =\n+    item `{$name}` is an associated {$kind}, which doesn't match its trait `{$trait_path}`\n+    .label = does not match trait\n+    .label_trait_item = item in trait\n+\n+resolve_invalid_asm_sym =\n+    invalid `sym` operand\n+    .label = is a local variable\n+    .help = `sym` operands must refer to either a function or a static\n+\n+resolve_trait_impl_duplicate =\n+    duplicate definitions with name `{$name}`:\n+    .label = duplicate definition\n+    .old_span_label = previous definition here\n+    .trait_item_span = item in trait\n+\n+resolve_relative_2018 =\n+    relative paths are not supported in visibilities in 2018 edition or later\n+    .suggestion = try\n+\n+resolve_ancestor_only =\n+    visibilities can only be restricted to ancestor modules\n+\n+resolve_expected_found =\n+    expected module, found {$res} `{$path_str}`\n+    .label = not a module\n+\n+resolve_indeterminate =\n+    cannot determine resolution for the visibility\n+\n+resolve_module_only =\n+    visibility must resolve to a module"}, {"sha": "9c71f0906b5ec3fa976c8a2b585a5ee6d4f03ea0", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -63,6 +63,7 @@ fluent_messages! {\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     query_system => \"../locales/en-US/query_system.ftl\",\n+    resolve => \"../locales/en-US/resolve.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     session => \"../locales/en-US/session.ftl\",\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\","}, {"sha": "ee68344805f4c34534d23d21cb3674c06a6fcd24", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -211,6 +211,12 @@ impl IntoDiagnosticArg for DiagnosticSymbolList {\n     }\n }\n \n+impl<Id> IntoDiagnosticArg for hir::def::Res<Id> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.descr()))\n+    }\n+}\n+\n impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag;"}, {"sha": "230d250ff88cbc1a2c6452284ef92231b6390094", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -95,6 +95,14 @@ macro_rules! language_item_table {\n                 }\n             }\n \n+            /// Returns the name of the `LangItem` enum variant.\n+            // This method is used by Clippy for internal lints.\n+            pub fn variant_name(self) -> &'static str {\n+                match self {\n+                    $( LangItem::$variant => stringify!($variant), )*\n+                }\n+            }\n+\n             pub fn target(self) -> Target {\n                 match self {\n                     $( LangItem::$variant => $target, )*"}, {"sha": "bd9cd53e11578b2442d0a981d1c3b6dd7fe1a8a2", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -144,7 +144,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n             AlreadyReported(ErrorGuaranteed { .. }) => {\n                 write!(\n                     f,\n-                    \"an error has already been reported elsewhere (this sould not usually be printed)\"\n+                    \"an error has already been reported elsewhere (this should not usually be printed)\"\n                 )\n             }\n             Layout(ref err) => write!(f, \"{err}\"),"}, {"sha": "211450250fdf44a1fc7f8f9d86cf7bc83bd5da04", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -1219,3 +1219,11 @@ pub(crate) struct FnPtrWithGenericsSugg {\n     pub arity: usize,\n     pub for_param_list_exists: bool,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_unexpected_if_with_if)]\n+pub(crate) struct UnexpectedIfWithIf(\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \" \", style = \"verbose\")]\n+    pub Span,\n+);"}, {"sha": "9f680a60613ff07ca2251914930e99ed8c10866a", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -21,8 +21,8 @@ use crate::errors::{\n     NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n     OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n     RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n-    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n-    UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n+    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n+    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use core::mem;\n@@ -2239,6 +2239,7 @@ impl<'a> Parser<'a> {\n                 if let Some(block) = recover_block_from_condition(self) {\n                     block\n                 } else {\n+                    self.error_on_extra_if(&cond)?;\n                     // Parse block, which will always fail, but we can add a nice note to the error\n                     self.parse_block().map_err(|mut err| {\n                         err.span_note(\n@@ -2375,6 +2376,16 @@ impl<'a> Parser<'a> {\n         });\n     }\n \n+    fn error_on_extra_if(&mut self, cond: &P<Expr>) -> PResult<'a, ()> {\n+        if let ExprKind::Binary(Spanned { span: binop_span, node: binop}, _, right) = &cond.kind &&\n+            let BinOpKind::And = binop &&\n+            let ExprKind::If(cond, ..) = &right.kind {\n+                    Err(self.sess.create_err(UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n+            } else {\n+                Ok(())\n+            }\n+    }\n+\n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n     fn parse_for_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         // Record whether we are about to parse `for (`."}, {"sha": "7c3a0f8f277b5b6480016958e3b3b7a5c24759f0", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -17,6 +17,7 @@ rustc_expand = { path = \"../rustc_expand\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_query_system = { path = \"../rustc_query_system\" }"}, {"sha": "bc3a710e84bd046b9213e2086f850d30f47236e8", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 182, "deletions": 362, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -27,6 +27,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};\n use thin_vec::ThinVec;\n \n+use crate::errors as errs;\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::late::{PatternSource, Rib};\n use crate::path_names_to_string;\n@@ -598,78 +599,41 @@ impl<'a> Resolver<'a> {\n \n                 err\n             }\n-            ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0403,\n-                    \"the name `{}` is already used for a generic \\\n-                     parameter in this item's generic parameters\",\n-                    name,\n-                );\n-                err.span_label(span, \"already used\");\n-                err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n-                err\n-            }\n+            ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => self\n+                .session\n+                .create_err(errs::NameAlreadyUsedInParameterList { span, first_use_span, name }),\n             ResolutionError::MethodNotMemberOfTrait(method, trait_, candidate) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::MethodNotMemberOfTrait {\n                     span,\n-                    E0407,\n-                    \"method `{}` is not a member of trait `{}`\",\n                     method,\n-                    trait_\n-                );\n-                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-                if let Some(candidate) = candidate {\n-                    err.span_suggestion(\n-                        method.span,\n-                        \"there is an associated function with a similar name\",\n-                        candidate.to_ident_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err\n+                    trait_,\n+                    sub: candidate.map(|c| errs::AssociatedFnWithSimilarNameExists {\n+                        span: method.span,\n+                        candidate: c,\n+                    }),\n+                })\n             }\n             ResolutionError::TypeNotMemberOfTrait(type_, trait_, candidate) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::TypeNotMemberOfTrait {\n                     span,\n-                    E0437,\n-                    \"type `{}` is not a member of trait `{}`\",\n                     type_,\n-                    trait_\n-                );\n-                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-                if let Some(candidate) = candidate {\n-                    err.span_suggestion(\n-                        type_.span,\n-                        \"there is an associated type with a similar name\",\n-                        candidate.to_ident_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err\n+                    trait_,\n+                    sub: candidate.map(|c| errs::AssociatedTypeWithSimilarNameExists {\n+                        span: type_.span,\n+                        candidate: c,\n+                    }),\n+                })\n             }\n             ResolutionError::ConstNotMemberOfTrait(const_, trait_, candidate) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::ConstNotMemberOfTrait {\n                     span,\n-                    E0438,\n-                    \"const `{}` is not a member of trait `{}`\",\n                     const_,\n-                    trait_\n-                );\n-                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-                if let Some(candidate) = candidate {\n-                    err.span_suggestion(\n-                        const_.span,\n-                        \"there is an associated constant with a similar name\",\n-                        candidate.to_ident_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err\n+                    trait_,\n+                    sub: candidate.map(|c| errs::AssociatedConstWithSimilarNameExists {\n+                        span: const_.span,\n+                        candidate: c,\n+                    }),\n+                })\n             }\n             ResolutionError::VariableNotBoundInPattern(binding_error, parent_scope) => {\n                 let BindingError { name, target, origin, could_be_path } = binding_error;\n@@ -731,128 +695,78 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name, first_binding_span) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0409,\n-                    \"variable `{}` is bound inconsistently across alternatives separated by `|`\",\n-                    variable_name\n-                );\n-                err.span_label(span, \"bound in different ways\");\n-                err.span_label(first_binding_span, \"first binding\");\n-                err\n-            }\n-            ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0415,\n-                    \"identifier `{}` is bound more than once in this parameter list\",\n-                    identifier\n-                );\n-                err.span_label(span, \"used as parameter more than once\");\n-                err\n-            }\n-            ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                self.session.create_err(errs::VariableBoundWithDifferentMode {\n                     span,\n-                    E0416,\n-                    \"identifier `{}` is bound more than once in the same pattern\",\n-                    identifier\n-                );\n-                err.span_label(span, \"used in a pattern more than once\");\n-                err\n-            }\n+                    first_binding_span,\n+                    variable_name,\n+                })\n+            }\n+            ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => self\n+                .session\n+                .create_err(errs::IdentifierBoundMoreThanOnceInParameterList { span, identifier }),\n+            ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => self\n+                .session\n+                .create_err(errs::IdentifierBoundMoreThanOnceInSamePattern { span, identifier }),\n             ResolutionError::UndeclaredLabel { name, suggestion } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0426,\n-                    \"use of undeclared label `{}`\",\n-                    name\n-                );\n-\n-                err.span_label(span, format!(\"undeclared label `{}`\", name));\n-\n-                match suggestion {\n+                let ((sub_reachable, sub_reachable_suggestion), sub_unreachable) = match suggestion\n+                {\n                     // A reachable label with a similar name exists.\n-                    Some((ident, true)) => {\n-                        err.span_label(ident.span, \"a label with a similar name is reachable\");\n-                        err.span_suggestion(\n-                            span,\n-                            \"try using similarly named label\",\n-                            ident.name,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                    Some((ident, true)) => (\n+                        (\n+                            Some(errs::LabelWithSimilarNameReachable(ident.span)),\n+                            Some(errs::TryUsingSimilarlyNamedLabel {\n+                                span,\n+                                ident_name: ident.name,\n+                            }),\n+                        ),\n+                        None,\n+                    ),\n                     // An unreachable label with a similar name exists.\n-                    Some((ident, false)) => {\n-                        err.span_label(\n-                            ident.span,\n-                            \"a label with a similar name exists but is unreachable\",\n-                        );\n-                    }\n+                    Some((ident, false)) => (\n+                        (None, None),\n+                        Some(errs::UnreachableLabelWithSimilarNameExists {\n+                            ident_span: ident.span,\n+                        }),\n+                    ),\n                     // No similarly-named labels exist.\n-                    None => (),\n-                }\n-\n-                err\n+                    None => ((None, None), None),\n+                };\n+                self.session.create_err(errs::UndeclaredLabel {\n+                    span,\n+                    name,\n+                    sub_reachable,\n+                    sub_reachable_suggestion,\n+                    sub_unreachable,\n+                })\n             }\n             ResolutionError::SelfImportsOnlyAllowedWithin { root, span_with_rename } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0429,\n-                    \"{}\",\n-                    \"`self` imports are only allowed within a { } list\"\n-                );\n-\n                 // None of the suggestions below would help with a case like `use self`.\n-                if !root {\n+                let (suggestion, mpart_suggestion) = if root {\n+                    (None, None)\n+                } else {\n                     // use foo::bar::self        -> foo::bar\n                     // use foo::bar::self as abc -> foo::bar as abc\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider importing the module directly\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    let suggestion = errs::SelfImportsOnlyAllowedWithinSuggestion { span };\n \n                     // use foo::bar::self        -> foo::bar::{self}\n                     // use foo::bar::self as abc -> foo::bar::{self as abc}\n-                    let braces = vec![\n-                        (span_with_rename.shrink_to_lo(), \"{\".to_string()),\n-                        (span_with_rename.shrink_to_hi(), \"}\".to_string()),\n-                    ];\n-                    err.multipart_suggestion(\n-                        \"alternatively, use the multi-path `use` syntax to import `self`\",\n-                        braces,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                err\n+                    let mpart_suggestion = errs::SelfImportsOnlyAllowedWithinMultipartSuggestion {\n+                        multipart_start: span_with_rename.shrink_to_lo(),\n+                        multipart_end: span_with_rename.shrink_to_hi(),\n+                    };\n+                    (Some(suggestion), Some(mpart_suggestion))\n+                };\n+                self.session.create_err(errs::SelfImportsOnlyAllowedWithin {\n+                    span,\n+                    suggestion,\n+                    mpart_suggestion,\n+                })\n             }\n             ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0430,\n-                    \"`self` import can only appear once in an import list\"\n-                );\n-                err.span_label(span, \"can only appear once in an import list\");\n-                err\n+                self.session.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n             }\n             ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0431,\n-                    \"`self` import can only appear in an import list with \\\n-                                                a non-empty prefix\"\n-                );\n-                err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n-                err\n+                self.session.create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span })\n             }\n             ResolutionError::FailedToResolve { label, suggestion } => {\n                 let mut err =\n@@ -870,23 +784,9 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0434,\n-                    \"{}\",\n-                    \"can't capture dynamic environment in a fn item\"\n-                );\n-                err.help(\"use the `|| { ... }` closure form instead\");\n-                err\n+                self.session.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n             }\n-            ResolutionError::AttemptToUseNonConstantValueInConstant(ident, sugg, current) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0435,\n-                    \"attempt to use a non-constant value in a constant\"\n-                );\n+            ResolutionError::AttemptToUseNonConstantValueInConstant(ident, suggestion, current) => {\n                 // let foo =...\n                 //     ^^^ given this Span\n                 // ------- get this Span to have an applicable suggestion\n@@ -900,23 +800,34 @@ impl<'a> Resolver<'a> {\n                     .source_map()\n                     .span_extend_to_prev_str(ident.span, current, true, false);\n \n-                match sp {\n+                let ((with, with_label), without) = match sp {\n                     Some(sp) if !self.session.source_map().is_multiline(sp) => {\n                         let sp = sp.with_lo(BytePos(sp.lo().0 - (current.len() as u32)));\n-                        err.span_suggestion(\n-                            sp,\n-                            &format!(\"consider using `{}` instead of `{}`\", sugg, current),\n-                            format!(\"{} {}\", sugg, ident),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        err.span_label(span, \"non-constant value\");\n-                    }\n-                    _ => {\n-                        err.span_label(ident.span, &format!(\"this would need to be a `{}`\", sugg));\n+                        (\n+                        (Some(errs::AttemptToUseNonConstantValueInConstantWithSuggestion {\n+                                span: sp,\n+                                ident,\n+                                suggestion,\n+                                current,\n+                            }), Some(errs::AttemptToUseNonConstantValueInConstantLabelWithSuggestion {span})),\n+                            None,\n+                        )\n                     }\n-                }\n+                    _ => (\n+                        (None, None),\n+                        Some(errs::AttemptToUseNonConstantValueInConstantWithoutSuggestion {\n+                            ident_span: ident.span,\n+                            suggestion,\n+                        }),\n+                    ),\n+                };\n \n-                err\n+                self.session.create_err(errs::AttemptToUseNonConstantValueInConstant {\n+                    span,\n+                    with,\n+                    with_label,\n+                    without,\n+                })\n             }\n             ResolutionError::BindingShadowsSomethingUnacceptable {\n                 shadowing_binding,\n@@ -925,135 +836,80 @@ impl<'a> Resolver<'a> {\n                 article,\n                 shadowed_binding,\n                 shadowed_binding_span,\n-            } => {\n-                let shadowed_binding_descr = shadowed_binding.descr();\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0530,\n-                    \"{}s cannot shadow {}s\",\n-                    shadowing_binding.descr(),\n-                    shadowed_binding_descr,\n-                );\n-                err.span_label(\n-                    span,\n-                    format!(\"cannot be named the same as {} {}\", article, shadowed_binding_descr),\n-                );\n-                match (shadowing_binding, shadowed_binding) {\n+            } => self.session.create_err(errs::BindingShadowsSomethingUnacceptable {\n+                span,\n+                shadowing_binding,\n+                shadowed_binding,\n+                article,\n+                sub_suggestion: match (shadowing_binding, shadowed_binding) {\n                     (\n                         PatternSource::Match,\n                         Res::Def(DefKind::Ctor(CtorOf::Variant | CtorOf::Struct, CtorKind::Fn), _),\n-                    ) => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try specify the pattern arguments\",\n-                            format!(\"{}(..)\", name),\n-                            Applicability::Unspecified,\n-                        );\n-                    }\n-                    _ => (),\n-                }\n-                let msg =\n-                    format!(\"the {} `{}` is {} here\", shadowed_binding_descr, name, participle);\n-                err.span_label(shadowed_binding_span, msg);\n-                err\n-            }\n+                    ) => Some(errs::BindingShadowsSomethingUnacceptableSuggestion { span, name }),\n+                    _ => None,\n+                },\n+                shadowed_binding_span,\n+                participle,\n+                name,\n+            }),\n             ResolutionError::ForwardDeclaredGenericParam => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0128,\n-                    \"generic parameters with a default cannot use \\\n-                                                forward declared identifiers\"\n-                );\n-                err.span_label(span, \"defaulted generic parameters cannot be forward declared\");\n-                err\n+                self.session.create_err(errs::ForwardDeclaredGenericParam { span })\n             }\n             ResolutionError::ParamInTyOfConstParam(name) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0770,\n-                    \"the type of const parameters must not depend on other generic parameters\"\n-                );\n-                err.span_label(\n-                    span,\n-                    format!(\"the type must not depend on the parameter `{}`\", name),\n-                );\n-                err\n+                self.session.create_err(errs::ParamInTyOfConstParam { span, name })\n             }\n             ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n-                let mut err = self.session.struct_span_err(\n+                self.session.create_err(errs::ParamInNonTrivialAnonConst {\n                     span,\n-                    \"generic parameters may not be used in const operations\",\n-                );\n-                err.span_label(span, &format!(\"cannot perform const operation using `{}`\", name));\n-\n-                if is_type {\n-                    err.note(\"type parameters may not be used in const expressions\");\n-                } else {\n-                    err.help(&format!(\n-                        \"const parameters may only be used as standalone arguments, i.e. `{}`\",\n-                        name\n-                    ));\n-                }\n-\n-                if self.session.is_nightly_build() {\n-                    err.help(\n-                        \"use `#![feature(generic_const_exprs)]` to allow generic const expressions\",\n-                    );\n-                }\n-\n-                err\n+                    name,\n+                    sub_is_type: if is_type {\n+                        errs::ParamInNonTrivialAnonConstIsType::AType\n+                    } else {\n+                        errs::ParamInNonTrivialAnonConstIsType::NotAType { name }\n+                    },\n+                    help: self\n+                        .session\n+                        .is_nightly_build()\n+                        .then_some(errs::ParamInNonTrivialAnonConstHelp),\n+                })\n             }\n             ResolutionError::SelfInGenericParamDefault => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0735,\n-                    \"generic parameters cannot use `Self` in their defaults\"\n-                );\n-                err.span_label(span, \"`Self` in generic parameter default\");\n-                err\n+                self.session.create_err(errs::SelfInGenericParamDefault { span })\n             }\n             ResolutionError::UnreachableLabel { name, definition_span, suggestion } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n+                let ((sub_suggestion_label, sub_suggestion), sub_unreachable_label) =\n+                    match suggestion {\n+                        // A reachable label with a similar name exists.\n+                        Some((ident, true)) => (\n+                            (\n+                                Some(errs::UnreachableLabelSubLabel { ident_span: ident.span }),\n+                                Some(errs::UnreachableLabelSubSuggestion {\n+                                    span,\n+                                    // intentionally taking 'ident.name' instead of 'ident' itself, as this\n+                                    // could be used in suggestion context\n+                                    ident_name: ident.name,\n+                                }),\n+                            ),\n+                            None,\n+                        ),\n+                        // An unreachable label with a similar name exists.\n+                        Some((ident, false)) => (\n+                            (None, None),\n+                            Some(errs::UnreachableLabelSubLabelUnreachable {\n+                                ident_span: ident.span,\n+                            }),\n+                        ),\n+                        // No similarly-named labels exist.\n+                        None => ((None, None), None),\n+                    };\n+                self.session.create_err(errs::UnreachableLabel {\n                     span,\n-                    E0767,\n-                    \"use of unreachable label `{}`\",\n                     name,\n-                );\n-\n-                err.span_label(definition_span, \"unreachable label defined here\");\n-                err.span_label(span, format!(\"unreachable label `{}`\", name));\n-                err.note(\n-                    \"labels are unreachable through functions, closures, async blocks and modules\",\n-                );\n-\n-                match suggestion {\n-                    // A reachable label with a similar name exists.\n-                    Some((ident, true)) => {\n-                        err.span_label(ident.span, \"a label with a similar name is reachable\");\n-                        err.span_suggestion(\n-                            span,\n-                            \"try using similarly named label\",\n-                            ident.name,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    // An unreachable label with a similar name exists.\n-                    Some((ident, false)) => {\n-                        err.span_label(\n-                            ident.span,\n-                            \"a label with a similar name exists but is also unreachable\",\n-                        );\n-                    }\n-                    // No similarly-named labels exist.\n-                    None => (),\n-                }\n-\n-                err\n+                    definition_span,\n+                    sub_suggestion,\n+                    sub_suggestion_label,\n+                    sub_unreachable_label,\n+                })\n             }\n             ResolutionError::TraitImplMismatch {\n                 name,\n@@ -1074,25 +930,10 @@ impl<'a> Resolver<'a> {\n                 err.span_label(trait_item_span, \"item in trait\");\n                 err\n             }\n-            ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0201,\n-                    \"duplicate definitions with name `{}`:\",\n-                    name,\n-                );\n-                err.span_label(old_span, \"previous definition here\");\n-                err.span_label(trait_item_span, \"item in trait\");\n-                err.span_label(span, \"duplicate definition\");\n-                err\n-            }\n-            ResolutionError::InvalidAsmSym => {\n-                let mut err = self.session.struct_span_err(span, \"invalid `sym` operand\");\n-                err.span_label(span, \"is a local variable\");\n-                err.help(\"`sym` operands must refer to either a function or a static\");\n-                err\n-            }\n+            ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => self\n+                .session\n+                .create_err(errs::TraitImplDuplicate { span, name, trait_item_span, old_span }),\n+            ResolutionError::InvalidAsmSym => self.session.create_err(errs::InvalidAsmSym { span }),\n         }\n     }\n \n@@ -1102,48 +943,27 @@ impl<'a> Resolver<'a> {\n     ) -> ErrorGuaranteed {\n         match vis_resolution_error {\n             VisResolutionError::Relative2018(span, path) => {\n-                let mut err = self.session.struct_span_err(\n+                self.session.create_err(errs::Relative2018 {\n                     span,\n-                    \"relative paths are not supported in visibilities in 2018 edition or later\",\n-                );\n-                err.span_suggestion(\n-                    path.span,\n-                    \"try\",\n-                    format!(\"crate::{}\", pprust::path_to_string(&path)),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err\n+                    path_span: path.span,\n+                    // intentionally converting to String, as the text would also be used as\n+                    // in suggestion context\n+                    path_str: pprust::path_to_string(&path),\n+                })\n+            }\n+            VisResolutionError::AncestorOnly(span) => {\n+                self.session.create_err(errs::AncestorOnly(span))\n             }\n-            VisResolutionError::AncestorOnly(span) => struct_span_err!(\n-                self.session,\n-                span,\n-                E0742,\n-                \"visibilities can only be restricted to ancestor modules\"\n-            ),\n             VisResolutionError::FailedToResolve(span, label, suggestion) => {\n                 self.into_struct_error(span, ResolutionError::FailedToResolve { label, suggestion })\n             }\n             VisResolutionError::ExpectedFound(span, path_str, res) => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0577,\n-                    \"expected module, found {} `{}`\",\n-                    res.descr(),\n-                    path_str\n-                );\n-                err.span_label(span, \"not a module\");\n-                err\n+                self.session.create_err(errs::ExpectedFound { span, res, path_str })\n             }\n-            VisResolutionError::Indeterminate(span) => struct_span_err!(\n-                self.session,\n-                span,\n-                E0578,\n-                \"cannot determine resolution for the visibility\"\n-            ),\n-            VisResolutionError::ModuleOnly(span) => {\n-                self.session.struct_span_err(span, \"visibility must resolve to a module\")\n+            VisResolutionError::Indeterminate(span) => {\n+                self.session.create_err(errs::Indeterminate(span))\n             }\n+            VisResolutionError::ModuleOnly(span) => self.session.create_err(errs::ModuleOnly(span)),\n         }\n         .emit()\n     }"}, {"sha": "2c442774667b2b21dc8c56b1cf3489c71c8cc6d8", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "added", "additions": 474, "deletions": 0, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,474 @@\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::{\n+    symbol::{Ident, Symbol},\n+    Span,\n+};\n+\n+use crate::{late::PatternSource, Res};\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_parent_module_reset_for_binding, code = \"E0637\")]\n+pub(crate) struct ParentModuleResetForBinding;\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ampersand_used_without_explicit_lifetime_name, code = \"E0637\")]\n+#[note]\n+pub(crate) struct AmpersandUsedWithoutExplicitLifetimeName(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_underscore_lifetime_name_cannot_be_used_here, code = \"E0637\")]\n+#[note]\n+pub(crate) struct UnderscoreLifetimeNameCannotBeUsedHere(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_crate_may_not_be_imported)]\n+pub(crate) struct CrateMayNotBeImprted(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_crate_root_imports_must_be_named_explicitly)]\n+pub(crate) struct CrateRootNamesMustBeNamedExplicitly(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_crate_root_imports_must_be_named_explicitly)]\n+pub(crate) struct ResolutionError(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_name_is_already_used_as_generic_parameter, code = \"E0403\")]\n+pub(crate) struct NameAlreadyUsedInParameterList {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(first_use_of_name)]\n+    pub(crate) first_use_span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_method_not_member_of_trait, code = \"E0407\")]\n+pub(crate) struct MethodNotMemberOfTrait {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) method: Ident,\n+    pub(crate) trait_: String,\n+    #[subdiagnostic]\n+    pub(crate) sub: Option<AssociatedFnWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_associated_fn_with_similar_name_exists,\n+    code = \"{candidate}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedFnWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) candidate: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_type_not_member_of_trait, code = \"E0437\")]\n+pub(crate) struct TypeNotMemberOfTrait {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) type_: Ident,\n+    pub(crate) trait_: String,\n+    #[subdiagnostic]\n+    pub(crate) sub: Option<AssociatedTypeWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_associated_type_with_similar_name_exists,\n+    code = \"{candidate}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedTypeWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) candidate: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_const_not_member_of_trait, code = \"E0438\")]\n+pub(crate) struct ConstNotMemberOfTrait {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) const_: Ident,\n+    pub(crate) trait_: String,\n+    #[subdiagnostic]\n+    pub(crate) sub: Option<AssociatedConstWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_associated_const_with_similar_name_exists,\n+    code = \"{candidate}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedConstWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) candidate: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_variable_bound_with_different_mode, code = \"E0409\")]\n+pub(crate) struct VariableBoundWithDifferentMode {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(first_binding_span)]\n+    pub(crate) first_binding_span: Span,\n+    pub(crate) variable_name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ident_bound_more_than_once_in_parameter_list, code = \"E0415\")]\n+pub(crate) struct IdentifierBoundMoreThanOnceInParameterList {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) identifier: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ident_bound_more_than_once_in_same_pattern, code = \"E0416\")]\n+pub(crate) struct IdentifierBoundMoreThanOnceInSamePattern {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) identifier: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_undeclared_label, code = \"E0426\")]\n+pub(crate) struct UndeclaredLabel {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[subdiagnostic]\n+    pub(crate) sub_reachable: Option<LabelWithSimilarNameReachable>,\n+    #[subdiagnostic]\n+    pub(crate) sub_reachable_suggestion: Option<TryUsingSimilarlyNamedLabel>,\n+    #[subdiagnostic]\n+    pub(crate) sub_unreachable: Option<UnreachableLabelWithSimilarNameExists>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_label_with_similar_name_reachable)]\n+pub(crate) struct LabelWithSimilarNameReachable(#[primary_span] pub(crate) Span);\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_try_using_similarly_named_label,\n+    code = \"{ident_name}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct TryUsingSimilarlyNamedLabel {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident_name: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_unreachable_label_with_similar_name_exists)]\n+pub(crate) struct UnreachableLabelWithSimilarNameExists {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_import_can_only_appear_once_in_the_list, code = \"E0430\")]\n+pub(crate) struct SelfImportCanOnlyAppearOnceInTheList {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_import_only_in_import_list_with_non_empty_prefix, code = \"E0431\")]\n+pub(crate) struct SelfImportOnlyInImportListWithNonEmptyPrefix {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_cannot_capture_dynamic_environment_in_fn_item, code = \"E0434\")]\n+#[help]\n+pub(crate) struct CannotCaptureDynamicEnvironmentInFnItem {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_attempt_to_use_non_constant_value_in_constant, code = \"E0435\")]\n+pub(crate) struct AttemptToUseNonConstantValueInConstant<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub(crate) with: Option<AttemptToUseNonConstantValueInConstantWithSuggestion<'a>>,\n+    #[subdiagnostic]\n+    pub(crate) with_label: Option<AttemptToUseNonConstantValueInConstantLabelWithSuggestion>,\n+    #[subdiagnostic]\n+    pub(crate) without: Option<AttemptToUseNonConstantValueInConstantWithoutSuggestion<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion,\n+    code = \"{suggestion} {ident}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AttemptToUseNonConstantValueInConstantWithSuggestion<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident: Ident,\n+    pub(crate) suggestion: &'a str,\n+    pub(crate) current: &'a str,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion)]\n+pub(crate) struct AttemptToUseNonConstantValueInConstantLabelWithSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion)]\n+pub(crate) struct AttemptToUseNonConstantValueInConstantWithoutSuggestion<'a> {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+    pub(crate) suggestion: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_imports_only_allowed_within, code = \"E0429\")]\n+pub(crate) struct SelfImportsOnlyAllowedWithin {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub(crate) suggestion: Option<SelfImportsOnlyAllowedWithinSuggestion>,\n+    #[subdiagnostic]\n+    pub(crate) mpart_suggestion: Option<SelfImportsOnlyAllowedWithinMultipartSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_self_imports_only_allowed_within_suggestion,\n+    code = \"\",\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct SelfImportsOnlyAllowedWithinSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    resolve_self_imports_only_allowed_within_multipart_suggestion,\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct SelfImportsOnlyAllowedWithinMultipartSuggestion {\n+    #[suggestion_part(code = \"{{\")]\n+    pub(crate) multipart_start: Span,\n+    #[suggestion_part(code = \"}}\")]\n+    pub(crate) multipart_end: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_binding_shadows_something_unacceptable, code = \"E0530\")]\n+pub(crate) struct BindingShadowsSomethingUnacceptable<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) shadowing_binding: PatternSource,\n+    pub(crate) shadowed_binding: Res,\n+    pub(crate) article: &'a str,\n+    #[subdiagnostic]\n+    pub(crate) sub_suggestion: Option<BindingShadowsSomethingUnacceptableSuggestion>,\n+    #[label(label_shadowed_binding)]\n+    pub(crate) shadowed_binding_span: Span,\n+    pub(crate) participle: &'a str,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_binding_shadows_something_unacceptable_suggestion,\n+    code = \"{name}(..)\",\n+    applicability = \"unspecified\"\n+)]\n+pub(crate) struct BindingShadowsSomethingUnacceptableSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_forward_declared_generic_param, code = \"E0128\")]\n+pub(crate) struct ForwardDeclaredGenericParam {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_param_in_ty_of_const_param, code = \"E0770\")]\n+pub(crate) struct ParamInTyOfConstParam {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_self_in_generic_param_default, code = \"E0735\")]\n+pub(crate) struct SelfInGenericParamDefault {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_param_in_non_trivial_anon_const)]\n+pub(crate) struct ParamInNonTrivialAnonConst {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[subdiagnostic]\n+    pub(crate) sub_is_type: ParamInNonTrivialAnonConstIsType,\n+    #[subdiagnostic]\n+    pub(crate) help: Option<ParamInNonTrivialAnonConstHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(resolve_param_in_non_trivial_anon_const_help)]\n+pub(crate) struct ParamInNonTrivialAnonConstHelp;\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ParamInNonTrivialAnonConstIsType {\n+    #[note(resolve_param_in_non_trivial_anon_const_sub_type)]\n+    AType,\n+    #[help(resolve_param_in_non_trivial_anon_const_sub_non_type)]\n+    NotAType { name: Symbol },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_unreachable_label, code = \"E0767\")]\n+#[note]\n+pub(crate) struct UnreachableLabel {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[label(label_definition_span)]\n+    pub(crate) definition_span: Span,\n+    #[subdiagnostic]\n+    pub(crate) sub_suggestion: Option<UnreachableLabelSubSuggestion>,\n+    #[subdiagnostic]\n+    pub(crate) sub_suggestion_label: Option<UnreachableLabelSubLabel>,\n+    #[subdiagnostic]\n+    pub(crate) sub_unreachable_label: Option<UnreachableLabelSubLabelUnreachable>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    resolve_unreachable_label_suggestion_use_similarly_named,\n+    code = \"{ident_name}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct UnreachableLabelSubSuggestion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident_name: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_unreachable_label_similar_name_reachable)]\n+pub(crate) struct UnreachableLabelSubLabel {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(resolve_unreachable_label_similar_name_unreachable)]\n+pub(crate) struct UnreachableLabelSubLabelUnreachable {\n+    #[primary_span]\n+    pub(crate) ident_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_trait_impl_mismatch, code = \"{code}\")]\n+pub(crate) struct TraitImplMismatch {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    pub(crate) kind: String,\n+    #[label(label_trait_item)]\n+    pub(crate) trait_item_span: Span,\n+    pub(crate) trait_path: String,\n+    pub(crate) code: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_invalid_asm_sym)]\n+#[help]\n+pub(crate) struct InvalidAsmSym {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_trait_impl_duplicate, code = \"E0201\")]\n+pub(crate) struct TraitImplDuplicate {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(old_span_label)]\n+    pub(crate) old_span: Span,\n+    #[label(trait_item_span)]\n+    pub(crate) trait_item_span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_relative_2018)]\n+pub(crate) struct Relative2018 {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[suggestion(code = \"crate::{path_str}\", applicability = \"maybe-incorrect\")]\n+    pub(crate) path_span: Span,\n+    pub(crate) path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_ancestor_only, code = \"E0742\")]\n+pub(crate) struct AncestorOnly(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_expected_found, code = \"E0577\")]\n+pub(crate) struct ExpectedFound {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) res: Res,\n+    pub(crate) path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_indeterminate, code = \"E0578\")]\n+pub(crate) struct Indeterminate(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_module_only)]\n+pub(crate) struct ModuleOnly(#[primary_span] pub(crate) Span);"}, {"sha": "5072d2aad1669ff99e10c879563db2606aa237a8", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -16,7 +16,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::DiagnosticId;\n+use rustc_errors::{DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n@@ -31,6 +31,7 @@ use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n use std::assert_matches::debug_assert_matches;\n+use std::borrow::Cow;\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, swap, take};\n \n@@ -78,6 +79,12 @@ impl PatternSource {\n     }\n }\n \n+impl IntoDiagnosticArg for PatternSource {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.descr()))\n+    }\n+}\n+\n /// Denotes whether the context for the set of already bound bindings is a `Product`\n /// or `Or` context. This is used in e.g., `fresh_binding` and `resolve_pattern_inner`.\n /// See those functions for more information."}, {"sha": "f9ae3b58172725eefc65025acd2332026b3f7143", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -73,6 +73,7 @@ mod check_unused;\n mod def_collector;\n mod diagnostics;\n mod effective_visibilities;\n+mod errors;\n mod ident;\n mod imports;\n mod late;"}, {"sha": "1b742864cfa1e214f2ed4d71d378282e84716488", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -780,7 +780,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            (&ty::Dynamic(ref data_a, _, dyn_a), &ty::Dynamic(ref data_b, _, dyn_b))\n+                if dyn_a == dyn_b =>\n+            {\n                 // Upcast coercions permit several things:\n                 //\n                 // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n@@ -841,7 +843,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // `T` -> `Trait`\n-            (_, &ty::Dynamic(..)) => {\n+            (_, &ty::Dynamic(_, _, ty::Dyn)) => {\n                 candidates.vec.push(BuiltinUnsizeCandidate);\n             }\n "}, {"sha": "a496aed38ac1772ffd00fe25742ed4bbf85ac46c", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -912,7 +912,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut nested = vec![];\n         match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (auto traits and lifetime subtyping).\n-            (&ty::Dynamic(ref data_a, r_a, ty::Dyn), &ty::Dynamic(ref data_b, r_b, ty::Dyn)) => {\n+            (&ty::Dynamic(ref data_a, r_a, dyn_a), &ty::Dynamic(ref data_b, r_b, dyn_b))\n+                if dyn_a == dyn_b =>\n+            {\n                 // See `assemble_candidates_for_unsizing` for more info.\n                 // We already checked the compatibility of auto traits within `assemble_candidates_for_unsizing`.\n                 let iter = data_a\n@@ -931,7 +933,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .map(ty::Binder::dummy),\n                     );\n                 let existential_predicates = tcx.mk_poly_existential_predicates(iter);\n-                let source_trait = tcx.mk_dynamic(existential_predicates, r_b, ty::Dyn);\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b, dyn_a);\n \n                 // Require that the traits involved in this upcast are **equal**;\n                 // only the **lifetime bound** is changed.\n@@ -1140,7 +1142,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }));\n             }\n \n-            _ => bug!(),\n+            _ => bug!(\"source: {source}, target: {target}\"),\n         };\n \n         Ok(ImplSourceBuiltinData { nested })"}, {"sha": "ffcc507d2a763f9a430d99af59c098caa5b79892", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -149,7 +149,11 @@ impl From<libc::timespec> for Timespec {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+#[cfg(any(\n+    all(target_os = \"macos\", any(not(target_arch = \"aarch64\"), miri)),\n+    target_os = \"ios\",\n+    target_os = \"watchos\"\n+))]\n mod inner {\n     use crate::sync::atomic::{AtomicU64, Ordering};\n     use crate::sys::cvt;\n@@ -265,7 +269,11 @@ mod inner {\n     }\n }\n \n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\")))]\n+#[cfg(not(any(\n+    all(target_os = \"macos\", any(not(target_arch = \"aarch64\"), miri)),\n+    target_os = \"ios\",\n+    target_os = \"watchos\"\n+)))]\n mod inner {\n     use crate::fmt;\n     use crate::mem::MaybeUninit;\n@@ -281,7 +289,11 @@ mod inner {\n \n     impl Instant {\n         pub fn now() -> Instant {\n-            Instant { t: Timespec::now(libc::CLOCK_MONOTONIC) }\n+            #[cfg(target_os = \"macos\")]\n+            const clock_id: libc::clockid_t = libc::CLOCK_UPTIME_RAW;\n+            #[cfg(not(target_os = \"macos\"))]\n+            const clock_id: libc::clockid_t = libc::CLOCK_MONOTONIC;\n+            Instant { t: Timespec::now(clock_id) }\n         }\n \n         pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n@@ -312,13 +324,8 @@ mod inner {\n         }\n     }\n \n-    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"espidf\", target_os = \"horizon\")))]\n-    pub type clock_t = libc::c_int;\n-    #[cfg(any(target_os = \"dragonfly\", target_os = \"espidf\", target_os = \"horizon\"))]\n-    pub type clock_t = libc::c_ulong;\n-\n     impl Timespec {\n-        pub fn now(clock: clock_t) -> Timespec {\n+        pub fn now(clock: libc::clockid_t) -> Timespec {\n             // Try to use 64-bit time in preparation for Y2038.\n             #[cfg(all(target_os = \"linux\", target_env = \"gnu\", target_pointer_width = \"32\"))]\n             {"}, {"sha": "2e64ae59aff24422cf1862c2e18b863b8201efe1", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -88,6 +88,14 @@ fn instant_math_is_associative() {\n     // Changing the order of instant math shouldn't change the results,\n     // especially when the expression reduces to X + identity.\n     assert_eq!((now + offset) - now, (now - now) + offset);\n+\n+    // On any platform, `Instant` should have the same resolution as `Duration` (e.g. 1 nanosecond)\n+    // or better. Otherwise, math will be non-associative (see #91417).\n+    let now = Instant::now();\n+    let provided_offset = Duration::from_nanos(1);\n+    let later = now + provided_offset;\n+    let measured_offset = later - now;\n+    assert_eq!(measured_offset, provided_offset);\n }\n \n #[test]"}, {"sha": "20efc23a53d9247faa89678a378e373009a0ee2e", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -384,8 +384,7 @@ img {\n \n .sidebar {\n \tfont-size: 0.875rem;\n-\twidth: 200px;\n-\tmin-width: 200px;\n+\tflex: 0 0 200px;\n \toverflow-y: scroll;\n \tposition: sticky;\n \theight: 100vh;\n@@ -394,12 +393,7 @@ img {\n }\n \n .rustdoc.source .sidebar {\n-\twidth: 50px;\n-\tmin-width: 0px;\n-\tmax-width: 300px;\n-\tflex-grow: 0;\n-\tflex-shrink: 0;\n-\tflex-basis: auto;\n+\tflex-basis: 50px;\n \tborder-right: 1px solid;\n \toverflow-x: hidden;\n \t/* The sidebar is by default hidden  */\n@@ -420,7 +414,7 @@ img {\n \n .source-sidebar-expanded .source .sidebar {\n \toverflow-y: auto;\n-\twidth: 300px;\n+\tflex-basis: 300px;\n }\n \n .source-sidebar-expanded .source .sidebar > *:not(#sidebar-toggle) {\n@@ -1701,6 +1695,7 @@ in storage.js\n \t\tz-index: 11;\n \t\t/* Reduce height slightly to account for mobile topbar. */\n \t\theight: calc(100vh - 45px);\n+\t\twidth: 200px;\n \t}\n \n \t/* The source view uses a different design for the sidebar toggle, and doesn't have a topbar,"}, {"sha": "abf8af77715c9eec5da0306c825e479abcf5db59", "filename": "src/test/rustdoc-gui/sidebar-source-code-display.goml", "status": "modified", "additions": 87, "deletions": 162, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -29,170 +29,95 @@ assert-local-storage: {\"rustdoc-source-sidebar-show\": \"true\"}\n // Now we check the display of the sidebar items.\n show-text: true\n \n-// First we start with the light theme.\n-local-storage: {\"rustdoc-theme\": \"light\", \"rustdoc-use-system-theme\": \"false\"}\n-reload:\n-// Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a.selected\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(255, 255, 255)\"},\n-)\n-// Without hover or focus.\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgba(0, 0, 0, 0)\"})\n-// With focus.\n-focus: \"#sidebar-toggle > button\"\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgb(224, 224, 224)\"})\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#sidebar-toggle > button\"\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgb(224, 224, 224)\"})\n-// Without hover.\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n-)\n-// With focus.\n-focus: \"#source-sidebar details[open] > .files a:not(.selected)\"\n-wait-for-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(224, 224, 224)\"},\n-)\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#source-sidebar details[open] > .files a:not(.selected)\"\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(224, 224, 224)\"},\n-)\n-// Without hover.\n-assert-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n-)\n-// With focus.\n-focus: \"#source-sidebar details[open] > .folders > details > summary\"\n-wait-for-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(224, 224, 224)\"},\n-)\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#source-sidebar details[open] > .folders > details > summary\"\n-assert-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(224, 224, 224)\"},\n+define-function: (\n+    \"check-colors\",\n+    (\n+        theme, color, color_hover, background, background_hover, background_toggle,\n+        background_toggle_hover,\n+    ),\n+    [\n+        (\"local-storage\", {\"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\"}),\n+        (\"reload\"),\n+        (\"wait-for-css\", (\"#sidebar-toggle\", {\"visibility\": \"visible\"})),\n+        (\"assert-css\", (\n+            \"#source-sidebar details[open] > .files a.selected\",\n+            {\"color\": |color_hover|, \"background-color\": |background|},\n+        )),\n+        // Without hover or focus.\n+        (\"assert-css\", (\"#sidebar-toggle > button\", {\"background-color\": |background_toggle|})),\n+        // With focus.\n+        (\"focus\", \"#sidebar-toggle > button\"),\n+        (\"assert-css\", (\"#sidebar-toggle > button\", {\"background-color\": |background_toggle_hover|})),\n+        (\"focus\", \".search-input\"),\n+        // With hover.\n+        (\"move-cursor-to\", \"#sidebar-toggle > button\"),\n+        (\"assert-css\", (\"#sidebar-toggle > button\", {\"background-color\": |background_toggle_hover|})),\n+        // Without hover.\n+        (\"assert-css\", (\n+            \"#source-sidebar details[open] > .files a:not(.selected)\",\n+            {\"color\": |color|, \"background-color\": |background_toggle|},\n+        )),\n+        // With focus.\n+        (\"focus\", \"#source-sidebar details[open] > .files a:not(.selected)\"),\n+        (\"wait-for-css\", (\n+            \"#source-sidebar details[open] > .files a:not(.selected)\",\n+            {\"color\": |color_hover|, \"background-color\": |background_hover|},\n+        )),\n+        (\"focus\", \".search-input\"),\n+        // With hover.\n+        (\"move-cursor-to\", \"#source-sidebar details[open] > .files a:not(.selected)\"),\n+        (\"assert-css\", (\n+            \"#source-sidebar details[open] > .files a:not(.selected)\",\n+            {\"color\": |color_hover|, \"background-color\": |background_hover|},\n+        )),\n+        // Without hover.\n+        (\"assert-css\", (\n+            \"#source-sidebar details[open] > .folders > details > summary\",\n+            {\"color\": |color|, \"background-color\": |background_toggle|},\n+        )),\n+        // With focus.\n+        (\"focus\", \"#source-sidebar details[open] > .folders > details > summary\"),\n+        (\"wait-for-css\", (\n+            \"#source-sidebar details[open] > .folders > details > summary\",\n+            {\"color\": |color_hover|, \"background-color\": |background_hover|},\n+        )),\n+        (\"focus\", \".search-input\"),\n+        // With hover.\n+        (\"move-cursor-to\", \"#source-sidebar details[open] > .folders > details > summary\"),\n+        (\"assert-css\", (\n+            \"#source-sidebar details[open] > .folders > details > summary\",\n+            {\"color\": |color_hover|, \"background-color\": |background_hover|},\n+        )),\n+    ],\n )\n \n-// Now with the dark theme.\n-local-storage: {\"rustdoc-theme\": \"dark\", \"rustdoc-use-system-theme\": \"false\"}\n-reload:\n-// Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n-assert-css: (\n-    \"#source-sidebar details[open] > .files > a.selected\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(51, 51, 51)\"},\n-)\n-// Without hover or focus.\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgba(0, 0, 0, 0)\"})\n-// With focus.\n-focus: \"#sidebar-toggle > button\"\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgb(103, 103, 103)\"})\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#sidebar-toggle > button\"\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgb(103, 103, 103)\"})\n-// Without hover.\n-assert-css: (\n-    \"#source-sidebar details[open] > .files > a:not(.selected)\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n-)\n-// With focus.\n-focus: \"#source-sidebar details[open] > .files a:not(.selected)\"\n-wait-for-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(68, 68, 68)\"},\n-)\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#source-sidebar details[open] > .files a:not(.selected)\"\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(68, 68, 68)\"},\n-)\n-// Without hover.\n-assert-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n-)\n-// With focus.\n-focus: \"#source-sidebar details[open] > .folders > details > summary\"\n-wait-for-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(68, 68, 68)\"},\n-)\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#source-sidebar details[open] > .folders > details > summary\"\n-assert-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(68, 68, 68)\"},\n-)\n-\n-// And finally with the ayu theme.\n-local-storage: {\"rustdoc-theme\": \"ayu\", \"rustdoc-use-system-theme\": \"false\"}\n-reload:\n-// Waiting for the sidebar to be displayed...\n-wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\"})\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a.selected\",\n-    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n-)\n-// Without hover or focus.\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgba(0, 0, 0, 0)\"})\n-// With focus.\n-focus: \"#sidebar-toggle > button\"\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgba(70, 70, 70, 0.33)\"})\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#sidebar-toggle > button\"\n-assert-css: (\"#sidebar-toggle > button\", {\"background-color\": \"rgba(70, 70, 70, 0.33)\"})\n-// Without hover.\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(197, 197, 197)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n-)\n-// With focus.\n-focus: \"#source-sidebar details[open] > .files a:not(.selected)\"\n-wait-for-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n-)\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#source-sidebar details[open] > .files a:not(.selected)\"\n-assert-css: (\n-    \"#source-sidebar details[open] > .files a:not(.selected)\",\n-    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n-)\n-// Without hover.\n-assert-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(197, 197, 197)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n-)\n-// With focus.\n-focus: \"#source-sidebar details[open] > .folders > details > summary\"\n-wait-for-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n-)\n-focus: \".search-input\"\n-// With hover.\n-move-cursor-to: \"#source-sidebar details[open] > .folders > details > summary\"\n-assert-css: (\n-    \"#source-sidebar details[open] > .folders > details > summary\",\n-    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n-)\n+call-function: (\"check-colors\", {\n+    \"theme\": \"light\",\n+    \"color\": \"rgb(0, 0, 0)\",\n+    \"color_hover\": \"rgb(0, 0, 0)\",\n+    \"background\": \"rgb(255, 255, 255)\",\n+    \"background_hover\": \"rgb(224, 224, 224)\",\n+    \"background_toggle\": \"rgba(0, 0, 0, 0)\",\n+    \"background_toggle_hover\": \"rgb(224, 224, 224)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"dark\",\n+    \"color\": \"rgb(221, 221, 221)\",\n+    \"color_hover\": \"rgb(221, 221, 221)\",\n+    \"background\": \"rgb(51, 51, 51)\",\n+    \"background_hover\": \"rgb(68, 68, 68)\",\n+    \"background_toggle\": \"rgba(0, 0, 0, 0)\",\n+    \"background_toggle_hover\": \"rgb(103, 103, 103)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"ayu\",\n+    \"color\": \"rgb(197, 197, 197)\",\n+    \"color_hover\": \"rgb(255, 180, 76)\",\n+    \"background\": \"rgb(20, 25, 31)\",\n+    \"background_hover\": \"rgb(20, 25, 31)\",\n+    \"background_toggle\": \"rgba(0, 0, 0, 0)\",\n+    \"background_toggle_hover\": \"rgba(70, 70, 70, 0.33)\",\n+})\n \n // Now checking on mobile devices.\n size: (500, 700)"}, {"sha": "b4ff8a222866a5ef787467690cbdf91ff85ed567", "filename": "src/test/ui/dyn-star/dont-unsize-coerce-dyn-star.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdont-unsize-coerce-dyn-star.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+\n+trait AddOne {\n+    fn add1(&mut self) -> usize;\n+}\n+\n+impl AddOne for usize {\n+    fn add1(&mut self) -> usize {\n+        *self += 1;\n+        *self\n+    }\n+}\n+\n+fn add_one(i: &mut (dyn* AddOne + '_)) -> usize {\n+    i.add1()\n+}\n+\n+fn main() {\n+    let mut x = 42usize as dyn* AddOne;\n+\n+    println!(\"{}\", add_one(&mut x));\n+    println!(\"{}\", add_one(&mut x));\n+}"}, {"sha": "1e8cafe1561e8a72e9d0803ba8260eef4a120070", "filename": "src/test/ui/dyn-star/unsize-into-ref-dyn-star.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fdyn-star%2Funsize-into-ref-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fdyn-star%2Funsize-into-ref-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Funsize-into-ref-dyn-star.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,9 @@\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    let i = 42 as &dyn* Debug;\n+    //~^ ERROR non-primitive cast: `i32` as `&dyn* Debug`\n+}"}, {"sha": "f6444a60a4654212148447ddededdfa1e00c3cc6", "filename": "src/test/ui/dyn-star/unsize-into-ref-dyn-star.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fdyn-star%2Funsize-into-ref-dyn-star.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fdyn-star%2Funsize-into-ref-dyn-star.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Funsize-into-ref-dyn-star.stderr?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,9 @@\n+error[E0605]: non-primitive cast: `i32` as `&dyn* Debug`\n+  --> $DIR/unsize-into-ref-dyn-star.rs:7:13\n+   |\n+LL |     let i = 42 as &dyn* Debug;\n+   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0605`."}, {"sha": "6a9fb991097fb4cd049a442fc266b290bf50dad5", "filename": "src/test/ui/parser/issue-103381.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fparser%2Fissue-103381.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fparser%2Fissue-103381.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103381.fixed?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+\n+#![feature(let_chains)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![allow(irrefutable_let_patterns)]\n+\n+fn err_some(b: bool, x: Option<u32>) {\n+    if b && let Some(x) = x {}\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn err_none(b: bool, x: Option<u32>) {\n+    if b && let None = x {}\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn err_bool_1() {\n+    if true && true { true } else { false };\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn err_bool_2() {\n+    if true && false { true } else { false };\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn should_ok_1() {\n+    if true && if let x = 1 { true } else { true } {}\n+}\n+\n+fn should_ok_2() {\n+    if true && if let 1 = 1 { true } else { true } {}\n+}\n+\n+fn should_ok_3() {\n+    if true && if true { true } else { false } {}\n+}\n+\n+fn shoule_match_ok() {\n+    #[cfg(feature = \"full\")]\n+    {\n+        let a = 1;\n+        let b = 2;\n+        if match a {\n+            1 if b == 1 => true,\n+            _ => false,\n+        } && if a > 1 { true } else { false }\n+        {\n+            true\n+        }\n+    }\n+}\n+\n+fn should_ok_in_nested() {\n+    if true && if true { true } else { false } { true } else { false };\n+}\n+\n+fn main() {}"}, {"sha": "bf79e10103e13c701c2367209b4265273fdcd60b", "filename": "src/test/ui/parser/issue-103381.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fparser%2Fissue-103381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fparser%2Fissue-103381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103381.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+\n+#![feature(let_chains)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+#![allow(irrefutable_let_patterns)]\n+\n+fn err_some(b: bool, x: Option<u32>) {\n+    if b && if let Some(x) = x {}\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn err_none(b: bool, x: Option<u32>) {\n+    if b && if let None = x {}\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn err_bool_1() {\n+    if true && if true { true } else { false };\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn err_bool_2() {\n+    if true && if false { true } else { false };\n+    //~^ ERROR unexpected `if` in the condition expression\n+}\n+\n+fn should_ok_1() {\n+    if true && if let x = 1 { true } else { true } {}\n+}\n+\n+fn should_ok_2() {\n+    if true && if let 1 = 1 { true } else { true } {}\n+}\n+\n+fn should_ok_3() {\n+    if true && if true { true } else { false } {}\n+}\n+\n+fn shoule_match_ok() {\n+    #[cfg(feature = \"full\")]\n+    {\n+        let a = 1;\n+        let b = 2;\n+        if match a {\n+            1 if b == 1 => true,\n+            _ => false,\n+        } && if a > 1 { true } else { false }\n+        {\n+            true\n+        }\n+    }\n+}\n+\n+fn should_ok_in_nested() {\n+    if true && if true { true } else { false } { true } else { false };\n+}\n+\n+fn main() {}"}, {"sha": "85fcc18e76b57f385122ad764f9a5a23332e54d8", "filename": "src/test/ui/parser/issue-103381.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fparser%2Fissue-103381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftest%2Fui%2Fparser%2Fissue-103381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103381.stderr?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -0,0 +1,50 @@\n+error: unexpected `if` in the condition expression\n+  --> $DIR/issue-103381.rs:9:12\n+   |\n+LL |     if b && if let Some(x) = x {}\n+   |            ^^^^\n+   |\n+help: remove the `if`\n+   |\n+LL -     if b && if let Some(x) = x {}\n+LL +     if b && let Some(x) = x {}\n+   |\n+\n+error: unexpected `if` in the condition expression\n+  --> $DIR/issue-103381.rs:14:12\n+   |\n+LL |     if b && if let None = x {}\n+   |            ^^^^\n+   |\n+help: remove the `if`\n+   |\n+LL -     if b && if let None = x {}\n+LL +     if b && let None = x {}\n+   |\n+\n+error: unexpected `if` in the condition expression\n+  --> $DIR/issue-103381.rs:19:15\n+   |\n+LL |     if true && if true { true } else { false };\n+   |               ^^^^\n+   |\n+help: remove the `if`\n+   |\n+LL -     if true && if true { true } else { false };\n+LL +     if true && true { true } else { false };\n+   |\n+\n+error: unexpected `if` in the condition expression\n+  --> $DIR/issue-103381.rs:24:15\n+   |\n+LL |     if true && if false { true } else { false };\n+   |               ^^^^\n+   |\n+help: remove the `if`\n+   |\n+LL -     if true && if false { true } else { false };\n+LL +     if true && false { true } else { false };\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "22a5aa5351ad5b1c044319975a19c81869ddba15", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -79,22 +79,22 @@ pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n         SimplifiedTypeGen::StrSimplifiedType,\n     ]\n     .iter()\n-    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n-    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n-        let lang_item_path = cx.get_def_path(*item_def_id);\n+    .flat_map(|&ty| cx.tcx.incoherent_impls(ty).iter().copied());\n+    for item_def_id in lang_items.iter().map(|(_, def_id)| def_id).chain(incoherent_impls) {\n+        let lang_item_path = cx.get_def_path(item_def_id);\n         if path_syms.starts_with(&lang_item_path) {\n             if let [item] = &path_syms[lang_item_path.len()..] {\n                 if matches!(\n-                    cx.tcx.def_kind(*item_def_id),\n+                    cx.tcx.def_kind(item_def_id),\n                     DefKind::Mod | DefKind::Enum | DefKind::Trait\n                 ) {\n-                    for child in cx.tcx.module_children(*item_def_id) {\n+                    for child in cx.tcx.module_children(item_def_id) {\n                         if child.ident.name == *item {\n                             return true;\n                         }\n                     }\n                 } else {\n-                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n+                    for child in cx.tcx.associated_item_def_ids(item_def_id) {\n                         if cx.tcx.item_name(*child) == *item {\n                             return true;\n                         }"}, {"sha": "cfba7fa8791de3c7567f09c8a41f643f7cd38427", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, Local, Mutability, Node};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -91,7 +91,7 @@ impl UnnecessaryDefPath {\n     #[allow(clippy::too_many_lines)]\n     fn check_call(&mut self, cx: &LateContext<'_>, func: &Expr<'_>, args: &[Expr<'_>], span: Span) {\n         enum Item {\n-            LangItem(Symbol),\n+            LangItem(&'static str),\n             DiagnosticItem(Symbol),\n         }\n         static PATHS: &[&[&str]] = &[\n@@ -325,18 +325,9 @@ fn inherent_def_path_res(cx: &LateContext<'_>, segments: &[&str]) -> Option<DefI\n     })\n }\n \n-fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<Symbol> {\n-    if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-        let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n-        let item_name = cx\n-            .tcx\n-            .adt_def(lang_items)\n-            .variants()\n-            .iter()\n-            .nth(lang_item)\n-            .unwrap()\n-            .name;\n-        Some(item_name)\n+fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<&'static str> {\n+    if let Some((lang_item, _)) = cx.tcx.lang_items().iter().find(|(_, id)| *id == def_id) {\n+        Some(lang_item.variant_name())\n     } else {\n         None\n     }"}, {"sha": "e474f370a5d172cbc4c2b4e469f1bb2daa91483b", "filename": "src/tools/clippy/tests/ui-internal/unnecessary_def_path.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path.fixed?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -48,14 +48,14 @@ fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = is_type_lang_item(cx, ty, LangItem::OwnedBox);\n     let _ = is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit);\n \n-    let _ = cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did);\n+    let _ = cx.tcx.lang_items().get(LangItem::OwnedBox) == Some(did);\n     let _ = cx.tcx.is_diagnostic_item(sym::Option, did);\n-    let _ = cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did);\n+    let _ = cx.tcx.lang_items().get(LangItem::OptionSome) == Some(did);\n \n     let _ = is_trait_method(cx, expr, sym::AsRef);\n \n     let _ = is_path_diagnostic_item(cx, expr, sym::Option);\n-    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id));\n+    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().get(LangItem::IteratorNext) == Some(id));\n     let _ = is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome);\n }\n "}, {"sha": "3ca29f099771b9607ab423d6087c0bb2c95cabaf", "filename": "src/tools/clippy/tests/ui-internal/unnecessary_def_path.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path.stderr?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -57,7 +57,7 @@ error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:51:13\n    |\n LL |     let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().get(LangItem::OwnedBox) == Some(did)`\n \n error: use of a def path to a diagnostic item\n   --> $DIR/unnecessary_def_path.rs:52:13\n@@ -69,7 +69,7 @@ error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:53:13\n    |\n LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().get(LangItem::OptionSome) == Some(did)`\n    |\n    = help: if this `DefId` came from a constructor expression or pattern then the parent `DefId` should be used instead\n \n@@ -89,7 +89,7 @@ error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:58:13\n    |\n LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id))`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().get(LangItem::IteratorNext) == Some(id))`\n \n error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:59:13"}, {"sha": "2a240cc249b0c768f084dab5b6f220ae53a59399", "filename": "src/tools/clippy/tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b833ad56f46a0bbe0e8729512812a161e7dae28a/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=b833ad56f46a0bbe0e8729512812a161e7dae28a", "patch": "@@ -1,10 +1,10 @@\n-error: hardcoded path to a language item\n-  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n    |\n-LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n-   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: convert all references to use `LangItem::DerefMut`\n+   = help: convert all references to use `sym::Deref`\n    = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n \n error: hardcoded path to a diagnostic item\n@@ -15,13 +15,13 @@ LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\",\n    |\n    = help: convert all references to use `sym::deref_method`\n \n-error: hardcoded path to a diagnostic item\n-  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n+error: hardcoded path to a language item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n    |\n-LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: convert all references to use `sym::Deref`\n+   = help: convert all references to use `LangItem::DerefMut`\n \n error: aborting due to 3 previous errors\n "}]}