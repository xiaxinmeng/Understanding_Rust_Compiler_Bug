{"sha": "c133b2110b79d7a735032e4af431ee3a1143f3ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzNiMjExMGI3OWQ3YTczNTAzMmU0YWY0MzFlZTNhMTE0M2YzY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-09T22:15:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-09T22:15:12Z"}, "message": "auto merge of #20776 : kmcallister/rust/macro-cleanup, r=alexcrichton\n\nr? @alexcrichton. This passes tests for me.", "tree": {"sha": "310ecc0eaf781b0dda71e5f04ab05ee61788925a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/310ecc0eaf781b0dda71e5f04ab05ee61788925a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c133b2110b79d7a735032e4af431ee3a1143f3ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c133b2110b79d7a735032e4af431ee3a1143f3ce", "html_url": "https://github.com/rust-lang/rust/commit/c133b2110b79d7a735032e4af431ee3a1143f3ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c133b2110b79d7a735032e4af431ee3a1143f3ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73a25f55ad748b4d3516417c711b99ce446591af", "url": "https://api.github.com/repos/rust-lang/rust/commits/73a25f55ad748b4d3516417c711b99ce446591af", "html_url": "https://github.com/rust-lang/rust/commit/73a25f55ad748b4d3516417c711b99ce446591af"}, {"sha": "a96a8b2b2526aaa631183f71aef9acf390b61f48", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96a8b2b2526aaa631183f71aef9acf390b61f48", "html_url": "https://github.com/rust-lang/rust/commit/a96a8b2b2526aaa631183f71aef9acf390b61f48"}], "stats": {"total": 198, "additions": 15, "deletions": 183}, "files": [{"sha": "9b9af2c65cad5773fa2b98ed4a34f18865409a7c", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=c133b2110b79d7a735032e4af431ee3a1143f3ce", "patch": "@@ -440,14 +440,18 @@ to print \"I am never printed\" and to run forever.\n \n # Scoping and macro import/export\n \n-Macros occupy a single global namespace. The interaction with Rust's system of\n-modules and crates is somewhat complex.\n+Macros are expanded at an early stage in compilation, before name resolution.\n+One downside is that scoping works differently for macros, compared to other\n+constructs in the language.\n \n Definition and expansion of macros both happen in a single depth-first,\n lexical-order traversal of a crate's source. So a macro defined at module scope\n is visible to any subsequent code in the same module, which includes the body\n of any subsequent child `mod` items.\n \n+A macro defined within the body of a single `fn`, or anywhere else not at\n+module scope, is visible only within that item.\n+\n If a module has the `macro_use` attribute, its macros are also visible in its\n parent module after the child's `mod` item. If the parent also has `macro_use`\n then the macros will be visible in the grandparent after the parent's `mod`"}, {"sha": "3d3b9f8cf658577389f7e89f9c28310460d0a2a7", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=c133b2110b79d7a735032e4af431ee3a1143f3ce", "patch": "@@ -49,15 +49,16 @@ macro_rules! panic {\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n-    ($cond:expr, $($arg:expr),+) => (\n+    ($cond:expr, $($arg:tt)+) => (\n         if !$cond {\n-            panic!($($arg),+)\n+            panic!($($arg)+)\n         }\n     );\n }\n@@ -75,6 +76,7 @@ macro_rules! assert {\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n@@ -116,6 +118,7 @@ macro_rules! assert_eq {\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n+#[stable]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n }\n@@ -227,6 +230,7 @@ macro_rules! writeln {\n /// }\n /// ```\n #[macro_export]\n+#[unstable = \"relationship with panic is unclear\"]\n macro_rules! unreachable {\n     () => ({\n         panic!(\"internal error: entered unreachable code\")\n@@ -242,6 +246,7 @@ macro_rules! unreachable {\n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n+#[unstable = \"relationship with panic is unclear\"]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }"}, {"sha": "e15e611adc08cfc8aacc743886e77656773e1f83", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c133b2110b79d7a735032e4af431ee3a1143f3ce", "patch": "@@ -122,7 +122,8 @@\n extern crate log;\n \n #[macro_use]\n-#[macro_reexport(write, writeln)]\n+#[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n+    unreachable, unimplemented, write, writeln)]\n extern crate core;\n \n #[macro_use]"}, {"sha": "a420c841d25e3196b9bbeb8ce82f324277271505", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c133b2110b79d7a735032e4af431ee3a1143f3ce/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c133b2110b79d7a735032e4af431ee3a1143f3ce", "patch": "@@ -60,184 +60,6 @@ macro_rules! panic {\n     });\n }\n \n-/// Ensure that a boolean expression is `true` at runtime.\n-///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n-/// evaluated to `true` at runtime.\n-///\n-/// # Example\n-///\n-/// ```\n-/// // the panic message for these assertions is the stringified value of the\n-/// // expression given.\n-/// assert!(true);\n-/// # fn some_computation() -> bool { true }\n-/// assert!(some_computation());\n-///\n-/// // assert with a custom message\n-/// # let x = true;\n-/// assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n-/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! assert {\n-    ($cond:expr) => (\n-        if !$cond {\n-            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n-        }\n-    );\n-    ($cond:expr, $($arg:tt)+) => (\n-        if !$cond {\n-            panic!($($arg)+)\n-        }\n-    );\n-}\n-\n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n-///\n-/// On panic, this macro will print the values of the expressions.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n-/// assert_eq!(a, b);\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! assert_eq {\n-    ($left:expr , $right:expr) => ({\n-        match (&($left), &($right)) {\n-            (left_val, right_val) => {\n-                // check both directions of equality....\n-                if !((*left_val == *right_val) &&\n-                     (*right_val == *left_val)) {\n-                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{:?}`, right: `{:?}`)\", *left_val, *right_val)\n-                }\n-            }\n-        }\n-    })\n-}\n-\n-/// Ensure that a boolean expression is `true` at runtime.\n-///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n-/// evaluated to `true` at runtime.\n-///\n-/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n-/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n-/// checks that are too expensive to be present in a release build but may be\n-/// helpful during development.\n-///\n-/// # Example\n-///\n-/// ```\n-/// // the panic message for these assertions is the stringified value of the\n-/// // expression given.\n-/// debug_assert!(true);\n-/// # fn some_expensive_computation() -> bool { true }\n-/// debug_assert!(some_expensive_computation());\n-///\n-/// // assert with a custom message\n-/// # let x = true;\n-/// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n-/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n-}\n-\n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n-///\n-/// On panic, this macro will print the values of the expressions.\n-///\n-/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n-/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n-/// useful for checks that are too expensive to be present in a release build\n-/// but may be helpful during development.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n-/// debug_assert_eq!(a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! debug_assert_eq {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n-}\n-\n-/// A utility macro for indicating unreachable code.\n-///\n-/// This is useful any time that the compiler can't determine that some code is unreachable. For\n-/// example:\n-///\n-/// * Match arms with guard conditions.\n-/// * Loops that dynamically terminate.\n-/// * Iterators that dynamically terminate.\n-///\n-/// # Panics\n-///\n-/// This will always panic.\n-///\n-/// # Examples\n-///\n-/// Match arms:\n-///\n-/// ```rust\n-/// fn foo(x: Option<int>) {\n-///     match x {\n-///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n-///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n-///         Some(_)           => unreachable!(), // compile error if commented out\n-///         None              => println!(\"None\")\n-///     }\n-/// }\n-/// ```\n-///\n-/// Iterators:\n-///\n-/// ```rust\n-/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n-///     for i in std::iter::count(0_u32, 1) {\n-///         if 3*i < i { panic!(\"u32 overflow\"); }\n-///         if x < 3*i { return i-1; }\n-///     }\n-///     unreachable!();\n-/// }\n-/// ```\n-#[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n-macro_rules! unreachable {\n-    () => ({\n-        panic!(\"internal error: entered unreachable code\")\n-    });\n-    ($msg:expr) => ({\n-        unreachable!(\"{}\", $msg)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n-    });\n-}\n-\n-/// A standardised placeholder for marking unfinished code. It panics with the\n-/// message `\"not yet implemented\"` when executed.\n-#[macro_export]\n-#[unstable = \"relationship with panic is unclear\"]\n-macro_rules! unimplemented {\n-    () => (panic!(\"not yet implemented\"))\n-}\n-\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///"}]}