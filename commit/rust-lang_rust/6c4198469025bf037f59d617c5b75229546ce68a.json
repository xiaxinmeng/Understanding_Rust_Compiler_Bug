{"sha": "6c4198469025bf037f59d617c5b75229546ce68a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDE5ODQ2OTAyNWJmMDM3ZjU5ZDYxN2M1Yjc1MjI5NTQ2Y2U2OGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-10-31T18:09:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-10T17:28:48Z"}, "message": "std: Refactor process spawning on Unix\n\n* Build up the argp/envp pointers while the `Command` is being constructed\n  rather than only when `spawn` is called. This will allow better sharing of\n  code between fork/exec paths.\n* Rename `child_after_fork` to `exec` and have it only perform the exec half of\n  the spawning. This also means the return type has changed to `io::Error`\n  rather than `!` to represent errors that happen.", "tree": {"sha": "851ce22cb1aab5adf8259a5414fb737aa62a5286", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/851ce22cb1aab5adf8259a5414fb737aa62a5286"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c4198469025bf037f59d617c5b75229546ce68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c4198469025bf037f59d617c5b75229546ce68a", "html_url": "https://github.com/rust-lang/rust/commit/6c4198469025bf037f59d617c5b75229546ce68a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c4198469025bf037f59d617c5b75229546ce68a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "096dbf84c7acc78283adfa46eecd41d7355f6f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/096dbf84c7acc78283adfa46eecd41d7355f6f3e", "html_url": "https://github.com/rust-lang/rust/commit/096dbf84c7acc78283adfa46eecd41d7355f6f3e"}], "stats": {"total": 334, "additions": 166, "deletions": 168}, "files": [{"sha": "c64471cc729af2c954ed3eaa802fbcd23c73e913", "filename": "src/libstd/process.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=6c4198469025bf037f59d617c5b75229546ce68a", "patch": "@@ -209,7 +209,9 @@ impl Command {\n     /// Add multiple arguments to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {\n-        self.inner.args(args.iter().map(AsRef::as_ref));\n+        for arg in args {\n+            self.arg(arg.as_ref());\n+        }\n         self\n     }\n "}, {"sha": "97938b07f8b9507b4954b8ff7029686acf9730f9", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=6c4198469025bf037f59d617c5b75229546ce68a", "patch": "@@ -12,8 +12,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use os::unix::raw::{uid_t, gid_t};\n use os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use os::unix::raw::{uid_t, gid_t};\n use process;\n use sys;\n use sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};"}, {"sha": "ed512b834f83be666ba476e83f4b162d7ce1b609", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 162, "deletions": 163, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=6c4198469025bf037f59d617c5b75229546ce68a", "patch": "@@ -13,27 +13,46 @@\n use prelude::v1::*;\n use os::unix::prelude::*;\n \n-use collections::HashMap;\n+use collections::hash_map::{HashMap, Entry};\n use env;\n use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n+use libc::{self, pid_t, c_int, gid_t, uid_t, c_char};\n+use mem;\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n-use sys::pipe::AnonPipe;\n use sys::{self, cvt, cvt_r};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Clone)]\n pub struct Command {\n+    // Currently we try hard to ensure that the call to `.exec()` doesn't\n+    // actually allocate any memory. While many platforms try to ensure that\n+    // memory allocation works after a fork in a multithreaded process, it's\n+    // been observed to be buggy and somewhat unreliable, so we do our best to\n+    // just not do it at all!\n+    //\n+    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n+    // what's gonna get passed to `execvp`. The `argv` array starts with the\n+    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n+    // also null-terminated.\n+    //\n+    // Right now we don't support removing arguments, so there's no much fancy\n+    // support there, but we support adding and removing environment variables,\n+    // so a side table is used to track where in the `envp` array each key is\n+    // located. Whenever we add a key we update it in place if it's already\n+    // present, and whenever we remove a key we update the locations of all\n+    // other keys.\n     program: CString,\n     args: Vec<CString>,\n-    env: Option<HashMap<OsString, OsString>>, // Guaranteed to have no NULs.\n+    env: Option<HashMap<OsString, (usize, CString)>>,\n+    argv: Vec<*const c_char>,\n+    envp: Option<Vec<*const c_char>>,\n+\n     cwd: Option<CString>,\n     uid: Option<uid_t>,\n     gid: Option<gid_t>,\n@@ -44,10 +63,13 @@ pub struct Command {\n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         let mut saw_nul = false;\n+        let program = os2c(program, &mut saw_nul);\n         Command {\n-            program: os2c(program, &mut saw_nul),\n+            argv: vec![program.as_ptr(), 0 as *const _],\n+            program: program,\n             args: Vec::new(),\n             env: None,\n+            envp: None,\n             cwd: None,\n             uid: None,\n             gid: None,\n@@ -57,40 +79,79 @@ impl Command {\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(os2c(arg, &mut self.saw_nul));\n+        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n+        // pointer.\n+        let arg = os2c(arg, &mut self.saw_nul);\n+        self.argv[self.args.len() + 1] = arg.as_ptr();\n+        self.argv.push(0 as *const _);\n+\n+        // Also make sure we keep track of the owned value to schedule a\n+        // destructor for this memory.\n+        self.args.push(arg);\n     }\n-    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        let mut saw_nul = self.saw_nul;\n-        self.args.extend(args.map(|arg| os2c(arg, &mut saw_nul)));\n-        self.saw_nul = saw_nul;\n-    }\n-    fn init_env_map(&mut self) {\n+\n+    fn init_env_map(&mut self) -> (&mut HashMap<OsString, (usize, CString)>,\n+                                   &mut Vec<*const c_char>) {\n         if self.env.is_none() {\n-            // Will not add NULs to env: preexisting environment will not contain any.\n-            self.env = Some(env::vars_os().collect());\n+            let mut map = HashMap::new();\n+            let mut envp = Vec::new();\n+            for (k, v) in env::vars_os() {\n+                let s = pair_to_key(&k, &v, &mut self.saw_nul);\n+                envp.push(s.as_ptr());\n+                map.insert(k, (envp.len() - 1, s));\n+            }\n+            envp.push(0 as *const _);\n+            self.env = Some(map);\n+            self.envp = Some(envp);\n         }\n+        (self.env.as_mut().unwrap(), self.envp.as_mut().unwrap())\n     }\n-    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n-        let k = OsString::from_vec(os2c(key, &mut self.saw_nul).into_bytes());\n-        let v = OsString::from_vec(os2c(val, &mut self.saw_nul).into_bytes());\n \n-        // Will not add NULs to env: return without inserting if any were seen.\n-        if self.saw_nul {\n-            return;\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        let new_key = pair_to_key(key, val, &mut self.saw_nul);\n+        let (map, envp) = self.init_env_map();\n+\n+        // If `key` is already present then we we just update `envp` in place\n+        // (and store the owned value), but if it's not there we override the\n+        // trailing NULL pointer, add a new NULL pointer, and store where we\n+        // were located.\n+        match map.entry(key.to_owned()) {\n+            Entry::Occupied(mut e) => {\n+                let (i, ref mut s) = *e.get_mut();\n+                envp[i] = new_key.as_ptr();\n+                *s = new_key;\n+            }\n+            Entry::Vacant(e) => {\n+                let len = envp.len();\n+                envp[len - 1] = new_key.as_ptr();\n+                envp.push(0 as *const _);\n+                e.insert((len - 1, new_key));\n+            }\n         }\n-\n-        self.init_env_map();\n-        self.env.as_mut()\n-            .unwrap()\n-            .insert(k, v);\n     }\n+\n     pub fn env_remove(&mut self, key: &OsStr) {\n-        self.init_env_map();\n-        self.env.as_mut().unwrap().remove(key);\n+        let (map, envp) = self.init_env_map();\n+\n+        // If we actually ended up removing a key, then we need to update the\n+        // position of all keys that come after us in `envp` because they're all\n+        // one element sooner now.\n+        if let Some((i, _)) = map.remove(key) {\n+            envp.remove(i);\n+\n+            for (_, &mut (ref mut j, _)) in map.iter_mut() {\n+                if *j >= i {\n+                    *j -= 1;\n+                }\n+            }\n+        }\n     }\n+\n     pub fn env_clear(&mut self) {\n-        self.env = Some(HashMap::new())\n+        self.env = Some(HashMap::new());\n+        self.envp = Some(vec![0 as *const _]);\n     }\n+\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(os2c(dir, &mut self.saw_nul));\n     }\n@@ -112,6 +173,18 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n     })\n }\n \n+fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n+    let (key, value) = (key.as_bytes(), value.as_bytes());\n+    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n+    v.extend(key);\n+    v.push(b'=');\n+    v.extend(value);\n+    CString::new(v).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"foo=bar\").unwrap()\n+    })\n+}\n+\n impl fmt::Debug for Command {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{:?}\", self.program));\n@@ -218,20 +291,28 @@ impl Process {\n             return Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"));\n         }\n \n-        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        let (envp, _a, _b) = make_envp(cfg.env.as_ref());\n-        let (argv, _a) = make_argv(&cfg.program, &cfg.args);\n         let (input, output) = try!(sys::pipe::anon_pipe());\n \n         let pid = unsafe {\n-            match libc::fork() {\n+            match try!(cvt(libc::fork())) {\n                 0 => {\n                     drop(input);\n-                    Process::child_after_fork(cfg, output, argv, envp, dirp,\n-                                              in_fd, out_fd, err_fd)\n+                    let err = Process::exec(cfg, in_fd, out_fd, err_fd);\n+                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                    // we want to be sure we *don't* run at_exit destructors as\n+                    // we're being torn down regardless\n+                    assert!(output.write(&bytes).is_ok());\n+                    libc::_exit(1)\n                 }\n-                n if n < 0 => return Err(Error::last_os_error()),\n                 n => n,\n             }\n         };\n@@ -306,29 +387,15 @@ impl Process {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke libc::exit)\n-    unsafe fn child_after_fork(cfg: &Command,\n-                               mut output: AnonPipe,\n-                               argv: *const *const libc::c_char,\n-                               envp: *const libc::c_void,\n-                               dirp: *const libc::c_char,\n-                               in_fd: Stdio,\n-                               out_fd: Stdio,\n-                               err_fd: Stdio) -> ! {\n-        fn fail(output: &mut AnonPipe) -> ! {\n-            let errno = sys::os::errno() as u32;\n-            let bytes = [\n-                (errno >> 24) as u8,\n-                (errno >> 16) as u8,\n-                (errno >>  8) as u8,\n-                (errno >>  0) as u8,\n-                CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-            ];\n-            // pipe I/O up to PIPE_BUF bytes should be atomic, and then we want\n-            // to be sure we *don't* run at_exit destructors as we're being torn\n-            // down regardless\n-            assert!(output.write(&bytes).is_ok());\n-            unsafe { libc::_exit(1) }\n+    unsafe fn exec(cfg: &Command,\n+                   in_fd: Stdio,\n+                   out_fd: Stdio,\n+                   err_fd: Stdio) -> io::Error {\n+        macro_rules! try {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return e,\n+            })\n         }\n \n         // Make sure that the source descriptors are not an stdio descriptor,\n@@ -337,30 +404,30 @@ impl Process {\n         // suppose we want the child's stderr to be the parent's stdout, and\n         // the child's stdout to be the parent's stderr. No matter which we\n         // dup first, the second will get overwritten prematurely.\n-        let maybe_migrate = |src: Stdio, output: &mut AnonPipe| {\n+        let maybe_migrate = |src: Stdio| {\n             match src {\n                 Stdio::Raw(fd @ libc::STDIN_FILENO) |\n                 Stdio::Raw(fd @ libc::STDOUT_FILENO) |\n                 Stdio::Raw(fd @ libc::STDERR_FILENO) => {\n-                    let fd = match cvt_r(|| libc::dup(fd)) {\n-                        Ok(fd) => fd,\n-                        Err(_) => fail(output),\n-                    };\n-                    let fd = FileDesc::new(fd);\n-                    fd.set_cloexec();\n-                    Stdio::Raw(fd.into_raw())\n-                },\n-\n+                    cvt_r(|| libc::dup(fd)).map(|fd| {\n+                        let fd = FileDesc::new(fd);\n+                        fd.set_cloexec();\n+                        Stdio::Raw(fd.into_raw())\n+                    })\n+                }\n                 s @ Stdio::None |\n                 s @ Stdio::Inherit |\n-                s @ Stdio::Raw(_) => s,\n+                s @ Stdio::Raw(_) => Ok(s),\n             }\n         };\n+        let in_fd = try!(maybe_migrate(in_fd));\n+        let out_fd = try!(maybe_migrate(out_fd));\n+        let err_fd = try!(maybe_migrate(err_fd));\n \n         let setup = |src: Stdio, dst: c_int| {\n             match src {\n-                Stdio::Inherit => true,\n-                Stdio::Raw(fd) => cvt_r(|| libc::dup2(fd, dst)).is_ok(),\n+                Stdio::Inherit => Ok(()),\n+                Stdio::Raw(fd) => cvt_r(|| libc::dup2(fd, dst)).map(|_| ()),\n \n                 // If a stdio file descriptor is set to be ignored, we open up\n                 // /dev/null into that file descriptor. Otherwise, the first\n@@ -373,29 +440,18 @@ impl Process {\n                     opts.write(dst != libc::STDIN_FILENO);\n                     let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n                                                     as *const _);\n-                    if let Ok(f) = File::open_c(devnull, &opts) {\n-                        cvt_r(|| libc::dup2(f.fd().raw(), dst)).is_ok()\n-                    } else {\n-                        false\n-                    }\n+                    File::open_c(devnull, &opts).and_then(|f| {\n+                        cvt_r(|| libc::dup2(f.fd().raw(), dst)).map(|_| ())\n+                    })\n                 }\n             }\n         };\n-\n-        // Make sure we migrate all source descriptors before\n-        // we start overwriting them\n-        let in_fd = maybe_migrate(in_fd, &mut output);\n-        let out_fd = maybe_migrate(out_fd, &mut output);\n-        let err_fd = maybe_migrate(err_fd, &mut output);\n-\n-        if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-        if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-        if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+        try!(setup(in_fd, libc::STDIN_FILENO));\n+        try!(setup(out_fd, libc::STDOUT_FILENO));\n+        try!(setup(err_fd, libc::STDERR_FILENO));\n \n         if let Some(u) = cfg.gid {\n-            if libc::setgid(u as libc::gid_t) != 0 {\n-                fail(&mut output);\n-            }\n+            try!(cvt(libc::setgid(u as gid_t)));\n         }\n         if let Some(u) = cfg.uid {\n             // When dropping privileges from root, the `setgroups` call\n@@ -407,26 +463,23 @@ impl Process {\n             // privilege dropping function.\n             let _ = libc::setgroups(0, ptr::null());\n \n-            if libc::setuid(u as libc::uid_t) != 0 {\n-                fail(&mut output);\n-            }\n+            try!(cvt(libc::setuid(u as uid_t)));\n         }\n         if cfg.session_leader {\n             // Don't check the error of setsid because it fails if we're the\n             // process leader already. We just forked so it shouldn't return\n             // error, but ignore it anyway.\n             let _ = libc::setsid();\n         }\n-        if !dirp.is_null() && libc::chdir(dirp) == -1 {\n-            fail(&mut output);\n+        if let Some(ref cwd) = cfg.cwd {\n+            try!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n-        if !envp.is_null() {\n-            *sys::os::environ() = envp as *const _;\n+        if let Some(ref envp) = cfg.envp {\n+            *sys::os::environ() = envp.as_ptr();\n         }\n \n-        #[cfg(not(target_os = \"nacl\"))]\n-        unsafe fn reset_signal_handling(output: &mut AnonPipe) {\n-            use mem;\n+        // NaCl has no signal support.\n+        if cfg!(not(target_os = \"nacl\")) {\n             // Reset signal handling so the child process starts in a\n             // standardized state. libstd ignores SIGPIPE, and signal-handling\n             // libraries often set a mask. Child processes inherit ignored\n@@ -435,23 +488,17 @@ impl Process {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set: libc::sigset_t = mem::uninitialized();\n-            if libc::sigemptyset(&mut set) != 0 ||\n-                libc::pthread_sigmask(libc::SIG_SETMASK, &set, ptr::null_mut()) != 0 ||\n-                libc::signal(\n-                    libc::SIGPIPE, mem::transmute(libc::SIG_DFL)\n-                        ) == mem::transmute(libc::SIG_ERR)\n-            {\n-                fail(output);\n+            try!(cvt(libc::sigemptyset(&mut set)));\n+            try!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                           ptr::null_mut())));\n+            let ret = libc::signal(libc::SIGPIPE, libc::SIG_DFL);\n+            if ret == libc::SIG_ERR {\n+                return io::Error::last_os_error()\n             }\n         }\n-        #[cfg(target_os = \"nacl\")]\n-        unsafe fn reset_signal_handling(_output: &mut AnonPipe) {\n-            // NaCl has no signal support.\n-        }\n-        reset_signal_handling(&mut output);\n \n-        let _ = libc::execvp(*argv, argv);\n-        fail(&mut output)\n+        libc::execvp(cfg.argv[0], cfg.argv.as_ptr());\n+        io::Error::last_os_error()\n     }\n \n     pub fn id(&self) -> u32 {\n@@ -477,54 +524,6 @@ impl Process {\n     }\n }\n \n-fn make_argv(prog: &CString, args: &[CString])\n-             -> (*const *const libc::c_char, Vec<*const libc::c_char>)\n-{\n-    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n-\n-    // Convert the CStrings into an array of pointers. Also return the\n-    // vector that owns the raw pointers, to ensure they live long\n-    // enough.\n-    ptrs.push(prog.as_ptr());\n-    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n-\n-    // Add a terminating null pointer (required by libc).\n-    ptrs.push(ptr::null());\n-\n-    (ptrs.as_ptr(), ptrs)\n-}\n-\n-fn make_envp(env: Option<&HashMap<OsString, OsString>>)\n-             -> (*const c_void, Vec<Vec<u8>>, Vec<*const libc::c_char>)\n-{\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\0\" strings. As with make_argv, we\n-    // return two vectors that own the data to ensure that they live\n-    // long enough.\n-    if let Some(env) = env {\n-        let mut tmps = Vec::with_capacity(env.len());\n-\n-        for pair in env {\n-            let mut kv = Vec::new();\n-            kv.extend_from_slice(pair.0.as_bytes());\n-            kv.push('=' as u8);\n-            kv.extend_from_slice(pair.1.as_bytes());\n-            kv.push(0); // terminating null\n-            tmps.push(kv);\n-        }\n-\n-        let mut ptrs: Vec<*const libc::c_char> =\n-            tmps.iter()\n-                .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                .collect();\n-        ptrs.push(ptr::null());\n-\n-        (ptrs.as_ptr() as *const _, tmps, ptrs)\n-    } else {\n-        (ptr::null(), Vec::new(), Vec::new())\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "6a04aa2f2c4f3aa5516841b17052e939bff1b91b", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4198469025bf037f59d617c5b75229546ce68a/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=6c4198469025bf037f59d617c5b75229546ce68a", "patch": "@@ -74,9 +74,6 @@ impl Command {\n     pub fn arg(&mut self, arg: &OsStr) {\n         self.args.push(arg.to_os_string())\n     }\n-    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        self.args.extend(args.map(OsStr::to_os_string))\n-    }\n     fn init_env_map(&mut self){\n         if self.env.is_none() {\n             self.env = Some(env::vars_os().map(|(key, val)| {"}]}