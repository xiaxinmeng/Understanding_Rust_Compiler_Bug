{"sha": "f6037f2816af15ebd2a78ff5f504b9358be91424", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MDM3ZjI4MTZhZjE1ZWJkMmE3OGZmNWY1MDRiOTM1OGJlOTE0MjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T16:59:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:43Z"}, "message": "separate the `Collector` from the `Data` it is collecting", "tree": {"sha": "15ddd37b352dfa57053861d07ccb5716571a340e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ddd37b352dfa57053861d07ccb5716571a340e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6037f2816af15ebd2a78ff5f504b9358be91424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6037f2816af15ebd2a78ff5f504b9358be91424", "html_url": "https://github.com/rust-lang/rust/commit/f6037f2816af15ebd2a78ff5f504b9358be91424", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6037f2816af15ebd2a78ff5f504b9358be91424/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adf1519941deb21bd12b5923a45fdd0c21f79140", "url": "https://api.github.com/repos/rust-lang/rust/commits/adf1519941deb21bd12b5923a45fdd0c21f79140", "html_url": "https://github.com/rust-lang/rust/commit/adf1519941deb21bd12b5923a45fdd0c21f79140"}], "stats": {"total": 242, "additions": 123, "deletions": 119}, "files": [{"sha": "41209487395785981d654d715a1d3fe4fb3cf9cb", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=f6037f2816af15ebd2a78ff5f504b9358be91424", "patch": "@@ -25,7 +25,7 @@ use middle::free_region::RegionRelations;\n use middle::region;\n use super::Constraint;\n use infer::SubregionOrigin;\n-use infer::region_constraints::RegionConstraintCollector;\n+use infer::region_constraints::RegionConstraintData;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n@@ -57,7 +57,7 @@ graphs will be printed.                                                     \\n\\\n }\n \n pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n-    region_constraints: &RegionConstraintCollector<'tcx>,\n+    region_data: &RegionConstraintData<'tcx>,\n     region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n {\n     let tcx = region_rels.tcx;\n@@ -113,7 +113,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    match dump_region_constraints_to(region_rels, &region_constraints.constraints, &output_path) {\n+    match dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);\n@@ -267,15 +267,15 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-                                              map: &ConstraintMap<'tcx>,\n-                                              path: &str)\n-                                              -> io::Result<()> {\n-    debug!(\"dump_region_constraints map (len: {}) path: {}\",\n+fn dump_region_data_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                                       map: &ConstraintMap<'tcx>,\n+                                       path: &str)\n+                                       -> io::Result<()> {\n+    debug!(\"dump_region_data map (len: {}) path: {}\",\n            map.len(),\n            path);\n-    let g = ConstraintGraph::new(format!(\"region_constraints\"), region_rels, map);\n-    debug!(\"dump_region_constraints calling render\");\n+    let g = ConstraintGraph::new(format!(\"region_data\"), region_rels, map);\n+    debug!(\"dump_region_data calling render\");\n     let mut v = Vec::new();\n     dot::render(&g, &mut v).unwrap();\n     File::create(path).and_then(|mut f| f.write_all(&v))"}, {"sha": "3522420a5dc135c68debb63b86fb7f65c1d75203", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=f6037f2816af15ebd2a78ff5f504b9358be91424", "patch": "@@ -14,7 +14,7 @@ use infer::SubregionOrigin;\n use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n-use infer::region_constraints::RegionConstraintCollector;\n+use infer::region_constraints::RegionConstraintData;\n use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::fx::FxHashSet;\n@@ -73,20 +73,20 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n-impl<'tcx> RegionConstraintCollector<'tcx> {\n+impl<'tcx> RegionConstraintData<'tcx> {\n     /// This function performs the actual region resolution.  It must be\n     /// called after all constraints have been added.  It performs a\n     /// fixed-point iteration to find region values which satisfy all\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n     pub fn resolve_regions(\n-        &mut self,\n+        mut self,\n         region_rels: &RegionRelations<'_, '_, 'tcx>,\n     ) -> (\n         LexicalRegionResolutions<'tcx>,\n         Vec<RegionResolutionError<'tcx>>,\n     ) {\n-        debug!(\"RegionConstraintCollector: resolve_regions()\");\n+        debug!(\"RegionConstraintData: resolve_regions()\");\n         let mut errors = vec![];\n         let values = self.infer_variable_values(region_rels, &mut errors);\n         (values, errors)\n@@ -642,7 +642,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         return (result, dup_found);\n \n         fn process_edges<'tcx>(\n-            this: &RegionConstraintCollector<'tcx>,\n+            this: &RegionConstraintData<'tcx>,\n             state: &mut WalkState<'tcx>,\n             graph: &RegionGraph<'tcx>,\n             source_vid: RegionVid,"}, {"sha": "53112bcd88073ea81a5a924d9cd544570ec53dab", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f6037f2816af15ebd2a78ff5f504b9358be91424", "patch": "@@ -1132,10 +1132,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                region_context,\n                                                region_map,\n                                                free_regions);\n-        let mut region_constraints = self.region_constraints.borrow_mut()\n-                                                            .take()\n-                                                            .expect(\"regions already resolved\");\n-        let (lexical_region_resolutions, errors) = region_constraints.resolve_regions(&region_rels);\n+        let region_data = self.region_constraints.borrow_mut()\n+                                                 .take()\n+                                                 .expect(\"regions already resolved\")\n+                                                 .into_data();\n+        let (lexical_region_resolutions, errors) = region_data.resolve_regions(&region_rels);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());"}, {"sha": "d2cd52c73e2c88c9c07655bc882f1d09664a0460", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 103, "deletions": 100, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6037f2816af15ebd2a78ff5f504b9358be91424/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=f6037f2816af15ebd2a78ff5f504b9358be91424", "patch": "@@ -30,6 +30,69 @@ use std::u32;\n \n mod taint;\n \n+pub struct RegionConstraintCollector<'tcx> {\n+    data: RegionConstraintData<'tcx>,\n+    lubs: CombineMap<'tcx>,\n+    glbs: CombineMap<'tcx>,\n+    skolemization_count: u32,\n+    bound_count: u32,\n+\n+    /// The undo log records actions that might later be undone.\n+    ///\n+    /// Note: when the undo_log is empty, we are not actively\n+    /// snapshotting. When the `start_snapshot()` method is called, we\n+    /// push an OpenSnapshot entry onto the list to indicate that we\n+    /// are now actively snapshotting. The reason for this is that\n+    /// otherwise we end up adding entries for things like the lower\n+    /// bound on a variable and so forth, which can never be rolled\n+    /// back.\n+    undo_log: Vec<UndoLogEntry<'tcx>>,\n+\n+    unification_table: UnificationTable<ty::RegionVid>,\n+}\n+\n+/// The full set of region constraints gathered up by the collector.\n+/// Describes a set of region variables ranging from 0..N (where N is\n+/// the length of the `var_origins` vector), and various constraints\n+/// between them.\n+#[derive(Default)]\n+pub struct RegionConstraintData<'tcx> {\n+    /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n+    pub var_origins: Vec<RegionVariableOrigin>,\n+\n+    /// Constraints of the form `A <= B`, where either `A` or `B` can\n+    /// be a region variable (or neither, as it happens).\n+    pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n+\n+    /// A \"verify\" is something that we need to verify after inference\n+    /// is done, but which does not directly affect inference in any\n+    /// way.\n+    ///\n+    /// An example is a `A <= B` where neither `A` nor `B` are\n+    /// inference variables.\n+    pub verifys: Vec<Verify<'tcx>>,\n+\n+    /// A \"given\" is a relationship that is known to hold. In\n+    /// particular, we often know from closure fn signatures that a\n+    /// particular free region must be a subregion of a region\n+    /// variable:\n+    ///\n+    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    ///\n+    /// In situations like this, `'b` is in fact a region variable\n+    /// introduced by the call to `iter()`, and `'a` is a bound region\n+    /// on the closure (as indicated by the `<'a>` prefix). If we are\n+    /// naive, we wind up inferring that `'b` must be `'static`,\n+    /// because we require that it be greater than `'a` and we do not\n+    /// know what `'a` is precisely.\n+    ///\n+    /// This hashmap is used to avoid that naive scenario. Basically\n+    /// we record the fact that `'a <= 'b` is implied by the fn\n+    /// signature, and then ignore the constraint when solving\n+    /// equations. This is a bit of a hack but seems to work.\n+    pub givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n+}\n+\n /// A constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n@@ -143,65 +206,6 @@ enum CombineMapType {\n \n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n-pub struct RegionConstraintCollector<'tcx> {\n-    pub(in infer) var_origins: Vec<RegionVariableOrigin>,\n-\n-    /// Constraints of the form `A <= B` introduced by the region\n-    /// checker.  Here at least one of `A` and `B` must be a region\n-    /// variable.\n-    ///\n-    /// Using `BTreeMap` because the order in which we iterate over\n-    /// these constraints can affect the way we build the region graph,\n-    /// which in turn affects the way that region errors are reported,\n-    /// leading to small variations in error output across runs and\n-    /// platforms.\n-    pub(in infer) constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-\n-    /// A \"verify\" is something that we need to verify after inference is\n-    /// done, but which does not directly affect inference in any way.\n-    ///\n-    /// An example is a `A <= B` where neither `A` nor `B` are\n-    /// inference variables.\n-    pub(in infer) verifys: Vec<Verify<'tcx>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In particular,\n-    /// we often know from closure fn signatures that a particular free\n-    /// region must be a subregion of a region variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically we\n-    /// record the fact that `'a <= 'b` is implied by the fn signature,\n-    /// and then ignore the constraint when solving equations. This is\n-    /// a bit of a hack but seems to work.\n-    pub(in infer) givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n-\n-    lubs: CombineMap<'tcx>,\n-    glbs: CombineMap<'tcx>,\n-    skolemization_count: u32,\n-    bound_count: u32,\n-\n-    /// The undo log records actions that might later be undone.\n-    ///\n-    /// Note: when the undo_log is empty, we are not actively\n-    /// snapshotting. When the `start_snapshot()` method is called, we\n-    /// push an OpenSnapshot entry onto the list to indicate that we\n-    /// are now actively snapshotting. The reason for this is that\n-    /// otherwise we end up adding entries for things like the lower\n-    /// bound on a variable and so forth, which can never be rolled\n-    /// back.\n-    undo_log: Vec<UndoLogEntry<'tcx>>,\n-\n-    unification_table: UnificationTable<ty::RegionVid>,\n-}\n-\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: unify::Snapshot<ty::RegionVid>,\n@@ -245,10 +249,7 @@ impl TaintDirections {\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> RegionConstraintCollector<'tcx> {\n         RegionConstraintCollector {\n-            var_origins: Vec::new(),\n-            constraints: BTreeMap::new(),\n-            verifys: Vec::new(),\n-            givens: FxHashSet(),\n+            data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n             skolemization_count: 0,\n@@ -258,6 +259,11 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n+    /// Once all the constraints have been gathered, extract out the final data.\n+    pub fn into_data(self) -> RegionConstraintData<'tcx> {\n+        self.data\n+    }\n+\n     fn in_snapshot(&self) -> bool {\n         !self.undo_log.is_empty()\n     }\n@@ -289,8 +295,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         } else {\n             (*self.undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n-        self.unification_table\n-            .commit(snapshot.region_snapshot);\n+        self.unification_table.commit(snapshot.region_snapshot);\n     }\n \n     pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n@@ -304,8 +309,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         let c = self.undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n         self.skolemization_count = snapshot.skolemization_count;\n-        self.unification_table\n-            .rollback_to(snapshot.region_snapshot);\n+        self.unification_table.rollback_to(snapshot.region_snapshot);\n     }\n \n     fn rollback_undo_entry(&mut self, undo_entry: UndoLogEntry<'tcx>) {\n@@ -317,18 +321,18 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n-                self.var_origins.pop().unwrap();\n-                assert_eq!(self.var_origins.len(), vid.index as usize);\n+                self.data.var_origins.pop().unwrap();\n+                assert_eq!(self.data.var_origins.len(), vid.index as usize);\n             }\n             AddConstraint(ref constraint) => {\n-                self.constraints.remove(constraint);\n+                self.data.constraints.remove(constraint);\n             }\n             AddVerify(index) => {\n-                self.verifys.pop();\n-                assert_eq!(self.verifys.len(), index);\n+                self.data.verifys.pop();\n+                assert_eq!(self.data.verifys.len(), index);\n             }\n             AddGiven(sub, sup) => {\n-                self.givens.remove(&(sub, sup));\n+                self.data.givens.remove(&(sub, sup));\n             }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n@@ -339,18 +343,11 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn num_vars(&self) -> u32 {\n-        let len = self.var_origins.len();\n-        // enforce no overflow\n-        assert!(len as u32 as usize == len);\n-        len as u32\n-    }\n-\n     pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n         let vid = RegionVid {\n-            index: self.num_vars(),\n+            index: self.data.num_vars(),\n         };\n-        self.var_origins.push(origin.clone());\n+        self.data.var_origins.push(origin.clone());\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -367,7 +364,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     }\n \n     pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_origins[vid.index as usize].clone()\n+        self.data.var_origins[vid.index as usize].clone()\n     }\n \n     /// Creates a new skolemized region. Skolemized regions are fresh\n@@ -523,21 +520,22 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     fn add_constraint(&mut self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n-        debug!(\"RegionConstraintCollector: add_constraint({:?})\", constraint);\n+        debug!(\n+            \"RegionConstraintCollector: add_constraint({:?})\",\n+            constraint\n+        );\n \n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n         // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n         let in_snapshot = self.in_snapshot();\n         let undo_log = &mut self.undo_log;\n-        self.constraints\n-            .entry(constraint)\n-            .or_insert_with(|| {\n-                if in_snapshot {\n-                    undo_log.push(AddConstraint(constraint));\n-                }\n-                origin\n-            });\n+        self.data.constraints.entry(constraint).or_insert_with(|| {\n+            if in_snapshot {\n+                undo_log.push(AddConstraint(constraint));\n+            }\n+            origin\n+        });\n     }\n \n     fn add_verify(&mut self, verify: Verify<'tcx>) {\n@@ -552,16 +550,16 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             _ => {}\n         }\n \n-        let index = self.verifys.len();\n-        self.verifys.push(verify);\n+        let index = self.data.verifys.len();\n+        self.data.verifys.push(verify);\n         if self.in_snapshot() {\n             self.undo_log.push(AddVerify(index));\n         }\n     }\n \n     pub fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n-        if self.givens.insert((sub, sup)) {\n+        if self.data.givens.insert((sub, sup)) {\n             debug!(\"add_given({:?} <= {:?})\", sub, sup);\n \n             self.undo_log.push(AddGiven(sub, sup));\n@@ -767,11 +765,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n         let mut taint_set = taint::TaintSet::new(directions, r0);\n-        taint_set.fixed_point(\n-            tcx,\n-            &self.undo_log[mark.length..],\n-            &self.verifys,\n-        );\n+        taint_set.fixed_point(tcx, &self.undo_log[mark.length..], &self.data.verifys);\n         debug!(\"tainted: result={:?}\", taint_set);\n         return taint_set.into_set();\n     }\n@@ -866,3 +860,12 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> RegionConstraintData<'tcx> {\n+    pub fn num_vars(&self) -> u32 {\n+        let len = self.var_origins.len();\n+        // enforce no overflow\n+        assert!(len as u32 as usize == len);\n+        len as u32\n+    }\n+}"}]}