{"sha": "058d785369e3fc27f7f67b9ea019dae68603f4af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OGQ3ODUzNjllM2ZjMjdmN2Y2N2I5ZWEwMTlkYWU2ODYwM2Y0YWY=", "commit": {"author": {"name": "niftynif", "email": "nif.ward@gmail.com", "date": "2013-11-06T00:44:21Z"}, "committer": {"name": "niftynif", "email": "nif.ward@gmail.com", "date": "2013-11-06T00:44:21Z"}, "message": "Re-arranging some things in btree.rs to accommodate testing.", "tree": {"sha": "636da94d20a94bcd54118d69287dddd9b480c7fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/636da94d20a94bcd54118d69287dddd9b480c7fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/058d785369e3fc27f7f67b9ea019dae68603f4af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/058d785369e3fc27f7f67b9ea019dae68603f4af", "html_url": "https://github.com/rust-lang/rust/commit/058d785369e3fc27f7f67b9ea019dae68603f4af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/058d785369e3fc27f7f67b9ea019dae68603f4af/comments", "author": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6dde28c95b66a46a0dc05bfc9a5586b64e08575", "html_url": "https://github.com/rust-lang/rust/commit/e6dde28c95b66a46a0dc05bfc9a5586b64e08575"}], "stats": {"total": 226, "additions": 119, "deletions": 107}, "files": [{"sha": "2c594842c07882f271fe95f564f7b6edea9a7f95", "filename": "src/libextra/btree.rs", "status": "modified", "additions": 119, "deletions": 107, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/058d785369e3fc27f7f67b9ea019dae68603f4af/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058d785369e3fc27f7f67b9ea019dae68603f4af/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=058d785369e3fc27f7f67b9ea019dae68603f4af", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //\n // btree.rs\n // Nif Ward\n@@ -17,25 +27,25 @@ pub struct BTree<K, V>{\n \n \n impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n-    \n+\n     //Returns new BTree with root node (leaf) and user-supplied lower bound\n     fn new(k: K, v: V, lb: uint) -> BTree<K, V>{\n         BTree{\n-\t    root: Node::new_leaf(~[LeafElt::new(k, v)]),\n-\t    len: 1,\n-\t    lower_bound: lb,\n-\t    upper_bound: 2 * lb\n+            root: Node::new_leaf(~[LeafElt::new(k, v)]),\n+            len: 1,\n+            lower_bound: lb,\n+            upper_bound: 2 * lb\n         }\n     }\n \n     //Helper function for clone\n     fn new_with_node_len(n: Node<K, V>, length: uint, lb: uint) -> BTree<K, V>{\n         BTree{\n-\t    root: n,\n-\t    len: length,\n-\t    lower_bound: lb,\n-\t    upper_bound: 2 * lb\n-\t}\n+            root: n,\n+            len: length,\n+            lower_bound: lb,\n+            upper_bound: 2 * lb\n+        }\n     }\n \n \n@@ -50,11 +60,11 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n \n     fn add(self, k: K, v: V) -> bool{\n         let is_get = &self.clone().get(k.clone());\n-\tif is_get.is_some(){ return false; }\n-\telse{\n-\t    std::util::replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n-\t    return true;\n-\t}\n+        if is_get.is_some(){ return false; }\n+        else{\n+            std::util::replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n+            return true;\n+        }\n \n     }\n \n@@ -66,7 +76,7 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V>{\n     //Returns a string representation of the BTree\n     fn to_str(&self) -> ~str{\n         let ret=self.root.to_str();\n-\treturn ret;\n+        return ret;\n     }\n }\n \n@@ -83,11 +93,11 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n     //differentiates between leaf and branch nodes\n     fn is_leaf(&self) -> bool{\n         match self{\n-\t    &LeafNode(*) => true,\n-\t    &BranchNode(*) => false\n+            &LeafNode(*) => true,\n+            &BranchNode(*) => false\n         }\n     }\n-    \n+\n     //Creates a new leaf or branch node\n     fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V>{\n          LeafNode(Leaf::new(vec))\n@@ -98,8 +108,8 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n \n     fn get(&self, k: K) -> Option<V>{\n         match *self{\n-\t    LeafNode(ref leaf) => return leaf.get(k),\n-\t    BranchNode(ref branch) => return branch.get(k)\n+            LeafNode(ref leaf) => return leaf.get(k),\n+            BranchNode(ref branch) => return branch.get(k)\n         }\n     }\n \n@@ -114,9 +124,10 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V>{\n     fn clone(&self) -> Node<K, V>{\n         match *self{\n-\t    LeafNode(ref leaf) => return Node::new_leaf(leaf.elts.clone()),\n-\t    BranchNode(ref branch) => return Node::new_branch(branch.elts.clone(), branch.rightmost_child.clone())\n-\t}\n+            LeafNode(ref leaf) => return Node::new_leaf(leaf.elts.clone()),\n+            BranchNode(ref branch) => return Node::new_branch(branch.elts.clone(),\n+                                      branch.rightmost_child.clone())\n+        }\n     }\n }\n \n@@ -125,10 +136,10 @@ impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V>{\n     fn cmp(&self, other: &Node<K, V>) -> Ordering{\n         //Requires a match statement--defer these procs to branch and leaf.\n         /* if self.elts[0].less_than(other.elts[0]) { return Less}\n-\tif self.elts[0].greater_than(other.elts[0]) {return Greater}\n-\telse {return Equal}\n-\t*/\n-\treturn Equal;\n+        if self.elts[0].greater_than(other.elts[0]) {return Greater}\n+        else {return Equal}\n+        */\n+        return Equal;\n     }\n }\n \n@@ -140,19 +151,19 @@ impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V>{\n \n         let mut shorter = 0;\n         if self.elts.len() <= other.elts.len(){\n-\t    shorter = self.elts.len();\n-\t}\n-\telse{\n-\t    shorter = other.elts.len();\n-\t}\n-\tlet mut i = 0;\n-\twhile i < shorter{\n-\t    if !self.elts[i].has_key(other.elts[i].key){\n-\t        return false;\n-\t    }\n-\t    i +=1;\n+            shorter = self.elts.len();\n+        }\n+        else{\n+            shorter = other.elts.len();\n         }\n-\treturn true;\n+        let mut i = 0;\n+        while i < shorter{\n+            if !self.elts[i].has_key(other.elts[i].key){\n+                return false;\n+            }\n+            i +=1;\n+        }\n+        return true;\n     */\n     return true;\n     }\n@@ -163,7 +174,7 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n     fn to_str(&self) -> ~str{\n        match *self{\n            LeafNode(ref leaf) => leaf.to_str(),\n-\t   BranchNode(*) => ~\"\"\n+           BranchNode(*) => ~\"\"\n        }\n     }\n }\n@@ -192,13 +203,13 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n \n     fn get(&self, k: K) -> Option<V>{\n         for s in self.elts.iter(){\n-\t    let order=s.key.cmp(&k);\n-\t    match order{\n-\t        Equal => return Some(s.value.clone()),\n-\t\t_ => {}\n-\t    }\n-\t}\n-\treturn None;\n+            let order=s.key.cmp(&k);\n+            match order{\n+                Equal => return Some(s.value.clone()),\n+                _ => {}\n+            }\n+        }\n+        return None;\n     }\n \n     //Add method in progress\n@@ -224,22 +235,22 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n     //constructor takes a branch vector and a rightmost child\n     fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V>{\n         Branch{\n-\t    elts: vec,\n-\t    rightmost_child: right\n+            elts: vec,\n+            rightmost_child: right\n         }\n     }\n \n     fn get(&self, k: K) -> Option<V>{\n         for s in self.elts.iter(){\n-\t    let order = s.key.cmp(&k);\n-\t    match order{\n-\t        Less => return s.left.get(k),\n-\t\tEqual => return Some(s.value.clone()),\n-\t\t_ => {}\n-\t    }\n-\t}\n-\treturn self.rightmost_child.get(k);\n-    }\n+            let order = s.key.cmp(&k);\n+            match order{\n+                Less => return s.left.get(k),\n+                Equal => return Some(s.value.clone()),\n+                _ => {}\n+            }\n+        }\n+        return self.rightmost_child.get(k);\n+     }\n \n \n     //Add method in progress\n@@ -265,33 +276,33 @@ impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n     fn new(k: K, v: V) -> LeafElt<K, V>{\n         LeafElt{\n             key: k,\n-\t    value: v\n-\t}\n+            value: v\n+        }\n     }\n \n     fn less_than(&self, other: LeafElt<K, V>) -> bool{\n         let order = self.key.cmp(&other.key);\n-\tmatch order{\n-\t    Less => true,\n-\t    _ => false\n-\t}\n+        match order{\n+            Less => true,\n+            _ => false\n+        }\n     }\n \n     fn greater_than(&self, other: LeafElt<K, V>) -> bool{\n         let order = self.key.cmp(&other.key);\n-\tmatch order{\n-\t    Greater => true,\n-\t    _ => false\n-\t}\n+        match order{\n+            Greater => true,\n+            _ => false\n+        }\n     }\n \n \n     fn has_key(&self, other: K) -> bool{\n         let order = self.key.cmp(&other);\n-\tmatch order{\n-\t    Equal => true,\n-\t    _ => false\n-\t}\n+        match order{\n+            Equal => true,\n+            _ => false\n+        }\n     }\n \n }\n@@ -318,7 +329,7 @@ impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n         }\n     }\n \n-    //Add method in progress.  Should it return a branch or a leaf elt?  It will depend on implementation.\n+    //Add method in progress.  Should it return a branch or a leaf elt?\n     fn add(&self, k: K, v: V) -> LeafElt<K, V>{\n         return LeafElt::new(k, v);\n     }\n@@ -330,43 +341,44 @@ impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V>{\n     }\n }\n \n-#[test]\n-fn add_test(){\n-    let b = BTree::new(1, ~\"abc\", 2);\n-    let is_add = b.add(2, ~\"xyz\");\n-    assert!(is_add);\n-\n-}\n-\n-#[test]\n-fn get_test(){\n-    let b = BTree::new(1, ~\"abc\", 2);\n-    let val = b.get(1);\n-    assert_eq!(val, Some(~\"abc\"));\n-}\n+#[cfg(test)]\n+mod test_btree{\n \n-//Testing LeafElt<K, V> functions (less_than, greater_than, and has_key)\n-#[test]\n-fn leaf_lt(){\n-    let l1 = LeafElt::new(1, ~\"abc\");\n-    let l2 = LeafElt::new(2, ~\"xyz\");\n-    assert!(l1.less_than(l2));\n-}\n+    use super::*;\n \n-#[test]\n-fn leaf_gt(){\n-    let l1 = LeafElt::new(1, ~\"abc\");\n-    let l2 = LeafElt::new(2, ~\"xyz\");\n-    assert!(l2.greater_than(l1));\n-}\n+    #[test]\n+    fn add_test(){\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let is_add = b.add(2, ~\"xyz\");\n+        assert!(is_add);\n+    }\n \n-#[test]\n-fn leaf_hk(){\n-    let l1 = LeafElt::new(1, ~\"abc\");\n-    assert!(l1.has_key(1));\n-}\n+    #[test]\n+    fn get_test(){\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let val = b.get(1);\n+        assert_eq!(val, Some(~\"abc\"));\n+    }\n \n-fn main(){\n+    //Testing LeafElt<K, V> functions (less_than, greater_than, and has_key)\n+    #[test]\n+    fn leaf_lt(){\n+        let l1 = LeafElt::new(1, ~\"abc\");\n+        let l2 = LeafElt::new(2, ~\"xyz\");\n+        assert!(l1.less_than(l2));\n+    }\n \n+    #[test]\n+    fn leaf_gt(){\n+        let l1 = LeafElt::new(1, ~\"abc\");\n+        let l2 = LeafElt::new(2, ~\"xyz\");\n+        assert!(l2.greater_than(l1));\n+    }\n \n+    #[test]\n+    fn leaf_hk(){\n+        let l1 = LeafElt::new(1, ~\"abc\");\n+        assert!(l1.has_key(1));\n+    }\n }\n+"}]}