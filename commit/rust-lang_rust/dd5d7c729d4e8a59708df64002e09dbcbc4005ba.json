{"sha": "dd5d7c729d4e8a59708df64002e09dbcbc4005ba", "node_id": "C_kwDOAAsO6NoAKGRkNWQ3YzcyOWQ0ZThhNTk3MDhkZjY0MDAyZTA5ZGJjYmM0MDA1YmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T19:53:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T19:53:32Z"}, "message": "Auto merge of #112162 - nnethercote:clarify-mono-item-usage, r=wesleywiser\n\nClarify mono item usage\n\nSome commits that make the terminology around mono items clearer, and simplify related data structures.\n\nr? `@wesleywiser`", "tree": {"sha": "00aabdb86cdcd507011da00a6fa5d64b803a5e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00aabdb86cdcd507011da00a6fa5d64b803a5e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd5d7c729d4e8a59708df64002e09dbcbc4005ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd5d7c729d4e8a59708df64002e09dbcbc4005ba", "html_url": "https://github.com/rust-lang/rust/commit/dd5d7c729d4e8a59708df64002e09dbcbc4005ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd5d7c729d4e8a59708df64002e09dbcbc4005ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "794249d768a4f112519f22502ade032dc03b9fde", "url": "https://api.github.com/repos/rust-lang/rust/commits/794249d768a4f112519f22502ade032dc03b9fde", "html_url": "https://github.com/rust-lang/rust/commit/794249d768a4f112519f22502ade032dc03b9fde"}, {"sha": "4f800b56d02a8025308f3d16b0a49828d307f954", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f800b56d02a8025308f3d16b0a49828d307f954", "html_url": "https://github.com/rust-lang/rust/commit/4f800b56d02a8025308f3d16b0a49828d307f954"}], "stats": {"total": 284, "additions": 120, "deletions": 164}, "files": [{"sha": "f4ee7b7587587b8587ae8b05e279d2eda9dec220", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 79, "deletions": 99, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/dd5d7c729d4e8a59708df64002e09dbcbc4005ba/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5d7c729d4e8a59708df64002e09dbcbc4005ba/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=dd5d7c729d4e8a59708df64002e09dbcbc4005ba", "patch": "@@ -35,15 +35,15 @@\n //!\n //! - A \"mono item\" is something that results in a function or global in\n //!   the LLVM IR of a codegen unit. Mono items do not stand on their\n-//!   own, they can reference other mono items. For example, if function\n+//!   own, they can use other mono items. For example, if function\n //!   `foo()` calls function `bar()` then the mono item for `foo()`\n-//!   references the mono item for function `bar()`. In general, the\n-//!   definition for mono item A referencing a mono item B is that\n-//!   the LLVM artifact produced for A references the LLVM artifact produced\n+//!   uses the mono item for function `bar()`. In general, the\n+//!   definition for mono item A using a mono item B is that\n+//!   the LLVM artifact produced for A uses the LLVM artifact produced\n //!   for B.\n //!\n-//! - Mono items and the references between them form a directed graph,\n-//!   where the mono items are the nodes and references form the edges.\n+//! - Mono items and the uses between them form a directed graph,\n+//!   where the mono items are the nodes and uses form the edges.\n //!   Let's call this graph the \"mono item graph\".\n //!\n //! - The mono item graph for a program contains all mono items\n@@ -53,12 +53,11 @@\n //! mono item graph for the current crate. It runs in two phases:\n //!\n //! 1. Discover the roots of the graph by traversing the HIR of the crate.\n-//! 2. Starting from the roots, find neighboring nodes by inspecting the MIR\n+//! 2. Starting from the roots, find uses by inspecting the MIR\n //!    representation of the item corresponding to a given node, until no more\n //!    new nodes are found.\n //!\n //! ### Discovering roots\n-//!\n //! The roots of the mono item graph correspond to the public non-generic\n //! syntactic items in the source code. We find them by walking the HIR of the\n //! crate, and whenever we hit upon a public function, method, or static item,\n@@ -69,25 +68,23 @@\n //! specified. Functions marked `#[no_mangle]` and functions called by inlinable\n //! functions also always act as roots.)\n //!\n-//! ### Finding neighbor nodes\n-//! Given a mono item node, we can discover neighbors by inspecting its\n-//! MIR. We walk the MIR and any time we hit upon something that signifies a\n-//! reference to another mono item, we have found a neighbor. Since the\n-//! mono item we are currently at is always monomorphic, we also know the\n-//! concrete type arguments of its neighbors, and so all neighbors again will be\n-//! monomorphic. The specific forms a reference to a neighboring node can take\n-//! in MIR are quite diverse. Here is an overview:\n+//! ### Finding uses\n+//! Given a mono item node, we can discover uses by inspecting its MIR. We walk\n+//! the MIR to find other mono items used by each mono item. Since the mono\n+//! item we are currently at is always monomorphic, we also know the concrete\n+//! type arguments of its used mono items. The specific forms a use can take in\n+//! MIR are quite diverse. Here is an overview:\n //!\n //! #### Calling Functions/Methods\n-//! The most obvious form of one mono item referencing another is a\n+//! The most obvious way for one mono item to use another is a\n //! function or method call (represented by a CALL terminator in MIR). But\n-//! calls are not the only thing that might introduce a reference between two\n+//! calls are not the only thing that might introduce a use between two\n //! function mono items, and as we will see below, they are just a\n //! specialization of the form described next, and consequently will not get any\n //! special treatment in the algorithm.\n //!\n //! #### Taking a reference to a function or method\n-//! A function does not need to actually be called in order to be a neighbor of\n+//! A function does not need to actually be called in order to be used by\n //! another function. It suffices to just take a reference in order to introduce\n //! an edge. Consider the following example:\n //!\n@@ -109,18 +106,18 @@\n //! The MIR of none of these functions will contain an explicit call to\n //! `print_val::<i32>`. Nonetheless, in order to mono this program, we need\n //! an instance of this function. Thus, whenever we encounter a function or\n-//! method in operand position, we treat it as a neighbor of the current\n+//! method in operand position, we treat it as a use of the current\n //! mono item. Calls are just a special case of that.\n //!\n //! #### Drop glue\n //! Drop glue mono items are introduced by MIR drop-statements. The\n-//! generated mono item will again have drop-glue item neighbors if the\n+//! generated mono item will have additional drop-glue item uses if the\n //! type to be dropped contains nested values that also need to be dropped. It\n-//! might also have a function item neighbor for the explicit `Drop::drop`\n+//! might also have a function item use for the explicit `Drop::drop`\n //! implementation of its type.\n //!\n //! #### Unsizing Casts\n-//! A subtle way of introducing neighbor edges is by casting to a trait object.\n+//! A subtle way of introducing use edges is by casting to a trait object.\n //! Since the resulting fat-pointer contains a reference to a vtable, we need to\n //! instantiate all object-safe methods of the trait, as we need to store\n //! pointers to these functions even if they never get called anywhere. This can\n@@ -151,7 +148,7 @@\n //! Mono item collection can be performed in one of two modes:\n //!\n //! - Lazy mode means that items will only be instantiated when actually\n-//!   referenced. The goal is to produce the least amount of machine code\n+//!   used. The goal is to produce the least amount of machine code\n //!   possible.\n //!\n //! - Eager mode is meant to be used in conjunction with incremental compilation\n@@ -198,7 +195,6 @@ use rustc_session::lint::builtin::LARGE_ASSIGNMENTS;\n use rustc_session::Limit;\n use rustc_span::source_map::{dummy_spanned, respan, Span, Spanned, DUMMY_SP};\n use rustc_target::abi::Size;\n-use std::ops::Range;\n use std::path::PathBuf;\n \n use crate::errors::{\n@@ -211,66 +207,51 @@ pub enum MonoItemCollectionMode {\n     Lazy,\n }\n \n-/// Maps every mono item to all mono items it references in its\n-/// body.\n-pub struct InliningMap<'tcx> {\n-    // Maps a source mono item to the range of mono items\n-    // accessed by it.\n-    // The range selects elements within the `targets` vecs.\n-    index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n-    targets: Vec<MonoItem<'tcx>>,\n+pub struct UsageMap<'tcx> {\n+    // Maps every mono item to the mono items used by it.\n+    used_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>>,\n+\n+    // Maps every mono item to the mono items that use it.\n+    user_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>>,\n }\n \n type MonoItems<'tcx> = Vec<Spanned<MonoItem<'tcx>>>;\n \n-impl<'tcx> InliningMap<'tcx> {\n-    fn new() -> InliningMap<'tcx> {\n-        InliningMap { index: FxHashMap::default(), targets: Vec::new() }\n+impl<'tcx> UsageMap<'tcx> {\n+    fn new() -> UsageMap<'tcx> {\n+        UsageMap { used_map: FxHashMap::default(), user_map: FxHashMap::default() }\n     }\n \n-    fn record_accesses<'a>(\n+    fn record_used<'a>(\n         &mut self,\n-        source: MonoItem<'tcx>,\n-        new_targets: &'a [Spanned<MonoItem<'tcx>>],\n+        user_item: MonoItem<'tcx>,\n+        used_items: &'a [Spanned<MonoItem<'tcx>>],\n     ) where\n         'tcx: 'a,\n     {\n-        let start_index = self.targets.len();\n-        let new_items_count = new_targets.len();\n-\n-        self.targets.reserve(new_items_count);\n-\n-        for Spanned { node: mono_item, .. } in new_targets.into_iter() {\n-            self.targets.push(*mono_item);\n+        let used_items: Vec<_> = used_items.iter().map(|item| item.node).collect();\n+        for &used_item in used_items.iter() {\n+            self.user_map.entry(used_item).or_default().push(user_item);\n         }\n \n-        let end_index = self.targets.len();\n-        assert!(self.index.insert(source, start_index..end_index).is_none());\n+        assert!(self.used_map.insert(user_item, used_items).is_none());\n     }\n \n-    /// Internally iterate over all items referenced by `source` which will be\n-    /// made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, tcx: TyCtxt<'tcx>, source: MonoItem<'tcx>, mut f: F)\n-    where\n-        F: FnMut(MonoItem<'tcx>),\n-    {\n-        if let Some(range) = self.index.get(&source) {\n-            for candidate in self.targets[range.clone()].iter() {\n-                let is_inlined = candidate.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n-                if is_inlined {\n-                    f(*candidate);\n-                }\n-            }\n-        }\n+    pub fn get_user_items(&self, item: MonoItem<'tcx>) -> Option<&[MonoItem<'tcx>]> {\n+        self.user_map.get(&item).map(|items| items.as_slice())\n     }\n \n-    /// Internally iterate over all items and the things each accesses.\n-    pub fn iter_accesses<F>(&self, mut f: F)\n+    /// Internally iterate over all inlined items used by `item`.\n+    pub fn for_each_inlined_used_item<F>(&self, tcx: TyCtxt<'tcx>, item: MonoItem<'tcx>, mut f: F)\n     where\n-        F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>]),\n+        F: FnMut(MonoItem<'tcx>),\n     {\n-        for (&accessor, range) in &self.index {\n-            f(accessor, &self.targets[range.clone()])\n+        let used_items = self.used_map.get(&item).unwrap();\n+        for used_item in used_items.iter() {\n+            let is_inlined = used_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n+            if is_inlined {\n+                f(*used_item);\n+            }\n         }\n     }\n }\n@@ -279,7 +260,7 @@ impl<'tcx> InliningMap<'tcx> {\n pub fn collect_crate_mono_items(\n     tcx: TyCtxt<'_>,\n     mode: MonoItemCollectionMode,\n-) -> (FxHashSet<MonoItem<'_>>, InliningMap<'_>) {\n+) -> (FxHashSet<MonoItem<'_>>, UsageMap<'_>) {\n     let _prof_timer = tcx.prof.generic_activity(\"monomorphization_collector\");\n \n     let roots =\n@@ -288,12 +269,12 @@ pub fn collect_crate_mono_items(\n     debug!(\"building mono item graph, beginning at roots\");\n \n     let mut visited = MTLock::new(FxHashSet::default());\n-    let mut inlining_map = MTLock::new(InliningMap::new());\n+    let mut usage_map = MTLock::new(UsageMap::new());\n     let recursion_limit = tcx.recursion_limit();\n \n     {\n         let visited: MTLockRef<'_, _> = &mut visited;\n-        let inlining_map: MTLockRef<'_, _> = &mut inlining_map;\n+        let usage_map: MTLockRef<'_, _> = &mut usage_map;\n \n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_for_each_in(roots, |root| {\n@@ -304,13 +285,13 @@ pub fn collect_crate_mono_items(\n                     visited,\n                     &mut recursion_depths,\n                     recursion_limit,\n-                    inlining_map,\n+                    usage_map,\n                 );\n             });\n         });\n     }\n \n-    (visited.into_inner(), inlining_map.into_inner())\n+    (visited.into_inner(), usage_map.into_inner())\n }\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n@@ -353,24 +334,23 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n \n /// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n /// post-monomorphization error is encountered during a collection step.\n-#[instrument(skip(tcx, visited, recursion_depths, recursion_limit, inlining_map), level = \"debug\")]\n+#[instrument(skip(tcx, visited, recursion_depths, recursion_limit, usage_map), level = \"debug\")]\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    starting_point: Spanned<MonoItem<'tcx>>,\n+    starting_item: Spanned<MonoItem<'tcx>>,\n     visited: MTLockRef<'_, FxHashSet<MonoItem<'tcx>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     recursion_limit: Limit,\n-    inlining_map: MTLockRef<'_, InliningMap<'tcx>>,\n+    usage_map: MTLockRef<'_, UsageMap<'tcx>>,\n ) {\n-    if !visited.lock_mut().insert(starting_point.node) {\n+    if !visited.lock_mut().insert(starting_item.node) {\n         // We've been here already, no need to search again.\n         return;\n     }\n \n-    let mut neighbors = Vec::new();\n+    let mut used_items = Vec::new();\n     let recursion_depth_reset;\n \n-    //\n     // Post-monomorphization errors MVP\n     //\n     // We can encounter errors while monomorphizing an item, but we don't have a good way of\n@@ -396,27 +376,27 @@ fn collect_items_rec<'tcx>(\n     // FIXME: don't rely on global state, instead bubble up errors. Note: this is very hard to do.\n     let error_count = tcx.sess.diagnostic().err_count();\n \n-    match starting_point.node {\n+    match starting_item.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_codegen_locally(tcx, &instance));\n \n             let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n-            visit_drop_use(tcx, ty, true, starting_point.span, &mut neighbors);\n+            visit_drop_use(tcx, ty, true, starting_item.span, &mut used_items);\n \n             recursion_depth_reset = None;\n \n             if let Ok(alloc) = tcx.eval_static_initializer(def_id) {\n                 for &id in alloc.inner().provenance().ptrs().values() {\n-                    collect_miri(tcx, id, &mut neighbors);\n+                    collect_miri(tcx, id, &mut used_items);\n                 }\n             }\n \n             if tcx.needs_thread_local_shim(def_id) {\n-                neighbors.push(respan(\n-                    starting_point.span,\n+                used_items.push(respan(\n+                    starting_item.span,\n                     MonoItem::Fn(Instance {\n                         def: InstanceDef::ThreadLocalShim(def_id),\n                         substs: InternalSubsts::empty(),\n@@ -432,14 +412,14 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = Some(check_recursion_limit(\n                 tcx,\n                 instance,\n-                starting_point.span,\n+                starting_item.span,\n                 recursion_depths,\n                 recursion_limit,\n             ));\n             check_type_length_limit(tcx, instance);\n \n             rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                collect_neighbours(tcx, instance, &mut neighbors);\n+                collect_used_items(tcx, instance, &mut used_items);\n             });\n         }\n         MonoItem::GlobalAsm(item_id) => {\n@@ -457,13 +437,13 @@ fn collect_items_rec<'tcx>(\n                         hir::InlineAsmOperand::SymFn { anon_const } => {\n                             let fn_ty =\n                                 tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n-                            visit_fn_use(tcx, fn_ty, false, *op_sp, &mut neighbors);\n+                            visit_fn_use(tcx, fn_ty, false, *op_sp, &mut used_items);\n                         }\n                         hir::InlineAsmOperand::SymStatic { path: _, def_id } => {\n                             let instance = Instance::mono(tcx, *def_id);\n                             if should_codegen_locally(tcx, &instance) {\n                                 trace!(\"collecting static {:?}\", def_id);\n-                                neighbors.push(dummy_spanned(MonoItem::Static(*def_id)));\n+                                used_items.push(dummy_spanned(MonoItem::Static(*def_id)));\n                             }\n                         }\n                         hir::InlineAsmOperand::In { .. }\n@@ -483,19 +463,19 @@ fn collect_items_rec<'tcx>(\n     // Check for PMEs and emit a diagnostic if one happened. To try to show relevant edges of the\n     // mono item graph.\n     if tcx.sess.diagnostic().err_count() > error_count\n-        && starting_point.node.is_generic_fn()\n-        && starting_point.node.is_user_defined()\n+        && starting_item.node.is_generic_fn()\n+        && starting_item.node.is_user_defined()\n     {\n-        let formatted_item = with_no_trimmed_paths!(starting_point.node.to_string());\n+        let formatted_item = with_no_trimmed_paths!(starting_item.node.to_string());\n         tcx.sess.emit_note(EncounteredErrorWhileInstantiating {\n-            span: starting_point.span,\n+            span: starting_item.span,\n             formatted_item,\n         });\n     }\n-    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors);\n+    usage_map.lock_mut().record_used(starting_item.node, &used_items);\n \n-    for neighbour in neighbors {\n-        collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n+    for used_item in used_items {\n+        collect_items_rec(tcx, used_item, visited, recursion_depths, recursion_limit, usage_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -611,14 +591,14 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     }\n }\n \n-struct MirNeighborCollector<'a, 'tcx> {\n+struct MirUsedCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut MonoItems<'tcx>,\n     instance: Instance<'tcx>,\n }\n \n-impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n+impl<'a, 'tcx> MirUsedCollector<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n@@ -632,7 +612,7 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n+impl<'a, 'tcx> MirVisitor<'tcx> for MirUsedCollector<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n@@ -1392,13 +1372,13 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n \n /// Scans the MIR in order to find function calls, closures, and drop-glue.\n #[instrument(skip(tcx, output), level = \"debug\")]\n-fn collect_neighbours<'tcx>(\n+fn collect_used_items<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     output: &mut MonoItems<'tcx>,\n ) {\n     let body = tcx.instance_mir(instance.def);\n-    MirNeighborCollector { tcx, body: &body, output, instance }.visit_body(&body);\n+    MirUsedCollector { tcx, body: &body, output, instance }.visit_body(&body);\n }\n \n #[instrument(skip(tcx, output), level = \"debug\")]"}, {"sha": "79fcd62bc6206fbd95d844c37f6c2015218807c4", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 41, "deletions": 65, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/dd5d7c729d4e8a59708df64002e09dbcbc4005ba/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd5d7c729d4e8a59708df64002e09dbcbc4005ba/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=dd5d7c729d4e8a59708df64002e09dbcbc4005ba", "patch": "@@ -115,14 +115,14 @@ use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n use rustc_span::symbol::Symbol;\n \n-use crate::collector::InliningMap;\n+use crate::collector::UsageMap;\n use crate::collector::{self, MonoItemCollectionMode};\n use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode};\n \n struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     target_cgu_count: usize,\n-    inlining_map: &'a InliningMap<'tcx>,\n+    usage_map: &'a UsageMap<'tcx>,\n }\n \n struct PlacedRootMonoItems<'tcx> {\n@@ -138,14 +138,14 @@ fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: &mut I,\n     max_cgu_count: usize,\n-    inlining_map: &InliningMap<'tcx>,\n+    usage_map: &UsageMap<'tcx>,\n ) -> Vec<CodegenUnit<'tcx>>\n where\n     I: Iterator<Item = MonoItem<'tcx>>,\n {\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n-    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, usage_map };\n \n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n@@ -405,7 +405,7 @@ fn merge_codegen_units<'tcx>(\n }\n \n /// For symbol internalization, we need to know whether a symbol/mono-item is\n-/// accessed from outside the codegen unit it is defined in. This type is used\n+/// used from outside the codegen unit it is defined in. This type is used\n /// to keep track of that.\n #[derive(Clone, PartialEq, Eq, Debug)]\n enum MonoItemPlacement {\n@@ -422,33 +422,25 @@ fn place_inlined_mono_items<'tcx>(\n \n     let single_codegen_unit = codegen_units.len() == 1;\n \n-    for old_codegen_unit in codegen_units.iter_mut() {\n+    for cgu in codegen_units.iter_mut() {\n         // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n-        for root in old_codegen_unit.items().keys() {\n-            follow_inlining(cx.tcx, *root, cx.inlining_map, &mut reachable);\n+        for root in cgu.items().keys() {\n+            // Insert the root item itself, plus all inlined items that are\n+            // reachable from it without going via another root item.\n+            reachable.insert(*root);\n+            get_reachable_inlined_items(cx.tcx, *root, cx.usage_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n         // Add all monomorphizations that are not already there.\n         for mono_item in reachable {\n-            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                // This is a root, just copy it over.\n-                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-            } else {\n+            if !cgu.items().contains_key(&mono_item) {\n                 if roots.contains(&mono_item) {\n-                    bug!(\n-                        \"GloballyShared mono-item inlined into other CGU: \\\n-                          {:?}\",\n-                        mono_item\n-                    );\n+                    bug!(\"GloballyShared mono-item inlined into other CGU: {:?}\", mono_item);\n                 }\n \n                 // This is a CGU-private copy.\n-                new_codegen_unit\n-                    .items_mut()\n-                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+                cgu.items_mut().insert(mono_item, (Linkage::Internal, Visibility::Default));\n             }\n \n             if !single_codegen_unit {\n@@ -458,39 +450,32 @@ fn place_inlined_mono_items<'tcx>(\n                     Entry::Occupied(e) => {\n                         let placement = e.into_mut();\n                         debug_assert!(match *placement {\n-                            MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                cgu_name != new_codegen_unit.name()\n-                            }\n+                            MonoItemPlacement::SingleCgu { cgu_name } => cgu_name != cgu.name(),\n                             MonoItemPlacement::MultipleCgus => true,\n                         });\n                         *placement = MonoItemPlacement::MultipleCgus;\n                     }\n                     Entry::Vacant(e) => {\n-                        e.insert(MonoItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name(),\n-                        });\n+                        e.insert(MonoItemPlacement::SingleCgu { cgu_name: cgu.name() });\n                     }\n                 }\n             }\n         }\n-\n-        *old_codegen_unit = new_codegen_unit;\n     }\n \n     return mono_item_placements;\n \n-    fn follow_inlining<'tcx>(\n+    fn get_reachable_inlined_items<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        mono_item: MonoItem<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n+        item: MonoItem<'tcx>,\n+        usage_map: &UsageMap<'tcx>,\n         visited: &mut FxHashSet<MonoItem<'tcx>>,\n     ) {\n-        if !visited.insert(mono_item) {\n-            return;\n-        }\n-\n-        inlining_map.with_inlining_candidates(tcx, mono_item, |target| {\n-            follow_inlining(tcx, target, inlining_map, visited);\n+        usage_map.for_each_inlined_used_item(tcx, item, |inlined_item| {\n+            let is_new = visited.insert(inlined_item);\n+            if is_new {\n+                get_reachable_inlined_items(tcx, inlined_item, usage_map, visited);\n+            }\n         });\n     }\n }\n@@ -504,7 +489,7 @@ fn internalize_symbols<'tcx>(\n     if codegen_units.len() == 1 {\n         // Fast path for when there is only one codegen unit. In this case we\n         // can internalize all candidates, since there is nowhere else they\n-        // could be accessed from.\n+        // could be used from.\n         for cgu in codegen_units {\n             for candidate in &internalization_candidates {\n                 cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n@@ -514,45 +499,36 @@ fn internalize_symbols<'tcx>(\n         return;\n     }\n \n-    // Build a map from every monomorphization to all the monomorphizations that\n-    // reference it.\n-    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-    cx.inlining_map.iter_accesses(|accessor, accessees| {\n-        for accessee in accessees {\n-            accessor_map.entry(*accessee).or_default().push(accessor);\n-        }\n-    });\n-\n     // For each internalization candidates in each codegen unit, check if it is\n-    // accessed from outside its defining codegen unit.\n+    // used from outside its defining codegen unit.\n     for cgu in codegen_units {\n         let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n \n-        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-            if !internalization_candidates.contains(accessee) {\n+        for (item, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(item) {\n                 // This item is no candidate for internalizing, so skip it.\n                 continue;\n             }\n-            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+            debug_assert_eq!(mono_item_placements[item], home_cgu);\n \n-            if let Some(accessors) = accessor_map.get(accessee) {\n-                if accessors\n+            if let Some(user_items) = cx.usage_map.get_user_items(*item) {\n+                if user_items\n                     .iter()\n-                    .filter_map(|accessor| {\n-                        // Some accessors might not have been\n+                    .filter_map(|user_item| {\n+                        // Some user mono items might not have been\n                         // instantiated. We can safely ignore those.\n-                        mono_item_placements.get(accessor)\n+                        mono_item_placements.get(user_item)\n                     })\n                     .any(|placement| *placement != home_cgu)\n                 {\n-                    // Found an accessor from another CGU, so skip to the next\n-                    // item without marking this one as internal.\n+                    // Found a user from another CGU, so skip to the next item\n+                    // without marking this one as internal.\n                     continue;\n                 }\n             }\n \n-            // If we got here, we did not find any accesses from other CGUs,\n-            // so it's fine to make this monomorphization internal.\n+            // If we got here, we did not find any uses from other CGUs, so\n+            // it's fine to make this monomorphization internal.\n             *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n         }\n     }\n@@ -788,7 +764,7 @@ fn mono_item_visibility<'tcx>(\n     } else {\n         // If this isn't a generic function then we mark this a `Default` if\n         // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n+        // use when they link to us.\n         if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n             *can_be_internalized = false;\n             debug_assert!(!is_generic);\n@@ -968,7 +944,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n         }\n     };\n \n-    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n+    let (items, usage_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n \n     tcx.sess.abort_if_errors();\n \n@@ -979,7 +955,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n                     tcx,\n                     &mut items.iter().copied(),\n                     tcx.sess.codegen_units(),\n-                    &inlining_map,\n+                    &usage_map,\n                 );\n                 codegen_units[0].make_primary();\n                 &*tcx.arena.alloc_from_iter(codegen_units)"}]}