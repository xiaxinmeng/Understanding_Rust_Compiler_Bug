{"sha": "098a7a07ee6d11cf6d2b9d18918f26be95ee2f66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5OGE3YTA3ZWU2ZDExY2Y2ZDJiOWQxODkxOGYyNmJlOTVlZTJmNjY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-10-09T16:02:37Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-10-09T16:04:18Z"}, "message": "Major revision to the dropck_legal_cycles test.\n\n1. Added big comment block explaining the test framework.\n\n2. Added tests exericising Rc and Arc. This was inspired by a comment\n   from eefriedman on PR #28861.\n\n3. Made the cycle-detection not issue false-positives on acyclic dags.\n\n   Doing this efficiently required revising the framework; instead of\n   visiting all children (i.e. doing a traversal), now each test is\n   responsible for supplying the path that will act as a witness to\n   the cycle.\n\n   Luckily for me, all of the pre-existing tests worked with a trivial\n   path built from \"always tke your first left\", but new tests I added\n   did require other input paths (i.e., \"first turn right, then left\".\n\n   (The path representation is a bit-string and its branches are\n    n-ary, not word phrases and binary branches as you might think\n    from the outline above.)", "tree": {"sha": "44fc606d968bf3dc9a16a8d3b724ff47cd336ea5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44fc606d968bf3dc9a16a8d3b724ff47cd336ea5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66", "html_url": "https://github.com/rust-lang/rust/commit/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d", "html_url": "https://github.com/rust-lang/rust/commit/c298efdb1f5e9334c25dcc1ea98fcc35a0b4c05d"}], "stats": {"total": 526, "additions": 480, "deletions": 46}, "files": [{"sha": "a31df0fd93e16a1aaca8508d97feec1bf52ae3bb", "filename": "src/test/run-pass/dropck_legal_cycles.rs", "status": "modified", "additions": 480, "deletions": 46, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/098a7a07ee6d11cf6d2b9d18918f26be95ee2f66/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs?ref=098a7a07ee6d11cf6d2b9d18918f26be95ee2f66", "patch": "@@ -24,9 +24,92 @@\n // through the collection, for every collection type that supports\n // this.\n \n-#![feature(vecmap)]\n+// HIGH LEVEL DESCRIPTION OF THE TEST ARCHITECTURE\n+// -----------------------------------------------\n+//\n+// We pick a data structure and want to make a cyclic construction\n+// from it. Each test of interest is labelled starting with \"Cycle N:\n+// { ... }\" where N is the test number and the \"...\"`is filled in with\n+// a graphviz-style description of the graph structure that the\n+// author believes is being made. So \"{ a -> b, b -> (c,d), (c,d) -> e }\"\n+// describes a line connected to a diamond:\n+//\n+//                           c\n+//                          / \\\n+//                     a - b   e\n+//                          \\ /\n+//                           d\n+//\n+// (Note that the above directed graph is actually acyclic.)\n+//\n+// The different graph structures are often composed of different data\n+// types. Some may be built atop `Vec`, others atop `HashMap`, etc.\n+//\n+// For each graph structure, we actually *confirm* that a cycle exists\n+// (as a safe-guard against a test author accidentally leaving it out)\n+// by traversing each graph and \"proving\" that a cycle exists within it.\n+//\n+// To do this, while trying to keep the code uniform (despite working\n+// with different underlying collection and smart-pointer types), we\n+// have a standard traversal API:\n+//\n+// 1. every node in the graph carries a `mark` (a u32, init'ed to 0).\n+//\n+// 2. every node provides a method to visit its children\n+//\n+// 3. a traversal attmepts to visit the nodes of the graph and prove that\n+//    it sees the same node twice. It does this by setting the mark of each\n+//    node to a fresh non-zero value, and if it sees the current mark, it\n+//    \"knows\" that it must have found a cycle, and stops attempting further\n+//    traversal.\n+//\n+// 4. each traversal is controlled by a bit-string that tells it which child\n+//    it visit when it can take different paths. As a simple example,\n+//    in a binary tree, 0 could mean \"left\" (and 1, \"right\"), so that\n+//    \"00010\" means \"left, left, left, right, left\". (In general it will\n+//    read as many bits as it needs to choose one child.)\n+//\n+//    The graphs in this test are all meant to be very small, and thus\n+//    short bitstrings of less than 64 bits should always suffice.\n+//\n+//    (An earlier version of this test infrastructure simply had any\n+//    given traversal visit all children it encountered, in a\n+//    depth-first manner; one problem with this approach is that an\n+//    acyclic graph can still have sharing, which would then be treated\n+//    as a repeat mark and reported as a detected cycle.)\n+//\n+// The travseral code is a little more complicated because it has been\n+// programmed in a somewhat defensive manner. For example it also has\n+// a max threshold for the number of nodes it will visit, to guard\n+// against scenarios where the nodes are not correctly setting their\n+// mark when asked. There are various other methods not discussed here\n+// that are for aiding debugging the test when it runs, such as the\n+// `name` method that all nodes provide.\n+//\n+// So each test:\n+//\n+// 1. allocates the nodes in the graph,\n+//\n+// 2. sets up the links in the graph,\n+//\n+// 3. clones the \"ContextData\"\n+//\n+// 4. chooses a new current mark value for this test\n+//\n+// 5. initiates a traversal, potentially from multiple starting points\n+//    (aka \"roots\"), with a given control-string (potentially a\n+//    different string for each root). if it does start from a\n+//    distinct root, then such a test should also increment the\n+//    current mark value, so that this traversal is considered\n+//    distinct from the prior one on this graph structure.\n+//\n+//    Note that most of the tests work with the default control string\n+//    of all-zeroes.\n+//\n+// 6. assert that the context confirms that it actually saw a cycle (since a traversal\n+//    might have terminated, e.g. on a tree structure that contained no cycles).\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::BinaryHeap;\n use std::collections::HashMap;\n@@ -35,6 +118,8 @@ use std::collections::VecDeque;\n use std::collections::btree_map::BTreeMap;\n use std::collections::btree_set::BTreeSet;\n use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n+use std::sync::{Arc, RwLock, Mutex};\n \n const PRINT: bool = false;\n \n@@ -47,8 +132,28 @@ pub fn main() {\n         skipped: 0,\n         curr_mark: 0,\n         saw_prev_marked: false,\n+        control_bits: 0,\n     };\n \n+    // SANITY CHECK FOR TEST SUITE (thus unnumbered)\n+    // Not a cycle: { v[0] -> (v[1], v[2]), v[1] -> v[3], v[2] -> v[3] };\n+    let v: Vec<S2> = vec![Named::new(\"s0\"),\n+                          Named::new(\"s1\"),\n+                          Named::new(\"s2\"),\n+                          Named::new(\"s3\")];\n+    v[0].next.set((Some(&v[1]), Some(&v[2])));\n+    v[1].next.set((Some(&v[3]), None));\n+    v[2].next.set((Some(&v[3]), None));\n+    v[3].next.set((None, None));\n+\n+    let mut c = c_orig.clone();\n+    c.curr_mark = 10;\n+    assert!(!c.saw_prev_marked);\n+    v[0].descend_into_self(&mut c);\n+    assert!(!c.saw_prev_marked); // <-- different from below, b/c acyclic above\n+\n+    if PRINT { println!(\"\"); }\n+\n     // Cycle 1: { v[0] -> v[1], v[1] -> v[0] };\n     // does not exercise `v` itself\n     let v: Vec<S> = vec![Named::new(\"s0\"),\n@@ -59,7 +164,7 @@ pub fn main() {\n     let mut c = c_orig.clone();\n     c.curr_mark = 10;\n     assert!(!c.saw_prev_marked);\n-    v[0].for_each_child(&mut c);\n+    v[0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n     if PRINT { println!(\"\"); }\n@@ -72,7 +177,7 @@ pub fn main() {\n     let mut c = c_orig.clone();\n     c.curr_mark = 20;\n     assert!(!c.saw_prev_marked);\n-    v.for_each_child(&mut c);\n+    v.descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n     if PRINT { println!(\"\"); }\n@@ -93,7 +198,7 @@ pub fn main() {\n     for (key, _) in h.iter() {\n         c.curr_mark += 1;\n         c.saw_prev_marked = false;\n-        key.for_each_child(&mut c);\n+        key.descend_into_self(&mut c);\n         assert!(c.saw_prev_marked);\n     }\n \n@@ -115,7 +220,7 @@ pub fn main() {\n     for (key, _) in h.iter() {\n         c.curr_mark += 1;\n         c.saw_prev_marked = false;\n-        key.for_each_child(&mut c);\n+        key.descend_into_self(&mut c);\n         assert!(c.saw_prev_marked);\n         // break;\n     }\n@@ -133,7 +238,7 @@ pub fn main() {\n     let mut c = c_orig.clone();\n     c.curr_mark = 50;\n     assert!(!c.saw_prev_marked);\n-    vd[0].for_each_child(&mut c);\n+    vd[0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n     if PRINT { println!(\"\"); }\n@@ -148,7 +253,7 @@ pub fn main() {\n     let mut c = c_orig.clone();\n     c.curr_mark = 60;\n     assert!(!c.saw_prev_marked);\n-    vd[0].for_each_child(&mut c);\n+    vd[0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n     if PRINT { println!(\"\"); }\n@@ -163,7 +268,7 @@ pub fn main() {\n     let mut c = c_orig.clone();\n     c.curr_mark = 70;\n     assert!(!c.saw_prev_marked);\n-    vm[&0].for_each_child(&mut c);\n+    vm[&0].descend_into_self(&mut c);\n     assert!(c.saw_prev_marked);\n \n     if PRINT { println!(\"\"); }\n@@ -181,7 +286,7 @@ pub fn main() {\n     for e in &ll {\n         c.curr_mark += 1;\n         c.saw_prev_marked = false;\n-        e.for_each_child(&mut c);\n+        e.descend_into_self(&mut c);\n         assert!(c.saw_prev_marked);\n         // break;\n     }\n@@ -201,7 +306,7 @@ pub fn main() {\n     for b in &bh {\n         c.curr_mark += 1;\n         c.saw_prev_marked = false;\n-        b.for_each_child(&mut c);\n+        b.descend_into_self(&mut c);\n         assert!(c.saw_prev_marked);\n         // break;\n     }\n@@ -222,7 +327,7 @@ pub fn main() {\n     for (k, _) in &btm {\n         c.curr_mark += 1;\n         c.saw_prev_marked = false;\n-        k.for_each_child(&mut c);\n+        k.descend_into_self(&mut c);\n         assert!(c.saw_prev_marked);\n         // break;\n     }\n@@ -242,10 +347,98 @@ pub fn main() {\n     for b in &bts {\n         c.curr_mark += 1;\n         c.saw_prev_marked = false;\n-        b.for_each_child(&mut c);\n+        b.descend_into_self(&mut c);\n         assert!(c.saw_prev_marked);\n         // break;\n     }\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 11: { rc0 -> (rc1, rc2), rc1 -> (), rc2 -> rc0 }\n+    let (rc0, rc1, rc2): (RCRC, RCRC, RCRC);\n+    rc0 = RCRC::new(\"rcrc0\");\n+    rc1 = RCRC::new(\"rcrc1\");\n+    rc2 = RCRC::new(\"rcrc2\");\n+    rc0.0.borrow_mut().children.0 = Some(&rc1);\n+    rc0.0.borrow_mut().children.1 = Some(&rc2);\n+    rc2.0.borrow_mut().children.0 = Some(&rc0);\n+\n+    let mut c = c_orig.clone();\n+    c.control_bits = 0b1;\n+    c.curr_mark = 110;\n+    assert!(!c.saw_prev_marked);\n+    rc0.descend_into_self(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // We want to take the previous Rc case and generalize it to Arc.\n+    //\n+    // We can use refcells if we're single-threaded (as this test is).\n+    // If one were to generalize these constructions to a\n+    // multi-threaded context, then it might seem like we could choose\n+    // between either a RwLock or a Mutex to hold the owned arcs on\n+    // each node.\n+    //\n+    // Part of the point of this test is to actually confirm that the\n+    // cycle exists by traversing it. We can do that just fine with an\n+    // RwLock (since we can grab the child pointers in read-only\n+    // mode), but we cannot lock a std::sync::Mutex to guard reading\n+    // from each node via the same pattern, since once you hit the\n+    // cycle, you'll be trying to acquring the same lock twice.\n+    // (We deal with this by exiting the traversal early if try_lock fails.)\n+\n+    // Cycle 12: { arc0 -> (arc1, arc2), arc1 -> (), arc2 -> arc0 }, refcells\n+    let (arc0, arc1, arc2): (ARCRC, ARCRC, ARCRC);\n+    arc0 = ARCRC::new(\"arcrc0\");\n+    arc1 = ARCRC::new(\"arcrc1\");\n+    arc2 = ARCRC::new(\"arcrc2\");\n+    arc0.0.borrow_mut().children.0 = Some(&arc1);\n+    arc0.0.borrow_mut().children.1 = Some(&arc2);\n+    arc2.0.borrow_mut().children.0 = Some(&arc0);\n+\n+    let mut c = c_orig.clone();\n+    c.control_bits = 0b1;\n+    c.curr_mark = 110;\n+    assert!(!c.saw_prev_marked);\n+    arc0.descend_into_self(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 13: { arc0 -> (arc1, arc2), arc1 -> (), arc2 -> arc0 }, rwlocks\n+    let (arc0, arc1, arc2): (ARCRW, ARCRW, ARCRW);\n+    arc0 = ARCRW::new(\"arcrw0\");\n+    arc1 = ARCRW::new(\"arcrw1\");\n+    arc2 = ARCRW::new(\"arcrw2\");\n+    arc0.0.write().unwrap().children.0 = Some(&arc1);\n+    arc0.0.write().unwrap().children.1 = Some(&arc2);\n+    arc2.0.write().unwrap().children.0 = Some(&arc0);\n+\n+    let mut c = c_orig.clone();\n+    c.control_bits = 0b1;\n+    c.curr_mark = 110;\n+    assert!(!c.saw_prev_marked);\n+    arc0.descend_into_self(&mut c);\n+    assert!(c.saw_prev_marked);\n+\n+    if PRINT { println!(\"\"); }\n+\n+    // Cycle 14: { arc0 -> (arc1, arc2), arc1 -> (), arc2 -> arc0 }, mutexs\n+    let (arc0, arc1, arc2): (ARCM, ARCM, ARCM);\n+    arc0 = ARCM::new(\"arcm0\");\n+    arc1 = ARCM::new(\"arcm1\");\n+    arc2 = ARCM::new(\"arcm2\");\n+    arc0.1.lock().unwrap().children.0 = Some(&arc1);\n+    arc0.1.lock().unwrap().children.1 = Some(&arc2);\n+    arc2.1.lock().unwrap().children.0 = Some(&arc0);\n+\n+    let mut c = c_orig.clone();\n+    c.control_bits = 0b1;\n+    c.curr_mark = 110;\n+    assert!(!c.saw_prev_marked);\n+    arc0.descend_into_self(&mut c);\n+    assert!(c.saw_prev_marked);\n }\n \n trait Named {\n@@ -276,6 +469,26 @@ impl<'a> Marked<u32> for S<'a> {\n     fn set_mark(&self, mark: u32) { self.mark.set(mark); }\n }\n \n+struct S2<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    next: Cell<(Option<&'a S2<'a>>, Option<&'a S2<'a>>)>,\n+}\n+\n+impl<'a> Named for S2<'a> {\n+    fn new<'b>(name: &'static str) -> S2<'b> {\n+        S2 { name: name, mark: Cell::new(0), next: Cell::new((None, None)) }\n+    }\n+    fn name(&self) -> &str { self.name }\n+}\n+\n+impl<'a> Marked<u32> for S2<'a> {\n+    fn mark(&self) -> u32 { self.mark.get() }\n+    fn set_mark(&self, mark: u32) {\n+        self.mark.set(mark);\n+    }\n+}\n+\n struct V<'a> {\n     name: &'static str,\n     mark: Cell<u32>,\n@@ -549,8 +762,168 @@ impl<'a> Ord for BTS<'a> {\n     }\n }\n \n+#[derive(Clone)]\n+struct RCRCData<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    children: (Option<&'a RCRC<'a>>, Option<&'a RCRC<'a>>),\n+}\n+#[derive(Clone)]\n+struct RCRC<'a>(Rc<RefCell<RCRCData<'a>>>);\n+\n+impl<'a> Named for RCRC<'a> {\n+    fn new(name: &'static str) -> Self {\n+        RCRC(Rc::new(RefCell::new(RCRCData {\n+            name: name, mark: Cell::new(0), children: (None, None), })))\n+    }\n+    fn name(&self) -> &str { self.0.borrow().name }\n+}\n+\n+impl<'a> Marked<u32> for RCRC<'a> {\n+    fn mark(&self) -> u32 { self.0.borrow().mark.get() }\n+    fn set_mark(&self, mark: u32) { self.0.borrow().mark.set(mark); }\n+}\n+\n+impl<'a> Children<'a> for RCRC<'a> {\n+    fn count_children(&self) -> usize { 2 }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        let children = &self.0.borrow().children;\n+        let child = match index {\n+            0 => if let Some(child) = children.0 { child } else { return; },\n+            1 => if let Some(child) = children.1 { child } else { return; },\n+            _ => panic!(\"bad children\"),\n+        };\n+        // println!(\"S2 {} descending into child {} at index {}\", self.name, child.name, index);\n+        child.descend_into_self(context);\n+    }\n+}\n+#[derive(Clone)]\n+struct ARCRCData<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    children: (Option<&'a ARCRC<'a>>, Option<&'a ARCRC<'a>>),\n+}\n+#[derive(Clone)]\n+struct ARCRC<'a>(Arc<RefCell<ARCRCData<'a>>>);\n+\n+impl<'a> Named for ARCRC<'a> {\n+    fn new(name: &'static str) -> Self {\n+        ARCRC(Arc::new(RefCell::new(ARCRCData {\n+            name: name, mark: Cell::new(0), children: (None, None), })))\n+    }\n+    fn name(&self) -> &str { self.0.borrow().name }\n+}\n+\n+impl<'a> Marked<u32> for ARCRC<'a> {\n+    fn mark(&self) -> u32 { self.0.borrow().mark.get() }\n+    fn set_mark(&self, mark: u32) { self.0.borrow().mark.set(mark); }\n+}\n+\n+impl<'a> Children<'a> for ARCRC<'a> {\n+    fn count_children(&self) -> usize { 2 }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        let children = &self.0.borrow().children;\n+        match index {\n+            0 => if let Some(ref child) = children.0 {\n+                child.descend_into_self(context);\n+            },\n+            1 => if let Some(ref child) = children.1 {\n+                child.descend_into_self(context);\n+            },\n+            _ => panic!(\"bad children!\"),\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct ARCMData<'a> {\n+    mark: Cell<u32>,\n+    children: (Option<&'a ARCM<'a>>, Option<&'a ARCM<'a>>),\n+}\n+\n+#[derive(Clone)]\n+struct ARCM<'a>(&'static str, Arc<Mutex<ARCMData<'a>>>);\n+\n+impl<'a> Named for ARCM<'a> {\n+    fn new(name: &'static str) -> Self {\n+        ARCM(name, Arc::new(Mutex::new(ARCMData {\n+            mark: Cell::new(0), children: (None, None), })))\n+    }\n+    fn name(&self) -> &str { self.0 }\n+}\n+\n+impl<'a> Marked<u32> for ARCM<'a> {\n+    fn mark(&self) -> u32 { self.1.lock().unwrap().mark.get() }\n+    fn set_mark(&self, mark: u32) { self.1.lock().unwrap().mark.set(mark); }\n+}\n+\n+impl<'a> Children<'a> for ARCM<'a> {\n+    fn count_children(&self) -> usize { 2 }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        let ref children = if let Ok(data) = self.1.try_lock() {\n+            data.children\n+        } else { return; };\n+        match index {\n+            0 => if let Some(ref child) = children.0 {\n+                child.descend_into_self(context);\n+            },\n+            1 => if let Some(ref child) = children.1 {\n+                child.descend_into_self(context);\n+            },\n+            _ => panic!(\"bad children!\"),\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct ARCRWData<'a> {\n+    name: &'static str,\n+    mark: Cell<u32>,\n+    children: (Option<&'a ARCRW<'a>>, Option<&'a ARCRW<'a>>),\n+}\n+\n+#[derive(Clone)]\n+struct ARCRW<'a>(Arc<RwLock<ARCRWData<'a>>>);\n+\n+impl<'a> Named for ARCRW<'a> {\n+    fn new(name: &'static str) -> Self {\n+        ARCRW(Arc::new(RwLock::new(ARCRWData {\n+            name: name, mark: Cell::new(0), children: (None, None), })))\n+    }\n+    fn name(&self) -> &str { self.0.read().unwrap().name }\n+}\n+\n+impl<'a> Marked<u32> for ARCRW<'a> {\n+    fn mark(&self) -> u32 { self.0.read().unwrap().mark.get() }\n+    fn set_mark(&self, mark: u32) { self.0.read().unwrap().mark.set(mark); }\n+}\n+\n+impl<'a> Children<'a> for ARCRW<'a> {\n+    fn count_children(&self) -> usize { 2 }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        let children = &self.0.read().unwrap().children;\n+        match index {\n+            0 => if let Some(ref child) = children.0 {\n+                child.descend_into_self(context);\n+            },\n+            1 => if let Some(ref child) = children.1 {\n+                child.descend_into_self(context);\n+            },\n+            _ => panic!(\"bad children!\"),\n+        }\n+    }\n+}\n \n trait Context {\n+    fn next_index(&mut self, len: usize) -> usize;\n     fn should_act(&self) -> bool;\n     fn increase_visited(&mut self);\n     fn increase_skipped(&mut self);\n@@ -565,17 +938,25 @@ trait PrePost<T> {\n }\n \n trait Children<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n+    fn count_children(&self) -> usize;\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n         where C: Context + PrePost<Self>, Self: Sized;\n \n+    fn next_child<C>(&self, context: &mut C)\n+        where C: Context + PrePost<Self>, Self: Sized\n+    {\n+        let index = context.next_index(self.count_children());\n+        self.descend_one_child(context, index);\n+    }\n+\n     fn descend_into_self<C>(&self, context: &mut C)\n         where C: Context + PrePost<Self>, Self: Sized\n     {\n         context.pre(self);\n         if context.should_act() {\n             context.increase_visited();\n             context.increase_depth();\n-            self.for_each_child(context);\n+            self.next_child(context);\n             context.decrease_depth();\n         } else {\n             context.hit_limit(self);\n@@ -594,113 +975,148 @@ trait Children<'a> {\n }\n \n impl<'a> Children<'a> for S<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n-        where C: Context + PrePost<S<'a>>\n+    fn count_children(&self) -> usize { 1 }\n+    fn descend_one_child<C>(&self, context: &mut C, _: usize)\n+        where C: Context + PrePost<Self>, Self: Sized {\n+            self.descend(&self.next, context);\n+        }\n+}\n+\n+impl<'a> Children<'a> for S2<'a> {\n+    fn count_children(&self) -> usize { 2 }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n     {\n-        self.descend(&self.next, context);\n+        let children = self.next.get();\n+        let child = match index {\n+            0 => if let Some(child) = children.0 { child } else { return; },\n+            1 => if let Some(child) = children.1 { child } else { return; },\n+            _ => panic!(\"bad children\"),\n+        };\n+        // println!(\"S2 {} descending into child {} at index {}\", self.name, child.name, index);\n+        child.descend_into_self(context);\n     }\n }\n \n impl<'a> Children<'a> for V<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n-        where C: Context + PrePost<V<'a>>\n+    fn count_children(&self) -> usize { self.contents.len() }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n     {\n-        for r in &self.contents {\n-            self.descend(r, context);\n+        if let Some(child) = self.contents[index].get() {\n+            child.descend_into_self(context);\n         }\n     }\n }\n \n impl<'a> Children<'a> for H<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n-        where C: Context + PrePost<H<'a>>\n+    fn count_children(&self) -> usize { 1 }\n+    fn descend_one_child<C>(&self, context: &mut C, _: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n     {\n         self.descend(&self.next, context);\n     }\n }\n \n impl<'a> Children<'a> for HM<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n-        where C: Context + PrePost<HM<'a>>\n+    fn count_children(&self) -> usize {\n+        if let Some(m) = self.contents.get() { 2 * m.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n     {\n         if let Some(ref hm) = self.contents.get() {\n-            for (k, v) in hm.iter() {\n-                for r in &[k, v] {\n-                    r.descend_into_self(context);\n-                }\n+            for (k, v) in hm.iter().nth(index / 2) {\n+                [k, v][index % 2].descend_into_self(context);\n             }\n         }\n     }\n }\n \n impl<'a> Children<'a> for VD<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n-        where C: Context + PrePost<VD<'a>>\n+    fn count_children(&self) -> usize {\n+        if let Some(d) = self.contents.get() { d.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n+        where C: Context + PrePost<Self>, Self: Sized\n     {\n         if let Some(ref vd) = self.contents.get() {\n-            for r in vd.iter() {\n+            for r in vd.iter().nth(index) {\n                 r.descend_into_self(context);\n             }\n         }\n     }\n }\n \n impl<'a> Children<'a> for VM<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n+    fn count_children(&self) -> usize {\n+        if let Some(m) = self.contents.get() { m.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n         where C: Context + PrePost<VM<'a>>\n     {\n         if let Some(ref vd) = self.contents.get() {\n-            for (_idx, r) in vd.iter() {\n+            for (_idx, r) in vd.iter().nth(index) {\n                 r.descend_into_self(context);\n             }\n         }\n     }\n }\n \n impl<'a> Children<'a> for LL<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n+    fn count_children(&self) -> usize {\n+        if let Some(l) = self.contents.get() { l.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n         where C: Context + PrePost<LL<'a>>\n     {\n         if let Some(ref ll) = self.contents.get() {\n-            for r in ll.iter() {\n+            for r in ll.iter().nth(index) {\n                 r.descend_into_self(context);\n             }\n         }\n     }\n }\n \n impl<'a> Children<'a> for BH<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n+    fn count_children(&self) -> usize {\n+        if let Some(h) = self.contents.get() { h.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n         where C: Context + PrePost<BH<'a>>\n     {\n         if let Some(ref bh) = self.contents.get() {\n-            for r in bh.iter() {\n+            for r in bh.iter().nth(index) {\n                 r.descend_into_self(context);\n             }\n         }\n     }\n }\n \n impl<'a> Children<'a> for BTM<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n+    fn count_children(&self) -> usize {\n+        if let Some(m) = self.contents.get() { 2 * m.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n         where C: Context + PrePost<BTM<'a>>\n     {\n         if let Some(ref bh) = self.contents.get() {\n-            for (k, v) in bh.iter() {\n-                for r in &[k, v] {\n-                    r.descend_into_self(context);\n-                }\n+            for (k, v) in bh.iter().nth(index / 2) {\n+                [k, v][index % 2].descend_into_self(context);\n             }\n         }\n     }\n }\n \n impl<'a> Children<'a> for BTS<'a> {\n-    fn for_each_child<C>(&self, context: &mut C)\n+    fn count_children(&self) -> usize {\n+        if let Some(s) = self.contents.get() { s.iter().count() } else { 0 }\n+    }\n+    fn descend_one_child<C>(&self, context: &mut C, index: usize)\n         where C: Context + PrePost<BTS<'a>>\n     {\n         if let Some(ref bh) = self.contents.get() {\n-            for r in bh.iter() {\n+            for r in bh.iter().nth(index) {\n                 r.descend_into_self(context);\n             }\n         }\n@@ -716,9 +1132,27 @@ struct ContextData {\n     skipped: usize,\n     curr_mark: u32,\n     saw_prev_marked: bool,\n+    control_bits: u64,\n }\n \n impl Context for ContextData {\n+    fn next_index(&mut self, len: usize) -> usize {\n+        if len < 2 { return 0; }\n+        let mut pow2 = len.next_power_of_two();\n+        let _pow2_orig = pow2;\n+        let mut idx = 0;\n+        let mut bits = self.control_bits;\n+        while pow2 > 1 {\n+            idx = (idx << 1) | (bits & 1) as usize;\n+            bits = bits >> 1;\n+            pow2 = pow2 >> 1;\n+        }\n+        idx = idx % len;\n+        // println!(\"next_index({} [{:b}]) says {}, pre(bits): {:b} post(bits): {:b}\",\n+        //          len, _pow2_orig, idx, self.control_bits, bits);\n+        self.control_bits = bits;\n+        return idx;\n+    }\n     fn should_act(&self) -> bool {\n         self.curr_depth < self.max_depth && self.visited < self.max_visits\n     }"}]}