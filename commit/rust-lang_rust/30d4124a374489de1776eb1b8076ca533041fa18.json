{"sha": "30d4124a374489de1776eb1b8076ca533041fa18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZDQxMjRhMzc0NDg5ZGUxNzc2ZWIxYjgwNzZjYTUzMzA0MWZhMTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-24T22:37:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-25T19:28:54Z"}, "message": "Merge remote-tracking branch 'brson/rt'\n\nConflicts:\n\tsrc/libcore/rt/context.rs\n\tsrc/libcore/rt/sched.rs\n\tsrc/libcore/rt/thread.rs\n\tsrc/libcore/rt/uv.rs", "tree": {"sha": "6d20b47e1cd46ba0b42f232b097d1246efc5f23b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d20b47e1cd46ba0b42f232b097d1246efc5f23b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30d4124a374489de1776eb1b8076ca533041fa18", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30d4124a374489de1776eb1b8076ca533041fa18", "html_url": "https://github.com/rust-lang/rust/commit/30d4124a374489de1776eb1b8076ca533041fa18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30d4124a374489de1776eb1b8076ca533041fa18/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a56ec8c1342453a88be79e192a11501844375d40", "url": "https://api.github.com/repos/rust-lang/rust/commits/a56ec8c1342453a88be79e192a11501844375d40", "html_url": "https://github.com/rust-lang/rust/commit/a56ec8c1342453a88be79e192a11501844375d40"}, {"sha": "5af5766512b0e90a3a076a09b35286aca332e48e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af5766512b0e90a3a076a09b35286aca332e48e", "html_url": "https://github.com/rust-lang/rust/commit/5af5766512b0e90a3a076a09b35286aca332e48e"}], "stats": {"total": 2901, "additions": 1815, "deletions": 1086}, "files": [{"sha": "dd2e6a95861bd82f3a851d71f18336ed900889a9", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -238,7 +238,7 @@ $(foreach target,$(CFG_TARGET_TRIPLES),\\\n \n CORELIB_CRATE := $(S)src/libcore/core.rc\n CORELIB_INPUTS := $(wildcard $(addprefix $(S)src/libcore/,        \\\n-                                           core.rc *.rs */*.rs))\n+                                           core.rc *.rs */*.rs */*/*rs))\n \n ######################################################################\n # Standard library variables"}, {"sha": "f96b7325f60d4abab77a4b8f576c87377eb62657", "filename": "mk/tests.mk", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -244,21 +244,29 @@ $(foreach host,$(CFG_HOST_TRIPLES), \\\n \n define TEST_RUNNER\n \n+# If NO_REBUILD is set then break the dependencies on std so we can\n+# test crates without rebuilding core and std first\n+ifeq ($(NO_REBUILD),)\n+STDTESTDEP_$(1)_$(2)_$(3) = $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB_$(2))\n+else\n+STDTESTDEP_$(1)_$(2)_$(3) =\n+endif\n+\n $(3)/test/coretest.stage$(1)-$(2)$$(X_$(2)):\t\t\t\\\n \t\t$$(CORELIB_CRATE) $$(CORELIB_INPUTS)\t\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB_$(2))\n+\t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n $(3)/test/stdtest.stage$(1)-$(2)$$(X_$(2)):\t\t\t\\\n \t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS)\t\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB_$(2))\n+\t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n $(3)/test/syntaxtest.stage$(1)-$(2)$$(X_$(2)):\t\t\t\\\n \t\t$$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS)\t\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB_$(2))\n+\t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n "}, {"sha": "f892e3a1e232a22078d66192368c1d13282de0ea", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -63,6 +63,9 @@ pub struct config {\n     // Run tests using the JIT\n     jit: bool,\n \n+    // Run tests using the new runtime\n+    newrt: bool,\n+\n     // Explain what's going on\n     verbose: bool\n "}, {"sha": "0c1f328ad09faaaf4496f39f8a7cd457c5334406", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -61,7 +61,8 @@ pub fn parse_config(args: ~[~str]) -> config {\n           getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n           getopts::optflag(~\"verbose\"),\n           getopts::optopt(~\"logfile\"),\n-          getopts::optflag(~\"jit\")];\n+          getopts::optflag(~\"jit\"),\n+          getopts::optflag(~\"newrt\")];\n \n     fail_unless!(!args.is_empty());\n     let args_ = vec::tail(args);\n@@ -95,6 +96,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n         jit: getopts::opt_present(matches, ~\"jit\"),\n+        newrt: getopts::opt_present(matches, ~\"newrt\"),\n         verbose: getopts::opt_present(matches, ~\"verbose\")\n     }\n }\n@@ -114,6 +116,7 @@ pub fn log_config(config: config) {\n     logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n     logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n     logv(c, fmt!(\"jit: %b\", config.jit));\n+    logv(c, fmt!(\"newrt: %b\", config.newrt));\n     logv(c, fmt!(\"verbose: %b\", config.verbose));\n     logv(c, fmt!(\"\\n\"));\n }"}, {"sha": "f17e9ffe548bde2fb8f6b15e63ddca4cfc6d8c24", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -484,9 +484,17 @@ fn compile_test_(config: config, props: TestProps,\n \n fn exec_compiled_test(config: config, props: TestProps,\n                       testfile: &Path) -> ProcRes {\n+\n+    // If testing the new runtime then set the RUST_NEWRT env var\n+    let env = if config.newrt {\n+        props.exec_env + ~[(~\"RUST_NEWRT\", ~\"1\")]\n+    } else {\n+        props.exec_env\n+    };\n+\n     compose_and_run(config, testfile,\n                     make_run_args(config, props, testfile),\n-                    props.exec_env,\n+                    env,\n                     config.run_lib_path, None)\n }\n "}, {"sha": "527acd4d1b1ba70d1d2cd3a93650a944732bda9f", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use option::*;\n use super::stack::StackSegment;\n use libc::c_void;\n use cast::{transmute, transmute_mut_unsafe,\n@@ -16,17 +17,30 @@ use cast::{transmute, transmute_mut_unsafe,\n // XXX: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n-pub struct Context(~Registers);\n+// XXX: It would be nice to define regs as `~Option<Registers>` since\n+// the registers are sometimes empty, but the discriminant would\n+// then misalign the regs again.\n+pub struct Context {\n+    /// The context entry point, saved here for later destruction\n+    start: Option<~~fn()>,\n+    /// Hold the registers while the task or scheduler is suspended\n+    regs: ~Registers\n+}\n \n pub impl Context {\n     fn empty() -> Context {\n-        Context(new_regs())\n+        Context {\n+            start: None,\n+            regs: new_regs()\n+        }\n     }\n \n     /// Create a new context that will resume execution by running ~fn()\n-    /// # Safety Note\n-    /// The `start` closure must remain valid for the life of the Task\n-    fn new(start: &~fn(), stack: &mut StackSegment) -> Context {\n+    fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n+        // XXX: Putting main into a ~ so it's a thin pointer and can\n+        // be passed to the spawn function.  Another unfortunate\n+        // allocation\n+        let start = ~start;\n \n         // The C-ABI function that is the task entry point\n         extern fn task_start_wrapper(f: &~fn()) { (*f)() }\n@@ -40,21 +54,29 @@ pub impl Context {\n         // which we will then modify to call the given function when restored\n         let mut regs = new_regs();\n         unsafe {\n-            swap_registers(transmute_mut_region(&mut *regs),\n-                           transmute_region(&*regs))\n+            swap_registers(transmute_mut_region(&mut *regs), transmute_region(&*regs))\n         };\n \n         initialize_call_frame(&mut *regs, fp, argp, sp);\n \n-        return Context(regs);\n+        return Context {\n+            start: Some(start),\n+            regs: regs\n+        }\n     }\n \n+    /* Switch contexts\n+\n+    Suspend the current execution context and resume another by\n+    saving the registers values of the executing thread to a Context\n+    then loading the registers from a previously saved Context.\n+    */\n     fn swap(out_context: &mut Context, in_context: &Context) {\n         let out_regs: &mut Registers = match out_context {\n-            &Context(~ref mut r) => r\n+            &Context { regs: ~ref mut r, _ } => r\n         };\n         let in_regs: &Registers = match in_context {\n-            &Context(~ref r) => r\n+            &Context { regs: ~ref r, _ } => r\n         };\n \n         unsafe { swap_registers(out_regs, in_regs) };\n@@ -84,11 +106,10 @@ fn new_regs() -> ~Registers {\n }\n \n #[cfg(target_arch = \"x86\")]\n-fn initialize_call_frame(regs: &mut Registers,\n-                         fptr: *c_void, arg: *c_void, sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp: *mut uint) {\n \n     let sp = align_down(sp);\n-    let sp = mut_offset(sp, -4); // XXX: -4 words? Needs this be done at all?\n+    let sp = mut_offset(sp, -4);\n \n     unsafe { *sp = arg as uint; }\n     let sp = mut_offset(sp, -1);\n@@ -108,8 +129,7 @@ type Registers = [uint * 22];\n fn new_regs() -> ~Registers { ~[0, .. 22] }\n \n #[cfg(target_arch = \"x86_64\")]\n-fn initialize_call_frame(regs: &mut Registers,\n-                         fptr: *c_void, arg: *c_void, sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp: *mut uint) {\n \n     // Redefinitions from regs.h\n     static RUSTRT_ARG0: uint = 3;\n@@ -143,8 +163,7 @@ type Registers = [uint * 32];\n fn new_regs() -> ~Registers { ~[0, .. 32] }\n \n #[cfg(target_arch = \"arm\")]\n-fn initialize_call_frame(regs: &mut Registers,\n-                         fptr: *c_void, arg: *c_void, sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp: *mut uint) {\n     let sp = mut_offset(sp, -1);\n \n     // The final return address. 0 indicates the bottom of the stack\n@@ -162,8 +181,7 @@ type Registers = [uint * 32];\n fn new_regs() -> ~Registers { ~[0, .. 32] }\n \n #[cfg(target_arch = \"mips\")]\n-fn initialize_call_frame(regs: &mut Registers,\n-                         fptr: *c_void, arg: *c_void, sp: *mut uint) {\n+fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp: *mut uint) {\n     let sp = mut_offset(sp, -1);\n \n     // The final return address. 0 indicates the bottom of the stack"}, {"sha": "9f1f200d8e466bd5ecfdedf9856a02d680db8ada", "filename": "src/libcore/rt/io/file.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::super::sched::*;\n+use super::super::rtio::*;\n+use super::Stream;\n+\n+pub struct FileStream;\n+\n+pub impl FileStream {\n+    fn new(_path: Path) -> FileStream {\n+        fail!()\n+    }\n+}\n+\n+impl Stream for FileStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> uint {\n+        fail!()\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        fail!()\n+    }\n+\n+    fn write(&mut self, _v: &const [u8]) {\n+        fail!()\n+    }\n+}\n+\n+#[test]\n+#[ignore]\n+fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {\n+    let message = \"it's alright. have a good time\";\n+    let filename = Path(\"test.txt\");\n+    let mut outstream = FileStream::new(filename);\n+    outstream.write(message.to_bytes());\n+}"}, {"sha": "f82092b829c9b53bf7f4ad0a42038a4e4f75e310", "filename": "src/libcore/rt/io/mod.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::*;\n+use comm::{GenericPort, GenericChan};\n+\n+pub mod file;\n+\n+// FIXME #5370 Strongly want this to be StreamError(&mut Stream)\n+pub struct StreamError;\n+\n+// XXX: Can't put doc comments on macros\n+// Raised by `Stream` instances on error. Returning `true` from the handler\n+// indicates that the `Stream` should continue, `false` that it should fail.\n+condition! {\n+    stream_error: super::StreamError -> bool;\n+}\n+\n+pub trait Stream {\n+    /// Read bytes, up to the length of `buf` and place them in `buf`,\n+    /// returning the number of bytes read or an `IoError`. Reads\n+    /// 0 bytes on EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `reader_error` condition on error\n+    fn read(&mut self, buf: &mut [u8]) -> uint;\n+\n+    /// Return whether the Reader has reached the end of the stream\n+    fn eof(&mut self) -> bool;\n+\n+    /// Write the given buffer\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `writer_error` condition on error\n+    fn write(&mut self, v: &const [u8]);\n+}"}, {"sha": "04891a1673c0a9a8e158e31eeef04283fad4ed3f", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -8,23 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc::c_char;\n \n // Some basic logging\n macro_rules! rtdebug_ (\n     ($( $arg:expr),+) => ( {\n         dumb_println(fmt!( $($arg),+ ));\n \n         fn dumb_println(s: &str) {\n-            use str::as_c_str;\n-            use libc::c_char;\n-\n-            extern {\n-                fn printf(s: *c_char);\n-            }\n-\n-            do as_c_str(s.to_str() + \"\\n\") |s| {\n-                unsafe { printf(s); }\n-            }\n+            use io::WriterUtil;\n+            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+            dbg.write_str(s);\n+            dbg.write_str(\"\\n\");\n         }\n \n     } )\n@@ -36,13 +31,37 @@ macro_rules! rtdebug (\n )\n \n mod sched;\n-mod io;\n+mod rtio;\n+pub mod uvll;\n mod uvio;\n+#[path = \"uv/mod.rs\"]\n mod uv;\n+#[path = \"io/mod.rs\"]\n+mod io;\n // FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n pub mod thread_local_storage;\n mod work_queue;\n mod stack;\n mod context;\n mod thread;\n pub mod env;\n+\n+pub fn start(main: *u8, _argc: int, _argv: *c_char, _crate_map: *u8) -> int {\n+    use self::sched::{Scheduler, Task};\n+    use self::uvio::UvEventLoop;\n+\n+    let loop_ = ~UvEventLoop::new();\n+    let mut sched = ~Scheduler::new(loop_);\n+    let main_task = ~do Task::new(&mut sched.stack_pool) {\n+        // XXX: Can't call a C function pointer from Rust yet\n+        unsafe { rust_call_nullary_fn(main) };\n+    };\n+    sched.task_queue.push_back(main_task);\n+    sched.run();\n+    return 0;\n+\n+    extern {\n+        fn rust_call_nullary_fn(f: *u8);\n+    }\n+}\n+"}, {"sha": "55e062de85b06054783f6104a14d538e5c662e77", "filename": "src/libcore/rt/rtio.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "previous_filename": "src/libcore/rt/io.rs"}, {"sha": "5034ffa3c6045ad99bf6146f2db9ffdf5e6ecc23", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -16,7 +16,7 @@ use ptr::mut_null;\n \n use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n-use super::io::{EventLoop, EventLoopObject};\n+use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n use tls = super::thread_local_storage;\n \n@@ -70,7 +70,14 @@ enum CleanupJob {\n \n pub impl Scheduler {\n \n-    pub fn new(event_loop: ~EventLoopObject) -> Scheduler {\n+    fn new(event_loop: ~EventLoopObject) -> Scheduler {\n+\n+        // Lazily initialize the global state, currently the scheduler TLS key\n+        unsafe { rust_initialize_global_state(); }\n+        extern {\n+            fn rust_initialize_global_state();\n+        }\n+\n         Scheduler {\n             event_loop: event_loop,\n             task_queue: WorkQueue::new(),\n@@ -183,8 +190,7 @@ pub impl Scheduler {\n \n         let blocked_task = self.current_task.swap_unwrap();\n         let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, ~Task),\n-                        &fn(&mut Scheduler, ~Task)>(f)\n+            transmute::<&fn(&mut Scheduler, ~Task), &fn(&mut Scheduler, ~Task)>(f)\n         };\n         let f_opaque = HackAroundBorrowCk::from_fn(f_fake_region);\n         self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n@@ -233,8 +239,7 @@ pub impl Scheduler {\n         Context::swap(task_context, scheduler_context);\n     }\n \n-    priv fn swap_in_task_from_running_task(&mut self,\n-                                           running_task: &mut Task) {\n+    priv fn swap_in_task_from_running_task(&mut self, running_task: &mut Task) {\n         let running_task_context = &mut running_task.saved_context;\n         let next_context = &self.current_task.get_ref().saved_context;\n         Context::swap(running_task_context, next_context);\n@@ -285,8 +290,6 @@ pub impl Scheduler {\n static TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n \n pub struct Task {\n-    /// The task entry point, saved here for later destruction\n-    priv start: ~~fn(),\n     /// The segment of stack on which the task is currently running or,\n     /// if the task is blocked, on which the task will resume execution\n     priv current_stack_segment: StackSegment,\n@@ -295,17 +298,13 @@ pub struct Task {\n     priv saved_context: Context,\n }\n \n-impl Task {\n-    pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n-        // XXX: Putting main into a ~ so it's a thin pointer and can\n-        // be passed to the spawn function.  Another unfortunate\n-        // allocation\n-        let start = ~Task::build_start_wrapper(start);\n+pub impl Task {\n+    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+        let start = Task::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n-        let initial_context = Context::new(&*start, &mut stack);\n+        let initial_context = Context::new(start, &mut stack);\n         return Task {\n-            start: start,\n             current_stack_segment: stack,\n             saved_context: initial_context,\n         };\n@@ -350,8 +349,7 @@ impl ThreadLocalScheduler {\n     fn put_scheduler(&mut self, scheduler: ~Scheduler) {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };\n-            let value: *mut c_void =\n-                transmute::<~Scheduler, *mut c_void>(scheduler);\n+            let value: *mut c_void = transmute::<~Scheduler, *mut c_void>(scheduler);\n             tls::set(key, value);\n         }\n     }\n@@ -363,8 +361,9 @@ impl ThreadLocalScheduler {\n             fail_unless!(value.is_not_null());\n             {\n                 let value_ptr = &mut value;\n-                let sched: &mut ~Scheduler =\n-                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr);\n+                let sched: &mut ~Scheduler = {\n+                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr)\n+                };\n                 let sched: &mut Scheduler = &mut **sched;\n                 return sched;\n             }"}, {"sha": "9eca3bda0473c079ab8889254ee88b202c391cda", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -27,6 +27,7 @@ pub impl StackSegment {\n         }\n     }\n \n+    /// Point one word beyond the high end of the allocated stack\n     fn end(&self) -> *uint {\n         unsafe {\n             vec::raw::to_ptr(self.buf).offset(self.buf.len()) as *uint"}, {"sha": "910e445f47b049716b5f2d7cb0e6545b9e74acb1", "filename": "src/libcore/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -14,13 +14,13 @@ use ops::Drop;\n #[allow(non_camel_case_types)] // runtime type\n type raw_thread = libc::c_void;\n \n-struct Thread {\n+pub struct Thread {\n     main: ~fn(),\n     raw_thread: *raw_thread\n }\n \n-impl Thread {\n-    pub fn start(main: ~fn()) -> Thread {\n+pub impl Thread {\n+    fn start(main: ~fn()) -> Thread {\n         fn substart(main: &fn()) -> *raw_thread {\n             unsafe { rust_raw_thread_start(&main) }\n         }"}, {"sha": "19ce04bd66b5c577123a55f60cfb58f5ea608e00", "filename": "src/libcore/rt/uv.rs", "status": "removed", "additions": 0, "deletions": 919, "changes": 919, "blob_url": "https://github.com/rust-lang/rust/blob/a56ec8c1342453a88be79e192a11501844375d40/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56ec8c1342453a88be79e192a11501844375d40/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=a56ec8c1342453a88be79e192a11501844375d40", "patch": "@@ -1,919 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Bindings to libuv.\n-\n-UV types consist of the event loop (Loop), Watchers, Requests and\n-Callbacks.\n-\n-Watchers and Requests encapsulate pointers to uv *handles*, which have\n-subtyping relationships with each other.  This subtyping is reflected\n-in the bindings with explicit or implicit coercions. For example, an\n-upcast from TcpWatcher to StreamWatcher is done with\n-`tcp_watcher.as_stream()`. In other cases a callback on a specific\n-type of watcher will be passed a watcher of a supertype.\n-\n-Currently all use of Request types (connect/write requests) are\n-encapsulated in the bindings and don't need to be dealt with by the\n-caller.\n-\n-# Safety note\n-\n-Due to the complex lifecycle of uv handles, as well as compiler bugs,\n-this module is not memory safe and requires explicit memory management,\n-via `close` and `delete` methods.\n-\n-*/\n-\n-use option::*;\n-use str::raw::from_c_str;\n-use to_str::ToStr;\n-use vec;\n-use ptr;\n-use libc::{c_void, c_int, size_t, malloc, free, ssize_t};\n-use cast::{transmute, transmute_mut_region};\n-use ptr::null;\n-use sys::size_of;\n-use unstable::uvll;\n-use super::io::{IpAddr, Ipv4, Ipv6};\n-\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::thread::Thread;\n-#[cfg(test)] use cell::Cell;\n-\n-fn ip4_to_uv_ip4(addr: IpAddr) -> uvll::sockaddr_in {\n-    match addr {\n-        Ipv4(a, b, c, d, p) => {\n-            unsafe {\n-                uvll::ip4_addr(fmt!(\"%u.%u.%u.%u\",\n-                                    a as uint,\n-                                    b as uint,\n-                                    c as uint,\n-                                    d as uint), p as int)\n-            }\n-        }\n-        Ipv6 => fail!()\n-    }\n-}\n-\n-/// A trait for callbacks to implement. Provides a little extra type safety\n-/// for generic, unsafe interop functions like `set_watcher_callback`.\n-trait Callback { }\n-\n-type NullCallback = ~fn();\n-impl Callback for NullCallback { }\n-\n-/// A type that wraps a native handle\n-trait NativeHandle<T> {\n-    pub fn from_native_handle(T) -> Self;\n-    pub fn native_handle(&self) -> T;\n-}\n-\n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    handle: *uvll::uv_loop_t\n-}\n-\n-pub impl Loop {\n-    fn new() -> Loop {\n-        let handle = unsafe { uvll::loop_new() };\n-        fail_unless!(handle.is_not_null());\n-        NativeHandle::from_native_handle(handle)\n-    }\n-\n-    fn run(&mut self) {\n-        unsafe { uvll::run(self.native_handle()) };\n-    }\n-\n-    fn close(&mut self) {\n-        unsafe { uvll::loop_delete(self.native_handle()) };\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_loop_t> for Loop {\n-    fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n-        Loop { handle: handle }\n-    }\n-    fn native_handle(&self) -> *uvll::uv_loop_t {\n-        self.handle\n-    }\n-}\n-\n-/// The trait implemented by uv 'watchers' (handles). Watchers are\n-/// non-owning wrappers around the uv handles and are not completely\n-/// safe - there may be multiple instances for a single underlying\n-/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n-/// and `close`ed, but due to their complex life cycle may not be\n-/// entirely memory safe if used in unanticipated patterns.\n-trait Watcher {\n-    fn event_loop(&self) -> Loop;\n-}\n-\n-pub struct IdleWatcher(*uvll::uv_idle_t);\n-\n-impl Watcher for IdleWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n-impl Callback for IdleCallback { }\n-\n-pub impl IdleWatcher {\n-    fn new(loop_: &mut Loop) -> IdleWatcher {\n-        unsafe {\n-            let handle = uvll::idle_new();\n-            fail_unless!(handle.is_not_null());\n-            fail_unless!(0 == uvll::idle_init(loop_.native_handle(), handle));\n-            uvll::set_data_for_uv_handle(handle, null::<()>());\n-            NativeHandle::from_native_handle(handle)\n-        }\n-    }\n-\n-    fn start(&mut self, cb: IdleCallback) {\n-\n-        set_watcher_callback(self, cb);\n-        unsafe {\n-            fail_unless!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let idle_watcher: IdleWatcher =\n-                NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback =\n-                borrow_callback_from_watcher(&idle_watcher);\n-            let status = status_to_maybe_uv_error(handle, status);\n-            (*cb)(idle_watcher, status);\n-        }\n-    }\n-\n-    fn stop(&mut self) {\n-        unsafe { fail_unless!(0 == uvll::idle_stop(self.native_handle())); }\n-    }\n-\n-    fn close(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n-            drop_watcher_callback::<uvll::uv_idle_t,\n-                                    IdleWatcher,\n-                                    IdleCallback>(&mut idle_watcher);\n-            unsafe { uvll::idle_delete(handle) };\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n-    }\n-}\n-\n-// uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n-// and uv_file_t\n-pub struct StreamWatcher(*uvll::uv_stream_t);\n-\n-impl Watcher for StreamWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n-impl Callback for ReadCallback { }\n-\n-// XXX: The uv alloc callback also has a *uv_handle_t arg\n-pub type AllocCallback = ~fn(uint) -> Buf;\n-impl Callback for AllocCallback { }\n-\n-pub impl StreamWatcher {\n-\n-    fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        // XXX: Borrowchk problems\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        data.alloc_cb = Some(alloc);\n-        data.read_cb = Some(cb);\n-\n-        let handle = self.native_handle();\n-        unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n-\n-        extern fn alloc_cb(stream: *uvll::uv_stream_t,\n-                           suggested_size: size_t) -> Buf {\n-            let mut stream_watcher: StreamWatcher =\n-                NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n-            let alloc_cb = data.alloc_cb.get_ref();\n-            return (*alloc_cb)(suggested_size as uint);\n-        }\n-\n-        extern fn read_cb(stream: *uvll::uv_stream_t,\n-                          nread: ssize_t, ++buf: Buf) {\n-            rtdebug!(\"buf addr: %x\", buf.base as uint);\n-            rtdebug!(\"buf len: %d\", buf.len as int);\n-            let mut stream_watcher: StreamWatcher =\n-                NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n-            let cb = data.read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream, nread as c_int);\n-            (*cb)(stream_watcher, nread as int, buf, status);\n-        }\n-    }\n-\n-    fn read_stop(&mut self) {\n-        // It would be nice to drop the alloc and read callbacks here,\n-        // but read_stop may be called from inside one of them and we\n-        // would end up freeing the in-use environment\n-        let handle = self.native_handle();\n-        unsafe { uvll::read_stop(handle); }\n-    }\n-\n-    // XXX: Needs to take &[u8], not ~[u8]\n-    fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        fail_unless!(data.write_cb.is_none());\n-        data.write_cb = Some(cb);\n-\n-        let req = WriteRequest::new();\n-        let buf = vec_to_uv_buf(msg);\n-        // XXX: Allocation\n-        let bufs = ~[buf];\n-        unsafe {\n-            fail_unless!(0 == uvll::write(req.native_handle(),\n-                                          self.native_handle(),\n-                                          &bufs, write_cb));\n-        }\n-        // XXX: Freeing immediately after write. Is this ok?\n-        let _v = vec_from_uv_buf(buf);\n-\n-        extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n-            let write_request: WriteRequest =\n-                NativeHandle::from_native_handle(req);\n-            let mut stream_watcher = write_request.stream();\n-            write_request.delete();\n-            let cb = get_watcher_data(&mut stream_watcher)\n-                .write_cb.swap_unwrap();\n-            let status = status_to_maybe_uv_error(\n-                stream_watcher.native_handle(), status);\n-            cb(stream_watcher, status);\n-        }\n-    }\n-\n-    fn accept(&mut self, stream: StreamWatcher) {\n-        let self_handle = self.native_handle() as *c_void;\n-        let stream_handle = stream.native_handle() as *c_void;\n-        unsafe {\n-            fail_unless!(0 == uvll::accept(self_handle, stream_handle));\n-        }\n-    }\n-\n-    fn close(self, cb: NullCallback) {\n-        {\n-            let mut self = self;\n-            let data = get_watcher_data(&mut self);\n-            fail_unless!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_stream_t) {\n-            let mut stream_watcher: StreamWatcher =\n-                NativeHandle::from_native_handle(handle);\n-            {\n-                let mut data = get_watcher_data(&mut stream_watcher);\n-                data.close_cb.swap_unwrap()();\n-            }\n-            drop_watcher_data(&mut stream_watcher);\n-            unsafe { free(handle as *c_void) }\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n-    fn from_native_handle(\n-        handle: *uvll::uv_stream_t) -> StreamWatcher {\n-        StreamWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_stream_t {\n-        match self { &StreamWatcher(ptr) => ptr }\n-    }\n-}\n-\n-pub struct TcpWatcher(*uvll::uv_tcp_t);\n-\n-impl Watcher for TcpWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-impl Callback for ConnectionCallback { }\n-\n-pub impl TcpWatcher {\n-    fn new(loop_: &mut Loop) -> TcpWatcher {\n-        unsafe {\n-            let size = size_of::<uvll::uv_tcp_t>() as size_t;\n-            let handle = malloc(size) as *uvll::uv_tcp_t;\n-            fail_unless!(handle.is_not_null());\n-            fail_unless!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n-            let mut watcher = NativeHandle::from_native_handle(handle);\n-            install_watcher_data(&mut watcher);\n-            return watcher;\n-        }\n-    }\n-\n-    fn bind(&mut self, address: IpAddr) {\n-        match address {\n-            Ipv4(*) => {\n-                let addr = ip4_to_uv_ip4(address);\n-                let result = unsafe {\n-                    uvll::tcp_bind(self.native_handle(), &addr)\n-                };\n-                // XXX: bind is likely to fail. need real error handling\n-                fail_unless!(result == 0);\n-            }\n-            _ => fail!()\n-        }\n-    }\n-\n-    fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n-        unsafe {\n-            fail_unless!(get_watcher_data(self).connect_cb.is_none());\n-            get_watcher_data(self).connect_cb = Some(cb);\n-\n-            let mut connect_watcher = ConnectRequest::new();\n-            let connect_handle = connect_watcher.native_handle();\n-            match address {\n-                Ipv4(*) => {\n-                    let addr = ip4_to_uv_ip4(address);\n-                    rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-                    fail_unless!(0 == uvll::tcp_connect(connect_handle,\n-                                                        self.native_handle(),\n-                                                        &addr, connect_cb));\n-                }\n-                _ => fail!()\n-            }\n-\n-            extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n-                rtdebug!(\"connect_t: %x\", req as uint);\n-                let connect_request: ConnectRequest =\n-                    NativeHandle::from_native_handle(req);\n-                let mut stream_watcher = connect_request.stream();\n-                connect_request.delete();\n-                let cb: ConnectionCallback = {\n-                    let data = get_watcher_data(&mut stream_watcher);\n-                    data.connect_cb.swap_unwrap()\n-                };\n-                let status = status_to_maybe_uv_error(\n-                    stream_watcher.native_handle(), status);\n-                cb(stream_watcher, status);\n-            }\n-        }\n-    }\n-\n-    fn listen(&mut self, cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        fail_unless!(data.connect_cb.is_none());\n-        data.connect_cb = Some(cb);\n-\n-        unsafe {\n-            static BACKLOG: c_int = 128; // XXX should be configurable\n-            // XXX: This can probably fail\n-            fail_unless!(0 == uvll::listen(self.native_handle(),\n-                                           BACKLOG, connection_cb));\n-        }\n-\n-        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n-            rtdebug!(\"connection_cb\");\n-            let mut stream_watcher: StreamWatcher =\n-                NativeHandle::from_native_handle(handle);\n-            let cb = get_watcher_data(&mut stream_watcher)\n-                .connect_cb.swap_unwrap();\n-            let status = status_to_maybe_uv_error(\n-                stream_watcher.native_handle(), status);\n-            cb(stream_watcher, status);\n-        }\n-    }\n-\n-    fn as_stream(&self) -> StreamWatcher {\n-        NativeHandle::from_native_handle(\n-            self.native_handle() as *uvll::uv_stream_t)\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n-    fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n-        TcpWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_tcp_t {\n-        match self { &TcpWatcher(ptr) => ptr }\n-    }\n-}\n-\n-trait Request { }\n-\n-type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n-impl Callback for ConnectCallback { }\n-\n-// uv_connect_t is a subclass of uv_req_t\n-struct ConnectRequest(*uvll::uv_connect_t);\n-\n-impl Request for ConnectRequest { }\n-\n-impl ConnectRequest {\n-\n-    fn new() -> ConnectRequest {\n-        let connect_handle = unsafe {\n-            malloc(size_of::<uvll::uv_connect_t>() as size_t)\n-        };\n-        fail_unless!(connect_handle.is_not_null());\n-        let connect_handle = connect_handle as *uvll::uv_connect_t;\n-        ConnectRequest(connect_handle)\n-    }\n-\n-    fn stream(&self) -> StreamWatcher {\n-        unsafe {\n-            let stream_handle =\n-                uvll::get_stream_handle_from_connect_req(\n-                    self.native_handle());\n-            NativeHandle::from_native_handle(stream_handle)\n-        }\n-    }\n-\n-    fn delete(self) {\n-        unsafe { free(self.native_handle() as *c_void) }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n-    fn from_native_handle(\n-        handle: *uvll:: uv_connect_t) -> ConnectRequest {\n-        ConnectRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_connect_t {\n-        match self { &ConnectRequest(ptr) => ptr }\n-    }\n-}\n-\n-pub struct WriteRequest(*uvll::uv_write_t);\n-\n-impl Request for WriteRequest { }\n-\n-impl WriteRequest {\n-\n-    fn new() -> WriteRequest {\n-        let write_handle = unsafe {\n-            malloc(size_of::<uvll::uv_write_t>() as size_t)\n-        };\n-        fail_unless!(write_handle.is_not_null());\n-        let write_handle = write_handle as *uvll::uv_write_t;\n-        WriteRequest(write_handle)\n-    }\n-\n-    fn stream(&self) -> StreamWatcher {\n-        unsafe {\n-            let stream_handle =\n-                uvll::get_stream_handle_from_write_req(self.native_handle());\n-            NativeHandle::from_native_handle(stream_handle)\n-        }\n-    }\n-\n-    fn delete(self) {\n-        unsafe { free(self.native_handle() as *c_void) }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n-    fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n-        WriteRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_write_t {\n-        match self { &WriteRequest(ptr) => ptr }\n-    }\n-}\n-\n-// XXX: Need to define the error constants like EOF so they can be\n-// compared to the UvError type\n-\n-struct UvError(uvll::uv_err_t);\n-\n-impl UvError {\n-\n-    fn name(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n-            let name_str = uvll::err_name(inner);\n-            fail_unless!(name_str.is_not_null());\n-            from_c_str(name_str)\n-        }\n-    }\n-\n-    fn desc(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n-            let desc_str = uvll::strerror(inner);\n-            fail_unless!(desc_str.is_not_null());\n-            from_c_str(desc_str)\n-        }\n-    }\n-}\n-\n-impl ToStr for UvError {\n-    fn to_str(&self) -> ~str {\n-        fmt!(\"%s: %s\", self.name(), self.desc())\n-    }\n-}\n-\n-#[test]\n-fn error_smoke_test() {\n-    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n-    let err: UvError = UvError(err);\n-    fail_unless!(err.to_str() == ~\"EOF: end of file\");\n-}\n-\n-\n-/// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-\n-/// Get the uv event loop from a Watcher\n-pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &W) -> Loop {\n-\n-    let handle = watcher.native_handle();\n-    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n-    NativeHandle::from_native_handle(loop_)\n-}\n-\n-/// Set the custom data on a handle to a callback Note: This is only\n-/// suitable for watchers that make just one type of callback.  For\n-/// others use WatcherData\n-fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W, cb: CB) {\n-\n-    drop_watcher_callback::<H, W, CB>(watcher);\n-    // XXX: Boxing the callback so it fits into a\n-    // pointer. Unfortunate extra allocation\n-    let boxed_cb = ~cb;\n-    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n-    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n-}\n-\n-/// Delete a callback from a handle's custom data\n-fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        if handle_data.is_not_null() {\n-            // Take ownership of the callback and drop it\n-            let _cb = transmute::<*c_void, ~CB>(handle_data);\n-            // Make sure the pointer is zeroed\n-            uvll::set_data_for_uv_handle(\n-                watcher.native_handle(), null::<()>());\n-        }\n-    }\n-}\n-\n-/// Take a pointer to the callback installed as custom data\n-fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n-                                CB: Callback>(watcher: &W) -> &CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        fail_unless!(handle_data.is_not_null());\n-        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-        return &**cb;\n-    }\n-}\n-\n-/// Take ownership of the callback installed as custom data\n-fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) -> CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        fail_unless!(handle_data.is_not_null());\n-        uvll::set_data_for_uv_handle(handle, null::<()>());\n-        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n-        let cb = match cb { ~cb => cb };\n-        return cb;\n-    }\n-}\n-\n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>\n-}\n-\n-fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = ~WatcherData {\n-            read_cb: None,\n-            write_cb: None,\n-            connect_cb: None,\n-            close_cb: None,\n-            alloc_cb: None\n-        };\n-        let data = transmute::<~WatcherData, *c_void>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n-    }\n-}\n-\n-fn get_watcher_data<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &'r mut W) -> &'r mut WatcherData {\n-\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-        return &mut **data;\n-    }\n-}\n-\n-fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let _data = transmute::<*c_void, ~WatcherData>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n-    }\n-}\n-\n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n-\n-    fail_unless!(buf.len == 20);\n-\n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n-    }\n-\n-    fail_unless!(slice[0] == 1);\n-    fail_unless!(slice[1] == 2);\n-}\n-\n-/// The uv buffer type\n-pub type Buf = uvll::uv_buf_t;\n-\n-/// Borrow a slice to a Buf\n-pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n-    let data = unsafe { vec::raw::to_ptr(v) };\n-    unsafe { uvll::buf_init(data, v.len()) }\n-}\n-\n-// XXX: Do these conversions without copying\n-\n-/// Transmute an owned vector to a Buf\n-fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n-    let data = unsafe { malloc(v.len() as size_t) } as *u8;\n-    fail_unless!(data.is_not_null());\n-    do vec::as_imm_buf(v) |b, l| {\n-        let data = data as *mut u8;\n-        unsafe { ptr::copy_memory(data, b, l) }\n-    }\n-    let buf = unsafe { uvll::buf_init(data, v.len()) };\n-    return buf;\n-}\n-\n-/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n-fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n-    if !(buf.len == 0 && buf.base.is_null()) {\n-        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n-        unsafe { free(buf.base as *c_void) };\n-        return Some(v);\n-    } else {\n-        // No buffer\n-        return None;\n-    }\n-}\n-\n-#[test]\n-fn loop_smoke_test() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n-#[test]\n-#[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n-fn idle_new_then_close() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        idle_watcher.close();\n-    }\n-}\n-\n-#[test]\n-fn idle_smoke_test() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        let mut count = 10;\n-        let count_ptr: *mut int = &mut count;\n-        do idle_watcher.start |idle_watcher, status| {\n-            let mut idle_watcher = idle_watcher;\n-            fail_unless!(status.is_none());\n-            if unsafe { *count_ptr == 10 } {\n-                idle_watcher.stop();\n-                idle_watcher.close();\n-            } else {\n-                unsafe { *count_ptr = *count_ptr + 1; }\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-        fail_unless!(count == 10);\n-    }\n-}\n-\n-#[test]\n-fn idle_start_stop_start() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        do idle_watcher.start |idle_watcher, status| {\n-            let mut idle_watcher = idle_watcher;\n-            fail_unless!(status.is_none());\n-            idle_watcher.stop();\n-            do idle_watcher.start |idle_watcher, status| {\n-                fail_unless!(status.is_none());\n-                let mut idle_watcher = idle_watcher;\n-                idle_watcher.stop();\n-                idle_watcher.close();\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n-#[test]\n-#[ignore(reason = \"ffi struct issues\")]\n-fn connect_close() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        // Connect to a port where nobody is listening\n-        let addr = Ipv4(127, 0, 0, 1, 2923);\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            fail_unless!(status.is_some());\n-            fail_unless!(status.get().name() == ~\"ECONNREFUSED\");\n-            stream_watcher.close(||());\n-        }\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n-#[test]\n-#[ignore(reason = \"need a server to connect to\")]\n-fn connect_read() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = Ipv4(127, 0, 0, 1, 2924);\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            let mut stream_watcher = stream_watcher;\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            fail_unless!(status.is_none());\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do stream_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n-\n-                let buf = vec_from_uv_buf(buf);\n-                rtdebug!(\"read cb!\");\n-                if status.is_none() {\n-                    let bytes = buf.unwrap();\n-                    rtdebug!(\"%s\", bytes.slice(0, nread as uint).to_str());\n-                } else {\n-                    rtdebug!(\"status after read: %s\", status.get().to_str());\n-                    rtdebug!(\"closing\");\n-                    stream_watcher.close(||());\n-                }\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n-#[test]\n-#[ignore(reason = \"ffi struct issues\")]\n-fn listen() {\n-    do run_in_bare_thread() {\n-        static MAX: int = 10;\n-        let mut loop_ = Loop::new();\n-        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = Ipv4(127, 0, 0, 1, 2925);\n-        server_tcp_watcher.bind(addr);\n-        let loop_ = loop_;\n-        rtdebug!(\"listening\");\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n-            rtdebug!(\"listened!\");\n-            fail_unless!(status.is_none());\n-            let mut server_stream_watcher = server_stream_watcher;\n-            let mut loop_ = loop_;\n-            let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-            server_stream_watcher.accept(client_tcp_watcher);\n-            let count_cell = Cell(0);\n-            let server_stream_watcher = server_stream_watcher;\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do client_tcp_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n-\n-                rtdebug!(\"i'm reading!\");\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = count_cell.take();\n-                if status.is_none() {\n-                    rtdebug!(\"got %d bytes\", nread);\n-                    let buf = buf.unwrap();\n-                    for buf.slice(0, nread as uint).each |byte| {\n-                        fail_unless!(*byte == count as u8);\n-                        rtdebug!(\"%u\", *byte as uint);\n-                        count += 1;\n-                    }\n-                } else {\n-                    fail_unless!(count == MAX);\n-                    do stream_watcher.close {\n-                        server_stream_watcher.close(||());\n-                    }\n-                }\n-                count_cell.put_back(count);\n-            }\n-        }\n-\n-        let _client_thread = do Thread::start {\n-            rtdebug!(\"starting client thread\");\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connecting\");\n-                fail_unless!(status.is_none());\n-                let mut stream_watcher = stream_watcher;\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                do stream_watcher.write(msg) |stream_watcher, status| {\n-                    rtdebug!(\"writing\");\n-                    fail_unless!(status.is_none());\n-                    stream_watcher.close(||());\n-                }\n-            }\n-            loop_.run();\n-            loop_.close();\n-        };\n-\n-        let mut loop_ = loop_;\n-        loop_.run();\n-        loop_.close();\n-    }\n-}"}, {"sha": "7df06f87dfe41b11710e20ad2910a4409eefdd64", "filename": "src/libcore/rt/uv/file.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ffile.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use ptr::null;\n+use libc::c_void;\n+use super::{UvError, Callback, Request, NativeHandle, Loop};\n+use super::super::uvll;\n+use super::super::uvll::*;\n+\n+pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+impl Callback for FsCallback { }\n+\n+pub struct FsRequest(*uvll::uv_fs_t);\n+\n+impl Request for FsRequest;\n+\n+impl FsRequest {\n+    fn new() -> FsRequest {\n+        let fs_req = unsafe { malloc_req(UV_FS) };\n+        fail_unless!(fs_req.is_not_null());\n+        let fs_req = fs_req as *uvll::uv_write_t;\n+        unsafe { uvll::set_data_for_req(fs_req, null::<()>()); }\n+        NativeHandle::from_native_handle(fs_req)\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+\n+    fn open(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    }\n+\n+    fn close(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n+    fn from_native_handle(handle: *uvll:: uv_fs_t) -> FsRequest {\n+        FsRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_fs_t {\n+        match self { &FsRequest(ptr) => ptr }\n+    }\n+}"}, {"sha": "28d695273e7c7b8e392dc63da47efa6f70633413", "filename": "src/libcore/rt/uv/mod.rs", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -0,0 +1,456 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Bindings to libuv.\n+\n+UV types consist of the event loop (Loop), Watchers, Requests and\n+Callbacks.\n+\n+Watchers and Requests encapsulate pointers to uv *handles*, which have\n+subtyping relationships with each other.  This subtyping is reflected\n+in the bindings with explicit or implicit coercions. For example, an\n+upcast from TcpWatcher to StreamWatcher is done with\n+`tcp_watcher.as_stream()`. In other cases a callback on a specific\n+type of watcher will be passed a watcher of a supertype.\n+\n+Currently all use of Request types (connect/write requests) are\n+encapsulated in the bindings and don't need to be dealt with by the\n+caller.\n+\n+# Safety note\n+\n+Due to the complex lifecycle of uv handles, as well as compiler bugs,\n+this module is not memory safe and requires explicit memory management,\n+via `close` and `delete` methods.\n+\n+*/\n+\n+use option::*;\n+use str::raw::from_c_str;\n+use to_str::ToStr;\n+use vec;\n+use ptr;\n+use libc::{c_void, c_int, size_t, malloc, free, ssize_t};\n+use cast::{transmute, transmute_mut_region};\n+use ptr::null;\n+use sys::size_of;\n+use super::uvll;\n+use super::uvll::*;\n+use unstable::finally::Finally;\n+\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::thread::Thread;\n+#[cfg(test)] use cell::Cell;\n+\n+pub use self::file::{FsRequest, FsCallback};\n+pub use self::net::{StreamWatcher, TcpWatcher};\n+pub use self::net::{ReadCallback, AllocCallback, ConnectionCallback, ConnectCallback};\n+\n+pub mod file;\n+pub mod net;\n+\n+/// A trait for callbacks to implement. Provides a little extra type safety\n+/// for generic, unsafe interop functions like `set_watcher_callback`.\n+pub trait Callback { }\n+\n+pub trait Request { }\n+\n+/// The trait implemented by uv 'watchers' (handles). Watchers are\n+/// non-owning wrappers around the uv handles and are not completely\n+/// safe - there may be multiple instances for a single underlying\n+/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n+/// and `close`ed, but due to their complex life cycle may not be\n+/// entirely memory safe if used in unanticipated patterns.\n+pub trait Watcher {\n+    fn event_loop(&self) -> Loop;\n+}\n+\n+pub type NullCallback = ~fn();\n+impl Callback for NullCallback { }\n+\n+/// A type that wraps a native handle\n+pub trait NativeHandle<T> {\n+    pub fn from_native_handle(T) -> Self;\n+    pub fn native_handle(&self) -> T;\n+}\n+\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    handle: *uvll::uv_loop_t\n+}\n+\n+pub impl Loop {\n+    fn new() -> Loop {\n+        let handle = unsafe { uvll::loop_new() };\n+        fail_unless!(handle.is_not_null());\n+        NativeHandle::from_native_handle(handle)\n+    }\n+\n+    fn run(&mut self) {\n+        unsafe { uvll::run(self.native_handle()) };\n+    }\n+\n+    fn close(&mut self) {\n+        unsafe { uvll::loop_delete(self.native_handle()) };\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_loop_t> for Loop {\n+    fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n+        Loop { handle: handle }\n+    }\n+    fn native_handle(&self) -> *uvll::uv_loop_t {\n+        self.handle\n+    }\n+}\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+\n+impl Watcher for IdleWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+impl Callback for IdleCallback { }\n+\n+pub impl IdleWatcher {\n+    fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::idle_new();\n+            fail_unless!(handle.is_not_null());\n+            fail_unless!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            uvll::set_data_for_uv_handle(handle, null::<()>());\n+            NativeHandle::from_native_handle(handle)\n+        }\n+    }\n+\n+    fn start(&mut self, cb: IdleCallback) {\n+\n+        set_watcher_callback(self, cb);\n+        unsafe {\n+            fail_unless!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n+    fn stop(&mut self) {\n+        unsafe { fail_unless!(0 == uvll::idle_stop(self.native_handle())); }\n+    }\n+\n+    fn close(self) {\n+        unsafe { uvll::close(self.native_handle(), close_cb) };\n+\n+        extern fn close_cb(handle: *uvll::uv_idle_t) {\n+            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n+            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n+            unsafe { uvll::idle_delete(handle) };\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}\n+\n+// XXX: Need to define the error constants like EOF so they can be\n+// compared to the UvError type\n+\n+pub struct UvError(uvll::uv_err_t);\n+\n+pub impl UvError {\n+\n+    fn name(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let name_str = uvll::err_name(inner);\n+            fail_unless!(name_str.is_not_null());\n+            from_c_str(name_str)\n+        }\n+    }\n+\n+    fn desc(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let desc_str = uvll::strerror(inner);\n+            fail_unless!(desc_str.is_not_null());\n+            from_c_str(desc_str)\n+        }\n+    }\n+}\n+\n+impl ToStr for UvError {\n+    fn to_str(&self) -> ~str {\n+        fmt!(\"%s: %s\", self.name(), self.desc())\n+    }\n+}\n+\n+#[test]\n+fn error_smoke_test() {\n+    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n+    let err: UvError = UvError(err);\n+    fail_unless!(err.to_str() == ~\"EOF: end of file\");\n+}\n+\n+\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n+}\n+\n+/// Get the uv event loop from a Watcher\n+pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n+    watcher: &W) -> Loop {\n+\n+    let handle = watcher.native_handle();\n+    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n+    NativeHandle::from_native_handle(loop_)\n+}\n+\n+/// Set the custom data on a handle to a callback Note: This is only\n+/// suitable for watchers that make just one type of callback.  For\n+/// others use WatcherData\n+pub fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W, cb: CB) {\n+\n+    drop_watcher_callback::<H, W, CB>(watcher);\n+    // XXX: Boxing the callback so it fits into a\n+    // pointer. Unfortunate extra allocation\n+    let boxed_cb = ~cb;\n+    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n+    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n+}\n+\n+/// Delete a callback from a handle's custom data\n+pub fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W) {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        if handle_data.is_not_null() {\n+            // Take ownership of the callback and drop it\n+            let _cb = transmute::<*c_void, ~CB>(handle_data);\n+            // Make sure the pointer is zeroed\n+            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+        }\n+    }\n+}\n+\n+/// Take a pointer to the callback installed as custom data\n+pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n+                                CB: Callback>(watcher: &W) -> &CB {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        fail_unless!(handle_data.is_not_null());\n+        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n+        return &**cb;\n+    }\n+}\n+\n+/// Take ownership of the callback installed as custom data\n+pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W) -> CB {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        fail_unless!(handle_data.is_not_null());\n+        uvll::set_data_for_uv_handle(handle, null::<()>());\n+        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n+        let cb = match cb { ~cb => cb };\n+        return cb;\n+    }\n+}\n+\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>\n+}\n+\n+pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n+    unsafe {\n+        let data = ~WatcherData {\n+            read_cb: None,\n+            write_cb: None,\n+            connect_cb: None,\n+            close_cb: None,\n+            alloc_cb: None\n+        };\n+        let data = transmute::<~WatcherData, *c_void>(data);\n+        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n+    }\n+}\n+\n+pub fn get_watcher_data<H, W: Watcher + NativeHandle<*H>>(\n+    watcher: &'r mut W) -> &'r mut WatcherData {\n+\n+    unsafe {\n+        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n+        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+        return &mut **data;\n+    }\n+}\n+\n+pub fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n+    unsafe {\n+        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n+        let _data = transmute::<*c_void, ~WatcherData>(data);\n+        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+    }\n+}\n+\n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    fail_unless!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    fail_unless!(slice[0] == 1);\n+    fail_unless!(slice[1] == 2);\n+}\n+\n+/// The uv buffer type\n+pub type Buf = uvll::uv_buf_t;\n+\n+/// Borrow a slice to a Buf\n+pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n+    let data = unsafe { vec::raw::to_ptr(v) };\n+    unsafe { uvll::buf_init(data, v.len()) }\n+}\n+\n+// XXX: Do these conversions without copying\n+\n+/// Transmute an owned vector to a Buf\n+pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n+    let data = unsafe { malloc(v.len() as size_t) } as *u8;\n+    fail_unless!(data.is_not_null());\n+    do vec::as_imm_buf(v) |b, l| {\n+        let data = data as *mut u8;\n+        unsafe { ptr::copy_memory(data, b, l) }\n+    }\n+    let buf = unsafe { uvll::buf_init(data, v.len()) };\n+    return buf;\n+}\n+\n+/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n+pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n+    if !(buf.len == 0 && buf.base.is_null()) {\n+        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n+        unsafe { free(buf.base as *c_void) };\n+        return Some(v);\n+    } else {\n+        // No buffer\n+        return None;\n+    }\n+}\n+\n+#[test]\n+fn loop_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n+fn idle_new_then_close() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        idle_watcher.close();\n+    }\n+}\n+\n+#[test]\n+fn idle_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        let mut count = 10;\n+        let count_ptr: *mut int = &mut count;\n+        do idle_watcher.start |idle_watcher, status| {\n+            let mut idle_watcher = idle_watcher;\n+            fail_unless!(status.is_none());\n+            if unsafe { *count_ptr == 10 } {\n+                idle_watcher.stop();\n+                idle_watcher.close();\n+            } else {\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+        fail_unless!(count == 10);\n+    }\n+}\n+\n+#[test]\n+fn idle_start_stop_start() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        do idle_watcher.start |idle_watcher, status| {\n+            let mut idle_watcher = idle_watcher;\n+            fail_unless!(status.is_none());\n+            idle_watcher.stop();\n+            do idle_watcher.start |idle_watcher, status| {\n+                fail_unless!(status.is_none());\n+                let mut idle_watcher = idle_watcher;\n+                idle_watcher.stop();\n+                idle_watcher.close();\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}"}, {"sha": "8f0e8c3edd50d166a3f4621b105f5caa82810c96", "filename": "src/libcore/rt/uv/net.rs", "status": "added", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -0,0 +1,483 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc::{size_t, ssize_t, c_int, c_void};\n+use cast::{transmute, transmute_mut_region};\n+use super::super::uvll;\n+use super::super::uvll::*;\n+use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCallback,\n+            loop_from_watcher, status_to_maybe_uv_error,\n+            install_watcher_data, get_watcher_data, drop_watcher_data,\n+            vec_to_uv_buf, vec_from_uv_buf};\n+use super::super::rtio::{IpAddr, Ipv4, Ipv6};\n+\n+#[cfg(test)]\n+use unstable::run_in_bare_thread;\n+#[cfg(test)]\n+use super::super::thread::Thread;\n+#[cfg(test)]\n+use cell::Cell;\n+\n+fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n+    match addr {\n+        Ipv4(a, b, c, d, p) => {\n+            unsafe {\n+                let addr = malloc_ip4_addr(fmt!(\"%u.%u.%u.%u\",\n+                                                a as uint,\n+                                                b as uint,\n+                                                c as uint,\n+                                                d as uint), p as int);\n+                do (|| {\n+                    f(addr);\n+                }).finally {\n+                    free_ip4_addr(addr);\n+                }\n+            }\n+        }\n+        Ipv6 => fail!()\n+    }\n+}\n+\n+// uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n+// and uv_file_t\n+pub struct StreamWatcher(*uvll::uv_stream_t);\n+\n+impl Watcher for StreamWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+impl Callback for ReadCallback { }\n+\n+// XXX: The uv alloc callback also has a *uv_handle_t arg\n+pub type AllocCallback = ~fn(uint) -> Buf;\n+impl Callback for AllocCallback { }\n+\n+pub impl StreamWatcher {\n+\n+    fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n+        // XXX: Borrowchk problems\n+        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n+        data.alloc_cb = Some(alloc);\n+        data.read_cb = Some(cb);\n+\n+        let handle = self.native_handle();\n+        unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n+\n+        extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n+            let data = get_watcher_data(&mut stream_watcher);\n+            let alloc_cb = data.alloc_cb.get_ref();\n+            return (*alloc_cb)(suggested_size as uint);\n+        }\n+\n+        extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, ++buf: Buf) {\n+            rtdebug!(\"buf addr: %x\", buf.base as uint);\n+            rtdebug!(\"buf len: %d\", buf.len as int);\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n+            let data = get_watcher_data(&mut stream_watcher);\n+            let cb = data.read_cb.get_ref();\n+            let status = status_to_maybe_uv_error(stream, nread as c_int);\n+            (*cb)(stream_watcher, nread as int, buf, status);\n+        }\n+    }\n+\n+    fn read_stop(&mut self) {\n+        // It would be nice to drop the alloc and read callbacks here,\n+        // but read_stop may be called from inside one of them and we\n+        // would end up freeing the in-use environment\n+        let handle = self.native_handle();\n+        unsafe { uvll::read_stop(handle); }\n+    }\n+\n+    // XXX: Needs to take &[u8], not ~[u8]\n+    fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n+        // XXX: Borrowck\n+        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n+        fail_unless!(data.write_cb.is_none());\n+        data.write_cb = Some(cb);\n+\n+        let req = WriteRequest::new();\n+        let buf = vec_to_uv_buf(msg);\n+        // XXX: Allocation\n+        let bufs = ~[buf];\n+        unsafe {\n+            fail_unless!(0 == uvll::write(req.native_handle(),\n+                                          self.native_handle(),\n+                                          &bufs, write_cb));\n+        }\n+        // XXX: Freeing immediately after write. Is this ok?\n+        let _v = vec_from_uv_buf(buf);\n+\n+        extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n+            let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n+            let mut stream_watcher = write_request.stream();\n+            write_request.delete();\n+            let cb = get_watcher_data(&mut stream_watcher).write_cb.swap_unwrap();\n+            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n+    fn accept(&mut self, stream: StreamWatcher) {\n+        let self_handle = self.native_handle() as *c_void;\n+        let stream_handle = stream.native_handle() as *c_void;\n+        unsafe {\n+            fail_unless!(0 == uvll::accept(self_handle, stream_handle));\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        {\n+            let mut self = self;\n+            let data = get_watcher_data(&mut self);\n+            fail_unless!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_stream_t) {\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let mut data = get_watcher_data(&mut stream_watcher);\n+                data.close_cb.swap_unwrap()();\n+            }\n+            drop_watcher_data(&mut stream_watcher);\n+            unsafe { free_handle(handle as *c_void) }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n+    fn from_native_handle(\n+        handle: *uvll::uv_stream_t) -> StreamWatcher {\n+        StreamWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_stream_t {\n+        match self { &StreamWatcher(ptr) => ptr }\n+    }\n+}\n+\n+pub struct TcpWatcher(*uvll::uv_tcp_t);\n+\n+impl Watcher for TcpWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+impl Callback for ConnectionCallback { }\n+\n+pub impl TcpWatcher {\n+    fn new(loop_: &mut Loop) -> TcpWatcher {\n+        unsafe {\n+            let handle = malloc_handle(UV_TCP);\n+            fail_unless!(handle.is_not_null());\n+            fail_unless!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n+            let mut watcher = NativeHandle::from_native_handle(handle);\n+            install_watcher_data(&mut watcher);\n+            return watcher;\n+        }\n+    }\n+\n+    fn bind(&mut self, address: IpAddr) {\n+        match address {\n+            Ipv4(*) => {\n+                do ip4_as_uv_ip4(address) |addr| {\n+                    let result = unsafe {\n+                        uvll::tcp_bind(self.native_handle(), addr)\n+                    };\n+                    // XXX: bind is likely to fail. need real error handling\n+                    fail_unless!(result == 0);\n+                }\n+            }\n+            _ => fail!()\n+        }\n+    }\n+\n+    fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n+        unsafe {\n+            fail_unless!(get_watcher_data(self).connect_cb.is_none());\n+            get_watcher_data(self).connect_cb = Some(cb);\n+\n+            let mut connect_watcher = ConnectRequest::new();\n+            let connect_handle = connect_watcher.native_handle();\n+            match address {\n+                Ipv4(*) => {\n+                    do ip4_as_uv_ip4(address) |addr| {\n+                        rtdebug!(\"connect_t: %x\", connect_handle as uint);\n+                        fail_unless!(0 == uvll::tcp_connect(connect_handle,\n+                                                            self.native_handle(),\n+                                                            addr, connect_cb));\n+                    }\n+                }\n+                _ => fail!()\n+            }\n+\n+            extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+                rtdebug!(\"connect_t: %x\", req as uint);\n+                let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n+                let mut stream_watcher = connect_request.stream();\n+                connect_request.delete();\n+                let cb: ConnectionCallback = {\n+                    let data = get_watcher_data(&mut stream_watcher);\n+                    data.connect_cb.swap_unwrap()\n+                };\n+                let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+                cb(stream_watcher, status);\n+            }\n+        }\n+    }\n+\n+    fn listen(&mut self, cb: ConnectionCallback) {\n+        // XXX: Borrowck\n+        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n+        fail_unless!(data.connect_cb.is_none());\n+        data.connect_cb = Some(cb);\n+\n+        unsafe {\n+            static BACKLOG: c_int = 128; // XXX should be configurable\n+            // XXX: This can probably fail\n+            fail_unless!(0 == uvll::listen(self.native_handle(),\n+                                           BACKLOG, connection_cb));\n+        }\n+\n+        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n+            rtdebug!(\"connection_cb\");\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n+            let cb = get_watcher_data(&mut stream_watcher).connect_cb.swap_unwrap();\n+            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n+    fn as_stream(&self) -> StreamWatcher {\n+        NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n+    fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n+        TcpWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_tcp_t {\n+        match self { &TcpWatcher(ptr) => ptr }\n+    }\n+}\n+\n+pub type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n+impl Callback for ConnectCallback { }\n+\n+// uv_connect_t is a subclass of uv_req_t\n+struct ConnectRequest(*uvll::uv_connect_t);\n+\n+impl Request for ConnectRequest { }\n+\n+impl ConnectRequest {\n+\n+    fn new() -> ConnectRequest {\n+        let connect_handle = unsafe {\n+            malloc_req(UV_CONNECT)\n+        };\n+        fail_unless!(connect_handle.is_not_null());\n+        let connect_handle = connect_handle as *uvll::uv_connect_t;\n+        ConnectRequest(connect_handle)\n+    }\n+\n+    fn stream(&self) -> StreamWatcher {\n+        unsafe {\n+            let stream_handle = uvll::get_stream_handle_from_connect_req(self.native_handle());\n+            NativeHandle::from_native_handle(stream_handle)\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n+    fn from_native_handle(\n+        handle: *uvll:: uv_connect_t) -> ConnectRequest {\n+        ConnectRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_connect_t {\n+        match self { &ConnectRequest(ptr) => ptr }\n+    }\n+}\n+\n+pub struct WriteRequest(*uvll::uv_write_t);\n+\n+impl Request for WriteRequest { }\n+\n+pub impl WriteRequest {\n+\n+    fn new() -> WriteRequest {\n+        let write_handle = unsafe {\n+            malloc_req(UV_WRITE)\n+        };\n+        fail_unless!(write_handle.is_not_null());\n+        let write_handle = write_handle as *uvll::uv_write_t;\n+        WriteRequest(write_handle)\n+    }\n+\n+    fn stream(&self) -> StreamWatcher {\n+        unsafe {\n+            let stream_handle = uvll::get_stream_handle_from_write_req(self.native_handle());\n+            NativeHandle::from_native_handle(stream_handle)\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n+    fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n+        WriteRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_write_t {\n+        match self { &WriteRequest(ptr) => ptr }\n+    }\n+}\n+\n+\n+#[test]\n+#[ignore(reason = \"ffi struct issues\")]\n+fn connect_close() {\n+    do run_in_bare_thread() {\n+        let mut loop_ = Loop::new();\n+        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        // Connect to a port where nobody is listening\n+        let addr = Ipv4(127, 0, 0, 1, 2923);\n+        do tcp_watcher.connect(addr) |stream_watcher, status| {\n+            rtdebug!(\"tcp_watcher.connect!\");\n+            fail_unless!(status.is_some());\n+            fail_unless!(status.get().name() == ~\"ECONNREFUSED\");\n+            stream_watcher.close(||());\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"need a server to connect to\")]\n+fn connect_read() {\n+    do run_in_bare_thread() {\n+        let mut loop_ = Loop::new();\n+        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        let addr = Ipv4(127, 0, 0, 1, 2924);\n+        do tcp_watcher.connect(addr) |stream_watcher, status| {\n+            let mut stream_watcher = stream_watcher;\n+            rtdebug!(\"tcp_watcher.connect!\");\n+            fail_unless!(status.is_none());\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+            do stream_watcher.read_start(alloc)\n+                |stream_watcher, nread, buf, status| {\n+\n+                let buf = vec_from_uv_buf(buf);\n+                rtdebug!(\"read cb!\");\n+                if status.is_none() {\n+                    let bytes = buf.unwrap();\n+                    rtdebug!(\"%s\", bytes.slice(0, nread as uint).to_str());\n+                } else {\n+                    rtdebug!(\"status after read: %s\", status.get().to_str());\n+                    rtdebug!(\"closing\");\n+                    stream_watcher.close(||());\n+                }\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"ffi struct issues\")]\n+fn listen() {\n+    do run_in_bare_thread() {\n+        static MAX: int = 10;\n+        let mut loop_ = Loop::new();\n+        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+        let addr = Ipv4(127, 0, 0, 1, 2925);\n+        server_tcp_watcher.bind(addr);\n+        let loop_ = loop_;\n+        rtdebug!(\"listening\");\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            rtdebug!(\"listened!\");\n+            fail_unless!(status.is_none());\n+            let mut server_stream_watcher = server_stream_watcher;\n+            let mut loop_ = loop_;\n+            let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+            server_stream_watcher.accept(client_tcp_watcher);\n+            let count_cell = Cell(0);\n+            let server_stream_watcher = server_stream_watcher;\n+            rtdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0))\n+            };\n+            do client_tcp_watcher.read_start(alloc)\n+                |stream_watcher, nread, buf, status| {\n+\n+                rtdebug!(\"i'm reading!\");\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = count_cell.take();\n+                if status.is_none() {\n+                    rtdebug!(\"got %d bytes\", nread);\n+                    let buf = buf.unwrap();\n+                    for buf.slice(0, nread as uint).each |byte| {\n+                        fail_unless!(*byte == count as u8);\n+                        rtdebug!(\"%u\", *byte as uint);\n+                        count += 1;\n+                    }\n+                } else {\n+                    fail_unless!(count == MAX);\n+                    do stream_watcher.close {\n+                        server_stream_watcher.close(||());\n+                    }\n+                }\n+                count_cell.put_back(count);\n+            }\n+        }\n+\n+        let _client_thread = do Thread::start {\n+            rtdebug!(\"starting client thread\");\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"connecting\");\n+                fail_unless!(status.is_none());\n+                let mut stream_watcher = stream_watcher;\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                do stream_watcher.write(msg) |stream_watcher, status| {\n+                    rtdebug!(\"writing\");\n+                    fail_unless!(status.is_none());\n+                    stream_watcher.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        };\n+\n+        let mut loop_ = loop_;\n+        loop_.run();\n+        loop_.close();\n+    }\n+}"}, {"sha": "bcad67c0c94ff0e45d38b64c72cbbc2d75e87b2d", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -12,13 +12,11 @@ use option::*;\n use result::*;\n \n use super::uv::*;\n-use super::io::*;\n+use super::rtio::*;\n use ops::Drop;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n-use super::StreamObject;\n use super::sched::Scheduler;\n-use super::IoFactoryObject;\n \n #[cfg(test)] use super::sched::Task;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -189,12 +187,9 @@ impl TcpListener for UvTcpListener {\n                 do server_tcp_watcher.listen |server_stream_watcher, status| {\n                     let maybe_stream = if status.is_none() {\n                         let mut server_stream_watcher = server_stream_watcher;\n-                        let mut loop_ =\n-                            loop_from_watcher(&server_stream_watcher);\n-                        let mut client_tcp_watcher =\n-                            TcpWatcher::new(&mut loop_);\n-                        let mut client_tcp_watcher =\n-                            client_tcp_watcher.as_stream();\n+                        let mut loop_ = loop_from_watcher(&server_stream_watcher);\n+                        let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                        let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n                         // XXX: Need's to be surfaced in interface\n                         server_stream_watcher.accept(client_tcp_watcher);\n                         Some(~UvStream::new(client_tcp_watcher))\n@@ -425,8 +420,7 @@ fn test_read_and_block() {\n                         // Yield to the other task in hopes that it\n                         // will trigger a read callback while we are\n                         // not ready for it\n-                        do scheduler.block_running_task_and_then\n-                            |scheduler, task| {\n+                        do scheduler.block_running_task_and_then |scheduler, task| {\n                             scheduler.task_queue.push_back(task);\n                         }\n                     }"}, {"sha": "5111b2bdc1d2226801cb3db31ccc32a9b93a0553", "filename": "src/libcore/rt/uvll.rs", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -0,0 +1,442 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Low-level bindings to the libuv library.\n+ *\n+ * This module contains a set of direct, 'bare-metal' wrappers around\n+ * the libuv C-API.\n+ *\n+ * We're not bothering yet to redefine uv's structs as Rust structs\n+ * because they are quite large and change often between versions.\n+ * The maintenance burden is just too high. Instead we use the uv's\n+ * `uv_handle_size` and `uv_req_size` to find the correct size of the\n+ * structs and allocate them on the heap. This can be revisited later.\n+ *\n+ * There are also a collection of helper functions to ease interacting\n+ * with the low-level API.\n+ *\n+ * As new functionality, existant in uv.h, is added to the rust stdlib,\n+ * the mappings should be added in this module.\n+ */\n+\n+#[allow(non_camel_case_types)]; // C types\n+\n+use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n+use libc::{malloc, free};\n+use prelude::*;\n+use ptr::to_unsafe_ptr;\n+\n+pub struct uv_err_t {\n+    code: c_int,\n+    sys_errno_: c_int\n+}\n+\n+pub struct uv_buf_t {\n+    base: *u8,\n+    len: libc::size_t,\n+}\n+\n+pub type uv_handle_t = c_void;\n+pub type uv_loop_t = c_void;\n+pub type uv_idle_t = c_void;\n+pub type uv_tcp_t = c_void;\n+pub type uv_connect_t = c_void;\n+pub type uv_write_t = c_void;\n+pub type uv_async_t = c_void;\n+pub type uv_timer_t = c_void;\n+pub type uv_stream_t = c_void;\n+pub type uv_fs_t = c_void;\n+\n+pub type uv_idle_cb = *u8;\n+\n+pub type sockaddr_in = c_void;\n+pub type sockaddr_in6 = c_void;\n+\n+#[deriving(Eq)]\n+pub enum uv_handle_type {\n+    UV_UNKNOWN_HANDLE,\n+    UV_ASYNC,\n+    UV_CHECK,\n+    UV_FS_EVENT,\n+    UV_FS_POLL,\n+    UV_HANDLE,\n+    UV_IDLE,\n+    UV_NAMED_PIPE,\n+    UV_POLL,\n+    UV_PREPARE,\n+    UV_PROCESS,\n+    UV_STREAM,\n+    UV_TCP,\n+    UV_TIMER,\n+    UV_TTY,\n+    UV_UDP,\n+    UV_SIGNAL,\n+    UV_FILE,\n+    UV_HANDLE_TYPE_MAX\n+}\n+\n+#[deriving(Eq)]\n+pub enum uv_req_type {\n+    UV_UNKNOWN_REQ,\n+    UV_REQ,\n+    UV_CONNECT,\n+    UV_WRITE,\n+    UV_SHUTDOWN,\n+    UV_UDP_SEND,\n+    UV_FS,\n+    UV_WORK,\n+    UV_GETADDRINFO,\n+    UV_REQ_TYPE_MAX\n+}\n+\n+pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+    fail_unless!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n+    let size = unsafe { rust_uv_handle_size(handle as uint) };\n+    let p = malloc(size);\n+    fail_unless!(p.is_not_null());\n+    return p;\n+}\n+\n+pub unsafe fn free_handle(v: *c_void) {\n+    free(v)\n+}\n+\n+pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+    fail_unless!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n+    let size = unsafe { rust_uv_req_size(req as uint) };\n+    let p = malloc(size);\n+    fail_unless!(p.is_not_null());\n+    return p;\n+}\n+\n+pub unsafe fn free_req(v: *c_void) {\n+    free(v)\n+}\n+\n+#[test]\n+fn handle_sanity_check() {\n+    unsafe {\n+        fail_unless!(UV_HANDLE_TYPE_MAX as uint == rust_uv_handle_type_max());\n+    }\n+}\n+\n+#[test]\n+fn request_sanity_check() {\n+    unsafe {\n+        fail_unless!(UV_REQ_TYPE_MAX as uint == rust_uv_req_type_max());\n+    }\n+}\n+\n+pub unsafe fn loop_new() -> *c_void {\n+    return rust_uv_loop_new();\n+}\n+\n+pub unsafe fn loop_delete(loop_handle: *c_void) {\n+    rust_uv_loop_delete(loop_handle);\n+}\n+\n+pub unsafe fn run(loop_handle: *c_void) {\n+    rust_uv_run(loop_handle);\n+}\n+\n+pub unsafe fn close<T>(handle: *T, cb: *u8) {\n+    rust_uv_close(handle as *c_void, cb);\n+}\n+\n+pub unsafe fn walk(loop_handle: *c_void, cb: *u8, arg: *c_void) {\n+    rust_uv_walk(loop_handle, cb, arg);\n+}\n+\n+pub unsafe fn idle_new() -> *uv_idle_t {\n+    rust_uv_idle_new()\n+}\n+\n+pub unsafe fn idle_delete(handle: *uv_idle_t) {\n+    rust_uv_idle_delete(handle)\n+}\n+\n+pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n+    rust_uv_idle_init(loop_handle, handle)\n+}\n+\n+pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n+    rust_uv_idle_start(handle, cb)\n+}\n+\n+pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n+    rust_uv_idle_stop(handle)\n+}\n+\n+pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n+    return rust_uv_tcp_init(loop_handle, handle);\n+}\n+\n+// FIXME ref #2064\n+pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n+                          tcp_handle_ptr: *uv_tcp_t,\n+                          addr_ptr: *sockaddr_in,\n+                          after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n+                                       after_connect_cb, addr_ptr);\n+}\n+// FIXME ref #2064\n+pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           addr_ptr: *sockaddr_in6,\n+                           after_connect_cb: *u8) -> c_int {\n+    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr,\n+                                        after_connect_cb, addr_ptr);\n+}\n+// FIXME ref #2064\n+pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n+}\n+// FIXME ref #2064\n+pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n+    return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n+}\n+\n+pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n+}\n+\n+pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int {\n+    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n+}\n+\n+pub unsafe fn listen<T>(stream: *T, backlog: c_int, cb: *u8) -> c_int {\n+    return rust_uv_listen(stream as *c_void, backlog, cb);\n+}\n+\n+pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n+    return rust_uv_accept(server as *c_void, client as *c_void);\n+}\n+\n+pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: *~[uv_buf_t], cb: *u8) -> c_int {\n+    let buf_ptr = vec::raw::to_ptr(*buf_in);\n+    let buf_cnt = vec::len(*buf_in) as i32;\n+    return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n+}\n+pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {\n+    return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n+}\n+\n+pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n+    return rust_uv_read_stop(stream as *c_void);\n+}\n+\n+pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n+    return rust_uv_last_error(loop_handle);\n+}\n+\n+pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+    return rust_uv_strerror(err);\n+}\n+pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n+    return rust_uv_err_name(err);\n+}\n+\n+pub unsafe fn async_init(loop_handle: *c_void, async_handle: *uv_async_t, cb: *u8) -> c_int {\n+    return rust_uv_async_init(loop_handle, async_handle, cb);\n+}\n+\n+pub unsafe fn async_send(async_handle: *uv_async_t) {\n+    return rust_uv_async_send(async_handle);\n+}\n+pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n+    let out_buf_ptr = ptr::addr_of(&out_buf);\n+    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n+    return out_buf;\n+}\n+\n+pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n+    return rust_uv_timer_init(loop_ptr, timer_ptr);\n+}\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n+                          repeat: uint) -> c_int {\n+    return rust_uv_timer_start(timer_ptr, cb, timeout as c_uint, repeat as c_uint);\n+}\n+pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n+    return rust_uv_timer_stop(timer_ptr);\n+}\n+\n+pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n+    }\n+}\n+pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n+    do str::as_c_str(ip) |ip_buf| {\n+        rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n+    }\n+}\n+\n+pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n+    rust_uv_free_ip4_addr(addr);\n+}\n+\n+pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n+    rust_uv_free_ip6_addr(addr);\n+}\n+\n+// data access helpers\n+pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n+    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n+}\n+pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n+    return rust_uv_get_stream_handle_from_connect_req(connect);\n+}\n+pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n+    return rust_uv_get_stream_handle_from_write_req(write_req);\n+}\n+pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+    rust_uv_get_data_for_uv_loop(loop_ptr)\n+}\n+pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n+    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n+}\n+pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n+    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n+}\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n+    rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n+}\n+pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n+    return rust_uv_get_data_for_req(req as *c_void);\n+}\n+pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n+    rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n+}\n+pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+    return rust_uv_get_base_from_buf(buf);\n+}\n+pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n+    return rust_uv_get_len_from_buf(buf);\n+}\n+pub unsafe fn malloc_buf_base_of(suggested_size: size_t) -> *u8 {\n+    return rust_uv_malloc_buf_base_of(suggested_size);\n+}\n+pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n+    rust_uv_free_base_of_buf(buf);\n+}\n+\n+pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::addr_of(&err);\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n+    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n+                    err_name, err_msg);\n+}\n+\n+pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::addr_of(&err);\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n+    uv_err_data { err_name: err_name, err_msg: err_msg }\n+}\n+\n+pub struct uv_err_data {\n+    err_name: ~str,\n+    err_msg: ~str,\n+}\n+\n+extern {\n+\n+    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_handle_type_max() -> uintptr_t;\n+    fn rust_uv_req_type_max() -> uintptr_t;\n+\n+    // libuv public API\n+    fn rust_uv_loop_new() -> *c_void;\n+    fn rust_uv_loop_delete(lp: *c_void);\n+    fn rust_uv_run(loop_handle: *c_void);\n+    fn rust_uv_close(handle: *c_void, cb: *u8);\n+    fn rust_uv_walk(loop_handle: *c_void, cb: *u8, arg: *c_void);\n+\n+    fn rust_uv_idle_new() -> *uv_idle_t;\n+    fn rust_uv_idle_delete(handle: *uv_idle_t);\n+    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n+    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n+    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n+\n+    fn rust_uv_async_send(handle: *uv_async_t);\n+    fn rust_uv_async_init(loop_handle: *c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: *u8) -> c_int;\n+    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n+    // FIXME ref #2604 .. ?\n+    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n+    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n+    // FIXME ref #2064\n+    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n+    // FIXME ref #2064\n+    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n+    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n+    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n+    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n+    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n+    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n+    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           ++after_cb: *u8,\n+                           ++addr: *sockaddr_in) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, ++addr: *sockaddr_in) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_connect6(connect_ptr: *uv_connect_t,\n+                            tcp_handle_ptr: *uv_tcp_t,\n+                            ++after_cb: *u8,\n+                            ++addr: *sockaddr_in6) -> c_int;\n+    // FIXME ref #2064\n+    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, ++addr: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, ++name: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, ++name: *sockaddr_in6) ->c_int;\n+    fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n+    fn rust_uv_write(req: *c_void,\n+                     stream: *c_void,\n+                     ++buf_in: *uv_buf_t,\n+                     buf_cnt: c_int,\n+                     cb: *u8) -> c_int;\n+    fn rust_uv_read_start(stream: *c_void,\n+                          on_alloc: *u8,\n+                          on_read: *u8) -> c_int;\n+    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n+    fn rust_uv_timer_init(loop_handle: *c_void,\n+                          timer_handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n+                           cb: *u8,\n+                           timeout: c_uint,\n+                           repeat: c_uint) -> c_int;\n+    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+\n+    fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;\n+    fn rust_uv_free_base_of_buf(++buf: uv_buf_t);\n+    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n+    fn rust_uv_get_base_from_buf(++buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(++buf: uv_buf_t) -> size_t;\n+}"}, {"sha": "6f0c9ba23dfd5e45a185215cd2ad13510082f33a", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -35,8 +35,6 @@ pub mod extfmt;\n #[path = \"unstable/lang.rs\"]\n #[cfg(notest)]\n pub mod lang;\n-#[path = \"unstable/uvll.rs\"]\n-pub mod uvll;\n \n mod rustrt {\n     use unstable::{raw_thread, rust_little_lock};"}, {"sha": "5d7920ce820eb4c556b0174dd789fcdb18c094c8", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -120,16 +120,25 @@ pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n #[lang=\"start\"]\n pub fn start(main: *u8, argc: int, argv: *c_char,\n              crate_map: *u8) -> int {\n+    use libc::getenv;\n+    use rt::start;\n+\n+    unsafe {\n+        let use_new_rt = do str::as_c_str(\"RUST_NEWRT\") |s| {\n+            getenv(s).is_null()\n+        };\n+        if use_new_rt {\n+            return rust_start(main as *c_void, argc as c_int, argv,\n+                              crate_map as *c_void) as int;\n+        } else {\n+            return start(main, argc, argv, crate_map);\n+        }\n+    }\n \n     extern {\n         fn rust_start(main: *c_void, argc: c_int, argv: *c_char,\n                       crate_map: *c_void) -> c_int;\n     }\n-\n-    unsafe {\n-        return rust_start(main as *c_void, argc as c_int, argv,\n-                          crate_map as *c_void) as int;\n-    }\n }\n \n // Local Variables:"}, {"sha": "15593571b43cac4f9a0bea4bbcca16aad6b25f14", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -21,20 +21,20 @@ use core::vec;\n use iotask = uv::iotask::IoTask;\n use interact = uv::iotask::interact;\n \n-use sockaddr_in = core::unstable::uvll::sockaddr_in;\n-use sockaddr_in6 = core::unstable::uvll::sockaddr_in6;\n-use addrinfo = core::unstable::uvll::addrinfo;\n-use uv_getaddrinfo_t = core::unstable::uvll::uv_getaddrinfo_t;\n-use uv_ip4_name = core::unstable::uvll::ip4_name;\n-use uv_ip4_port = core::unstable::uvll::ip4_port;\n-use uv_ip6_name = core::unstable::uvll::ip6_name;\n-use uv_ip6_port = core::unstable::uvll::ip6_port;\n-use uv_getaddrinfo = core::unstable::uvll::getaddrinfo;\n-use uv_freeaddrinfo = core::unstable::uvll::freeaddrinfo;\n-use create_uv_getaddrinfo_t = core::unstable::uvll::getaddrinfo_t;\n-use set_data_for_req = core::unstable::uvll::set_data_for_req;\n-use get_data_for_req = core::unstable::uvll::get_data_for_req;\n-use ll = core::unstable::uvll;\n+use sockaddr_in = super::uv_ll::sockaddr_in;\n+use sockaddr_in6 = super::uv_ll::sockaddr_in6;\n+use addrinfo = super::uv_ll::addrinfo;\n+use uv_getaddrinfo_t = super::uv_ll::uv_getaddrinfo_t;\n+use uv_ip4_name = super::uv_ll::ip4_name;\n+use uv_ip4_port = super::uv_ll::ip4_port;\n+use uv_ip6_name = super::uv_ll::ip6_name;\n+use uv_ip6_port = super::uv_ll::ip6_port;\n+use uv_getaddrinfo = super::uv_ll::getaddrinfo;\n+use uv_freeaddrinfo = super::uv_ll::freeaddrinfo;\n+use create_uv_getaddrinfo_t = super::uv_ll::getaddrinfo_t;\n+use set_data_for_req = super::uv_ll::set_data_for_req;\n+use get_data_for_req = super::uv_ll::get_data_for_req;\n+use ll = super::uv_ll;\n \n /// An IP address\n pub enum IpAddr {"}, {"sha": "6a7576645b8f8ebf74d0dfe1a5b7585ba00f1677", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -36,7 +36,7 @@ not required in or otherwise suitable for the core library.\n extern mod core(vers = \"0.6\");\n use core::*;\n \n-pub use uv_ll = core::unstable::uvll;\n+pub mod uv_ll;\n \n // General io and system-services modules\n "}, {"sha": "e055b40705773dc6382d1274c5bdfb05292a2ae9", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -33,6 +33,6 @@\n  * facilities.\n  */\n \n-pub use ll = core::unstable::uvll;\n+pub use ll = super::uv_ll;\n pub use iotask = uv_iotask;\n pub use global_loop = uv_global_loop;"}, {"sha": "57d769d707e677fce24c9626ffab2f169e4372b3", "filename": "src/libstd/uv_ll.rs", "status": "renamed", "additions": 39, "deletions": 59, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -32,10 +32,10 @@\n \n #[allow(non_camel_case_types)]; // C types\n \n-use libc::size_t;\n-use libc::c_void;\n-use prelude::*;\n-use ptr::to_unsafe_ptr;\n+use core::libc::size_t;\n+use core::libc::c_void;\n+use core::prelude::*;\n+use core::ptr::to_unsafe_ptr;\n \n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n@@ -357,7 +357,7 @@ pub struct uv_getaddrinfo_t {\n \n pub mod uv_ll_struct_stubgen {\n \n-    use ptr;\n+    use core::ptr;\n \n     use super::{\n         uv_async_t,\n@@ -930,8 +930,6 @@ pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       addr_ptr: *sockaddr_in,\n                       after_connect_cb: *u8)\n -> libc::c_int {\n-    debug!(\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n-                    (*addr_ptr).sin_port as uint, after_connect_cb as uint);\n     return rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n }\n@@ -1021,22 +1019,8 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(&out_buf);\n-    debug!(\"buf_init - input %u len %u out_buf: %u\",\n-                     input as uint,\n-                     len as uint,\n-                     out_buf_ptr as uint);\n-    // yuck :/\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n-    debug!(\"after rust_uv_buf_init\");\n-    let res_base = get_base_from_buf(out_buf);\n-    let res_len = get_len_from_buf(out_buf);\n-    //let res_base = get_base_from_buf(result);\n-    debug!(\"buf_init - result %u len %u\",\n-                     res_base as uint,\n-                     res_len as uint);\n     return out_buf;\n-    //return result;\n }\n pub unsafe fn ip4_addr(ip: &str, port: int)\n -> sockaddr_in {\n@@ -1078,8 +1062,6 @@ pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n     do vec::as_imm_buf(dst) |dst_buf, size| {\n         let src_unsafe_ptr = to_unsafe_ptr(src);\n-        debug!(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n-                        src_unsafe_ptr, src);\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n         match result {\n@@ -1240,9 +1222,9 @@ pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n \n #[cfg(test)]\n pub mod test {\n-    use prelude::*;\n+    use core::prelude::*;\n+    use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n     use super::*;\n-    use comm::{SharedChan, stream, GenericChan, GenericPort};\n \n     enum tcp_read_data {\n         tcp_read_eof,\n@@ -1265,7 +1247,7 @@ pub mod test {\n                          suggested_size: libc::size_t)\n         -> uv_buf_t {\n         unsafe {\n-            debug!(\"on_alloc_cb!\");\n+            debug!(~\"on_alloc_cb!\");\n             let char_ptr = malloc_buf_base_of(suggested_size);\n             debug!(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                              handle,\n@@ -1298,15 +1280,15 @@ pub mod test {\n             }\n             else if (nread == -1) {\n                 // err .. possibly EOF\n-                debug!(\"read: eof!\");\n+                debug!(~\"read: eof!\");\n             }\n             else {\n                 // nread == 0 .. do nothing, just free buf as below\n-                debug!(\"read: do nothing!\");\n+                debug!(~\"read: do nothing!\");\n             }\n             // when we're done\n             free_base_of_buf(buf);\n-            debug!(\"CLIENT exiting on_read_cb\");\n+            debug!(~\"CLIENT exiting on_read_cb\");\n         }\n     }\n \n@@ -1321,8 +1303,7 @@ pub mod test {\n                 \"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n                 stream as int, write_req as int);\n             let result = read_start(stream, on_alloc_cb, on_read_cb);\n-            debug!(\n-                \"CLIENT ending on_write_complete_cb .. status: %d\",\n+            debug!(\"CLIENT ending on_write_complete_cb .. status: %d\",\n                      result as int);\n         }\n     }\n@@ -1335,7 +1316,7 @@ pub mod test {\n             let stream =\n                 get_stream_handle_from_connect_req(connect_req_ptr);\n             if (status == 0i32) {\n-                debug!(\"on_connect_cb: in status=0 if..\");\n+                debug!(~\"on_connect_cb: in status=0 if..\");\n                 let client_data = get_data_for_req(\n                     connect_req_ptr as *libc::c_void)\n                     as *request_wrapper;\n@@ -1353,10 +1334,10 @@ pub mod test {\n                 let test_loop = get_loop_for_uv_handle(\n                     stream as *libc::c_void);\n                 let err_msg = get_last_err_info(test_loop);\n-                debug!(\"%?\", err_msg);\n+                debug!(err_msg);\n                 fail_unless!(false);\n             }\n-            debug!(\"finishing on_connect_cb\");\n+            debug!(~\"finishing on_connect_cb\");\n         }\n     }\n \n@@ -1396,9 +1377,9 @@ pub mod test {\n             let tcp_init_result = tcp_init(\n                 test_loop as *libc::c_void, tcp_handle_ptr);\n             if (tcp_init_result == 0i32) {\n-                debug!(\"sucessful tcp_init_result\");\n+                debug!(~\"sucessful tcp_init_result\");\n \n-                debug!(\"building addr...\");\n+                debug!(~\"building addr...\");\n                 let addr = ip4_addr(ip, port);\n                 // FIXME ref #2064\n                 let addr_ptr = ptr::addr_of(&addr);\n@@ -1420,17 +1401,17 @@ pub mod test {\n                     set_data_for_uv_handle(\n                         tcp_handle_ptr as *libc::c_void,\n                         ptr::addr_of(&client_data) as *libc::c_void);\n-                    debug!(\"before run tcp req loop\");\n+                    debug!(~\"before run tcp req loop\");\n                     run(test_loop);\n-                    debug!(\"after run tcp req loop\");\n+                    debug!(~\"after run tcp req loop\");\n                 }\n                 else {\n-                   debug!(\"tcp_connect() failure\");\n+                   debug!(~\"tcp_connect() failure\");\n                    fail_unless!(false);\n                 }\n             }\n             else {\n-                debug!(\"tcp_init() failure\");\n+                debug!(~\"tcp_init() failure\");\n                 fail_unless!(false);\n             }\n             loop_delete(test_loop);\n@@ -1446,8 +1427,7 @@ pub mod test {\n \n     extern fn client_stream_after_close_cb(handle: *libc::c_void) {\n         unsafe {\n-            debug!(\n-                \"SERVER: closed client stream, now closing server stream\");\n+            debug!(~\"SERVER: closed client stream, now closing server stream\");\n             let client_data = get_data_for_uv_handle(\n                 handle) as\n                 *tcp_server_data;\n@@ -1460,7 +1440,7 @@ pub mod test {\n         unsafe {\n             let client_stream_ptr =\n                 get_stream_handle_from_write_req(req);\n-            debug!(\"SERVER: resp sent... closing client stream\");\n+            debug!(~\"SERVER: resp sent... closing client stream\");\n             close(client_stream_ptr as *libc::c_void,\n                           client_stream_after_close_cb)\n         }\n@@ -1491,8 +1471,8 @@ pub mod test {\n                 let server_kill_msg = copy (*client_data).server_kill_msg;\n                 let write_req = (*client_data).server_write_req;\n                 if str::contains(request_str, server_kill_msg) {\n-                    debug!(\"SERVER: client req contains kill_msg!\");\n-                    debug!(\"SERVER: sending response to client\");\n+                    debug!(~\"SERVER: client req contains kill_msg!\");\n+                    debug!(~\"SERVER: sending response to client\");\n                     read_stop(client_stream_ptr);\n                     let server_chan = (*client_data).server_chan.clone();\n                     server_chan.send(request_str);\n@@ -1504,36 +1484,36 @@ pub mod test {\n                     debug!(\"SERVER: resp write result: %d\",\n                                 write_result as int);\n                     if (write_result != 0i32) {\n-                        debug!(\"bad result for server resp write()\");\n-                        debug!(\"%s\", get_last_err_info(\n+                        debug!(~\"bad result for server resp write()\");\n+                        debug!(get_last_err_info(\n                             get_loop_for_uv_handle(client_stream_ptr\n                                 as *libc::c_void)));\n                         fail_unless!(false);\n                     }\n                 }\n                 else {\n-                    debug!(\"SERVER: client req !contain kill_msg!\");\n+                    debug!(~\"SERVER: client req !contain kill_msg!\");\n                 }\n             }\n             else if (nread == -1) {\n                 // err .. possibly EOF\n-                debug!(\"read: eof!\");\n+                debug!(~\"read: eof!\");\n             }\n             else {\n                 // nread == 0 .. do nothing, just free buf as below\n-                debug!(\"read: do nothing!\");\n+                debug!(~\"read: do nothing!\");\n             }\n             // when we're done\n             free_base_of_buf(buf);\n-            debug!(\"SERVER exiting on_read_cb\");\n+            debug!(~\"SERVER exiting on_read_cb\");\n         }\n     }\n \n     extern fn server_connection_cb(server_stream_ptr:\n                                     *uv_stream_t,\n                                   status: libc::c_int) {\n         unsafe {\n-            debug!(\"client connecting!\");\n+            debug!(~\"client connecting!\");\n             let test_loop = get_loop_for_uv_handle(\n                                    server_stream_ptr as *libc::c_void);\n             if status != 0i32 {\n@@ -1551,7 +1531,7 @@ pub mod test {\n                 client_stream_ptr as *libc::c_void,\n                 server_data as *libc::c_void);\n             if (client_init_result == 0i32) {\n-                debug!(\"successfully initialized client stream\");\n+                debug!(~\"successfully initialized client stream\");\n                 let accept_result = accept(server_stream_ptr as\n                                                      *libc::c_void,\n                                                    client_stream_ptr as\n@@ -1563,7 +1543,7 @@ pub mod test {\n                                                          on_alloc_cb,\n                                                          on_server_read_cb);\n                     if (read_result == 0i32) {\n-                        debug!(\"successful server read start\");\n+                        debug!(~\"successful server read start\");\n                     }\n                     else {\n                         debug!(\"server_connection_cb: bad read:%d\",\n@@ -1674,7 +1654,7 @@ pub mod test {\n                 let bind_result = tcp_bind(tcp_server_ptr,\n                                                    server_addr_ptr);\n                 if (bind_result == 0i32) {\n-                    debug!(\"successful uv_tcp_bind, listening\");\n+                    debug!(~\"successful uv_tcp_bind, listening\");\n \n                     // uv_listen()\n                     let listen_result = listen(tcp_server_ptr as\n@@ -1694,7 +1674,7 @@ pub mod test {\n                             async_send(continue_async_handle_ptr);\n                             // uv_run()\n                             run(test_loop);\n-                            debug!(\"server uv::run() has returned\");\n+                            debug!(~\"server uv::run() has returned\");\n                         }\n                         else {\n                             debug!(\"uv_async_init failure: %d\",\n@@ -1751,9 +1731,9 @@ pub mod test {\n             };\n \n             // block until the server up is.. possibly a race?\n-            debug!(\"before receiving on server continue_port\");\n+            debug!(~\"before receiving on server continue_port\");\n             continue_port.recv();\n-            debug!(\"received on continue port, set up tcp client\");\n+            debug!(~\"received on continue port, set up tcp client\");\n \n             let kill_server_msg_copy = copy kill_server_msg;\n             do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1808,7 +1788,7 @@ pub mod test {\n                 let output = fmt!(\n                     \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n                     t_name, rust_size, foreign_size as uint);\n-                debug!(\"%s\", output);\n+                debug!(output);\n             }\n             fail_unless!(sizes_match);\n         }", "previous_filename": "src/libcore/unstable/uvll.rs"}, {"sha": "803da32cbc8ac7cffa5c8c6631ce5fdc31b69bee", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -21,17 +21,6 @@\n \n void* global_crate_map = NULL;\n \n-#ifndef _WIN32\n-pthread_key_t sched_key;\n-#else\n-DWORD sched_key;\n-#endif\n-\n-extern \"C\" void*\n-rust_get_sched_tls_key() {\n-    return &sched_key;\n-}\n-\n /**\n    The runtime entrypoint. The (C ABI) main function generated by rustc calls\n    `rust_start`, providing the address of the Rust ABI main function, the\n@@ -41,10 +30,6 @@ rust_get_sched_tls_key() {\n extern \"C\" CDECL int\n rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n-#ifndef _WIN32\n-    pthread_key_create(&sched_key, NULL);\n-#endif\n-\n     // Load runtime configuration options from the environment.\n     // FIXME #1497: Should provide a way to get these from the command\n     // line as well."}, {"sha": "f586e05772b76d5598bf7bd272c560002a45280a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -882,6 +882,46 @@ rust_get_rt_env() {\n     return task->kernel->env;\n }\n \n+typedef void *(*nullary_fn)();\n+\n+extern \"C\" CDECL void\n+rust_call_nullary_fn(nullary_fn f) {\n+    f();\n+}\n+\n+#ifndef _WIN32\n+pthread_key_t sched_key;\n+#else\n+DWORD sched_key;\n+#endif\n+\n+extern \"C\" void*\n+rust_get_sched_tls_key() {\n+    return &sched_key;\n+}\n+\n+// Initialize the global state required by the new scheduler\n+extern \"C\" CDECL void\n+rust_initialize_global_state() {\n+\n+    static lock_and_signal init_lock;\n+    static bool initialized = false;\n+\n+    scoped_lock with(init_lock);\n+\n+    if (!initialized) {\n+\n+#ifndef _WIN32\n+        assert(!pthread_key_create(&sched_key, NULL));\n+#else\n+        sched_key = TlsAlloc();\n+        assert(sched_key != TLS_OUT_OF_INDEXES);\n+#endif\n+\n+        initialized = true;\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "325b10b92df6b5f9ea8dad9ac66c4f37dbb5ff9b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -479,6 +479,34 @@ extern \"C\" struct sockaddr_in6\n rust_uv_ip6_addr(const char* ip, int port) {\n     return uv_ip6_addr(ip, port);\n }\n+\n+extern \"C\" struct sockaddr_in*\n+rust_uv_ip4_addrp(const char* ip, int port) {\n+  struct sockaddr_in addr = uv_ip4_addr(ip, port);\n+  struct sockaddr_in *addrp = (sockaddr_in*)malloc(sizeof(struct sockaddr_in));\n+  assert(addrp);\n+  memcpy(addrp, &addr, sizeof(struct sockaddr_in));\n+  return addrp;\n+}\n+extern \"C\" struct sockaddr_in6*\n+rust_uv_ip6_addrp(const char* ip, int port) {\n+  struct sockaddr_in6 addr = uv_ip6_addr(ip, port);\n+  struct sockaddr_in6 *addrp = (sockaddr_in6*)malloc(sizeof(struct sockaddr_in6));\n+  assert(addrp);\n+  memcpy(addrp, &addr, sizeof(struct sockaddr_in6));\n+  return addrp;\n+}\n+\n+extern \"C\" void\n+rust_uv_free_ip4_addr(sockaddr_in *addrp) {\n+  free(addrp);\n+}\n+\n+extern \"C\" void\n+rust_uv_free_ip6_addr(sockaddr_in6 *addrp) {\n+  free(addrp);\n+}\n+\n extern \"C\" int\n rust_uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size) {\n     return uv_ip4_name(src, dst, size);\n@@ -563,3 +591,23 @@ extern \"C\" int\n rust_uv_idle_stop(uv_idle_t* idle) {\n   return uv_idle_stop(idle);\n }\n+\n+extern \"C\" size_t\n+rust_uv_handle_size(uintptr_t type) {\n+  return uv_handle_size((uv_handle_type)type);\n+}\n+\n+extern \"C\" size_t\n+rust_uv_req_size(uintptr_t type) {\n+  return uv_req_size((uv_req_type)type);\n+}\n+\n+extern \"C\" uintptr_t\n+rust_uv_handle_type_max() {\n+  return UV_HANDLE_TYPE_MAX;\n+}\n+\n+extern \"C\" uintptr_t\n+rust_uv_req_type_max() {\n+  return UV_REQ_TYPE_MAX;\n+}"}, {"sha": "59fd8991622c69c5e393ead5d47375683f1e89f9", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/30d4124a374489de1776eb1b8076ca533041fa18/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=30d4124a374489de1776eb1b8076ca533041fa18", "patch": "@@ -202,3 +202,15 @@ rust_dbg_extern_identity_TwoU64s\n rust_dbg_extern_identity_double\n rust_dbg_extern_identity_u8\n rust_get_rt_env\n+rust_uv_handle_size\n+rust_uv_req_size\n+rust_uv_handle_type_max\n+rust_uv_req_type_max\n+rust_uv_ip4_addrp\n+rust_uv_ip6_addrp\n+rust_uv_free_ip4_addr\n+rust_uv_free_ip6_addr\n+rust_call_nullary_fn\n+rust_initialize_global_state\n+\n+"}]}