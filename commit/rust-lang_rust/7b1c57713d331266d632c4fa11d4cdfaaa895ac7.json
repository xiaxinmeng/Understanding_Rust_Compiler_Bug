{"sha": "7b1c57713d331266d632c4fa11d4cdfaaa895ac7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMWM1NzcxM2QzMzEyNjZkNjMyYzRmYTExZDRjZGZhYWE4OTVhYzc=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-10T01:49:32Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:54:34Z"}, "message": "dlist: Introduce a struct Rawlink mimicing Option<T> for a raw pointer\n\nRawlink<T> holds a *mut T pointer and can convert itself to Option<&mut T>.\nThe null pointer is of course None.", "tree": {"sha": "37b59d0c0930e50794d79ecc9607030f6d8f8b28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37b59d0c0930e50794d79ecc9607030f6d8f8b28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b1c57713d331266d632c4fa11d4cdfaaa895ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1c57713d331266d632c4fa11d4cdfaaa895ac7", "html_url": "https://github.com/rust-lang/rust/commit/7b1c57713d331266d632c4fa11d4cdfaaa895ac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b1c57713d331266d632c4fa11d4cdfaaa895ac7/comments", "author": null, "committer": null, "parents": [{"sha": "f97e64083b10e06286eb621f9dff918362e03fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f97e64083b10e06286eb621f9dff918362e03fc1", "html_url": "https://github.com/rust-lang/rust/commit/f97e64083b10e06286eb621f9dff918362e03fc1"}], "stats": {"total": 135, "additions": 73, "deletions": 62}, "files": [{"sha": "b197ea83fdc41d6047fdac2efbc252f751649d4b", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7b1c57713d331266d632c4fa11d4cdfaaa895ac7/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1c57713d331266d632c4fa11d4cdfaaa895ac7/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=7b1c57713d331266d632c4fa11d4cdfaaa895ac7", "patch": "@@ -13,25 +13,23 @@\n \n use std::cast;\n use std::cmp;\n+use std::ptr;\n use std::util;\n use std::iterator::FromIterator;\n \n /// A doubly-linked list\n pub struct List<T> {\n     priv length: uint,\n     priv list_head: Link<T>,\n-    priv list_tail: Rawlink<T>,\n+    priv list_tail: Rawlink<Node<T>>,\n }\n \n type Link<T> = Option<~Node<T>>;\n-type Rawlink<T> = Option<&'static Node<T>>;\n-// Rawlink uses &'static to have a small Option<&'> represenation.\n-// FIXME: Use a raw pointer like *mut Node if possible.\n-// FIXME: Causes infinite recursion in %? repr\n+struct Rawlink<T> { priv p: *mut T }\n \n struct Node<T> {\n     priv next: Link<T>,\n-    priv prev: Rawlink<T>,\n+    priv prev: Rawlink<Node<T>>,\n     priv value: T,\n }\n \n@@ -45,21 +43,21 @@ pub struct ForwardIterator<'self, T> {\n /// List reverse iterator\n pub struct ReverseIterator<'self, T> {\n     priv list: &'self List<T>,\n-    priv next: Rawlink<T>,\n+    priv next: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n /// List mutable iterator\n pub struct MutForwardIterator<'self, T> {\n     priv list: &'self mut List<T>,\n-    priv curs: Rawlink<T>,\n+    priv curs: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n /// List mutable reverse iterator\n pub struct MutReverseIterator<'self, T> {\n     priv list: &'self mut List<T>,\n-    priv next: Rawlink<T>,\n+    priv next: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n@@ -73,6 +71,33 @@ pub struct ConsumeRevIterator<T> {\n     priv list: List<T>\n }\n \n+/// Rawlink is a type like Option<T> but for holding a raw pointer\n+impl<T> Rawlink<T> {\n+    /// Like Option::None for Rawlink\n+    fn none() -> Rawlink<T> {\n+        Rawlink{p: ptr::mut_null()}\n+    }\n+\n+    /// Like Option::Some for Rawlink\n+    fn some(n: &mut T) -> Rawlink<T> {\n+        Rawlink{p: ptr::to_mut_unsafe_ptr(n)}\n+    }\n+\n+    /// Convert the `Rawlink` into an Option value\n+    fn resolve_immut(&self) -> Option<&T> {\n+        unsafe { self.p.to_option() }\n+    }\n+\n+    /// Convert the `Rawlink` into an Option value\n+    fn resolve(&mut self) -> Option<&mut T> {\n+        if self.p.is_null() {\n+            None\n+        } else {\n+            Some(unsafe { cast::transmute(self.p) })\n+        }\n+    }\n+}\n+\n impl<T> Container for List<T> {\n     /// O(1)\n     fn is_empty(&self) -> bool {\n@@ -93,19 +118,11 @@ impl<T> Mutable for List<T> {\n     }\n }\n \n-/// Cast the raw link into a borrowed ref\n-fn resolve_rawlink<T>(lnk: &'static Node<T>) -> &mut Node<T> {\n-    unsafe { cast::transmute_mut(lnk) }\n-}\n-fn rawlink<T>(n: &mut Node<T>) -> Rawlink<T> {\n-    Some(unsafe { cast::transmute(n) })\n-}\n-\n impl<T> List<T> {\n     /// Create an empty List\n     #[inline]\n     pub fn new() -> List<T> {\n-        List{list_head: None, list_tail: None, length: 0}\n+        List{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n     /// Provide a reference to the front element, or None if the list is empty\n@@ -123,30 +140,29 @@ impl<T> List<T> {\n \n     /// Provide a reference to the back element, or None if the list is empty\n     pub fn peek_back<'a>(&'a self) -> Option<&'a T> {\n-        match self.list_tail {\n+        match self.list_tail.resolve_immut() {\n             None => None,\n-            Some(tail) => Some(&resolve_rawlink(tail).value),\n+            Some(tail) => Some(&tail.value),\n         }\n     }\n \n     /// Provide a mutable reference to the back element, or None if the list is empty\n     pub fn peek_back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        match self.list_tail {\n+        match self.list_tail.resolve() {\n             None => None,\n-            Some(tail) => Some(&mut resolve_rawlink(tail).value),\n+            Some(tail) => Some(&mut tail.value),\n         }\n     }\n \n     /// Add an element last in the list\n     ///\n     /// O(1)\n     pub fn push_back(&mut self, elt: T) {\n-        match self.list_tail {\n+        match self.list_tail.resolve() {\n             None => return self.push_front(elt),\n-            Some(rtail) => {\n+            Some(tail) => {\n                 let mut new_tail = ~Node{value: elt, next: None, prev: self.list_tail};\n-                self.list_tail = rawlink(new_tail);\n-                let tail = resolve_rawlink(rtail);\n+                self.list_tail = Rawlink::some(new_tail);\n                 tail.next = Some(new_tail);\n             }\n         }\n@@ -158,19 +174,18 @@ impl<T> List<T> {\n     /// O(1)\n     #[inline]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        match self.list_tail {\n+        match self.list_tail.resolve() {\n             None => None,\n-            Some(rtail) => {\n+            Some(tail) => {\n                 self.length -= 1;\n-                let tail = resolve_rawlink(rtail);\n-                let tail_own = match tail.prev {\n+                let tail_own = match tail.prev.resolve() {\n                     None => {\n-                        self.list_tail = None;\n+                        self.list_tail = Rawlink::none();\n                         self.list_head.swap_unwrap()\n                     },\n-                    Some(rtail_prev) => {\n+                    Some(tail_prev) => {\n                         self.list_tail = tail.prev;\n-                        resolve_rawlink(rtail_prev).next.swap_unwrap()\n+                        tail_prev.next.swap_unwrap()\n                     }\n                 };\n                 Some(tail_own.value)\n@@ -182,14 +197,14 @@ impl<T> List<T> {\n     ///\n     /// O(1)\n     pub fn push_front(&mut self, elt: T) {\n-        let mut new_head = ~Node{value: elt, next: None, prev: None};\n+        let mut new_head = ~Node{value: elt, next: None, prev: Rawlink::none()};\n         match self.list_head {\n             None => {\n-                self.list_tail = rawlink(new_head);\n+                self.list_tail = Rawlink::some(new_head);\n                 self.list_head = Some(new_head);\n             }\n             Some(ref mut head) => {\n-                head.prev = rawlink(new_head);\n+                head.prev = Rawlink::some(new_head);\n                 util::swap(head, &mut new_head);\n                 head.next = Some(new_head);\n             }\n@@ -208,12 +223,12 @@ impl<T> List<T> {\n                 match *head.swap_unwrap() {\n                     Node{value: value, next: Some(next), prev: _} => {\n                         let mut mnext = next;\n-                        mnext.prev = None;\n+                        mnext.prev = Rawlink::none();\n                         *head = Some(mnext);\n                         Some(value)\n                     }\n                     Node{value: value, next: None, prev: _} => {\n-                        self.list_tail = None;\n+                        self.list_tail = Rawlink::none();\n                         *head = None;\n                         Some(value)\n                     }\n@@ -226,14 +241,13 @@ impl<T> List<T> {\n     ///\n     /// O(1)\n     pub fn append(&mut self, other: List<T>) {\n-        match self.list_tail {\n+        match self.list_tail.resolve() {\n             None => *self = other,\n-            Some(rtail) => {\n+            Some(tail) => {\n                 match other {\n                     List{list_head: None, list_tail: _, length: _} => return,\n                     List{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n                         let mut lnk_node = node;\n-                        let tail = resolve_rawlink(rtail);\n                         lnk_node.prev = self.list_tail;\n                         tail.next = Some(lnk_node);\n                         self.list_tail = o_tail;\n@@ -301,7 +315,7 @@ impl<T> List<T> {\n \n     /// Provide a forward iterator with mutable references\n     pub fn mut_iter<'a>(&'a mut self) -> MutForwardIterator<'a, T> {\n-        MutForwardIterator{nelem: self.len(), list: self, curs: None}\n+        MutForwardIterator{nelem: self.len(), list: self, curs: Rawlink::none()}\n     }\n \n     /// Provide a reverse iterator with mutable references\n@@ -353,23 +367,23 @@ impl<'self, A> Iterator<&'self A> for ForwardIterator<'self, A> {\n impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self mut A> {\n-        match self.curs {\n+        match self.curs.resolve() {\n             None => {\n                 match self.list.list_head {\n                     None => None,\n                     Some(ref mut head) => {\n                         self.nelem -= 1;\n-                        self.curs = rawlink(&mut **head);\n+                        self.curs = Rawlink::some(*head);\n                         Some(&mut head.value)\n                     }\n                 }\n             }\n-            Some(rcurs) => {\n-                match resolve_rawlink(rcurs).next {\n+            Some(curs) => {\n+                match curs.next {\n                     None => None,\n                     Some(ref mut head) => {\n                         self.nelem -= 1;\n-                        self.curs = rawlink(&mut **head);\n+                        self.curs = Rawlink::some(*head);\n                         Some(&mut head.value)\n                     }\n                 }\n@@ -385,11 +399,10 @@ impl<'self, A> Iterator<&'self mut A> for MutForwardIterator<'self, A> {\n impl<'self, A> Iterator<&'self A> for ReverseIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self A> {\n-        match self.next {\n+        match self.next.resolve() {\n             None => None,\n-            Some(rnext) => {\n+            Some(prev) => {\n                 self.nelem -= 1;\n-                let prev = resolve_rawlink(rnext);\n                 self.next = prev.prev;\n                 Some(&prev.value)\n             }\n@@ -404,11 +417,10 @@ impl<'self, A> Iterator<&'self A> for ReverseIterator<'self, A> {\n impl<'self, A> Iterator<&'self mut A> for MutReverseIterator<'self, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self mut A> {\n-        match self.next {\n+        match self.next.resolve() {\n             None => None,\n-            Some(rnext) => {\n+            Some(prev) => {\n                 self.nelem -= 1;\n-                let prev = resolve_rawlink(rnext);\n                 self.next = prev.prev;\n                 Some(&mut prev.value)\n             }\n@@ -428,19 +440,18 @@ trait ListInsertCursor<A> {\n \n impl<'self, A> ListInsertCursor<A> for MutForwardIterator<'self, A> {\n     fn insert_before(&mut self, elt: A) {\n-        match self.curs {\n+        match self.curs.resolve() {\n             None => self.list.push_front(elt),\n-            Some(rcurs) => {\n-                let node = resolve_rawlink(rcurs);\n-                let prev_node = match node.prev {\n+            Some(node) => {\n+                let prev_node = match node.prev.resolve() {\n                     None => return self.list.push_front(elt),  // at head\n-                    Some(rprev) => resolve_rawlink(rprev),\n+                    Some(prev) => prev,\n                 };\n                 let mut node_own = prev_node.next.swap_unwrap();\n                 let mut ins_node = ~Node{value: elt,\n                                          next: None,\n-                                         prev: rawlink(prev_node)};\n-                node_own.prev = rawlink(ins_node);\n+                                         prev: Rawlink::some(prev_node)};\n+                node_own.prev = Rawlink::some(ins_node);\n                 ins_node.next = Some(node_own);\n                 prev_node.next = Some(ins_node);\n                 self.list.length += 1;\n@@ -497,11 +508,11 @@ fn check_links<T>(list: &List<T>) {\n         Some(ref node) => node_ptr = &**node,\n     }\n     loop {\n-        match (last_ptr, node_ptr.prev) {\n+        match (last_ptr, node_ptr.prev.resolve_immut()) {\n             (None   , None      ) => {}\n             (None   , _         ) => fail!(\"prev link for list_head\"),\n             (Some(p), Some(pptr)) => {\n-                assert_eq!((p as *Node<T>) as uint, pptr as *Node<T> as uint);\n+                assert_eq!(p as *Node<T>, pptr as *Node<T>);\n             }\n             _ => fail!(\"prev link is none, not good\"),\n         }"}]}