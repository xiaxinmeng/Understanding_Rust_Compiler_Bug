{"sha": "bf4e77d4b543632ca4df8fdd7092850dffc3954b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNGU3N2Q0YjU0MzYzMmNhNGRmOGZkZDcwOTI4NTBkZmZjMzk1NGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T00:42:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:14:11Z"}, "message": "std: Remove old_io/old_path/rand modules\n\nThis commit entirely removes the old I/O, path, and rand modules. All\nfunctionality has been deprecated and unstable for quite some time now!", "tree": {"sha": "c4b56d2a5974e1b3bf4bfc8b7ca1a62d64c2c341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4b56d2a5974e1b3bf4bfc8b7ca1a62d64c2c341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf4e77d4b543632ca4df8fdd7092850dffc3954b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4e77d4b543632ca4df8fdd7092850dffc3954b", "html_url": "https://github.com/rust-lang/rust/commit/bf4e77d4b543632ca4df8fdd7092850dffc3954b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf4e77d4b543632ca4df8fdd7092850dffc3954b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dabf0c6371d3b193664f58746fa27c1835a010f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dabf0c6371d3b193664f58746fa27c1835a010f3", "html_url": "https://github.com/rust-lang/rust/commit/dabf0c6371d3b193664f58746fa27c1835a010f3"}], "stats": {"total": 22887, "additions": 60, "deletions": 22827}, "files": [{"sha": "d7299b939f8ab5184ace0b90706da258ca04f982", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -24,15 +24,13 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(no_std)]\n #![no_std]\n-#![unstable(feature = \"rand\")]\n-#![feature(staged_api)]\n #![staged_api]\n+#![unstable(feature = \"rand\")]\n #![feature(core)]\n+#![feature(no_std)]\n+#![feature(staged_api)]\n #![feature(step_by)]\n-#![deprecated(reason = \"use the crates.io `rand` library instead\",\n-              since = \"1.0.0-alpha\")]\n \n #![cfg_attr(test, feature(test, rand, rustc_private))]\n "}, {"sha": "2efa84e69411572eb897eebc26a1c3b2ae73deff", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -30,7 +30,6 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "af1387346106a9f54213b09092773802dd72fea9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -14,8 +14,6 @@\n Core encoding and decoding interfaces.\n */\n \n-#[allow(deprecated)]\n-use std::old_path::{self, GenericPath};\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -540,36 +538,6 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-#[allow(deprecated)]\n-impl Encodable for old_path::posix::Path {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-#[allow(deprecated)]\n-impl Decodable for old_path::posix::Path {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<old_path::posix::Path, D::Error> {\n-        let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(old_path::posix::Path::new(bytes))\n-    }\n-}\n-\n-#[allow(deprecated)]\n-impl Encodable for old_path::windows::Path {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-#[allow(deprecated)]\n-impl Decodable for old_path::windows::Path {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<old_path::windows::Path, D::Error> {\n-        let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(old_path::windows::Path::new(bytes))\n-    }\n-}\n-\n impl Encodable for path::PathBuf {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.to_str().unwrap().encode(e)"}, {"sha": "d510ee48a16981a865412b94e3f1af0d7a9cb75e", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -18,8 +18,6 @@ use io;\n use iter::Iterator;\n use libc;\n use mem;\n-#[allow(deprecated)]\n-use old_io;\n use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n@@ -245,18 +243,6 @@ impl From<NulError> for io::Error {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl From<NulError> for old_io::IoError {\n-    fn from(_: NulError) -> old_io::IoError {\n-        old_io::IoError {\n-            kind: old_io::IoErrorKind::InvalidInput,\n-            desc: \"data provided contains a nul byte\",\n-            detail: None\n-        }\n-    }\n-}\n-\n impl CStr {\n     /// Cast a raw C string to a safe C string wrapper.\n     ///"}, {"sha": "cc2ba265cd75f808917967e0fda917bea994b48e", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -42,7 +42,6 @@ use string::String;\n use ops;\n use cmp;\n use hash::{Hash, Hasher};\n-use old_path::{Path, GenericPath};\n use vec::Vec;\n \n use sys::os_str::{Buf, Slice};\n@@ -447,21 +446,6 @@ impl AsRef<OsStr> for String {\n     }\n }\n \n-#[allow(deprecated)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for Path {\n-    #[cfg(unix)]\n-    fn as_os_str(&self) -> &OsStr {\n-        unsafe { mem::transmute(self.as_vec()) }\n-    }\n-    #[cfg(windows)]\n-    fn as_os_str(&self) -> &OsStr {\n-        // currently .as_str() is actually infallible on windows\n-        OsStr::from_str(self.as_str().unwrap())\n-    }\n-}\n-\n impl FromInner<Buf> for OsString {\n     fn from_inner(buf: Buf) -> OsString {\n         OsString { inner: buf }"}, {"sha": "23776ecbc6e900a7e3abbf324ce752ebff1623e3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -262,12 +262,9 @@ pub mod ffi;\n pub mod fs;\n pub mod io;\n pub mod net;\n-pub mod old_io;\n-pub mod old_path;\n pub mod os;\n pub mod path;\n pub mod process;\n-pub mod rand;\n pub mod sync;\n pub mod time;\n \n@@ -281,6 +278,7 @@ pub mod time;\n \n pub mod rt;\n mod panicking;\n+mod rand;\n \n // Modules that exist purely to document + host impl docs for primitive types\n \n@@ -297,8 +295,6 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    #[allow(deprecated)]\n-    pub use old_io; // used for println!()\n     pub use option; // used for bitflags!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]"}, {"sha": "68aa7e4770f067e3cada0738e0256ac7381d242a", "filename": "src/libstd/old_io/buffered.rs", "status": "removed", "additions": 0, "deletions": 702, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,702 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-//! Buffering wrappers for I/O traits\n-\n-use cmp;\n-use fmt;\n-use old_io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n-use iter::{Iterator, ExactSizeIterator, repeat};\n-use ops::Drop;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::Ok;\n-use slice;\n-use vec::Vec;\n-\n-/// Wraps a Reader and buffers input from it\n-///\n-/// It can be excessively inefficient to work directly with a `Reader`. For\n-/// example, every call to `read` on `TcpStream` results in a system call. A\n-/// `BufferedReader` performs large, infrequent reads on the underlying\n-/// `Reader` and maintains an in-memory buffer of the results.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let file = File::open(&Path::new(\"message.txt\"));\n-/// let mut reader = BufferedReader::new(file);\n-///\n-/// let mut buf = [0; 100];\n-/// match reader.read(&mut buf) {\n-///     Ok(nread) => println!(\"Read {} bytes\", nread),\n-///     Err(e) => println!(\"error reading: {}\", e)\n-/// }\n-/// ```\n-pub struct BufferedReader<R> {\n-    inner: R,\n-    buf: Vec<u8>,\n-    pos: usize,\n-    cap: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufferedReader {{ reader: {:?}, buffer: {}/{} }}\",\n-               self.inner, self.cap - self.pos, self.buf.len())\n-    }\n-}\n-\n-impl<R: Reader> BufferedReader<R> {\n-    /// Creates a new `BufferedReader` with the specified buffer capacity\n-    pub fn with_capacity(cap: usize, inner: R) -> BufferedReader<R> {\n-        BufferedReader {\n-            inner: inner,\n-            // We can't use the same trick here as we do for BufferedWriter,\n-            // since this memory is visible to the inner Reader.\n-            buf: repeat(0).take(cap).collect(),\n-            pos: 0,\n-            cap: 0,\n-        }\n-    }\n-\n-    /// Creates a new `BufferedReader` with a default buffer capacity\n-    pub fn new(inner: R) -> BufferedReader<R> {\n-        BufferedReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Gets a reference to the underlying reader.\n-    pub fn get_ref<'a>(&self) -> &R { &self.inner }\n-\n-    /// Gets a mutable reference to the underlying reader.\n-    ///\n-    /// # Warning\n-    ///\n-    /// It is inadvisable to directly read from the underlying reader.\n-    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n-\n-    /// Unwraps this `BufferedReader`, returning the underlying reader.\n-    ///\n-    /// Note that any leftover data in the internal buffer is lost.\n-    pub fn into_inner(self) -> R { self.inner }\n-}\n-\n-impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(&mut self.buf));\n-            self.pos = 0;\n-        }\n-        Ok(&self.buf[self.pos..self.cap])\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        self.pos += amt;\n-        assert!(self.pos <= self.cap);\n-    }\n-}\n-\n-impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.pos == self.cap && buf.len() >= self.buf.len() {\n-            return self.inner.read(buf);\n-        }\n-        let nread = {\n-            let available = try!(self.fill_buf());\n-            let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(&available[..nread], buf);\n-            nread\n-        };\n-        self.pos += nread;\n-        Ok(nread)\n-    }\n-}\n-\n-/// Wraps a Writer and buffers output to it\n-///\n-/// It can be excessively inefficient to work directly with a `Writer`. For\n-/// example, every call to `write` on `TcpStream` results in a system call. A\n-/// `BufferedWriter` keeps an in memory buffer of data and writes it to the\n-/// underlying `Writer` in large, infrequent batches.\n-///\n-/// This writer will be flushed when it is dropped.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let file = File::create(&Path::new(\"message.txt\")).unwrap();\n-/// let mut writer = BufferedWriter::new(file);\n-///\n-/// writer.write_str(\"hello, world\").unwrap();\n-/// writer.flush().unwrap();\n-/// ```\n-pub struct BufferedWriter<W: Writer> {\n-    inner: Option<W>,\n-    buf: Vec<u8>,\n-    pos: usize\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Writer> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.as_ref().unwrap(), self.pos, self.buf.len())\n-    }\n-}\n-\n-impl<W: Writer> BufferedWriter<W> {\n-    /// Creates a new `BufferedWriter` with the specified buffer capacity\n-    pub fn with_capacity(cap: usize, inner: W) -> BufferedWriter<W> {\n-        // It's *much* faster to create an uninitialized buffer than it is to\n-        // fill everything in with 0. This buffer is entirely an implementation\n-        // detail and is never exposed, so we're safe to not initialize\n-        // everything up-front. This allows creation of BufferedWriter instances\n-        // to be very cheap (large mallocs are not nearly as expensive as large\n-        // callocs).\n-        let mut buf = Vec::with_capacity(cap);\n-        unsafe { buf.set_len(cap); }\n-        BufferedWriter {\n-            inner: Some(inner),\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Creates a new `BufferedWriter` with a default buffer capacity\n-    pub fn new(inner: W) -> BufferedWriter<W> {\n-        BufferedWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    fn flush_buf(&mut self) -> IoResult<()> {\n-        if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write_all(&self.buf[..self.pos]);\n-            self.pos = 0;\n-            ret\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n-\n-    /// Gets a mutable reference to the underlying write.\n-    ///\n-    /// # Warning\n-    ///\n-    /// It is inadvisable to directly read from the underlying writer.\n-    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n-\n-    /// Unwraps this `BufferedWriter`, returning the underlying writer.\n-    ///\n-    /// The buffer is flushed before returning the writer.\n-    pub fn into_inner(mut self) -> W {\n-        // FIXME(#12628): is panicking the right thing to do if flushing panicks?\n-        self.flush_buf().unwrap();\n-        self.inner.take().unwrap()\n-    }\n-}\n-\n-impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        if self.pos + buf.len() > self.buf.len() {\n-            try!(self.flush_buf());\n-        }\n-\n-        if buf.len() > self.buf.len() {\n-            self.inner.as_mut().unwrap().write_all(buf)\n-        } else {\n-            let dst = &mut self.buf[self.pos..];\n-            slice::bytes::copy_memory(buf, dst);\n-            self.pos += buf.len();\n-            Ok(())\n-        }\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> {\n-        self.flush_buf().and_then(|()| self.inner.as_mut().unwrap().flush())\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<W: Writer> Drop for BufferedWriter<W> {\n-    fn drop(&mut self) {\n-        if self.inner.is_some() {\n-            // dtors should not panic, so we ignore a panicked flush\n-            let _ = self.flush_buf();\n-        }\n-    }\n-}\n-\n-/// Wraps a Writer and buffers output to it, flushing whenever a newline (`0x0a`,\n-/// `'\\n'`) is detected.\n-///\n-/// This writer will be flushed when it is dropped.\n-pub struct LineBufferedWriter<W: Writer> {\n-    inner: BufferedWriter<W>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Writer> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"LineBufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.inner, self.inner.pos, self.inner.buf.len())\n-    }\n-}\n-\n-impl<W: Writer> LineBufferedWriter<W> {\n-    /// Creates a new `LineBufferedWriter`\n-    pub fn new(inner: W) -> LineBufferedWriter<W> {\n-        // Lines typically aren't that long, don't use a giant buffer\n-        LineBufferedWriter {\n-            inner: BufferedWriter::with_capacity(1024, inner)\n-        }\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// This type does not expose the ability to get a mutable reference to the\n-    /// underlying reader because that could possibly corrupt the buffer.\n-    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n-\n-    /// Unwraps this `LineBufferedWriter`, returning the underlying writer.\n-    ///\n-    /// The internal buffer is flushed before returning the writer.\n-    pub fn into_inner(self) -> W { self.inner.into_inner() }\n-}\n-\n-impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        match buf.iter().rposition(|&b| b == b'\\n') {\n-            Some(i) => {\n-                try!(self.inner.write_all(&buf[..i + 1]));\n-                try!(self.inner.flush());\n-                try!(self.inner.write_all(&buf[i + 1..]));\n-                Ok(())\n-            }\n-            None => self.inner.write_all(buf),\n-        }\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n-}\n-\n-struct InternalBufferedWriter<W: Writer>(BufferedWriter<W>);\n-\n-impl<W: Writer> InternalBufferedWriter<W> {\n-    fn get_mut<'a>(&'a mut self) -> &'a mut BufferedWriter<W> {\n-        let InternalBufferedWriter(ref mut w) = *self;\n-        return w;\n-    }\n-}\n-\n-impl<W: Reader + Writer> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.get_mut().inner.as_mut().unwrap().read(buf)\n-    }\n-}\n-\n-/// Wraps a Stream and buffers input and output to and from it.\n-///\n-/// It can be excessively inefficient to work directly with a `Stream`. For\n-/// example, every call to `read` or `write` on `TcpStream` results in a system\n-/// call. A `BufferedStream` keeps in memory buffers of data, making large,\n-/// infrequent calls to `read` and `write` on the underlying `Stream`.\n-///\n-/// The output half will be flushed when this stream is dropped.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let file = File::open(&Path::new(\"message.txt\"));\n-/// let mut stream = BufferedStream::new(file);\n-///\n-/// stream.write_all(\"hello, world\".as_bytes());\n-/// stream.flush();\n-///\n-/// let mut buf = [0; 100];\n-/// match stream.read(&mut buf) {\n-///     Ok(nread) => println!(\"Read {} bytes\", nread),\n-///     Err(e) => println!(\"error reading: {}\", e)\n-/// }\n-/// ```\n-pub struct BufferedStream<S: Writer> {\n-    inner: BufferedReader<InternalBufferedWriter<S>>\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Writer> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let reader = &self.inner;\n-        let writer = &self.inner.inner.0;\n-        write!(fmt, \"BufferedStream {{ stream: {:?}, write_buffer: {}/{}, read_buffer: {}/{} }}\",\n-               writer.inner,\n-               writer.pos, writer.buf.len(),\n-               reader.cap - reader.pos, reader.buf.len())\n-    }\n-}\n-\n-impl<S: Stream> BufferedStream<S> {\n-    /// Creates a new buffered stream with explicitly listed capacities for the\n-    /// reader/writer buffer.\n-    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n-                           -> BufferedStream<S> {\n-        let writer = BufferedWriter::with_capacity(writer_cap, inner);\n-        let internal_writer = InternalBufferedWriter(writer);\n-        let reader = BufferedReader::with_capacity(reader_cap,\n-                                                   internal_writer);\n-        BufferedStream { inner: reader }\n-    }\n-\n-    /// Creates a new buffered stream with the default reader/writer buffer\n-    /// capacities.\n-    pub fn new(inner: S) -> BufferedStream<S> {\n-        BufferedStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE,\n-                                        inner)\n-    }\n-\n-    /// Gets a reference to the underlying stream.\n-    pub fn get_ref(&self) -> &S {\n-        let InternalBufferedWriter(ref w) = self.inner.inner;\n-        w.get_ref()\n-    }\n-\n-    /// Gets a mutable reference to the underlying stream.\n-    ///\n-    /// # Warning\n-    ///\n-    /// It is inadvisable to read directly from or write directly to the\n-    /// underlying stream.\n-    pub fn get_mut(&mut self) -> &mut S {\n-        let InternalBufferedWriter(ref mut w) = self.inner.inner;\n-        w.get_mut()\n-    }\n-\n-    /// Unwraps this `BufferedStream`, returning the underlying stream.\n-    ///\n-    /// The internal buffer is flushed before returning the stream. Any leftover\n-    /// data in the read buffer is lost.\n-    pub fn into_inner(self) -> S {\n-        let InternalBufferedWriter(w) = self.inner.inner;\n-        w.into_inner()\n-    }\n-}\n-\n-impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n-}\n-\n-impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.inner.get_mut().write_all(buf)\n-    }\n-    fn flush(&mut self) -> IoResult<()> {\n-        self.inner.inner.get_mut().flush()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    extern crate test;\n-    use old_io::{self, Reader, Writer, Buffer, BufferPrelude};\n-    use prelude::v1::*;\n-    use super::*;\n-    use super::super::{IoResult, EndOfFile};\n-    use super::super::mem::MemReader;\n-    use self::test::Bencher;\n-\n-    /// A type, free to create, primarily intended for benchmarking creation of\n-    /// wrappers that, just for construction, don't need a Reader/Writer that\n-    /// does anything useful. Is equivalent to `/dev/null` in semantics.\n-    #[derive(Clone,PartialEq,PartialOrd)]\n-    pub struct NullStream;\n-\n-    impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    impl Writer for NullStream {\n-        fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n-    }\n-\n-    /// A dummy reader intended at testing short-reads propagation.\n-    pub struct ShortReader {\n-        lengths: Vec<usize>,\n-    }\n-\n-    impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.lengths.is_empty() {\n-                Err(old_io::standard_error(old_io::EndOfFile))\n-            } else {\n-                Ok(self.lengths.remove(0))\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader() {\n-        let inner = MemReader::new(vec!(5, 6, 7, 0, 1, 2, 3, 4));\n-        let mut reader = BufferedReader::with_capacity(2, inner);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(3), nread);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf, b);\n-\n-        let mut buf = [0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(2), nread);\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(buf, b);\n-\n-        let mut buf = [0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n-        let b: &[_] = &[2];\n-        assert_eq!(buf, b);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n-        let b: &[_] = &[3, 0, 0];\n-        assert_eq!(buf, b);\n-\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n-        let b: &[_] = &[4, 0, 0];\n-        assert_eq!(buf, b);\n-\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer() {\n-        let inner = Vec::new();\n-        let mut writer = BufferedWriter::with_capacity(2, inner);\n-\n-        writer.write_all(&[0, 1]).unwrap();\n-        let b: &[_] = &[];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        writer.write_all(&[2]).unwrap();\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        writer.write_all(&[3]).unwrap();\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        writer.flush().unwrap();\n-        let a: &[_] = &[0, 1, 2, 3];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[4]).unwrap();\n-        writer.write_all(&[5]).unwrap();\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[6]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[7, 8]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[9, 10, 11]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.flush().unwrap();\n-        assert_eq!(a, &writer.get_ref()[..]);\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer_inner_flushes() {\n-        let mut w = BufferedWriter::with_capacity(3, Vec::new());\n-        w.write_all(&[0, 1]).unwrap();\n-        let a: &[_] = &[];\n-        assert_eq!(&w.get_ref()[..], a);\n-        let w = w.into_inner();\n-        let a: &[_] = &[0, 1];\n-        assert_eq!(a, &w[..]);\n-    }\n-\n-    // This is just here to make sure that we don't infinite loop in the\n-    // newtype struct autoderef weirdness\n-    #[test]\n-    fn test_buffered_stream() {\n-        struct S;\n-\n-        impl old_io::Writer for S {\n-            fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n-        }\n-\n-        impl old_io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-                Err(old_io::standard_error(old_io::EndOfFile))\n-            }\n-        }\n-\n-        let mut stream = BufferedStream::new(S);\n-        let mut buf = [];\n-        assert!(stream.read(&mut buf).is_err());\n-        stream.write_all(&buf).unwrap();\n-        stream.flush().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_read_until() {\n-        let inner = MemReader::new(vec!(0, 1, 2, 1, 0));\n-        let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Ok(vec!(0)));\n-        assert_eq!(reader.read_until(2), Ok(vec!(1, 2)));\n-        assert_eq!(reader.read_until(1), Ok(vec!(1)));\n-        assert_eq!(reader.read_until(8), Ok(vec!(0)));\n-        assert!(reader.read_until(9).is_err());\n-    }\n-\n-    #[test]\n-    fn test_line_buffer() {\n-        let mut writer = LineBufferedWriter::new(Vec::new());\n-        writer.write_all(&[0]).unwrap();\n-        let b: &[_] = &[];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.write_all(&[1]).unwrap();\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.flush().unwrap();\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.write_all(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n-        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.flush().unwrap();\n-        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.write_all(&[3, b'\\n']).unwrap();\n-        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n-        assert_eq!(&writer.get_ref()[..], b);\n-    }\n-\n-    #[test]\n-    fn test_read_line() {\n-        let in_buf = MemReader::new(b\"a\\nb\\nc\".to_vec());\n-        let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_string()));\n-        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_string()));\n-        assert_eq!(reader.read_line(), Ok(\"c\".to_string()));\n-        assert!(reader.read_line().is_err());\n-    }\n-\n-    #[test]\n-    fn test_lines() {\n-        let in_buf = MemReader::new(b\"a\\nb\\nc\".to_vec());\n-        let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_string())));\n-        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_string())));\n-        assert_eq!(it.next(), Some(Ok(\"c\".to_string())));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_short_reads() {\n-        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n-        let mut reader = BufferedReader::new(inner);\n-        let mut buf = [0, 0];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.read(&mut buf), Ok(2));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn read_char_buffered() {\n-        let buf = [195, 159];\n-        let mut reader = BufferedReader::with_capacity(1, &buf[..]);\n-        assert_eq!(reader.read_char(), Ok('\u00df'));\n-    }\n-\n-    #[test]\n-    fn test_chars() {\n-        let buf = [195, 159, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, &buf[..]);\n-        let mut it = reader.chars();\n-        assert_eq!(it.next(), Some(Ok('\u00df')));\n-        assert_eq!(it.next(), Some(Ok('a')));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn dont_panic_in_drop_on_panicked_flush() {\n-        struct FailFlushWriter;\n-\n-        impl Writer for FailFlushWriter {\n-            fn write_all(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n-            fn flush(&mut self) -> IoResult<()> { Err(old_io::standard_error(EndOfFile)) }\n-        }\n-\n-        let writer = FailFlushWriter;\n-        let _writer = BufferedWriter::new(writer);\n-\n-        // If writer panics *again* due to the flush error then the process will abort.\n-        panic!();\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_reader(b: &mut Bencher) {\n-        b.iter(|| {\n-            BufferedReader::new(NullStream)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_writer(b: &mut Bencher) {\n-        b.iter(|| {\n-            BufferedWriter::new(NullStream)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_stream(b: &mut Bencher) {\n-        b.iter(|| {\n-            BufferedStream::new(NullStream);\n-        });\n-    }\n-}"}, {"sha": "5ebf931e95c375f60f2358faae6b3112b756c3a8", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "removed", "additions": 0, "deletions": 247, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,247 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use clone::Clone;\n-use cmp;\n-use sync::mpsc::{Sender, Receiver};\n-use old_io;\n-use option::Option::{None, Some};\n-use result::Result::{Ok, Err};\n-use slice::bytes;\n-use super::{Buffer, Reader, Writer, IoResult};\n-use vec::Vec;\n-\n-/// Allows reading from a rx.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::sync::mpsc::channel;\n-/// use std::old_io::*;\n-///\n-/// let (tx, rx) = channel();\n-/// # drop(tx);\n-/// let mut reader = ChanReader::new(rx);\n-///\n-/// let mut buf = [0; 100];\n-/// match reader.read(&mut buf) {\n-///     Ok(nread) => println!(\"Read {} bytes\", nread),\n-///     Err(e) => println!(\"read error: {}\", e),\n-/// }\n-/// ```\n-pub struct ChanReader {\n-    buf: Vec<u8>,          // A buffer of bytes received but not consumed.\n-    pos: usize,             // How many of the buffered bytes have already be consumed.\n-    rx: Receiver<Vec<u8>>, // The Receiver to pull data from.\n-    closed: bool,          // Whether the channel this Receiver connects to has been closed.\n-}\n-\n-impl ChanReader {\n-    /// Wraps a `Port` in a `ChanReader` structure\n-    pub fn new(rx: Receiver<Vec<u8>>) -> ChanReader {\n-        ChanReader {\n-            buf: Vec::new(),\n-            pos: 0,\n-            rx: rx,\n-            closed: false,\n-        }\n-    }\n-}\n-\n-impl Buffer for ChanReader {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        if self.pos >= self.buf.len() {\n-            self.pos = 0;\n-            match self.rx.recv() {\n-                Ok(bytes) => {\n-                    self.buf = bytes;\n-                },\n-                Err(..) => {\n-                    self.closed = true;\n-                    self.buf = Vec::new();\n-                }\n-            }\n-        }\n-        if self.closed {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(&self.buf[self.pos..])\n-        }\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        self.pos += amt;\n-        assert!(self.pos <= self.buf.len());\n-    }\n-}\n-\n-impl Reader for ChanReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let mut num_read = 0;\n-        loop {\n-            let count = match self.fill_buf().ok() {\n-                Some(src) => {\n-                    let dst = &mut buf[num_read..];\n-                    let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(&src[..count], dst);\n-                    count\n-                },\n-                None => 0,\n-            };\n-            self.consume(count);\n-            num_read += count;\n-            if num_read == buf.len() || self.closed {\n-                break;\n-            }\n-        }\n-        if self.closed && num_read == 0 {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(num_read)\n-        }\n-    }\n-}\n-\n-/// Allows writing to a tx.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::sync::mpsc::channel;\n-/// use std::old_io::*;\n-///\n-/// let (tx, rx) = channel();\n-/// # drop(rx);\n-/// let mut writer = ChanWriter::new(tx);\n-/// writer.write(\"hello, world\".as_bytes());\n-/// ```\n-pub struct ChanWriter {\n-    tx: Sender<Vec<u8>>,\n-}\n-\n-impl ChanWriter {\n-    /// Wraps a channel in a `ChanWriter` structure\n-    pub fn new(tx: Sender<Vec<u8>>) -> ChanWriter {\n-        ChanWriter { tx: tx }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for ChanWriter {\n-    fn clone(&self) -> ChanWriter {\n-        ChanWriter { tx: self.tx.clone() }\n-    }\n-}\n-\n-impl Writer for ChanWriter {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.tx.send(buf.to_vec()).map_err(|_| {\n-            old_io::IoError {\n-                kind: old_io::BrokenPipe,\n-                desc: \"Pipe closed\",\n-                detail: None\n-            }\n-        })\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use sync::mpsc::channel;\n-    use super::*;\n-    use old_io::{self, Reader, Writer, Buffer};\n-    use thread;\n-\n-    #[test]\n-    fn test_rx_reader() {\n-        let (tx, rx) = channel();\n-        thread::spawn(move|| {\n-          tx.send(vec![1, 2]).unwrap();\n-          tx.send(vec![]).unwrap();\n-          tx.send(vec![3, 4]).unwrap();\n-          tx.send(vec![5, 6]).unwrap();\n-          tx.send(vec![7, 8]).unwrap();\n-        });\n-\n-        let mut reader = ChanReader::new(rx);\n-        let mut buf = [0; 3];\n-\n-        assert_eq!(Ok(0), reader.read(&mut []));\n-\n-        assert_eq!(Ok(3), reader.read(&mut buf));\n-        let a: &[u8] = &[1,2,3];\n-        assert_eq!(a, buf);\n-\n-        assert_eq!(Ok(3), reader.read(&mut buf));\n-        let a: &[u8] = &[4,5,6];\n-        assert_eq!(a, buf);\n-\n-        assert_eq!(Ok(2), reader.read(&mut buf));\n-        let a: &[u8] = &[7,8,6];\n-        assert_eq!(a, buf);\n-\n-        match reader.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-        assert_eq!(a, buf);\n-\n-        // Ensure it continues to panic in the same way.\n-        match reader.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-        assert_eq!(a, buf);\n-    }\n-\n-    #[test]\n-    fn test_rx_buffer() {\n-        let (tx, rx) = channel();\n-        thread::spawn(move|| {\n-          tx.send(b\"he\".to_vec()).unwrap();\n-          tx.send(b\"llo wo\".to_vec()).unwrap();\n-          tx.send(b\"\".to_vec()).unwrap();\n-          tx.send(b\"rld\\nhow \".to_vec()).unwrap();\n-          tx.send(b\"are you?\".to_vec()).unwrap();\n-          tx.send(b\"\".to_vec()).unwrap();\n-        });\n-\n-        let mut reader = ChanReader::new(rx);\n-\n-        assert_eq!(Ok(\"hello world\\n\".to_string()), reader.read_line());\n-        assert_eq!(Ok(\"how are you?\".to_string()), reader.read_line());\n-        match reader.read_line() {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_chan_writer() {\n-        let (tx, rx) = channel();\n-        let mut writer = ChanWriter::new(tx);\n-        writer.write_be_u32(42).unwrap();\n-\n-        let wanted = vec![0, 0, 0, 42];\n-        let got = thread::scoped(move|| { rx.recv().unwrap() }).join();\n-        assert_eq!(wanted, got);\n-\n-        match writer.write_u8(1) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::BrokenPipe),\n-        }\n-    }\n-}"}, {"sha": "73973d0db282d26c92c8adc059d46bb0f1c5dc96", "filename": "src/libstd/old_io/extensions.rs", "status": "removed", "additions": 0, "deletions": 564, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,564 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utility mixins that apply to all Readers and Writers\n-\n-#![allow(missing_docs)]\n-#![unstable(feature = \"old_io\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"functionality will be removed with no immediate \\\n-                        replacement\")]\n-\n-// FIXME: Not sure how this should be structured\n-// FIXME: Iteration should probably be considered separately\n-\n-use old_io::{IoError, IoResult, Reader};\n-use old_io;\n-use iter::Iterator;\n-use num::Int;\n-use ops::FnOnce;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::{Ok, Err};\n-\n-/// An iterator that reads a single byte on each iteration,\n-/// until `.read_byte()` returns `EndOfFile`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `Bytes` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Error\n-///\n-/// Any error other than `EndOfFile` that is produced by the underlying Reader\n-/// is returned by the iterator and should be handled by the caller.\n-pub struct Bytes<'r, T:'r> {\n-    reader: &'r mut T,\n-}\n-\n-impl<'r, R: Reader> Bytes<'r, R> {\n-    /// Constructs a new byte iterator from the given Reader instance.\n-    pub fn new(r: &'r mut R) -> Bytes<'r, R> {\n-        Bytes {\n-            reader: r,\n-        }\n-    }\n-}\n-\n-impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n-    type Item = IoResult<u8>;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<IoResult<u8>> {\n-        match self.reader.read_byte() {\n-            Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: old_io::EndOfFile, .. }) => None,\n-            Err(e) => Some(Err(e))\n-        }\n-    }\n-}\n-\n-/// Converts an 8-bit to 64-bit unsigned value to a little-endian byte\n-/// representation of the given size. If the size is not big enough to\n-/// represent the value, then the high-order bytes are truncated.\n-///\n-/// Arguments:\n-///\n-/// * `n`: The value to convert.\n-/// * `size`: The size of the value, in bytes. This must be 8 or less, or task\n-///           panic occurs. If this is less than 8, then a value of that\n-///           many bytes is produced. For example, if `size` is 4, then a\n-///           32-bit byte representation is produced.\n-/// * `f`: A callback that receives the value.\n-///\n-/// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_le_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n-    F: FnOnce(&[u8]) -> T,\n-{\n-    use mem::transmute;\n-\n-    // LLVM fails to properly optimize this when using shifts instead of the to_le* intrinsics\n-    assert!(size <= 8);\n-    match size {\n-      1 => f(&[n as u8]),\n-      2 => f(unsafe { & transmute::<_, [u8; 2]>((n as u16).to_le()) }),\n-      4 => f(unsafe { & transmute::<_, [u8; 4]>((n as u32).to_le()) }),\n-      8 => f(unsafe { & transmute::<_, [u8; 8]>(n.to_le()) }),\n-      _ => {\n-\n-        let mut bytes = vec!();\n-        let mut i = size;\n-        let mut n = n;\n-        while i > 0 {\n-            bytes.push((n & 255) as u8);\n-            n >>= 8;\n-            i -= 1;\n-        }\n-        f(&bytes)\n-      }\n-    }\n-}\n-\n-/// Converts an 8-bit to 64-bit unsigned value to a big-endian byte\n-/// representation of the given size. If the size is not big enough to\n-/// represent the value, then the high-order bytes are truncated.\n-///\n-/// Arguments:\n-///\n-/// * `n`: The value to convert.\n-/// * `size`: The size of the value, in bytes. This must be 8 or less, or task\n-///           panic occurs. If this is less than 8, then a value of that\n-///           many bytes is produced. For example, if `size` is 4, then a\n-///           32-bit byte representation is produced.\n-/// * `f`: A callback that receives the value.\n-///\n-/// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_be_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n-    F: FnOnce(&[u8]) -> T,\n-{\n-    use mem::transmute;\n-\n-    // LLVM fails to properly optimize this when using shifts instead of the to_be* intrinsics\n-    assert!(size <= 8);\n-    match size {\n-      1 => f(&[n as u8]),\n-      2 => f(unsafe { & transmute::<_, [u8; 2]>((n as u16).to_be()) }),\n-      4 => f(unsafe { & transmute::<_, [u8; 4]>((n as u32).to_be()) }),\n-      8 => f(unsafe { & transmute::<_, [u8; 8]>(n.to_be()) }),\n-      _ => {\n-        let mut bytes = vec!();\n-        let mut i = size;\n-        while i > 0 {\n-            let shift = (i - 1) * 8;\n-            bytes.push((n >> shift) as u8);\n-            i -= 1;\n-        }\n-        f(&bytes)\n-      }\n-    }\n-}\n-\n-/// Extracts an 8-bit to 64-bit unsigned big-endian value from the given byte\n-/// buffer and returns it as a 64-bit value.\n-///\n-/// Arguments:\n-///\n-/// * `data`: The buffer in which to extract the value.\n-/// * `start`: The offset at which to extract the value.\n-/// * `size`: The size of the value in bytes to extract. This must be 8 or\n-///           less, or task panic occurs. If this is less than 8, then only\n-///           that many bytes are parsed. For example, if `size` is 4, then a\n-///           32-bit value is parsed.\n-pub fn u64_from_be_bytes(data: &[u8], start: usize, size: usize) -> u64 {\n-    use ptr::{copy_nonoverlapping};\n-\n-    assert!(size <= 8);\n-\n-    if data.len() - start < size {\n-        panic!(\"index out of bounds\");\n-    }\n-\n-    let mut buf = [0; 8];\n-    unsafe {\n-        let ptr = data.as_ptr().offset(start as isize);\n-        let out = buf.as_mut_ptr();\n-        copy_nonoverlapping(ptr, out.offset((8 - size) as isize), size);\n-        (*(out as *const u64)).to_be()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use old_io::{self, Reader, Writer};\n-    use old_io::{MemReader, BytesReader};\n-\n-    struct InitialZeroByteReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                Ok(0)\n-            } else {\n-                buf[0] = 10;\n-                Ok(1)\n-            }\n-        }\n-    }\n-\n-    struct EofReader;\n-\n-    impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    struct ErroringReader;\n-\n-    impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            Err(old_io::standard_error(old_io::InvalidInput))\n-        }\n-    }\n-\n-    struct PartialReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                buf[1] = 11;\n-                Ok(2)\n-            } else {\n-                buf[0] = 12;\n-                buf[1] = 13;\n-                Ok(2)\n-            }\n-        }\n-    }\n-\n-    struct ErroringLaterReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                Ok(1)\n-            } else {\n-                Err(old_io::standard_error(old_io::InvalidInput))\n-            }\n-        }\n-    }\n-\n-    struct ThreeChunkReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                buf[1] = 11;\n-                Ok(2)\n-            } else if self.count == 1 {\n-                self.count = 2;\n-                buf[0] = 12;\n-                buf[1] = 13;\n-                Ok(2)\n-            } else {\n-                Err(old_io::standard_error(old_io::EndOfFile))\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn read_byte() {\n-        let mut reader = MemReader::new(vec!(10));\n-        let byte = reader.read_byte();\n-        assert!(byte == Ok(10));\n-    }\n-\n-    #[test]\n-    fn read_byte_0_bytes() {\n-        let mut reader = InitialZeroByteReader {\n-            count: 0,\n-        };\n-        let byte = reader.read_byte();\n-        assert!(byte == Ok(10));\n-    }\n-\n-    #[test]\n-    fn read_byte_eof() {\n-        let mut reader = EofReader;\n-        let byte = reader.read_byte();\n-        assert!(byte.is_err());\n-    }\n-\n-    #[test]\n-    fn read_byte_error() {\n-        let mut reader = ErroringReader;\n-        let byte = reader.read_byte();\n-        assert!(byte.is_err());\n-    }\n-\n-    #[test]\n-    fn bytes_0_bytes() {\n-        let mut reader = InitialZeroByteReader {\n-            count: 0,\n-        };\n-        let byte = reader.bytes().next();\n-        assert!(byte == Some(Ok(10)));\n-    }\n-\n-    #[test]\n-    fn bytes_eof() {\n-        let mut reader = EofReader;\n-        let byte = reader.bytes().next();\n-        assert!(byte.is_none());\n-    }\n-\n-    #[test]\n-    fn bytes_error() {\n-        let mut reader = ErroringReader;\n-        let mut it = reader.bytes();\n-        let byte = it.next();\n-        assert!(byte.unwrap().is_err());\n-    }\n-\n-    #[test]\n-    fn read_bytes() {\n-        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n-        let bytes = reader.read_exact(4).unwrap();\n-        assert_eq!(bytes, [10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn read_bytes_partial() {\n-        let mut reader = PartialReader {\n-            count: 0,\n-        };\n-        let bytes = reader.read_exact(4).unwrap();\n-        assert_eq!(bytes, [10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn read_bytes_eof() {\n-        let mut reader = MemReader::new(vec!(10, 11));\n-        assert!(reader.read_exact(4).is_err());\n-    }\n-\n-    #[test]\n-    fn push_at_least() {\n-        let mut reader = MemReader::new(vec![10, 11, 12, 13]);\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn push_at_least_partial() {\n-        let mut reader = PartialReader {\n-            count: 0,\n-        };\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn push_at_least_eof() {\n-        let mut reader = MemReader::new(vec![10, 11]);\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert_eq!(buf, [8, 9, 10, 11]);\n-    }\n-\n-    #[test]\n-    fn push_at_least_error() {\n-        let mut reader = ErroringLaterReader {\n-            count: 0,\n-        };\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert_eq!(buf, [8, 9, 10]);\n-    }\n-\n-    #[test]\n-    fn read_to_end() {\n-        let mut reader = ThreeChunkReader {\n-            count: 0,\n-        };\n-        let buf = reader.read_to_end().unwrap();\n-        assert_eq!(buf, [10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn read_to_end_error() {\n-        let mut reader = ThreeChunkReader {\n-            count: 0,\n-        };\n-        let buf = reader.read_to_end().unwrap();\n-        assert_eq!(buf, [10, 11]);\n-    }\n-\n-    #[test]\n-    fn test_read_write_le_mem() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n-\n-        let mut writer = Vec::new();\n-        for i in &uints {\n-            writer.write_le_u64(*i).unwrap();\n-        }\n-\n-        let mut reader = MemReader::new(writer);\n-        for i in &uints {\n-            assert!(reader.read_le_u64().unwrap() == *i);\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_read_write_be() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n-\n-        let mut writer = Vec::new();\n-        for i in &uints {\n-            writer.write_be_u64(*i).unwrap();\n-        }\n-\n-        let mut reader = MemReader::new(writer);\n-        for i in &uints {\n-            assert!(reader.read_be_u64().unwrap() == *i);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_be_int_n() {\n-        let ints = [::i32::MIN, -123456, -42, -5, 0, 1, ::i32::MAX];\n-\n-        let mut writer = Vec::new();\n-        for i in &ints {\n-            writer.write_be_i32(*i).unwrap();\n-        }\n-\n-        let mut reader = MemReader::new(writer);\n-        for i in &ints {\n-            // this tests that the sign extension is working\n-            // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n(4).unwrap() == *i as i64);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_f32() {\n-        //big-endian floating-point 8.1250\n-        let buf = vec![0x41, 0x02, 0x00, 0x00];\n-\n-        let mut writer = Vec::new();\n-        writer.write(&buf).unwrap();\n-\n-        let mut reader = MemReader::new(writer);\n-        let f = reader.read_be_f32().unwrap();\n-        assert!(f == 8.1250);\n-    }\n-\n-    #[test]\n-    fn test_read_write_f32() {\n-        let f:f32 = 8.1250;\n-\n-        let mut writer = Vec::new();\n-        writer.write_be_f32(f).unwrap();\n-        writer.write_le_f32(f).unwrap();\n-\n-        let mut reader = MemReader::new(writer);\n-        assert!(reader.read_be_f32().unwrap() == 8.1250);\n-        assert!(reader.read_le_f32().unwrap() == 8.1250);\n-    }\n-\n-    #[test]\n-    fn test_u64_from_be_bytes() {\n-        use super::u64_from_be_bytes;\n-\n-        let buf = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09];\n-\n-        // Aligned access\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 0), 0);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 1), 0x01);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 2), 0x0102);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 3), 0x010203);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 4), 0x01020304);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 5), 0x0102030405);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 6), 0x010203040506);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 7), 0x01020304050607);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 8), 0x0102030405060708);\n-\n-        // Unaligned access\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 0), 0);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 1), 0x02);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 2), 0x0203);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 3), 0x020304);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 4), 0x02030405);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 5), 0x0203040506);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 6), 0x020304050607);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 7), 0x02030405060708);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 8), 0x0203040506070809);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use prelude::v1::*;\n-    use self::test::Bencher;\n-\n-    // why is this a macro? wouldn't an inlined function work just as well?\n-    macro_rules! u64_from_be_bytes_bench_impl {\n-        ($b:expr, $size:expr, $stride:expr, $start_index:expr) =>\n-        ({\n-            use super::u64_from_be_bytes;\n-\n-            let len = ($stride as u8).wrapping_mul(100).wrapping_add($start_index);\n-            let data = (0..len).collect::<Vec<_>>();\n-            let mut sum = 0;\n-            $b.iter(|| {\n-                let mut i = $start_index;\n-                while i < data.len() {\n-                    sum += u64_from_be_bytes(&data, i, $size);\n-                    i += $stride;\n-                }\n-            });\n-        })\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_4_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 4, 4, 0);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_4_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 4, 4, 1);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_7_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 7, 8, 0);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_7_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 7, 8, 1);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_8_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 8, 8, 0);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_8_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 8, 8, 1);\n-    }\n-}"}, {"sha": "509daa46ef3be1b509d54da638c27590b8d2dff5", "filename": "src/libstd/old_io/fs.rs", "status": "removed", "additions": 0, "deletions": 1654, "changes": 1654, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,1654 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Synchronous File I/O\n-//!\n-//! This module provides a set of functions and traits for working\n-//! with regular files & directories on a filesystem.\n-//!\n-//! At the top-level of the module are a set of freestanding functions, associated\n-//! with various filesystem operations. They all operate on `Path` objects.\n-//!\n-//! All operations in this module, including those as part of `File` et al block\n-//! the task during execution. In the event of failure, all functions/methods\n-//! will return an `IoResult` type with an `Err` value.\n-//!\n-//! Also included in this module is an implementation block on the `Path` object\n-//! defined in `std::path::Path`. The impl adds useful methods about inspecting\n-//! the metadata of a file. This includes getting the `stat` information,\n-//! reading off particular bits of it, etc.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! # #![feature(old_io, io, old_path)]\n-//! # #![allow(unused_must_use)]\n-//! use std::old_io::fs::PathExtensions;\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n-//!\n-//! let path = Path::new(\"foo.txt\");\n-//!\n-//! // create the file, whether it exists or not\n-//! let mut file = File::create(&path);\n-//! file.write(b\"foobar\");\n-//! # drop(file);\n-//!\n-//! // open the file in read-only mode\n-//! let mut file = File::open(&path);\n-//! file.read_to_end();\n-//!\n-//! println!(\"{}\", path.stat().unwrap().size);\n-//! # drop(file);\n-//! fs::unlink(&path);\n-//! ```\n-\n-use clone::Clone;\n-use old_io::standard_error;\n-use old_io::{FilePermission, Write, Open, FileAccess, FileMode, FileType};\n-use old_io::{IoResult, IoError, InvalidInput};\n-use old_io::{FileStat, SeekStyle, Seek, Writer, Reader};\n-use old_io::{Read, Truncate, ReadWrite, Append};\n-use old_io::UpdateIoError;\n-use old_io;\n-use iter::{Iterator, Extend};\n-use option::Option;\n-use option::Option::{Some, None};\n-use old_path::{Path, GenericPath};\n-use old_path;\n-use result::Result::{Err, Ok};\n-use string::String;\n-use vec::Vec;\n-\n-use sys::fs as fs_imp;\n-use sys_common;\n-\n-/// Unconstrained file access type that exposes read and write operations\n-///\n-/// Can be constructed via `File::open()`, `File::create()`, and\n-/// `File::open_mode()`.\n-///\n-/// # Error\n-///\n-/// This type will return errors as an `IoResult<T>` if operations are\n-/// attempted against it for which its underlying file descriptor was not\n-/// configured at creation time, via the `FileAccess` parameter to\n-/// `File::open_mode()`.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct File {\n-    fd: fs_imp::FileDesc,\n-    path: Path,\n-    last_nread: isize,\n-}\n-\n-impl sys_common::AsInner<fs_imp::FileDesc> for File {\n-    fn as_inner(&self) -> &fs_imp::FileDesc {\n-        &self.fd\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-#[unstable(feature = \"old_io\")]\n-impl File {\n-    /// Open a file at `path` in the mode specified by the `mode` and `access`\n-    /// arguments\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust,should_panic\n-    /// # #![feature(old_io, old_path)]\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let p = Path::new(\"/some/file/path.txt\");\n-    ///\n-    /// let file = match File::open_mode(&p, Open, ReadWrite) {\n-    ///     Ok(f) => f,\n-    ///     Err(e) => panic!(\"file error: {}\", e),\n-    /// };\n-    /// // do some stuff with that file\n-    ///\n-    /// // the file will be closed at the end of this block\n-    /// ```\n-    ///\n-    /// `FileMode` and `FileAccess` provide information about the permissions\n-    /// context in which a given stream is created. More information about them\n-    /// can be found in `std::io`'s docs. If a file is opened with `Write`\n-    /// or `ReadWrite` access, then it will be created if it does not already\n-    /// exist.\n-    ///\n-    /// Note that, with this function, a `File` is returned regardless of the\n-    /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-    /// `File` opened as `Read` will return an error at runtime).\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an error under a number of different\n-    /// circumstances, to include but not limited to:\n-    ///\n-    /// * Opening a file that does not exist with `Read` access.\n-    /// * Attempting to open a file with a `FileAccess` that the user lacks\n-    ///   permissions for\n-    /// * Filesystem-level errors (full disk, etc)\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::OpenOptions\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn open_mode(path: &Path,\n-                     mode: FileMode,\n-                     access: FileAccess) -> IoResult<File> {\n-        fs_imp::open(path, mode, access).and_then(|fd| {\n-            // On *BSD systems, we can open a directory as a file and read from it:\n-            // fd=open(\"/tmp\", O_RDONLY); read(fd, buf, N);\n-            // due to an old tradition before the introduction of opendir(3).\n-            // We explicitly reject it because there are few use cases.\n-            if cfg!(not(any(windows, target_os = \"linux\", target_os = \"android\"))) &&\n-               try!(fd.fstat()).kind == FileType::Directory {\n-                Err(IoError {\n-                    kind: InvalidInput,\n-                    desc: \"is a directory\",\n-                    detail: None\n-                })\n-            } else {\n-                Ok(File {\n-                    path: path.clone(),\n-                    fd: fd,\n-                    last_nread: -1\n-                })\n-            }\n-        }).update_err(\"couldn't open path as file\", |e| {\n-            format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n-                mode_string(mode), access_string(access))\n-        })\n-    }\n-\n-    /// Attempts to open a file in read-only mode. This function is equivalent to\n-    /// `File::open_mode(path, Open, Read)`, and will raise all of the same\n-    /// errors that `File::open_mode` does.\n-    ///\n-    /// For more information, see the `File::open_mode` function.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, old_path)]\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n-    /// ```\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File::open\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn open(path: &Path) -> IoResult<File> {\n-        File::open_mode(path, Open, Read)\n-    }\n-\n-    /// Attempts to create a file in write-only mode. This function is\n-    /// equivalent to `File::open_mode(path, Truncate, Write)`, and will\n-    /// raise all of the same errors that `File::open_mode` does.\n-    ///\n-    /// For more information, see the `File::open_mode` function.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, old_path, io)]\n-    /// # #![allow(unused_must_use)]\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let mut f = File::create(&Path::new(\"foo.txt\"));\n-    /// f.write(b\"This is a sample file\");\n-    /// # drop(f);\n-    /// # ::std::old_io::fs::unlink(&Path::new(\"foo.txt\"));\n-    /// ```\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File::create\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn create(path: &Path) -> IoResult<File> {\n-        File::open_mode(path, Truncate, Write)\n-             .update_desc(\"couldn't create file\")\n-    }\n-\n-    /// Returns the original path that was used to open this file.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn path<'a>(&'a self) -> &'a Path {\n-        &self.path\n-    }\n-\n-    /// Synchronizes all modifications to this file to its permanent storage\n-    /// device. This will flush any internal buffers necessary to perform this\n-    /// operation.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn fsync(&mut self) -> IoResult<()> {\n-        self.fd.fsync()\n-            .update_err(\"couldn't fsync file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-\n-    /// This function is similar to `fsync`, except that it may not synchronize\n-    /// file metadata to the filesystem. This is intended for use cases that\n-    /// must synchronize content, but don't need the metadata on disk. The goal\n-    /// of this method is to reduce disk operations.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn datasync(&mut self) -> IoResult<()> {\n-        self.fd.datasync()\n-            .update_err(\"couldn't datasync file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-\n-    /// Either truncates or extends the underlying file, updating the size of\n-    /// this file to become `size`. This is equivalent to unix's `truncate`\n-    /// function.\n-    ///\n-    /// If the `size` is less than the current file's size, then the file will\n-    /// be shrunk. If it is greater than the current file's size, then the file\n-    /// will be extended to `size` and have all of the intermediate data filled\n-    /// in with 0s.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        self.fd.truncate(size)\n-            .update_err(\"couldn't truncate file\", |e|\n-                format!(\"{}; path={}; size={}\", e, self.path.display(), size))\n-    }\n-\n-    /// Returns true if the stream has reached the end of the file.\n-    ///\n-    /// If true, then this file will no longer continue to return data via\n-    /// `read`.\n-    ///\n-    /// Note that the operating system will not return an `EOF` indicator\n-    /// until you have attempted to read past the end of the file, so if\n-    /// you've read _exactly_ the number of bytes in the file, this will\n-    /// return `false`, not `true`.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn eof(&self) -> bool {\n-        self.last_nread == 0\n-    }\n-\n-    /// Queries information about the underlying file.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn stat(&self) -> IoResult<FileStat> {\n-        self.fd.fstat()\n-            .update_err(\"couldn't fstat file\", |e|\n-                format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-}\n-\n-/// Unlink a file from the underlying filesystem.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/file/path.txt\");\n-/// fs::unlink(&p);\n-/// ```\n-///\n-/// Note that, just because an unlink call was successful, it is not\n-/// guaranteed that a file is immediately deleted (e.g. depending on\n-/// platform, other open file descriptors may prevent immediate removal)\n-///\n-/// # Error\n-///\n-/// This function will return an error if `path` points to a directory, if the\n-/// user lacks permissions to remove the file, or if some other filesystem-level\n-/// error occurs.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_file\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn unlink(path: &Path) -> IoResult<()> {\n-    fs_imp::unlink(path)\n-           .update_err(\"couldn't unlink path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Given a path, query the file system to get information about a file,\n-/// directory, etc. This function will traverse symlinks to query\n-/// information about the destination file.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/file/path.txt\");\n-/// match fs::stat(&p) {\n-///     Ok(stat) => { /* ... */ }\n-///     Err(e) => { /* handle error */ }\n-/// }\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the user lacks the requisite permissions\n-/// to perform a `stat` call on the given `path` or if there is no entry in the\n-/// filesystem at the provided path.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::metadata\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    fs_imp::stat(path)\n-           .update_err(\"couldn't stat path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Perform the same operation as the `stat` function, except that this\n-/// function does not traverse through symlinks. This will return\n-/// information about the symlink file instead of the file that it points\n-/// to.\n-///\n-/// # Error\n-///\n-/// See `stat`\n-#[unstable(feature = \"old_fs\")]\n-pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    fs_imp::lstat(path)\n-           .update_err(\"couldn't lstat path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Rename a file or directory to a new name.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the provided `from` doesn't exist, if\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::rename\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    fs_imp::rename(from, to)\n-           .update_err(\"couldn't rename path\", |e|\n-               format!(\"{}; from={:?}; to={:?}\", e, from.display(), to.display()))\n-}\n-\n-/// Copies the contents of one file to another. This function will also\n-/// copy the permission bits of the original file to the destination file.\n-///\n-/// Note that if `from` and `to` both point to the same file, then the file\n-/// will likely get truncated by this operation.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error in the following situations, but is not\n-/// limited to just these cases:\n-///\n-/// * The `from` path is not a file\n-/// * The `from` file does not exist\n-/// * The current process does not have the permission rights to access\n-///   `from` or write `to`\n-///\n-/// Note that this copy is not atomic in that once the destination is\n-/// ensured to not exist, there is nothing preventing the destination from\n-/// being created and then destroyed by this operation.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::copy\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n-    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n-        result.update_err(\"couldn't copy path\", |e| {\n-            format!(\"{}; from={:?}; to={:?}\", e, from.display(), to.display())\n-        })\n-    }\n-\n-    if !from.is_file() {\n-        return update_err(Err(IoError {\n-            kind: old_io::MismatchedFileTypeForOperation,\n-            desc: \"the source path is not an existing file\",\n-            detail: None\n-        }), from, to)\n-    }\n-\n-    let mut reader = try!(File::open(from));\n-    let mut writer = try!(File::create(to));\n-\n-    try!(update_err(super::util::copy(&mut reader, &mut writer), from, to));\n-\n-    chmod(to, try!(update_err(from.stat(), from, to)).perm)\n-}\n-\n-/// Changes the permission mode bits found on a file or a directory. This\n-/// function takes a mask from the `io` module\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io;\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_FILE);\n-/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_READ | old_io::USER_WRITE);\n-/// fs::chmod(&Path::new(\"dir\"),      old_io::USER_DIR);\n-/// fs::chmod(&Path::new(\"file.exe\"), old_io::USER_EXEC);\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the provided `path` doesn't exist, if\n-/// the process lacks permissions to change the attributes of the file, or if\n-/// some other I/O error is encountered.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_permissions\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n-    fs_imp::chmod(path, mode.bits() as usize)\n-           .update_err(\"couldn't chmod path\", |e|\n-               format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n-}\n-\n-/// Change the user and group owners of a file at the specified path.\n-#[unstable(feature = \"old_fs\")]\n-pub fn chown(path: &Path, uid: isize, gid: isize) -> IoResult<()> {\n-    fs_imp::chown(path, uid, gid)\n-           .update_err(\"couldn't chown path\", |e|\n-               format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n-}\n-\n-/// Creates a new hard link on the filesystem. The `dst` path will be a\n-/// link pointing to the `src` path. Note that systems often require these\n-/// two paths to both be located on the same filesystem.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::hard_link\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    fs_imp::link(src, dst)\n-           .update_err(\"couldn't link path\", |e|\n-               format!(\"{}; src={:?}; dest={:?}\", e, src.display(), dst.display()))\n-}\n-\n-/// Creates a new symbolic link on the filesystem. The `dst` path will be a\n-/// symlink pointing to the `src` path.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::soft_link\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    fs_imp::symlink(src, dst)\n-           .update_err(\"couldn't symlink path\", |e|\n-               format!(\"{}; src={:?}; dest={:?}\", e, src.display(), dst.display()))\n-}\n-\n-/// Reads a symlink, returning the file that the symlink points to.\n-///\n-/// # Error\n-///\n-/// This function will return an error on failure. Failure conditions include\n-/// reading a file that does not exist or reading a file that is not a symlink.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::read_link\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn readlink(path: &Path) -> IoResult<Path> {\n-    fs_imp::readlink(path)\n-           .update_err(\"couldn't resolve symlink for path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Create a new, empty directory at the provided path\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path, old_fs)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io;\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/dir\");\n-/// fs::mkdir(&p, old_io::USER_RWX);\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the user lacks permissions to make a\n-/// new directory at the provided `path`, or if the directory already exists.\n-#[unstable(feature = \"old_fs\")]\n-pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    fs_imp::mkdir(path, mode.bits() as usize)\n-           .update_err(\"couldn't create directory\", |e|\n-               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n-}\n-\n-/// Remove an existing, empty directory\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/dir\");\n-/// fs::rmdir(&p);\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the user lacks permissions to remove\n-/// the directory at the provided `path`, or if the directory isn't empty.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_dir\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn rmdir(path: &Path) -> IoResult<()> {\n-    fs_imp::rmdir(path)\n-           .update_err(\"couldn't remove directory\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Retrieve a vector containing all entries within a provided directory\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::fs::PathExtensions;\n-/// use std::old_io;\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// // one possible implementation of fs::walk_dir only visiting files\n-/// fn visit_dirs<F>(dir: &Path, cb: &mut F) -> old_io::IoResult<()> where\n-///     F: FnMut(&Path),\n-/// {\n-///     if dir.is_dir() {\n-///         let contents = try!(fs::readdir(dir));\n-///         for entry in contents.iter() {\n-///             if entry.is_dir() {\n-///                 try!(visit_dirs(entry, cb));\n-///             } else {\n-///                 (*cb)(entry);\n-///             }\n-///         }\n-///         Ok(())\n-///     } else {\n-///         Err(old_io::standard_error(old_io::InvalidInput))\n-///     }\n-/// }\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the provided `path` doesn't exist, if\n-/// the process lacks permissions to view the contents or if the `path` points\n-/// at a non-directory file\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::read_dir\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n-    fs_imp::readdir(path)\n-           .update_err(\"couldn't read directory\",\n-                       |e| format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Returns an iterator that will recursively walk the directory structure\n-/// rooted at `path`. The path given will not be iterated over, and this will\n-/// perform iteration in some top-down order.  The contents of unreadable\n-/// subdirectories are ignored.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::walk_dir\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n-    Ok(Directories {\n-        stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n-                                             |e| format!(\"{}; path={}\", e, path.display())))\n-    })\n-}\n-\n-/// An iterator that walks over a directory\n-#[derive(Clone)]\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::ReadDir\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct Directories {\n-    stack: Vec<Path>,\n-}\n-\n-impl Iterator for Directories {\n-    type Item = Path;\n-\n-    fn next(&mut self) -> Option<Path> {\n-        match self.stack.pop() {\n-            Some(path) => {\n-                if path.is_dir() {\n-                    match readdir(&path) {\n-                        Ok(dirs) => { self.stack.extend(dirs.into_iter()); }\n-                        Err(..) => {}\n-                    }\n-                }\n-                Some(path)\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n-/// Recursively create a directory and all of its parent components if they\n-/// are missing.\n-///\n-/// # Error\n-///\n-/// See `fs::mkdir`.\n-#[unstable(feature = \"old_fs\")]\n-pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    // tjc: if directory exists but with different permissions,\n-    // should we return false?\n-    if path.is_dir() {\n-        return Ok(())\n-    }\n-\n-    let comps = path.components();\n-    let mut curpath = path.root_path().unwrap_or(Path::new(\".\"));\n-\n-    for c in comps {\n-        curpath.push(c);\n-\n-        let result = mkdir(&curpath, mode)\n-            .update_err(\"couldn't recursively mkdir\",\n-                        |e| format!(\"{}; path={}\", e, path.display()));\n-\n-        match result {\n-            Err(mkdir_err) => {\n-                // already exists ?\n-                if try!(stat(&curpath)).kind != FileType::Directory {\n-                    return Err(mkdir_err);\n-                }\n-            }\n-            Ok(()) => ()\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Removes a directory at this path, after removing all its contents. Use\n-/// carefully!\n-///\n-/// # Error\n-///\n-/// See `file::unlink` and `fs::readdir`\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_dir_all\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n-    let mut rm_stack = Vec::new();\n-    rm_stack.push(path.clone());\n-\n-    fn rmdir_failed(err: &IoError, path: &Path) -> String {\n-        format!(\"rmdir_recursive failed; path={}; cause={}\",\n-                path.display(), err)\n-    }\n-\n-    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> {\n-        err.update_err(\"couldn't recursively rmdir\",\n-                       |e| rmdir_failed(e, path))\n-    }\n-\n-    while !rm_stack.is_empty() {\n-        let children = try!(readdir(rm_stack.last().unwrap())\n-            .update_detail(|e| rmdir_failed(e, path)));\n-\n-        let mut has_child_dir = false;\n-\n-        // delete all regular files in the way and push subdirs\n-        // on the stack\n-        for child in children {\n-            // FIXME(#12795) we should use lstat in all cases\n-            let child_type = match cfg!(windows) {\n-                true => try!(update_err(stat(&child), path)),\n-                false => try!(update_err(lstat(&child), path))\n-            };\n-\n-            if child_type.kind == FileType::Directory {\n-                rm_stack.push(child);\n-                has_child_dir = true;\n-            } else {\n-                // we can carry on safely if the file is already gone\n-                // (eg: deleted by someone else since readdir)\n-                match update_err(unlink(&child), path) {\n-                    Ok(()) => (),\n-                    Err(ref e) if e.kind == old_io::FileNotFound => (),\n-                    Err(e) => return Err(e)\n-                }\n-            }\n-        }\n-\n-        // if no subdir was found, let's pop and delete\n-        if !has_child_dir {\n-            let result = update_err(rmdir(&rm_stack.pop().unwrap()), path);\n-            match result {\n-                Ok(()) => (),\n-                Err(ref e) if e.kind == old_io::FileNotFound => (),\n-                Err(e) => return Err(e)\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Changes the timestamps for a file's last modification and access time.\n-/// The file at the path specified will have its last access time set to\n-/// `atime` and its modification time set to `mtime`. The times specified should\n-/// be in milliseconds.\n-// FIXME(#10301) these arguments should not be u64\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_file_times\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    fs_imp::utime(path, atime, mtime)\n-           .update_err(\"couldn't change_file_times\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n-            result.update_err(\"couldn't read file\",\n-                              |e| format!(\"{}; path={}\",\n-                                          e, file.path.display()))\n-        }\n-\n-        let result = update_err(self.fd.read(buf), self);\n-\n-        match result {\n-            Ok(read) => {\n-                self.last_nread = read as isize;\n-                match read {\n-                    0 => update_err(Err(standard_error(old_io::EndOfFile)), self),\n-                    _ => Ok(read as usize)\n-                }\n-            },\n-            Err(e) => Err(e)\n-        }\n-    }\n-}\n-\n-impl Writer for File {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.fd.write(buf)\n-            .update_err(\"couldn't write to file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-}\n-\n-impl Seek for File {\n-    fn tell(&self) -> IoResult<u64> {\n-        self.fd.tell()\n-            .update_err(\"couldn't retrieve file cursor (`tell`)\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let err = match self.fd.seek(pos, style) {\n-            Ok(_) => {\n-                // successful seek resets EOF indicator\n-                self.last_nread = -1;\n-                Ok(())\n-            }\n-            Err(e) => Err(e),\n-        };\n-        err.update_err(\"couldn't seek in file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-}\n-\n-/// Utility methods for paths.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::PathExt\")]\n-#[unstable(feature = \"old_io\")]\n-pub trait PathExtensions {\n-    /// Get information on the file, directory, etc at this path.\n-    ///\n-    /// Consult the `fs::stat` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`.\n-    fn stat(&self) -> IoResult<FileStat>;\n-\n-    /// Get information on the file, directory, etc at this path, not following\n-    /// symlinks.\n-    ///\n-    /// Consult the `fs::lstat` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with `file::lstat`.\n-    fn lstat(&self) -> IoResult<FileStat>;\n-\n-    /// Boolean value indicator whether the underlying file exists on the local\n-    /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n-    fn exists(&self) -> bool;\n-\n-    /// Whether the underlying implementation (be it a file path, or something\n-    /// else) points at a \"regular file\" on the FS. Will return false for paths\n-    /// to non-existent locations or directories or other non-regular files\n-    /// (named pipes, etc). Follows links when making this determination.\n-    fn is_file(&self) -> bool;\n-\n-    /// Whether the underlying implementation (be it a file path, or something\n-    /// else) is pointing at a directory in the underlying FS. Will return\n-    /// false for paths to non-existent locations or if the item is not a\n-    /// directory (eg files, named pipes, etc). Follows links when making this\n-    /// determination.\n-    fn is_dir(&self) -> bool;\n-}\n-\n-impl PathExtensions for old_path::Path {\n-    fn stat(&self) -> IoResult<FileStat> { stat(self) }\n-    fn lstat(&self) -> IoResult<FileStat> { lstat(self) }\n-    fn exists(&self) -> bool {\n-        self.stat().is_ok()\n-    }\n-    fn is_file(&self) -> bool {\n-        match self.stat() {\n-            Ok(s) => s.kind == FileType::RegularFile,\n-            Err(..) => false\n-        }\n-    }\n-    fn is_dir(&self) -> bool {\n-        match self.stat() {\n-            Ok(s) => s.kind == FileType::Directory,\n-            Err(..) => false\n-        }\n-    }\n-}\n-\n-fn mode_string(mode: FileMode) -> &'static str {\n-    match mode {\n-        super::Open => \"open\",\n-        super::Append => \"append\",\n-        super::Truncate => \"truncate\"\n-    }\n-}\n-\n-fn access_string(access: FileAccess) -> &'static str {\n-    match access {\n-        super::Read => \"read\",\n-        super::Write => \"write\",\n-        super::ReadWrite => \"readwrite\"\n-    }\n-}\n-\n-#[cfg(test)]\n-#[allow(unused_imports)]\n-#[allow(unused_variables)]\n-#[allow(unused_mut)]\n-#[allow(deprecated)] // rand\n-mod test {\n-    use prelude::v1::*;\n-    use old_io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n-    use old_io::{self, Reader, Writer, Seek};\n-    use old_path::{Path, GenericPath};\n-    use str;\n-    use old_io::fs::*;\n-\n-    macro_rules! check { ($e:expr) => (\n-        match $e {\n-            Ok(t) => t,\n-            Err(e) => panic!(\"{} failed with: {:?}\", stringify!($e), e),\n-        }\n-    ) }\n-\n-    macro_rules! error { ($e:expr, $s:expr) => (\n-        match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.to_string().contains($s),\n-                                    format!(\"`{}` did not contain `{}`\", err, $s))\n-        }\n-    ) }\n-\n-    pub struct TempDir(Path);\n-\n-    impl TempDir {\n-        fn join(&self, path: &str) -> Path {\n-            let TempDir(ref p) = *self;\n-            p.join(path)\n-        }\n-\n-        fn path<'a>(&'a self) -> &'a Path {\n-            let TempDir(ref p) = *self;\n-            p\n-        }\n-    }\n-\n-    impl Drop for TempDir {\n-        fn drop(&mut self) {\n-            // Gee, seeing how we're testing the fs module I sure hope that we\n-            // at least implement this correctly!\n-            let TempDir(ref p) = *self;\n-            check!(old_io::fs::rmdir_recursive(p));\n-        }\n-    }\n-\n-    pub fn tmpdir() -> TempDir {\n-        use os;\n-        use rand;\n-        let temp = Path::new(::env::temp_dir().to_str().unwrap());\n-        let ret = temp.join(format!(\"rust-{}\", rand::random::<u32>()));\n-        check!(old_io::fs::mkdir(&ret, old_io::USER_RWX));\n-        TempDir(ret)\n-    }\n-\n-    #[test]\n-    fn file_test_io_smoke_test() {\n-        let message = \"it's alright. have a good time\";\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n-        {\n-            let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(write_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            let mut read_buf = [0; 1028];\n-            let read_str = match check!(read_stream.read(&mut read_buf)) {\n-                0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n-            };\n-            assert_eq!(read_str, message);\n-        }\n-        check!(unlink(filename));\n-    }\n-\n-    #[test]\n-    fn invalid_path_raises() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n-        let result = File::open_mode(filename, Open, Read);\n-\n-        error!(result, \"couldn't open path as file\");\n-        if cfg!(unix) {\n-            error!(result, \"no such file or directory\");\n-        }\n-        error!(result, &format!(\"path={}; mode=open; access=read\", filename.display()));\n-    }\n-\n-    #[test]\n-    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-\n-        let result = unlink(filename);\n-\n-        error!(result, \"couldn't unlink path\");\n-        if cfg!(unix) {\n-            error!(result, \"no such file or directory\");\n-        }\n-        error!(result, &format!(\"path={}\", filename.display()));\n-    }\n-\n-    #[test]\n-    fn file_test_io_non_positional_read() {\n-        let message: &str = \"ten-four\";\n-        let mut read_mem = [0; 8];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            {\n-                let read_buf = &mut read_mem[0..4];\n-                check!(read_stream.read(read_buf));\n-            }\n-            {\n-                let read_buf = &mut read_mem[4..8];\n-                check!(read_stream.read(read_buf));\n-            }\n-        }\n-        check!(unlink(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert_eq!(read_str, message);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_tell_smoke_test() {\n-        let message = \"ten-four\";\n-        let mut read_mem = [0; 4];\n-        let set_cursor = 4 as u64;\n-        let mut tell_pos_pre_read;\n-        let mut tell_pos_post_read;\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            check!(read_stream.seek(set_cursor as i64, SeekSet));\n-            tell_pos_pre_read = check!(read_stream.tell());\n-            check!(read_stream.read(&mut read_mem));\n-            tell_pos_post_read = check!(read_stream.tell());\n-        }\n-        check!(unlink(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert_eq!(read_str, &message[4..8]);\n-        assert_eq!(tell_pos_pre_read, set_cursor);\n-        assert_eq!(tell_pos_post_read, message.len() as u64);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_write() {\n-        let initial_msg =   \"food-is-yummy\";\n-        let overwrite_msg =    \"-the-bar!!\";\n-        let final_msg =     \"foo-the-bar!!\";\n-        let seek_idx = 3;\n-        let mut read_mem = [0; 13];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(initial_msg.as_bytes()));\n-            check!(rw_stream.seek(seek_idx as i64, SeekSet));\n-            check!(rw_stream.write(overwrite_msg.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            check!(read_stream.read(&mut read_mem));\n-        }\n-        check!(unlink(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert!(read_str == final_msg);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_shakedown() {\n-        use str;          // 01234567890123\n-        let initial_msg =   \"qwer-asdf-zxcv\";\n-        let chunk_one: &str = \"qwer\";\n-        let chunk_two: &str = \"asdf\";\n-        let chunk_three: &str = \"zxcv\";\n-        let mut read_mem = [0; 4];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(initial_msg.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-\n-            check!(read_stream.seek(-4, SeekEnd));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_three);\n-\n-            check!(read_stream.seek(-9, SeekCur));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_two);\n-\n-            check!(read_stream.seek(0, SeekSet));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_one);\n-        }\n-        check!(unlink(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_file() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n-        {\n-            let mut fs = check!(File::open_mode(filename, Open, ReadWrite));\n-            let msg = \"hw\";\n-            fs.write(msg.as_bytes()).unwrap();\n-\n-            let fstat_res = check!(fs.stat());\n-            assert_eq!(fstat_res.kind, FileType::RegularFile);\n-        }\n-        let stat_res_fn = check!(stat(filename));\n-        assert_eq!(stat_res_fn.kind, FileType::RegularFile);\n-        let stat_res_meth = check!(filename.stat());\n-        assert_eq!(stat_res_meth.kind, FileType::RegularFile);\n-        check!(unlink(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_dir() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        check!(mkdir(filename, old_io::USER_RWX));\n-        let stat_res_fn = check!(stat(filename));\n-        assert!(stat_res_fn.kind == FileType::Directory);\n-        let stat_res_meth = check!(filename.stat());\n-        assert!(stat_res_meth.kind == FileType::Directory);\n-        check!(rmdir(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        assert!(dir.is_file() == false);\n-        check!(rmdir(dir));\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        let tmpdir = tmpdir();\n-        let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        check!(File::create(file).write(b\"foo\"));\n-        assert!(file.exists());\n-        check!(unlink(file));\n-        assert!(!file.exists());\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"before_and_after_dir\");\n-        assert!(!dir.exists());\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        assert!(dir.exists());\n-        assert!(dir.is_dir());\n-        check!(rmdir(dir));\n-        assert!(!dir.exists());\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_readdir() {\n-        use str;\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"di_readdir\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        let prefix = \"foo\";\n-        for n in 0..3 {\n-            let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = check!(File::create(&f));\n-            let msg_str = format!(\"{}{}\", prefix, n);\n-            let msg = msg_str.as_bytes();\n-            check!(w.write(msg));\n-        }\n-        let files = check!(readdir(dir));\n-        let mut mem = [0; 4];\n-        for f in &files {\n-            {\n-                let n = f.filestem_str();\n-                check!(File::open(f).read(&mut mem));\n-                let read_str = str::from_utf8(&mem).unwrap();\n-                let expected = match n {\n-                    None|Some(\"\") => panic!(\"really shouldn't happen..\"),\n-                    Some(n) => format!(\"{}{}\", prefix, n),\n-                };\n-                assert_eq!(expected, read_str);\n-            }\n-            check!(unlink(f));\n-        }\n-        check!(rmdir(dir));\n-    }\n-\n-    #[test]\n-    fn file_test_walk_dir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"walk_dir\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-\n-        let dir1 = &dir.join(\"01/02/03\");\n-        check!(mkdir_recursive(dir1, old_io::USER_RWX));\n-        check!(File::create(&dir1.join(\"04\")));\n-\n-        let dir2 = &dir.join(\"11/12/13\");\n-        check!(mkdir_recursive(dir2, old_io::USER_RWX));\n-        check!(File::create(&dir2.join(\"14\")));\n-\n-        let mut files = check!(walk_dir(dir));\n-        let mut cur = [0; 2];\n-        for f in files {\n-            let stem = f.filestem_str().unwrap();\n-            let root = stem.as_bytes()[0] - b'0';\n-            let name = stem.as_bytes()[1] - b'0';\n-            assert!(cur[root as usize] < name);\n-            cur[root as usize] = name;\n-        }\n-\n-        check!(rmdir_recursive(dir));\n-    }\n-\n-    #[test]\n-    fn mkdir_path_already_exists_error() {\n-        use old_io::{IoError, PathAlreadyExists};\n-\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"mkdir_error_twice\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        match mkdir(dir, old_io::USER_RWX) {\n-            Err(IoError{kind:PathAlreadyExists,..}) => (),\n-            _ => assert!(false)\n-        };\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = tmpdir.join(\"d1/d2\");\n-        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n-        assert!(dir.is_dir())\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_failure() {\n-        let tmpdir = tmpdir();\n-        let dir = tmpdir.join(\"d1\");\n-        let file = dir.join(\"f1\");\n-\n-        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n-        check!(File::create(&file));\n-\n-        let result = mkdir_recursive(&file, old_io::USER_RWX);\n-\n-        error!(result, \"couldn't recursively mkdir\");\n-        error!(result, \"couldn't create directory\");\n-        error!(result, \"mode=0700\");\n-        error!(result, &format!(\"path={}\", file.display()));\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_slash() {\n-        check!(mkdir_recursive(&Path::new(\"/\"), old_io::USER_RWX));\n-    }\n-\n-    // FIXME(#12795) depends on lstat to work on windows\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn recursive_rmdir() {\n-        let tmpdir = tmpdir();\n-        let d1 = tmpdir.join(\"d1\");\n-        let dt = d1.join(\"t\");\n-        let dtt = dt.join(\"t\");\n-        let d2 = tmpdir.join(\"d2\");\n-        let canary = d2.join(\"do_not_delete\");\n-        check!(mkdir_recursive(&dtt, old_io::USER_RWX));\n-        check!(mkdir_recursive(&d2, old_io::USER_RWX));\n-        check!(File::create(&canary).write(b\"foo\"));\n-        check!(symlink(&d2, &dt.join(\"d2\")));\n-        check!(rmdir_recursive(&d1));\n-\n-        assert!(!d1.is_dir());\n-        assert!(canary.exists());\n-    }\n-\n-    #[test]\n-    fn unicode_path_is_dir() {\n-        assert!(Path::new(\".\").is_dir());\n-        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n-\n-        let tmpdir = tmpdir();\n-\n-        let mut dirpath = tmpdir.path().clone();\n-        dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        check!(mkdir(&dirpath, old_io::USER_RWX));\n-        assert!(dirpath.is_dir());\n-\n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\u{ac00}\\u{4e00}\\u{30fc}\\u{4f60}\\u{597d}.rs\");\n-        check!(File::create(&filepath)); // ignore return; touch only\n-        assert!(!filepath.is_dir());\n-        assert!(filepath.exists());\n-    }\n-\n-    #[test]\n-    fn unicode_path_exists() {\n-        assert!(Path::new(\".\").exists());\n-        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n-\n-        let tmpdir = tmpdir();\n-        let unicode = tmpdir.path();\n-        let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        check!(mkdir(&unicode, old_io::USER_RWX));\n-        assert!(unicode.exists());\n-        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n-    }\n-\n-    #[test]\n-    fn copy_file_does_not_exist() {\n-        let from = Path::new(\"test/nonexistent-bogus-path\");\n-        let to = Path::new(\"test/other-bogus-path\");\n-\n-        error!(copy(&from, &to),\n-            &format!(\"couldn't copy path (the source path is not an \\\n-                     existing file; from={:?}; to={:?})\",\n-                     from.display(), to.display()));\n-\n-        match copy(&from, &to) {\n-            Ok(..) => panic!(),\n-            Err(..) => {\n-                assert!(!from.exists());\n-                assert!(!to.exists());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn copy_file_ok() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input).write(b\"hello\"));\n-        check!(copy(&input, &out));\n-        let contents = check!(File::open(&out).read_to_end());\n-        assert_eq!(contents, b\"hello\");\n-\n-        assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n-    }\n-\n-    #[test]\n-    fn copy_file_dst_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        check!(File::create(&out));\n-        match copy(&out, tmpdir.path()) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn copy_file_dst_exists() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in\");\n-        let output = tmpdir.join(\"out\");\n-\n-        check!(File::create(&input).write(\"foo\".as_bytes()));\n-        check!(File::create(&output).write(\"bar\".as_bytes()));\n-        check!(copy(&input, &output));\n-\n-        assert_eq!(check!(File::open(&output).read_to_end()),\n-                   b\"foo\".to_vec());\n-    }\n-\n-    #[test]\n-    fn copy_file_src_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        match copy(tmpdir.path(), &out) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-        assert!(!out.exists());\n-    }\n-\n-    #[test]\n-    fn copy_file_preserves_perm_bits() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input));\n-        check!(chmod(&input, old_io::USER_READ));\n-        check!(copy(&input, &out));\n-        assert!(!check!(out.stat()).perm.intersects(old_io::USER_WRITE));\n-\n-        check!(chmod(&input, old_io::USER_FILE));\n-        check!(chmod(&out, old_io::USER_FILE));\n-    }\n-\n-    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n-    #[test]\n-    fn symlinks_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input).write(\"foobar\".as_bytes()));\n-        check!(symlink(&input, &out));\n-        if cfg!(not(windows)) {\n-            assert_eq!(check!(lstat(&out)).kind, FileType::Symlink);\n-            assert_eq!(check!(out.lstat()).kind, FileType::Symlink);\n-        }\n-        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n-        assert_eq!(check!(File::open(&out).read_to_end()),\n-                   b\"foobar\".to_vec());\n-    }\n-\n-    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n-    #[test]\n-    fn symlink_noexist() {\n-        let tmpdir = tmpdir();\n-        // symlinks can point to things that don't exist\n-        check!(symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n-        assert!(check!(readlink(&tmpdir.join(\"bar\"))) == tmpdir.join(\"foo\"));\n-    }\n-\n-    #[test]\n-    fn readlink_not_symlink() {\n-        let tmpdir = tmpdir();\n-        match readlink(tmpdir.path()) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn links_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input).write(\"foobar\".as_bytes()));\n-        check!(link(&input, &out));\n-        if cfg!(not(windows)) {\n-            assert_eq!(check!(lstat(&out)).kind, FileType::RegularFile);\n-            assert_eq!(check!(out.lstat()).kind, FileType::RegularFile);\n-            assert_eq!(check!(stat(&out)).unstable.nlink, 2);\n-            assert_eq!(check!(out.stat()).unstable.nlink, 2);\n-        }\n-        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n-        assert_eq!(check!(stat(&out)).size, check!(input.stat()).size);\n-        assert_eq!(check!(File::open(&out).read_to_end()),\n-                   b\"foobar\".to_vec());\n-\n-        // can't link to yourself\n-        match link(&input, &input) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-        // can't link to something that doesn't exist\n-        match link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn chmod_works() {\n-        let tmpdir = tmpdir();\n-        let file = tmpdir.join(\"in.txt\");\n-\n-        check!(File::create(&file));\n-        assert!(check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n-        check!(chmod(&file, old_io::USER_READ));\n-        assert!(!check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n-\n-        match chmod(&tmpdir.join(\"foo\"), old_io::USER_RWX) {\n-            Ok(..) => panic!(\"wanted a panic\"),\n-            Err(..) => {}\n-        }\n-\n-        check!(chmod(&file, old_io::USER_FILE));\n-    }\n-\n-    #[test]\n-    fn sync_doesnt_kill_anything() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n-        check!(file.fsync());\n-        check!(file.datasync());\n-        check!(file.write(b\"foo\"));\n-        check!(file.fsync());\n-        check!(file.datasync());\n-        drop(file);\n-    }\n-\n-    #[test]\n-    fn truncate_works() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n-        check!(file.write(b\"foo\"));\n-        check!(file.fsync());\n-\n-        // Do some simple things with truncation\n-        assert_eq!(check!(file.stat()).size, 3);\n-        check!(file.truncate(10));\n-        assert_eq!(check!(file.stat()).size, 10);\n-        check!(file.write(b\"bar\"));\n-        check!(file.fsync());\n-        assert_eq!(check!(file.stat()).size, 10);\n-        assert_eq!(check!(File::open(&path).read_to_end()),\n-                   b\"foobar\\0\\0\\0\\0\".to_vec());\n-\n-        // Truncate to a smaller length, don't seek, and then write something.\n-        // Ensure that the intermediate zeroes are all filled in (we have `seek`ed\n-        // past the end of the file).\n-        check!(file.truncate(2));\n-        assert_eq!(check!(file.stat()).size, 2);\n-        check!(file.write(b\"wut\"));\n-        check!(file.fsync());\n-        assert_eq!(check!(file.stat()).size, 9);\n-        assert_eq!(check!(File::open(&path).read_to_end()),\n-                   b\"fo\\0\\0\\0\\0wut\".to_vec());\n-        drop(file);\n-    }\n-\n-    #[test]\n-    fn open_flavors() {\n-        let tmpdir = tmpdir();\n-\n-        match File::open_mode(&tmpdir.join(\"a\"), old_io::Open, old_io::Read) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-\n-        // Perform each one twice to make sure that it succeeds the second time\n-        // (where the file exists)\n-        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n-        assert!(tmpdir.join(\"b\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n-\n-        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n-        assert!(tmpdir.join(\"c\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n-\n-        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n-        assert!(tmpdir.join(\"d\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n-\n-        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n-        assert!(tmpdir.join(\"e\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n-\n-        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n-        assert!(tmpdir.join(\"f\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n-\n-        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n-        assert!(tmpdir.join(\"g\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n-\n-        check!(File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()));\n-        check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open, old_io::Read));\n-        {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open,\n-                                               old_io::Read));\n-            match f.write(\"wut\".as_bytes()) {\n-                Ok(..) => panic!(), Err(..) => {}\n-            }\n-        }\n-        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n-                \"write/stat failed\");\n-        {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Append,\n-                                               old_io::Write));\n-            check!(f.write(\"bar\".as_bytes()));\n-        }\n-        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 6,\n-                \"append didn't append\");\n-        {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Truncate,\n-                                               old_io::Write));\n-            check!(f.write(\"bar\".as_bytes()));\n-        }\n-        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n-                \"truncate didn't truncate\");\n-    }\n-\n-    #[test]\n-    fn utime() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"a\");\n-        check!(File::create(&path));\n-        // These numbers have to be bigger than the time in the day to account\n-        // for timezones Windows in particular will fail in certain timezones\n-        // with small enough values\n-        check!(change_file_times(&path, 100000, 200000));\n-        assert_eq!(check!(path.stat()).accessed, 100000);\n-        assert_eq!(check!(path.stat()).modified, 200000);\n-    }\n-\n-    #[test]\n-    fn utime_noexist() {\n-        let tmpdir = tmpdir();\n-\n-        match change_file_times(&tmpdir.join(\"a\"), 100, 200) {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn binary_file() {\n-        use rand::{StdRng, Rng};\n-\n-        let mut bytes = [0; 1024];\n-        StdRng::new().unwrap().fill_bytes(&mut bytes);\n-\n-        let tmpdir = tmpdir();\n-\n-        check!(File::create(&tmpdir.join(\"test\")).write(&bytes));\n-        let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n-        assert!(actual == &bytes[..]);\n-    }\n-\n-    #[test]\n-    fn unlink_readonly() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"file\");\n-        check!(File::create(&path));\n-        check!(chmod(&path, old_io::USER_READ));\n-        check!(unlink(&path));\n-    }\n-}"}, {"sha": "c92e74fbc565e10b3a84aa46c67b86a630d816d8", "filename": "src/libstd/old_io/mem.rs", "status": "removed", "additions": 0, "deletions": 765, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,765 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Readers and Writers for in-memory buffers\n-\n-use cmp::min;\n-use option::Option::None;\n-use result::Result::{Err, Ok};\n-use old_io;\n-use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use slice;\n-use vec::Vec;\n-\n-const BUF_CAPACITY: usize = 128;\n-\n-fn combine(seek: SeekStyle, cur: usize, end: usize, offset: i64) -> IoResult<u64> {\n-    // compute offset as signed and clamp to prevent overflow\n-    let pos = match seek {\n-        old_io::SeekSet => 0,\n-        old_io::SeekEnd => end,\n-        old_io::SeekCur => cur,\n-    } as i64;\n-\n-    if offset + pos < 0 {\n-        Err(IoError {\n-            kind: old_io::InvalidInput,\n-            desc: \"invalid seek to a negative offset\",\n-            detail: None\n-        })\n-    } else {\n-        Ok((offset + pos) as u64)\n-    }\n-}\n-\n-impl Writer for Vec<u8> {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n-/// Writes to an owned, growable byte vector\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let mut w = MemWriter::new();\n-/// w.write(&[0, 1, 2]);\n-///\n-/// assert_eq!(w.into_inner(), [0, 1, 2]);\n-/// ```\n-#[unstable(feature = \"io\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use the Vec<u8> Writer implementation directly\")]\n-#[derive(Clone)]\n-#[allow(deprecated)]\n-pub struct MemWriter {\n-    buf: Vec<u8>,\n-}\n-\n-#[allow(deprecated)]\n-impl MemWriter {\n-    /// Create a new `MemWriter`.\n-    #[inline]\n-    pub fn new() -> MemWriter {\n-        MemWriter::with_capacity(BUF_CAPACITY)\n-    }\n-    /// Create a new `MemWriter`, allocating at least `n` bytes for\n-    /// the internal buffer.\n-    #[inline]\n-    pub fn with_capacity(n: usize) -> MemWriter {\n-        MemWriter::from_vec(Vec::with_capacity(n))\n-    }\n-    /// Create a new `MemWriter` that will append to an existing `Vec`.\n-    #[inline]\n-    pub fn from_vec(buf: Vec<u8>) -> MemWriter {\n-        MemWriter { buf: buf }\n-    }\n-\n-    /// Acquires an immutable reference to the underlying buffer of this\n-    /// `MemWriter`.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n-\n-    /// Unwraps this `MemWriter`, returning the underlying buffer\n-    #[inline]\n-    pub fn into_inner(self) -> Vec<u8> { self.buf }\n-}\n-\n-impl Writer for MemWriter {\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.buf.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n-/// Reads from an owned byte vector\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let mut r = MemReader::new(vec!(0, 1, 2));\n-///\n-/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n-/// ```\n-pub struct MemReader {\n-    buf: Vec<u8>,\n-    pos: usize\n-}\n-\n-impl MemReader {\n-    /// Creates a new `MemReader` which will read the buffer given. The buffer\n-    /// can be re-acquired through `unwrap`\n-    #[inline]\n-    pub fn new(buf: Vec<u8>) -> MemReader {\n-        MemReader {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Tests whether this reader has read all bytes in its buffer.\n-    ///\n-    /// If `true`, then this will no longer return bytes from `read`.\n-    #[inline]\n-    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n-\n-    /// Acquires an immutable reference to the underlying buffer of this\n-    /// `MemReader`.\n-    ///\n-    /// No method is exposed for acquiring a mutable reference to the buffer\n-    /// because it could corrupt the state of this `MemReader`.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n-\n-    /// Unwraps this `MemReader`, returning the underlying buffer\n-    #[inline]\n-    pub fn into_inner(self) -> Vec<u8> { self.buf }\n-}\n-\n-impl Reader for MemReader {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n-\n-        let write_len = min(buf.len(), self.buf.len() - self.pos);\n-        {\n-            let input = &self.buf[self.pos.. self.pos + write_len];\n-            let output = &mut buf[..write_len];\n-            assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(input, output);\n-        }\n-        self.pos += write_len;\n-        assert!(self.pos <= self.buf.len());\n-\n-        return Ok(write_len);\n-    }\n-}\n-\n-impl Seek for MemReader {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as usize;\n-        Ok(())\n-    }\n-}\n-\n-impl Buffer for MemReader {\n-    #[inline]\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        if self.pos < self.buf.len() {\n-            Ok(&self.buf[self.pos..])\n-        } else {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    #[inline]\n-    fn consume(&mut self, amt: usize) { self.pos += amt; }\n-}\n-\n-impl<'a> Reader for &'a [u8] {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.is_empty() { return Err(old_io::standard_error(old_io::EndOfFile)); }\n-\n-        let write_len = min(buf.len(), self.len());\n-        {\n-            let input = &self[..write_len];\n-            let output = &mut buf[.. write_len];\n-            slice::bytes::copy_memory(input, output);\n-        }\n-\n-        *self = &self[write_len..];\n-\n-        Ok(write_len)\n-    }\n-}\n-\n-impl<'a> Buffer for &'a [u8] {\n-    #[inline]\n-    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n-        if self.is_empty() {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(*self)\n-        }\n-    }\n-\n-    #[inline]\n-    fn consume(&mut self, amt: usize) {\n-        *self = &self[amt..];\n-    }\n-}\n-\n-\n-/// Writes to a fixed-size byte slice\n-///\n-/// If a write will not fit in the buffer, it returns an error and does not\n-/// write any data.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let mut buf = [0; 4];\n-/// {\n-///     let mut w = BufWriter::new(&mut buf);\n-///     w.write(&[0, 1, 2]);\n-/// }\n-/// assert!(buf == [0, 1, 2, 0]);\n-/// ```\n-pub struct BufWriter<'a> {\n-    buf: &'a mut [u8],\n-    pos: usize\n-}\n-\n-impl<'a> BufWriter<'a> {\n-    /// Creates a new `BufWriter` which will wrap the specified buffer. The\n-    /// writer initially starts at position 0.\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> BufWriter<'a> {\n-        BufWriter {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-}\n-\n-impl<'a> Writer for BufWriter<'a> {\n-    #[inline]\n-    fn write_all(&mut self, src: &[u8]) -> IoResult<()> {\n-        let dst = &mut self.buf[self.pos..];\n-        let dst_len = dst.len();\n-\n-        if dst_len == 0 {\n-            return Err(old_io::standard_error(old_io::EndOfFile));\n-        }\n-\n-        let src_len = src.len();\n-\n-        if dst_len >= src_len {\n-            slice::bytes::copy_memory(src, dst);\n-\n-            self.pos += src_len;\n-\n-            Ok(())\n-        } else {\n-            slice::bytes::copy_memory(&src[..dst_len], dst);\n-\n-            self.pos += dst_len;\n-\n-            Err(old_io::standard_error(old_io::ShortWrite(dst_len)))\n-        }\n-    }\n-}\n-\n-impl<'a> Seek for BufWriter<'a> {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = min(new as usize, self.buf.len());\n-        Ok(())\n-    }\n-}\n-\n-/// Reads from a fixed-size byte slice\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let buf = [0, 1, 2, 3];\n-/// let mut r = BufReader::new(&buf);\n-///\n-/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n-/// ```\n-pub struct BufReader<'a> {\n-    buf: &'a [u8],\n-    pos: usize\n-}\n-\n-impl<'a> BufReader<'a> {\n-    /// Creates a new buffered reader which will read the specified buffer\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> BufReader<'a> {\n-        BufReader {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Tests whether this reader has read all bytes in its buffer.\n-    ///\n-    /// If `true`, then this will no longer return bytes from `read`.\n-    #[inline]\n-    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n-}\n-\n-impl<'a> Reader for BufReader<'a> {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n-\n-        let write_len = min(buf.len(), self.buf.len() - self.pos);\n-        {\n-            let input = &self.buf[self.pos.. self.pos + write_len];\n-            let output = &mut buf[..write_len];\n-            assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(input, output);\n-        }\n-        self.pos += write_len;\n-        assert!(self.pos <= self.buf.len());\n-\n-        return Ok(write_len);\n-     }\n-}\n-\n-impl<'a> Seek for BufReader<'a> {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as usize;\n-        Ok(())\n-    }\n-}\n-\n-impl<'a> Buffer for BufReader<'a> {\n-    #[inline]\n-    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n-        if self.pos < self.buf.len() {\n-            Ok(&self.buf[self.pos..])\n-        } else {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    #[inline]\n-    fn consume(&mut self, amt: usize) { self.pos += amt; }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    extern crate test as test_crate;\n-    use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek, Buffer};\n-    use prelude::v1::{Ok, Err, Vec};\n-    use prelude::v1::Iterator;\n-    use old_io;\n-    use iter::repeat;\n-    use self::test_crate::Bencher;\n-    use super::*;\n-\n-    #[test]\n-    fn test_vec_writer() {\n-        let mut writer = Vec::new();\n-        writer.write(&[0]).unwrap();\n-        writer.write(&[1, 2, 3]).unwrap();\n-        writer.write(&[4, 5, 6, 7]).unwrap();\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer, b);\n-    }\n-\n-    #[test]\n-    fn test_mem_writer() {\n-        let mut writer = MemWriter::new();\n-        writer.write(&[0]).unwrap();\n-        writer.write(&[1, 2, 3]).unwrap();\n-        writer.write(&[4, 5, 6, 7]).unwrap();\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer.get_ref(), b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer() {\n-        let mut buf = [0 as u8; 9];\n-        {\n-            let mut writer = BufWriter::new(&mut buf);\n-            assert_eq!(writer.tell(), Ok(0));\n-            writer.write(&[0]).unwrap();\n-            assert_eq!(writer.tell(), Ok(1));\n-            writer.write(&[1, 2, 3]).unwrap();\n-            writer.write(&[4, 5, 6, 7]).unwrap();\n-            assert_eq!(writer.tell(), Ok(8));\n-            writer.write(&[]).unwrap();\n-            assert_eq!(writer.tell(), Ok(8));\n-\n-            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, old_io::ShortWrite(1));\n-            assert_eq!(writer.write(&[10]).err().unwrap().kind, old_io::EndOfFile);\n-        }\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_seek() {\n-        let mut buf = [0 as u8; 8];\n-        {\n-            let mut writer = BufWriter::new(&mut buf);\n-            assert_eq!(writer.tell(), Ok(0));\n-            writer.write(&[1]).unwrap();\n-            assert_eq!(writer.tell(), Ok(1));\n-\n-            writer.seek(2, SeekSet).unwrap();\n-            assert_eq!(writer.tell(), Ok(2));\n-            writer.write(&[2]).unwrap();\n-            assert_eq!(writer.tell(), Ok(3));\n-\n-            writer.seek(-2, SeekCur).unwrap();\n-            assert_eq!(writer.tell(), Ok(1));\n-            writer.write(&[3]).unwrap();\n-            assert_eq!(writer.tell(), Ok(2));\n-\n-            writer.seek(-1, SeekEnd).unwrap();\n-            assert_eq!(writer.tell(), Ok(7));\n-            writer.write(&[4]).unwrap();\n-            assert_eq!(writer.tell(), Ok(8));\n-\n-        }\n-        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_error() {\n-        let mut buf = [0 as u8; 2];\n-        let mut writer = BufWriter::new(&mut buf);\n-        writer.write(&[0]).unwrap();\n-\n-        match writer.write(&[0, 0]) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::ShortWrite(1)),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mem_reader() {\n-        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.tell(), Ok(0));\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.tell(), Ok(1));\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n-        assert_eq!(reader.tell(), Ok(5));\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert!(reader.read(&mut buf).is_err());\n-        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n-        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_slice_reader() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = &mut &*in_buf;\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.len(), 7);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n-        assert_eq!(reader.len(), 3);\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert!(reader.read(&mut buf).is_err());\n-        let mut reader = &mut &*in_buf;\n-        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_buf_reader() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = BufReader::new(&in_buf);\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.tell(), Ok(0));\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.tell(), Ok(1));\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n-        assert_eq!(reader.tell(), Ok(5));\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert!(reader.read(&mut buf).is_err());\n-        let mut reader = BufReader::new(&in_buf);\n-        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_read_char() {\n-        let b = b\"Vi\\xE1\\xBB\\x87t\";\n-        let mut r = BufReader::new(b);\n-        assert_eq!(r.read_char(), Ok('V'));\n-        assert_eq!(r.read_char(), Ok('i'));\n-        assert_eq!(r.read_char(), Ok('\u1ec7'));\n-        assert_eq!(r.read_char(), Ok('t'));\n-        assert!(r.read_char().is_err());\n-    }\n-\n-    #[test]\n-    fn test_read_bad_char() {\n-        let b = b\"\\x80\";\n-        let mut r = BufReader::new(b);\n-        assert!(r.read_char().is_err());\n-    }\n-\n-    #[test]\n-    fn test_write_strings() {\n-        let mut writer = MemWriter::new();\n-        writer.write_str(\"testing\").unwrap();\n-        writer.write_line(\"testing\").unwrap();\n-        writer.write_str(\"testing\").unwrap();\n-        let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_string().unwrap(), \"testingtesting\\ntesting\");\n-    }\n-\n-    #[test]\n-    fn test_write_char() {\n-        let mut writer = MemWriter::new();\n-        writer.write_char('a').unwrap();\n-        writer.write_char('\\n').unwrap();\n-        writer.write_char('\u1ec7').unwrap();\n-        let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_string().unwrap(), \"a\\n\u1ec7\");\n-    }\n-\n-    #[test]\n-    fn test_read_whole_string_bad() {\n-        let buf = [0xff];\n-        let mut r = BufReader::new(&buf);\n-        match r.read_to_string() {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn seek_past_end() {\n-        let buf = [0xff];\n-        let mut r = BufReader::new(&buf);\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.read(&mut []).is_err());\n-\n-        let mut r = MemReader::new(vec!(10));\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.read(&mut []).is_err());\n-\n-        let mut buf = [0];\n-        let mut r = BufWriter::new(&mut buf);\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.write(&[3]).is_err());\n-    }\n-\n-    #[test]\n-    fn seek_before_0() {\n-        let buf = [0xff];\n-        let mut r = BufReader::new(&buf);\n-        assert!(r.seek(-1, SeekSet).is_err());\n-\n-        let mut r = MemReader::new(vec!(10));\n-        assert!(r.seek(-1, SeekSet).is_err());\n-\n-        let mut buf = [0];\n-        let mut r = BufWriter::new(&mut buf);\n-        assert!(r.seek(-1, SeekSet).is_err());\n-    }\n-\n-    #[test]\n-    fn io_read_at_least() {\n-        let mut r = MemReader::new(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n-        let mut buf = [0; 3];\n-        assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n-        let b: &[_] = &[1, 2, 3];\n-        assert_eq!(buf, b);\n-        assert!(r.read_at_least(0, &mut buf[..0]).is_ok());\n-        assert_eq!(buf, b);\n-        assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n-        let b: &[_] = &[4, 5, 6];\n-        assert_eq!(buf, b);\n-        assert!(r.read_at_least(buf.len(), &mut buf).is_err());\n-        let b: &[_] = &[7, 8, 6];\n-        assert_eq!(buf, b);\n-    }\n-\n-    fn do_bench_mem_writer(b: &mut Bencher, times: usize, len: usize) {\n-        let src: Vec<u8> = repeat(5).take(len).collect();\n-\n-        b.bytes = (times * len) as u64;\n-        b.iter(|| {\n-            let mut wr = MemWriter::new();\n-            for _ in 0..times {\n-                wr.write(&src).unwrap();\n-            }\n-\n-            let v = wr.into_inner();\n-            assert_eq!(v.len(), times * len);\n-            assert!(v.iter().all(|x| *x == 5));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_0000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_0010(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_0100(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_1000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_0000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_0010(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_0100(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_1000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_reader(b: &mut Bencher) {\n-        b.iter(|| {\n-            let buf = [5 as u8; 100].to_vec();\n-            {\n-                let mut rdr = MemReader::new(buf);\n-                for _i in 0..10 {\n-                    let mut buf = [0 as u8; 10];\n-                    rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf, [5; 10]);\n-                }\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buf_writer(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut buf = [0 as u8; 100];\n-            {\n-                let mut wr = BufWriter::new(&mut buf);\n-                for _i in 0..10 {\n-                    wr.write(&[5; 10]).unwrap();\n-                }\n-            }\n-            assert_eq!(&buf[..], &[5; 100][..]);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buf_reader(b: &mut Bencher) {\n-        b.iter(|| {\n-            let buf = [5 as u8; 100];\n-            {\n-                let mut rdr = BufReader::new(&buf);\n-                for _i in 0..10 {\n-                    let mut buf = [0 as u8; 10];\n-                    rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf, [5; 10]);\n-                }\n-            }\n-        });\n-    }\n-}"}, {"sha": "f62b1a836fd10201a4452780afe93d0427245efc", "filename": "src/libstd/old_io/mod.rs", "status": "removed", "additions": 0, "deletions": 1984, "changes": 1984, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,1984 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-// FIXME: cover these topics:\n-//        path, reader, writer, stream, raii (close not needed),\n-//        stdio, print!, println!, file access, process spawning,\n-//        error handling\n-\n-\n-//! I/O, including files, networking, timers, and processes\n-//!\n-//! > **Warning**: This module is currently called `old_io` for a reason! The\n-//! > module is currently being redesigned in a number of RFCs. For more details\n-//! > follow the RFC repository in connection with [RFC 517][base] or follow\n-//! > some of these sub-RFCs\n-//! >\n-//! > * [String handling][osstr]\n-//! > * [Core I/O support][core]\n-//! > * [Deadlines][deadlines]\n-//! > * [std::env][env]\n-//! > * [std::process][process]\n-//!\n-//! [base]: https://github.com/rust-lang/rfcs/blob/master/text/0517-io-os-reform.md\n-//! [osstr]: https://github.com/rust-lang/rfcs/pull/575\n-//! [core]: https://github.com/rust-lang/rfcs/pull/576\n-//! [deadlines]: https://github.com/rust-lang/rfcs/pull/577\n-//! [env]: https://github.com/rust-lang/rfcs/pull/578\n-//! [process]: https://github.com/rust-lang/rfcs/pull/579\n-//!\n-//! `std::io` provides Rust's basic I/O types,\n-//! for reading and writing to files, TCP, UDP,\n-//! and other types of sockets and pipes,\n-//! manipulating the file system, spawning processes.\n-//!\n-//! # Examples\n-//!\n-//! Some examples of obvious things you might want to do\n-//!\n-//! * Read lines from stdin\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io)]\n-//!     use std::old_io as io;\n-//!     use std::old_io::*;\n-//!\n-//!     let mut stdin = io::stdin();\n-//!     for line in stdin.lock().lines() {\n-//!         print!(\"{}\", line.unwrap());\n-//!     }\n-//!     ```\n-//!\n-//! * Read a complete file\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io, old_path)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n-//!     ```\n-//!\n-//! * Write a line to a file\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io, old_path)]\n-//!     # #![allow(unused_must_use)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let mut file = File::create(&Path::new(\"message.txt\"));\n-//!     file.write_all(b\"hello, file!\\n\");\n-//!     # drop(file);\n-//!     # ::std::old_io::fs::unlink(&Path::new(\"message.txt\"));\n-//!     ```\n-//!\n-//! * Iterate over the lines of a file\n-//!\n-//!     ```rust,no_run\n-//!     # #![feature(old_io, old_path)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let path = Path::new(\"message.txt\");\n-//!     let mut file = BufferedReader::new(File::open(&path));\n-//!     for line in file.lines() {\n-//!         print!(\"{}\", line.unwrap());\n-//!     }\n-//!     ```\n-//!\n-//! * Pull the lines of a file into a vector of strings\n-//!\n-//!     ```rust,no_run\n-//!     # #![feature(old_io, old_path)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let path = Path::new(\"message.txt\");\n-//!     let mut file = BufferedReader::new(File::open(&path));\n-//!     let lines: Vec<String> = file.lines().map(|x| x.unwrap()).collect();\n-//!     ```\n-//!\n-//! * Make a simple TCP client connection and request\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io)]\n-//!     # #![allow(unused_must_use)]\n-//!     use std::old_io::*;\n-//!\n-//!     # // connection doesn't fail if a server is running on 8080\n-//!     # // locally, we still want to be type checking this code, so lets\n-//!     # // just stop it running (#11576)\n-//!     # if false {\n-//!     let mut socket = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n-//!     socket.write_all(b\"GET / HTTP/1.0\\n\\n\");\n-//!     let response = socket.read_to_end();\n-//!     # }\n-//!     ```\n-//!\n-//! * Make a simple TCP server\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io)]\n-//!     # fn main() { }\n-//!     # fn foo() {\n-//!     # #![allow(dead_code)]\n-//!     use std::old_io::*;\n-//!     use std::thread;\n-//!\n-//!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n-//!\n-//!     // bind the listener to the specified address\n-//!     let mut acceptor = listener.listen();\n-//!\n-//!     fn handle_client(mut stream: TcpStream) {\n-//!         // ...\n-//!     # &mut stream; // silence unused mutability/variable warning\n-//!     }\n-//!     // accept connections and process them, spawning a new tasks for each one\n-//!     for stream in acceptor.incoming() {\n-//!         match stream {\n-//!             Err(e) => { /* connection failed */ }\n-//!             Ok(stream) => {\n-//!                 thread::spawn(move|| {\n-//!                     // connection succeeded\n-//!                     handle_client(stream)\n-//!                 });\n-//!             }\n-//!         }\n-//!     }\n-//!\n-//!     // close the socket server\n-//!     drop(acceptor);\n-//!     # }\n-//!     ```\n-//!\n-//!\n-//! # Error Handling\n-//!\n-//! I/O is an area where nearly every operation can result in unexpected\n-//! errors. Errors should be painfully visible when they happen, and handling them\n-//! should be easy to work with. It should be convenient to handle specific I/O\n-//! errors, and it should also be convenient to not deal with I/O errors.\n-//!\n-//! Rust's I/O employs a combination of techniques to reduce boilerplate\n-//! while still providing feedback about errors. The basic strategy:\n-//!\n-//! * All I/O operations return `IoResult<T>` which is equivalent to\n-//!   `Result<T, IoError>`. The `Result` type is defined in the `std::result`\n-//!   module.\n-//! * If the `Result` type goes unused, then the compiler will by default emit a\n-//!   warning about the unused result. This is because `Result` has the\n-//!   `#[must_use]` attribute.\n-//! * Common traits are implemented for `IoResult`, e.g.\n-//!   `impl<R: Reader> Reader for IoResult<R>`, so that error values do not have\n-//!   to be 'unwrapped' before use.\n-//!\n-//! These features combine in the API to allow for expressions like\n-//! `File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\")`\n-//! without having to worry about whether \"diary.txt\" exists or whether\n-//! the write succeeds. As written, if either `new` or `write_line`\n-//! encounters an error then the result of the entire expression will\n-//! be an error.\n-//!\n-//! If you wanted to handle the error though you might write:\n-//!\n-//! ```rust\n-//! # #![feature(old_io, old_path)]\n-//! # #![allow(unused_must_use)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n-//!\n-//! match File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\") {\n-//!     Ok(()) => (), // succeeded\n-//!     Err(e) => println!(\"failed to write to my diary: {}\", e),\n-//! }\n-//!\n-//! # ::std::old_io::fs::unlink(&Path::new(\"diary.txt\"));\n-//! ```\n-//!\n-//! So what actually happens if `create` encounters an error?\n-//! It's important to know that what `new` returns is not a `File`\n-//! but an `IoResult<File>`.  If the file does not open, then `new` will simply\n-//! return `Err(..)`. Because there is an implementation of `Writer` (the trait\n-//! required ultimately required for types to implement `write_line`) there is no\n-//! need to inspect or unwrap the `IoResult<File>` and we simply call `write_line`\n-//! on it. If `new` returned an `Err(..)` then the followup call to `write_line`\n-//! will also return an error.\n-//!\n-//! ## `try!`\n-//!\n-//! Explicit pattern matching on `IoResult`s can get quite verbose, especially\n-//! when performing many I/O operations. Some examples (like those above) are\n-//! alleviated with extra methods implemented on `IoResult`, but others have more\n-//! complex interdependencies among each I/O operation.\n-//!\n-//! The `try!` macro from `std::macros` is provided as a method of early-return\n-//! inside `Result`-returning functions. It expands to an early-return on `Err`\n-//! and otherwise unwraps the contained `Ok` value.\n-//!\n-//! If you wanted to read several `u32`s from a file and return their product:\n-//!\n-//! ```rust\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n-//!\n-//! fn file_product(p: &Path) -> IoResult<u32> {\n-//!     let mut f = File::open(p);\n-//!     let x1 = try!(f.read_le_u32());\n-//!     let x2 = try!(f.read_le_u32());\n-//!\n-//!     Ok(x1 * x2)\n-//! }\n-//!\n-//! match file_product(&Path::new(\"numbers.bin\")) {\n-//!     Ok(x) => println!(\"{}\", x),\n-//!     Err(e) => println!(\"Failed to read numbers!\")\n-//! }\n-//! ```\n-//!\n-//! With `try!` in `file_product`, each `read_le_u32` need not be directly\n-//! concerned with error handling; instead its caller is responsible for\n-//! responding to errors that may occur while attempting to read the numbers.\n-\n-#![unstable(feature = \"old_io\")]\n-#![deny(unused_must_use)]\n-#![allow(deprecated)] // seriously this is all deprecated\n-#![allow(unused_imports)]\n-#![deprecated(since = \"1.0.0\",\n-              reasons = \"APIs have been replaced with new I/O modules such as \\\n-                         std::{io, fs, net, process}\")]\n-\n-pub use self::SeekStyle::*;\n-pub use self::FileMode::*;\n-pub use self::FileAccess::*;\n-pub use self::IoErrorKind::*;\n-\n-use default::Default;\n-use error::Error;\n-use fmt;\n-use isize;\n-use iter::Iterator;\n-use marker::{PhantomFn, Sized};\n-use mem::transmute;\n-use ops::FnOnce;\n-use option::Option;\n-use option::Option::{Some, None};\n-use sys::os;\n-use boxed::Box;\n-use result::Result;\n-use result::Result::{Ok, Err};\n-use sys;\n-use str;\n-use string::String;\n-use usize;\n-use unicode;\n-use vec::Vec;\n-\n-// Reexports\n-pub use self::stdio::stdin;\n-pub use self::stdio::stdout;\n-pub use self::stdio::stderr;\n-pub use self::stdio::print;\n-pub use self::stdio::println;\n-\n-pub use self::fs::File;\n-pub use self::timer::Timer;\n-pub use self::net::ip::IpAddr;\n-pub use self::net::tcp::TcpListener;\n-pub use self::net::tcp::TcpStream;\n-pub use self::pipe::PipeStream;\n-pub use self::process::{Process, Command};\n-pub use self::tempfile::TempDir;\n-\n-pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n-pub use self::buffered::{BufferedReader, BufferedWriter, BufferedStream,\n-                         LineBufferedWriter};\n-pub use self::comm_adapters::{ChanReader, ChanWriter};\n-\n-mod buffered;\n-mod comm_adapters;\n-mod mem;\n-mod result;\n-mod tempfile;\n-pub mod extensions;\n-pub mod fs;\n-pub mod net;\n-pub mod pipe;\n-pub mod process;\n-pub mod stdio;\n-pub mod timer;\n-pub mod util;\n-\n-#[macro_use]\n-pub mod test;\n-\n-/// The default buffer size for various I/O operations\n-// libuv recommends 64k buffers to maximize throughput\n-// https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n-const DEFAULT_BUF_SIZE: usize = 1024 * 64;\n-\n-/// A convenient typedef of the return value of any I/O action.\n-pub type IoResult<T> = Result<T, IoError>;\n-\n-/// The type passed to I/O condition handlers to indicate error\n-///\n-/// # FIXME\n-///\n-/// Is something like this sufficient? It's kind of archaic\n-#[derive(PartialEq, Eq, Clone, Debug)]\n-pub struct IoError {\n-    /// An enumeration which can be matched against for determining the flavor\n-    /// of error.\n-    pub kind: IoErrorKind,\n-    /// A human-readable description about the error\n-    pub desc: &'static str,\n-    /// Detailed information about this error, not always available\n-    pub detail: Option<String>\n-}\n-\n-impl IoError {\n-    /// Convert an `errno` value into an `IoError`.\n-    ///\n-    /// If `detail` is `true`, the `detail` field of the `IoError`\n-    /// struct is filled with an allocated string describing the error\n-    /// in more detail, retrieved from the operating system.\n-    pub fn from_errno(errno: i32, detail: bool) -> IoError {\n-        let mut err = sys::decode_error(errno as i32);\n-        if detail && err.kind == OtherIoError {\n-            err.detail = Some(os::error_string(errno).to_lowercase());\n-        }\n-        err\n-    }\n-\n-    /// Retrieve the last error to occur as a (detailed) IoError.\n-    ///\n-    /// This uses the OS `errno`, and so there should not be any task\n-    /// descheduling or migration (other than that performed by the\n-    /// operating system) between the call(s) for which errors are\n-    /// being checked and the call of this function.\n-    pub fn last_error() -> IoError {\n-        IoError::from_errno(os::errno(), true)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for IoError {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail) } =>\n-                write!(fmt, \"{}\", detail),\n-            IoError { detail: None, desc, .. } =>\n-                write!(fmt, \"{}\", desc),\n-            IoError { detail: Some(ref detail), desc, .. } =>\n-                write!(fmt, \"{} ({})\", desc, detail)\n-        }\n-    }\n-}\n-\n-impl Error for IoError {\n-    fn description(&self) -> &str { self.desc }\n-}\n-\n-/// A list specifying general categories of I/O error.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum IoErrorKind {\n-    /// Any I/O error not part of this list.\n-    OtherIoError,\n-    /// The operation could not complete because end of file was reached.\n-    EndOfFile,\n-    /// The file was not found.\n-    FileNotFound,\n-    /// The file permissions disallowed access to this file.\n-    PermissionDenied,\n-    /// A network connection failed for some reason not specified in this list.\n-    ConnectionFailed,\n-    /// The network operation failed because the network connection was closed.\n-    Closed,\n-    /// The connection was refused by the remote server.\n-    ConnectionRefused,\n-    /// The connection was reset by the remote server.\n-    ConnectionReset,\n-    /// The connection was aborted (terminated) by the remote server.\n-    ConnectionAborted,\n-    /// The network operation failed because it was not connected yet.\n-    NotConnected,\n-    /// The operation failed because a pipe was closed.\n-    BrokenPipe,\n-    /// A file already existed with that name.\n-    PathAlreadyExists,\n-    /// No file exists at that location.\n-    PathDoesntExist,\n-    /// The path did not specify the type of file that this operation required. For example,\n-    /// attempting to copy a directory with the `fs::copy()` operation will fail with this error.\n-    MismatchedFileTypeForOperation,\n-    /// The operation temporarily failed (for example, because a signal was received), and retrying\n-    /// may succeed.\n-    ResourceUnavailable,\n-    /// No I/O functionality is available for this task.\n-    IoUnavailable,\n-    /// A parameter was incorrect in a way that caused an I/O error not part of this list.\n-    InvalidInput,\n-    /// The I/O operation's timeout expired, causing it to be canceled.\n-    TimedOut,\n-    /// This write operation failed to write all of its data.\n-    ///\n-    /// Normally the write() method on a Writer guarantees that all of its data\n-    /// has been written, but some operations may be terminated after only\n-    /// partially writing some data. An example of this is a timed out write\n-    /// which successfully wrote a known number of bytes, but bailed out after\n-    /// doing so.\n-    ///\n-    /// The payload contained as part of this variant is the number of bytes\n-    /// which are known to have been successfully written.\n-    ShortWrite(usize),\n-    /// The Reader returned 0 bytes from `read()` too many times.\n-    NoProgress,\n-}\n-\n-/// A trait that lets you add a `detail` to an IoError easily\n-trait UpdateIoError {\n-    /// Returns an IoError with updated description and detail\n-    fn update_err<D>(self, desc: &'static str, detail: D) -> Self where\n-        D: FnOnce(&IoError) -> String;\n-\n-    /// Returns an IoError with updated detail\n-    fn update_detail<D>(self, detail: D) -> Self where\n-        D: FnOnce(&IoError) -> String;\n-\n-    /// Returns an IoError with update description\n-    fn update_desc(self, desc: &'static str) -> Self;\n-}\n-\n-impl<T> UpdateIoError for IoResult<T> {\n-    fn update_err<D>(self, desc: &'static str, detail: D) -> IoResult<T> where\n-        D: FnOnce(&IoError) -> String,\n-    {\n-        self.map_err(move |mut e| {\n-            let detail = detail(&e);\n-            e.desc = desc;\n-            e.detail = Some(detail);\n-            e\n-        })\n-    }\n-\n-    fn update_detail<D>(self, detail: D) -> IoResult<T> where\n-        D: FnOnce(&IoError) -> String,\n-    {\n-        self.map_err(move |mut e| { e.detail = Some(detail(&e)); e })\n-    }\n-\n-    fn update_desc(self, desc: &'static str) -> IoResult<T> {\n-        self.map_err(|mut e| { e.desc = desc; e })\n-    }\n-}\n-\n-static NO_PROGRESS_LIMIT: usize = 1000;\n-\n-/// A trait for objects which are byte-oriented streams. Readers are defined by\n-/// one method, `read`. This function will block until data is available,\n-/// filling in the provided buffer with any data read.\n-///\n-/// Readers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Reader` trait.\n-pub trait Reader {\n-\n-    // Only method which need to get implemented for this trait\n-\n-    /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read. The number of bytes read may\n-    /// be less than the number requested, even 0. Returns `Err` on EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs during this I/O operation, then it is returned as\n-    /// `Err(IoError)`. Note that end-of-file is considered an error, and can be\n-    /// inspected for in the error's `kind` field. Also note that reading 0\n-    /// bytes is not considered an error in all circumstances\n-    ///\n-    /// # Implementation Note\n-    ///\n-    /// When implementing this method on a new Reader, you are strongly encouraged\n-    /// not to return 0 if you can avoid it.\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize>;\n-\n-    // Convenient helper methods based on the above methods\n-\n-    /// Reads at least `min` bytes and places them in `buf`.\n-    /// Returns the number of bytes read.\n-    ///\n-    /// This will continue to call `read` until at least `min` bytes have been\n-    /// read. If `read` returns 0 too many times, `NoProgress` will be\n-    /// returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs at any point, that error is returned, and no further\n-    /// bytes are read.\n-    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n-        if min > buf.len() {\n-            return Err(IoError {\n-                detail: Some(String::from_str(\"the buffer is too short\")),\n-                ..standard_error(InvalidInput)\n-            });\n-        }\n-        let mut read = 0;\n-        while read < min {\n-            let mut zeroes = 0;\n-            loop {\n-                match self.read(&mut buf[read..]) {\n-                    Ok(0) => {\n-                        zeroes += 1;\n-                        if zeroes >= NO_PROGRESS_LIMIT {\n-                            return Err(standard_error(NoProgress));\n-                        }\n-                    }\n-                    Ok(n) => {\n-                        read += n;\n-                        break;\n-                    }\n-                    err@Err(_) => return err\n-                }\n-            }\n-        }\n-        Ok(read)\n-    }\n-\n-    /// Reads a single byte. Returns `Err` on EOF.\n-    fn read_byte(&mut self) -> IoResult<u8> {\n-        let mut buf = [0];\n-        try!(self.read_at_least(1, &mut buf));\n-        Ok(buf[0])\n-    }\n-\n-    /// Reads up to `len` bytes and appends them to a vector.\n-    /// Returns the number of bytes read. The number of bytes read may be\n-    /// less than the number requested, even 0. Returns Err on EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs during this I/O operation, then it is returned\n-    /// as `Err(IoError)`. See `read()` for more details.\n-    fn push(&mut self, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n-        let start_len = buf.len();\n-        buf.reserve(len);\n-\n-        let n = {\n-            let s = unsafe { slice_vec_capacity(buf, start_len, start_len + len) };\n-            try!(self.read(s))\n-        };\n-        unsafe { buf.set_len(start_len + n) };\n-        Ok(n)\n-    }\n-\n-    /// Reads at least `min` bytes, but no more than `len`, and appends them to\n-    /// a vector.\n-    /// Returns the number of bytes read.\n-    ///\n-    /// This will continue to call `read` until at least `min` bytes have been\n-    /// read. If `read` returns 0 too many times, `NoProgress` will be\n-    /// returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs at any point, that error is returned, and no further\n-    /// bytes are read.\n-    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n-        if min > len {\n-            return Err(IoError {\n-                detail: Some(String::from_str(\"the buffer is too short\")),\n-                ..standard_error(InvalidInput)\n-            });\n-        }\n-\n-        let start_len = buf.len();\n-        buf.reserve(len);\n-\n-        // we can't just use self.read_at_least(min, slice) because we need to push\n-        // successful reads onto the vector before any returned errors.\n-\n-        let mut read = 0;\n-        while read < min {\n-            read += {\n-                let s = unsafe { slice_vec_capacity(buf, start_len + read, start_len + len) };\n-                try!(self.read_at_least(1, s))\n-            };\n-            unsafe { buf.set_len(start_len + read) };\n-        }\n-        Ok(read)\n-    }\n-\n-    /// Reads exactly `len` bytes and gives you back a new vector of length\n-    /// `len`\n-    ///\n-    /// # Error\n-    ///\n-    /// Fails with the same conditions as `read`. Additionally returns error\n-    /// on EOF. Note that if an error is returned, then some number of bytes may\n-    /// have already been consumed from the underlying reader, and they are lost\n-    /// (not returned as part of the error). If this is unacceptable, then it is\n-    /// recommended to use the `push_at_least` or `read` methods.\n-    fn read_exact(&mut self, len: usize) -> IoResult<Vec<u8>> {\n-        let mut buf = Vec::with_capacity(len);\n-        match self.push_at_least(len, len, &mut buf) {\n-            Ok(_) => Ok(buf),\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    /// Reads all remaining bytes from the stream.\n-    ///\n-    /// # Error\n-    ///\n-    /// Returns any non-EOF error immediately. Previously read bytes are\n-    /// discarded when an error is returned.\n-    ///\n-    /// When EOF is encountered, all bytes read up to that point are returned.\n-    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        let mut buf = Vec::with_capacity(DEFAULT_BUF_SIZE);\n-        loop {\n-            match self.push_at_least(1, DEFAULT_BUF_SIZE, &mut buf) {\n-                Ok(_) => {}\n-                Err(ref e) if e.kind == EndOfFile => break,\n-                Err(e) => return Err(e)\n-            }\n-        }\n-        return Ok(buf);\n-    }\n-\n-    /// Reads all of the remaining bytes of this stream, interpreting them as a\n-    /// UTF-8 encoded stream. The corresponding string is returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function returns all of the same errors as `read_to_end` with an\n-    /// additional error if the reader's contents are not a valid sequence of\n-    /// UTF-8 bytes.\n-    fn read_to_string(&mut self) -> IoResult<String> {\n-        self.read_to_end().and_then(|s| {\n-            match String::from_utf8(s) {\n-                Ok(s)  => Ok(s),\n-                Err(_) => Err(standard_error(InvalidInput)),\n-            }\n-        })\n-    }\n-\n-    // Byte conversion helpers\n-\n-    /// Reads `n` little-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0;\n-        let mut pos = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            val += (try!(self.read_u8()) as u64) << pos;\n-            pos += 8;\n-            i -= 1;\n-        }\n-        Ok(val)\n-    }\n-\n-    /// Reads `n` little-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n-        self.read_le_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n-    }\n-\n-    /// Reads `n` big-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            i -= 1;\n-            val += (try!(self.read_u8()) as u64) << i * 8;\n-        }\n-        Ok(val)\n-    }\n-\n-    /// Reads `n` big-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n-        self.read_be_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n-    }\n-\n-    /// Reads a little-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_le_uint(&mut self) -> IoResult<usize> {\n-        self.read_le_uint_n(usize::BYTES).map(|i| i as usize)\n-    }\n-\n-    /// Reads a little-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_le_int(&mut self) -> IoResult<isize> {\n-        self.read_le_int_n(isize::BYTES).map(|i| i as isize)\n-    }\n-\n-    /// Reads a big-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_be_uint(&mut self) -> IoResult<usize> {\n-        self.read_be_uint_n(usize::BYTES).map(|i| i as usize)\n-    }\n-\n-    /// Reads a big-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_be_int(&mut self) -> IoResult<isize> {\n-        self.read_be_int_n(isize::BYTES).map(|i| i as isize)\n-    }\n-\n-    /// Reads a big-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_be_u64(&mut self) -> IoResult<u64> {\n-        self.read_be_uint_n(8)\n-    }\n-\n-    /// Reads a big-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_be_u32(&mut self) -> IoResult<u32> {\n-        self.read_be_uint_n(4).map(|i| i as u32)\n-    }\n-\n-    /// Reads a big-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_be_u16(&mut self) -> IoResult<u16> {\n-        self.read_be_uint_n(2).map(|i| i as u16)\n-    }\n-\n-    /// Reads a big-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_be_i64(&mut self) -> IoResult<i64> {\n-        self.read_be_int_n(8)\n-    }\n-\n-    /// Reads a big-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_be_i32(&mut self) -> IoResult<i32> {\n-        self.read_be_int_n(4).map(|i| i as i32)\n-    }\n-\n-    /// Reads a big-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_be_i16(&mut self) -> IoResult<i16> {\n-        self.read_be_int_n(2).map(|i| i as i16)\n-    }\n-\n-    /// Reads a big-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64(&mut self) -> IoResult<f64> {\n-        self.read_be_u64().map(|i| unsafe {\n-            transmute::<u64, f64>(i)\n-        })\n-    }\n-\n-    /// Reads a big-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32(&mut self) -> IoResult<f32> {\n-        self.read_be_u32().map(|i| unsafe {\n-            transmute::<u32, f32>(i)\n-        })\n-    }\n-\n-    /// Reads a little-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_le_u64(&mut self) -> IoResult<u64> {\n-        self.read_le_uint_n(8)\n-    }\n-\n-    /// Reads a little-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_le_u32(&mut self) -> IoResult<u32> {\n-        self.read_le_uint_n(4).map(|i| i as u32)\n-    }\n-\n-    /// Reads a little-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_le_u16(&mut self) -> IoResult<u16> {\n-        self.read_le_uint_n(2).map(|i| i as u16)\n-    }\n-\n-    /// Reads a little-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_le_i64(&mut self) -> IoResult<i64> {\n-        self.read_le_int_n(8)\n-    }\n-\n-    /// Reads a little-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_le_i32(&mut self) -> IoResult<i32> {\n-        self.read_le_int_n(4).map(|i| i as i32)\n-    }\n-\n-    /// Reads a little-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_le_i16(&mut self) -> IoResult<i16> {\n-        self.read_le_int_n(2).map(|i| i as i16)\n-    }\n-\n-    /// Reads a little-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64(&mut self) -> IoResult<f64> {\n-        self.read_le_u64().map(|i| unsafe {\n-            transmute::<u64, f64>(i)\n-        })\n-    }\n-\n-    /// Reads a little-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32(&mut self) -> IoResult<f32> {\n-        self.read_le_u32().map(|i| unsafe {\n-            transmute::<u32, f32>(i)\n-        })\n-    }\n-\n-    /// Read a u8.\n-    ///\n-    /// `u8`s are 1 byte.\n-    fn read_u8(&mut self) -> IoResult<u8> {\n-        self.read_byte()\n-    }\n-\n-    /// Read an i8.\n-    ///\n-    /// `i8`s are 1 byte.\n-    fn read_i8(&mut self) -> IoResult<i8> {\n-        self.read_byte().map(|i| i as i8)\n-    }\n-}\n-\n-/// A reader which can be converted to a RefReader.\n-pub trait ByRefReader {\n-    /// Creates a wrapper around a mutable reference to the reader.\n-    ///\n-    /// This is useful to allow applying adaptors while still\n-    /// retaining ownership of the original value.\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self>;\n-}\n-\n-impl<T: Reader> ByRefReader for T {\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, T> {\n-        RefReader { inner: self }\n-    }\n-}\n-\n-/// A reader which can be converted to bytes.\n-pub trait BytesReader {\n-    /// Create an iterator that reads a single byte on\n-    /// each iteration, until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self>;\n-}\n-\n-impl<T: Reader> BytesReader for T {\n-    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, T> {\n-        extensions::Bytes::new(self)\n-    }\n-}\n-\n-impl<'a> Reader for Box<Reader+'a> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let reader: &mut Reader = &mut **self;\n-        reader.read(buf)\n-    }\n-}\n-\n-impl<'a> Reader for &'a mut (Reader+'a) {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { (*self).read(buf) }\n-}\n-\n-/// Returns a slice of `v` between `start` and `end`.\n-///\n-/// Similar to `slice()` except this function only bounds the slice on the\n-/// capacity of `v`, not the length.\n-///\n-/// # Panics\n-///\n-/// Panics when `start` or `end` point outside the capacity of `v`, or when\n-/// `start` > `end`.\n-// Private function here because we aren't sure if we want to expose this as\n-// API yet. If so, it should be a method on Vec.\n-unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: usize, end: usize) -> &'a mut [T] {\n-    use slice;\n-\n-    assert!(start <= end);\n-    assert!(end <= v.capacity());\n-    slice::from_raw_parts_mut(\n-        v.as_mut_ptr().offset(start as isize),\n-        end - start\n-    )\n-}\n-\n-/// A `RefReader` is a struct implementing `Reader` which contains a reference\n-/// to another reader. This is often useful when composing streams.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io as io;\n-/// use std::old_io::*;\n-/// use std::old_io::util::LimitReader;\n-///\n-/// fn process_input<R: Reader>(r: R) {}\n-///\n-/// let mut stream = io::stdin();\n-///\n-/// // Only allow the function to process at most one kilobyte of input\n-/// {\n-///     let stream = LimitReader::new(stream.by_ref(), 1024);\n-///     process_input(stream);\n-/// }\n-///\n-/// // 'stream' is still available for use here\n-/// ```\n-pub struct RefReader<'a, R:'a> {\n-    /// The underlying reader which this is referencing\n-    inner: &'a mut R\n-}\n-\n-impl<'a, R: Reader> Reader for RefReader<'a, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { self.inner.read(buf) }\n-}\n-\n-impl<'a, R: Buffer> Buffer for RefReader<'a, R> {\n-    fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n-}\n-\n-fn extend_sign(val: u64, nbytes: usize) -> i64 {\n-    let shift = (8 - nbytes) * 8;\n-    (val << shift) as i64 >> shift\n-}\n-\n-/// A trait for objects which are byte-oriented streams. Writers are defined by\n-/// one method, `write`. This function will block until the provided buffer of\n-/// bytes has been entirely written, and it will return any failures which occur.\n-///\n-/// Another commonly overridden method is the `flush` method for writers such as\n-/// buffered writers.\n-///\n-/// Writers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Writer` trait.\n-pub trait Writer {\n-    /// Write the entirety of a given buffer\n-    ///\n-    /// # Errors\n-    ///\n-    /// If an error happens during the I/O operation, the error is returned as\n-    /// `Err`. Note that it is considered an error if the entire buffer could\n-    /// not be written, and if an error is returned then it is unknown how much\n-    /// data (if any) was actually written.\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()>;\n-\n-    /// Deprecated, this method was renamed to `write_all`\n-    #[unstable(feature = \"io\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_all`\")]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write_all(buf) }\n-\n-    /// Flush this output stream, ensuring that all intermediately buffered\n-    /// contents reach their destination.\n-    ///\n-    /// This is by default a no-op and implementers of the `Writer` trait should\n-    /// decide whether their stream needs to be buffered or not.\n-    fn flush(&mut self) -> IoResult<()> { Ok(()) }\n-\n-    /// Writes a formatted string into this writer, returning any error\n-    /// encountered.\n-    ///\n-    /// This method is primarily used to interface with the `format_args!`\n-    /// macro, but it is rare that this should explicitly be called. The\n-    /// `write!` macro should be favored to invoke this method instead.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will return any I/O error reported while formatting.\n-    fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n-        // Create a shim which translates a Writer to a fmt::Write and saves\n-        // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T: ?Sized +'a> {\n-            inner: &'a mut T,\n-            error: IoResult<()>,\n-        }\n-\n-        impl<'a, T: ?Sized + Writer> fmt::Write for Adaptor<'a, T> {\n-            fn write_str(&mut self, s: &str) -> fmt::Result {\n-                match self.inner.write_all(s.as_bytes()) {\n-                    Ok(()) => Ok(()),\n-                    Err(e) => {\n-                        self.error = Err(e);\n-                        Err(fmt::Error)\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut output = Adaptor { inner: self, error: Ok(()) };\n-        match fmt::write(&mut output, fmt) {\n-            Ok(()) => Ok(()),\n-            Err(..) => output.error\n-        }\n-    }\n-\n-\n-    /// Write a rust string into this sink.\n-    ///\n-    /// The bytes written will be the UTF-8 encoded version of the input string.\n-    /// If other encodings are desired, it is recommended to compose this stream\n-    /// with another performing the conversion, or to use `write` with a\n-    /// converted byte-array instead.\n-    #[inline]\n-    fn write_str(&mut self, s: &str) -> IoResult<()> {\n-        self.write_all(s.as_bytes())\n-    }\n-\n-    /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n-    /// byte afterwards. Note that the writing of the newline is *not* atomic in\n-    /// the sense that the call to `write` is invoked twice (once with the\n-    /// string and once with a newline character).\n-    ///\n-    /// If other encodings or line ending flavors are desired, it is recommended\n-    /// that the `write` method is used specifically instead.\n-    #[inline]\n-    fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write_all(&[b'\\n']))\n-    }\n-\n-    /// Write a single char, encoded as UTF-8.\n-    #[inline]\n-    fn write_char(&mut self, c: char) -> IoResult<()> {\n-        let mut buf = [0; 4];\n-        let n = c.encode_utf8(&mut buf).unwrap_or(0);\n-        self.write_all(&buf[..n])\n-    }\n-\n-    /// Write the result of passing n through `isize::to_str_bytes`.\n-    #[inline]\n-    fn write_int(&mut self, n: isize) -> IoResult<()> {\n-        write!(self, \"{}\", n)\n-    }\n-\n-    /// Write the result of passing n through `usize::to_str_bytes`.\n-    #[inline]\n-    fn write_uint(&mut self, n: usize) -> IoResult<()> {\n-        write!(self, \"{}\", n)\n-    }\n-\n-    /// Write a little-endian usize (number of bytes depends on system).\n-    #[inline]\n-    fn write_le_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian isize (number of bytes depends on system).\n-    #[inline]\n-    fn write_le_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian usize (number of bytes depends on system).\n-    #[inline]\n-    fn write_be_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian isize (number of bytes depends on system).\n-    #[inline]\n-    fn write_be_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian u64 (8 bytes).\n-    #[inline]\n-    fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian u32 (4 bytes).\n-    #[inline]\n-    fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian u16 (2 bytes).\n-    #[inline]\n-    fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian i64 (8 bytes).\n-    #[inline]\n-    fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian i32 (4 bytes).\n-    #[inline]\n-    fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian i16 (2 bytes).\n-    #[inline]\n-    fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    #[inline]\n-    fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n-        unsafe {\n-            self.write_be_u64(transmute(f))\n-        }\n-    }\n-\n-    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    #[inline]\n-    fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n-        unsafe {\n-            self.write_be_u32(transmute(f))\n-        }\n-    }\n-\n-    /// Write a little-endian u64 (8 bytes).\n-    #[inline]\n-    fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian u32 (4 bytes).\n-    #[inline]\n-    fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian u16 (2 bytes).\n-    #[inline]\n-    fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian i64 (8 bytes).\n-    #[inline]\n-    fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian i32 (4 bytes).\n-    #[inline]\n-    fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian i16 (2 bytes).\n-    #[inline]\n-    fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian IEEE754 double-precision floating-point\n-    /// (8 bytes).\n-    #[inline]\n-    fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n-        unsafe {\n-            self.write_le_u64(transmute(f))\n-        }\n-    }\n-\n-    /// Write a little-endian IEEE754 single-precision floating-point\n-    /// (4 bytes).\n-    #[inline]\n-    fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n-        unsafe {\n-            self.write_le_u32(transmute(f))\n-        }\n-    }\n-\n-    /// Write a u8 (1 byte).\n-    #[inline]\n-    fn write_u8(&mut self, n: u8) -> IoResult<()> {\n-        self.write_all(&[n])\n-    }\n-\n-    /// Write an i8 (1 byte).\n-    #[inline]\n-    fn write_i8(&mut self, n: i8) -> IoResult<()> {\n-        self.write_all(&[n as u8])\n-    }\n-}\n-\n-/// A writer which can be converted to a RefWriter.\n-pub trait ByRefWriter {\n-    /// Creates a wrapper around a mutable reference to the writer.\n-    ///\n-    /// This is useful to allow applying wrappers while still\n-    /// retaining ownership of the original value.\n-    #[inline]\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self>;\n-}\n-\n-impl<T: Writer> ByRefWriter for T {\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, T> {\n-        RefWriter { inner: self }\n-    }\n-}\n-\n-impl<'a> Writer for Box<Writer+'a> {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        (&mut **self).write_all(buf)\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> IoResult<()> {\n-        (&mut **self).flush()\n-    }\n-}\n-\n-impl<'a> Writer for &'a mut (Writer+'a) {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write_all(buf) }\n-\n-    #[inline]\n-    fn flush(&mut self) -> IoResult<()> { (**self).flush() }\n-}\n-\n-/// A `RefWriter` is a struct implementing `Writer` which contains a reference\n-/// to another writer. This is often useful when composing streams.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io::util::TeeReader;\n-/// use std::old_io::*;\n-///\n-/// fn process_input<R: Reader>(r: R) {}\n-///\n-/// let mut output = Vec::new();\n-///\n-/// {\n-///     // Don't give ownership of 'output' to the 'tee'. Instead we keep a\n-///     // handle to it in the outer scope\n-///     let mut tee = TeeReader::new(stdin(), output.by_ref());\n-///     process_input(tee);\n-/// }\n-///\n-/// println!(\"input processed: {:?}\", output);\n-/// ```\n-pub struct RefWriter<'a, W:'a> {\n-    /// The underlying writer which this is referencing\n-    inner: &'a mut W\n-}\n-\n-impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write_all(buf) }\n-\n-    #[inline]\n-    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n-}\n-\n-\n-/// A Stream is a readable and a writable object. Data written is typically\n-/// received by the object which reads receive data from.\n-pub trait Stream: Reader + Writer { }\n-\n-impl<T: Reader + Writer> Stream for T {}\n-\n-/// An iterator that reads a line on each iteration,\n-/// until `.read_line()` encounters `EndOfFile`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `Lines` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Error\n-///\n-/// Any error other than `EndOfFile` that is produced by the underlying Reader\n-/// is returned by the iterator and should be handled by the caller.\n-pub struct Lines<'r, T:'r> {\n-    buffer: &'r mut T,\n-}\n-\n-impl<'r, T: Buffer> Iterator for Lines<'r, T> {\n-    type Item = IoResult<String>;\n-\n-    fn next(&mut self) -> Option<IoResult<String>> {\n-        match self.buffer.read_line() {\n-            Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: EndOfFile, ..}) => None,\n-            Err(y) => Some(Err(y))\n-        }\n-    }\n-}\n-\n-/// An iterator that reads a utf8-encoded character on each iteration,\n-/// until `.read_char()` encounters `EndOfFile`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `Chars` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Error\n-///\n-/// Any error other than `EndOfFile` that is produced by the underlying Reader\n-/// is returned by the iterator and should be handled by the caller.\n-pub struct Chars<'r, T:'r> {\n-    buffer: &'r mut T\n-}\n-\n-impl<'r, T: Buffer> Iterator for Chars<'r, T> {\n-    type Item = IoResult<char>;\n-\n-    fn next(&mut self) -> Option<IoResult<char>> {\n-        match self.buffer.read_char() {\n-            Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: EndOfFile, ..}) => None,\n-            Err(y) => Some(Err(y))\n-        }\n-    }\n-}\n-\n-/// A Buffer is a type of reader which has some form of internal buffering to\n-/// allow certain kinds of reading operations to be more optimized than others.\n-/// This type extends the `Reader` trait with a few methods that are not\n-/// possible to reasonably implement with purely a read interface.\n-pub trait Buffer: Reader {\n-    /// Fills the internal buffer of this object, returning the buffer contents.\n-    /// Note that none of the contents will be \"read\" in the sense that later\n-    /// calling `read` may return the same contents.\n-    ///\n-    /// The `consume` function must be called with the number of bytes that are\n-    /// consumed from this buffer returned to ensure that the bytes are never\n-    /// returned twice.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an I/O error if the underlying reader was\n-    /// read, but returned an error. Note that it is not an error to return a\n-    /// 0-length buffer.\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n-\n-    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n-    /// so they should no longer be returned in calls to `read`.\n-    fn consume(&mut self, amt: usize);\n-\n-    /// Reads the next line of input, interpreted as a sequence of UTF-8\n-    /// encoded Unicode codepoints. If a newline is encountered, then the\n-    /// newline is contained in the returned string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::*;\n-    ///\n-    /// let mut reader = BufReader::new(b\"hello\\nworld\");\n-    /// assert_eq!(\"hello\\n\", &*reader.read_line().unwrap());\n-    /// ```\n-    ///\n-    /// # Error\n-    ///\n-    /// This function has the same error semantics as `read_until`:\n-    ///\n-    /// * All non-EOF errors will be returned immediately\n-    /// * If an error is returned previously consumed bytes are lost\n-    /// * EOF is only returned if no bytes have been read\n-    /// * Reach EOF may mean that the delimiter is not present in the return\n-    ///   value\n-    ///\n-    /// Additionally, this function can fail if the line of input read is not a\n-    /// valid UTF-8 sequence of bytes.\n-    fn read_line(&mut self) -> IoResult<String> {\n-        self.read_until(b'\\n').and_then(|line|\n-            match String::from_utf8(line) {\n-                Ok(s)  => Ok(s),\n-                Err(_) => Err(standard_error(InvalidInput)),\n-            }\n-        )\n-    }\n-\n-    /// Reads a sequence of bytes leading up to a specified delimiter. Once the\n-    /// specified byte is encountered, reading ceases and the bytes up to and\n-    /// including the delimiter are returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// If any I/O error is encountered other than EOF, the error is immediately\n-    /// returned. Note that this may discard bytes which have already been read,\n-    /// and those bytes will *not* be returned. It is recommended to use other\n-    /// methods if this case is worrying.\n-    ///\n-    /// If EOF is encountered, then this function will return EOF if 0 bytes\n-    /// have been read, otherwise the pending byte buffer is returned. This\n-    /// is the reason that the byte buffer returned may not always contain the\n-    /// delimiter.\n-    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        let mut res = Vec::new();\n-\n-        loop {\n-            let (done, used) = {\n-                let available = match self.fill_buf() {\n-                    Ok(n) => n,\n-                    Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n-                        return Ok(res);\n-                    }\n-                    Err(e) => return Err(e)\n-                };\n-                match available.iter().position(|&b| b == byte) {\n-                    Some(i) => {\n-                        res.push_all(&available[..i + 1]);\n-                        (true, i + 1)\n-                    }\n-                    None => {\n-                        res.push_all(available);\n-                        (false, available.len())\n-                    }\n-                }\n-            };\n-            self.consume(used);\n-            if done {\n-                return Ok(res);\n-            }\n-        }\n-    }\n-\n-    /// Reads the next utf8-encoded character from the underlying stream.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an I/O error occurs, or EOF, then this function will return `Err`.\n-    /// This function will also return error if the stream does not contain a\n-    /// valid utf-8 encoded codepoint as the next few bytes in the stream.\n-    fn read_char(&mut self) -> IoResult<char> {\n-        let first_byte = try!(self.read_byte());\n-        let width = unicode::str::utf8_char_width(first_byte);\n-        if width == 1 { return Ok(first_byte as char) }\n-        if width == 0 { return Err(standard_error(InvalidInput)) } // not utf8\n-        let mut buf = [first_byte, 0, 0, 0];\n-        {\n-            let mut start = 1;\n-            while start < width {\n-                match try!(self.read(&mut buf[start .. width])) {\n-                    n if n == width - start => break,\n-                    n if n < width - start => { start += n; }\n-                    _ => return Err(standard_error(InvalidInput)),\n-                }\n-            }\n-        }\n-        match str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => Ok(s.char_at(0)),\n-            None => Err(standard_error(InvalidInput))\n-        }\n-    }\n-}\n-\n-/// Extension methods for the Buffer trait which are included in the prelude.\n-pub trait BufferPrelude {\n-    /// Create an iterator that reads a utf8-encoded character on each iteration\n-    /// until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn chars<'r>(&'r mut self) -> Chars<'r, Self>;\n-\n-    /// Create an iterator that reads a line on each iteration until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn lines<'r>(&'r mut self) -> Lines<'r, Self>;\n-}\n-\n-impl<T: Buffer> BufferPrelude for T {\n-    fn chars<'r>(&'r mut self) -> Chars<'r, T> {\n-        Chars { buffer: self }\n-    }\n-\n-    fn lines<'r>(&'r mut self) -> Lines<'r, T> {\n-        Lines { buffer: self }\n-    }\n-}\n-\n-/// When seeking, the resulting cursor is offset from a base by the offset given\n-/// to the `seek` function. The base used is specified by this enumeration.\n-#[derive(Copy, Clone)]\n-pub enum SeekStyle {\n-    /// Seek from the beginning of the stream\n-    SeekSet,\n-    /// Seek from the end of the stream\n-    SeekEnd,\n-    /// Seek from the current position\n-    SeekCur,\n-}\n-\n-/// An object implementing `Seek` internally has some form of cursor which can\n-/// be moved within a stream of bytes. The stream typically has a fixed size,\n-/// allowing seeking relative to either end.\n-pub trait Seek {\n-    /// Return position of file cursor in the stream\n-    fn tell(&self) -> IoResult<u64>;\n-\n-    /// Seek to an offset in a stream\n-    ///\n-    /// A successful seek clears the EOF indicator. Seeking beyond EOF is\n-    /// allowed, but seeking before position 0 is not allowed.\n-    ///\n-    /// # Errors\n-    ///\n-    /// * Seeking to a negative offset is considered an error\n-    /// * Seeking past the end of the stream does not modify the underlying\n-    ///   stream, but the next write may cause the previous data to be filled in\n-    ///   with a bit pattern.\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n-}\n-\n-/// A listener is a value that can consume itself to start listening for\n-/// connections.\n-///\n-/// Doing so produces some sort of Acceptor.\n-pub trait Listener<A: Acceptor> {\n-    /// Spin up the listener and start queuing incoming connections\n-    ///\n-    /// # Error\n-    ///\n-    /// Returns `Err` if this listener could not be bound to listen for\n-    /// connections. In all cases, this listener is consumed.\n-    fn listen(self) -> IoResult<A>;\n-}\n-\n-/// An acceptor is a value that presents incoming connections\n-pub trait Acceptor {\n-    /// Type of connection that is accepted by this acceptor.\n-    type Connection;\n-\n-    /// Wait for and accept an incoming connection\n-    ///\n-    /// # Error\n-    ///\n-    /// Returns `Err` if an I/O error is encountered.\n-    fn accept(&mut self) -> IoResult<Self::Connection>;\n-\n-    /// Create an iterator over incoming connection attempts.\n-    ///\n-    /// Note that I/O errors will be yielded by the iterator itself.\n-    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {\n-        IncomingConnections { inc: self }\n-    }\n-}\n-\n-/// An infinite iterator over incoming connection attempts.\n-/// Calling `next` will block the task until a connection is attempted.\n-///\n-/// Since connection attempts can continue forever, this iterator always returns\n-/// `Some`. The `Some` contains the `IoResult` representing whether the\n-/// connection attempt was successful.  A successful connection will be wrapped\n-/// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, A: ?Sized +'a> {\n-    inc: &'a mut A,\n-}\n-\n-impl<'a, A: ?Sized + Acceptor> Iterator for IncomingConnections<'a, A> {\n-    type Item = IoResult<A::Connection>;\n-\n-    fn next(&mut self) -> Option<IoResult<A::Connection>> {\n-        Some(self.inc.accept())\n-    }\n-}\n-\n-/// Creates a standard error for a commonly used flavor of error. The `detail`\n-/// field of the returned error will always be `None`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io as io;\n-///\n-/// let eof = io::standard_error(io::EndOfFile);\n-/// let einval = io::standard_error(io::InvalidInput);\n-/// ```\n-pub fn standard_error(kind: IoErrorKind) -> IoError {\n-    let desc = match kind {\n-        EndOfFile => \"end of file\",\n-        IoUnavailable => \"I/O is unavailable\",\n-        InvalidInput => \"invalid input\",\n-        OtherIoError => \"unknown I/O error\",\n-        FileNotFound => \"file not found\",\n-        PermissionDenied => \"permission denied\",\n-        ConnectionFailed => \"connection failed\",\n-        Closed => \"stream is closed\",\n-        ConnectionRefused => \"connection refused\",\n-        ConnectionReset => \"connection reset\",\n-        ConnectionAborted => \"connection aborted\",\n-        NotConnected => \"not connected\",\n-        BrokenPipe => \"broken pipe\",\n-        PathAlreadyExists => \"file already exists\",\n-        PathDoesntExist => \"no such file\",\n-        MismatchedFileTypeForOperation => \"mismatched file type\",\n-        ResourceUnavailable => \"resource unavailable\",\n-        TimedOut => \"operation timed out\",\n-        ShortWrite(..) => \"short write\",\n-        NoProgress => \"no progress\",\n-    };\n-    IoError {\n-        kind: kind,\n-        desc: desc,\n-        detail: None,\n-    }\n-}\n-\n-/// A mode specifies how a file should be opened or created. These modes are\n-/// passed to `File::open_mode` and are used to control where the file is\n-/// positioned when it is initially opened.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum FileMode {\n-    /// Opens a file positioned at the beginning.\n-    Open,\n-    /// Opens a file positioned at EOF.\n-    Append,\n-    /// Opens a file, truncating it if it already exists.\n-    Truncate,\n-}\n-\n-/// Access permissions with which the file should be opened. `File`s\n-/// opened with `Read` will return an error if written to.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum FileAccess {\n-    /// Read-only access, requests to write will result in an error\n-    Read,\n-    /// Write-only access, requests to read will result in an error\n-    Write,\n-    /// Read-write access, no requests are denied by default\n-    ReadWrite,\n-}\n-\n-/// Different kinds of files which can be identified by a call to stat\n-#[derive(Copy, PartialEq, Debug, Hash, Clone)]\n-pub enum FileType {\n-    /// This is a normal file, corresponding to `S_IFREG`\n-    RegularFile,\n-\n-    /// This file is a directory, corresponding to `S_IFDIR`\n-    Directory,\n-\n-    /// This file is a named pipe, corresponding to `S_IFIFO`\n-    NamedPipe,\n-\n-    /// This file is a block device, corresponding to `S_IFBLK`\n-    BlockSpecial,\n-\n-    /// This file is a symbolic link to another file, corresponding to `S_IFLNK`\n-    Symlink,\n-\n-    /// The type of this file is not recognized as one of the other categories\n-    Unknown,\n-}\n-\n-/// A structure used to describe metadata information about a file. This\n-/// structure is created through the `stat` method on a `Path`.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// # #![feature(old_io, old_path)]\n-///\n-/// use std::old_io::fs::PathExtensions;\n-/// use std::old_path::Path;\n-///\n-/// let info = match Path::new(\"foo.txt\").stat() {\n-///     Ok(stat) => stat,\n-///     Err(e) => panic!(\"couldn't read foo.txt: {}\", e),\n-/// };\n-///\n-/// println!(\"byte size: {}\", info.size);\n-/// ```\n-#[derive(Copy, Clone, Hash)]\n-pub struct FileStat {\n-    /// The size of the file, in bytes\n-    pub size: u64,\n-    /// The kind of file this path points to (directory, file, pipe, etc.)\n-    pub kind: FileType,\n-    /// The file permissions currently on the file\n-    pub perm: FilePermission,\n-\n-    // FIXME(#10301): These time fields are pretty useless without an actual\n-    //                time representation, what are the milliseconds relative\n-    //                to?\n-\n-    /// The time that the file was created at, in platform-dependent\n-    /// milliseconds\n-    pub created: u64,\n-    /// The time that this file was last modified, in platform-dependent\n-    /// milliseconds\n-    pub modified: u64,\n-    /// The time that this file was last accessed, in platform-dependent\n-    /// milliseconds\n-    pub accessed: u64,\n-\n-    /// Information returned by stat() which is not guaranteed to be\n-    /// platform-independent. This information may be useful on some platforms,\n-    /// but it may have different meanings or no meaning at all on other\n-    /// platforms.\n-    ///\n-    /// Usage of this field is discouraged, but if access is desired then the\n-    /// fields are located here.\n-    #[unstable(feature = \"io\")]\n-    pub unstable: UnstableFileStat,\n-}\n-\n-/// This structure represents all of the possible information which can be\n-/// returned from a `stat` syscall which is not contained in the `FileStat`\n-/// structure. This information is not necessarily platform independent, and may\n-/// have different meanings or no meaning at all on some platforms.\n-#[unstable(feature = \"io\")]\n-#[derive(Copy, Clone, Hash)]\n-pub struct UnstableFileStat {\n-    /// The ID of the device containing the file.\n-    pub device: u64,\n-    /// The file serial number.\n-    pub inode: u64,\n-    /// The device ID.\n-    pub rdev: u64,\n-    /// The number of hard links to this file.\n-    pub nlink: u64,\n-    /// The user ID of the file.\n-    pub uid: u64,\n-    /// The group ID of the file.\n-    pub gid: u64,\n-    /// The optimal block size for I/O.\n-    pub blksize: u64,\n-    /// The blocks allocated for this file.\n-    pub blocks: u64,\n-    /// User-defined flags for the file.\n-    pub flags: u64,\n-    /// The file generation number.\n-    pub gen: u64,\n-}\n-\n-\n-bitflags! {\n-    /// A set of permissions for a file or directory is represented by a set of\n-    /// flags which are or'd together.\n-    #[derive(Debug)]\n-    flags FilePermission: u32 {\n-        const USER_READ     = 0o400,\n-        const USER_WRITE    = 0o200,\n-        const USER_EXECUTE  = 0o100,\n-        const GROUP_READ    = 0o040,\n-        const GROUP_WRITE   = 0o020,\n-        const GROUP_EXECUTE = 0o010,\n-        const OTHER_READ    = 0o004,\n-        const OTHER_WRITE   = 0o002,\n-        const OTHER_EXECUTE = 0o001,\n-\n-        const USER_RWX  = USER_READ.bits | USER_WRITE.bits | USER_EXECUTE.bits,\n-        const GROUP_RWX = GROUP_READ.bits | GROUP_WRITE.bits | GROUP_EXECUTE.bits,\n-        const OTHER_RWX = OTHER_READ.bits | OTHER_WRITE.bits | OTHER_EXECUTE.bits,\n-\n-        /// Permissions for user owned files, equivalent to 0644 on unix-like\n-        /// systems.\n-        const USER_FILE = USER_READ.bits | USER_WRITE.bits | GROUP_READ.bits | OTHER_READ.bits,\n-\n-        /// Permissions for user owned directories, equivalent to 0755 on\n-        /// unix-like systems.\n-        const USER_DIR  = USER_RWX.bits | GROUP_READ.bits | GROUP_EXECUTE.bits |\n-                   OTHER_READ.bits | OTHER_EXECUTE.bits,\n-\n-        /// Permissions for user owned executables, equivalent to 0755\n-        /// on unix-like systems.\n-        const USER_EXEC = USER_DIR.bits,\n-\n-        /// All possible permissions enabled.\n-        const ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n-    }\n-}\n-\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for FilePermission {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn default() -> FilePermission { FilePermission::empty() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for FilePermission {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:04o}\", self.bits)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use self::BadReaderBehavior::*;\n-    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n-    use super::Buffer;\n-    use prelude::v1::{Ok, Vec};\n-    use usize;\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    enum BadReaderBehavior {\n-        GoodBehavior(usize),\n-        BadBehavior(usize)\n-    }\n-\n-    struct BadReader<T> {\n-        r: T,\n-        behavior: Vec<BadReaderBehavior>,\n-    }\n-\n-    impl<T: Reader> BadReader<T> {\n-        fn new(r: T, behavior: Vec<BadReaderBehavior>) -> BadReader<T> {\n-            BadReader { behavior: behavior, r: r }\n-        }\n-    }\n-\n-    impl<T: Reader> Reader for BadReader<T> {\n-        fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-            let BadReader { ref mut behavior, ref mut r } = *self;\n-            loop {\n-                if behavior.is_empty() {\n-                    // fall back on good\n-                    return r.read(buf);\n-                }\n-                match (&mut **behavior)[0] {\n-                    GoodBehavior(0) => (),\n-                    GoodBehavior(ref mut x) => {\n-                        *x -= 1;\n-                        return r.read(buf);\n-                    }\n-                    BadBehavior(0) => (),\n-                    BadBehavior(ref mut x) => {\n-                        *x -= 1;\n-                        return Ok(0);\n-                    }\n-                };\n-                behavior.remove(0);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_at_least() {\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(usize::MAX)]);\n-        let buf = &mut [0; 5];\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-        assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n-        assert!(r.read_at_least(0, buf).is_ok());\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(usize::MAX)]);\n-        assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n-\n-        let mut r = MemReader::new(b\"hello, world!\".to_vec());\n-        assert_eq!(r.read_at_least(5, buf).unwrap(), 5);\n-        assert_eq!(r.read_at_least(6, buf).unwrap_err().kind, InvalidInput);\n-    }\n-\n-    #[test]\n-    fn test_push_at_least() {\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(usize::MAX)]);\n-        let mut buf = Vec::new();\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-        assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(usize::MAX)]);\n-        assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n-\n-        let mut r = MemReader::new(b\"hello, world!\".to_vec());\n-        assert_eq!(r.push_at_least(5, 1, &mut buf).unwrap_err().kind, InvalidInput);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        use super::*;\n-\n-        assert_eq!(format!(\"{}\", USER_READ), \"0400\");\n-        assert_eq!(format!(\"{}\", USER_FILE), \"0644\");\n-        assert_eq!(format!(\"{}\", USER_EXEC), \"0755\");\n-        assert_eq!(format!(\"{}\", USER_RWX),  \"0700\");\n-        assert_eq!(format!(\"{}\", GROUP_RWX), \"0070\");\n-        assert_eq!(format!(\"{}\", OTHER_RWX), \"0007\");\n-        assert_eq!(format!(\"{}\", ALL_PERMISSIONS), \"0777\");\n-        assert_eq!(format!(\"{}\", USER_READ | USER_WRITE | OTHER_WRITE), \"0602\");\n-    }\n-\n-    fn _ensure_buffer_is_object_safe<T: Buffer>(x: &T) -> &Buffer {\n-        x as &Buffer\n-    }\n-}"}, {"sha": "dd30363e316afee68a12ed105ac1293daeec084f", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous DNS Resolution\n-//!\n-//! Contains the functionality to perform DNS resolution or reverse lookup,\n-//! in a style related to `getaddrinfo()` and `getnameinfo()`, respectively.\n-\n-#![allow(missing_docs)]\n-\n-pub use self::SocketType::*;\n-pub use self::Flag::*;\n-pub use self::Protocol::*;\n-\n-use iter::Iterator;\n-use old_io::IoResult;\n-use old_io::net::ip::{SocketAddr, IpAddr};\n-use option::Option;\n-use option::Option::{Some, None};\n-use string::String;\n-use sys;\n-use vec::Vec;\n-\n-/// Hints to the types of sockets that are desired when looking up hosts\n-#[derive(Copy, Clone, Debug)]\n-pub enum SocketType {\n-    Stream, Datagram, Raw\n-}\n-\n-/// Flags which can be or'd into the `flags` field of a `Hint`. These are used\n-/// to manipulate how a query is performed.\n-///\n-/// The meaning of each of these flags can be found with `man -s 3 getaddrinfo`\n-#[derive(Copy, Clone, Debug)]\n-pub enum Flag {\n-    AddrConfig,\n-    All,\n-    CanonName,\n-    NumericHost,\n-    NumericServ,\n-    Passive,\n-    V4Mapped,\n-}\n-\n-/// A transport protocol associated with either a hint or a return value of\n-/// `lookup`\n-#[derive(Copy, Clone, Debug)]\n-pub enum Protocol {\n-    TCP, UDP\n-}\n-\n-/// This structure is used to provide hints when fetching addresses for a\n-/// remote host to control how the lookup is performed.\n-///\n-/// For details on these fields, see their corresponding definitions via\n-/// `man -s 3 getaddrinfo`\n-#[derive(Copy, Clone, Debug)]\n-pub struct Hint {\n-    pub family: usize,\n-    pub socktype: Option<SocketType>,\n-    pub protocol: Option<Protocol>,\n-    pub flags: usize,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct Info {\n-    pub address: SocketAddr,\n-    pub family: usize,\n-    pub socktype: Option<SocketType>,\n-    pub protocol: Option<Protocol>,\n-    pub flags: usize,\n-}\n-\n-/// Easy name resolution. Given a hostname, returns the list of IP addresses for\n-/// that hostname.\n-pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n-    lookup(Some(host), None, None).map(|a| a.into_iter().map(|i| i.address.ip).collect())\n-}\n-\n-/// Reverse name resolution. Given an address, returns the corresponding\n-/// hostname.\n-pub fn get_address_name(addr: IpAddr) -> IoResult<String> {\n-    sys::addrinfo::get_address_name(addr)\n-}\n-\n-/// Full-fledged resolution. This function will perform a synchronous call to\n-/// getaddrinfo, controlled by the parameters\n-///\n-/// # Arguments\n-///\n-/// * hostname - an optional hostname to lookup against\n-/// * servname - an optional service name, listed in the system services\n-/// * hint - see the hint structure, and \"man -s 3 getaddrinfo\", for how this\n-///          controls lookup\n-///\n-/// FIXME: this is not public because the `Hint` structure is not ready for public\n-///      consumption just yet.\n-#[allow(unused_variables)]\n-fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n-          -> IoResult<Vec<Info>> {\n-    sys::addrinfo::get_host_addresses(hostname, servname, hint)\n-}\n-\n-// Ignored on android since we cannot give tcp/ip\n-// permission without help of apk\n-#[cfg(all(test, not(target_os = \"android\")))]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-    use old_io::net::ip::*;\n-\n-    #[test]\n-    fn dns_smoke_test() {\n-        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n-        let mut found_local = false;\n-        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n-        for addr in &ipaddrs {\n-            found_local = found_local || addr == local_addr;\n-        }\n-        assert!(found_local);\n-    }\n-\n-    #[test]\n-    fn issue_10663() {\n-        // Something should happen here, but this certainly shouldn't cause\n-        // everything to die. The actual outcome we don't care too much about.\n-        let _ = get_host_addresses(\"example.com\");\n-    }\n-}"}, {"sha": "f5310292b911b8c4f15a204263c849a3179e3341", "filename": "src/libstd/old_io/net/ip.rs", "status": "removed", "additions": 0, "deletions": 710, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,710 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Internet Protocol (IP) addresses.\n-//!\n-//! This module contains functions useful for parsing, formatting, and\n-//! manipulating IP addresses.\n-\n-#![allow(missing_docs)]\n-\n-pub use self::IpAddr::*;\n-\n-use boxed::Box;\n-use fmt;\n-use old_io::{self, IoResult, IoError};\n-use old_io::net;\n-use iter::Iterator;\n-use ops::{FnOnce, FnMut};\n-use option::Option;\n-use option::Option::{None, Some};\n-use result::Result::{self, Ok, Err};\n-use str::FromStr;\n-use vec::Vec;\n-\n-pub type Port = u16;\n-\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n-pub enum IpAddr {\n-    Ipv4Addr(u8, u8, u8, u8),\n-    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Ipv4Addr(a, b, c, d) =>\n-                write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n-\n-            // Ipv4 Compatible address\n-            Ipv6Addr(0, 0, 0, 0, 0, 0, g, h) => {\n-                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n-                       (h >> 8) as u8, h as u8)\n-            }\n-\n-            // Ipv4-Mapped address\n-            Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, g, h) => {\n-                write!(fmt, \"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n-                       (h >> 8) as u8, h as u8)\n-            }\n-\n-            Ipv6Addr(a, b, c, d, e, f, g, h) =>\n-                write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n-                       a, b, c, d, e, f, g, h)\n-        }\n-    }\n-}\n-\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n-pub struct SocketAddr {\n-    pub ip: IpAddr,\n-    pub port: Port,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.ip {\n-            Ipv4Addr(..) => write!(f, \"{}:{}\", self.ip, self.port),\n-            Ipv6Addr(..) => write!(f, \"[{}]:{}\", self.ip, self.port),\n-        }\n-    }\n-}\n-\n-struct Parser<'a> {\n-    // parsing as ASCII, so can use byte array\n-    s: &'a [u8],\n-    pos: usize,\n-}\n-\n-impl<'a> Parser<'a> {\n-    fn new(s: &'a str) -> Parser<'a> {\n-        Parser {\n-            s: s.as_bytes(),\n-            pos: 0,\n-        }\n-    }\n-\n-    fn is_eof(&self) -> bool {\n-        self.pos == self.s.len()\n-    }\n-\n-    // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n-        F: FnOnce(&mut Parser) -> Option<T>,\n-    {\n-        let pos = self.pos;\n-        let r = cb(self);\n-        if r.is_none() {\n-            self.pos = pos;\n-        }\n-        r\n-    }\n-\n-    // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n-        F: FnOnce(&mut Parser) -> Option<T>,\n-    {\n-        self.read_atomically(move |p| {\n-            match cb(p) {\n-                Some(x) => if p.is_eof() {Some(x)} else {None},\n-                None => None,\n-            }\n-        })\n-    }\n-\n-    // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n-               -> Option<T> {\n-        for pf in parsers {\n-            match self.read_atomically(|p: &mut Parser| pf.call_mut((p,))) {\n-                Some(r) => return Some(r),\n-                None => {}\n-            }\n-        }\n-        None\n-    }\n-\n-    // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n-                                       pa: PA,\n-                                       pb: PB,\n-                                       pc: PC)\n-                                       -> Option<(A, B, C)> where\n-        PA: FnOnce(&mut Parser) -> Option<A>,\n-        PB: FnOnce(&mut Parser) -> Option<B>,\n-        PC: FnOnce(&mut Parser) -> Option<C>,\n-    {\n-        self.read_atomically(move |p| {\n-            let a = pa(p);\n-            let b = if a.is_some() { pb(p) } else { None };\n-            let c = if b.is_some() { pc(p) } else { None };\n-            match (a, b, c) {\n-                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None\n-            }\n-        })\n-    }\n-\n-    // Read next char\n-    fn read_char(&mut self) -> Option<char> {\n-        if self.is_eof() {\n-            None\n-        } else {\n-            let r = self.s[self.pos] as char;\n-            self.pos += 1;\n-            Some(r)\n-        }\n-    }\n-\n-    // Return char and advance iff next char is equal to requested\n-    fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| {\n-            match p.read_char() {\n-                Some(next) if next == c => Some(next),\n-                _ => None,\n-            }\n-        })\n-    }\n-\n-    // Read digit\n-    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n-        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n-            let c = c as u8;\n-            // assuming radix is either 10 or 16\n-            if c >= b'0' && c <= b'9' {\n-                Some(c - b'0')\n-            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n-                Some(c - b'a' + 10)\n-            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n-                Some(c - b'A' + 10)\n-            } else {\n-                None\n-            }\n-        }\n-\n-        self.read_atomically(|p| {\n-            p.read_char().and_then(|c| parse_digit(c, radix))\n-        })\n-    }\n-\n-    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        let mut r = 0;\n-        let mut digit_count = 0;\n-        loop {\n-            match self.read_digit(radix) {\n-                Some(d) => {\n-                    r = r * (radix as u32) + (d as u32);\n-                    digit_count += 1;\n-                    if digit_count > max_digits || r >= upto {\n-                        return None\n-                    }\n-                }\n-                None => {\n-                    if digit_count == 0 {\n-                        return None\n-                    } else {\n-                        return Some(r)\n-                    }\n-                }\n-            };\n-        }\n-    }\n-\n-    // Read number, failing if max_digits of number value exceeded\n-    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n-    }\n-\n-    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> {\n-        let mut bs = [0; 4];\n-        let mut i = 0;\n-        while i < 4 {\n-            if i != 0 && self.read_given_char('.').is_none() {\n-                return None;\n-            }\n-\n-            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n-            match octet {\n-                Some(d) => bs[i] = d,\n-                None => return None,\n-            };\n-            i += 1;\n-        }\n-        Some(Ipv4Addr(bs[0], bs[1], bs[2], bs[3]))\n-    }\n-\n-    // Read IPv4 address\n-    fn read_ipv4_addr(&mut self) -> Option<IpAddr> {\n-        self.read_atomically(|p| p.read_ipv4_addr_impl())\n-    }\n-\n-    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> {\n-        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr {\n-            assert!(head.len() + tail.len() <= 8);\n-            let mut gs = [0; 8];\n-            gs.clone_from_slice(head);\n-            gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n-            Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n-        }\n-\n-        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n-            let mut i = 0;\n-            while i < limit {\n-                if i < limit - 1 {\n-                    let ipv4 = p.read_atomically(|p| {\n-                        if i == 0 || p.read_given_char(':').is_some() {\n-                            p.read_ipv4_addr()\n-                        } else {\n-                            None\n-                        }\n-                    });\n-                    match ipv4 {\n-                        Some(Ipv4Addr(a, b, c, d)) => {\n-                            groups[i + 0] = ((a as u16) << 8) | (b as u16);\n-                            groups[i + 1] = ((c as u16) << 8) | (d as u16);\n-                            return (i + 2, true);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                let group = p.read_atomically(|p| {\n-                    if i == 0 || p.read_given_char(':').is_some() {\n-                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n-                    } else {\n-                        None\n-                    }\n-                });\n-                match group {\n-                    Some(g) => groups[i] = g,\n-                    None => return (i, false)\n-                }\n-                i += 1;\n-            }\n-            (i, false)\n-        }\n-\n-        let mut head = [0; 8];\n-        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n-\n-        if head_size == 8 {\n-            return Some(Ipv6Addr(\n-                head[0], head[1], head[2], head[3],\n-                head[4], head[5], head[6], head[7]))\n-        }\n-\n-        // IPv4 part is not allowed before `::`\n-        if head_ipv4 {\n-            return None\n-        }\n-\n-        // read `::` if previous code parsed less than 8 groups\n-        if !self.read_given_char(':').is_some() || !self.read_given_char(':').is_some() {\n-            return None;\n-        }\n-\n-        let mut tail = [0; 8];\n-        let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n-    }\n-\n-    fn read_ipv6_addr(&mut self) -> Option<IpAddr> {\n-        self.read_atomically(|p| p.read_ipv6_addr_impl())\n-    }\n-\n-    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        let ipv4_addr: Box<_> = box |p: &mut Parser| p.read_ipv4_addr();\n-        let ipv6_addr: Box<_> = box |p: &mut Parser| p.read_ipv6_addr();\n-        self.read_or(&mut [ipv4_addr, ipv6_addr])\n-    }\n-\n-    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n-        let ip_addr = |p: &mut Parser| {\n-            let ipv4_p: Box<_> = box |p: &mut Parser| p.read_ip_addr();\n-            let ipv6_p: Box<_> = box |p: &mut Parser| {\n-                let open_br = |p: &mut Parser| p.read_given_char('[');\n-                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n-                let clos_br = |p: &mut Parser| p.read_given_char(']');\n-                p.read_seq_3::<char, IpAddr, char, _, _, _>(open_br, ip_addr, clos_br)\n-                        .map(|t| match t { (_, ip, _) => ip })\n-            };\n-            p.read_or(&mut [ipv4_p, ipv6_p])\n-        };\n-        let colon = |p: &mut Parser| p.read_given_char(':');\n-        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n-\n-        // host, colon, port\n-        self.read_seq_3::<IpAddr, char, u16, _, _, _>(ip_addr, colon, port)\n-                .map(|t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n-    }\n-}\n-\n-impl FromStr for IpAddr {\n-    type Err = ParseError;\n-    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(ParseError),\n-        }\n-    }\n-}\n-\n-impl FromStr for SocketAddr {\n-    type Err = ParseError;\n-    fn from_str(s: &str) -> Result<SocketAddr, ParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(ParseError),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Copy)]\n-pub struct ParseError;\n-\n-/// A trait for objects which can be converted or resolved to one or more `SocketAddr` values.\n-///\n-/// Implementing types minimally have to implement either `to_socket_addr` or `to_socket_addr_all`\n-/// method, and its trivial counterpart will be available automatically.\n-///\n-/// This trait is used for generic address resolution when constructing network objects.\n-/// By default it is implemented for the following types:\n-///\n-///  * `SocketAddr` - `to_socket_addr` is identity function.\n-///\n-///  * `(IpAddr, u16)` - `to_socket_addr` constructs `SocketAddr` trivially.\n-///\n-///  * `(&str, u16)` - the string should be either a string representation of an IP address\n-///    expected by `FromStr` implementation for `IpAddr` or a host name.\n-///\n-///    For the former, `to_socket_addr_all` returns a vector with a single element corresponding\n-///    to that IP address joined with the given port.\n-///\n-///    For the latter, it tries to resolve the host name and returns a vector of all IP addresses\n-///    for the host name, each joined with the given port.\n-///\n-///  * `&str` - the string should be either a string representation of a `SocketAddr` as\n-///    expected by its `FromStr` implementation or a string like `<host_name>:<port>` pair\n-///    where `<port>` is a `u16` value.\n-///\n-///    For the former, `to_socket_addr_all` returns a vector with a single element corresponding\n-///    to that socket address.\n-///\n-///    For the latter, it tries to resolve the host name and returns a vector of all IP addresses\n-///    for the host name, each joined with the port.\n-///\n-///\n-/// This trait allows constructing network objects like `TcpStream` or `UdpSocket` easily with\n-/// values of various types for the bind/connection address. It is needed because sometimes\n-/// one type is more appropriate than the other: for simple uses a string like `\"localhost:12345\"`\n-/// is much nicer than manual construction of the corresponding `SocketAddr`, but sometimes\n-/// `SocketAddr` value is *the* main source of the address, and converting it to some other type\n-/// (e.g. a string) just for it to be converted back to `SocketAddr` in constructor methods\n-/// is pointless.\n-///\n-/// Some examples:\n-///\n-/// ```rust,no_run\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-///\n-/// use std::old_io::{TcpStream, TcpListener};\n-/// use std::old_io::net::udp::UdpSocket;\n-/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n-///\n-/// fn main() {\n-///     // The following lines are equivalent modulo possible \"localhost\" name resolution\n-///     // differences\n-///     let tcp_s = TcpStream::connect(SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 12345 });\n-///     let tcp_s = TcpStream::connect((Ipv4Addr(127, 0, 0, 1), 12345));\n-///     let tcp_s = TcpStream::connect((\"127.0.0.1\", 12345));\n-///     let tcp_s = TcpStream::connect((\"localhost\", 12345));\n-///     let tcp_s = TcpStream::connect(\"127.0.0.1:12345\");\n-///     let tcp_s = TcpStream::connect(\"localhost:12345\");\n-///\n-///     // TcpListener::bind(), UdpSocket::bind() and UdpSocket::send_to() behave similarly\n-///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n-///\n-///     let mut udp_s = UdpSocket::bind((\"127.0.0.1\", 23451)).unwrap();\n-///     udp_s.send_to([7, 7, 7].as_ref(), (Ipv4Addr(127, 0, 0, 1), 23451));\n-/// }\n-/// ```\n-pub trait ToSocketAddr {\n-    /// Converts this object to single socket address value.\n-    ///\n-    /// If more than one value is available, this method returns the first one. If no\n-    /// values are available, this method returns an `IoError`.\n-    ///\n-    /// By default this method delegates to `to_socket_addr_all` method, taking the first\n-    /// item from its result.\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n-        self.to_socket_addr_all()\n-            .and_then(|v| v.into_iter().next().ok_or_else(|| IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"no address available\",\n-                detail: None\n-            }))\n-    }\n-\n-    /// Converts this object to all available socket address values.\n-    ///\n-    /// Some values like host name string naturally correspond to multiple IP addresses.\n-    /// This method tries to return all available addresses corresponding to this object.\n-    ///\n-    /// By default this method delegates to `to_socket_addr` method, creating a singleton\n-    /// vector from its result.\n-    #[inline]\n-    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n-        self.to_socket_addr().map(|a| vec![a])\n-    }\n-}\n-\n-impl ToSocketAddr for SocketAddr {\n-    #[inline]\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> { Ok(*self) }\n-}\n-\n-impl ToSocketAddr for (IpAddr, u16) {\n-    #[inline]\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n-        let (ip, port) = *self;\n-        Ok(SocketAddr { ip: ip, port: port })\n-    }\n-}\n-\n-fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> {\n-    net::get_host_addresses(s)\n-        .map(|v| v.into_iter().map(|a| SocketAddr { ip: a, port: p }).collect())\n-}\n-\n-fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n-    macro_rules! try_opt {\n-        ($e:expr, $msg:expr) => (\n-            match $e {\n-                Some(r) => r,\n-                None => return Err(IoError {\n-                    kind: old_io::InvalidInput,\n-                    desc: $msg,\n-                    detail: None\n-                })\n-            }\n-        )\n-    }\n-\n-    // split the string by ':' and convert the second part to u16\n-    let mut parts_iter = s.rsplitn(2, ':');\n-    let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n-    let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-    let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n-    resolve_socket_addr(host, port)\n-}\n-\n-impl<'a> ToSocketAddr for (&'a str, u16) {\n-    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n-        let (host, port) = *self;\n-\n-        // try to parse the host as a regular IpAddr first\n-        match host.parse().ok() {\n-            Some(addr) => return Ok(vec![SocketAddr {\n-                ip: addr,\n-                port: port\n-            }]),\n-            None => {}\n-        }\n-\n-        resolve_socket_addr(host, port)\n-    }\n-}\n-\n-// accepts strings like 'localhost:12345'\n-impl<'a> ToSocketAddr for &'a str {\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n-        // try to parse as a regular SocketAddr first\n-        match self.parse().ok() {\n-            Some(addr) => return Ok(addr),\n-            None => {}\n-        }\n-\n-        parse_and_resolve_socket_addr(*self)\n-            .and_then(|v| v.into_iter().next()\n-                .ok_or_else(|| IoError {\n-                    kind: old_io::InvalidInput,\n-                    desc: \"no address available\",\n-                    detail: None\n-                })\n-            )\n-    }\n-\n-    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n-        // try to parse as a regular SocketAddr first\n-        match self.parse().ok() {\n-            Some(addr) => return Ok(vec![addr]),\n-            None => {}\n-        }\n-\n-        parse_and_resolve_socket_addr(*self)\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-    use str::FromStr;\n-\n-    #[test]\n-    fn test_from_str_ipv4() {\n-        assert_eq!(Ok(Ipv4Addr(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-        assert_eq!(Ok(Ipv4Addr(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-        assert_eq!(Ok(Ipv4Addr(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-        // out of range\n-        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n-        assert_eq!(None, none);\n-        // no number between dots\n-        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-                \"2a02:6b8::11:11\".parse());\n-\n-        // too long group\n-        let none: Option<IpAddr> = \"::00000\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-        assert_eq!(None, none);\n-        // triple colon\n-        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n-        assert_eq!(None, none);\n-        // two double colons\n-        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n-                \"::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-                \"::FFFF:192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-                \"64:ff9b::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n-\n-        // colon after v4\n-        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // not enough groups\n-        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too many groups\n-        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_socket_addr() {\n-        assert_eq!(Ok(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n-                \"77.88.21.11:80\".parse());\n-        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n-                \"[2a02:6b8:0:1::1]:53\".parse());\n-        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n-                \"[::127.0.0.1]:22\".parse());\n-\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // wrong brackets around v4\n-        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-        assert_eq!(None, none);\n-        // port out of range\n-        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn ipv6_addr_to_string() {\n-        let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_string() == \"::ffff:192.0.2.128\" ||\n-                a1.to_string() == \"::FFFF:192.0.2.128\");\n-        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n-                   \"8:9:a:b:c:d:e:f\");\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_socketaddr() {\n-        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 12345 };\n-        assert_eq!(Ok(a), a.to_socket_addr());\n-        assert_eq!(Ok(vec![a]), a.to_socket_addr_all());\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_ipaddr_u16() {\n-        let a = Ipv4Addr(77, 88, 21, 11);\n-        let p = 12345;\n-        let e = SocketAddr { ip: a, port: p };\n-        assert_eq!(Ok(e), (a, p).to_socket_addr());\n-        assert_eq!(Ok(vec![e]), (a, p).to_socket_addr_all());\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_str_u16() {\n-        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n-        assert_eq!(Ok(a), (\"77.88.21.11\", 24352).to_socket_addr());\n-        assert_eq!(Ok(vec![a]), (\"77.88.21.11\", 24352).to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n-        assert_eq!(Ok(a), (\"2a02:6b8:0:1::1\", 53).to_socket_addr());\n-        assert_eq!(Ok(vec![a]), (\"2a02:6b8:0:1::1\", 53).to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n-        assert!((\"localhost\", 23924).to_socket_addr_all().unwrap().contains(&a));\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_str() {\n-        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n-        assert_eq!(Ok(a), \"77.88.21.11:24352\".to_socket_addr());\n-        assert_eq!(Ok(vec![a]), \"77.88.21.11:24352\".to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n-        assert_eq!(Ok(a), \"[2a02:6b8:0:1::1]:53\".to_socket_addr());\n-        assert_eq!(Ok(vec![a]), \"[2a02:6b8:0:1::1]:53\".to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n-        assert!(\"localhost:23924\".to_socket_addr_all().unwrap().contains(&a));\n-    }\n-}"}, {"sha": "a3567290b0e16395a83003ed874f3301bb469e50", "filename": "src/libstd/old_io/net/mod.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Networking I/O\n-\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"replaced with new I/O primitives in `std::net`\")]\n-#![unstable(feature = \"old_io\")]\n-\n-use old_io::{IoError, IoResult, InvalidInput};\n-use ops::FnMut;\n-use option::Option::None;\n-use result::Result::{Ok, Err};\n-use self::ip::{SocketAddr, ToSocketAddr};\n-\n-pub use self::addrinfo::get_host_addresses;\n-\n-pub mod addrinfo;\n-pub mod tcp;\n-pub mod udp;\n-pub mod ip;\n-pub mod pipe;\n-\n-fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where\n-    A: ToSocketAddr,\n-    F: FnMut(SocketAddr) -> IoResult<T>,\n-{\n-    const DEFAULT_ERROR: IoError = IoError {\n-        kind: InvalidInput,\n-        desc: \"no addresses found for hostname\",\n-        detail: None\n-    };\n-\n-    let addresses = try!(addr.to_socket_addr_all());\n-    let mut err = DEFAULT_ERROR;\n-    for addr in addresses {\n-        match action(addr) {\n-            Ok(r) => return Ok(r),\n-            Err(e) => err = e\n-        }\n-    }\n-    Err(err)\n-}"}, {"sha": "7b23c3e1d03f21f8f60be42924fc1608f3d84f5d", "filename": "src/libstd/old_io/net/pipe.rs", "status": "removed", "additions": 0, "deletions": 883, "changes": 883, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,883 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Named pipes\n-//!\n-//! This module contains the ability to communicate over named pipes with\n-//! synchronous I/O. On windows, this corresponds to talking over a Named Pipe,\n-//! while on Unix it corresponds to UNIX domain sockets.\n-//!\n-//! These pipes are similar to TCP in the sense that you can have both a stream to a\n-//! server and a server itself. The server provided accepts other `UnixStream`\n-//! instances as clients.\n-\n-#![allow(missing_docs)]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"will be removed to be reintroduced at a later date; \\\n-                        in the meantime consider using the `unix_socket` crate \\\n-                        for unix sockets; there is currently no replacement \\\n-                        for named pipes\")]\n-#![unstable(feature = \"old_io\")]\n-\n-use prelude::v1::*;\n-\n-use ffi::CString;\n-use old_path::BytesContainer;\n-use old_io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n-use old_io::{Reader, Writer};\n-use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n-use sys::pipe::UnixListener as UnixListenerImp;\n-use sys::pipe::UnixStream as UnixStreamImp;\n-use time::Duration;\n-\n-use sys_common;\n-\n-/// A stream which communicates over a named pipe.\n-pub struct UnixStream {\n-    inner: UnixStreamImp,\n-}\n-\n-impl UnixStream {\n-\n-    /// Connect to a pipe named by `path`. This will attempt to open a\n-    /// connection to the underlying socket.\n-    ///\n-    /// The returned stream will be closed when the object falls out of scope.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, old_path, io)]\n-    /// # #![allow(unused_must_use)]\n-    /// use std::old_io::net::pipe::UnixStream;\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let server = Path::new(\"path/to/my/socket\");\n-    /// let mut stream = UnixStream::connect(&server);\n-    /// stream.write(&[1, 2, 3]);\n-    /// ```\n-    pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> {\n-        let path = try!(CString::new(path.container_as_bytes()));\n-        UnixStreamImp::connect(&path, None)\n-            .map(|inner| UnixStream { inner: inner })\n-    }\n-\n-    /// Connect to a pipe named by `path`, timing out if the specified number of\n-    /// milliseconds.\n-    ///\n-    /// This function is similar to `connect`, except that if `timeout`\n-    /// elapses the function will return an error of kind `TimedOut`.\n-    ///\n-    /// If a `timeout` with zero or negative duration is specified then\n-    /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument is likely to change types\")]\n-    pub fn connect_timeout<P>(path: P, timeout: Duration)\n-                              -> IoResult<UnixStream>\n-                              where P: BytesContainer {\n-        if timeout <= Duration::milliseconds(0) {\n-            return Err(standard_error(TimedOut));\n-        }\n-\n-        let path = try!(CString::new(path.container_as_bytes()));\n-        UnixStreamImp::connect(&path, Some(timeout.num_milliseconds() as u64))\n-            .map(|inner| UnixStream { inner: inner })\n-    }\n-\n-\n-    /// Closes the reading half of this connection.\n-    ///\n-    /// This method will close the reading portion of this connection, causing\n-    /// all pending and future reads to immediately return with an error.\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        self.inner.close_read()\n-    }\n-\n-    /// Closes the writing half of this connection.\n-    ///\n-    /// This method will close the writing portion of this connection, causing\n-    /// all pending and future writes to immediately return with an error.\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        self.inner.close_write()\n-    }\n-\n-    /// Sets the read/write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the read timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_read_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_write_timeout(timeout_ms)\n-    }\n-}\n-\n-impl Clone for UnixStream {\n-    fn clone(&self) -> UnixStream {\n-        UnixStream { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl Writer for UnixStream {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.write(buf)\n-    }\n-}\n-\n-impl sys_common::AsInner<UnixStreamImp> for UnixStream {\n-    fn as_inner(&self) -> &UnixStreamImp {\n-        &self.inner\n-    }\n-}\n-\n-/// A value that can listen for incoming named pipe connection requests.\n-pub struct UnixListener {\n-    /// The internal, opaque runtime Unix listener.\n-    inner: UnixListenerImp,\n-}\n-\n-impl UnixListener {\n-    /// Creates a new listener, ready to receive incoming connections on the\n-    /// specified socket. The server will be named by `path`.\n-    ///\n-    /// This listener will be closed when it falls out of scope.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, io, old_path)]\n-    /// # fn foo() {\n-    /// use std::old_io::net::pipe::UnixListener;\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let server = Path::new(\"/path/to/my/socket\");\n-    /// let stream = UnixListener::bind(&server);\n-    /// for mut client in stream.listen().incoming() {\n-    ///     let _ = client.write(&[1, 2, 3, 4]);\n-    /// }\n-    /// # }\n-    /// ```\n-    pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> {\n-        let path = try!(CString::new(path.container_as_bytes()));\n-        UnixListenerImp::bind(&path)\n-            .map(|inner| UnixListener { inner: inner })\n-    }\n-}\n-\n-impl Listener<UnixAcceptor> for UnixListener {\n-    fn listen(self) -> IoResult<UnixAcceptor> {\n-        self.inner.listen()\n-            .map(|inner| UnixAcceptor { inner: inner })\n-    }\n-}\n-\n-impl sys_common::AsInner<UnixListenerImp> for UnixListener {\n-    fn as_inner(&self) -> &UnixListenerImp {\n-        &self.inner\n-    }\n-}\n-\n-/// A value that can accept named pipe connections, returned from `listen()`.\n-pub struct UnixAcceptor {\n-    /// The internal, opaque runtime Unix acceptor.\n-    inner: UnixAcceptorImp\n-}\n-\n-impl UnixAcceptor {\n-    /// Sets a timeout for this acceptor, after which accept() will no longer\n-    /// block indefinitely.\n-    ///\n-    /// The argument specified is the amount of time, in milliseconds, into the\n-    /// future after which all invocations of accept() will not block (and any\n-    /// pending invocation will return). A value of `None` will clear any\n-    /// existing timeout.\n-    ///\n-    /// When using this method, it is likely necessary to reset the timeout as\n-    /// appropriate, the timeout specified is specific to this object, not\n-    /// specific to the next request.\n-    #[unstable(feature = \"io\",\n-               reason = \"the name and arguments to this function are likely \\\n-                         to change\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Closes the accepting capabilities of this acceptor.\n-    ///\n-    /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n-    /// more information can be found in that documentation.\n-    #[unstable(feature = \"io\")]\n-    pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.close_accept()\n-    }\n-}\n-\n-impl Acceptor for UnixAcceptor {\n-    type Connection = UnixStream;\n-    fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.inner.accept().map(|s| {\n-            UnixStream { inner: s }\n-        })\n-    }\n-}\n-\n-impl Clone for UnixAcceptor {\n-    /// Creates a new handle to this unix acceptor, allowing for simultaneous\n-    /// accepts.\n-    ///\n-    /// The underlying unix acceptor will not be closed until all handles to the\n-    /// acceptor have been deallocated. Incoming connections will be received on\n-    /// at most once acceptor, the same connection will not be accepted twice.\n-    ///\n-    /// The `close_accept` method will shut down *all* acceptors cloned from the\n-    /// same original acceptor, whereas the `set_timeout` method only affects\n-    /// the selector that it is called on.\n-    ///\n-    /// This function is useful for creating a handle to invoke `close_accept`\n-    /// on to wake up any other task blocked in `accept`.\n-    fn clone(&self) -> UnixAcceptor {\n-        UnixAcceptor { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n-    fn as_inner(&self) -> &UnixAcceptorImp {\n-        &self.inner\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use old_io::fs::PathExtensions;\n-    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n-    use old_io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n-    use old_io::{PermissionDenied, Acceptor, Listener};\n-    use old_io::{Reader, Writer};\n-    use old_io::test::*;\n-    use super::*;\n-    use sync::mpsc::channel;\n-    use thread;\n-    use time::Duration;\n-\n-    pub fn smalltest<F,G>(server: F, client: G)\n-        where F : FnOnce(UnixStream), F : Send,\n-              G : FnOnce(UnixStream), G : Send + 'static\n-    {\n-        let path1 = next_test_unix();\n-        let path2 = path1.clone();\n-\n-        let mut acceptor = UnixListener::bind(&path1).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            match UnixStream::connect(&path2) {\n-                Ok(c) => client(c),\n-                Err(e) => panic!(\"failed connect: {}\", e),\n-            }\n-        });\n-\n-        match acceptor.accept() {\n-            Ok(c) => server(c),\n-            Err(e) => panic!(\"failed accept: {}\", e),\n-        }\n-    }\n-\n-    #[test]\n-    fn bind_error() {\n-        let path = \"path/to/nowhere\";\n-        match UnixListener::bind(&path) {\n-            Ok(..) => panic!(),\n-            Err(e) => {\n-                assert!(e.kind == PermissionDenied || e.kind == FileNotFound ||\n-                        e.kind == InvalidInput);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_error() {\n-        let path = if cfg!(windows) {\n-            r\"\\\\.\\pipe\\this_should_not_exist_ever\"\n-        } else {\n-            \"path/to/nowhere\"\n-        };\n-        match UnixStream::connect(&path) {\n-            Ok(..) => panic!(),\n-            Err(e) => {\n-                assert!(e.kind == FileNotFound || e.kind == OtherIoError);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke() {\n-        smalltest(move |mut server| {\n-            let mut buf = [0];\n-            server.read(&mut buf).unwrap();\n-            assert!(buf[0] == 99);\n-        }, move|mut client| {\n-            client.write(&[99]).unwrap();\n-        })\n-    }\n-\n-    #[cfg_attr(windows, ignore)] // FIXME(#12516)\n-    #[test]\n-    fn read_eof() {\n-        smalltest(move|mut server| {\n-            let mut buf = [0];\n-            assert!(server.read(&mut buf).is_err());\n-            assert!(server.read(&mut buf).is_err());\n-        }, move|_client| {\n-            // drop the client\n-        })\n-    }\n-\n-    #[test]\n-    fn write_begone() {\n-        smalltest(move|mut server| {\n-            let buf = [0];\n-            loop {\n-                match server.write(&buf) {\n-                    Ok(..) => {}\n-                    Err(e) => {\n-                        assert!(e.kind == BrokenPipe ||\n-                                e.kind == NotConnected ||\n-                                e.kind == ConnectionReset,\n-                                \"unknown error {}\", e);\n-                        break;\n-                    }\n-                }\n-            }\n-        }, move|_client| {\n-            // drop the client\n-        })\n-    }\n-\n-    #[test]\n-    fn accept_lots() {\n-        let times = 10;\n-        let path1 = next_test_unix();\n-        let path2 = path1.clone();\n-\n-        let mut acceptor = match UnixListener::bind(&path1).listen() {\n-            Ok(a) => a,\n-            Err(e) => panic!(\"failed listen: {}\", e),\n-        };\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..times {\n-                let mut stream = UnixStream::connect(&path2);\n-                match stream.write(&[100]) {\n-                    Ok(..) => {}\n-                    Err(e) => panic!(\"failed write: {}\", e)\n-                }\n-            }\n-        });\n-\n-        for _ in 0..times {\n-            let mut client = acceptor.accept();\n-            let mut buf = [0];\n-            match client.read(&mut buf) {\n-                Ok(..) => {}\n-                Err(e) => panic!(\"failed read/accept: {}\", e),\n-            }\n-            assert_eq!(buf[0], 100);\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    #[test]\n-    fn path_exists() {\n-        let path = next_test_unix();\n-        let _acceptor = UnixListener::bind(&path).listen();\n-        assert!(path.exists());\n-    }\n-\n-    #[test]\n-    fn unix_clone_smoke() {\n-        let addr = next_test_unix();\n-        let mut acceptor = UnixListener::bind(&addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr);\n-            let mut buf = [0, 0];\n-            debug!(\"client reading\");\n-            assert_eq!(s.read(&mut buf), Ok(1));\n-            assert_eq!(buf[0], 1);\n-            debug!(\"client writing\");\n-            s.write(&[2]).unwrap();\n-            debug!(\"client dropping\");\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            rx1.recv().unwrap();\n-            debug!(\"writer writing\");\n-            s2.write(&[1]).unwrap();\n-            debug!(\"writer done\");\n-            tx2.send(()).unwrap();\n-        });\n-        tx1.send(()).unwrap();\n-        let mut buf = [0, 0];\n-        debug!(\"reader reading\");\n-        assert_eq!(s1.read(&mut buf), Ok(1));\n-        debug!(\"reader done\");\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn unix_clone_two_read() {\n-        let addr = next_test_unix();\n-        let mut acceptor = UnixListener::bind(&addr).listen();\n-        let (tx1, rx) = channel();\n-        let tx2 = tx1.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr);\n-            s.write(&[1]).unwrap();\n-            rx.recv().unwrap();\n-            s.write(&[2]).unwrap();\n-            rx.recv().unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            let mut buf = [0, 0];\n-            s2.read(&mut buf).unwrap();\n-            tx2.send(()).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        let mut buf = [0, 0];\n-        s1.read(&mut buf).unwrap();\n-        tx1.send(()).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn unix_clone_two_write() {\n-        let addr = next_test_unix();\n-        let mut acceptor = UnixListener::bind(&addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr);\n-            let buf = &mut [0, 1];\n-            s.read(buf).unwrap();\n-            s.read(buf).unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            s2.write(&[1]).unwrap();\n-            tx.send(()).unwrap();\n-        });\n-        s1.write(&[2]).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn drop_removes_listener_path() {\n-        let path = next_test_unix();\n-        let l = UnixListener::bind(&path).unwrap();\n-        assert!(path.exists());\n-        drop(l);\n-        assert!(!path.exists());\n-    }\n-\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn drop_removes_acceptor_path() {\n-        let path = next_test_unix();\n-        let l = UnixListener::bind(&path).unwrap();\n-        assert!(path.exists());\n-        drop(l.listen().unwrap());\n-        assert!(!path.exists());\n-    }\n-\n-    #[test]\n-    fn accept_timeout() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-\n-        a.set_timeout(Some(10));\n-\n-        // Make sure we time out once and future invocations also time out\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-\n-        // Also make sure that even though the timeout is expired that we will\n-        // continue to receive any pending connections.\n-        let (tx, rx) = channel();\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n-        });\n-        let l = rx.recv().unwrap();\n-        for i in 0..1001 {\n-            match a.accept() {\n-                Ok(..) => break,\n-                Err(ref e) if e.kind == TimedOut => {}\n-                Err(e) => panic!(\"error: {}\", e),\n-            }\n-            ::thread::yield_now();\n-            if i == 1000 { panic!(\"should have a pending connection\") }\n-        }\n-        drop(l);\n-\n-        // Unset the timeout and make sure that this always blocks.\n-        a.set_timeout(None);\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            drop(UnixStream::connect(&addr2).unwrap());\n-        });\n-        a.accept().unwrap();\n-    }\n-\n-    #[test]\n-    fn connect_timeout_error() {\n-        let addr = next_test_unix();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_err());\n-    }\n-\n-    #[test]\n-    fn connect_timeout_success() {\n-        let addr = next_test_unix();\n-        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_ok());\n-    }\n-\n-    #[test]\n-    fn connect_timeout_zero() {\n-        let addr = next_test_unix();\n-        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(0)).is_err());\n-    }\n-\n-    #[test]\n-    fn connect_timeout_negative() {\n-        let addr = next_test_unix();\n-        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(-1)).is_err());\n-    }\n-\n-    #[test]\n-    fn close_readwrite_smoke() {\n-        let addr = next_test_unix();\n-        let a = UnixListener::bind(&addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv();\n-        });\n-\n-        let mut b = [0];\n-        let mut s = UnixStream::connect(&addr).unwrap();\n-        let mut s2 = s.clone();\n-\n-        // closing should prevent reads/writes\n-        s.close_write().unwrap();\n-        assert!(s.write(&[0]).is_err());\n-        s.close_read().unwrap();\n-        assert!(s.read(&mut b).is_err());\n-\n-        // closing should affect previous handles\n-        assert!(s2.write(&[0]).is_err());\n-        assert!(s2.read(&mut b).is_err());\n-\n-        // closing should affect new handles\n-        let mut s3 = s.clone();\n-        assert!(s3.write(&[0]).is_err());\n-        assert!(s3.read(&mut b).is_err());\n-\n-        // make sure these don't die\n-        let _ = s2.close_read();\n-        let _ = s2.close_write();\n-        let _ = s3.close_read();\n-        let _ = s3.close_write();\n-    }\n-\n-    #[test]\n-    fn close_read_wakes_up() {\n-        let addr = next_test_unix();\n-        let a = UnixListener::bind(&addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = UnixStream::connect(&addr).unwrap();\n-        let s2 = s.clone();\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert!(s2.read(&mut [0]).is_err());\n-            tx.send(()).unwrap();\n-        });\n-        // this should wake up the child task\n-        s.close_read().unwrap();\n-\n-        // this test will never finish if the child doesn't wake up\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn readwrite_timeouts() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        s.set_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-\n-        // I'm not sure as to why, but apparently the write on windows always\n-        // succeeds after the previous timeout. Who knows?\n-        if !cfg!(windows) {\n-            assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n-        }\n-\n-        tx.send(()).unwrap();\n-        s.set_timeout(None);\n-        assert_eq!(s.read(&mut [0, 0]), Ok(1));\n-    }\n-\n-    #[test]\n-    fn read_timeouts() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            let mut amt = 0;\n-            while amt < 100 * 128 * 1024 {\n-                match s.read(&mut [0;128 * 1024]) {\n-                    Ok(n) => { amt += n; }\n-                    Err(e) => panic!(\"{}\", e),\n-                }\n-            }\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        for _ in 0..100 {\n-            assert!(s.write(&[0;128 * 1024]).is_ok());\n-        }\n-    }\n-\n-    #[test]\n-    fn write_timeouts() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_write_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-\n-        tx.send(()).unwrap();\n-        assert!(s.read(&mut [0]).is_ok());\n-    }\n-\n-    #[test]\n-    fn timeout_concurrent_read() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        let s2 = s.clone();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert!(s2.read(&mut [0]).is_ok());\n-            tx2.send(()).unwrap();\n-        });\n-\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(()).unwrap();\n-\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn clone_accept_smoke() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let mut a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr2);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr);\n-        });\n-\n-        assert!(a.accept().is_ok());\n-        drop(a);\n-        assert!(a2.accept().is_ok());\n-    }\n-\n-    #[cfg(not(windows))] // FIXME #17553\n-    #[test]\n-    fn clone_accept_concurrent() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let a = l.listen().unwrap();\n-        let a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let tx2 = tx.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap()\n-        });\n-        let _t = thread::spawn(move|| {\n-            let mut a = a2;\n-            tx2.send(a.accept()).unwrap()\n-        });\n-\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr2);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr);\n-        });\n-\n-        assert!(rx.recv().unwrap().is_ok());\n-        assert!(rx.recv().unwrap().is_ok());\n-    }\n-\n-    #[test]\n-    fn close_accept_smoke() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let mut a = l.listen().unwrap();\n-\n-        a.close_accept().unwrap();\n-        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n-    }\n-\n-    #[test]\n-    fn close_accept_concurrent() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap();\n-        });\n-        a2.close_accept().unwrap();\n-\n-        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n-    }\n-}"}, {"sha": "7fc460c16efca2454a61b7e48bb5d606c62741cf", "filename": "src/libstd/old_io/net/tcp.rs", "status": "removed", "additions": 0, "deletions": 1483, "changes": 1483, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,1483 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! TCP network connections\n-//!\n-//! This module contains the ability to open a TCP stream to a socket address,\n-//! as well as creating a socket server to accept incoming connections. The\n-//! destination and binding addresses can either be an IPv4 or IPv6 address.\n-//!\n-//! A TCP connection implements the `Reader` and `Writer` traits, while the TCP\n-//! listener (socket server) implements the `Listener` and `Acceptor` traits.\n-\n-use clone::Clone;\n-use old_io::IoResult;\n-use result::Result::Err;\n-use old_io::net::ip::{SocketAddr, ToSocketAddr};\n-use old_io::{Reader, Writer, Listener, Acceptor};\n-use old_io::{standard_error, TimedOut};\n-use option::Option;\n-use option::Option::{None, Some};\n-use time::Duration;\n-\n-use sys::tcp::TcpStream as TcpStreamImp;\n-use sys::tcp::TcpListener as TcpListenerImp;\n-use sys::tcp::TcpAcceptor as TcpAcceptorImp;\n-\n-use sys_common;\n-\n-/// A structure which represents a TCP stream between a local socket and a\n-/// remote socket.\n-///\n-/// The socket will be closed when the value is dropped.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// # #![feature(old_io, io)]\n-/// use std::old_io::*;\n-///\n-/// {\n-///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n-///\n-///     // ignore the Result\n-///     let _ = stream.write(&[1]);\n-///\n-///     let mut buf = [0];\n-///     let _ = stream.read(&mut buf); // ignore here too\n-/// } // the stream is closed here\n-/// ```\n-pub struct TcpStream {\n-    inner: TcpStreamImp,\n-}\n-\n-impl TcpStream {\n-    fn new(s: TcpStreamImp) -> TcpStream {\n-        TcpStream { inner: s }\n-    }\n-\n-    /// Open a TCP connection to a remote host.\n-    ///\n-    /// `addr` is an address of the remote host. Anything which implements `ToSocketAddr`\n-    /// trait can be supplied for the address; see this trait documentation for\n-    /// concrete examples.\n-    pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> {\n-        super::with_addresses(addr, |addr| {\n-            TcpStreamImp::connect(addr, None).map(TcpStream::new)\n-        })\n-    }\n-\n-    /// Creates a TCP connection to a remote socket address, timing out after\n-    /// the specified duration.\n-    ///\n-    /// This is the same as the `connect` method, except that if the timeout\n-    /// specified elapses before a connection is made an error will be\n-    /// returned. The error's kind will be `TimedOut`.\n-    ///\n-    /// Same as the `connect` method, `addr` argument type can be anything which\n-    /// implements `ToSocketAddr` trait.\n-    ///\n-    /// If a `timeout` with zero or negative duration is specified then\n-    /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may eventually change types\")]\n-    pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n-                                            timeout: Duration) -> IoResult<TcpStream> {\n-        if timeout <= Duration::milliseconds(0) {\n-            return Err(standard_error(TimedOut));\n-        }\n-\n-        super::with_addresses(addr, |addr| {\n-            TcpStreamImp::connect(addr, Some(timeout.num_milliseconds() as u64))\n-                .map(TcpStream::new)\n-        })\n-    }\n-\n-    /// Returns the socket address of the remote peer of this TCP connection.\n-    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.peer_name()\n-    }\n-\n-    /// Returns the socket address of the local half of this TCP connection.\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.socket_name()\n-    }\n-\n-    /// Sets the nodelay flag on this connection to the boolean specified\n-    #[unstable(feature = \"io\")]\n-    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        self.inner.set_nodelay(nodelay)\n-    }\n-\n-    /// Sets the keepalive timeout to the timeout specified.\n-    ///\n-    /// If the value specified is `None`, then the keepalive flag is cleared on\n-    /// this connection. Otherwise, the keepalive timeout will be set to the\n-    /// specified time, in seconds.\n-    #[unstable(feature = \"io\")]\n-    pub fn set_keepalive(&mut self, delay_in_seconds: Option<usize>) -> IoResult<()> {\n-        self.inner.set_keepalive(delay_in_seconds)\n-    }\n-\n-    /// Closes the reading half of this connection.\n-    ///\n-    /// This method will close the reading portion of this connection, causing\n-    /// all pending and future reads to immediately return with an error.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_io, std_misc)]\n-    /// # #![allow(unused_must_use)]\n-    /// use std::old_io::*;\n-    /// use std::time::Duration;\n-    /// use std::thread;\n-    ///\n-    /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n-    /// let stream2 = stream.clone();\n-    ///\n-    /// let _t = thread::spawn(move|| {\n-    ///     // close this stream after one second\n-    ///     timer::sleep(Duration::seconds(1));\n-    ///     let mut stream = stream2;\n-    ///     stream.close_read();\n-    /// });\n-    ///\n-    /// // wait for some data, will get canceled after one second\n-    /// let mut buf = [0];\n-    /// stream.read(&mut buf);\n-    /// ```\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        self.inner.close_read()\n-    }\n-\n-    /// Closes the writing half of this connection.\n-    ///\n-    /// This method will close the writing portion of this connection, causing\n-    /// all future writes to immediately return with an error.\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        self.inner.close_write()\n-    }\n-\n-    /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n-    ///\n-    /// This function will set a timeout for all blocking operations (including\n-    /// reads and writes) on this stream. The timeout specified is a relative\n-    /// time, in milliseconds, into the future after which point operations will\n-    /// time out. This means that the timeout must be reset periodically to keep\n-    /// it from expiring. Specifying a value of `None` will clear the timeout\n-    /// for this stream.\n-    ///\n-    /// The timeout on this stream is local to this stream only. Setting a\n-    /// timeout does not affect any other cloned instances of this stream, nor\n-    /// does the timeout propagated to cloned handles of this stream. Setting\n-    /// this timeout will override any specific read or write timeouts\n-    /// previously set for this stream.\n-    ///\n-    /// For clarification on the semantics of interrupting a read and a write,\n-    /// take a look at `set_read_timeout` and `set_write_timeout`.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the timeout for read operations on this stream.\n-    ///\n-    /// See documentation in `set_timeout` for the semantics of this read time.\n-    /// This will overwrite any previous read timeout set through either this\n-    /// function or `set_timeout`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// When this timeout expires, if there is no pending read operation, no\n-    /// action is taken. Otherwise, the read operation will be scheduled to\n-    /// promptly return. If a timeout error is returned, then no data was read\n-    /// during the timeout period.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_read_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the timeout for write operations on this stream.\n-    ///\n-    /// See documentation in `set_timeout` for the semantics of this write time.\n-    /// This will overwrite any previous write timeout set through either this\n-    /// function or `set_timeout`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// When this timeout expires, if there is no pending write operation, no\n-    /// action is taken. Otherwise, the pending write operation will be\n-    /// scheduled to promptly return. The actual state of the underlying stream\n-    /// is not specified.\n-    ///\n-    /// The write operation may return an error of type `ShortWrite` which\n-    /// indicates that the object is known to have written an exact number of\n-    /// bytes successfully during the timeout period, and the remaining bytes\n-    /// were never written.\n-    ///\n-    /// If the write operation returns `TimedOut`, then it the timeout primitive\n-    /// does not know how many bytes were written as part of the timeout\n-    /// operation. It may be the case that bytes continue to be written in an\n-    /// asynchronous fashion after the call to write returns.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_write_timeout(timeout_ms)\n-    }\n-}\n-\n-impl Clone for TcpStream {\n-    /// Creates a new handle to this TCP stream, allowing for simultaneous reads\n-    /// and writes of this connection.\n-    ///\n-    /// The underlying TCP stream will not be closed until all handles to the\n-    /// stream have been deallocated. All handles will also follow the same\n-    /// stream, but two concurrent reads will not receive the same data.\n-    /// Instead, the first read will receive the first packet received, and the\n-    /// second read will receive the second packet.\n-    fn clone(&self) -> TcpStream {\n-        TcpStream { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl Writer for TcpStream {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.write(buf)\n-    }\n-}\n-\n-impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n-    fn as_inner(&self) -> &TcpStreamImp {\n-        &self.inner\n-    }\n-}\n-\n-/// A structure representing a socket server. This listener is used to create a\n-/// `TcpAcceptor` which can be used to accept sockets on a local port.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// # fn foo() {\n-/// use std::old_io::*;\n-/// use std::thread;\n-///\n-/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n-///\n-/// // bind the listener to the specified address\n-/// let mut acceptor = listener.listen().unwrap();\n-///\n-/// fn handle_client(mut stream: TcpStream) {\n-///     // ...\n-/// # &mut stream; // silence unused mutability/variable warning\n-/// }\n-/// // accept connections and process them, spawning a new tasks for each one\n-/// for stream in acceptor.incoming() {\n-///     match stream {\n-///         Err(e) => { /* connection failed */ }\n-///         Ok(stream) => {\n-///             thread::spawn(move|| {\n-///                 // connection succeeded\n-///                 handle_client(stream)\n-///             });\n-///         }\n-///     }\n-/// }\n-///\n-/// // close the socket server\n-/// drop(acceptor);\n-/// # }\n-/// ```\n-pub struct TcpListener {\n-    inner: TcpListenerImp,\n-}\n-\n-impl TcpListener {\n-    /// Creates a new `TcpListener` which will be bound to the specified address.\n-    /// This listener is not ready for accepting connections, `listen` must be called\n-    /// on it before that's possible.\n-    ///\n-    /// Binding with a port number of 0 will request that the OS assigns a port\n-    /// to this listener. The port allocated can be queried via the\n-    /// `socket_name` function.\n-    ///\n-    /// The address type can be any implementer of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n-    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> {\n-        super::with_addresses(addr, |addr| {\n-            TcpListenerImp::bind(addr).map(|inner| TcpListener { inner: inner })\n-        })\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.socket_name()\n-    }\n-}\n-\n-impl Listener<TcpAcceptor> for TcpListener {\n-    fn listen(self) -> IoResult<TcpAcceptor> {\n-        self.inner.listen(128).map(|a| TcpAcceptor { inner: a })\n-    }\n-}\n-\n-impl sys_common::AsInner<TcpListenerImp> for TcpListener {\n-    fn as_inner(&self) -> &TcpListenerImp {\n-        &self.inner\n-    }\n-}\n-\n-/// The accepting half of a TCP socket server. This structure is created through\n-/// a `TcpListener`'s `listen` method, and this object can be used to accept new\n-/// `TcpStream` instances.\n-pub struct TcpAcceptor {\n-    inner: TcpAcceptorImp,\n-}\n-\n-impl TcpAcceptor {\n-    /// Prevents blocking on all future accepts after `ms` milliseconds have\n-    /// elapsed.\n-    ///\n-    /// This function is used to set a deadline after which this acceptor will\n-    /// time out accepting any connections. The argument is the relative\n-    /// distance, in milliseconds, to a point in the future after which all\n-    /// accepts will fail.\n-    ///\n-    /// If the argument specified is `None`, then any previously registered\n-    /// timeout is cleared.\n-    ///\n-    /// A timeout of `0` can be used to \"poll\" this acceptor to see if it has\n-    /// any pending connections. All pending connections will be accepted,\n-    /// regardless of whether the timeout has expired or not (the accept will\n-    /// not block in this case).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_io, io)]\n-    /// use std::old_io::*;\n-    ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n-    ///\n-    /// // After 100ms have passed, all accepts will fail\n-    /// a.set_timeout(Some(100));\n-    ///\n-    /// match a.accept() {\n-    ///     Ok(..) => println!(\"accepted a socket\"),\n-    ///     Err(ref e) if e.kind == TimedOut => { println!(\"timed out!\"); }\n-    ///     Err(e) => println!(\"err: {}\", e),\n-    /// }\n-    ///\n-    /// // Reset the timeout and try again\n-    /// a.set_timeout(Some(100));\n-    /// let socket = a.accept();\n-    ///\n-    /// // Clear the timeout and block indefinitely waiting for a connection\n-    /// a.set_timeout(None);\n-    /// let socket = a.accept();\n-    /// ```\n-    #[unstable(feature = \"io\",\n-               reason = \"the type of the argument and name of this function are \\\n-                         subject to change\")]\n-    pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n-\n-    /// Closes the accepting capabilities of this acceptor.\n-    ///\n-    /// This function is similar to `TcpStream`'s `close_{read,write}` methods\n-    /// in that it will affect *all* cloned handles of this acceptor's original\n-    /// handle.\n-    ///\n-    /// Once this function succeeds, all future calls to `accept` will return\n-    /// immediately with an error, preventing all future calls to accept. The\n-    /// underlying socket will not be relinquished back to the OS until all\n-    /// acceptors have been deallocated.\n-    ///\n-    /// This is useful for waking up a thread in an accept loop to indicate that\n-    /// it should exit.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, io)]\n-    /// use std::old_io::*;\n-    /// use std::thread;\n-    ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n-    /// let a2 = a.clone();\n-    ///\n-    /// let _t = thread::spawn(move|| {\n-    ///     let mut a2 = a2;\n-    ///     for socket in a2.incoming() {\n-    ///         match socket {\n-    ///             Ok(s) => { /* handle s */ }\n-    ///             Err(ref e) if e.kind == EndOfFile => break, // closed\n-    ///             Err(e) => panic!(\"unexpected error: {}\", e),\n-    ///         }\n-    ///     }\n-    /// });\n-    ///\n-    /// # fn wait_for_sigint() {}\n-    /// // Now that our accept loop is running, wait for the program to be\n-    /// // requested to exit.\n-    /// wait_for_sigint();\n-    ///\n-    /// // Signal our accept loop to exit\n-    /// assert!(a.close_accept().is_ok());\n-    /// ```\n-    #[unstable(feature = \"io\")]\n-    pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.close_accept()\n-    }\n-}\n-\n-impl Acceptor for TcpAcceptor {\n-    type Connection = TcpStream;\n-    fn accept(&mut self) -> IoResult<TcpStream> {\n-        self.inner.accept().map(TcpStream::new)\n-    }\n-}\n-\n-impl Clone for TcpAcceptor {\n-    /// Creates a new handle to this TCP acceptor, allowing for simultaneous\n-    /// accepts.\n-    ///\n-    /// The underlying TCP acceptor will not be closed until all handles to the\n-    /// acceptor have been deallocated. Incoming connections will be received on\n-    /// at most once acceptor, the same connection will not be accepted twice.\n-    ///\n-    /// The `close_accept` method will shut down *all* acceptors cloned from the\n-    /// same original acceptor, whereas the `set_timeout` method only affects\n-    /// the selector that it is called on.\n-    ///\n-    /// This function is useful for creating a handle to invoke `close_accept`\n-    /// on to wake up any other task blocked in `accept`.\n-    fn clone(&self) -> TcpAcceptor {\n-        TcpAcceptor { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n-    fn as_inner(&self) -> &TcpAcceptorImp {\n-        &self.inner\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use sync::mpsc::channel;\n-    use thread;\n-    use old_io::net::tcp::*;\n-    use old_io::net::ip::*;\n-    use old_io::test::*;\n-    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError};\n-    use old_io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n-    use old_io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n-    use old_io::{InvalidInput};\n-    use old_io::{Acceptor, Listener};\n-    use old_io::{Reader, Writer};\n-\n-    // FIXME #11530 this fails on android because tests are run as root\n-    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n-    #[test]\n-    fn bind_error() {\n-        match TcpListener::bind(\"0.0.0.0:1\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, PermissionDenied),\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_error() {\n-        match TcpStream::connect(\"0.0.0.0:1\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert!((e.kind == ConnectionRefused)\n-                              || (e.kind == InvalidInput)),\n-        }\n-    }\n-\n-    #[test]\n-    fn listen_ip4_localhost() {\n-        let socket_addr = next_test_ip4();\n-        let listener = TcpListener::bind(socket_addr);\n-        let mut acceptor = listener.listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n-            stream.write(&[144]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 144);\n-    }\n-\n-    #[test]\n-    fn connect_localhost() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"localhost\", addr.port));\n-            stream.write(&[64]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 64);\n-    }\n-\n-    #[test]\n-    fn connect_ip4_loopback() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n-            stream.write(&[44]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 44);\n-    }\n-\n-    #[test]\n-    fn connect_ip6_loopback() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"::1\", addr.port));\n-            stream.write(&[66]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 66);\n-    }\n-\n-    #[test]\n-    fn smoke_test_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect(addr);\n-            stream.write(&[99]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 99);\n-    }\n-\n-    #[test]\n-    fn smoke_test_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect(addr);\n-            stream.write(&[99]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 99);\n-    }\n-\n-    #[test]\n-    fn read_eof_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-    }\n-\n-    #[test]\n-    fn read_eof_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-    }\n-\n-    #[test]\n-    fn read_eof_twice_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-\n-        match stream.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(ref e) => {\n-                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n-                        \"unknown kind: {:?}\", e.kind);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn read_eof_twice_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-\n-        match stream.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(ref e) => {\n-                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n-                        \"unknown kind: {:?}\", e.kind);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn write_close_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            drop(TcpStream::connect(addr));\n-            tx.send(()).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        rx.recv().unwrap();\n-        let buf = [0];\n-        match stream.write(&buf) {\n-            Ok(..) => {}\n-            Err(e) => {\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {}\", e);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn write_close_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            drop(TcpStream::connect(addr));\n-            tx.send(()).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        rx.recv().unwrap();\n-        let buf = [0];\n-        match stream.write(&buf) {\n-            Ok(..) => {}\n-            Err(e) => {\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {}\", e);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_serial_ip4() {\n-        let addr = next_test_ip4();\n-        let max = 10;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..max {\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write(&[99]).unwrap();\n-            }\n-        });\n-\n-        for ref mut stream in acceptor.incoming().take(max) {\n-            let mut buf = [0];\n-            stream.read(&mut buf).unwrap();\n-            assert_eq!(buf[0], 99);\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_serial_ip6() {\n-        let addr = next_test_ip6();\n-        let max = 10;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..max {\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write(&[99]).unwrap();\n-            }\n-        });\n-\n-        for ref mut stream in acceptor.incoming().take(max) {\n-            let mut buf = [0];\n-            stream.read(&mut buf).unwrap();\n-            assert_eq!(buf[0], 99);\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n-        let addr = next_test_ip4();\n-        static MAX: isize = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == i as u8);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[i as u8]).unwrap();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n-        let addr = next_test_ip6();\n-        static MAX: isize = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == i as u8);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[i as u8]).unwrap();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        static MAX: isize = 10;\n-        let addr = next_test_ip4();\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == 99);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[99]).unwrap();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        static MAX: isize = 10;\n-        let addr = next_test_ip6();\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == 99);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[99]).unwrap();\n-            });\n-        }\n-    }\n-\n-    pub fn socket_name(addr: SocketAddr) {\n-        let mut listener = TcpListener::bind(addr).unwrap();\n-\n-        // Make sure socket_name gives\n-        // us the socket we binded to.\n-        let so_name = listener.socket_name();\n-        assert!(so_name.is_ok());\n-        assert_eq!(addr, so_name.unwrap());\n-    }\n-\n-    pub fn peer_name(addr: SocketAddr) {\n-        let acceptor = TcpListener::bind(addr).listen();\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            acceptor.accept().unwrap();\n-        });\n-\n-        let stream = TcpStream::connect(addr);\n-\n-        assert!(stream.is_ok());\n-        let mut stream = stream.unwrap();\n-\n-        // Make sure peer_name gives us the\n-        // address/port of the peer we've\n-        // connected to.\n-        let peer_name = stream.peer_name();\n-        assert!(peer_name.is_ok());\n-        assert_eq!(addr, peer_name.unwrap());\n-    }\n-\n-    #[test]\n-    fn socket_and_peer_name_ip4() {\n-        peer_name(next_test_ip4());\n-        socket_name(next_test_ip4());\n-    }\n-\n-    #[test]\n-    fn socket_and_peer_name_ip6() {\n-        // FIXME: peer name is not consistent\n-        //peer_name(next_test_ip6());\n-        socket_name(next_test_ip6());\n-    }\n-\n-    #[test]\n-    fn partial_read() {\n-        let addr = next_test_ip4();\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut srv = TcpListener::bind(addr).listen().unwrap();\n-            tx.send(()).unwrap();\n-            let mut cl = srv.accept().unwrap();\n-            cl.write(&[10]).unwrap();\n-            let mut b = [0];\n-            cl.read(&mut b).unwrap();\n-            tx.send(()).unwrap();\n-        });\n-\n-        rx.recv().unwrap();\n-        let mut c = TcpStream::connect(addr).unwrap();\n-        let mut b = [0; 10];\n-        assert_eq!(c.read(&mut b), Ok(1));\n-        c.write(&[1]).unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn double_bind() {\n-        let addr = next_test_ip4();\n-        let listener = TcpListener::bind(addr).unwrap().listen();\n-        assert!(listener.is_ok());\n-        match TcpListener::bind(addr).listen() {\n-            Ok(..) => panic!(),\n-            Err(e) => {\n-                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n-                        \"unknown error: {} {:?}\", e, e.kind);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn fast_rebind() {\n-        let addr = next_test_ip4();\n-        let (tx, rx) = channel();\n-\n-        let _t = thread::spawn(move|| {\n-            rx.recv().unwrap();\n-            let _stream = TcpStream::connect(addr).unwrap();\n-            // Close\n-            rx.recv().unwrap();\n-        });\n-\n-        {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            tx.send(()).unwrap();\n-            {\n-                let _stream = acceptor.accept().unwrap();\n-                // Close client\n-                tx.send(()).unwrap();\n-            }\n-            // Close listener\n-        }\n-        let _listener = TcpListener::bind(addr);\n-    }\n-\n-    #[test]\n-    fn tcp_clone_smoke() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr);\n-            let mut buf = [0, 0];\n-            assert_eq!(s.read(&mut buf), Ok(1));\n-            assert_eq!(buf[0], 1);\n-            s.write(&[2]).unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            rx1.recv().unwrap();\n-            s2.write(&[1]).unwrap();\n-            tx2.send(()).unwrap();\n-        });\n-        tx1.send(()).unwrap();\n-        let mut buf = [0, 0];\n-        assert_eq!(s1.read(&mut buf), Ok(1));\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn tcp_clone_two_read() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        let (tx1, rx) = channel();\n-        let tx2 = tx1.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr);\n-            s.write(&[1]).unwrap();\n-            rx.recv().unwrap();\n-            s.write(&[2]).unwrap();\n-            rx.recv().unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            let mut buf = [0, 0];\n-            s2.read(&mut buf).unwrap();\n-            tx2.send(()).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        let mut buf = [0, 0];\n-        s1.read(&mut buf).unwrap();\n-        tx1.send(()).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn tcp_clone_two_write() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr);\n-            let mut buf = [0, 1];\n-            s.read(&mut buf).unwrap();\n-            s.read(&mut buf).unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            s2.write(&[1]).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        s1.write(&[2]).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn shutdown_smoke() {\n-        let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).unwrap().listen();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            let mut c = a.accept().unwrap();\n-            assert_eq!(c.read_to_end(), Ok(vec!()));\n-            c.write(&[1]).unwrap();\n-        });\n-\n-        let mut s = TcpStream::connect(addr).unwrap();\n-        assert!(s.inner.close_write().is_ok());\n-        assert!(s.write(&[1]).is_err());\n-        assert_eq!(s.read_to_end(), Ok(vec!(1)));\n-    }\n-\n-    #[test]\n-    fn accept_timeout() {\n-        let addr = next_test_ip4();\n-        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n-\n-        a.set_timeout(Some(10));\n-\n-        // Make sure we time out once and future invocations also time out\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-\n-        // Also make sure that even though the timeout is expired that we will\n-        // continue to receive any pending connections.\n-        //\n-        // FIXME: freebsd apparently never sees the pending connection, but\n-        //        testing manually always works. Need to investigate this\n-        //        flakiness.\n-        if !cfg!(target_os = \"freebsd\") {\n-            let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n-                tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n-            });\n-            let _l = rx.recv().unwrap();\n-            for i in 0..1001 {\n-                match a.accept() {\n-                    Ok(..) => break,\n-                    Err(ref e) if e.kind == TimedOut => {}\n-                    Err(e) => panic!(\"error: {}\", e),\n-                }\n-                ::thread::yield_now();\n-                if i == 1000 { panic!(\"should have a pending connection\") }\n-            }\n-        }\n-\n-        // Unset the timeout and make sure that this always blocks.\n-        a.set_timeout(None);\n-        let _t = thread::spawn(move|| {\n-            drop(TcpStream::connect(addr).unwrap());\n-        });\n-        a.accept().unwrap();\n-    }\n-\n-    #[test]\n-    fn close_readwrite_smoke() {\n-        let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv().unwrap();\n-        });\n-\n-        let mut b = [0];\n-        let mut s = TcpStream::connect(addr).unwrap();\n-        let mut s2 = s.clone();\n-\n-        // closing should prevent reads/writes\n-        s.close_write().unwrap();\n-        assert!(s.write(&[0]).is_err());\n-        s.close_read().unwrap();\n-        assert!(s.read(&mut b).is_err());\n-\n-        // closing should affect previous handles\n-        assert!(s2.write(&[0]).is_err());\n-        assert!(s2.read(&mut b).is_err());\n-\n-        // closing should affect new handles\n-        let mut s3 = s.clone();\n-        assert!(s3.write(&[0]).is_err());\n-        assert!(s3.read(&mut b).is_err());\n-\n-        // make sure these don't die\n-        let _ = s2.close_read();\n-        let _ = s2.close_write();\n-        let _ = s3.close_read();\n-        let _ = s3.close_write();\n-    }\n-\n-    #[test]\n-    fn close_read_wakes_up() {\n-        let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv().unwrap();\n-        });\n-\n-        let mut s = TcpStream::connect(addr).unwrap();\n-        let s2 = s.clone();\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert!(s2.read(&mut [0]).is_err());\n-            tx.send(()).unwrap();\n-        });\n-        // this should wake up the child task\n-        s.close_read().unwrap();\n-\n-        // this test will never finish if the child doesn't wake up\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn readwrite_timeouts() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        s.set_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-        assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        s.set_timeout(None);\n-        assert_eq!(s.read(&mut [0, 0]), Ok(1));\n-    }\n-\n-    #[test]\n-    fn read_timeouts() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            let mut amt = 0;\n-            while amt < 100 * 128 * 1024 {\n-                match s.read(&mut [0;128 * 1024]) {\n-                    Ok(n) => { amt += n; }\n-                    Err(e) => panic!(\"{}\", e),\n-                }\n-            }\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        for _ in 0..100 {\n-            assert!(s.write(&[0;128 * 1024]).is_ok());\n-        }\n-    }\n-\n-    #[test]\n-    fn write_timeouts() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_write_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-        assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        assert!(s.read(&mut [0]).is_ok());\n-    }\n-\n-    #[test]\n-    fn timeout_concurrent_read() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            assert_eq!(s.write(&[0]), Ok(()));\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        let s2 = s.clone();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert_eq!(s2.read(&mut [0]), Ok(1));\n-            tx2.send(()).unwrap();\n-        });\n-\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(()).unwrap();\n-\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn clone_while_reading() {\n-        let addr = next_test_ip6();\n-        let listen = TcpListener::bind(addr);\n-        let mut accept = listen.listen().unwrap();\n-\n-        // Enqueue a task to write to a socket\n-        let (tx, rx) = channel();\n-        let (txdone, rxdone) = channel();\n-        let txdone2 = txdone.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut tcp = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            tcp.write_u8(0).unwrap();\n-            txdone2.send(()).unwrap();\n-        });\n-\n-        // Spawn off a reading clone\n-        let tcp = accept.accept().unwrap();\n-        let tcp2 = tcp.clone();\n-        let txdone3 = txdone.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut tcp2 = tcp2;\n-            tcp2.read_u8().unwrap();\n-            txdone3.send(()).unwrap();\n-        });\n-\n-        // Try to ensure that the reading clone is indeed reading\n-        for _ in 0..50 {\n-            ::thread::yield_now();\n-        }\n-\n-        // clone the handle again while it's reading, then let it finish the\n-        // read.\n-        let _ = tcp.clone();\n-        tx.send(()).unwrap();\n-        rxdone.recv().unwrap();\n-        rxdone.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn clone_accept_smoke() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let mut a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-\n-        assert!(a.accept().is_ok());\n-        assert!(a2.accept().is_ok());\n-    }\n-\n-    #[test]\n-    fn clone_accept_concurrent() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let a = l.listen().unwrap();\n-        let a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let tx2 = tx.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap();\n-        });\n-        let _t = thread::spawn(move|| {\n-            let mut a = a2;\n-            tx2.send(a.accept()).unwrap();\n-        });\n-\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-\n-        assert!(rx.recv().unwrap().is_ok());\n-        assert!(rx.recv().unwrap().is_ok());\n-    }\n-\n-    #[test]\n-    fn close_accept_smoke() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let mut a = l.listen().unwrap();\n-\n-        a.close_accept().unwrap();\n-        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n-    }\n-\n-    #[test]\n-    fn close_accept_concurrent() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap();\n-        });\n-        a2.close_accept().unwrap();\n-\n-        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n-    }\n-}"}, {"sha": "196447d71efbf8ff598cf6fa4bb564365aa790b1", "filename": "src/libstd/old_io/net/udp.rs", "status": "removed", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,459 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! UDP (User Datagram Protocol) network connections.\n-//!\n-//! This module contains the ability to open a UDP stream to a socket address.\n-//! The destination and binding addresses can either be an IPv4 or IPv6\n-//! address. There is no corresponding notion of a server because UDP is a\n-//! datagram protocol.\n-\n-use clone::Clone;\n-use old_io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use old_io::IoResult;\n-use option::Option;\n-use sys::udp::UdpSocket as UdpSocketImp;\n-use sys_common;\n-\n-/// A User Datagram Protocol socket.\n-///\n-/// This is an implementation of a bound UDP socket. This supports both IPv4 and\n-/// IPv6 addresses, and there is no corresponding notion of a server because UDP\n-/// is a datagram protocol.\n-///\n-/// # Examples\n-///\n-/// ```rust,no_run\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-///\n-/// use std::old_io::net::udp::UdpSocket;\n-/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n-/// fn main() {\n-///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-///     let mut socket = match UdpSocket::bind(addr) {\n-///         Ok(s) => s,\n-///         Err(e) => panic!(\"couldn't bind socket: {}\", e),\n-///     };\n-///\n-///     let mut buf = [0; 10];\n-///     match socket.recv_from(&mut buf) {\n-///         Ok((amt, src)) => {\n-///             // Send a reply to the socket we received data from\n-///             let buf = &mut buf[..amt];\n-///             buf.reverse();\n-///             socket.send_to(buf, src);\n-///         }\n-///         Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n-///     }\n-///     drop(socket); // close the socket\n-/// }\n-/// ```\n-pub struct UdpSocket {\n-    inner: UdpSocketImp,\n-}\n-\n-impl UdpSocket {\n-    /// Creates a UDP socket from the given address.\n-    ///\n-    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n-    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> {\n-        super::with_addresses(addr, |addr| {\n-            UdpSocketImp::bind(addr).map(|s| UdpSocket { inner: s })\n-        })\n-    }\n-\n-    /// Receives data from the socket. On success, returns the number of bytes\n-    /// read and the address from whence the data came.\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n-        self.inner.recv_from(buf)\n-    }\n-\n-    /// Sends data on the socket to the given address. Returns nothing on\n-    /// success.\n-    ///\n-    /// Address type can be any implementer of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n-    pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> {\n-        super::with_addresses(addr, |addr| self.inner.send_to(buf, addr))\n-    }\n-\n-    /// Returns the socket address that this socket was created from.\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.socket_name()\n-    }\n-\n-    /// Joins a multicast IP address (becomes a member of it)\n-    #[unstable(feature = \"io\")]\n-    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.inner.join_multicast(multi)\n-    }\n-\n-    /// Leaves a multicast IP address (drops membership from it)\n-    #[unstable(feature = \"io\")]\n-    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.inner.leave_multicast(multi)\n-    }\n-\n-    /// Set the multicast loop flag to the specified value\n-    ///\n-    /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[unstable(feature = \"io\")]\n-    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        self.inner.set_multicast_loop(on)\n-    }\n-\n-    /// Sets the multicast TTL\n-    #[unstable(feature = \"io\")]\n-    pub fn set_multicast_ttl(&mut self, ttl: isize) -> IoResult<()> {\n-        self.inner.multicast_time_to_live(ttl)\n-    }\n-\n-    /// Sets this socket's TTL\n-    #[unstable(feature = \"io\")]\n-    pub fn set_ttl(&mut self, ttl: isize) -> IoResult<()> {\n-        self.inner.time_to_live(ttl)\n-    }\n-\n-    /// Sets the broadcast flag on or off\n-    #[unstable(feature = \"io\")]\n-    pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n-        self.inner.set_broadcast(broadcast)\n-    }\n-\n-    /// Sets the read/write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the read timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_read_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_write_timeout(timeout_ms)\n-    }\n-}\n-\n-impl Clone for UdpSocket {\n-    /// Creates a new handle to this UDP socket, allowing for simultaneous\n-    /// reads and writes of the socket.\n-    ///\n-    /// The underlying UDP socket will not be closed until all handles to the\n-    /// socket have been deallocated. Two concurrent reads will not receive\n-    /// the same data. Instead, the first read will receive the first packet\n-    /// received, and the second read will receive the second packet.\n-    fn clone(&self) -> UdpSocket {\n-        UdpSocket {\n-            inner: self.inner.clone(),\n-        }\n-    }\n-}\n-\n-impl sys_common::AsInner<UdpSocketImp> for UdpSocket {\n-    fn as_inner(&self) -> &UdpSocketImp {\n-        &self.inner\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use sync::mpsc::channel;\n-    use old_io::net::ip::*;\n-    use old_io::test::*;\n-    use old_io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n-    use super::*;\n-    use thread;\n-\n-    // FIXME #11530 this fails on android because tests are run as root\n-    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n-    #[test]\n-    fn bind_error() {\n-        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-        match UdpSocket::bind(addr) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, PermissionDenied),\n-        }\n-    }\n-\n-    #[test]\n-    fn socket_smoke_test_ip4() {\n-        let server_ip = next_test_ip4();\n-        let client_ip = next_test_ip4();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-\n-        let _t = thread::spawn(move|| {\n-            match UdpSocket::bind(client_ip) {\n-                Ok(ref mut client) => {\n-                    rx1.recv().unwrap();\n-                    client.send_to(&[99], server_ip).unwrap()\n-                }\n-                Err(..) => panic!()\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        match UdpSocket::bind(server_ip) {\n-            Ok(ref mut server) => {\n-                tx1.send(()).unwrap();\n-                let mut buf = [0];\n-                match server.recv_from(&mut buf) {\n-                    Ok((nread, src)) => {\n-                        assert_eq!(nread, 1);\n-                        assert_eq!(buf[0], 99);\n-                        assert_eq!(src, client_ip);\n-                    }\n-                    Err(..) => panic!()\n-                }\n-            }\n-            Err(..) => panic!()\n-        }\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn socket_smoke_test_ip6() {\n-        let server_ip = next_test_ip6();\n-        let client_ip = next_test_ip6();\n-        let (tx, rx) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            match UdpSocket::bind(client_ip) {\n-                Ok(ref mut client) => {\n-                    rx.recv().unwrap();\n-                    client.send_to(&[99], server_ip).unwrap()\n-                }\n-                Err(..) => panic!()\n-            }\n-        });\n-\n-        match UdpSocket::bind(server_ip) {\n-            Ok(ref mut server) => {\n-                tx.send(()).unwrap();\n-                let mut buf = [0];\n-                match server.recv_from(&mut buf) {\n-                    Ok((nread, src)) => {\n-                        assert_eq!(nread, 1);\n-                        assert_eq!(buf[0], 99);\n-                        assert_eq!(src, client_ip);\n-                    }\n-                    Err(..) => panic!()\n-                }\n-            }\n-            Err(..) => panic!()\n-        }\n-    }\n-\n-    pub fn socket_name(addr: SocketAddr) {\n-        let server = UdpSocket::bind(addr);\n-\n-        assert!(server.is_ok());\n-        let mut server = server.unwrap();\n-\n-        // Make sure socket_name gives\n-        // us the socket we binded to.\n-        let so_name = server.socket_name();\n-        assert!(so_name.is_ok());\n-        assert_eq!(addr, so_name.unwrap());\n-    }\n-\n-    #[test]\n-    fn socket_name_ip4() {\n-        socket_name(next_test_ip4());\n-    }\n-\n-    #[test]\n-    fn socket_name_ip6() {\n-        socket_name(next_test_ip6());\n-    }\n-\n-    #[test]\n-    fn udp_clone_smoke() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n-        let sock2 = UdpSocket::bind(addr2).unwrap();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut sock2 = sock2;\n-            let mut buf = [0, 0];\n-            assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n-            assert_eq!(buf[0], 1);\n-            sock2.send_to(&[2], addr1).unwrap();\n-        });\n-\n-        let sock3 = sock1.clone();\n-\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut sock3 = sock3;\n-            rx1.recv().unwrap();\n-            sock3.send_to(&[1], addr2).unwrap();\n-            tx2.send(()).unwrap();\n-        });\n-        tx1.send(()).unwrap();\n-        let mut buf = [0, 0];\n-        assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn udp_clone_two_read() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n-        let sock2 = UdpSocket::bind(addr2).unwrap();\n-        let (tx1, rx) = channel();\n-        let tx2 = tx1.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut sock2 = sock2;\n-            sock2.send_to(&[1], addr1).unwrap();\n-            rx.recv().unwrap();\n-            sock2.send_to(&[2], addr1).unwrap();\n-            rx.recv().unwrap();\n-        });\n-\n-        let sock3 = sock1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut sock3 = sock3;\n-            let mut buf = [0, 0];\n-            sock3.recv_from(&mut buf).unwrap();\n-            tx2.send(()).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        let mut buf = [0, 0];\n-        sock1.recv_from(&mut buf).unwrap();\n-        tx1.send(()).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn udp_clone_two_write() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n-        let sock2 = UdpSocket::bind(addr2).unwrap();\n-\n-        let (tx, rx) = channel();\n-        let (serv_tx, serv_rx) = channel();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut sock2 = sock2;\n-            let mut buf = [0, 1];\n-\n-            rx.recv().unwrap();\n-            match sock2.recv_from(&mut buf) {\n-                Ok(..) => {}\n-                Err(e) => panic!(\"failed receive: {}\", e),\n-            }\n-            serv_tx.send(()).unwrap();\n-        });\n-\n-        let sock3 = sock1.clone();\n-\n-        let (done, rx) = channel();\n-        let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut sock3 = sock3;\n-            match sock3.send_to(&[1], addr2) {\n-                Ok(..) => { let _ = tx2.send(()); }\n-                Err(..) => {}\n-            }\n-            done.send(()).unwrap();\n-        });\n-        match sock1.send_to(&[2], addr2) {\n-            Ok(..) => { let _ = tx.send(()); }\n-            Err(..) => {}\n-        }\n-        drop(tx);\n-\n-        rx.recv().unwrap();\n-        serv_rx.recv().unwrap();\n-    }\n-\n-    #[cfg(not(windows))] // FIXME #17553\n-    #[test]\n-    fn recv_from_timeout() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut a = UdpSocket::bind(addr1).unwrap();\n-        let a2 = UdpSocket::bind(addr2).unwrap();\n-\n-        let (tx, rx) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a2;\n-            assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n-            assert_eq!(a.send_to(&[0], addr1), Ok(()));\n-            rx.recv().unwrap();\n-            assert_eq!(a.send_to(&[0], addr1), Ok(()));\n-\n-            tx2.send(()).unwrap();\n-        });\n-\n-        // Make sure that reads time out, but writes can continue\n-        a.set_read_timeout(Some(20));\n-        assert_eq!(a.recv_from(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.recv_from(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.send_to(&[0], addr2), Ok(()));\n-\n-        // Cloned handles should be able to block\n-        let mut a2 = a.clone();\n-        assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n-\n-        // Clearing the timeout should allow for receiving\n-        a.set_timeout(None);\n-        tx.send(()).unwrap();\n-        assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n-\n-        // Make sure the child didn't die\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn send_to_timeout() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut a = UdpSocket::bind(addr1).unwrap();\n-        let _b = UdpSocket::bind(addr2).unwrap();\n-\n-        a.set_write_timeout(Some(1000));\n-        for _ in 0..100 {\n-            match a.send_to(&[0;4*1024], addr2) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"other error: {}\", e),\n-            }\n-        }\n-    }\n-}"}, {"sha": "fd1df49473e586d4bd6c40b8a497bf1a1937d963", "filename": "src/libstd/old_io/pipe.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,141 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous, in-memory pipes.\n-//!\n-//! Currently these aren't particularly useful, there only exists bindings\n-//! enough so that pipes can be created to child processes.\n-\n-#![allow(missing_docs)]\n-\n-use prelude::v1::*;\n-\n-use old_io::{IoResult, Reader, Writer};\n-use libc;\n-use sync::Arc;\n-\n-use sys_common;\n-use sys;\n-use sys::fs::FileDesc as FileDesc;\n-\n-/// A synchronous, in-memory pipe.\n-pub struct PipeStream {\n-    inner: Arc<FileDesc>\n-}\n-\n-pub struct PipePair {\n-    pub reader: PipeStream,\n-    pub writer: PipeStream,\n-}\n-\n-impl PipeStream {\n-    /// Consumes a file descriptor to return a pipe stream that will have\n-    /// synchronous, but non-blocking reads/writes. This is useful if the file\n-    /// descriptor is acquired via means other than the standard methods.\n-    ///\n-    /// This operation consumes ownership of the file descriptor and it will be\n-    /// closed once the object is deallocated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```{rust,no_run}\n-    /// # #![feature(old_io, libc, io)]\n-    /// # #![allow(unused_must_use)]\n-    /// extern crate libc;\n-    ///\n-    /// use std::old_io::*;\n-    ///\n-    /// fn main() {\n-    ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n-    ///     pipe.write(b\"Hello, stderr!\");\n-    /// }\n-    /// ```\n-    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n-        Ok(PipeStream::from_filedesc(FileDesc::new(fd, true)))\n-    }\n-\n-    // FIXME: expose this some other way\n-    /// Wrap a FileDesc directly, taking ownership.\n-    #[doc(hidden)]\n-    pub fn from_filedesc(fd: FileDesc) -> PipeStream {\n-        PipeStream { inner: Arc::new(fd) }\n-    }\n-\n-    /// Creates a pair of in-memory OS pipes for a unidirectional communication\n-    /// stream.\n-    ///\n-    /// The structure returned contains a reader and writer I/O object. Data\n-    /// written to the writer can be read from the reader.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function can fail to succeed if the underlying OS has run out of\n-    /// available resources to allocate a new pipe.\n-    pub fn pair() -> IoResult<PipePair> {\n-        let (reader, writer) = try!(unsafe { sys::os::pipe() });\n-        Ok(PipePair {\n-            reader: PipeStream::from_filedesc(reader),\n-            writer: PipeStream::from_filedesc(writer),\n-        })\n-    }\n-}\n-\n-impl sys_common::AsInner<sys::fs::FileDesc> for PipeStream {\n-    fn as_inner(&self) -> &sys::fs::FileDesc {\n-        &*self.inner\n-    }\n-}\n-\n-impl Clone for PipeStream {\n-    fn clone(&self) -> PipeStream {\n-        PipeStream { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl Writer for PipeStream {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.write(buf)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use old_io::{Writer, Reader};\n-    use sync::mpsc::channel;\n-    use thread;\n-\n-    #[test]\n-    fn partial_read() {\n-        use os;\n-        use old_io::pipe::PipeStream;\n-\n-        let (reader, writer) = unsafe { ::sys::os::pipe().unwrap() };\n-        let out = PipeStream::open(writer.unwrap());\n-        let mut input = PipeStream::open(reader.unwrap());\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut out = out;\n-            out.write(&[10]).unwrap();\n-            rx.recv().unwrap(); // don't close the pipe until the other read has finished\n-        });\n-\n-        let mut buf = [0; 10];\n-        input.read(&mut buf).unwrap();\n-        tx.send(()).unwrap();\n-    }\n-}"}, {"sha": "b55d1f4db07f78e6e5c57480c557d4192828dca1", "filename": "src/libstd/old_io/process.rs", "status": "removed", "additions": 0, "deletions": 1239, "changes": 1239, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,1239 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Bindings for executing child processes\n-\n-#![allow(non_upper_case_globals)]\n-#![unstable(feature = \"old_io\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"replaced with the std::process module\")]\n-\n-pub use self::StdioContainer::*;\n-pub use self::ProcessExit::*;\n-\n-use prelude::v1::*;\n-\n-use collections::HashMap;\n-use ffi::CString;\n-use fmt;\n-use old_io::pipe::{PipeStream, PipePair};\n-use old_io::{IoResult, IoError, Reader, Writer};\n-use old_io;\n-use old_path::{Path, GenericPath};\n-use libc;\n-use os;\n-use old_path::BytesContainer;\n-use sync::mpsc::{channel, Receiver};\n-use sys::fs::FileDesc;\n-use sys::process::Process as ProcessImp;\n-use sys;\n-use thread;\n-\n-#[cfg(windows)] use hash;\n-#[cfg(windows)] use str;\n-\n-/// Signal a process to exit, without forcibly killing it. Corresponds to\n-/// SIGTERM on unix platforms.\n-#[cfg(windows)] pub const PleaseExitSignal: isize = 15;\n-/// Signal a process to exit immediately, forcibly killing it. Corresponds to\n-/// SIGKILL on unix platforms.\n-#[cfg(windows)] pub const MustDieSignal: isize = 9;\n-/// Signal a process to exit, without forcibly killing it. Corresponds to\n-/// SIGTERM on unix platforms.\n-#[cfg(not(windows))] pub const PleaseExitSignal: isize = libc::SIGTERM as isize;\n-/// Signal a process to exit immediately, forcibly killing it. Corresponds to\n-/// SIGKILL on unix platforms.\n-#[cfg(not(windows))] pub const MustDieSignal: isize = libc::SIGKILL as isize;\n-\n-/// Representation of a running or exited child process.\n-///\n-/// This structure is used to represent and manage child processes. A child\n-/// process is created via the `Command` struct, which configures the spawning\n-/// process and can itself be constructed using a builder-style interface.\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// # #![feature(old_io)]\n-/// use std::old_io::*;\n-///\n-/// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n-///     Ok(child) => child,\n-///     Err(e) => panic!(\"failed to execute child: {}\", e),\n-/// };\n-///\n-/// let contents = child.stdout.as_mut().unwrap().read_to_end();\n-/// assert!(child.wait().unwrap().success());\n-/// ```\n-pub struct Process {\n-    handle: ProcessImp,\n-    forget: bool,\n-\n-    /// None until wait() is called.\n-    exit_code: Option<ProcessExit>,\n-\n-    /// Manually delivered signal\n-    exit_signal: Option<isize>,\n-\n-    /// Deadline after which wait() will return\n-    deadline: u64,\n-\n-    /// Handle to the child's stdin, if the `stdin` field of this process's\n-    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdin: Option<PipeStream>,\n-\n-    /// Handle to the child's stdout, if the `stdout` field of this process's\n-    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdout: Option<PipeStream>,\n-\n-    /// Handle to the child's stderr, if the `stderr` field of this process's\n-    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stderr: Option<PipeStream>,\n-}\n-\n-/// A representation of environment variable name\n-/// It compares case-insensitive on Windows and case-sensitive everywhere else.\n-#[cfg(not(windows))]\n-#[derive(Hash, PartialEq, Eq, Clone, Debug)]\n-struct EnvKey(CString);\n-\n-#[doc(hidden)]\n-#[cfg(windows)]\n-#[derive(Eq, Clone, Debug)]\n-struct EnvKey(CString);\n-\n-#[cfg(windows)]\n-impl hash::Hash for EnvKey {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        use ascii::AsciiExt;\n-        let &EnvKey(ref x) = self;\n-        match str::from_utf8(x.as_bytes()) {\n-            Ok(s) => for ch in s.chars() {\n-                ch.to_ascii_lowercase().hash(state);\n-            },\n-            Err(..) => x.hash(state)\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-impl PartialEq for EnvKey {\n-    fn eq(&self, other: &EnvKey) -> bool {\n-        use ascii::AsciiExt;\n-        let &EnvKey(ref x) = self;\n-        let &EnvKey(ref y) = other;\n-        match (str::from_utf8(x.as_bytes()), str::from_utf8(y.as_bytes())) {\n-            (Ok(xs), Ok(ys)) => {\n-                if xs.len() != ys.len() {\n-                    return false\n-                } else {\n-                    for (xch, ych) in xs.chars().zip(ys.chars()) {\n-                        if xch.to_ascii_lowercase() != ych.to_ascii_lowercase() {\n-                            return false;\n-                        }\n-                    }\n-                    return true;\n-                }\n-            },\n-            // If either is not a valid utf8 string, just compare them byte-wise\n-            _ => return x.eq(y)\n-        }\n-    }\n-}\n-\n-impl BytesContainer for EnvKey {\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        let &EnvKey(ref k) = self;\n-        k.container_as_bytes()\n-    }\n-}\n-\n-/// A HashMap representation of environment variables.\n-pub type EnvMap = HashMap<EnvKey, CString>;\n-\n-/// The `Command` type acts as a process builder, providing fine-grained control\n-/// over how a new process should be spawned. A default configuration can be\n-/// generated using `Command::new(program)`, where `program` gives a path to the\n-/// program to be executed. Additional builder methods allow the configuration\n-/// to be changed (for example, by adding arguments) prior to spawning:\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io::*;\n-///\n-/// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n-///   Ok(p) => p,\n-///   Err(e) => panic!(\"failed to execute process: {}\", e),\n-/// };\n-///\n-/// let output = process.stdout.as_mut().unwrap().read_to_end();\n-/// ```\n-#[derive(Clone)]\n-pub struct Command {\n-    // The internal data for the builder. Documented by the builder\n-    // methods below, and serialized into rt::rtio::ProcessConfig.\n-    program: CString,\n-    args: Vec<CString>,\n-    env: Option<EnvMap>,\n-    cwd: Option<CString>,\n-    stdin: StdioContainer,\n-    stdout: StdioContainer,\n-    stderr: StdioContainer,\n-    uid: Option<usize>,\n-    gid: Option<usize>,\n-    detach: bool,\n-}\n-\n-// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take BytesContainer arguments by reference (without forcing an\n-// additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take BytesContainer as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by BytesContainer should be passed by\n-// reference. (Here: {new, arg, args, env}.)\n-\n-impl Command {\n-    /// Constructs a new `Command` for launching the program at\n-    /// path `program`, with the following default configuration:\n-    ///\n-    /// * No arguments to the program\n-    /// * Inherit the current process's environment\n-    /// * Inherit the current process's working directory\n-    /// * A readable pipe for stdin (file descriptor 0)\n-    /// * A writeable pipe for stdout and stderr (file descriptors 1 and 2)\n-    ///\n-    /// Builder methods are provided to change these defaults and\n-    /// otherwise configure the process.\n-    pub fn new<T: BytesContainer>(program: T) -> Command {\n-        Command {\n-            program: CString::new(program.container_as_bytes()).unwrap(),\n-            args: Vec::new(),\n-            env: None,\n-            cwd: None,\n-            stdin: CreatePipe(true, false),\n-            stdout: CreatePipe(false, true),\n-            stderr: CreatePipe(false, true),\n-            uid: None,\n-            gid: None,\n-            detach: false,\n-        }\n-    }\n-\n-    /// Add an argument to pass to the program.\n-    pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command {\n-        self.args.push(CString::new(arg.container_as_bytes()).unwrap());\n-        self\n-    }\n-\n-    /// Add multiple arguments to pass to the program.\n-    pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command {\n-        self.args.extend(args.iter().map(|arg| {\n-            CString::new(arg.container_as_bytes()).unwrap()\n-        }));\n-        self\n-    }\n-    // Get a mutable borrow of the environment variable map for this `Command`.\n-    #[allow(deprecated)]\n-    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n-        match self.env {\n-            Some(ref mut map) => map,\n-            None => {\n-                // if the env is currently just inheriting from the parent's,\n-                // materialize the parent's env into a hashtable.\n-                self.env = Some(::env::vars().map(|(k, v)| {\n-                    (EnvKey(CString::new(k).unwrap()),\n-                     CString::new(v).unwrap())\n-                }).collect());\n-                self.env.as_mut().unwrap()\n-            }\n-        }\n-    }\n-\n-    /// Inserts or updates an environment variable mapping.\n-    ///\n-    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n-    /// and case-sensitive on all other platforms.\n-    pub fn env<'a, T, U>(&'a mut self, key: T, val: U)\n-                         -> &'a mut Command\n-                         where T: BytesContainer, U: BytesContainer {\n-        let key = EnvKey(CString::new(key.container_as_bytes()).unwrap());\n-        let val = CString::new(val.container_as_bytes()).unwrap();\n-        self.get_env_map().insert(key, val);\n-        self\n-    }\n-\n-    /// Removes an environment variable mapping.\n-    pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command\n-                             where T: BytesContainer {\n-        let key = EnvKey(CString::new(key.container_as_bytes()).unwrap());\n-        self.get_env_map().remove(&key);\n-        self\n-    }\n-\n-    /// Sets the entire environment map for the child process.\n-    ///\n-    /// If the given slice contains multiple instances of an environment\n-    /// variable, the *rightmost* instance will determine the value.\n-    pub fn env_set_all<'a, T, U>(&'a mut self, env: &[(T,U)])\n-                                 -> &'a mut Command\n-                                 where T: BytesContainer, U: BytesContainer {\n-        self.env = Some(env.iter().map(|&(ref k, ref v)| {\n-            (EnvKey(CString::new(k.container_as_bytes()).unwrap()),\n-             CString::new(v.container_as_bytes()).unwrap())\n-        }).collect());\n-        self\n-    }\n-\n-    /// Set the working directory for the child process.\n-    pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command {\n-        self.cwd = Some(CString::new(dir.as_vec()).unwrap());\n-        self\n-    }\n-\n-    /// Configuration for the child process's stdin handle (file descriptor 0).\n-    /// Defaults to `CreatePipe(true, false)` so the input can be written to.\n-    pub fn stdin<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.stdin = cfg;\n-        self\n-    }\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 1).\n-    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n-    pub fn stdout<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.stdout = cfg;\n-        self\n-    }\n-\n-    /// Configuration for the child process's stderr handle (file descriptor 2).\n-    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n-    pub fn stderr<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.stderr = cfg;\n-        self\n-    }\n-\n-    /// Sets the child process's user id. This translates to a `setuid` call in\n-    /// the child process. Setting this value on windows will cause the spawn to\n-    /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n-    /// fail.\n-    pub fn uid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n-        self.uid = Some(id);\n-        self\n-    }\n-\n-    /// Similar to `uid`, but sets the group id of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    pub fn gid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n-        self.gid = Some(id);\n-        self\n-    }\n-\n-    /// Sets the child process to be spawned in a detached state. On unix, this\n-    /// means that the child is the leader of a new process group.\n-    pub fn detached<'a>(&'a mut self) -> &'a mut Command {\n-        self.detach = true;\n-        self\n-    }\n-\n-    /// Executes the command as a child process, which is returned.\n-    pub fn spawn(&self) -> IoResult<Process> {\n-        let (their_stdin, our_stdin) = try!(setup_io(self.stdin));\n-        let (their_stdout, our_stdout) = try!(setup_io(self.stdout));\n-        let (their_stderr, our_stderr) = try!(setup_io(self.stderr));\n-\n-        match ProcessImp::spawn(self, their_stdin, their_stdout, their_stderr) {\n-            Err(e) => Err(e),\n-            Ok(handle) => Ok(Process {\n-                handle: handle,\n-                forget: false,\n-                exit_code: None,\n-                exit_signal: None,\n-                deadline: 0,\n-                stdin: our_stdin,\n-                stdout: our_stdout,\n-                stderr: our_stderr,\n-            })\n-        }\n-    }\n-\n-    /// Executes the command as a child process, waiting for it to finish and\n-    /// collecting all of its output.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::Command;\n-    ///\n-    /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n-    ///     Ok(output) => output,\n-    ///     Err(e) => panic!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.output.as_ref()));\n-    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.error.as_ref()));\n-    /// ```\n-    pub fn output(&self) -> IoResult<ProcessOutput> {\n-        self.spawn().and_then(|p| p.wait_with_output())\n-    }\n-\n-    /// Executes a command as a child process, waiting for it to finish and\n-    /// collecting its exit status.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::Command;\n-    ///\n-    /// let status = match Command::new(\"ls\").status() {\n-    ///     Ok(status) => status,\n-    ///     Err(e) => panic!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// println!(\"process exited with: {}\", status);\n-    /// ```\n-    pub fn status(&self) -> IoResult<ProcessExit> {\n-        self.spawn().and_then(|mut p| p.wait())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Command {\n-    /// Format the program and arguments of a Command for display. Any\n-    /// non-utf8 data is lossily converted using the utf8 replacement\n-    /// character.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n-        for arg in &self.args {\n-            try!(write!(f, \" '{:?}'\", arg));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn setup_io(io: StdioContainer) -> IoResult<(Option<PipeStream>, Option<PipeStream>)> {\n-    let ours;\n-    let theirs;\n-    match io {\n-        Ignored => {\n-            theirs = None;\n-            ours = None;\n-        }\n-        InheritFd(fd) => {\n-            theirs = Some(PipeStream::from_filedesc(FileDesc::new(fd, false)));\n-            ours = None;\n-        }\n-        CreatePipe(readable, _writable) => {\n-            let PipePair { reader, writer } = try!(PipeStream::pair());\n-            if readable {\n-                theirs = Some(reader);\n-                ours = Some(writer);\n-            } else {\n-                theirs = Some(writer);\n-                ours = Some(reader);\n-            }\n-        }\n-    }\n-    Ok((theirs, ours))\n-}\n-\n-// Allow the sys module to get access to the Command state\n-impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n-    fn program(&self) -> &CString {\n-        &self.program\n-    }\n-    fn args(&self) -> &[CString] {\n-        &self.args\n-    }\n-    fn env(&self) -> Option<&EnvMap> {\n-        self.env.as_ref()\n-    }\n-    fn cwd(&self) -> Option<&CString> {\n-        self.cwd.as_ref()\n-    }\n-    fn uid(&self) -> Option<usize> {\n-        self.uid.clone()\n-    }\n-    fn gid(&self) -> Option<usize> {\n-        self.gid.clone()\n-    }\n-    fn detach(&self) -> bool {\n-        self.detach\n-    }\n-\n-}\n-\n-/// The output of a finished process.\n-#[derive(PartialEq, Eq, Clone)]\n-pub struct ProcessOutput {\n-    /// The status (exit code) of the process.\n-    pub status: ProcessExit,\n-    /// The data that the process wrote to stdout.\n-    pub output: Vec<u8>,\n-    /// The data that the process wrote to stderr.\n-    pub error: Vec<u8>,\n-}\n-\n-/// Describes what to do with a standard io stream for a child process.\n-#[derive(Clone, Copy)]\n-pub enum StdioContainer {\n-    /// This stream will be ignored. This is the equivalent of attaching the\n-    /// stream to `/dev/null`\n-    Ignored,\n-\n-    /// The specified file descriptor is inherited for the stream which it is\n-    /// specified for. Ownership of the file descriptor is *not* taken, so the\n-    /// caller must clean it up.\n-    InheritFd(libc::c_int),\n-\n-    /// Creates a pipe for the specified file descriptor which will be created\n-    /// when the process is spawned.\n-    ///\n-    /// The first boolean argument is whether the pipe is readable, and the\n-    /// second is whether it is writable. These properties are from the view of\n-    /// the *child* process, not the parent process.\n-    CreatePipe(bool /* readable */, bool /* writable */),\n-}\n-\n-/// Describes the result of a process after it has terminated.\n-/// Note that Windows have no signals, so the result is usually ExitStatus.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub enum ProcessExit {\n-    /// Normal termination with an exit status.\n-    ExitStatus(isize),\n-\n-    /// Termination by signal, with the signal number.\n-    ExitSignal(isize),\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ProcessExit {\n-    /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ExitStatus(code) =>  write!(f, \"exit code: {}\", code),\n-            ExitSignal(code) =>  write!(f, \"signal: {}\", code),\n-        }\n-    }\n-}\n-\n-impl ProcessExit {\n-    /// Was termination successful? Signal termination not considered a success,\n-    /// and success is defined as a zero exit status.\n-    pub fn success(&self) -> bool {\n-        return self.matches_exit_status(0);\n-    }\n-\n-    /// Checks whether this ProcessExit matches the given exit status.\n-    /// Termination by signal will never match an exit code.\n-    pub fn matches_exit_status(&self, wanted: isize) -> bool {\n-        *self == ExitStatus(wanted)\n-    }\n-}\n-\n-impl Process {\n-    /// Sends `signal` to another process in the system identified by `id`.\n-    ///\n-    /// Note that windows doesn't quite have the same model as unix, so some\n-    /// unix signals are mapped to windows signals. Notably, unix termination\n-    /// signals (SIGTERM/SIGKILL/SIGINT) are translated to `TerminateProcess`.\n-    ///\n-    /// Additionally, a signal number of 0 can check for existence of the target\n-    /// process. Note, though, that on some platforms signals will continue to\n-    /// be successfully delivered if the child has exited, but not yet been\n-    /// reaped.\n-    pub fn kill(id: libc::pid_t, signal: isize) -> IoResult<()> {\n-        unsafe { ProcessImp::killpid(id, signal) }\n-    }\n-\n-    /// Returns the process id of this child process\n-    pub fn id(&self) -> libc::pid_t { self.handle.id() }\n-\n-    /// Sends the specified signal to the child process, returning whether the\n-    /// signal could be delivered or not.\n-    ///\n-    /// Note that signal 0 is interpreted as a poll to check whether the child\n-    /// process is still alive or not. If an error is returned, then the child\n-    /// process has exited.\n-    ///\n-    /// On some unix platforms signals will continue to be received after a\n-    /// child has exited but not yet been reaped. In order to report the status\n-    /// of signal delivery correctly, unix implementations may invoke\n-    /// `waitpid()` with `WNOHANG` in order to reap the child as necessary.\n-    ///\n-    /// # Errors\n-    ///\n-    /// If the signal delivery fails, the corresponding error is returned.\n-    pub fn signal(&mut self, signal: isize) -> IoResult<()> {\n-        #[cfg(unix)] fn collect_status(p: &mut Process) {\n-            // On Linux (and possibly other unices), a process that has exited will\n-            // continue to accept signals because it is \"defunct\". The delivery of\n-            // signals will only fail once the child has been reaped. For this\n-            // reason, if the process hasn't exited yet, then we attempt to collect\n-            // their status with WNOHANG.\n-            if p.exit_code.is_none() {\n-                match p.handle.try_wait() {\n-                    Some(code) => { p.exit_code = Some(code); }\n-                    None => {}\n-                }\n-            }\n-        }\n-        #[cfg(windows)] fn collect_status(_p: &mut Process) {}\n-\n-        collect_status(self);\n-\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.exit_code.is_some() {\n-            return Err(IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"invalid argument: can't kill an exited process\",\n-                detail: None,\n-            })\n-        }\n-\n-        // A successfully delivered signal that isn't 0 (just a poll for being\n-        // alive) is recorded for windows (see wait())\n-        match unsafe { self.handle.kill(signal) } {\n-            Ok(()) if signal == 0 => Ok(()),\n-            Ok(()) => { self.exit_signal = Some(signal); Ok(()) }\n-            Err(e) => Err(e),\n-        }\n-\n-    }\n-\n-    /// Sends a signal to this child requesting that it exits. This is\n-    /// equivalent to sending a SIGTERM on unix platforms.\n-    pub fn signal_exit(&mut self) -> IoResult<()> {\n-        self.signal(PleaseExitSignal)\n-    }\n-\n-    /// Sends a signal to this child forcing it to exit. This is equivalent to\n-    /// sending a SIGKILL on unix platforms.\n-    pub fn signal_kill(&mut self) -> IoResult<()> {\n-        self.signal(MustDieSignal)\n-    }\n-\n-    /// Wait for the child to exit completely, returning the status that it\n-    /// exited with. This function will continue to have the same return value\n-    /// after it has been called at least once.\n-    ///\n-    /// The stdin handle to the child process will be closed before waiting.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function can fail if a timeout was previously specified via\n-    /// `set_timeout` and the timeout expires before the child exits.\n-    pub fn wait(&mut self) -> IoResult<ProcessExit> {\n-        drop(self.stdin.take());\n-        match self.exit_code {\n-            Some(code) => Ok(code),\n-            None => {\n-                let code = try!(self.handle.wait(self.deadline));\n-                // On windows, waitpid will never return a signal. If a signal\n-                // was successfully delivered to the process, however, we can\n-                // consider it as having died via a signal.\n-                let code = match self.exit_signal {\n-                    None => code,\n-                    Some(signal) if cfg!(windows) => ExitSignal(signal),\n-                    Some(..) => code,\n-                };\n-                self.exit_code = Some(code);\n-                Ok(code)\n-            }\n-        }\n-    }\n-\n-    /// Sets a timeout, in milliseconds, for future calls to wait().\n-    ///\n-    /// The argument specified is a relative distance into the future, in\n-    /// milliseconds, after which any call to wait() will return immediately\n-    /// with a timeout error, and all future calls to wait() will not block.\n-    ///\n-    /// A value of `None` will clear any previous timeout, and a value of `Some`\n-    /// will override any previously set timeout.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_io, io)]\n-    /// use std::old_io::{Command, IoResult};\n-    /// use std::old_io::process::ProcessExit;\n-    ///\n-    /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n-    ///     let mut p = try!(Command::new(\"long-running-process\").spawn());\n-    ///\n-    ///     // give the process 10 seconds to finish completely\n-    ///     p.set_timeout(Some(10_000));\n-    ///     match p.wait() {\n-    ///         Ok(status) => return Ok(status),\n-    ///         Err(..) => {}\n-    ///     }\n-    ///\n-    ///     // Attempt to exit gracefully, but don't wait for it too long\n-    ///     try!(p.signal_exit());\n-    ///     p.set_timeout(Some(1_000));\n-    ///     match p.wait() {\n-    ///         Ok(status) => return Ok(status),\n-    ///         Err(..) => {}\n-    ///     }\n-    ///\n-    ///     // Well, we did our best, forcefully kill the process\n-    ///     try!(p.signal_kill());\n-    ///     p.set_timeout(None);\n-    ///     p.wait()\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"io\",\n-               reason = \"the type of the timeout is likely to change\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n-    }\n-\n-    /// Simultaneously wait for the child to exit and collect all remaining\n-    /// output on the stdout/stderr handles, returning a `ProcessOutput`\n-    /// instance.\n-    ///\n-    /// The stdin handle to the child is closed before waiting.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function can fail for any of the same reasons that `wait()` can\n-    /// fail.\n-    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> {\n-        drop(self.stdin.take());\n-        fn read(stream: Option<old_io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n-            let (tx, rx) = channel();\n-            match stream {\n-                Some(stream) => {\n-                    thread::spawn(move || {\n-                        let mut stream = stream;\n-                        tx.send(stream.read_to_end()).unwrap();\n-                    });\n-                }\n-                None => tx.send(Ok(Vec::new())).unwrap()\n-            }\n-            rx\n-        }\n-        let stdout = read(self.stdout.take());\n-        let stderr = read(self.stderr.take());\n-\n-        let status = try!(self.wait());\n-\n-        Ok(ProcessOutput {\n-            status: status,\n-            output: stdout.recv().unwrap().unwrap_or(Vec::new()),\n-            error:  stderr.recv().unwrap().unwrap_or(Vec::new()),\n-        })\n-    }\n-\n-    /// Forgets this process, allowing it to outlive the parent\n-    ///\n-    /// This function will forcefully prevent calling `wait()` on the child\n-    /// process in the destructor, allowing the child to outlive the\n-    /// parent. Note that this operation can easily lead to leaking the\n-    /// resources of the child process, so care must be taken when\n-    /// invoking this method.\n-    pub fn forget(mut self) {\n-        self.forget = true;\n-    }\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        if self.forget { return }\n-\n-        // Close all I/O before exiting to ensure that the child doesn't wait\n-        // forever to print some text or something similar.\n-        drop(self.stdin.take());\n-        drop(self.stdout.take());\n-        drop(self.stderr.take());\n-\n-        self.set_timeout(None);\n-        let _ = self.wait().unwrap();\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n-    use old_io::{Reader, Writer};\n-    use old_path::{GenericPath, Path};\n-    use old_io::fs::PathExtensions;\n-    use old_io::timer::*;\n-    use rt::running_on_valgrind;\n-    use str;\n-    use super::{CreatePipe};\n-    use super::{InheritFd, Process, PleaseExitSignal, Command, ProcessOutput};\n-    use sync::mpsc::channel;\n-    use thread;\n-    use time::Duration;\n-\n-    // FIXME(#10380) these tests should not all be ignored on android.\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn smoke() {\n-        let p = Command::new(\"true\").spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn smoke_failure() {\n-        match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn exit_reported_right() {\n-        let p = Command::new(\"false\").spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        assert!(p.wait().unwrap().matches_exit_status(1));\n-        drop(p.wait().clone());\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn signal_reported_right() {\n-        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -9 $$\").spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        match p.wait().unwrap() {\n-            process::ExitSignal(9) => {},\n-            result => panic!(\"not terminated by signal 9 (instead, {})\", result),\n-        }\n-    }\n-\n-    pub fn read_all(input: &mut Reader) -> String {\n-        input.read_to_string().unwrap()\n-    }\n-\n-    pub fn run_output(cmd: Command) -> String {\n-        let p = cmd.spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        assert!(p.stdout.is_some());\n-        let ret = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n-        assert!(p.wait().unwrap().success());\n-        return ret;\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn stdout_works() {\n-        let mut cmd = Command::new(\"echo\");\n-        cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"foobar\\n\");\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn set_cwd_works() {\n-        let mut cmd = Command::new(\"/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\")\n-           .cwd(&Path::new(\"/\"))\n-           .stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"/\\n\");\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn stdin_works() {\n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"read line; echo $line\")\n-                            .stdin(CreatePipe(true, false))\n-                            .stdout(CreatePipe(false, true))\n-                            .spawn().unwrap();\n-        p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n-        drop(p.stdin.take());\n-        let out = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n-        assert!(p.wait().unwrap().success());\n-        assert_eq!(out, \"foobar\\n\");\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn detach_works() {\n-        let mut p = Command::new(\"true\").detached().spawn().unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[cfg(windows)]\n-    #[test]\n-    fn uid_fails_on_windows() {\n-        assert!(Command::new(\"test\").uid(10).spawn().is_err());\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn uid_works() {\n-        use libc;\n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"true\")\n-                            .uid(unsafe { libc::getuid() as usize })\n-                            .gid(unsafe { libc::getgid() as usize })\n-                            .spawn().unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn uid_to_root_fails() {\n-        use libc;\n-\n-        // if we're already root, this isn't a valid test. Most of the bots run\n-        // as non-root though (android is an exception).\n-        if unsafe { libc::getuid() == 0 } { return }\n-        assert!(Command::new(\"/bin/ls\").uid(0).gid(0).spawn().is_err());\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_process_status() {\n-        let mut status = Command::new(\"false\").status().unwrap();\n-        assert!(status.matches_exit_status(1));\n-\n-        status = Command::new(\"true\").status().unwrap();\n-        assert!(status.success());\n-    }\n-\n-    #[test]\n-    fn test_process_output_fail_to_start() {\n-        match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n-            Err(e) => assert_eq!(e.kind, FileNotFound),\n-            Ok(..) => panic!()\n-        }\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_process_output_output() {\n-        let ProcessOutput {status, output, error}\n-             = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n-        let output_str = str::from_utf8(&output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_string(), \"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_process_output_error() {\n-        let ProcessOutput {status, output, error}\n-             = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n-\n-        assert!(status.matches_exit_status(1));\n-        assert_eq!(output, Vec::new());\n-        assert!(!error.is_empty());\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_finish_once() {\n-        let mut prog = Command::new(\"false\").spawn().unwrap();\n-        assert!(prog.wait().unwrap().matches_exit_status(1));\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_finish_twice() {\n-        let mut prog = Command::new(\"false\").spawn().unwrap();\n-        assert!(prog.wait().unwrap().matches_exit_status(1));\n-        assert!(prog.wait().unwrap().matches_exit_status(1));\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_wait_with_output_once() {\n-        let prog = Command::new(\"echo\").arg(\"hello\").spawn().unwrap();\n-        let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n-        let output_str = str::from_utf8(&output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_string(), \"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    pub fn pwd_cmd() -> Command {\n-        Command::new(\"pwd\")\n-    }\n-    #[cfg(target_os=\"android\")]\n-    pub fn pwd_cmd() -> Command {\n-        let mut cmd = Command::new(\"/system/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\");\n-        cmd\n-    }\n-\n-    #[cfg(windows)]\n-    pub fn pwd_cmd() -> Command {\n-        let mut cmd = Command::new(\"cmd\");\n-        cmd.arg(\"/c\").arg(\"cd\");\n-        cmd\n-    }\n-\n-    #[test]\n-    fn test_keep_current_working_dir() {\n-        use os;\n-        let prog = pwd_cmd().spawn().unwrap();\n-\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n-        let child_dir = Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[test]\n-    fn test_change_working_directory() {\n-        use os;\n-        // test changing to the parent of os::getcwd() because we know\n-        // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n-        let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n-\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let child_dir = Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    pub fn env_cmd() -> Command {\n-        Command::new(\"env\")\n-    }\n-    #[cfg(target_os=\"android\")]\n-    pub fn env_cmd() -> Command {\n-        let mut cmd = Command::new(\"/system/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"set\");\n-        cmd\n-    }\n-\n-    #[cfg(windows)]\n-    pub fn env_cmd() -> Command {\n-        let mut cmd = Command::new(\"cmd\");\n-        cmd.arg(\"/c\").arg(\"set\");\n-        cmd\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_inherit_env() {\n-        use os;\n-        if running_on_valgrind() { return; }\n-\n-        let prog = env_cmd().spawn().unwrap();\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-\n-        let r = ::env::vars();\n-        for (k, v) in r {\n-            // don't check windows magical empty-named variables\n-            assert!(k.is_empty() ||\n-                    output.contains(&format!(\"{}={}\", k, v)),\n-                    \"output doesn't contain `{}={}`\\n{}\",\n-                    k, v, output);\n-        }\n-    }\n-    #[cfg(target_os=\"android\")]\n-    #[test]\n-    fn test_inherit_env() {\n-        use os;\n-        if running_on_valgrind() { return; }\n-\n-        let mut prog = env_cmd().spawn().unwrap();\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-\n-        let r = ::env::vars();\n-        for (k, v) in r {\n-            // don't check android RANDOM variables\n-            if k != \"RANDOM\".to_string() {\n-                assert!(output.contains(&format!(\"{}={}\", k, v)) ||\n-                        output.contains(&format!(\"{}=\\'{}\\'\", k, v)));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_override_env() {\n-        use os;\n-\n-        // In some build environments (such as chrooted Nix builds), `env` can\n-        // only be found in the explicitly-provided PATH env variable, not in\n-        // default places such as /bin or /usr/bin. So we need to pass through\n-        // PATH to our sub-process.\n-        let path_val: String;\n-        let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n-        match ::env::var(\"PATH\") {\n-            Err(..) => {}\n-            Ok(val) => {\n-                path_val = val;\n-                new_env.push((\"PATH\", &path_val))\n-            }\n-        }\n-\n-        let prog = env_cmd().env_set_all(&new_env).spawn().unwrap();\n-        let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(&result.output).to_string();\n-\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    }\n-\n-    #[test]\n-    fn test_add_to_env() {\n-        let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n-        let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(&result.output).to_string();\n-\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    }\n-\n-    #[cfg(unix)]\n-    pub fn sleeper() -> Process {\n-        Command::new(\"sleep\").arg(\"1000\").spawn().unwrap()\n-    }\n-    #[cfg(windows)]\n-    pub fn sleeper() -> Process {\n-        // There's a `timeout` command on windows, but it doesn't like having\n-        // its output piped, so instead just ping ourselves a few times with\n-        // gaps in between so we're sure this process is alive for awhile\n-        Command::new(\"ping\").arg(\"127.0.0.1\").arg(\"-n\").arg(\"1000\").spawn().unwrap()\n-    }\n-\n-    #[test]\n-    fn test_kill() {\n-        let mut p = sleeper();\n-        Process::kill(p.id(), PleaseExitSignal).unwrap();\n-        assert!(!p.wait().unwrap().success());\n-    }\n-\n-    #[test]\n-    fn test_exists() {\n-        let mut p = sleeper();\n-        assert!(Process::kill(p.id(), 0).is_ok());\n-        p.signal_kill().unwrap();\n-        assert!(!p.wait().unwrap().success());\n-    }\n-\n-    #[test]\n-    fn test_zero() {\n-        let mut p = sleeper();\n-        p.signal_kill().unwrap();\n-        for _ in 0..20 {\n-            if p.signal(0).is_err() {\n-                assert!(!p.wait().unwrap().success());\n-                return\n-            }\n-            timer::sleep(Duration::milliseconds(100));\n-        }\n-        panic!(\"never saw the child go away\");\n-    }\n-\n-    #[test]\n-    fn wait_timeout() {\n-        let mut p = sleeper();\n-        p.set_timeout(Some(10));\n-        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-        p.signal_kill().unwrap();\n-        p.set_timeout(None);\n-        assert!(p.wait().is_ok());\n-    }\n-\n-    #[test]\n-    fn wait_timeout2() {\n-        let (tx, rx) = channel();\n-        let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut p = sleeper();\n-            p.set_timeout(Some(10));\n-            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-            p.signal_kill().unwrap();\n-            tx.send(()).unwrap();\n-        });\n-        let _t = thread::spawn(move|| {\n-            let mut p = sleeper();\n-            p.set_timeout(Some(10));\n-            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-            p.signal_kill().unwrap();\n-            tx2.send(()).unwrap();\n-        });\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn forget() {\n-        let p = sleeper();\n-        let id = p.id();\n-        p.forget();\n-        assert!(Process::kill(id, 0).is_ok());\n-        assert!(Process::kill(id, PleaseExitSignal).is_ok());\n-    }\n-\n-    #[test]\n-    fn dont_close_fd_on_command_spawn() {\n-        use sys::fs;\n-\n-        let path = if cfg!(windows) {\n-            Path::new(\"NUL\")\n-        } else {\n-            Path::new(\"/dev/null\")\n-        };\n-\n-        let fdes = match fs::open(&path, Truncate, Write) {\n-            Ok(f) => f,\n-            Err(_) => panic!(\"failed to open file descriptor\"),\n-        };\n-\n-        let mut cmd = pwd_cmd();\n-        let _ = cmd.stdout(InheritFd(fdes.fd()));\n-        assert!(cmd.status().unwrap().success());\n-        assert!(fdes.write(\"extra write\\n\".as_bytes()).is_ok());\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn env_map_keys_ci() {\n-        use ffi::CString;\n-        use super::EnvKey;\n-        let mut cmd = Command::new(\"\");\n-        cmd.env(\"path\", \"foo\");\n-        cmd.env(\"Path\", \"bar\");\n-        let env = &cmd.env.unwrap();\n-        let val = env.get(&EnvKey(CString::new(\"PATH\").unwrap()));\n-        assert!(val.unwrap() == &CString::new(\"bar\").unwrap());\n-    }\n-}"}, {"sha": "e1037f26b7fcf575bf61f50a0905745125ceb6da", "filename": "src/libstd/old_io/result.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementations of I/O traits for the IoResult type\n-//!\n-//! I/O constructors return option types to allow errors to be handled.\n-//! These implementations allow e.g. `IoResult<File>` to be used\n-//! as a `Reader` without unwrapping the result first.\n-\n-use clone::Clone;\n-use result::Result::{Ok, Err};\n-use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle, IoResult};\n-\n-impl<W: Writer> Writer for IoResult<W> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        match *self {\n-            Ok(ref mut writer) => writer.write_all(buf),\n-            Err(ref e) => Err((*e).clone())\n-        }\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> {\n-        match *self {\n-            Ok(ref mut writer) => writer.flush(),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-}\n-\n-impl<R: Reader> Reader for IoResult<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        match *self {\n-            Ok(ref mut reader) => reader.read(buf),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-}\n-\n-impl<S: Seek> Seek for IoResult<S> {\n-    fn tell(&self) -> IoResult<u64> {\n-        match *self {\n-            Ok(ref seeker) => seeker.tell(),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        match *self {\n-            Ok(ref mut seeker) => seeker.seek(pos, style),\n-            Err(ref e) => Err(e.clone())\n-        }\n-    }\n-}\n-\n-impl<A: Acceptor, L: Listener<A>> Listener<A> for IoResult<L> {\n-    fn listen(self) -> IoResult<A> {\n-        match self {\n-            Ok(listener) => listener.listen(),\n-            Err(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl<A: Acceptor> Acceptor for IoResult<A> {\n-    type Connection = A::Connection;\n-    fn accept(&mut self) -> IoResult<A::Connection> {\n-        match *self {\n-            Ok(ref mut acceptor) => acceptor.accept(),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::super::mem::*;\n-    use old_io::{self, Reader, Writer};\n-\n-    #[test]\n-    fn test_option_writer() {\n-        let mut writer: old_io::IoResult<Vec<u8>> = Ok(Vec::new());\n-        writer.write_all(&[0, 1, 2]).unwrap();\n-        writer.flush().unwrap();\n-        assert_eq!(writer.unwrap(), [0, 1, 2]);\n-    }\n-\n-    #[test]\n-    fn test_option_writer_error() {\n-        let mut writer: old_io::IoResult<Vec<u8>> =\n-            Err(old_io::standard_error(old_io::EndOfFile));\n-\n-        match writer.write_all(&[0, 0, 0]) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-        match writer.flush() {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_option_reader() {\n-        let mut reader: old_io::IoResult<MemReader> =\n-            Ok(MemReader::new(vec!(0, 1, 2, 3)));\n-        let mut buf = [0, 0];\n-        reader.read(&mut buf).unwrap();\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_option_reader_error() {\n-        let mut reader: old_io::IoResult<MemReader> =\n-            Err(old_io::standard_error(old_io::EndOfFile));\n-        let mut buf = [];\n-\n-        match reader.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-    }\n-}"}, {"sha": "b4924c7b78b753112d6e58ff59b9b8872fe4c28c", "filename": "src/libstd/old_io/stdio.rs", "status": "removed", "additions": 0, "deletions": 540, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,540 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Non-blocking access to stdin, stdout, and stderr.\n-//!\n-//! This module provides bindings to the local event loop's TTY interface, using it\n-//! to offer synchronous but non-blocking versions of stdio. These handles can be\n-//! inspected for information about terminal dimensions or for related information\n-//! about the stream or terminal to which it is attached.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! # #![feature(old_io)]\n-//! # #![allow(unused_must_use)]\n-//! use std::old_io;\n-//! use std::old_io::*;\n-//!\n-//! let mut out = old_io::stdout();\n-//! out.write_all(b\"Hello, world!\");\n-//! ```\n-\n-use self::StdSource::*;\n-\n-use boxed;\n-use boxed::Box;\n-use cell::RefCell;\n-use clone::Clone;\n-use fmt;\n-use old_io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n-             standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n-use marker::{Sync, Send};\n-use libc;\n-use mem;\n-use option::Option;\n-use option::Option::{Some, None};\n-use ops::{Deref, DerefMut, FnOnce};\n-use ptr;\n-use result::Result::{Ok, Err};\n-use rt;\n-use string::String;\n-use sys::{fs, tty};\n-use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n-use usize;\n-use vec::Vec;\n-\n-// And so begins the tale of acquiring a uv handle to a stdio stream on all\n-// platforms in all situations. Our story begins by splitting the world into two\n-// categories, windows and unix. Then one day the creators of unix said let\n-// there be redirection! And henceforth there was redirection away from the\n-// console for standard I/O streams.\n-//\n-// After this day, the world split into four factions:\n-//\n-// 1. Unix with stdout on a terminal.\n-// 2. Unix with stdout redirected.\n-// 3. Windows with stdout on a terminal.\n-// 4. Windows with stdout redirected.\n-//\n-// Many years passed, and then one day the nation of libuv decided to unify this\n-// world. After months of toiling, uv created three ideas: TTY, Pipe, File.\n-// These three ideas propagated throughout the lands and the four great factions\n-// decided to settle among them.\n-//\n-// The groups of 1, 2, and 3 all worked very hard towards the idea of TTY. Upon\n-// doing so, they even enhanced themselves further then their Pipe/File\n-// brethren, becoming the dominant powers.\n-//\n-// The group of 4, however, decided to work independently. They abandoned the\n-// common TTY belief throughout, and even abandoned the fledgling Pipe belief.\n-// The members of the 4th faction decided to only align themselves with File.\n-//\n-// tl;dr; TTY works on everything but when windows stdout is redirected, in that\n-//        case pipe also doesn't work, but magically file does!\n-enum StdSource {\n-    TTY(tty::TTY),\n-    File(fs::FileDesc),\n-}\n-\n-fn src<T, F>(fd: libc::c_int, _readable: bool, f: F) -> T where\n-    F: FnOnce(StdSource) -> T,\n-{\n-    match tty::TTY::new(fd) {\n-        Ok(tty) => f(TTY(tty)),\n-        Err(_) => f(File(fs::FileDesc::new(fd, false))),\n-    }\n-}\n-\n-thread_local! {\n-    static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n-        RefCell::new(None)\n-    }\n-}\n-\n-struct RaceBox(BufferedReader<StdReader>);\n-\n-unsafe impl Send for RaceBox {}\n-unsafe impl Sync for RaceBox {}\n-\n-/// A synchronized wrapper around a buffered reader from stdin\n-#[derive(Clone)]\n-pub struct StdinReader {\n-    inner: Arc<Mutex<RaceBox>>,\n-}\n-\n-unsafe impl Send for StdinReader {}\n-unsafe impl Sync for StdinReader {}\n-\n-/// A guard for exclusive access to `StdinReader`'s internal `BufferedReader`.\n-pub struct StdinReaderGuard<'a> {\n-    inner: MutexGuard<'a, RaceBox>,\n-}\n-\n-impl<'a> Deref for StdinReaderGuard<'a> {\n-    type Target = BufferedReader<StdReader>;\n-\n-    fn deref(&self) -> &BufferedReader<StdReader> {\n-        &self.inner.0\n-    }\n-}\n-\n-impl<'a> DerefMut for StdinReaderGuard<'a> {\n-    fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n-        &mut self.inner.0\n-    }\n-}\n-\n-impl StdinReader {\n-    /// Locks the `StdinReader`, granting the calling thread exclusive access\n-    /// to the underlying `BufferedReader`.\n-    ///\n-    /// This provides access to methods like `chars` and `lines`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io;\n-    /// use std::old_io::*;\n-    ///\n-    /// let mut stdin = old_io::stdin();\n-    /// for line in stdin.lock().lines() {\n-    ///     println!(\"{}\", line.unwrap());\n-    /// }\n-    /// ```\n-    pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> {\n-        StdinReaderGuard {\n-            inner: self.inner.lock().unwrap()\n-        }\n-    }\n-\n-    /// Like `Buffer::read_line`.\n-    ///\n-    /// The read is performed atomically - concurrent read calls in other\n-    /// threads will not interleave with this one.\n-    pub fn read_line(&mut self) -> IoResult<String> {\n-        self.inner.lock().unwrap().0.read_line()\n-    }\n-\n-    /// Like `Buffer::read_until`.\n-    ///\n-    /// The read is performed atomically - concurrent read calls in other\n-    /// threads will not interleave with this one.\n-    pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        self.inner.lock().unwrap().0.read_until(byte)\n-    }\n-\n-    /// Like `Buffer::read_char`.\n-    ///\n-    /// The read is performed atomically - concurrent read calls in other\n-    /// threads will not interleave with this one.\n-    pub fn read_char(&mut self) -> IoResult<char> {\n-        self.inner.lock().unwrap().0.read_char()\n-    }\n-}\n-\n-impl Reader for StdinReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.lock().unwrap().0.read(buf)\n-    }\n-\n-    // We have to manually delegate all of these because the default impls call\n-    // read more than once and we don't want those calls to interleave (or\n-    // incur the costs of repeated locking).\n-\n-    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.lock().unwrap().0.read_at_least(min, buf)\n-    }\n-\n-    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n-        self.inner.lock().unwrap().0.push_at_least(min, len, buf)\n-    }\n-\n-    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        self.inner.lock().unwrap().0.read_to_end()\n-    }\n-\n-    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        self.inner.lock().unwrap().0.read_le_uint_n(nbytes)\n-    }\n-\n-    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        self.inner.lock().unwrap().0.read_be_uint_n(nbytes)\n-    }\n-}\n-\n-/// Creates a new handle to the stdin of the current process.\n-///\n-/// The returned handle is a wrapper around a global `BufferedReader` shared\n-/// by all threads. If buffered access is not desired, the `stdin_raw` function\n-/// is provided to provided unbuffered access to stdin.\n-///\n-/// See `stdout()` for more notes about this function.\n-pub fn stdin() -> StdinReader {\n-    // We're following the same strategy as kimundi's lazy_static library\n-    static mut STDIN: *mut StdinReader = 0 as *mut StdinReader;\n-    static ONCE: Once = ONCE_INIT;\n-\n-    unsafe {\n-        ONCE.call_once(|| {\n-            // The default buffer capacity is 64k, but apparently windows\n-            // doesn't like 64k reads on stdin. See #13304 for details, but the\n-            // idea is that on windows we use a slightly smaller buffer that's\n-            // been seen to be acceptable.\n-            let stdin = if cfg!(windows) {\n-                BufferedReader::with_capacity(8 * 1024, stdin_raw())\n-            } else {\n-                BufferedReader::new(stdin_raw())\n-            };\n-            let stdin = StdinReader {\n-                inner: Arc::new(Mutex::new(RaceBox(stdin)))\n-            };\n-            STDIN = boxed::into_raw(box stdin);\n-\n-            // Make sure to free it at exit\n-            let _ = rt::at_exit(|| {\n-                Box::from_raw(STDIN);\n-                STDIN = ptr::null_mut();\n-            });\n-        });\n-\n-        (*STDIN).clone()\n-    }\n-}\n-\n-/// Creates a new non-blocking handle to the stdin of the current process.\n-///\n-/// Unlike `stdin()`, the returned reader is *not* a buffered reader.\n-///\n-/// See `stdout()` for more notes about this function.\n-pub fn stdin_raw() -> StdReader {\n-    src(libc::STDIN_FILENO, true, |src| StdReader { inner: src })\n-}\n-\n-/// Creates a line-buffered handle to the stdout of the current process.\n-///\n-/// Note that this is a fairly expensive operation in that at least one memory\n-/// allocation is performed. Additionally, this must be called from a runtime\n-/// task context because the stream returned will be a non-blocking object using\n-/// the local scheduler to perform the I/O.\n-///\n-/// Care should be taken when creating multiple handles to an output stream for\n-/// a single process. While usage is still safe, the output may be surprising if\n-/// no synchronization is performed to ensure a sane output.\n-pub fn stdout() -> LineBufferedWriter<StdWriter> {\n-    LineBufferedWriter::new(stdout_raw())\n-}\n-\n-/// Creates an unbuffered handle to the stdout of the current process\n-///\n-/// See notes in `stdout()` for more information.\n-pub fn stdout_raw() -> StdWriter {\n-    src(libc::STDOUT_FILENO, false, |src| StdWriter { inner: src })\n-}\n-\n-/// Creates a line-buffered handle to the stderr of the current process.\n-///\n-/// See `stdout()` for notes about this function.\n-pub fn stderr() -> LineBufferedWriter<StdWriter> {\n-    LineBufferedWriter::new(stderr_raw())\n-}\n-\n-/// Creates an unbuffered handle to the stderr of the current process\n-///\n-/// See notes in `stdout()` for more information.\n-pub fn stderr_raw() -> StdWriter {\n-    src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n-}\n-\n-/// Resets the task-local stdout handle to the specified writer\n-///\n-/// This will replace the current task's stdout handle, returning the old\n-/// handle. All future calls to `print` and friends will emit their output to\n-/// this specified handle.\n-///\n-/// Note that this does not need to be called for all new tasks; the default\n-/// output handle is to the process's stdout stream.\n-pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    let mut new = Some(stdout);\n-    LOCAL_STDOUT.with(|slot| {\n-        mem::replace(&mut *slot.borrow_mut(), new.take())\n-    }).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n-}\n-\n-/// Resets the task-local stderr handle to the specified writer\n-///\n-/// This will replace the current task's stderr handle, returning the old\n-/// handle. Currently, the stderr handle is used for printing panic messages\n-/// during task panic.\n-///\n-/// Note that this does not need to be called for all new tasks; the default\n-/// output handle is to the process's stderr stream.\n-#[unstable(feature = \"old_io\")]\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::io::set_panic\")]\n-pub fn set_stderr(_stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    None\n-}\n-\n-// Helper to access the local task's stdout handle\n-//\n-// Note that this is not a safe function to expose because you can create an\n-// aliased pointer very easily:\n-//\n-//  with_task_stdout(|io1| {\n-//      with_task_stdout(|io2| {\n-//          // io1 aliases io2\n-//      })\n-//  })\n-fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> {\n-    let mut my_stdout: Box<Writer + Send> = LOCAL_STDOUT.with(|slot| {\n-        slot.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box stdout()\n-    });\n-    let result = f(&mut *my_stdout);\n-    let mut var = Some(my_stdout);\n-    LOCAL_STDOUT.with(|slot| {\n-        *slot.borrow_mut() = var.take();\n-    });\n-    match result {\n-        Ok(()) => {}\n-        Err(e) => panic!(\"failed printing to stdout: {:?}\", e),\n-    }\n-}\n-\n-/// Flushes the local task's stdout handle.\n-///\n-/// By default, this stream is a line-buffering stream, so flushing may be\n-/// necessary to ensure that all output is printed to the screen (if there are\n-/// no newlines printed).\n-///\n-/// Note that logging macros do not use this stream. Using the logging macros\n-/// will emit output to stderr, and while they are line buffered the log\n-/// messages are always terminated in a newline (no need to flush).\n-pub fn flush() {\n-    with_task_stdout(|io| io.flush())\n-}\n-\n-/// Prints a string to the stdout of the current process. No newline is emitted\n-/// after the string is printed.\n-pub fn print(s: &str) {\n-    with_task_stdout(|io| io.write_all(s.as_bytes()))\n-}\n-\n-/// Prints a string to the stdout of the current process. A literal\n-/// `\\n` character is printed to the console after the string.\n-pub fn println(s: &str) {\n-    with_task_stdout(|io| {\n-        io.write_all(s.as_bytes()).and_then(|()| io.write_all(&[b'\\n']))\n-    })\n-}\n-\n-/// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n-/// with the `format_args!` macro.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn print_args(fmt: fmt::Arguments) {\n-    with_task_stdout(|io| write!(io, \"{}\", fmt))\n-}\n-\n-/// Similar to `println`, but takes a `fmt::Arguments` structure to be\n-/// compatible with the `format_args!` macro.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn println_args(fmt: fmt::Arguments) {\n-    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n-}\n-\n-/// Representation of a reader of a standard input stream\n-pub struct StdReader {\n-    inner: StdSource\n-}\n-\n-impl StdReader {\n-    /// Returns whether this stream is attached to a TTY instance or not.\n-    pub fn isatty(&self) -> bool {\n-        match self.inner {\n-            TTY(..) => true,\n-            File(..) => false,\n-        }\n-    }\n-}\n-\n-impl Reader for StdReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let ret = match self.inner {\n-            TTY(ref mut tty) => {\n-                // Flush the task-local stdout so that weird issues like a\n-                // print!'d prompt not being shown until after the user hits\n-                // enter.\n-                flush();\n-                tty.read(buf).map(|i| i as usize)\n-            },\n-            File(ref mut file) => file.read(buf).map(|i| i as usize),\n-        };\n-        match ret {\n-            // When reading a piped stdin, libuv will return 0-length reads when\n-            // stdin reaches EOF. For pretty much all other streams it will\n-            // return an actual EOF error, but apparently for stdin it's a\n-            // little different. Hence, here we convert a 0 length read to an\n-            // end-of-file indicator so the caller knows to stop reading.\n-            Ok(0) => { Err(standard_error(EndOfFile)) }\n-            ret @ Ok(..) | ret @ Err(..) => ret,\n-        }\n-    }\n-}\n-\n-/// Representation of a writer to a standard output stream\n-pub struct StdWriter {\n-    inner: StdSource\n-}\n-\n-unsafe impl Send for StdWriter {}\n-unsafe impl Sync for StdWriter {}\n-\n-impl StdWriter {\n-    /// Gets the size of this output window, if possible. This is typically used\n-    /// when the writer is attached to something like a terminal, this is used\n-    /// to fetch the dimensions of the terminal.\n-    ///\n-    /// If successful, returns `Ok((width, height))`.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an error if the output stream is not actually\n-    /// connected to a TTY instance, or if querying the TTY instance fails.\n-    pub fn winsize(&mut self) -> IoResult<(isize, isize)> {\n-        match self.inner {\n-            TTY(ref mut tty) => {\n-                tty.get_winsize()\n-            }\n-            File(..) => {\n-                Err(IoError {\n-                    kind: OtherIoError,\n-                    desc: \"stream is not a tty\",\n-                    detail: None,\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Controls whether this output stream is a \"raw stream\" or simply a normal\n-    /// stream.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an error if the output stream is not actually\n-    /// connected to a TTY instance, or if querying the TTY instance fails.\n-    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n-        match self.inner {\n-            TTY(ref mut tty) => {\n-                tty.set_raw(raw)\n-            }\n-            File(..) => {\n-                Err(IoError {\n-                    kind: OtherIoError,\n-                    desc: \"stream is not a tty\",\n-                    detail: None,\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Returns whether this stream is attached to a TTY instance or not.\n-    pub fn isatty(&self) -> bool {\n-        match self.inner {\n-            TTY(..) => true,\n-            File(..) => false,\n-        }\n-    }\n-}\n-\n-impl Writer for StdWriter {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        // As with stdin on windows, stdout often can't handle writes of large\n-        // sizes. For an example, see #14940. For this reason, chunk the output\n-        // buffer on windows, but on unix we can just write the whole buffer all\n-        // at once.\n-        //\n-        // For some other references, it appears that this problem has been\n-        // encountered by others [1] [2]. We choose the number 8KB just because\n-        // libuv does the same.\n-        //\n-        // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n-        // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-        let max_size = if cfg!(windows) {8192} else {usize::MAX};\n-        for chunk in buf.chunks(max_size) {\n-            try!(match self.inner {\n-                TTY(ref mut tty) => tty.write(chunk),\n-                File(ref mut file) => file.write(chunk),\n-            })\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use super::*;\n-    use sync::mpsc::channel;\n-    use thread;\n-\n-    #[test]\n-    fn smoke() {\n-        // Just make sure we can acquire handles\n-        stdin();\n-        stdout();\n-        stderr();\n-    }\n-}"}, {"sha": "94faa5540bb30d538945a8e27b8c239a61345aee", "filename": "src/libstd/old_io/tempfile.rs", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,188 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Temporary files and directories\n-#![allow(deprecated)] // rand\n-\n-use env;\n-use iter::Iterator;\n-use old_io::{fs, IoError, IoErrorKind, IoResult};\n-use old_io;\n-use ops::Drop;\n-use option::Option::{None, Some};\n-use option::Option;\n-use old_path::{Path, GenericPath};\n-use rand::{Rng, thread_rng};\n-use result::Result::{Ok, Err};\n-use string::String;\n-\n-/// A wrapper for a path to temporary directory implementing automatic\n-/// scope-based deletion.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// {\n-///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"myprefix\") {\n-///         Ok(dir) => dir,\n-///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n-///     };\n-///\n-///     // get the path of the temporary directory without affecting the wrapper\n-///     let tmppath = tmpdir.path();\n-///\n-///     println!(\"The path of temporary directory is {}\", tmppath.display());\n-///\n-///     // the temporary directory is automatically removed when tmpdir goes\n-///     // out of scope at the end of the block\n-/// }\n-/// {\n-///     // create a temporary directory, this time using a custom path\n-///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"myprefix\") {\n-///         Ok(dir) => dir,\n-///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n-///     };\n-///\n-///     // get the path of the temporary directory and disable automatic deletion in the wrapper\n-///     let tmppath = tmpdir.into_inner();\n-///\n-///     println!(\"The path of the not-so-temporary directory is {}\", tmppath.display());\n-///\n-///     // the temporary directory is not removed here\n-///     // because the directory is detached from the wrapper\n-/// }\n-/// {\n-///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"myprefix\") {\n-///         Ok(dir) => dir,\n-///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n-///     };\n-///\n-///     // close the temporary directory manually and check the result\n-///     match tmpdir.close() {\n-///         Ok(_) => println!(\"success!\"),\n-///         Err(e) => panic!(\"couldn't remove temporary directory: {}\", e)\n-///     };\n-/// }\n-/// ```\n-pub struct TempDir {\n-    path: Option<Path>,\n-    disarmed: bool\n-}\n-\n-// How many times should we (re)try finding an unused random name? It should be\n-// enough that an attacker will run out of luck before we run out of patience.\n-const NUM_RETRIES: u32 = 1 << 31;\n-// How many characters should we include in a random file name? It needs to\n-// be enough to dissuade an attacker from trying to preemptively create names\n-// of that length, but not so huge that we unnecessarily drain the random number\n-// generator of entropy.\n-const NUM_RAND_CHARS: usize = 12;\n-\n-impl TempDir {\n-    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n-    /// will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n-    pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n-        if !tmpdir.is_absolute() {\n-            let cur_dir = ::env::current_dir().unwrap();\n-            let cur_dir = Path::new(cur_dir.to_str().unwrap());\n-            return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n-        }\n-\n-        let mut rng = thread_rng();\n-        for _ in 0..NUM_RETRIES {\n-            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n-            let leaf = if prefix.len() > 0 {\n-                format!(\"{}.{}\", prefix, suffix)\n-            } else {\n-                // If we're given an empty string for a prefix, then creating a\n-                // directory starting with \".\" would lead to it being\n-                // semi-invisible on some systems.\n-                suffix\n-            };\n-            let path = tmpdir.join(leaf);\n-            match fs::mkdir(&path, old_io::USER_RWX) {\n-                Ok(_) => return Ok(TempDir { path: Some(path), disarmed: false }),\n-                Err(IoError{kind:IoErrorKind::PathAlreadyExists,..}) => (),\n-                Err(e) => return Err(e)\n-            }\n-        }\n-\n-        return Err(IoError{\n-                       kind: IoErrorKind::PathAlreadyExists,\n-                       desc:\"Exhausted\",\n-                       detail: None});\n-    }\n-\n-    /// Attempts to make a temporary directory inside of `os::tmpdir()` whose\n-    /// name will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n-    pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        let tmp = Path::new(::env::temp_dir().to_str().unwrap());\n-        TempDir::new_in(&tmp, prefix)\n-    }\n-\n-    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n-    /// This discards the wrapper so that the automatic deletion of the\n-    /// temporary directory is prevented.\n-    pub fn into_inner(self) -> Path {\n-        let mut tmpdir = self;\n-        tmpdir.path.take().unwrap()\n-    }\n-\n-    /// Access the wrapped `std::path::Path` to the temporary directory.\n-    pub fn path<'a>(&'a self) -> &'a Path {\n-        self.path.as_ref().unwrap()\n-    }\n-\n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> IoResult<()> {\n-        self.cleanup_dir()\n-    }\n-\n-    fn cleanup_dir(&mut self) -> IoResult<()> {\n-        assert!(!self.disarmed);\n-        self.disarmed = true;\n-        match self.path {\n-            Some(ref p) => {\n-                fs::rmdir_recursive(p)\n-            }\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl Drop for TempDir {\n-    fn drop(&mut self) {\n-        if !self.disarmed {\n-            let _ = self.cleanup_dir();\n-        }\n-    }\n-}\n-\n-// the tests for this module need to change the path using change_dir,\n-// and this doesn't play nicely with other tests so these unit tests are located\n-// in src/test/run-pass/tempfile.rs"}, {"sha": "312e1c814dc58e730c588e446da5dbcd877879ce", "filename": "src/libstd/old_io/test.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,177 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Various utility functions useful for writing I/O tests\n-\n-use prelude::v1::*;\n-\n-use env;\n-use libc;\n-use old_io::net::ip::*;\n-use old_path::{Path, GenericPath};\n-use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n-\n-/// Get a port number, starting at 9600, for use in tests\n-pub fn next_test_port() -> u16 {\n-    static NEXT_OFFSET: AtomicUsize = ATOMIC_USIZE_INIT;\n-    base_port() + NEXT_OFFSET.fetch_add(1, Ordering::Relaxed) as u16\n-}\n-\n-// iOS has a pretty long tmpdir path which causes pipe creation\n-// to like: invalid argument: path must be smaller than SUN_LEN\n-fn next_test_unix_socket() -> String {\n-    static COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n-    // base port and pid are an attempt to be unique between multiple\n-    // test-runners of different configurations running on one\n-    // buildbot, the count is to be unique within this executable.\n-    format!(\"rust-test-unix-path-{}-{}-{}\",\n-            base_port(),\n-            unsafe {libc::getpid()},\n-            COUNT.fetch_add(1, Ordering::Relaxed))\n-}\n-\n-/// Get a temporary path which could be the location of a unix socket\n-#[cfg(not(target_os = \"ios\"))]\n-#[allow(deprecated)]\n-pub fn next_test_unix() -> Path {\n-    let string = next_test_unix_socket();\n-    if cfg!(unix) {\n-        Path::new(::env::temp_dir().to_str().unwrap()).join(string)\n-    } else {\n-        Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n-    }\n-}\n-\n-/// Get a temporary path which could be the location of a unix socket\n-#[cfg(target_os = \"ios\")]\n-pub fn next_test_unix() -> Path {\n-    Path::new(format!(\"/var/tmp/{}\", next_test_unix_socket()))\n-}\n-\n-/// Get a unique IPv4 localhost:port pair starting at 9600\n-pub fn next_test_ip4() -> SocketAddr {\n-    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/// Get a unique IPv6 localhost:port pair starting at 9600\n-pub fn next_test_ip6() -> SocketAddr {\n-    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/*\n-XXX: Welcome to MegaHack City.\n-\n-The bots run multiple builds at the same time, and these builds\n-all want to use ports. This function figures out which workspace\n-it is running in and assigns a port range based on it.\n-*/\n-fn base_port() -> u16 {\n-\n-    let base = 9600;\n-    let range = 1000;\n-\n-    let bases = [\n-        (\"32-opt\", base + range * 1),\n-        (\"32-nopt\", base + range * 2),\n-        (\"64-opt\", base + range * 3),\n-        (\"64-nopt\", base + range * 4),\n-        (\"64-opt-vg\", base + range * 5),\n-        (\"all-opt\", base + range * 6),\n-        (\"snap3\", base + range * 7),\n-        (\"dist\", base + range * 8)\n-    ];\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = env::current_dir().unwrap();\n-    let path_s = path.to_str().unwrap();\n-\n-    let mut final_base = base;\n-\n-    for &(dir, base) in &bases {\n-        if path_s.contains(dir) {\n-            final_base = base;\n-            break;\n-        }\n-    }\n-\n-    return final_base;\n-}\n-\n-/// Raises the file descriptor limit when running tests if necessary\n-pub fn raise_fd_limit() {\n-    unsafe { darwin_fd_limit::raise_fd_limit() }\n-}\n-\n-/// darwin_fd_limit exists to work around an issue where launchctl on Mac OS X defaults the rlimit\n-/// maxfiles to 256/unlimited. The default soft limit of 256 ends up being far too low for our\n-/// multithreaded scheduler testing, depending on the number of cores available.\n-///\n-/// This fixes issue #7772.\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-#[allow(non_camel_case_types)]\n-mod darwin_fd_limit {\n-    use libc;\n-    type rlim_t = libc::uint64_t;\n-    #[repr(C)]\n-    struct rlimit {\n-        rlim_cur: rlim_t,\n-        rlim_max: rlim_t\n-    }\n-    extern {\n-        // name probably doesn't need to be mut, but the C function doesn't specify const\n-        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,\n-                  oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n-                  newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n-        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n-        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;\n-    }\n-    static CTL_KERN: libc::c_int = 1;\n-    static KERN_MAXFILESPERPROC: libc::c_int = 29;\n-    static RLIMIT_NOFILE: libc::c_int = 8;\n-\n-    pub unsafe fn raise_fd_limit() {\n-        // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n-        // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n-        use ptr::null_mut;\n-        use mem::size_of_val;\n-        use io;\n-\n-        // Fetch the kern.maxfilesperproc value\n-        let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n-        let mut maxfiles: libc::c_int = 0;\n-        let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-        if sysctl(&mut mib[0], 2, &mut maxfiles as *mut libc::c_int as *mut libc::c_void, &mut size,\n-                  null_mut(), 0) != 0 {\n-            let err = io::Error::last_os_error();\n-            panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n-        }\n-\n-        // Fetch the current resource limits\n-        let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n-        if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {\n-            let err = io::Error::last_os_error();\n-            panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n-        }\n-\n-        // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit\n-        rlim.rlim_cur = ::cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n-\n-        // Set our newly-increased resource limit\n-        if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {\n-            let err = io::Error::last_os_error();\n-            panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n-        }\n-    }\n-}\n-\n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-mod darwin_fd_limit {\n-    pub unsafe fn raise_fd_limit() {}\n-}"}, {"sha": "f8cba0444433175b02a141ed88cdd62b234b81c5", "filename": "src/libstd/old_io/timer.rs", "status": "removed", "additions": 0, "deletions": 488, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,488 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous Timers\n-//!\n-//! This module exposes the functionality to create timers, block the current task,\n-//! and create receivers which will receive notifications after a period of time.\n-\n-// FIXME: These functions take Durations but only pass ms to the backend impls.\n-\n-use boxed::Box;\n-use sync::mpsc::{Receiver, Sender, channel};\n-use time::Duration;\n-use old_io::IoResult;\n-use sys::timer::Callback;\n-use sys::timer::Timer as TimerImp;\n-\n-/// A synchronous timer object\n-///\n-/// Values of this type can be used to put the current task to sleep for a\n-/// period of time. Handles to this timer can also be created in the form of\n-/// receivers which will receive notifications over time.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, std_misc)]\n-/// # fn foo() {\n-/// use std::old_io::Timer;\n-/// use std::time::Duration;\n-///\n-/// let mut timer = Timer::new().unwrap();\n-/// timer.sleep(Duration::milliseconds(10)); // block the task for awhile\n-///\n-/// let timeout = timer.oneshot(Duration::milliseconds(10));\n-/// // do some work\n-/// timeout.recv().unwrap(); // wait for the timeout to expire\n-///\n-/// let periodic = timer.periodic(Duration::milliseconds(10));\n-/// loop {\n-///     periodic.recv().unwrap();\n-///     // this loop is only executed once every 10ms\n-/// }\n-/// # }\n-/// ```\n-///\n-/// If only sleeping is necessary, then a convenience API is provided through\n-/// the `old_io::timer` module.\n-///\n-/// ```\n-/// # #![feature(old_io, std_misc)]\n-/// # fn foo() {\n-/// use std::old_io::timer;\n-/// use std::time::Duration;\n-///\n-/// // Put this task to sleep for 5 seconds\n-/// timer::sleep(Duration::seconds(5));\n-/// # }\n-/// ```\n-pub struct Timer {\n-    inner: TimerImp,\n-}\n-\n-struct TimerCallback { tx: Sender<()> }\n-\n-/// Sleep the current task for the specified duration.\n-///\n-/// When provided a zero or negative `duration`, the function will\n-/// return immediately.\n-pub fn sleep(duration: Duration) {\n-    let timer = Timer::new();\n-    let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n-\n-    timer.sleep(duration)\n-}\n-\n-impl Timer {\n-    /// Creates a new timer which can be used to put the current task to sleep\n-    /// for a number of milliseconds, or to possibly create channels which will\n-    /// get notified after an amount of time has passed.\n-    pub fn new() -> IoResult<Timer> {\n-        TimerImp::new().map(|t| Timer { inner: t })\n-    }\n-\n-    /// Blocks the current task for the specified duration.\n-    ///\n-    /// Note that this function will cause any other receivers for this timer to\n-    /// be invalidated (the other end will be closed).\n-    ///\n-    /// When provided a zero or negative `duration`, the function will\n-    /// return immediately.\n-    pub fn sleep(&mut self, duration: Duration) {\n-        // Short-circuit the timer backend for 0 duration\n-        let ms = in_ms_u64(duration);\n-        if ms == 0 { return }\n-        self.inner.sleep(ms);\n-    }\n-\n-    /// Creates a oneshot receiver which will have a notification sent when\n-    /// the specified duration has elapsed.\n-    ///\n-    /// This does *not* block the current task, but instead returns immediately.\n-    ///\n-    /// Note that this invalidates any previous receiver which has been created\n-    /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope). In particular, if\n-    /// this is called in method-chaining style, the receiver will be\n-    /// invalidated at the end of that statement, and all `recv` calls will\n-    /// fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.oneshot(Duration::milliseconds(10));\n-    ///\n-    /// for _ in 0..100 { /* do work */ }\n-    ///\n-    /// // blocks until 10 ms after the `oneshot` call\n-    /// ten_milliseconds.recv().unwrap();\n-    /// ```\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// // Incorrect, method chaining-style:\n-    /// let mut five_ms = Timer::new().unwrap().oneshot(Duration::milliseconds(5));\n-    /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv().unwrap()\n-    /// ```\n-    ///\n-    /// When provided a zero or negative `duration`, the message will\n-    /// be sent immediately.\n-    pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-        // Short-circuit the timer backend for 0 duration\n-        if in_ms_u64(duration) != 0 {\n-            self.inner.oneshot(in_ms_u64(duration), Box::new(TimerCallback { tx: tx }));\n-        } else {\n-            tx.send(()).unwrap();\n-        }\n-        return rx\n-    }\n-\n-    /// Creates a receiver which will have a continuous stream of notifications\n-    /// being sent each time the specified duration has elapsed.\n-    ///\n-    /// This does *not* block the current task, but instead returns\n-    /// immediately. The first notification will not be received immediately,\n-    /// but rather after the first duration.\n-    ///\n-    /// Note that this invalidates any previous receiver which has been created\n-    /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope). In particular, if\n-    /// this is called in method-chaining style, the receiver will be\n-    /// invalidated at the end of that statement, and all `recv` calls will\n-    /// fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.periodic(Duration::milliseconds(10));\n-    ///\n-    /// for _ in 0..100 { /* do work */ }\n-    ///\n-    /// // blocks until 10 ms after the `periodic` call\n-    /// ten_milliseconds.recv().unwrap();\n-    ///\n-    /// for _ in 0..100 { /* do work */ }\n-    ///\n-    /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n-    /// // previous `recv`)\n-    /// ten_milliseconds.recv().unwrap();\n-    /// ```\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// // Incorrect, method chaining-style.\n-    /// let mut five_ms = Timer::new().unwrap().periodic(Duration::milliseconds(5));\n-    /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv().unwrap()\n-    /// ```\n-    ///\n-    /// When provided a zero or negative `duration`, the messages will\n-    /// be sent without delay.\n-    pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n-        let ms = in_ms_u64(duration);\n-        // FIXME: The backend implementations don't ever send a message\n-        // if given a 0 ms duration. Temporarily using 1ms. It's\n-        // not clear what use a 0ms period is anyway...\n-        let ms = if ms == 0 { 1 } else { ms };\n-        let (tx, rx) = channel();\n-        self.inner.period(ms, Box::new(TimerCallback { tx: tx }));\n-        return rx\n-    }\n-}\n-\n-impl Callback for TimerCallback {\n-    fn call(&mut self) {\n-        let _ = self.tx.send(());\n-    }\n-}\n-\n-fn in_ms_u64(d: Duration) -> u64 {\n-    let ms = d.num_milliseconds();\n-    if ms < 0 { return 0 };\n-    return ms as u64;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Timer;\n-    use thread;\n-    use time::Duration;\n-\n-    #[test]\n-    fn test_timer_send() {\n-        let mut timer = Timer::new().unwrap();\n-        thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_simple() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_oneshot() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_oneshot_forget() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(100000000));\n-    }\n-\n-    #[test]\n-    fn oneshot_twice() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx1 = timer.oneshot(Duration::milliseconds(10000));\n-        let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        assert!(rx1.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn test_io_timer_oneshot_then_sleep() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(100000000));\n-        timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n-\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_periodic() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_periodic_forget() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.periodic(Duration::milliseconds(100000000));\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_standalone() {\n-        super::sleep(Duration::milliseconds(1))\n-    }\n-\n-    #[test]\n-    fn oneshot() {\n-        let mut timer = Timer::new().unwrap();\n-\n-        let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        assert!(rx.recv().is_err());\n-\n-        let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn test_override() {\n-        let mut timer = Timer::new().unwrap();\n-        let orx = timer.oneshot(Duration::milliseconds(100));\n-        let prx = timer.periodic(Duration::milliseconds(100));\n-        timer.sleep(Duration::milliseconds(1));\n-        assert!(orx.recv().is_err());\n-        assert!(prx.recv().is_err());\n-        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn period() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        let rx2 = timer.periodic(Duration::milliseconds(1));\n-        rx2.recv().unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn sleep() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(1));\n-        timer.sleep(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn oneshot_fail() {\n-        let mut timer = Timer::new().unwrap();\n-        let _rx = timer.oneshot(Duration::milliseconds(1));\n-        panic!();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn period_fail() {\n-        let mut timer = Timer::new().unwrap();\n-        let _rx = timer.periodic(Duration::milliseconds(1));\n-        panic!();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn normal_fail() {\n-        let _timer = Timer::new().unwrap();\n-        panic!();\n-    }\n-\n-    #[test]\n-    fn closing_channel_during_drop_doesnt_kill_everything() {\n-        // see issue #10375\n-        let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n-\n-        thread::spawn(move|| {\n-            let _ = timer_rx.recv();\n-        });\n-\n-        // when we drop the TimerWatcher we're going to destroy the channel,\n-        // which must wake up the task on the other end\n-    }\n-\n-    #[test]\n-    fn reset_doesnt_switch_tasks() {\n-        // similar test to the one above.\n-        let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n-\n-        thread::spawn(move|| {\n-            let _ = timer_rx.recv();\n-        });\n-\n-        timer.oneshot(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    fn reset_doesnt_switch_tasks2() {\n-        // similar test to the one above.\n-        let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n-\n-        thread::spawn(move|| {\n-            let _ = timer_rx.recv();\n-        });\n-\n-        timer.sleep(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_oneshot() {\n-        let rx = {\n-            let mut timer = Timer::new().unwrap();\n-            timer.oneshot(Duration::milliseconds(1000))\n-        };\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_period() {\n-        let rx = {\n-            let mut timer = Timer::new().unwrap();\n-            timer.periodic(Duration::milliseconds(1000))\n-        };\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_oneshot() {\n-        let mut timer1 = Timer::new().unwrap();\n-        timer1.oneshot(Duration::milliseconds(1));\n-        let mut timer2 = Timer::new().unwrap();\n-        // while sleeping, the previous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(Duration::milliseconds(2));\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_period() {\n-        let mut timer1 = Timer::new().unwrap();\n-        timer1.periodic(Duration::milliseconds(1));\n-        let mut timer2 = Timer::new().unwrap();\n-        // while sleeping, the previous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(Duration::milliseconds(2));\n-    }\n-\n-    #[test]\n-    fn sleep_zero() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(0));\n-    }\n-\n-    #[test]\n-    fn sleep_negative() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(-1000000));\n-    }\n-\n-    #[test]\n-    fn oneshot_zero() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(0));\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn oneshot_negative() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(-1000000));\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn periodic_zero() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(0));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn periodic_negative() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(-1000000));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-}"}, {"sha": "818c8e76d6087aff50dbe3ae3e3675159bc5b0dd", "filename": "src/libstd/old_io/util.rs", "status": "removed", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,495 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utility implementations of Reader and Writer\n-\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-use cmp;\n-use old_io::{self, Reader, Writer, Buffer};\n-use slice::bytes::MutableByteVector;\n-\n-/// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n-#[derive(Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct LimitReader<R> {\n-    limit: usize,\n-    inner: R\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader> LimitReader<R> {\n-    /// Creates a new `LimitReader`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(r: R, limit: usize) -> LimitReader<R> {\n-        LimitReader { limit: limit, inner: r }\n-    }\n-\n-    /// Consumes the `LimitReader`, returning the underlying `Reader`.\n-    pub fn into_inner(self) -> R { self.inner }\n-\n-    /// Returns the number of bytes that can be read before the `LimitReader`\n-    /// will return EOF.\n-    ///\n-    /// # Note\n-    ///\n-    /// The reader may reach EOF after reading fewer bytes than indicated by\n-    /// this method if the underlying reader reaches EOF.\n-    pub fn limit(&self) -> usize { self.limit }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader> Reader for LimitReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        if self.limit == 0 {\n-            return Err(old_io::standard_error(old_io::EndOfFile));\n-        }\n-\n-        let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(&mut buf[..len]);\n-        match res {\n-            Ok(len) => self.limit -= len,\n-            _ => {}\n-        }\n-        res\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Buffer> Buffer for LimitReader<R> {\n-    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n-        let amt = try!(self.inner.fill_buf());\n-        let buf = &amt[..cmp::min(amt.len(), self.limit)];\n-        if buf.len() == 0 {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(buf)\n-        }\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        // Don't let callers reset the limit by passing an overlarge value\n-        let amt = cmp::min(amt, self.limit);\n-        self.limit -= amt;\n-        self.inner.consume(amt);\n-    }\n-\n-}\n-\n-/// A `Writer` which ignores bytes written to it, like /dev/null.\n-#[derive(Copy, Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::sink() instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct NullWriter;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::sink() instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Writer for NullWriter {\n-    #[inline]\n-    fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n-}\n-\n-/// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n-#[derive(Copy, Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct ZeroReader;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Reader for ZeroReader {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        buf.set_memory(0);\n-        Ok(buf.len())\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Buffer for ZeroReader {\n-    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n-        static DATA: [u8; 64] = [0; 64];\n-        Ok(&DATA)\n-    }\n-\n-    fn consume(&mut self, _amt: usize) {}\n-}\n-\n-/// A `Reader` which is always at EOF, like /dev/null.\n-#[derive(Copy, Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct NullReader;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Reader for NullReader {\n-    #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        Err(old_io::standard_error(old_io::EndOfFile))\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Buffer for NullReader {\n-    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n-        Err(old_io::standard_error(old_io::EndOfFile))\n-    }\n-    fn consume(&mut self, _amt: usize) {}\n-}\n-\n-/// A `Writer` which multiplexes writes to a set of `Writer`s.\n-///\n-/// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n-/// that error is returned immediately and remaining `Writer`s are not called.\n-#[derive(Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Broadcast instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct MultiWriter<W> {\n-    writers: Vec<W>\n-}\n-\n-impl<W> MultiWriter<W> where W: Writer {\n-    /// Creates a new `MultiWriter`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's broadcast method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(writers: Vec<W>) -> MultiWriter<W> {\n-        MultiWriter { writers: writers }\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Broadcast instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<W> Writer for MultiWriter<W> where W: Writer {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n-        for writer in &mut self.writers {\n-            try!(writer.write_all(buf));\n-        }\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> old_io::IoResult<()> {\n-        for writer in &mut self.writers {\n-            try!(writer.flush());\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// A `Reader` which chains input from multiple `Reader`s, reading each to\n-/// completion before moving onto the next.\n-#[derive(Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct ChainedReader<I, R> {\n-    readers: I,\n-    cur_reader: Option<R>,\n-}\n-\n-impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n-    /// Creates a new `ChainedReader`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's chain method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(mut readers: I) -> ChainedReader<I, R> {\n-        let r = readers.next();\n-        ChainedReader { readers: readers, cur_reader: r }\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        loop {\n-            let err = match self.cur_reader {\n-                Some(ref mut r) => {\n-                    match r.read(buf) {\n-                        Ok(len) => return Ok(len),\n-                        Err(ref e) if e.kind == old_io::EndOfFile => None,\n-                        Err(e) => Some(e),\n-                    }\n-                }\n-                None => break\n-            };\n-            self.cur_reader = self.readers.next();\n-            match err {\n-                Some(e) => return Err(e),\n-                None => {}\n-            }\n-        }\n-        Err(old_io::standard_error(old_io::EndOfFile))\n-    }\n-}\n-\n-/// A `Reader` which forwards input from another `Reader`, passing it along to\n-/// a `Writer` as well. Similar to the `tee(1)` command.\n-#[derive(Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct TeeReader<R, W> {\n-    reader: R,\n-    writer: W,\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader, W: Writer> TeeReader<R, W> {\n-    /// Creates a new `TeeReader`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's tee method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(r: R, w: W) -> TeeReader<R, W> {\n-        TeeReader { reader: r, writer: w }\n-    }\n-\n-    /// Consumes the `TeeReader`, returning the underlying `Reader` and\n-    /// `Writer`.\n-    pub fn into_inner(self) -> (R, W) {\n-        let TeeReader { reader, writer } = self;\n-        (reader, writer)\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        self.reader.read(buf).and_then(|len| {\n-            self.writer.write_all(&mut buf[..len]).map(|()| len)\n-        })\n-    }\n-}\n-\n-/// Copies all data from a `Reader` to a `Writer`.\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io's copy function instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()> {\n-    let mut buf = [0; super::DEFAULT_BUF_SIZE];\n-    loop {\n-        let len = match r.read(&mut buf) {\n-            Ok(len) => len,\n-            Err(ref e) if e.kind == old_io::EndOfFile => return Ok(()),\n-            Err(e) => return Err(e),\n-        };\n-        try!(w.write_all(&buf[..len]));\n-    }\n-}\n-\n-/// An adaptor converting an `Iterator<u8>` to a `Reader`.\n-#[derive(Clone, Debug)]\n-pub struct IterReader<T> {\n-    iter: T,\n-}\n-\n-impl<T: Iterator<Item=u8>> IterReader<T> {\n-    /// Creates a new `IterReader` which will read from the specified\n-    /// `Iterator`.\n-    pub fn new(iter: T) -> IterReader<T> {\n-        IterReader { iter: iter }\n-    }\n-}\n-\n-impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        let mut len = 0;\n-        for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n-            *slot = elt;\n-            len += 1;\n-        }\n-        if len == 0 && buf.len() != 0 {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(len)\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use old_io::{MemReader, ByRefReader, Reader, Writer, Buffer};\n-    use old_io;\n-    use super::*;\n-\n-    #[test]\n-    fn test_limit_reader_unlimited() {\n-        let mut r = MemReader::new(vec!(0, 1, 2));\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_limit_reader_limited() {\n-        let mut r = MemReader::new(vec!(0, 1, 2));\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!(r.read_to_end().unwrap(), [0, 1]);\n-        }\n-        assert_eq!(r.read_to_end().unwrap(), [2]);\n-    }\n-\n-    #[test]\n-    fn test_limit_reader_limit() {\n-        let r = MemReader::new(vec!(0, 1, 2));\n-        let mut r = LimitReader::new(r, 3);\n-        assert_eq!(3, r.limit());\n-        assert_eq!(0, r.read_byte().unwrap());\n-        assert_eq!(2, r.limit());\n-        assert_eq!(r.read_to_end().unwrap(), [1, 2]);\n-        assert_eq!(0, r.limit());\n-    }\n-\n-    #[test]\n-    fn test_limit_reader_overlong_consume() {\n-        let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n-        let mut r = LimitReader::new(r.by_ref(), 1);\n-        r.consume(2);\n-        assert_eq!(r.read_to_end().unwrap(), []);\n-    }\n-\n-    #[test]\n-    fn test_null_writer() {\n-        let mut s = NullWriter;\n-        let buf = vec![0, 0, 0];\n-        s.write_all(&buf).unwrap();\n-        s.flush().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_zero_reader() {\n-        let mut s = ZeroReader;\n-        let mut buf = vec![1, 2, 3];\n-        assert_eq!(s.read(&mut buf), Ok(3));\n-        assert_eq!(buf, [0, 0, 0]);\n-    }\n-\n-    #[test]\n-    fn test_null_reader() {\n-        let mut r = NullReader;\n-        let mut buf = vec![0];\n-        assert!(r.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_multi_writer() {\n-        static mut writes: usize = 0;\n-        static mut flushes: usize = 0;\n-\n-        struct TestWriter;\n-        impl Writer for TestWriter {\n-            fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> {\n-                unsafe { writes += 1 }\n-                Ok(())\n-            }\n-\n-            fn flush(&mut self) -> old_io::IoResult<()> {\n-                unsafe { flushes += 1 }\n-                Ok(())\n-            }\n-        }\n-\n-        let mut multi = MultiWriter::new(vec!(box TestWriter as Box<Writer>,\n-                                              box TestWriter as Box<Writer>));\n-        multi.write_all(&[1, 2, 3]).unwrap();\n-        assert_eq!(2, unsafe { writes });\n-        assert_eq!(0, unsafe { flushes });\n-        multi.flush().unwrap();\n-        assert_eq!(2, unsafe { writes });\n-        assert_eq!(2, unsafe { flushes });\n-    }\n-\n-    #[test]\n-    fn test_chained_reader() {\n-        let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n-                      MemReader::new(vec!(2, 3)));\n-        let mut r = ChainedReader::new(rs.into_iter());\n-        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_tee_reader() {\n-        let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n-                                   Vec::new());\n-        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n-        let (_, w) = r.into_inner();\n-        assert_eq!(w, [0, 1, 2]);\n-    }\n-\n-    #[test]\n-    fn test_copy() {\n-        let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n-        let mut w = Vec::new();\n-        copy(&mut r, &mut w).unwrap();\n-        assert_eq!(w, [0, 1, 2, 3, 4]);\n-    }\n-\n-    #[test]\n-    fn limit_reader_buffer() {\n-        let mut r: &[u8] = b\"0123456789\\n0123456789\\n\";\n-        let r = &mut r;\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 3);\n-            assert_eq!(r.read_line(), Ok(\"012\".to_string()));\n-            assert_eq!(r.limit(), 0);\n-            assert_eq!(r.read_line().err().unwrap().kind, old_io::EndOfFile);\n-        }\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 9);\n-            assert_eq!(r.read_line(), Ok(\"3456789\\n\".to_string()));\n-            assert_eq!(r.limit(), 1);\n-            assert_eq!(r.read_line(), Ok(\"0\".to_string()));\n-        }\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 100);\n-            assert_eq!(r.read_char(), Ok('1'));\n-            assert_eq!(r.limit(), 99);\n-            assert_eq!(r.read_line(), Ok(\"23456789\\n\".to_string()));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iter_reader() {\n-        let mut r = IterReader::new(0..8);\n-        let mut buf = [0, 0, 0];\n-        let len = r.read(&mut buf).unwrap();\n-        assert_eq!(len, 3);\n-        assert!(buf == [0, 1, 2]);\n-\n-        let len = r.read(&mut buf).unwrap();\n-        assert_eq!(len, 3);\n-        assert!(buf == [3, 4, 5]);\n-\n-        let len = r.read(&mut buf).unwrap();\n-        assert_eq!(len, 2);\n-        assert!(buf == [6, 7, 5]);\n-\n-        assert_eq!(r.read(&mut buf).unwrap_err().kind, old_io::EndOfFile);\n-    }\n-\n-    #[test]\n-    fn iter_reader_zero_length() {\n-        let mut r = IterReader::new(0..8);\n-        let mut buf = [];\n-        assert_eq!(Ok(0), r.read(&mut buf));\n-    }\n-}"}, {"sha": "2dee90e9a6660daad699813cf8bac4ab0923bae6", "filename": "src/libstd/old_path/mod.rs", "status": "removed", "additions": 0, "deletions": 985, "changes": 985, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,985 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Cross-platform path support\n-//!\n-//! This module implements support for two flavors of paths. `PosixPath` represents a path on any\n-//! unix-like system, whereas `WindowsPath` represents a path on Windows. This module also exposes\n-//! a typedef `Path` which is equal to the appropriate platform-specific path variant.\n-//!\n-//! Both `PosixPath` and `WindowsPath` implement a trait `GenericPath`, which contains the set of\n-//! methods that behave the same for both paths. They each also implement some methods that could\n-//! not be expressed in `GenericPath`, yet behave identically for both path flavors, such as\n-//! `.components()`.\n-//!\n-//! The three main design goals of this module are 1) to avoid unnecessary allocation, 2) to behave\n-//! the same regardless of which flavor of path is being used, and 3) to support paths that cannot\n-//! be represented in UTF-8 (as Linux has no restriction on paths beyond disallowing NUL).\n-//!\n-//! ## Usage\n-//!\n-//! Usage of this module is fairly straightforward. Unless writing platform-specific code, `Path`\n-//! should be used to refer to the platform-native path.\n-//!\n-//! Creation of a path is typically done with either `Path::new(some_str)` or\n-//! `Path::new(some_vec)`. This path can be modified with `.push()` and `.pop()` (and other\n-//! setters). The resulting Path can either be passed to another API that expects a path, or can be\n-//! turned into a `&[u8]` with `.as_vec()` or a `Option<&str>` with `.as_str()`. Similarly,\n-//! attributes of the path can be queried with methods such as `.filename()`. There are also\n-//! methods that return a new path instead of modifying the receiver, such as `.join()` or\n-//! `.dir_path()`.\n-//!\n-//! Paths are always kept in normalized form. This means that creating the path\n-//! `Path::new(\"a/b/../c\")` will return the path `a/c`. Similarly any attempt to mutate the path\n-//! will always leave it in normalized form.\n-//!\n-//! When rendering a path to some form of output, there is a method `.display()` which is\n-//! compatible with the `format!()` parameter `{}`. This will render the path as a string,\n-//! replacing all non-utf8 sequences with the Replacement Character (U+FFFD). As such it is not\n-//! suitable for passing to any API that actually operates on the path; it is only intended for\n-//! display.\n-//!\n-//! ## Examples\n-//!\n-//! ```rust,ignore\n-//! # #![feature(old_path, old_io)]\n-//! use std::old_io::fs::PathExtensions;\n-//! use std::old_path::{Path, GenericPath};\n-//!\n-//! let mut path = Path::new(\"/tmp/path\");\n-//! println!(\"path: {}\", path.display());\n-//! path.set_filename(\"foo\");\n-//! path.push(\"bar\");\n-//! println!(\"new path: {}\", path.display());\n-//! println!(\"path exists: {}\", path.exists());\n-//! ```\n-\n-#![unstable(feature = \"old_path\")]\n-#![deprecated(since = \"1.0.0\", reason = \"use std::path instead\")]\n-#![allow(deprecated)] // seriously this is all deprecated\n-#![allow(unused_imports)]\n-\n-use core::marker::Sized;\n-use ffi::CString;\n-use clone::Clone;\n-use borrow::Cow;\n-use fmt;\n-use iter::Iterator;\n-use option::Option;\n-use option::Option::{None, Some};\n-use str;\n-use string::String;\n-use vec::Vec;\n-\n-/// Typedef for POSIX file paths.\n-/// See `posix::Path` for more info.\n-pub use self::posix::Path as PosixPath;\n-\n-/// Typedef for Windows file paths.\n-/// See `windows::Path` for more info.\n-pub use self::windows::Path as WindowsPath;\n-\n-/// Typedef for the platform-native path type\n-#[cfg(unix)]\n-pub use self::posix::Path as Path;\n-/// Typedef for the platform-native path type\n-#[cfg(windows)]\n-pub use self::windows::Path as Path;\n-\n-/// Typedef for the platform-native component iterator\n-#[cfg(unix)]\n-pub use self::posix::Components as Components;\n-/// Typedef for the platform-native component iterator\n-#[cfg(windows)]\n-pub use self::windows::Components as Components;\n-\n-/// Typedef for the platform-native str component iterator\n-#[cfg(unix)]\n-pub use self::posix::StrComponents as StrComponents;\n-/// Typedef for the platform-native str component iterator\n-#[cfg(windows)]\n-pub use self::windows::StrComponents as StrComponents;\n-\n-/// Alias for the platform-native separator character.\n-#[cfg(unix)]\n-pub use self::posix::SEP as SEP;\n-/// Alias for the platform-native separator character.\n-#[cfg(windows)]\n-pub use self::windows::SEP as SEP;\n-\n-/// Alias for the platform-native separator byte.\n-#[cfg(unix)]\n-pub use self::posix::SEP_BYTE as SEP_BYTE;\n-/// Alias for the platform-native separator byte.\n-#[cfg(windows)]\n-pub use self::windows::SEP_BYTE as SEP_BYTE;\n-\n-/// Typedef for the platform-native separator char func\n-#[cfg(unix)]\n-pub use self::posix::is_sep as is_sep;\n-/// Typedef for the platform-native separator char func\n-#[cfg(windows)]\n-pub use self::windows::is_sep as is_sep;\n-/// Typedef for the platform-native separator byte func\n-#[cfg(unix)]\n-pub use self::posix::is_sep_byte as is_sep_byte;\n-/// Typedef for the platform-native separator byte func\n-#[cfg(windows)]\n-pub use self::windows::is_sep_byte as is_sep_byte;\n-\n-pub mod posix;\n-pub mod windows;\n-\n-/// A trait that represents the generic operations available on paths\n-pub trait GenericPath: Clone + GenericPathUnsafe {\n-    /// Creates a new Path from a byte vector or string.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_path)]\n-    /// # fn main() {\n-    /// use std::old_path::Path;\n-    /// let path = Path::new(\"foo/bar\");\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the path contains a NUL.\n-    ///\n-    /// See individual Path impls for additional restrictions.\n-    #[inline]\n-    fn new<T: BytesContainer>(path: T) -> Self {\n-        assert!(!contains_nul(&path));\n-        unsafe { GenericPathUnsafe::new_unchecked(path) }\n-    }\n-\n-    /// Creates a new Path from a byte vector or string, if possible.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_path)]\n-    /// # fn main() {\n-    /// use std::old_path::Path;\n-    /// let x: &[u8] = b\"foo\\0\";\n-    /// assert!(Path::new_opt(x).is_none());\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {\n-        if contains_nul(&path) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::new_unchecked(path) })\n-        }\n-    }\n-\n-    /// Returns the path as a string, if possible.\n-    /// If the path is not representable in utf-8, this returns None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def\");\n-    /// assert_eq!(p.as_str(), Some(\"/abc/def\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.as_vec()).ok()\n-    }\n-\n-    /// Returns the path as a byte vector\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// assert_eq!(p.as_vec(), b\"abc/def\");\n-    /// # }\n-    /// ```\n-    fn as_vec<'a>(&'a self) -> &'a [u8];\n-\n-    /// Converts the Path into an owned byte vector\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// assert_eq!(p.into_vec(), b\"abc/def\".to_vec());\n-    /// // attempting to use p now results in \"error: use of moved value\"\n-    /// # }\n-    /// ```\n-    fn into_vec(self) -> Vec<u8>;\n-\n-    /// Returns an object that implements `Display` for printing paths\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// println!(\"{}\", p.display()); // prints \"abc/def\"\n-    /// # }\n-    /// ```\n-    fn display<'a>(&'a self) -> Display<'a, Self> {\n-        Display{ path: self, filename: false }\n-    }\n-\n-    /// Returns an object that implements `Display` for printing filenames\n-    ///\n-    /// If there is no filename, nothing will be printed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// println!(\"{}\", p.filename_display()); // prints \"def\"\n-    /// # }\n-    /// ```\n-    fn filename_display<'a>(&'a self) -> Display<'a, Self> {\n-        Display{ path: self, filename: true }\n-    }\n-\n-    /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n-    /// If `self` has no directory component, returns ['.'].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.dirname(), b\"abc/def\");\n-    /// # }\n-    /// ```\n-    fn dirname<'a>(&'a self) -> &'a [u8];\n-\n-    /// Returns the directory component of `self`, as a string, if possible.\n-    /// See `dirname` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.dirname_str(), Some(\"abc/def\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.dirname()).ok()\n-    }\n-\n-    /// Returns the file component of `self`, as a byte vector.\n-    /// If `self` represents the root of the file hierarchy, returns None.\n-    /// If `self` is \".\" or \"..\", returns None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.filename(), Some(&b\"ghi\"[..]));\n-    /// # }\n-    /// ```\n-    fn filename<'a>(&'a self) -> Option<&'a [u8]>;\n-\n-    /// Returns the file component of `self`, as a string, if possible.\n-    /// See `filename` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.filename_str(), Some(\"ghi\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filename().and_then(|s| str::from_utf8(s).ok())\n-    }\n-\n-    /// Returns the stem of the filename of `self`, as a byte vector.\n-    /// The stem is the portion of the filename just before the last '.'.\n-    /// If there is no '.', the entire filename is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def.txt\");\n-    /// assert_eq!(p.filestem(), Some(&b\"def\"[..]));\n-    /// # }\n-    /// ```\n-    fn filestem<'a>(&'a self) -> Option<&'a [u8]> {\n-        match self.filename() {\n-            None => None,\n-            Some(name) => Some({\n-                let dot = b'.';\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => name,\n-                    Some(1) if name == b\"..\" => name,\n-                    Some(pos) => &name[..pos]\n-                }\n-            })\n-        }\n-    }\n-\n-    /// Returns the stem of the filename of `self`, as a string, if possible.\n-    /// See `filestem` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def.txt\");\n-    /// assert_eq!(p.filestem_str(), Some(\"def\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filestem().and_then(|s| str::from_utf8(s).ok())\n-    }\n-\n-    /// Returns the extension of the filename of `self`, as an optional byte vector.\n-    /// The extension is the portion of the filename just after the last '.'.\n-    /// If there is no extension, None is returned.\n-    /// If the filename ends in '.', the empty vector is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.extension(), Some(&b\"txt\"[..]));\n-    /// # }\n-    /// ```\n-    fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n-        match self.filename() {\n-            None => None,\n-            Some(name) => {\n-                let dot = b'.';\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => None,\n-                    Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(&name[pos+1..])\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns the extension of the filename of `self`, as a string, if possible.\n-    /// See `extension` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.extension_str(), Some(\"txt\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().and_then(|s| str::from_utf8(s).ok())\n-    }\n-\n-    /// Replaces the filename portion of the path with the given byte vector or string.\n-    /// If the replacement name is [], this is equivalent to popping the path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// p.set_filename(\"foo.dat\");\n-    /// assert!(p == Path::new(\"abc/foo.dat\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the filename contains a NUL.\n-    #[inline]\n-    fn set_filename<T: BytesContainer>(&mut self, filename: T) {\n-        assert!(!contains_nul(&filename));\n-        unsafe { self.set_filename_unchecked(filename) }\n-    }\n-\n-    /// Replaces the extension with the given byte vector or string.\n-    /// If there is no extension in `self`, this adds one.\n-    /// If the argument is [] or \"\", this removes the extension.\n-    /// If `self` has no filename, this is a no-op.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// p.set_extension(\"csv\");\n-    /// assert_eq!(p, Path::new(\"abc/def.csv\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the extension contains a NUL.\n-    fn set_extension<T: BytesContainer>(&mut self, extension: T) {\n-        assert!(!contains_nul(&extension));\n-\n-        let val = self.filename().and_then(|name| {\n-            let dot = b'.';\n-            let extlen = extension.container_as_bytes().len();\n-            match (name.rposition_elem(&dot), extlen) {\n-                (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name[..idx].to_vec()),\n-                (idx, extlen) => {\n-                    let idx = match idx {\n-                        None | Some(0) => name.len(),\n-                        Some(val) => val\n-                    };\n-\n-                    let mut v;\n-                    v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(&name[..idx]);\n-                    v.push(dot);\n-                    v.push_all(extension.container_as_bytes());\n-                    Some(v)\n-                }\n-            }\n-        });\n-\n-        match val {\n-            None => (),\n-            Some(v) => unsafe { self.set_filename_unchecked(v) }\n-        }\n-    }\n-\n-    /// Returns a new Path constructed by replacing the filename with the given\n-    /// byte vector or string.\n-    /// See `set_filename` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.with_filename(\"foo.dat\"), Path::new(\"abc/foo.dat\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the filename contains a NUL.\n-    #[inline]\n-    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self {\n-        let mut p = self.clone();\n-        p.set_filename(filename);\n-        p\n-    }\n-\n-    /// Returns a new Path constructed by setting the extension to the given\n-    /// byte vector or string.\n-    /// See `set_extension` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.with_extension(\"csv\"), Path::new(\"abc/def.csv\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the extension contains a NUL.\n-    #[inline]\n-    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self {\n-        let mut p = self.clone();\n-        p.set_extension(extension);\n-        p\n-    }\n-\n-    /// Returns the directory component of `self`, as a Path.\n-    /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.dir_path(), Path::new(\"abc/def\"));\n-    /// # }\n-    /// ```\n-    fn dir_path(&self) -> Self {\n-        // self.dirname() returns a NUL-free vector\n-        unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n-    }\n-\n-    /// Returns a Path that represents the filesystem root that `self` is rooted in.\n-    ///\n-    /// If `self` is not absolute, or vol/cwd-relative in the case of Windows, this returns None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// assert_eq!(Path::new(\"abc/def\").root_path(), None);\n-    /// assert_eq!(Path::new(\"/abc/def\").root_path(), Some(Path::new(\"/\")));\n-    /// # }\n-    /// ```\n-    fn root_path(&self) -> Option<Self>;\n-\n-    /// Pushes a path (as a byte vector or string) onto `self`.\n-    /// If the argument represents an absolute path, it replaces `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"foo/bar\");\n-    /// p.push(\"baz.txt\");\n-    /// assert_eq!(p, Path::new(\"foo/bar/baz.txt\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the path contains a NUL.\n-    #[inline]\n-    fn push<T: BytesContainer>(&mut self, path: T) {\n-        assert!(!contains_nul(&path));\n-        unsafe { self.push_unchecked(path) }\n-    }\n-\n-    /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n-    /// See `push` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"foo\");\n-    /// p.push_many(&[\"bar\", \"baz.txt\"]);\n-    /// assert_eq!(p, Path::new(\"foo/bar/baz.txt\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n-        let t: Option<&T> = None;\n-        if BytesContainer::is_str(t) {\n-            for p in paths {\n-                self.push(p.container_as_str().unwrap())\n-            }\n-        } else {\n-            for p in paths {\n-                self.push(p.container_as_bytes())\n-            }\n-        }\n-    }\n-\n-    /// Removes the last path component from the receiver.\n-    /// Returns `true` if the receiver was modified, or `false` if it already\n-    /// represented the root of the file hierarchy.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"foo/bar/baz.txt\");\n-    /// p.pop();\n-    /// assert_eq!(p, Path::new(\"foo/bar\"));\n-    /// # }\n-    /// ```\n-    fn pop(&mut self) -> bool;\n-\n-    /// Returns a new Path constructed by joining `self` with the given path\n-    /// (as a byte vector or string).\n-    /// If the given path is absolute, the new Path will represent just that.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/foo\");\n-    /// assert_eq!(p.join(\"bar.txt\"), Path::new(\"/foo/bar.txt\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the path contains a NUL.\n-    #[inline]\n-    fn join<T: BytesContainer>(&self, path: T) -> Self {\n-        let mut p = self.clone();\n-        p.push(path);\n-        p\n-    }\n-\n-    /// Returns a new Path constructed by joining `self` with the given paths\n-    /// (as byte vectors or strings).\n-    /// See `join` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo\");\n-    /// let fbbq = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// assert_eq!(p.join_many(&[\"bar\", \"baz\", \"quux.txt\"]), fbbq);\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self {\n-        let mut p = self.clone();\n-        p.push_many(paths);\n-        p\n-    }\n-\n-    /// Returns whether `self` represents an absolute path.\n-    /// An absolute path is defined as one that, when joined to another path, will\n-    /// yield back the same absolute path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def\");\n-    /// assert!(p.is_absolute());\n-    /// # }\n-    /// ```\n-    fn is_absolute(&self) -> bool;\n-\n-    /// Returns whether `self` represents a relative path.\n-    /// Typically this is the inverse of `is_absolute`.\n-    /// But for Windows paths, it also means the path is not volume-relative or\n-    /// relative to the current working directory.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// assert!(p.is_relative());\n-    /// # }\n-    /// ```\n-    fn is_relative(&self) -> bool {\n-        !self.is_absolute()\n-    }\n-\n-    /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n-    /// If both paths are relative, they are compared as though they are relative\n-    /// to the same parent path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// let fb = Path::new(\"foo/bar\");\n-    /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert!(fb.is_ancestor_of(&p));\n-    /// # }\n-    /// ```\n-    fn is_ancestor_of(&self, other: &Self) -> bool;\n-\n-    /// Returns the Path that, were it joined to `base`, would yield `self`.\n-    /// If no such path exists, None is returned.\n-    /// If `self` is absolute and `base` is relative, or on Windows if both\n-    /// paths refer to separate drives, an absolute path is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// let fb = Path::new(\"foo/bar\");\n-    /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert_eq!(p.path_relative_from(&fb), Some(bq));\n-    /// # }\n-    /// ```\n-    fn path_relative_from(&self, base: &Self) -> Option<Self>;\n-\n-    /// Returns whether the relative path `child` is a suffix of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert!(p.ends_with_path(&bq));\n-    /// # }\n-    /// ```\n-    fn ends_with_path(&self, child: &Self) -> bool;\n-}\n-\n-/// A trait that represents something bytes-like (e.g. a &[u8] or a &str)\n-pub trait BytesContainer {\n-    /// Returns a &[u8] representing the receiver\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8];\n-    /// Returns the receiver interpreted as a utf-8 string, if possible\n-    #[inline]\n-    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.container_as_bytes()).ok()\n-    }\n-    /// Returns whether .container_as_str() is guaranteed to not fail\n-    // FIXME (#8888): Remove unused arg once ::<for T> works\n-    #[inline]\n-    fn is_str(_: Option<&Self>) -> bool { false }\n-}\n-\n-/// A trait that represents the unsafe operations on GenericPaths\n-pub trait GenericPathUnsafe {\n-    /// Creates a new Path without checking for null bytes.\n-    /// The resulting Path will always be normalized.\n-    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;\n-\n-    /// Replaces the filename portion of the path without checking for null\n-    /// bytes.\n-    /// See `set_filename` for details.\n-    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);\n-\n-    /// Pushes a path onto `self` without checking for null bytes.\n-    /// See `push` for details.\n-    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);\n-}\n-\n-/// Helper struct for printing paths with format!()\n-pub struct Display<'a, P:'a> {\n-    path: &'a P,\n-    filename: bool\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: GenericPath> fmt::Debug for Display<'a, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.as_cow(), f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: GenericPath> fmt::Display for Display<'a, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_cow().fmt(f)\n-    }\n-}\n-\n-impl<'a, P: GenericPath> Display<'a, P> {\n-    /// Returns the path as a possibly-owned string.\n-    ///\n-    /// If the path is not UTF-8, invalid sequences will be replaced with the\n-    /// Unicode replacement char. This involves allocation.\n-    #[inline]\n-    pub fn as_cow(&self) -> Cow<'a, str> {\n-        String::from_utf8_lossy(if self.filename {\n-            match self.path.filename() {\n-                None => {\n-                    let result: &[u8] = &[];\n-                    result\n-                }\n-                Some(v) => v\n-            }\n-        } else {\n-            self.path.as_vec()\n-        })\n-    }\n-}\n-\n-impl BytesContainer for str {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self.as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str(&self) -> Option<&str> {\n-        Some(self)\n-    }\n-    #[inline]\n-    fn is_str(_: Option<&str>) -> bool { true }\n-}\n-\n-impl BytesContainer for String {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self.as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str(&self) -> Option<&str> {\n-        Some(&self[..])\n-    }\n-    #[inline]\n-    fn is_str(_: Option<&String>) -> bool { true }\n-}\n-\n-impl BytesContainer for [u8] {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self\n-    }\n-}\n-\n-impl BytesContainer for Vec<u8> {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        &self[..]\n-    }\n-}\n-\n-impl BytesContainer for CString {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_bytes()\n-    }\n-}\n-\n-impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        (**self).container_as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str(&self) -> Option<&str> {\n-        (**self).container_as_str()\n-    }\n-    #[inline]\n-    fn is_str(_: Option<& &'a T>) -> bool { BytesContainer::is_str(None::<&T>) }\n-}\n-\n-#[inline(always)]\n-fn contains_nul<T: BytesContainer>(v: &T) -> bool {\n-    v.container_as_bytes().iter().any(|&x| x == 0)\n-}"}, {"sha": "af63be2aa9e3f891d0ec2716f7a68cd8e4ddc6b6", "filename": "src/libstd/old_path/posix.rs", "status": "removed", "additions": 0, "deletions": 1347, "changes": 1347, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,1347 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! POSIX file path handling\n-\n-use clone::Clone;\n-use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n-use fmt;\n-use hash;\n-use old_io::Writer;\n-use iter::{Extend, Iterator, Map};\n-use marker::Sized;\n-use option::Option::{self, Some, None};\n-use result::Result::{self, Ok, Err};\n-use slice::{Split, SliceConcatExt};\n-use str::{self, FromStr};\n-use vec::Vec;\n-\n-use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n-\n-/// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> = Split<'a, u8, fn(&u8) -> bool>;\n-\n-/// Iterator that yields successive components of a Path as Option<&str>\n-pub type StrComponents<'a> =\n-    Map<Components<'a>, fn(&[u8]) -> Option<&str>>;\n-\n-/// Represents a POSIX file path\n-#[derive(Clone)]\n-pub struct Path {\n-    repr: Vec<u8>, // assumed to never be empty or contain NULs\n-    sepidx: Option<usize> // index of the final separator in repr\n-}\n-\n-/// The standard path separator character\n-pub const SEP: char = '/';\n-\n-/// The standard path separator byte\n-pub const SEP_BYTE: u8 = SEP as u8;\n-\n-/// Returns whether the given byte is a path separator\n-#[inline]\n-pub fn is_sep_byte(u: &u8) -> bool {\n-    *u as char == SEP\n-}\n-\n-/// Returns whether the given char is a path separator\n-#[inline]\n-pub fn is_sep(c: char) -> bool {\n-    c == SEP\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.display(), f)\n-    }\n-}\n-\n-impl PartialEq for Path {\n-    #[inline]\n-    fn eq(&self, other: &Path) -> bool {\n-        self.repr == other.repr\n-    }\n-}\n-\n-impl Eq for Path {}\n-\n-impl PartialOrd for Path {\n-    fn partial_cmp(&self, other: &Path) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Path {\n-    fn cmp(&self, other: &Path) -> Ordering {\n-        self.repr.cmp(&other.repr)\n-    }\n-}\n-\n-impl FromStr for Path {\n-    type Err = ParsePathError;\n-    fn from_str(s: &str) -> Result<Path, ParsePathError> {\n-        match Path::new_opt(s) {\n-            Some(p) => Ok(p),\n-            None => Err(ParsePathError),\n-        }\n-    }\n-}\n-\n-/// Valuelue indicating that a path could not be parsed from a string.\n-#[derive(Debug, Clone, PartialEq, Copy)]\n-pub struct ParsePathError;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Path {\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.repr.hash(state)\n-    }\n-}\n-\n-impl BytesContainer for Path {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_vec()\n-    }\n-}\n-\n-impl GenericPathUnsafe for Path {\n-    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n-        let path = Path::normalize(path.container_as_bytes());\n-        assert!(!path.is_empty());\n-        let idx = path.rposition_elem(&SEP_BYTE);\n-        Path{ repr: path, sepidx: idx }\n-    }\n-\n-    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n-        let filename = filename.container_as_bytes();\n-        match self.sepidx {\n-            None if self.repr == b\"..\" => {\n-                let mut v = Vec::with_capacity(3 + filename.len());\n-                v.push_all(dot_dot_static);\n-                v.push(SEP_BYTE);\n-                v.push_all(filename);\n-                // FIXME: this is slow\n-                self.repr = Path::normalize(&v);\n-            }\n-            None => {\n-                self.repr = Path::normalize(filename);\n-            }\n-            Some(idx) if &self.repr[idx+1..] == b\"..\" => {\n-                let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n-                v.push_all(&self.repr);\n-                v.push(SEP_BYTE);\n-                v.push_all(filename);\n-                // FIXME: this is slow\n-                self.repr = Path::normalize(&v);\n-            }\n-            Some(idx) => {\n-                let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(&self.repr[..idx+1]);\n-                v.push_all(filename);\n-                // FIXME: this is slow\n-                self.repr = Path::normalize(&v);\n-            }\n-        }\n-        self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n-    }\n-\n-    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n-        let path = path.container_as_bytes();\n-        if !path.is_empty() {\n-            if path[0] == SEP_BYTE {\n-                self.repr = Path::normalize(path);\n-            }  else {\n-                let mut v = Vec::with_capacity(self.repr.len() + path.len() + 1);\n-                v.push_all(&self.repr);\n-                v.push(SEP_BYTE);\n-                v.push_all(path);\n-                // FIXME: this is slow\n-                self.repr = Path::normalize(&v);\n-            }\n-            self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n-        }\n-    }\n-}\n-\n-impl GenericPath for Path {\n-    #[inline]\n-    fn as_vec<'a>(&'a self) -> &'a [u8] {\n-        &self.repr\n-    }\n-\n-    fn into_vec(self) -> Vec<u8> {\n-        self.repr\n-    }\n-\n-    fn dirname<'a>(&'a self) -> &'a [u8] {\n-        match self.sepidx {\n-            None if self.repr == b\"..\" => &self.repr,\n-            None => dot_static,\n-            Some(0) => &self.repr[..1],\n-            Some(idx) if &self.repr[idx+1..] == b\"..\" => &self.repr,\n-            Some(idx) => &self.repr[..idx]\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n-        match self.sepidx {\n-            None if self.repr == b\".\" || self.repr == b\"..\" => None,\n-            None => Some(&self.repr),\n-            Some(idx) if &self.repr[idx+1..] == b\"..\" => None,\n-            Some(0) if self.repr[1..].is_empty() => None,\n-            Some(idx) => Some(&self.repr[idx+1..])\n-        }\n-    }\n-\n-    fn pop(&mut self) -> bool {\n-        match self.sepidx {\n-            None if self.repr == b\".\" => false,\n-            None => {\n-                self.repr = vec![b'.'];\n-                self.sepidx = None;\n-                true\n-            }\n-            Some(0) if self.repr == b\"/\" => false,\n-            Some(idx) => {\n-                if idx == 0 {\n-                    self.repr.truncate(idx+1);\n-                } else {\n-                    self.repr.truncate(idx);\n-                }\n-                self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n-                true\n-            }\n-        }\n-    }\n-\n-    fn root_path(&self) -> Option<Path> {\n-        if self.is_absolute() {\n-            Some(Path::new(\"/\"))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_absolute(&self) -> bool {\n-        self.repr[0] == SEP_BYTE\n-    }\n-\n-    fn is_ancestor_of(&self, other: &Path) -> bool {\n-        if self.is_absolute() != other.is_absolute() {\n-            false\n-        } else {\n-            let mut ita = self.components();\n-            let mut itb = other.components();\n-            if self.repr == b\".\" {\n-                return match itb.next() {\n-                    None => true,\n-                    Some(b) => b != b\"..\"\n-                };\n-            }\n-            loop {\n-                match (ita.next(), itb.next()) {\n-                    (None, _) => break,\n-                    (Some(a), Some(b)) if a == b => { continue },\n-                    (Some(a), _) if a == b\"..\" => {\n-                        // if ita contains only .. components, it's an ancestor\n-                        return ita.all(|x| x == b\"..\");\n-                    }\n-                    _ => return false\n-                }\n-            }\n-            true\n-        }\n-    }\n-\n-    fn path_relative_from(&self, base: &Path) -> Option<Path> {\n-        if self.is_absolute() != base.is_absolute() {\n-            if self.is_absolute() {\n-                Some(self.clone())\n-            } else {\n-                None\n-            }\n-        } else {\n-            let mut ita = self.components();\n-            let mut itb = base.components();\n-            let mut comps = vec![];\n-            loop {\n-                match (ita.next(), itb.next()) {\n-                    (None, None) => break,\n-                    (Some(a), None) => {\n-                        comps.push(a);\n-                        comps.extend(ita.by_ref());\n-                        break;\n-                    }\n-                    (None, _) => comps.push(dot_dot_static),\n-                    (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                    (Some(a), Some(b)) if b == b\".\" => comps.push(a),\n-                    (Some(_), Some(b)) if b == b\"..\" => return None,\n-                    (Some(a), Some(_)) => {\n-                        comps.push(dot_dot_static);\n-                        for _ in itb {\n-                            comps.push(dot_dot_static);\n-                        }\n-                        comps.push(a);\n-                        comps.extend(ita.by_ref());\n-                        break;\n-                    }\n-                }\n-            }\n-            Some(Path::new(comps.connect(&SEP_BYTE)))\n-        }\n-    }\n-\n-    fn ends_with_path(&self, child: &Path) -> bool {\n-        if !child.is_relative() { return false; }\n-        let mut selfit = self.components().rev();\n-        let mut childit = child.components().rev();\n-        loop {\n-            match (selfit.next(), childit.next()) {\n-                (Some(a), Some(b)) => if a != b { return false; },\n-                (Some(_), None) => break,\n-                (None, Some(_)) => return false,\n-                (None, None) => break\n-            }\n-        }\n-        true\n-    }\n-}\n-\n-impl Path {\n-    /// Returns a new Path from a byte vector or string\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the vector contains a NUL.\n-    #[inline]\n-    pub fn new<T: BytesContainer>(path: T) -> Path {\n-        GenericPath::new(path)\n-    }\n-\n-    /// Returns a new Path from a byte vector or string, if possible\n-    #[inline]\n-    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n-        GenericPath::new_opt(path)\n-    }\n-\n-    /// Returns a normalized byte vector representation of a path, by removing all empty\n-    /// components, and unnecessary . and .. components.\n-    fn normalize(v: &[u8]) -> Vec<u8> {\n-        // borrowck is being very picky\n-        let val = {\n-            let is_abs = !v.is_empty() && v[0] == SEP_BYTE;\n-            let v_ = if is_abs { &v[1..] } else { v };\n-            let comps = normalize_helper(v_, is_abs);\n-            match comps {\n-                None => None,\n-                Some(comps) => {\n-                    if is_abs && comps.is_empty() {\n-                        Some(vec![SEP_BYTE])\n-                    } else {\n-                        let n = if is_abs { comps.len() } else { comps.len() - 1} +\n-                                comps.iter().map(|v| v.len()).sum::<usize>();\n-                        let mut v = Vec::with_capacity(n);\n-                        let mut it = comps.into_iter();\n-                        if !is_abs {\n-                            match it.next() {\n-                                None => (),\n-                                Some(comp) => v.push_all(comp)\n-                            }\n-                        }\n-                        for comp in it {\n-                            v.push(SEP_BYTE);\n-                            v.push_all(comp);\n-                        }\n-                        Some(v)\n-                    }\n-                }\n-            }\n-        };\n-        match val {\n-            None => v.to_vec(),\n-            Some(val) => val\n-        }\n-    }\n-\n-    /// Returns an iterator that yields each component of the path in turn.\n-    /// Does not distinguish between absolute and relative paths, e.g.\n-    /// /a/b/c and a/b/c yield the same set of components.\n-    /// A path of \"/\" yields no components. A path of \".\" yields one component.\n-    pub fn components<'a>(&'a self) -> Components<'a> {\n-        let v = if self.repr[0] == SEP_BYTE {\n-            &self.repr[1..]\n-        } else { &*self.repr };\n-        let is_sep_byte: fn(&u8) -> bool = is_sep_byte; // coerce to fn ptr\n-        let mut ret = v.split(is_sep_byte);\n-        if v.is_empty() {\n-            // consume the empty \"\" component\n-            ret.next();\n-        }\n-        ret\n-    }\n-\n-    /// Returns an iterator that yields each component of the path as Option<&str>.\n-    /// See components() for details.\n-    pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        fn from_utf8(s: &[u8]) -> Option<&str> {\n-            str::from_utf8(s).ok()\n-        }\n-        let f: fn(&[u8]) -> Option<&str> = from_utf8; // coerce to fn ptr\n-        self.components().map(f)\n-    }\n-}\n-\n-// None result means the byte vector didn't need normalizing\n-fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n-    if is_abs && v.is_empty() {\n-        return None;\n-    }\n-    let mut comps: Vec<&'a [u8]> = vec![];\n-    let mut n_up = 0;\n-    let mut changed = false;\n-    for comp in v.split(is_sep_byte) {\n-        if comp.is_empty() { changed = true }\n-        else if comp == b\".\" { changed = true }\n-        else if comp == b\"..\" {\n-            if is_abs && comps.is_empty() { changed = true }\n-            else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n-            else { comps.pop().unwrap(); changed = true }\n-        } else { comps.push(comp) }\n-    }\n-    if changed {\n-        if comps.is_empty() && !is_abs {\n-            if v == b\".\" {\n-                return None;\n-            }\n-            comps.push(dot_static);\n-        }\n-        Some(comps)\n-    } else {\n-        None\n-    }\n-}\n-\n-#[allow(non_upper_case_globals)]\n-static dot_static: &'static [u8] = b\".\";\n-#[allow(non_upper_case_globals)]\n-static dot_dot_static: &'static [u8] = b\"..\";\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use clone::Clone;\n-    use option::Option::{self, Some, None};\n-    use old_path::GenericPath;\n-    use str;\n-    use string::ToString;\n-    use vec::Vec;\n-    use iter::Iterator;\n-\n-    macro_rules! t {\n-        (s: $path:expr, $exp:expr) => (\n-            {\n-                let path = $path;\n-                assert_eq!(path.as_str(), Some($exp));\n-            }\n-        );\n-        (v: $path:expr, $exp:expr) => (\n-            {\n-                let path = $path;\n-                assert_eq!(path.as_vec(), $exp);\n-            }\n-        )\n-    }\n-\n-    #[test]\n-    fn test_paths() {\n-        let empty: &[u8] = &[];\n-        t!(v: Path::new(empty), b\".\");\n-        t!(v: Path::new(&b\"/\"[..]), b\"/\");\n-        t!(v: Path::new(&b\"a/b/c\"[..]), b\"a/b/c\");\n-        t!(v: Path::new(&b\"a/b/c\\xFF\"[..]), b\"a/b/c\\xFF\");\n-        t!(v: Path::new(&b\"\\xFF/../foo\\x80\"[..]), b\"foo\\x80\");\n-        let p = Path::new(&b\"a/b/c\\xFF\"[..]);\n-        assert!(p.as_str().is_none());\n-\n-        t!(s: Path::new(\"\"), \".\");\n-        t!(s: Path::new(\"/\"), \"/\");\n-        t!(s: Path::new(\"hi\"), \"hi\");\n-        t!(s: Path::new(\"hi/\"), \"hi\");\n-        t!(s: Path::new(\"/lib\"), \"/lib\");\n-        t!(s: Path::new(\"/lib/\"), \"/lib\");\n-        t!(s: Path::new(\"hi/there\"), \"hi/there\");\n-        t!(s: Path::new(\"hi/there.txt\"), \"hi/there.txt\");\n-\n-        t!(s: Path::new(\"hi/there/\"), \"hi/there\");\n-        t!(s: Path::new(\"hi/../there\"), \"there\");\n-        t!(s: Path::new(\"../hi/there\"), \"../hi/there\");\n-        t!(s: Path::new(\"/../hi/there\"), \"/hi/there\");\n-        t!(s: Path::new(\"foo/..\"), \".\");\n-        t!(s: Path::new(\"/foo/..\"), \"/\");\n-        t!(s: Path::new(\"/foo/../..\"), \"/\");\n-        t!(s: Path::new(\"/foo/../../bar\"), \"/bar\");\n-        t!(s: Path::new(\"/./hi/./there/.\"), \"/hi/there\");\n-        t!(s: Path::new(\"/./hi/./there/./..\"), \"/hi\");\n-        t!(s: Path::new(\"foo/../..\"), \"..\");\n-        t!(s: Path::new(\"foo/../../..\"), \"../..\");\n-        t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n-\n-        assert_eq!(Path::new(&b\"foo/bar\"[..]).into_vec(), b\"foo/bar\");\n-        assert_eq!(Path::new(&b\"/foo/../../bar\"[..]).into_vec(),\n-                   b\"/bar\");\n-\n-        let p = Path::new(&b\"foo/bar\\x80\"[..]);\n-        assert!(p.as_str().is_none());\n-    }\n-\n-    #[test]\n-    fn test_opt_paths() {\n-        assert!(Path::new_opt(&b\"foo/bar\\0\"[..]).is_none());\n-        t!(v: Path::new_opt(&b\"foo/bar\"[..]).unwrap(), b\"foo/bar\");\n-        assert!(Path::new_opt(\"foo/bar\\0\").is_none());\n-        t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n-    }\n-\n-    #[test]\n-    fn test_null_byte() {\n-        use thread;\n-        let result = thread::spawn(move|| {\n-            Path::new(&b\"foo/bar\\0\"[..]);\n-        }).join();\n-        assert!(result.is_err());\n-\n-        let result = thread::spawn(move|| {\n-            Path::new(\"test\").set_filename(&b\"f\\0o\"[..])\n-        }).join();\n-        assert!(result.is_err());\n-\n-        let result = thread::spawn(move|| {\n-            Path::new(\"test\").push(&b\"f\\0o\"[..]);\n-        }).join();\n-        assert!(result.is_err());\n-    }\n-\n-    #[test]\n-    fn test_display_str() {\n-        macro_rules! t {\n-            ($path:expr, $disp:ident, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    assert_eq!(path.$disp().to_string(), $exp);\n-                }\n-            )\n-        }\n-        t!(\"foo\", display, \"foo\");\n-        t!(&b\"foo\\x80\"[..], display, \"foo\\u{FFFD}\");\n-        t!(&b\"foo\\xFFbar\"[..], display, \"foo\\u{FFFD}bar\");\n-        t!(&b\"foo\\xFF/bar\"[..], filename_display, \"bar\");\n-        t!(&b\"foo/\\xFFbar\"[..], filename_display, \"\\u{FFFD}bar\");\n-        t!(&b\"/\"[..], filename_display, \"\");\n-\n-        macro_rules! t {\n-            ($path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let mo = path.display().as_cow();\n-                    assert_eq!(mo, $exp);\n-                }\n-            );\n-            ($path:expr, $exp:expr, filename) => (\n-                {\n-                    let path = Path::new($path);\n-                    let mo = path.filename_display().as_cow();\n-                    assert_eq!(mo, $exp);\n-                }\n-            )\n-        }\n-\n-        t!(\"foo\", \"foo\");\n-        t!(&b\"foo\\x80\"[..], \"foo\\u{FFFD}\");\n-        t!(&b\"foo\\xFFbar\"[..], \"foo\\u{FFFD}bar\");\n-        t!(&b\"foo\\xFF/bar\"[..], \"bar\", filename);\n-        t!(&b\"foo/\\xFFbar\"[..], \"\\u{FFFD}bar\", filename);\n-        t!(&b\"/\"[..], \"\", filename);\n-    }\n-\n-    #[test]\n-    fn test_display() {\n-        macro_rules! t {\n-            ($path:expr, $exp:expr, $expf:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let f = format!(\"{}\", path.display());\n-                    assert_eq!(f, $exp);\n-                    let f = format!(\"{}\", path.filename_display());\n-                    assert_eq!(f, $expf);\n-                }\n-            )\n-        }\n-\n-        t!(&b\"foo\"[..], \"foo\", \"foo\");\n-        t!(&b\"foo/bar\"[..], \"foo/bar\", \"bar\");\n-        t!(&b\"/\"[..], \"/\", \"\");\n-        t!(&b\"foo\\xFF\"[..], \"foo\\u{FFFD}\", \"foo\\u{FFFD}\");\n-        t!(&b\"foo\\xFF/bar\"[..], \"foo\\u{FFFD}/bar\", \"bar\");\n-        t!(&b\"foo/\\xFFbar\"[..], \"foo/\\u{FFFD}bar\", \"\\u{FFFD}bar\");\n-        t!(&b\"\\xFFfoo/bar\\xFF\"[..], \"\\u{FFFD}foo/bar\\u{FFFD}\", \"bar\\u{FFFD}\");\n-    }\n-\n-    #[test]\n-    fn test_components() {\n-        macro_rules! t {\n-            (s: $path:expr, $op:ident, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    assert_eq!(path.$op(), ($exp).as_bytes());\n-                }\n-            );\n-            (s: $path:expr, $op:ident, $exp:expr, opt) => (\n-                {\n-                    let path = Path::new($path);\n-                    let left = path.$op().map(|x| str::from_utf8(x).unwrap());\n-                    assert_eq!(left, $exp);\n-                }\n-            );\n-            (v: $path:expr, $op:ident, $exp:expr) => (\n-                {\n-                    let arg = $path;\n-                    let path = Path::new(arg);\n-                    assert_eq!(path.$op(), $exp);\n-                }\n-            );\n-        }\n-\n-        t!(v: &b\"a/b/c\"[..], filename, Some(&b\"c\"[..]));\n-        t!(v: &b\"a/b/c\\xFF\"[..], filename, Some(&b\"c\\xFF\"[..]));\n-        t!(v: &b\"a/b\\xFF/c\"[..], filename, Some(&b\"c\"[..]));\n-        t!(s: \"a/b/c\", filename, Some(\"c\"), opt);\n-        t!(s: \"/a/b/c\", filename, Some(\"c\"), opt);\n-        t!(s: \"a\", filename, Some(\"a\"), opt);\n-        t!(s: \"/a\", filename, Some(\"a\"), opt);\n-        t!(s: \".\", filename, None, opt);\n-        t!(s: \"/\", filename, None, opt);\n-        t!(s: \"..\", filename, None, opt);\n-        t!(s: \"../..\", filename, None, opt);\n-\n-        t!(v: &b\"a/b/c\"[..], dirname, b\"a/b\");\n-        t!(v: &b\"a/b/c\\xFF\"[..], dirname, b\"a/b\");\n-        t!(v: &b\"a/b\\xFF/c\"[..], dirname, b\"a/b\\xFF\");\n-        t!(s: \"a/b/c\", dirname, \"a/b\");\n-        t!(s: \"/a/b/c\", dirname, \"/a/b\");\n-        t!(s: \"a\", dirname, \".\");\n-        t!(s: \"/a\", dirname, \"/\");\n-        t!(s: \".\", dirname, \".\");\n-        t!(s: \"/\", dirname, \"/\");\n-        t!(s: \"..\", dirname, \"..\");\n-        t!(s: \"../..\", dirname, \"../..\");\n-\n-        t!(v: &b\"hi/there.txt\"[..], filestem, Some(&b\"there\"[..]));\n-        t!(v: &b\"hi/there\\x80.txt\"[..], filestem, Some(&b\"there\\x80\"[..]));\n-        t!(v: &b\"hi/there.t\\x80xt\"[..], filestem, Some(&b\"there\"[..]));\n-        t!(s: \"hi/there.txt\", filestem, Some(\"there\"), opt);\n-        t!(s: \"hi/there\", filestem, Some(\"there\"), opt);\n-        t!(s: \"there.txt\", filestem, Some(\"there\"), opt);\n-        t!(s: \"there\", filestem, Some(\"there\"), opt);\n-        t!(s: \".\", filestem, None, opt);\n-        t!(s: \"/\", filestem, None, opt);\n-        t!(s: \"foo/.bar\", filestem, Some(\".bar\"), opt);\n-        t!(s: \".bar\", filestem, Some(\".bar\"), opt);\n-        t!(s: \"..bar\", filestem, Some(\".\"), opt);\n-        t!(s: \"hi/there..txt\", filestem, Some(\"there.\"), opt);\n-        t!(s: \"..\", filestem, None, opt);\n-        t!(s: \"../..\", filestem, None, opt);\n-\n-        t!(v: &b\"hi/there.txt\"[..], extension, Some(&b\"txt\"[..]));\n-        t!(v: &b\"hi/there\\x80.txt\"[..], extension, Some(&b\"txt\"[..]));\n-        t!(v: &b\"hi/there.t\\x80xt\"[..], extension, Some(&b\"t\\x80xt\"[..]));\n-        t!(v: &b\"hi/there\"[..], extension, None);\n-        t!(v: &b\"hi/there\\x80\"[..], extension, None);\n-        t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n-        t!(s: \"hi/there\", extension, None, opt);\n-        t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n-        t!(s: \"there\", extension, None, opt);\n-        t!(s: \".\", extension, None, opt);\n-        t!(s: \"/\", extension, None, opt);\n-        t!(s: \"foo/.bar\", extension, None, opt);\n-        t!(s: \".bar\", extension, None, opt);\n-        t!(s: \"..bar\", extension, Some(\"bar\"), opt);\n-        t!(s: \"hi/there..txt\", extension, Some(\"txt\"), opt);\n-        t!(s: \"..\", extension, None, opt);\n-        t!(s: \"../..\", extension, None, opt);\n-    }\n-\n-    #[test]\n-    fn test_push() {\n-        macro_rules! t {\n-            (s: $path:expr, $join:expr) => (\n-                {\n-                    let path = $path;\n-                    let join = $join;\n-                    let mut p1 = Path::new(path);\n-                    let p2 = p1.clone();\n-                    p1.push(join);\n-                    assert_eq!(p1, p2.join(join));\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", \"..\");\n-        t!(s: \"/a/b/c\", \"d\");\n-        t!(s: \"a/b\", \"c/d\");\n-        t!(s: \"a/b\", \"/c/d\");\n-    }\n-\n-    #[test]\n-    fn test_push_path() {\n-        macro_rules! t {\n-            (s: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    let push = Path::new($push);\n-                    p.push(&push);\n-                    assert_eq!(p.as_str(), Some($exp));\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n-        t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n-        t!(s: \"a/b\", \"c/d\", \"a/b/c/d\");\n-        t!(s: \"a/b\", \"/c/d\", \"/c/d\");\n-        t!(s: \"a/b\", \".\", \"a/b\");\n-        t!(s: \"a/b\", \"../c\", \"a/c\");\n-    }\n-\n-    #[test]\n-    fn test_push_many() {\n-        macro_rules! t {\n-            (s: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    p.push_many(&$push);\n-                    assert_eq!(p.as_str(), Some($exp));\n-                }\n-            );\n-            (v: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    p.push_many(&$push);\n-                    assert_eq!(p.as_vec(), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n-        t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n-        t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: &b\"a/b/c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a/b/c/d/e\");\n-        t!(v: &b\"a/b/c\"[..], [&b\"d\"[..], &b\"/e\"[..], &b\"f\"[..]], b\"/e/f\");\n-        t!(v: &b\"a/b/c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        macro_rules! t {\n-            (s: $path:expr, $left:expr, $right:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    let result = p.pop();\n-                    assert_eq!(p.as_str(), Some($left));\n-                    assert_eq!(result, $right);\n-                }\n-            );\n-            (b: $path:expr, $left:expr, $right:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    let result = p.pop();\n-                    assert_eq!(p.as_vec(), $left);\n-                    assert_eq!(result, $right);\n-                }\n-            )\n-        }\n-\n-        t!(b: &b\"a/b/c\"[..], b\"a/b\", true);\n-        t!(b: &b\"a\"[..], b\".\", true);\n-        t!(b: &b\".\"[..], b\".\", false);\n-        t!(b: &b\"/a\"[..], b\"/\", true);\n-        t!(b: &b\"/\"[..], b\"/\", false);\n-        t!(b: &b\"a/b/c\\x80\"[..], b\"a/b\", true);\n-        t!(b: &b\"a/b\\x80/c\"[..], b\"a/b\\x80\", true);\n-        t!(b: &b\"\\xFF\"[..], b\".\", true);\n-        t!(b: &b\"/\\xFF\"[..], b\"/\", true);\n-        t!(s: \"a/b/c\", \"a/b\", true);\n-        t!(s: \"a\", \".\", true);\n-        t!(s: \".\", \".\", false);\n-        t!(s: \"/a\", \"/\", true);\n-        t!(s: \"/\", \"/\", false);\n-    }\n-\n-    #[test]\n-    fn test_root_path() {\n-        assert_eq!(Path::new(&b\"a/b/c\"[..]).root_path(), None);\n-        assert_eq!(Path::new(&b\"/a/b/c\"[..]).root_path(), Some(Path::new(\"/\")));\n-    }\n-\n-    #[test]\n-    fn test_join() {\n-        t!(v: Path::new(&b\"a/b/c\"[..]).join(&b\"..\"[..]), b\"a/b\");\n-        t!(v: Path::new(&b\"/a/b/c\"[..]).join(&b\"d\"[..]), b\"/a/b/c/d\");\n-        t!(v: Path::new(&b\"a/\\x80/c\"[..]).join(&b\"\\xFF\"[..]), b\"a/\\x80/c/\\xFF\");\n-        t!(s: Path::new(\"a/b/c\").join(\"..\"), \"a/b\");\n-        t!(s: Path::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n-        t!(s: Path::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n-        t!(s: Path::new(\"a/b\").join(\"/c/d\"), \"/c/d\");\n-        t!(s: Path::new(\".\").join(\"a/b\"), \"a/b\");\n-        t!(s: Path::new(\"/\").join(\"a/b\"), \"/a/b\");\n-    }\n-\n-    #[test]\n-    fn test_join_path() {\n-        macro_rules! t {\n-            (s: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let join = Path::new($join);\n-                    let res = path.join(&join);\n-                    assert_eq!(res.as_str(), Some($exp));\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", \"..\", \"a/b\");\n-        t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n-        t!(s: \"a/b\", \"c/d\", \"a/b/c/d\");\n-        t!(s: \"a/b\", \"/c/d\", \"/c/d\");\n-        t!(s: \".\", \"a/b\", \"a/b\");\n-        t!(s: \"/\", \"a/b\", \"/a/b\");\n-    }\n-\n-    #[test]\n-    fn test_join_many() {\n-        macro_rules! t {\n-            (s: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let res = path.join_many(&$join);\n-                    assert_eq!(res.as_str(), Some($exp));\n-                }\n-            );\n-            (v: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let res = path.join_many(&$join);\n-                    assert_eq!(res.as_vec(), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n-        t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n-        t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: &b\"a/b/c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a/b/c/d/e\");\n-        t!(v: &b\"a/b/c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n-    }\n-\n-    #[test]\n-    fn test_with_helpers() {\n-        let empty: &[u8] = &[];\n-\n-        t!(v: Path::new(&b\"a/b/c\"[..]).with_filename(&b\"d\"[..]), b\"a/b/d\");\n-        t!(v: Path::new(&b\"a/b/c\\xFF\"[..]).with_filename(&b\"\\x80\"[..]), b\"a/b/\\x80\");\n-        t!(v: Path::new(&b\"/\\xFF/foo\"[..]).with_filename(&b\"\\xCD\"[..]),\n-              b\"/\\xFF/\\xCD\");\n-        t!(s: Path::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n-        t!(s: Path::new(\".\").with_filename(\"foo\"), \"foo\");\n-        t!(s: Path::new(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n-        t!(s: Path::new(\"/\").with_filename(\"foo\"), \"/foo\");\n-        t!(s: Path::new(\"/a\").with_filename(\"foo\"), \"/foo\");\n-        t!(s: Path::new(\"foo\").with_filename(\"bar\"), \"bar\");\n-        t!(s: Path::new(\"/\").with_filename(\"foo/\"), \"/foo\");\n-        t!(s: Path::new(\"/a\").with_filename(\"foo/\"), \"/foo\");\n-        t!(s: Path::new(\"a/b/c\").with_filename(\"\"), \"a/b\");\n-        t!(s: Path::new(\"a/b/c\").with_filename(\".\"), \"a/b\");\n-        t!(s: Path::new(\"a/b/c\").with_filename(\"..\"), \"a\");\n-        t!(s: Path::new(\"/a\").with_filename(\"\"), \"/\");\n-        t!(s: Path::new(\"foo\").with_filename(\"\"), \".\");\n-        t!(s: Path::new(\"a/b/c\").with_filename(\"d/e\"), \"a/b/d/e\");\n-        t!(s: Path::new(\"a/b/c\").with_filename(\"/d\"), \"a/b/d\");\n-        t!(s: Path::new(\"..\").with_filename(\"foo\"), \"../foo\");\n-        t!(s: Path::new(\"../..\").with_filename(\"foo\"), \"../../foo\");\n-        t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n-        t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n-\n-        t!(v: Path::new(&b\"hi/there\\x80.txt\"[..]).with_extension(&b\"exe\"[..]),\n-              b\"hi/there\\x80.exe\");\n-        t!(v: Path::new(&b\"hi/there.txt\\x80\"[..]).with_extension(&b\"\\xFF\"[..]),\n-              b\"hi/there.\\xFF\");\n-        t!(v: Path::new(&b\"hi/there\\x80\"[..]).with_extension(&b\"\\xFF\"[..]),\n-              b\"hi/there\\x80.\\xFF\");\n-        t!(v: Path::new(&b\"hi/there.\\xFF\"[..]).with_extension(empty), b\"hi/there\");\n-        t!(s: Path::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n-        t!(s: Path::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n-        t!(s: Path::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n-        t!(s: Path::new(\"hi/there.txt\").with_extension(\"..\"), \"hi/there...\");\n-        t!(s: Path::new(\"hi/there\").with_extension(\"txt\"), \"hi/there.txt\");\n-        t!(s: Path::new(\"hi/there\").with_extension(\".\"), \"hi/there..\");\n-        t!(s: Path::new(\"hi/there\").with_extension(\"..\"), \"hi/there...\");\n-        t!(s: Path::new(\"hi/there.\").with_extension(\"txt\"), \"hi/there.txt\");\n-        t!(s: Path::new(\"hi/.foo\").with_extension(\"txt\"), \"hi/.foo.txt\");\n-        t!(s: Path::new(\"hi/there.txt\").with_extension(\".foo\"), \"hi/there..foo\");\n-        t!(s: Path::new(\"/\").with_extension(\"txt\"), \"/\");\n-        t!(s: Path::new(\"/\").with_extension(\".\"), \"/\");\n-        t!(s: Path::new(\"/\").with_extension(\"..\"), \"/\");\n-        t!(s: Path::new(\".\").with_extension(\"txt\"), \".\");\n-    }\n-\n-    #[test]\n-    fn test_setters() {\n-        macro_rules! t {\n-            (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n-                {\n-                    let path = $path;\n-                    let arg = $arg;\n-                    let mut p1 = Path::new(path);\n-                    p1.$set(arg);\n-                    let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n-                }\n-            );\n-            (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n-                {\n-                    let path = $path;\n-                    let arg = $arg;\n-                    let mut p1 = Path::new(path);\n-                    p1.$set(arg);\n-                    let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n-                }\n-            )\n-        }\n-\n-        t!(v: &b\"a/b/c\"[..], set_filename, with_filename, &b\"d\"[..]);\n-        t!(v: &b\"/\"[..], set_filename, with_filename, &b\"foo\"[..]);\n-        t!(v: &b\"\\x80\"[..], set_filename, with_filename, &b\"\\xFF\"[..]);\n-        t!(s: \"a/b/c\", set_filename, with_filename, \"d\");\n-        t!(s: \"/\", set_filename, with_filename, \"foo\");\n-        t!(s: \".\", set_filename, with_filename, \"foo\");\n-        t!(s: \"a/b\", set_filename, with_filename, \"\");\n-        t!(s: \"a\", set_filename, with_filename, \"\");\n-\n-        t!(v: &b\"hi/there.txt\"[..], set_extension, with_extension, &b\"exe\"[..]);\n-        t!(v: &b\"hi/there.t\\x80xt\"[..], set_extension, with_extension, &b\"exe\\xFF\"[..]);\n-        t!(s: \"hi/there.txt\", set_extension, with_extension, \"exe\");\n-        t!(s: \"hi/there.\", set_extension, with_extension, \"txt\");\n-        t!(s: \"hi/there\", set_extension, with_extension, \"txt\");\n-        t!(s: \"hi/there.txt\", set_extension, with_extension, \"\");\n-        t!(s: \"hi/there\", set_extension, with_extension, \"\");\n-        t!(s: \".\", set_extension, with_extension, \"txt\");\n-    }\n-\n-    #[test]\n-    fn test_getters() {\n-        macro_rules! t {\n-            (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n-                {\n-                    let path = $path;\n-                    assert_eq!(path.filename_str(), $filename);\n-                    assert_eq!(path.dirname_str(), $dirname);\n-                    assert_eq!(path.filestem_str(), $filestem);\n-                    assert_eq!(path.extension_str(), $ext);\n-               }\n-            );\n-            (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n-                {\n-                    let path = $path;\n-                    assert_eq!(path.filename(), $filename);\n-                    assert_eq!(path.dirname(), $dirname);\n-                    assert_eq!(path.filestem(), $filestem);\n-                    assert_eq!(path.extension(), $ext);\n-                }\n-            )\n-        }\n-\n-        t!(v: Path::new(&b\"a/b/c\"[..]), Some(&b\"c\"[..]), b\"a/b\", Some(&b\"c\"[..]), None);\n-        t!(v: Path::new(&b\"a/b/\\xFF\"[..]), Some(&b\"\\xFF\"[..]), b\"a/b\", Some(&b\"\\xFF\"[..]), None);\n-        t!(v: Path::new(&b\"hi/there.\\xFF\"[..]), Some(&b\"there.\\xFF\"[..]), b\"hi\",\n-              Some(&b\"there\"[..]), Some(&b\"\\xFF\"[..]));\n-        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, None);\n-        t!(s: Path::new(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n-              Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: Path::new(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n-              Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n-              Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(&b\"a/b/\\xFF\"[..]), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::new(&b\"a/b/\\xFF.txt\"[..]), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(&b\"a/b/c.\\x80\"[..]), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(&b\"\\xFF/b\"[..]), Some(\"b\"), None, Some(\"b\"), None);\n-    }\n-\n-    #[test]\n-    fn test_dir_path() {\n-        t!(v: Path::new(&b\"hi/there\\x80\"[..]).dir_path(), b\"hi\");\n-        t!(v: Path::new(&b\"hi\\xFF/there\"[..]).dir_path(), b\"hi\\xFF\");\n-        t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n-        t!(s: Path::new(\"hi\").dir_path(), \".\");\n-        t!(s: Path::new(\"/hi\").dir_path(), \"/\");\n-        t!(s: Path::new(\"/\").dir_path(), \"/\");\n-        t!(s: Path::new(\"..\").dir_path(), \"..\");\n-        t!(s: Path::new(\"../..\").dir_path(), \"../..\");\n-    }\n-\n-    #[test]\n-    fn test_is_absolute() {\n-        macro_rules! t {\n-            (s: $path:expr, $abs:expr, $rel:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    assert_eq!(path.is_absolute(), $abs);\n-                    assert_eq!(path.is_relative(), $rel);\n-                }\n-            )\n-        }\n-        t!(s: \"a/b/c\", false, true);\n-        t!(s: \"/a/b/c\", true, false);\n-        t!(s: \"a\", false, true);\n-        t!(s: \"/a\", true, false);\n-        t!(s: \".\", false, true);\n-        t!(s: \"/\", true, false);\n-        t!(s: \"..\", false, true);\n-        t!(s: \"../..\", false, true);\n-    }\n-\n-    #[test]\n-    fn test_is_ancestor_of() {\n-        macro_rules! t {\n-            (s: $path:expr, $dest:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let dest = Path::new($dest);\n-                    assert_eq!(path.is_ancestor_of(&dest), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", \"a/b/c/d\", true);\n-        t!(s: \"a/b/c\", \"a/b/c\", true);\n-        t!(s: \"a/b/c\", \"a/b\", false);\n-        t!(s: \"/a/b/c\", \"/a/b/c\", true);\n-        t!(s: \"/a/b\", \"/a/b/c\", true);\n-        t!(s: \"/a/b/c/d\", \"/a/b/c\", false);\n-        t!(s: \"/a/b\", \"a/b/c\", false);\n-        t!(s: \"a/b\", \"/a/b/c\", false);\n-        t!(s: \"a/b/c\", \"a/b/d\", false);\n-        t!(s: \"../a/b/c\", \"a/b/c\", false);\n-        t!(s: \"a/b/c\", \"../a/b/c\", false);\n-        t!(s: \"a/b/c\", \"a/b/cd\", false);\n-        t!(s: \"a/b/cd\", \"a/b/c\", false);\n-        t!(s: \"../a/b\", \"../a/b/c\", true);\n-        t!(s: \".\", \"a/b\", true);\n-        t!(s: \".\", \".\", true);\n-        t!(s: \"/\", \"/\", true);\n-        t!(s: \"/\", \"/a/b\", true);\n-        t!(s: \"..\", \"a/b\", true);\n-        t!(s: \"../..\", \"a/b\", true);\n-    }\n-\n-    #[test]\n-    fn test_ends_with_path() {\n-        macro_rules! t {\n-            (s: $path:expr, $child:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let child = Path::new($child);\n-                    assert_eq!(path.ends_with_path(&child), $exp);\n-                }\n-            );\n-            (v: $path:expr, $child:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let child = Path::new($child);\n-                    assert_eq!(path.ends_with_path(&child), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", \"c\", true);\n-        t!(s: \"a/b/c\", \"d\", false);\n-        t!(s: \"foo/bar/quux\", \"bar\", false);\n-        t!(s: \"foo/bar/quux\", \"barquux\", false);\n-        t!(s: \"a/b/c\", \"b/c\", true);\n-        t!(s: \"a/b/c\", \"a/b/c\", true);\n-        t!(s: \"a/b/c\", \"foo/a/b/c\", false);\n-        t!(s: \"/a/b/c\", \"a/b/c\", true);\n-        t!(s: \"/a/b/c\", \"/a/b/c\", false); // child must be relative\n-        t!(s: \"/a/b/c\", \"foo/a/b/c\", false);\n-        t!(s: \"a/b/c\", \"\", false);\n-        t!(s: \"\", \"\", true);\n-        t!(s: \"/a/b/c\", \"d/e/f\", false);\n-        t!(s: \"a/b/c\", \"a/b\", false);\n-        t!(s: \"a/b/c\", \"b\", false);\n-        t!(v: &b\"a/b/c\"[..], &b\"b/c\"[..], true);\n-        t!(v: &b\"a/b/\\xFF\"[..], &b\"\\xFF\"[..], true);\n-        t!(v: &b\"a/b/\\xFF\"[..], &b\"b/\\xFF\"[..], true);\n-    }\n-\n-    #[test]\n-    fn test_path_relative_from() {\n-        macro_rules! t {\n-            (s: $path:expr, $other:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let other = Path::new($other);\n-                    let res = path.path_relative_from(&other);\n-                    assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n-        t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n-        t!(s: \"a/b/c\", \"a/b/c/d\", Some(\"..\"));\n-        t!(s: \"a/b/c\", \"a/b/c\", Some(\".\"));\n-        t!(s: \"a/b/c\", \"a/b/c/d/e\", Some(\"../..\"));\n-        t!(s: \"a/b/c\", \"a/d/e\", Some(\"../../b/c\"));\n-        t!(s: \"a/b/c\", \"d/e/f\", Some(\"../../../a/b/c\"));\n-        t!(s: \"a/b/c\", \"/a/b/c\", None);\n-        t!(s: \"/a/b/c\", \"a/b/c\", Some(\"/a/b/c\"));\n-        t!(s: \"/a/b/c\", \"/a/b/c/d\", Some(\"..\"));\n-        t!(s: \"/a/b/c\", \"/a/b\", Some(\"c\"));\n-        t!(s: \"/a/b/c\", \"/a/b/c/d/e\", Some(\"../..\"));\n-        t!(s: \"/a/b/c\", \"/a/d/e\", Some(\"../../b/c\"));\n-        t!(s: \"/a/b/c\", \"/d/e/f\", Some(\"../../../a/b/c\"));\n-        t!(s: \"hi/there.txt\", \"hi/there\", Some(\"../there.txt\"));\n-        t!(s: \".\", \"a\", Some(\"..\"));\n-        t!(s: \".\", \"a/b\", Some(\"../..\"));\n-        t!(s: \".\", \".\", Some(\".\"));\n-        t!(s: \"a\", \".\", Some(\"a\"));\n-        t!(s: \"a/b\", \".\", Some(\"a/b\"));\n-        t!(s: \"..\", \".\", Some(\"..\"));\n-        t!(s: \"a/b/c\", \"a/b/c\", Some(\".\"));\n-        t!(s: \"/a/b/c\", \"/a/b/c\", Some(\".\"));\n-        t!(s: \"/\", \"/\", Some(\".\"));\n-        t!(s: \"/\", \".\", Some(\"/\"));\n-        t!(s: \"../../a\", \"b\", Some(\"../../../a\"));\n-        t!(s: \"a\", \"../../b\", None);\n-        t!(s: \"../../a\", \"../../b\", Some(\"../a\"));\n-        t!(s: \"../../a\", \"../../a/b\", Some(\"..\"));\n-        t!(s: \"../../a/b\", \"../../a\", Some(\"b\"));\n-    }\n-\n-    #[test]\n-    fn test_components_iter() {\n-        macro_rules! t {\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&str] = &$exp;\n-                    let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n-                    assert_eq!(comps, exps);\n-                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n-                    let exps = exps.into_iter().rev().collect::<Vec<&[u8]>>();\n-                    assert_eq!(comps, exps);\n-                }\n-            );\n-            (b: $arg:expr, [$($exp:expr),*]) => (\n-                {\n-                    let path = Path::new($arg);\n-                    let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&[u8]] = &[$($exp),*];\n-                    assert_eq!(comps, exp);\n-                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n-                    let exp = exp.iter().rev().cloned().collect::<Vec<&[u8]>>();\n-                    assert_eq!(comps, exp)\n-                }\n-            )\n-        }\n-\n-        t!(b: &b\"a/b/c\"[..], [b\"a\", b\"b\", b\"c\"]);\n-        t!(b: &b\"/\\xFF/a/\\x80\"[..], [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n-        t!(b: &b\"../../foo\\xCDbar\"[..], [b\"..\", b\"..\", b\"foo\\xCDbar\"]);\n-        t!(s: \"a/b/c\", [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a/b/d\", [\"a\", \"b\", \"d\"]);\n-        t!(s: \"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n-        t!(s: \"/a/b/c\", [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a\", [\"a\"]);\n-        t!(s: \"/a\", [\"a\"]);\n-        t!(s: \"/\", []);\n-        t!(s: \".\", [\".\"]);\n-        t!(s: \"..\", [\"..\"]);\n-        t!(s: \"../..\", [\"..\", \"..\"]);\n-        t!(s: \"../../foo\", [\"..\", \"..\", \"foo\"]);\n-    }\n-\n-    #[test]\n-    fn test_str_components() {\n-        macro_rules! t {\n-            (b: $arg:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($arg);\n-                    let comps = path.str_components().collect::<Vec<Option<&str>>>();\n-                    let exp: &[Option<&str>] = &$exp;\n-                    assert_eq!(comps, exp);\n-                    let comps = path.str_components().rev().collect::<Vec<Option<&str>>>();\n-                    let exp = exp.iter().rev().cloned().collect::<Vec<Option<&str>>>();\n-                    assert_eq!(comps, exp);\n-                }\n-            )\n-        }\n-\n-        t!(b: &b\"a/b/c\"[..], [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n-        t!(b: &b\"/\\xFF/a/\\x80\"[..], [None, Some(\"a\"), None]);\n-        t!(b: &b\"../../foo\\xCDbar\"[..], [Some(\"..\"), Some(\"..\"), None]);\n-        // str_components is a wrapper around components, so no need to do\n-        // the full set of tests\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::*;\n-    use old_path::GenericPath;\n-    use prelude::v1::Clone;\n-\n-    #[bench]\n-    fn join_home_dir(b: &mut Bencher) {\n-        let posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.join(\"home\");\n-        });\n-    }\n-\n-    #[bench]\n-    fn join_abs_path_home_dir(b: &mut Bencher) {\n-        let posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.join(\"/home\");\n-        });\n-    }\n-\n-    #[bench]\n-    fn join_many_home_dir(b: &mut Bencher) {\n-        let posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.join_many(&[\"home\"]);\n-        });\n-    }\n-\n-    #[bench]\n-    fn join_many_abs_path_home_dir(b: &mut Bencher) {\n-        let posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.join_many(&[\"/home\"]);\n-        });\n-    }\n-\n-    #[bench]\n-    fn push_home_dir(b: &mut Bencher) {\n-        let mut posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.push(\"home\");\n-        });\n-    }\n-\n-    #[bench]\n-    fn push_abs_path_home_dir(b: &mut Bencher) {\n-        let mut posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.push(\"/home\");\n-        });\n-    }\n-\n-    #[bench]\n-    fn push_many_home_dir(b: &mut Bencher) {\n-        let mut posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.push_many(&[\"home\"]);\n-        });\n-    }\n-\n-    #[bench]\n-    fn push_many_abs_path_home_dir(b: &mut Bencher) {\n-        let mut posix_path = Path::new(\"/\");\n-        b.iter(|| {\n-            posix_path.push_many(&[\"/home\"]);\n-        });\n-    }\n-\n-    #[bench]\n-    fn ends_with_path_home_dir(b: &mut Bencher) {\n-        let posix_home_path = Path::new(\"/home\");\n-        b.iter(|| {\n-            posix_home_path.ends_with_path(&Path::new(\"home\"));\n-        });\n-    }\n-\n-    #[bench]\n-    fn ends_with_path_missmatch_jome_home(b: &mut Bencher) {\n-        let posix_home_path = Path::new(\"/home\");\n-        b.iter(|| {\n-            posix_home_path.ends_with_path(&Path::new(\"jome\"));\n-        });\n-    }\n-\n-    #[bench]\n-    fn is_ancestor_of_path_with_10_dirs(b: &mut Bencher) {\n-        let path = Path::new(\"/home/1/2/3/4/5/6/7/8/9\");\n-        let mut sub = path.clone();\n-        sub.pop();\n-        b.iter(|| {\n-            path.is_ancestor_of(&sub);\n-        });\n-    }\n-\n-    #[bench]\n-    fn path_relative_from_forward(b: &mut Bencher) {\n-        let path = Path::new(\"/a/b/c\");\n-        let mut other = path.clone();\n-        other.pop();\n-        b.iter(|| {\n-            path.path_relative_from(&other);\n-        });\n-    }\n-\n-    #[bench]\n-    fn path_relative_from_same_level(b: &mut Bencher) {\n-        let path = Path::new(\"/a/b/c\");\n-        let mut other = path.clone();\n-        other.pop();\n-        other.push(\"d\");\n-        b.iter(|| {\n-            path.path_relative_from(&other);\n-        });\n-    }\n-\n-    #[bench]\n-    fn path_relative_from_backward(b: &mut Bencher) {\n-        let path = Path::new(\"/a/b\");\n-        let mut other = path.clone();\n-        other.push(\"c\");\n-        b.iter(|| {\n-            path.path_relative_from(&other);\n-        });\n-    }\n-}"}, {"sha": "65aad38a2b43d5e848edba99ae4d9174fae3d2fa", "filename": "src/libstd/old_path/windows.rs", "status": "removed", "additions": 0, "deletions": 2330, "changes": 2330, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,2330 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-//! Windows file path handling\n-\n-use self::PathPrefix::*;\n-\n-use ascii::AsciiExt;\n-use clone::Clone;\n-use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n-use fmt;\n-use hash;\n-use old_io::Writer;\n-use iter::{Extend, Iterator, Map, repeat};\n-use mem;\n-use option::Option::{self, Some, None};\n-use result::Result::{self, Ok, Err};\n-use slice::SliceConcatExt;\n-use str::{SplitTerminator, FromStr};\n-use string::{String, ToString};\n-use vec::Vec;\n-\n-use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n-\n-/// Iterator that yields successive components of a Path as &str\n-///\n-/// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n-/// every component in WindowsPath is guaranteed to be Some.\n-pub type StrComponents<'a> =\n-    Map<SplitTerminator<'a, char>, fn(&'a str) -> Option<&'a str>>;\n-\n-/// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> =\n-    Map<StrComponents<'a>, fn(Option<&str>) -> &[u8]>;\n-\n-/// Represents a Windows path\n-// Notes for Windows path impl:\n-// The MAX_PATH is 260, but 253 is the practical limit due to some API bugs\n-// See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx for good information\n-// about windows paths.\n-// That same page puts a bunch of restrictions on allowed characters in a path.\n-// `\\foo.txt` means \"relative to current drive\", but will not be considered to be absolute here\n-// as `\u2203P | P.join(\"\\foo.txt\") != \"\\foo.txt\"`.\n-// `C:` is interesting, that means \"the current directory on drive C\".\n-// Long absolute paths need to have \\\\?\\ prefix (or, for UNC, \\\\?\\UNC\\). I think that can be\n-// ignored for now, though, and only added in a hypothetical .to_pwstr() function.\n-// However, if a path is parsed that has \\\\?\\, this needs to be preserved as it disables the\n-// processing of \".\" and \"..\" components and / as a separator.\n-// Experimentally, \\\\?\\foo is not the same thing as \\foo.\n-// Also, \\\\foo is not valid either (certainly not equivalent to \\foo).\n-// Similarly, C:\\\\Users is not equivalent to C:\\Users, although C:\\Users\\\\foo is equivalent\n-// to C:\\Users\\foo. In fact the command prompt treats C:\\\\foo\\bar as UNC path. But it might be\n-// best to just ignore that and normalize it to C:\\foo\\bar.\n-//\n-// Based on all this, I think the right approach is to do the following:\n-// * Require valid utf-8 paths. Windows API may use WCHARs, but we don't, and utf-8 is convertible\n-// to UTF-16 anyway (though does Windows use UTF-16 or UCS-2? Not sure).\n-// * Parse the prefixes \\\\?\\UNC\\, \\\\?\\, and \\\\.\\ explicitly.\n-// * If \\\\?\\UNC\\, treat following two path components as server\\share. Don't error for missing\n-//   server\\share.\n-// * If \\\\?\\, parse disk from following component, if present. Don't error for missing disk.\n-// * If \\\\.\\, treat rest of path as just regular components. I don't know how . and .. are handled\n-//   here, they probably aren't, but I'm not going to worry about that.\n-// * Else if starts with \\\\, treat following two components as server\\share. Don't error for missing\n-//   server\\share.\n-// * Otherwise, attempt to parse drive from start of path.\n-//\n-// The only error condition imposed here is valid utf-8. All other invalid paths are simply\n-// preserved by the data structure; let the Windows API error out on them.\n-#[derive(Clone)]\n-pub struct Path {\n-    repr: String, // assumed to never be empty\n-    prefix: Option<PathPrefix>,\n-    sepidx: Option<usize> // index of the final separator in the non-prefix portion of repr\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.display(), f)\n-    }\n-}\n-\n-impl PartialEq for Path {\n-    #[inline]\n-    fn eq(&self, other: &Path) -> bool {\n-        self.repr == other.repr\n-    }\n-}\n-\n-impl Eq for Path {}\n-\n-impl PartialOrd for Path {\n-    fn partial_cmp(&self, other: &Path) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Path {\n-    fn cmp(&self, other: &Path) -> Ordering {\n-        self.repr.cmp(&other.repr)\n-    }\n-}\n-\n-impl FromStr for Path {\n-    type Err = ParsePathError;\n-    fn from_str(s: &str) -> Result<Path, ParsePathError> {\n-        match Path::new_opt(s) {\n-            Some(p) => Ok(p),\n-            None => Err(ParsePathError),\n-        }\n-    }\n-}\n-\n-/// Value indicating that a path could not be parsed from a string.\n-#[derive(Debug, Clone, PartialEq, Copy)]\n-pub struct ParsePathError;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Path {\n-    #[cfg(not(test))]\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.repr.hash(state)\n-    }\n-\n-    #[cfg(test)]\n-    #[inline]\n-    fn hash<H: hash::Hasher>(&self, _: &mut H) {\n-        // No-op because the `hash` implementation will be wrong.\n-    }\n-}\n-\n-impl BytesContainer for Path {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_vec()\n-    }\n-    #[inline]\n-    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n-        self.as_str()\n-    }\n-    #[inline]\n-    fn is_str(_: Option<&Path>) -> bool { true }\n-}\n-\n-impl GenericPathUnsafe for Path {\n-    /// See `GenericPathUnsafe::from_vec_unchecked`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if not valid UTF-8.\n-    #[inline]\n-    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n-        let (prefix, path) = Path::normalize_(path.container_as_str().unwrap());\n-        assert!(!path.is_empty());\n-        let mut ret = Path{ repr: path, prefix: prefix, sepidx: None };\n-        ret.update_sepidx();\n-        ret\n-    }\n-\n-    /// See `GenericPathUnsafe::set_filename_unchecked`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if not valid UTF-8.\n-    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n-        let filename = filename.container_as_str().unwrap();\n-        match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => {\n-                let mut s = String::with_capacity(3 + filename.len());\n-                s.push_str(\"..\");\n-                s.push(SEP);\n-                s.push_str(filename);\n-                self.update_normalized(&s[..]);\n-            }\n-            None => {\n-                self.update_normalized(filename);\n-            }\n-            Some((_,idxa,end)) if &self.repr[idxa..end] == \"..\" => {\n-                let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(&self.repr[..end]);\n-                s.push(SEP);\n-                s.push_str(filename);\n-                self.update_normalized(&s[..]);\n-            }\n-            Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n-                let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(&self.repr[..idxb]);\n-                s.push_str(filename);\n-                self.update_normalized(&s[..]);\n-            }\n-            Some((idxb,_,_)) => {\n-                let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(&self.repr[..idxb]);\n-                s.push(SEP);\n-                s.push_str(filename);\n-                self.update_normalized(&s[..]);\n-            }\n-        }\n-    }\n-\n-    /// See `GenericPathUnsafe::push_unchecked`.\n-    ///\n-    /// Concatenating two Windows Paths is rather complicated.\n-    /// For the most part, it will behave as expected, except in the case of\n-    /// pushing a volume-relative path, e.g. `C:foo.txt`. Because we have no\n-    /// concept of per-volume cwds like Windows does, we can't behave exactly\n-    /// like Windows will. Instead, if the receiver is an absolute path on\n-    /// the same volume as the new path, it will be treated as the cwd that\n-    /// the new path is relative to. Otherwise, the new path will be treated\n-    /// as if it were absolute and will replace the receiver outright.\n-    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n-        let path = path.container_as_str().unwrap();\n-        fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n-            // assume prefix is Some(DiskPrefix)\n-            let rest = &path[prefix_len(prefix)..];\n-            !rest.is_empty() && rest.as_bytes()[0].is_ascii() && is_sep(rest.as_bytes()[0] as char)\n-        }\n-        fn shares_volume(me: &Path, path: &str) -> bool {\n-            // path is assumed to have a prefix of Some(DiskPrefix)\n-            let repr = &me.repr[..];\n-            match me.prefix {\n-                Some(DiskPrefix) => {\n-                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii_uppercase()\n-                }\n-                Some(VerbatimDiskPrefix) => {\n-                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii_uppercase()\n-                }\n-                _ => false\n-            }\n-        }\n-        fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool {\n-            if prefix_is_verbatim(prefix) { is_sep_verbatim(u as char) }\n-            else { is_sep(u as char) }\n-        }\n-\n-        fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) {\n-            let newpath = Path::normalize__(path, prefix);\n-            me.repr = match newpath {\n-                Some(p) => p,\n-                None => String::from_str(path)\n-            };\n-            me.prefix = prefix;\n-            me.update_sepidx();\n-        }\n-        fn append_path(me: &mut Path, path: &str) {\n-            // appends a path that has no prefix\n-            // if me is verbatim, we need to pre-normalize the new path\n-            let path_ = if is_verbatim(me) { Path::normalize__(path, None) }\n-                        else { None };\n-            let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n-            let mut s = String::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(&me.repr[..]);\n-            let plen = me.prefix_len();\n-            // if me is \"C:\" we don't want to add a path separator\n-            match me.prefix {\n-                Some(DiskPrefix) if me.repr.len() == plen => (),\n-                _ if !(me.repr.len() > plen && me.repr.as_bytes()[me.repr.len()-1] == SEP_BYTE) => {\n-                    s.push(SEP);\n-                }\n-                _ => ()\n-            }\n-            match path_ {\n-                None => s.push_str(path),\n-                Some(p) => s.push_str(&p[..]),\n-            };\n-            me.update_normalized(&s[..])\n-        }\n-\n-        if !path.is_empty() {\n-            let prefix = parse_prefix(path);\n-            match prefix {\n-                Some(DiskPrefix) if !is_vol_abs(path, prefix) && shares_volume(self, path) => {\n-                    // cwd-relative path, self is on the same volume\n-                    append_path(self, &path[prefix_len(prefix)..]);\n-                }\n-                Some(_) => {\n-                    // absolute path, or cwd-relative and self is not same volume\n-                    replace_path(self, path, prefix);\n-                }\n-                None if !path.is_empty() && is_sep_(self.prefix, path.as_bytes()[0]) => {\n-                    // volume-relative path\n-                    if self.prefix.is_some() {\n-                        // truncate self down to the prefix, then append\n-                        let n = self.prefix_len();\n-                        self.repr.truncate(n);\n-                        append_path(self, path);\n-                    } else {\n-                        // we have no prefix, so nothing to be relative to\n-                        replace_path(self, path, prefix);\n-                    }\n-                }\n-                None => {\n-                    // relative path\n-                    append_path(self, path);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl GenericPath for Path {\n-    #[inline]\n-    fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n-        match path.container_as_str() {\n-            None => None,\n-            Some(ref s) => {\n-                if contains_nul(s) {\n-                    None\n-                } else {\n-                    Some(unsafe { GenericPathUnsafe::new_unchecked(*s) })\n-                }\n-            }\n-        }\n-    }\n-\n-    /// See `GenericPath::as_str` for info.\n-    /// Always returns a `Some` value.\n-    #[inline]\n-    fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(&self.repr[..])\n-    }\n-\n-    #[inline]\n-    fn as_vec<'a>(&'a self) -> &'a [u8] {\n-        self.repr.as_bytes()\n-    }\n-\n-    #[inline]\n-    fn into_vec(self) -> Vec<u8> {\n-        self.repr.into_bytes()\n-    }\n-\n-    #[inline]\n-    fn dirname<'a>(&'a self) -> &'a [u8] {\n-        self.dirname_str().unwrap().as_bytes()\n-    }\n-\n-    /// See `GenericPath::dirname_str` for info.\n-    /// Always returns a `Some` value.\n-    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => &self.repr[..],\n-            None => \".\",\n-            Some((_,idxa,end)) if &self.repr[idxa..end] == \"..\" => {\n-                &self.repr[..]\n-            }\n-            Some((idxb,_,end)) if &self.repr[idxb..end] == \"\\\\\" => {\n-                &self.repr[..]\n-            }\n-            Some((0,idxa,_)) => &self.repr[..idxa],\n-            Some((idxb,idxa,_)) => {\n-                match self.prefix {\n-                    Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        &self.repr[..idxa]\n-                    }\n-                    _ => &self.repr[..idxb]\n-                }\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n-        self.filename_str().map(|x| x.as_bytes())\n-    }\n-\n-    /// See `GenericPath::filename_str` for info.\n-    /// Always returns a `Some` value if `filename` returns a `Some` value.\n-    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        let repr = &self.repr[..];\n-        match self.sepidx_or_prefix_len() {\n-            None if \".\" == repr || \"..\" == repr => None,\n-            None => Some(repr),\n-            Some((_,idxa,end)) if &repr[idxa..end] == \"..\" => None,\n-            Some((_,idxa,end)) if idxa == end => None,\n-            Some((_,idxa,end)) => Some(&repr[idxa..end])\n-        }\n-    }\n-\n-    /// See `GenericPath::filestem_str` for info.\n-    /// Always returns a `Some` value if `filestem` returns a `Some` value.\n-    #[inline]\n-    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        // filestem() returns a byte vector that's guaranteed valid UTF-8\n-        self.filestem().map(|t| unsafe { mem::transmute(t) })\n-    }\n-\n-    #[inline]\n-    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        // extension() returns a byte vector that's guaranteed valid UTF-8\n-        self.extension().map(|t| unsafe { mem::transmute(t) })\n-    }\n-\n-    fn dir_path(&self) -> Path {\n-        unsafe { GenericPathUnsafe::new_unchecked(self.dirname_str().unwrap()) }\n-    }\n-\n-    #[inline]\n-    fn pop(&mut self) -> bool {\n-        match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr => false,\n-            None => {\n-                self.repr = String::from_str(\".\");\n-                self.sepidx = None;\n-                true\n-            }\n-            Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if &self.repr[idxb..end] == \"\\\\\" => false,\n-            Some((idxb,idxa,_)) => {\n-                let trunc = match self.prefix {\n-                    Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n-                        let plen = self.prefix_len();\n-                        if idxb == plen { idxa } else { idxb }\n-                    }\n-                    _ => idxb\n-                };\n-                self.repr.truncate(trunc);\n-                self.update_sepidx();\n-                true\n-            }\n-        }\n-    }\n-\n-    fn root_path(&self) -> Option<Path> {\n-        if self.prefix.is_some() {\n-            Some(Path::new(match self.prefix {\n-                Some(DiskPrefix) if self.is_absolute() => {\n-                    &self.repr[..self.prefix_len()+1]\n-                }\n-                Some(VerbatimDiskPrefix) => {\n-                    &self.repr[..self.prefix_len()+1]\n-                }\n-                _ => &self.repr[..self.prefix_len()]\n-            }))\n-        } else if is_vol_relative(self) {\n-            Some(Path::new(&self.repr[..1]))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// See `GenericPath::is_absolute` for info.\n-    ///\n-    /// A Windows Path is considered absolute only if it has a non-volume prefix,\n-    /// or if it has a volume prefix and the path starts with '\\'.\n-    /// A path of `\\foo` is not considered absolute because it's actually\n-    /// relative to the \"current volume\". A separate method `Path::is_vol_relative`\n-    /// is provided to indicate this case. Similarly a path of `C:foo` is not\n-    /// considered absolute because it's relative to the cwd on volume C:. A\n-    /// separate method `Path::is_cwd_relative` is provided to indicate this case.\n-    #[inline]\n-    fn is_absolute(&self) -> bool {\n-        match self.prefix {\n-            Some(DiskPrefix) => {\n-                let rest = &self.repr[self.prefix_len()..];\n-                rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n-            }\n-            Some(_) => true,\n-            None => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_relative(&self) -> bool {\n-        self.prefix.is_none() && !is_vol_relative(self)\n-    }\n-\n-    fn is_ancestor_of(&self, other: &Path) -> bool {\n-        if !self.equiv_prefix(other) {\n-            false\n-        } else if self.is_absolute() != other.is_absolute() ||\n-                  is_vol_relative(self) != is_vol_relative(other) {\n-            false\n-        } else {\n-            let mut ita = self.str_components().map(|x|x.unwrap());\n-            let mut itb = other.str_components().map(|x|x.unwrap());\n-            if \".\" == self.repr {\n-                return itb.next() != Some(\"..\");\n-            }\n-            loop {\n-                match (ita.next(), itb.next()) {\n-                    (None, _) => break,\n-                    (Some(a), Some(b)) if a == b => { continue },\n-                    (Some(a), _) if a == \"..\" => {\n-                        // if ita contains only .. components, it's an ancestor\n-                        return ita.all(|x| x == \"..\");\n-                    }\n-                    _ => return false\n-                }\n-            }\n-            true\n-        }\n-    }\n-\n-    fn path_relative_from(&self, base: &Path) -> Option<Path> {\n-        fn comp_requires_verbatim(s: &str) -> bool {\n-            s == \".\" || s == \"..\" || s.contains(SEP2)\n-        }\n-\n-        if !self.equiv_prefix(base) {\n-            // prefixes differ\n-            if self.is_absolute() {\n-                Some(self.clone())\n-            } else if self.prefix == Some(DiskPrefix) && base.prefix == Some(DiskPrefix) {\n-                // both drives, drive letters must differ or they'd be equiv\n-                Some(self.clone())\n-            } else {\n-                None\n-            }\n-        } else if self.is_absolute() != base.is_absolute() {\n-            if self.is_absolute() {\n-                Some(self.clone())\n-            } else {\n-                None\n-            }\n-        } else if is_vol_relative(self) != is_vol_relative(base) {\n-            if is_vol_relative(self) {\n-                Some(self.clone())\n-            } else {\n-                None\n-            }\n-        } else {\n-            let mut ita = self.str_components().map(|x|x.unwrap());\n-            let mut itb = base.str_components().map(|x|x.unwrap());\n-            let mut comps = vec![];\n-\n-            let a_verb = is_verbatim(self);\n-            let b_verb = is_verbatim(base);\n-            loop {\n-                match (ita.next(), itb.next()) {\n-                    (None, None) => break,\n-                    (Some(a), None) if a_verb && comp_requires_verbatim(a) => {\n-                        return Some(self.clone())\n-                    }\n-                    (Some(a), None) => {\n-                        comps.push(a);\n-                        if !a_verb {\n-                            comps.extend(ita.by_ref());\n-                            break;\n-                        }\n-                    }\n-                    (None, _) => comps.push(\"..\"),\n-                    (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                    (Some(a), Some(b)) if !b_verb && b == \".\" => {\n-                        if a_verb && comp_requires_verbatim(a) {\n-                            return Some(self.clone())\n-                        } else { comps.push(a) }\n-                    }\n-                    (Some(_), Some(b)) if !b_verb && b == \"..\" => return None,\n-                    (Some(a), Some(_)) if a_verb && comp_requires_verbatim(a) => {\n-                        return Some(self.clone())\n-                    }\n-                    (Some(a), Some(_)) => {\n-                        comps.push(\"..\");\n-                        for _ in itb.by_ref() {\n-                            comps.push(\"..\");\n-                        }\n-                        comps.push(a);\n-                        if !a_verb {\n-                            comps.extend(ita.by_ref());\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            Some(Path::new(comps.connect(\"\\\\\")))\n-        }\n-    }\n-\n-    fn ends_with_path(&self, child: &Path) -> bool {\n-        if !child.is_relative() { return false; }\n-        let mut selfit = self.str_components().rev();\n-        let mut childit = child.str_components().rev();\n-        loop {\n-            match (selfit.next(), childit.next()) {\n-                (Some(a), Some(b)) => if a != b { return false; },\n-                (Some(_), None) => break,\n-                (None, Some(_)) => return false,\n-                (None, None) => break\n-            }\n-        }\n-        true\n-    }\n-}\n-\n-impl Path {\n-    /// Returns a new `Path` from a `BytesContainer`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the vector contains a `NUL`, or if it contains invalid UTF-8.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// println!(\"{}\", Path::new(r\"C:\\some\\path\").display());\n-    /// ```\n-    #[inline]\n-    pub fn new<T: BytesContainer>(path: T) -> Path {\n-        GenericPath::new(path)\n-    }\n-\n-    /// Returns a new `Some(Path)` from a `BytesContainer`.\n-    ///\n-    /// Returns `None` if the vector contains a `NUL`, or if it contains invalid UTF-8.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// let path = Path::new_opt(r\"C:\\some\\path\");\n-    ///\n-    /// match path {\n-    ///     Some(path) => println!(\"{}\", path.display()),\n-    ///     None       => println!(\"There was a problem with your path.\"),\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn new_opt<T: BytesContainer>(path: T) -> Option<Path> {\n-        GenericPath::new_opt(path)\n-    }\n-\n-    /// Returns an iterator that yields each component of the path in turn as a Option<&str>.\n-    /// Every component is guaranteed to be Some.\n-    /// Does not yield the path prefix (including server/share components in UNC paths).\n-    /// Does not distinguish between volume-relative and relative paths, e.g.\n-    /// \\a\\b\\c and a\\b\\c.\n-    /// Does not distinguish between absolute and cwd-relative paths, e.g.\n-    /// C:\\foo and C:foo.\n-    pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        let repr = &self.repr[..];\n-        let s = match self.prefix {\n-            Some(_) => {\n-                let plen = self.prefix_len();\n-                if repr.len() > plen && repr.as_bytes()[plen] == SEP_BYTE {\n-                    &repr[plen+1..]\n-                } else { &repr[plen..] }\n-            }\n-            None if repr.as_bytes()[0] == SEP_BYTE => &repr[1..],\n-            None => repr\n-        };\n-        let some: fn(&'a str) -> Option<&'a str> = Some; // coerce to fn ptr\n-        let ret = s.split_terminator(SEP).map(some);\n-        ret\n-    }\n-\n-    /// Returns an iterator that yields each component of the path in turn as a &[u8].\n-    /// See str_components() for details.\n-    pub fn components<'a>(&'a self) -> Components<'a> {\n-        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n-            #![inline]\n-            x.unwrap().as_bytes()\n-        }\n-        let convert: for<'b> fn(Option<&'b str>) -> &'b [u8] = convert; // coerce to fn ptr\n-        self.str_components().map(convert)\n-    }\n-\n-    fn equiv_prefix(&self, other: &Path) -> bool {\n-        let s_repr = &self.repr[..];\n-        let o_repr = &other.repr[..];\n-        match (self.prefix, other.prefix) {\n-            (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                self.is_absolute() &&\n-                    s_repr.as_bytes()[0].to_ascii_lowercase() ==\n-                        o_repr.as_bytes()[4].to_ascii_lowercase()\n-            }\n-            (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n-                other.is_absolute() &&\n-                    s_repr.as_bytes()[4].to_ascii_lowercase() ==\n-                        o_repr.as_bytes()[0].to_ascii_lowercase()\n-            }\n-            (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                s_repr.as_bytes()[4].to_ascii_lowercase() ==\n-                    o_repr.as_bytes()[4].to_ascii_lowercase()\n-            }\n-            (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n-                &s_repr[2..self.prefix_len()] == &o_repr[8..other.prefix_len()]\n-            }\n-            (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n-                &s_repr[8..self.prefix_len()] == &o_repr[2..other.prefix_len()]\n-            }\n-            (None, None) => true,\n-            (a, b) if a == b => {\n-                &s_repr[..self.prefix_len()] == &o_repr[..other.prefix_len()]\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    fn normalize_(s: &str) -> (Option<PathPrefix>, String) {\n-        // make borrowck happy\n-        let (prefix, val) = {\n-            let prefix = parse_prefix(s);\n-            let path = Path::normalize__(s, prefix);\n-            (prefix, path)\n-        };\n-        (prefix, match val {\n-            None => s.to_string(),\n-            Some(val) => val\n-        })\n-    }\n-\n-    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<String> {\n-        if prefix_is_verbatim(prefix) {\n-            // don't do any normalization\n-            match prefix {\n-                Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n-                    // the server component has no trailing '\\'\n-                    let mut s = String::from_str(s);\n-                    s.push(SEP);\n-                    Some(s)\n-                }\n-                _ => None\n-            }\n-        } else {\n-            let (is_abs, comps) = normalize_helper(s, prefix);\n-            let mut comps = comps;\n-            match (comps.is_some(),prefix) {\n-                (false, Some(DiskPrefix)) => {\n-                    if s.as_bytes()[0] >= b'a' && s.as_bytes()[0] <= b'z' {\n-                        comps = Some(vec![]);\n-                    }\n-                }\n-                (false, Some(VerbatimDiskPrefix)) => {\n-                    if s.as_bytes()[4] >= b'a' && s.as_bytes()[0] <= b'z' {\n-                        comps = Some(vec![]);\n-                    }\n-                }\n-                _ => ()\n-            }\n-            match comps {\n-                None => None,\n-                Some(comps) => {\n-                    if prefix.is_some() && comps.is_empty() {\n-                        match prefix.unwrap() {\n-                            DiskPrefix => {\n-                                let len = prefix_len(prefix) + is_abs as usize;\n-                                let mut s = String::from_str(&s[..len]);\n-                                unsafe {\n-                                    let v = s.as_mut_vec();\n-                                    v[0] = (*v)[0].to_ascii_uppercase();\n-                                }\n-                                if is_abs {\n-                                    // normalize C:/ to C:\\\n-                                    unsafe {\n-                                        s.as_mut_vec()[2] = SEP_BYTE;\n-                                    }\n-                                }\n-                                Some(s)\n-                            }\n-                            VerbatimDiskPrefix => {\n-                                let len = prefix_len(prefix) + is_abs as usize;\n-                                let mut s = String::from_str(&s[..len]);\n-                                unsafe {\n-                                    let v = s.as_mut_vec();\n-                                    v[4] = (*v)[4].to_ascii_uppercase();\n-                                }\n-                                Some(s)\n-                            }\n-                            _ => {\n-                                let plen = prefix_len(prefix);\n-                                if s.len() > plen {\n-                                    Some(String::from_str(&s[..plen]))\n-                                } else { None }\n-                            }\n-                        }\n-                    } else if is_abs && comps.is_empty() {\n-                        Some(repeat(SEP).take(1).collect())\n-                    } else {\n-                        let prefix_ = &s[..prefix_len(prefix)];\n-                        let n = prefix_.len() +\n-                                if is_abs { comps.len() } else { comps.len() - 1} +\n-                                comps.iter().map(|v| v.len()).sum::<usize>();\n-                        let mut s = String::with_capacity(n);\n-                        match prefix {\n-                            Some(DiskPrefix) => {\n-                                s.push(prefix_.as_bytes()[0].to_ascii_uppercase() as char);\n-                                s.push(':');\n-                            }\n-                            Some(VerbatimDiskPrefix) => {\n-                                s.push_str(&prefix_[..4]);\n-                                s.push(prefix_.as_bytes()[4].to_ascii_uppercase() as char);\n-                                s.push_str(&prefix_[5..]);\n-                            }\n-                            Some(UNCPrefix(a,b)) => {\n-                                s.push_str(\"\\\\\\\\\");\n-                                s.push_str(&prefix_[2..a+2]);\n-                                s.push(SEP);\n-                                s.push_str(&prefix_[3+a..3+a+b]);\n-                            }\n-                            Some(_) => s.push_str(prefix_),\n-                            None => ()\n-                        }\n-                        let mut it = comps.into_iter();\n-                        if !is_abs {\n-                            match it.next() {\n-                                None => (),\n-                                Some(comp) => s.push_str(comp)\n-                            }\n-                        }\n-                        for comp in it {\n-                            s.push(SEP);\n-                            s.push_str(comp);\n-                        }\n-                        Some(s)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn update_sepidx(&mut self) {\n-        let s = if self.has_nonsemantic_trailing_slash() {\n-                    &self.repr[..self.repr.len()-1]\n-                } else { &self.repr[..] };\n-        let sep_test: fn(char) -> bool = if !prefix_is_verbatim(self.prefix) {\n-            is_sep\n-        } else {\n-            is_sep_verbatim\n-        };\n-        let idx = s.rfind(sep_test);\n-        let prefixlen = self.prefix_len();\n-        self.sepidx = idx.and_then(|x| if x < prefixlen { None } else { Some(x) });\n-    }\n-\n-    fn prefix_len(&self) -> usize {\n-        prefix_len(self.prefix)\n-    }\n-\n-    // Returns a tuple (before, after, end) where before is the index of the separator\n-    // and after is the index just after the separator.\n-    // end is the length of the string, normally, or the index of the final character if it is\n-    // a non-semantic trailing separator in a verbatim string.\n-    // If the prefix is considered the separator, before and after are the same.\n-    fn sepidx_or_prefix_len(&self) -> Option<(usize,usize,usize)> {\n-        match self.sepidx {\n-            None => match self.prefix_len() { 0 => None, x => Some((x,x,self.repr.len())) },\n-            Some(x) => {\n-                if self.has_nonsemantic_trailing_slash() {\n-                    Some((x,x+1,self.repr.len()-1))\n-                } else { Some((x,x+1,self.repr.len())) }\n-            }\n-        }\n-    }\n-\n-    fn has_nonsemantic_trailing_slash(&self) -> bool {\n-        is_verbatim(self) && self.repr.len() > self.prefix_len()+1 &&\n-            self.repr.as_bytes()[self.repr.len()-1] == SEP_BYTE\n-    }\n-\n-    fn update_normalized(&mut self, s: &str) {\n-        let (prefix, path) = Path::normalize_(s);\n-        self.repr = path;\n-        self.prefix = prefix;\n-        self.update_sepidx();\n-    }\n-}\n-\n-/// Returns whether the path is considered \"volume-relative\", which means a path\n-/// that looks like \"\\foo\". Paths of this form are relative to the current volume,\n-/// but absolute within that volume.\n-#[inline]\n-pub fn is_vol_relative(path: &Path) -> bool {\n-    path.prefix.is_none() && is_sep_byte(&path.repr.as_bytes()[0])\n-}\n-\n-/// Returns whether the path is considered \"cwd-relative\", which means a path\n-/// with a volume prefix that is not absolute. This look like \"C:foo.txt\". Paths\n-/// of this form are relative to the cwd on the given volume.\n-#[inline]\n-pub fn is_cwd_relative(path: &Path) -> bool {\n-    path.prefix == Some(DiskPrefix) && !path.is_absolute()\n-}\n-\n-/// Returns the PathPrefix for this Path\n-#[inline]\n-pub fn prefix(path: &Path) -> Option<PathPrefix> {\n-    path.prefix\n-}\n-\n-/// Returns whether the Path's prefix is a verbatim prefix, i.e. `\\\\?\\`\n-#[inline]\n-pub fn is_verbatim(path: &Path) -> bool {\n-    prefix_is_verbatim(path.prefix)\n-}\n-\n-/// Returns the non-verbatim equivalent of the input path, if possible.\n-/// If the input path is a device namespace path, None is returned.\n-/// If the input path is not verbatim, it is returned as-is.\n-/// If the input path is verbatim, but the same path can be expressed as\n-/// non-verbatim, the non-verbatim version is returned.\n-/// Otherwise, None is returned.\n-pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n-    let repr = &path.repr[..];\n-    let new_path = match path.prefix {\n-        Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n-        Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n-        Some(VerbatimDiskPrefix) => {\n-            // \\\\?\\D:\\\n-            Path::new(&repr[4..])\n-        }\n-        Some(VerbatimUNCPrefix(_,_)) => {\n-            // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\{}\", &repr[7..]))\n-        }\n-    };\n-    if new_path.prefix.is_none() {\n-        // \\\\?\\UNC\\server is a VerbatimUNCPrefix\n-        // but \\\\server is nothing\n-        return None;\n-    }\n-    // now ensure normalization didn't change anything\n-    if &repr[path.prefix_len()..] == &new_path.repr[new_path.prefix_len()..] {\n-        Some(new_path)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// The standard path separator character\n-pub const SEP: char = '\\\\';\n-/// The standard path separator byte\n-pub const SEP_BYTE: u8 = SEP as u8;\n-\n-/// The alternative path separator character\n-pub const SEP2: char = '/';\n-/// The alternative path separator character\n-pub const SEP2_BYTE: u8 = SEP2 as u8;\n-\n-/// Returns whether the given char is a path separator.\n-/// Allows both the primary separator '\\' and the alternative separator '/'.\n-#[inline]\n-pub fn is_sep(c: char) -> bool {\n-    c == SEP || c == SEP2\n-}\n-\n-/// Returns whether the given char is a path separator.\n-/// Only allows the primary separator '\\'; use is_sep to allow '/'.\n-#[inline]\n-pub fn is_sep_verbatim(c: char) -> bool {\n-    c == SEP\n-}\n-\n-/// Returns whether the given byte is a path separator.\n-/// Allows both the primary separator '\\' and the alternative separator '/'.\n-#[inline]\n-pub fn is_sep_byte(u: &u8) -> bool {\n-    *u == SEP_BYTE || *u == SEP2_BYTE\n-}\n-\n-/// Returns whether the given byte is a path separator.\n-/// Only allows the primary separator '\\'; use is_sep_byte to allow '/'.\n-#[inline]\n-pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n-    *u == SEP_BYTE\n-}\n-\n-/// Prefix types for Path\n-#[derive(Copy, PartialEq, Clone, Debug)]\n-pub enum PathPrefix {\n-    /// Prefix `\\\\?\\`, usize is the length of the following component\n-    VerbatimPrefix(usize),\n-    /// Prefix `\\\\?\\UNC\\`, uints are the lengths of the UNC components\n-    VerbatimUNCPrefix(usize, usize),\n-    /// Prefix `\\\\?\\C:\\` (for any alphabetic character)\n-    VerbatimDiskPrefix,\n-    /// Prefix `\\\\.\\`, usize is the length of the following component\n-    DeviceNSPrefix(usize),\n-    /// UNC prefix `\\\\server\\share`, uints are the lengths of the server/share\n-    UNCPrefix(usize, usize),\n-    /// Prefix `C:` for any alphabetic character\n-    DiskPrefix\n-}\n-\n-fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n-    if path.starts_with(\"\\\\\\\\\") {\n-        // \\\\\n-        path = &path[2..];\n-        if path.starts_with(\"?\\\\\") {\n-            // \\\\?\\\n-            path = &path[2..];\n-            if path.starts_with(\"UNC\\\\\") {\n-                // \\\\?\\UNC\\server\\share\n-                path = &path[4..];\n-                let (idx_a, idx_b) = match parse_two_comps(path, is_sep_verbatim) {\n-                    Some(x) => x,\n-                    None => (path.len(), 0)\n-                };\n-                return Some(VerbatimUNCPrefix(idx_a, idx_b));\n-            } else {\n-                // \\\\?\\path\n-                let idx = path.find('\\\\');\n-                if idx == Some(2) && path.as_bytes()[1] == b':' {\n-                    let c = path.as_bytes()[0];\n-                    if c.is_ascii() && (c as char).is_alphabetic() {\n-                        // \\\\?\\C:\\ path\n-                        return Some(VerbatimDiskPrefix);\n-                    }\n-                }\n-                let idx = idx.unwrap_or(path.len());\n-                return Some(VerbatimPrefix(idx));\n-            }\n-        } else if path.starts_with(\".\\\\\") {\n-            // \\\\.\\path\n-            path = &path[2..];\n-            let idx = path.find('\\\\').unwrap_or(path.len());\n-            return Some(DeviceNSPrefix(idx));\n-        }\n-        match parse_two_comps(path, is_sep) {\n-            Some((idx_a, idx_b)) if idx_a > 0 && idx_b > 0 => {\n-                // \\\\server\\share\n-                return Some(UNCPrefix(idx_a, idx_b));\n-            }\n-            _ => ()\n-        }\n-    } else if path.len() > 1 && path.as_bytes()[1] == b':' {\n-        // C:\n-        let c = path.as_bytes()[0];\n-        if c.is_ascii() && (c as char).is_alphabetic() {\n-            return Some(DiskPrefix);\n-        }\n-    }\n-    return None;\n-\n-    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(usize, usize)> {\n-        let idx_a = match path.find(f) {\n-            None => return None,\n-            Some(x) => x\n-        };\n-        path = &path[idx_a+1..];\n-        let idx_b = path.find(f).unwrap_or(path.len());\n-        Some((idx_a, idx_b))\n-    }\n-}\n-\n-// None result means the string didn't need normalizing\n-fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) {\n-    let f: fn(char) -> bool = if !prefix_is_verbatim(prefix) {\n-        is_sep\n-    } else {\n-        is_sep_verbatim\n-    };\n-    let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n-    let s_ = &s[prefix_len(prefix)..];\n-    let s_ = if is_abs { &s_[1..] } else { s_ };\n-\n-    if is_abs && s_.is_empty() {\n-        return (is_abs, match prefix {\n-            Some(DiskPrefix) | None => (if is_sep_verbatim(s.char_at(prefix_len(prefix))) { None }\n-                                        else { Some(vec![]) }),\n-            Some(_) => Some(vec![]), // need to trim the trailing separator\n-        });\n-    }\n-    let mut comps: Vec<&'a str> = vec![];\n-    let mut n_up = 0;\n-    let mut changed = false;\n-    for comp in s_.split(f) {\n-        if comp.is_empty() { changed = true }\n-        else if comp == \".\" { changed = true }\n-        else if comp == \"..\" {\n-            let has_abs_prefix = match prefix {\n-                Some(DiskPrefix) => false,\n-                Some(_) => true,\n-                None => false\n-            };\n-            if (is_abs || has_abs_prefix) && comps.is_empty() { changed = true }\n-            else if comps.len() == n_up { comps.push(\"..\"); n_up += 1 }\n-            else { comps.pop().unwrap(); changed = true }\n-        } else { comps.push(comp) }\n-    }\n-    if !changed && !prefix_is_verbatim(prefix) {\n-        changed = s.find(is_sep).is_some();\n-    }\n-    if changed {\n-        if comps.is_empty() && !is_abs && prefix.is_none() {\n-            if s == \".\" {\n-                return (is_abs, None);\n-            }\n-            comps.push(\".\");\n-        }\n-        (is_abs, Some(comps))\n-    } else {\n-        (is_abs, None)\n-    }\n-}\n-\n-fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool {\n-    match p {\n-        Some(VerbatimPrefix(_)) | Some(VerbatimUNCPrefix(_,_)) | Some(VerbatimDiskPrefix) => true,\n-        Some(DeviceNSPrefix(_)) => true, // not really sure, but I think so\n-        _ => false\n-    }\n-}\n-\n-fn prefix_len(p: Option<PathPrefix>) -> usize {\n-    match p {\n-        None => 0,\n-        Some(VerbatimPrefix(x)) => 4 + x,\n-        Some(VerbatimUNCPrefix(x,y)) => 8 + x + 1 + y,\n-        Some(VerbatimDiskPrefix) => 6,\n-        Some(UNCPrefix(x,y)) => 2 + x + 1 + y,\n-        Some(DeviceNSPrefix(x)) => 4 + x,\n-        Some(DiskPrefix) => 2\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::PathPrefix::*;\n-    use super::parse_prefix;\n-    use super::*;\n-\n-    use clone::Clone;\n-    use iter::Iterator;\n-    use option::Option::{self, Some, None};\n-    use old_path::GenericPath;\n-    use string::ToString;\n-    use vec::Vec;\n-\n-    macro_rules! t {\n-        (s: $path:expr, $exp:expr) => (\n-            {\n-                let path = $path;\n-                assert_eq!(path.as_str(), Some($exp));\n-            }\n-        );\n-        (v: $path:expr, $exp:expr) => (\n-            {\n-                let path = $path;\n-                assert_eq!(path.as_vec(), $exp);\n-            }\n-        )\n-    }\n-\n-    #[test]\n-    fn test_parse_prefix() {\n-        macro_rules! t {\n-            ($path:expr, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let exp = $exp;\n-                    let res = parse_prefix(path);\n-                    assert_eq!(res, exp);\n-                }\n-            )\n-        }\n-\n-        t!(\"\\\\\\\\SERVER\\\\share\\\\foo\", Some(UNCPrefix(6,5)));\n-        t!(\"\\\\\\\\\", None);\n-        t!(\"\\\\\\\\SERVER\", None);\n-        t!(\"\\\\\\\\SERVER\\\\\", None);\n-        t!(\"\\\\\\\\SERVER\\\\\\\\\", None);\n-        t!(\"\\\\\\\\SERVER\\\\\\\\foo\", None);\n-        t!(\"\\\\\\\\SERVER\\\\share\", Some(UNCPrefix(6,5)));\n-        t!(\"\\\\\\\\SERVER/share/foo\", Some(UNCPrefix(6,5)));\n-        t!(\"\\\\\\\\SERVER\\\\share/foo\", Some(UNCPrefix(6,5)));\n-        t!(\"//SERVER/share/foo\", None);\n-        t!(\"\\\\\\\\\\\\a\\\\b\\\\c\", None);\n-        t!(\"\\\\\\\\?\\\\a\\\\b\\\\c\", Some(VerbatimPrefix(1)));\n-        t!(\"\\\\\\\\?\\\\a/b/c\", Some(VerbatimPrefix(5)));\n-        t!(\"//?/a/b/c\", None);\n-        t!(\"\\\\\\\\.\\\\a\\\\b\", Some(DeviceNSPrefix(1)));\n-        t!(\"\\\\\\\\.\\\\a/b\", Some(DeviceNSPrefix(3)));\n-        t!(\"//./a/b\", None);\n-        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", Some(VerbatimUNCPrefix(6,5)));\n-        t!(\"\\\\\\\\?\\\\UNC\\\\\\\\share\\\\foo\", Some(VerbatimUNCPrefix(0,5)));\n-        t!(\"\\\\\\\\?\\\\UNC\\\\\", Some(VerbatimUNCPrefix(0,0)));\n-        t!(\"\\\\\\\\?\\\\UNC\\\\server/share/foo\", Some(VerbatimUNCPrefix(16,0)));\n-        t!(\"\\\\\\\\?\\\\UNC\\\\server\", Some(VerbatimUNCPrefix(6,0)));\n-        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\\", Some(VerbatimUNCPrefix(6,0)));\n-        t!(\"\\\\\\\\?\\\\UNC/server/share\", Some(VerbatimPrefix(16)));\n-        t!(\"\\\\\\\\?\\\\UNC\", Some(VerbatimPrefix(3)));\n-        t!(\"\\\\\\\\?\\\\C:\\\\a\\\\b.txt\", Some(VerbatimDiskPrefix));\n-        t!(\"\\\\\\\\?\\\\z:\\\\\", Some(VerbatimDiskPrefix));\n-        t!(\"\\\\\\\\?\\\\C:\", Some(VerbatimPrefix(2)));\n-        t!(\"\\\\\\\\?\\\\C:a.txt\", Some(VerbatimPrefix(7)));\n-        t!(\"\\\\\\\\?\\\\C:a\\\\b.txt\", Some(VerbatimPrefix(3)));\n-        t!(\"\\\\\\\\?\\\\C:/a\", Some(VerbatimPrefix(4)));\n-        t!(\"C:\\\\foo\", Some(DiskPrefix));\n-        t!(\"z:/foo\", Some(DiskPrefix));\n-        t!(\"d:\", Some(DiskPrefix));\n-        t!(\"ab:\", None);\n-        t!(\"\u00fc:\\\\foo\", None);\n-        t!(\"3:\\\\foo\", None);\n-        t!(\" :\\\\foo\", None);\n-        t!(\"::\\\\foo\", None);\n-        t!(\"\\\\\\\\?\\\\C:\", Some(VerbatimPrefix(2)));\n-        t!(\"\\\\\\\\?\\\\z:\\\\\", Some(VerbatimDiskPrefix));\n-        t!(\"\\\\\\\\?\\\\ab:\\\\\", Some(VerbatimPrefix(3)));\n-        t!(\"\\\\\\\\?\\\\C:\\\\a\", Some(VerbatimDiskPrefix));\n-        t!(\"\\\\\\\\?\\\\C:/a\", Some(VerbatimPrefix(4)));\n-        t!(\"\\\\\\\\?\\\\C:\\\\a/b\", Some(VerbatimDiskPrefix));\n-    }\n-\n-    #[test]\n-    fn test_paths() {\n-        let empty: &[u8] = &[];\n-        t!(v: Path::new(empty), b\".\");\n-        t!(v: Path::new(&b\"\\\\\"[..]), b\"\\\\\");\n-        t!(v: Path::new(&b\"a\\\\b\\\\c\"[..]), b\"a\\\\b\\\\c\");\n-\n-        t!(s: Path::new(\"\"), \".\");\n-        t!(s: Path::new(\"\\\\\"), \"\\\\\");\n-        t!(s: Path::new(\"hi\"), \"hi\");\n-        t!(s: Path::new(\"hi\\\\\"), \"hi\");\n-        t!(s: Path::new(\"\\\\lib\"), \"\\\\lib\");\n-        t!(s: Path::new(\"\\\\lib\\\\\"), \"\\\\lib\");\n-        t!(s: Path::new(\"hi\\\\there\"), \"hi\\\\there\");\n-        t!(s: Path::new(\"hi\\\\there.txt\"), \"hi\\\\there.txt\");\n-        t!(s: Path::new(\"/\"), \"\\\\\");\n-        t!(s: Path::new(\"hi/\"), \"hi\");\n-        t!(s: Path::new(\"/lib\"), \"\\\\lib\");\n-        t!(s: Path::new(\"/lib/\"), \"\\\\lib\");\n-        t!(s: Path::new(\"hi/there\"), \"hi\\\\there\");\n-\n-        t!(s: Path::new(\"hi\\\\there\\\\\"), \"hi\\\\there\");\n-        t!(s: Path::new(\"hi\\\\..\\\\there\"), \"there\");\n-        t!(s: Path::new(\"hi/../there\"), \"there\");\n-        t!(s: Path::new(\"..\\\\hi\\\\there\"), \"..\\\\hi\\\\there\");\n-        t!(s: Path::new(\"\\\\..\\\\hi\\\\there\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::new(\"/../hi/there\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::new(\"foo\\\\..\"), \".\");\n-        t!(s: Path::new(\"\\\\foo\\\\..\"), \"\\\\\");\n-        t!(s: Path::new(\"\\\\foo\\\\..\\\\..\"), \"\\\\\");\n-        t!(s: Path::new(\"\\\\foo\\\\..\\\\..\\\\bar\"), \"\\\\bar\");\n-        t!(s: Path::new(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\"), \"\\\\hi\\\\there\");\n-        t!(s: Path::new(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\\\\..\"), \"\\\\hi\");\n-        t!(s: Path::new(\"foo\\\\..\\\\..\"), \"..\");\n-        t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n-        t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n-\n-        assert_eq!(Path::new(&b\"foo\\\\bar\"[..]).into_vec(), b\"foo\\\\bar\");\n-        assert_eq!(Path::new(&b\"\\\\foo\\\\..\\\\..\\\\bar\"[..]).into_vec(), b\"\\\\bar\");\n-\n-        t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n-        t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n-        t!(s: Path::new(\"\\\\\\\\a\\\\b\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::new(\"\\\\\\\\a\\\\b\\\\\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::new(\"\\\\\\\\a\\\\b/\"), \"\\\\\\\\a\\\\b\");\n-        t!(s: Path::new(\"\\\\\\\\\\\\b\"), \"\\\\b\");\n-        t!(s: Path::new(\"\\\\\\\\a\\\\\\\\b\"), \"\\\\a\\\\b\");\n-        t!(s: Path::new(\"\\\\\\\\a\\\\b\\\\c\"), \"\\\\\\\\a\\\\b\\\\c\");\n-        t!(s: Path::new(\"\\\\\\\\server\\\\share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n-        t!(s: Path::new(\"\\\\\\\\server/share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n-        t!(s: Path::new(\"C:a\\\\b.txt\"), \"C:a\\\\b.txt\");\n-        t!(s: Path::new(\"C:a/b.txt\"), \"C:a\\\\b.txt\");\n-        t!(s: Path::new(\"z:\\\\a\\\\b.txt\"), \"Z:\\\\a\\\\b.txt\");\n-        t!(s: Path::new(\"z:/a/b.txt\"), \"Z:\\\\a\\\\b.txt\");\n-        t!(s: Path::new(\"ab:/a/b.txt\"), \"ab:\\\\a\\\\b.txt\");\n-        t!(s: Path::new(\"C:\\\\\"), \"C:\\\\\");\n-        t!(s: Path::new(\"C:\"), \"C:\");\n-        t!(s: Path::new(\"q:\"), \"Q:\");\n-        t!(s: Path::new(\"C:/\"), \"C:\\\\\");\n-        t!(s: Path::new(\"C:\\\\foo\\\\..\"), \"C:\\\\\");\n-        t!(s: Path::new(\"C:foo\\\\..\"), \"C:\");\n-        t!(s: Path::new(\"C:\\\\a\\\\\"), \"C:\\\\a\");\n-        t!(s: Path::new(\"C:\\\\a/\"), \"C:\\\\a\");\n-        t!(s: Path::new(\"C:\\\\a\\\\b\\\\\"), \"C:\\\\a\\\\b\");\n-        t!(s: Path::new(\"C:\\\\a\\\\b/\"), \"C:\\\\a\\\\b\");\n-        t!(s: Path::new(\"C:a\\\\\"), \"C:a\");\n-        t!(s: Path::new(\"C:a/\"), \"C:a\");\n-        t!(s: Path::new(\"C:a\\\\b\\\\\"), \"C:a\\\\b\");\n-        t!(s: Path::new(\"C:a\\\\b/\"), \"C:a\\\\b\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\C:/a/b.txt\"), \"\\\\\\\\?\\\\C:/a/b.txt\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\C:\\\\a/b.txt\"), \"\\\\\\\\?\\\\C:\\\\a/b.txt\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\test\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\test\\\\a\\\\b.txt\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\foo\\\\bar\\\\\"), \"\\\\\\\\?\\\\foo\\\\bar\\\\\");\n-        t!(s: Path::new(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n-        t!(s: Path::new(\"\\\\\\\\.\\\\\"), \"\\\\\\\\.\\\\\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server/share\"), \"\\\\\\\\?\\\\UNC\\\\server/share\\\\\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\server\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\\\\\"), \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n-        t!(s: Path::new(\"\\\\\\\\?\\\\UNC\"), \"\\\\\\\\?\\\\UNC\");\n-\n-        // I'm not sure whether \\\\.\\foo/bar should normalize to \\\\.\\foo\\bar\n-        // as information is sparse and this isn't really googleable.\n-        // I'm going to err on the side of not normalizing it, as this skips the filesystem\n-        t!(s: Path::new(\"\\\\\\\\.\\\\foo/bar\"), \"\\\\\\\\.\\\\foo/bar\");\n-        t!(s: Path::new(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n-    }\n-\n-    #[test]\n-    fn test_opt_paths() {\n-        assert!(Path::new_opt(&b\"foo\\\\bar\\0\"[..]) == None);\n-        assert!(Path::new_opt(&b\"foo\\\\bar\\x80\"[..]) == None);\n-        t!(v: Path::new_opt(&b\"foo\\\\bar\"[..]).unwrap(), b\"foo\\\\bar\");\n-        assert!(Path::new_opt(\"foo\\\\bar\\0\") == None);\n-        t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n-    }\n-\n-    #[test]\n-    fn test_null_byte() {\n-        use thread;\n-        let result = thread::spawn(move|| {\n-            Path::new(&b\"foo/bar\\0\"[..]);\n-        }).join();\n-        assert!(result.is_err());\n-\n-        let result = thread::spawn(move|| {\n-            Path::new(\"test\").set_filename(&b\"f\\0o\"[..])\n-        }).join();\n-        assert!(result.is_err());\n-\n-        let result = thread::spawn(move || {\n-            Path::new(\"test\").push(&b\"f\\0o\"[..]);\n-        }).join();\n-        assert!(result.is_err());\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_not_utf8_panics() {\n-        Path::new(&b\"hello\\x80.txt\"[..]);\n-    }\n-\n-    #[test]\n-    fn test_display_str() {\n-        let path = Path::new(\"foo\");\n-        assert_eq!(path.display().to_string(), \"foo\");\n-        let path = Path::new(&b\"\\\\\"[..]);\n-        assert_eq!(path.filename_display().to_string(), \"\");\n-\n-        let path = Path::new(\"foo\");\n-        let mo = path.display().as_cow();\n-        assert_eq!(mo, \"foo\");\n-        let path = Path::new(&b\"\\\\\"[..]);\n-        let mo = path.filename_display().as_cow();\n-        assert_eq!(mo, \"\");\n-    }\n-\n-    #[test]\n-    fn test_display() {\n-        macro_rules! t {\n-            ($path:expr, $exp:expr, $expf:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let f = format!(\"{}\", path.display());\n-                    assert_eq!(f, $exp);\n-                    let f = format!(\"{}\", path.filename_display());\n-                    assert_eq!(f, $expf);\n-                }\n-            )\n-        }\n-\n-        t!(\"foo\", \"foo\", \"foo\");\n-        t!(\"foo\\\\bar\", \"foo\\\\bar\", \"bar\");\n-        t!(\"\\\\\", \"\\\\\", \"\");\n-    }\n-\n-    #[test]\n-    fn test_components() {\n-        macro_rules! t {\n-            (s: $path:expr, $op:ident, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    assert_eq!(path.$op(), Some($exp));\n-                }\n-            );\n-            (s: $path:expr, $op:ident, $exp:expr, opt) => (\n-                {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    let left = path.$op();\n-                    assert_eq!(left, $exp);\n-                }\n-            );\n-            (v: $path:expr, $op:ident, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let path = Path::new(path);\n-                    assert_eq!(path.$op(), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(v: &b\"a\\\\b\\\\c\"[..], filename, Some(&b\"c\"[..]));\n-        t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", filename_str, \"c\");\n-        t!(s: \"a\", filename_str, \"a\");\n-        t!(s: \"\\\\a\", filename_str, \"a\");\n-        t!(s: \".\", filename_str, None, opt);\n-        t!(s: \"\\\\\", filename_str, None, opt);\n-        t!(s: \"..\", filename_str, None, opt);\n-        t!(s: \"..\\\\..\", filename_str, None, opt);\n-        t!(s: \"c:\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"C:\\\\\", filename_str, None, opt);\n-        t!(s: \"C:\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\server\\\\share\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\server\", filename_str, \"server\");\n-        t!(s: \"\\\\\\\\?\\\\bar\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\?\\\\bar\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo.txt\", filename_str, \"foo.txt\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\C:\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\foo/bar\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\C:/foo\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", filename_str, \"bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\.\\\\foo/bar\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar/baz\", filename_str, \"bar/baz\");\n-        t!(s: \"\\\\\\\\.\\\\\", filename_str, None, opt);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", filename_str, \"b\");\n-\n-        t!(v: &b\"a\\\\b\\\\c\"[..], dirname, b\"a\\\\b\");\n-        t!(s: \"a\\\\b\\\\c\", dirname_str, \"a\\\\b\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", dirname_str, \"\\\\a\\\\b\");\n-        t!(s: \"a\", dirname_str, \".\");\n-        t!(s: \"\\\\a\", dirname_str, \"\\\\\");\n-        t!(s: \".\", dirname_str, \".\");\n-        t!(s: \"\\\\\", dirname_str, \"\\\\\");\n-        t!(s: \"..\", dirname_str, \"..\");\n-        t!(s: \"..\\\\..\", dirname_str, \"..\\\\..\");\n-        t!(s: \"c:\\\\foo.txt\", dirname_str, \"C:\\\\\");\n-        t!(s: \"C:\\\\\", dirname_str, \"C:\\\\\");\n-        t!(s: \"C:\", dirname_str, \"C:\");\n-        t!(s: \"C:foo.txt\", dirname_str, \"C:\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo.txt\", dirname_str, \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\", dirname_str, \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\", dirname_str, \"\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\bar\\\\foo.txt\", dirname_str, \"\\\\\\\\?\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\bar\", dirname_str, \"\\\\\\\\?\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\\", dirname_str, \"\\\\\\\\?\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\", dirname_str, \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", dirname_str, \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\\", dirname_str, \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo.txt\", dirname_str, \"\\\\\\\\?\\\\C:\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", dirname_str, \"\\\\\\\\?\\\\C:\\\\\");\n-        t!(s: \"\\\\\\\\?\\\\C:\", dirname_str, \"\\\\\\\\?\\\\C:\");\n-        t!(s: \"\\\\\\\\?\\\\C:/foo/bar\", dirname_str, \"\\\\\\\\?\\\\C:/foo/bar\");\n-        t!(s: \"\\\\\\\\?\\\\foo/bar\", dirname_str, \"\\\\\\\\?\\\\foo/bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", dirname_str, \"\\\\\\\\.\\\\foo\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", dirname_str, \"\\\\\\\\.\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", dirname_str, \"\\\\\\\\?\\\\a\");\n-\n-        t!(v: &b\"hi\\\\there.txt\"[..], filestem, Some(&b\"there\"[..]));\n-        t!(s: \"hi\\\\there.txt\", filestem_str, \"there\");\n-        t!(s: \"hi\\\\there\", filestem_str, \"there\");\n-        t!(s: \"there.txt\", filestem_str, \"there\");\n-        t!(s: \"there\", filestem_str, \"there\");\n-        t!(s: \".\", filestem_str, None, opt);\n-        t!(s: \"\\\\\", filestem_str, None, opt);\n-        t!(s: \"foo\\\\.bar\", filestem_str, \".bar\");\n-        t!(s: \".bar\", filestem_str, \".bar\");\n-        t!(s: \"..bar\", filestem_str, \".\");\n-        t!(s: \"hi\\\\there..txt\", filestem_str, \"there.\");\n-        t!(s: \"..\", filestem_str, None, opt);\n-        t!(s: \"..\\\\..\", filestem_str, None, opt);\n-        // filestem is based on filename, so we don't need the full set of prefix tests\n-\n-        t!(v: &b\"hi\\\\there.txt\"[..], extension, Some(&b\"txt\"[..]));\n-        t!(v: &b\"hi\\\\there\"[..], extension, None);\n-        t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n-        t!(s: \"hi\\\\there\", extension_str, None, opt);\n-        t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n-        t!(s: \"there\", extension_str, None, opt);\n-        t!(s: \".\", extension_str, None, opt);\n-        t!(s: \"\\\\\", extension_str, None, opt);\n-        t!(s: \"foo\\\\.bar\", extension_str, None, opt);\n-        t!(s: \".bar\", extension_str, None, opt);\n-        t!(s: \"..bar\", extension_str, Some(\"bar\"), opt);\n-        t!(s: \"hi\\\\there..txt\", extension_str, Some(\"txt\"), opt);\n-        t!(s: \"..\", extension_str, None, opt);\n-        t!(s: \"..\\\\..\", extension_str, None, opt);\n-        // extension is based on filename, so we don't need the full set of prefix tests\n-    }\n-\n-    #[test]\n-    fn test_push() {\n-        macro_rules! t {\n-            (s: $path:expr, $join:expr) => (\n-                {\n-                    let path = $path;\n-                    let join = $join;\n-                    let mut p1 = Path::new(path);\n-                    let p2 = p1.clone();\n-                    p1.push(join);\n-                    assert_eq!(p1, p2.join(join));\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"..\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n-        t!(s: \"a\\\\b\", \"c\\\\d\");\n-        t!(s: \"a\\\\b\", \"\\\\c\\\\d\");\n-        // this is just a sanity-check test. push and join share an implementation,\n-        // so there's no need for the full set of prefix tests\n-\n-        // we do want to check one odd case though to ensure the prefix is re-parsed\n-        let mut p = Path::new(\"\\\\\\\\?\\\\C:\");\n-        assert_eq!(prefix(&p), Some(VerbatimPrefix(2)));\n-        p.push(\"foo\");\n-        assert_eq!(prefix(&p), Some(VerbatimDiskPrefix));\n-        assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n-\n-        // and another with verbatim non-normalized paths\n-        let mut p = Path::new(\"\\\\\\\\?\\\\C:\\\\a\\\\\");\n-        p.push(\"foo\");\n-        assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\a\\\\foo\"));\n-    }\n-\n-    #[test]\n-    fn test_push_path() {\n-        macro_rules! t {\n-            (s: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    let push = Path::new($push);\n-                    p.push(&push);\n-                    assert_eq!(p.as_str(), Some($exp));\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: \"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n-        t!(s: \"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n-        t!(s: \"a\\\\b\", \".\", \"a\\\\b\");\n-        t!(s: \"a\\\\b\", \"..\\\\c\", \"a\\\\c\");\n-        t!(s: \"a\\\\b\", \"C:a.txt\", \"C:a.txt\");\n-        t!(s: \"a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"..\\\\c\");\n-        t!(s: \"a\\\\b\", \"C:\\\\a.txt\", \"C:\\\\a.txt\");\n-        t!(s: \"C:\\\\a\", \"C:\\\\b.txt\", \"C:\\\\b.txt\");\n-        t!(s: \"C:\\\\a\\\\b\\\\c\", \"C:d\", \"C:\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: \"C:a\\\\b\\\\c\", \"C:d\", \"C:a\\\\b\\\\c\\\\d\");\n-        t!(s: \"C:a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"C:..\\\\c\");\n-        t!(s: \"C:\\\\a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"C:\\\\c\");\n-        t!(s: \"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n-        t!(s: \"C:\", r\"..\\a\", r\"C:..\\a\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"..\\\\..\\\\bar\", \"\\\\\\\\server\\\\share\\\\bar\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: \"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\..\\\\..\\\\..\\\\c\");\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"..\\\\..\\\\c\", \"\\\\\\\\?\\\\foo\\\\bar\\\\..\\\\..\\\\c\");\n-        t!(s: \"\\\\\\\\?\\\\\", \"foo\", \"\\\\\\\\?\\\\\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\\\\\foo\");\n-        t!(s: \"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n-        // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n-        t!(s: \"\\\\\\\\.\\\\foo\", \"..\\\\bar\", \"\\\\\\\\.\\\\foo\\\\..\\\\bar\");\n-\n-        t!(s: \"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n-    }\n-\n-    #[test]\n-    fn test_push_many() {\n-        macro_rules! t {\n-            (s: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    p.push_many(&$push);\n-                    assert_eq!(p.as_str(), Some($exp));\n-                }\n-            );\n-            (v: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    p.push_many(&$push);\n-                    assert_eq!(p.as_vec(), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: &b\"a\\\\b\\\\c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: &b\"a\\\\b\\\\c\"[..], [&b\"d\"[..], &b\"\\\\e\"[..], &b\"f\"[..]], b\"\\\\e\\\\f\");\n-        t!(v: &b\"a\\\\b\\\\c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()],\n-           b\"a\\\\b\\\\c\\\\d\\\\e\");\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        macro_rules! t {\n-            (s: $path:expr, $left:expr, $right:expr) => (\n-                {\n-                    let pstr = $path;\n-                    let mut p = Path::new(pstr);\n-                    let result = p.pop();\n-                    let left = $left;\n-                    assert_eq!(p.as_str(), Some(left));\n-                    assert_eq!(result, $right);\n-                }\n-            );\n-            (b: $path:expr, $left:expr, $right:expr) => (\n-                {\n-                    let mut p = Path::new($path);\n-                    let result = p.pop();\n-                    assert_eq!(p.as_vec(), $left);\n-                    assert_eq!(result, $right);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", true);\n-        t!(s: \"a\", \".\", true);\n-        t!(s: \".\", \".\", false);\n-        t!(s: \"\\\\a\", \"\\\\\", true);\n-        t!(s: \"\\\\\", \"\\\\\", false);\n-        t!(b: &b\"a\\\\b\\\\c\"[..], b\"a\\\\b\", true);\n-        t!(b: &b\"a\"[..], b\".\", true);\n-        t!(b: &b\".\"[..], b\".\", false);\n-        t!(b: &b\"\\\\a\"[..], b\"\\\\\", true);\n-        t!(b: &b\"\\\\\"[..], b\"\\\\\", false);\n-\n-        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n-        t!(s: \"C:\\\\a\", \"C:\\\\\", true);\n-        t!(s: \"C:\\\\\", \"C:\\\\\", false);\n-        t!(s: \"C:a\\\\b\", \"C:a\", true);\n-        t!(s: \"C:a\", \"C:\", true);\n-        t!(s: \"C:\", \"C:\", false);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", true);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\", true);\n-        t!(s: \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", false);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\", true);\n-        t!(s: \"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", true);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n-        t!(s: \"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\", true);\n-        t!(s: \"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n-\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\", true);\n-    }\n-\n-    #[test]\n-    fn test_root_path() {\n-        assert_eq!(Path::new(\"a\\\\b\\\\c\").root_path(),  None);\n-        assert_eq!(Path::new(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\")));\n-        assert_eq!(Path::new(\"C:a\").root_path(), Some(Path::new(\"C:\")));\n-        assert_eq!(Path::new(\"C:\\\\a\").root_path(), Some(Path::new(\"C:\\\\\")));\n-        assert_eq!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\\\\a\\\\b\")));\n-        assert_eq!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\a\")));\n-        assert_eq!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n-        assert_eq!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n-                Some(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n-        assert_eq!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\.\\\\a\")));\n-    }\n-\n-    #[test]\n-    fn test_join() {\n-        t!(s: Path::new(\"a\\\\b\\\\c\").join(\"..\"), \"a\\\\b\");\n-        t!(s: Path::new(\"\\\\a\\\\b\\\\c\").join(\"d\"), \"\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: Path::new(\"a\\\\b\").join(\"c\\\\d\"), \"a\\\\b\\\\c\\\\d\");\n-        t!(s: Path::new(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n-        t!(s: Path::new(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n-        t!(s: Path::new(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::new(&b\"a\\\\b\\\\c\"[..]).join(&b\"..\"[..]), b\"a\\\\b\");\n-        t!(v: Path::new(&b\"\\\\a\\\\b\\\\c\"[..]).join(&b\"d\"[..]), b\"\\\\a\\\\b\\\\c\\\\d\");\n-        // full join testing is covered under test_push_path, so no need for\n-        // the full set of prefix tests\n-    }\n-\n-    #[test]\n-    fn test_join_path() {\n-        macro_rules! t {\n-            (s: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let join = Path::new($join);\n-                    let res = path.join(&join);\n-                    assert_eq!(res.as_str(), Some($exp));\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"..\", \"a\\\\b\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n-        t!(s: \"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n-        t!(s: \"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n-        t!(s: \".\", \"a\\\\b\", \"a\\\\b\");\n-        t!(s: \"\\\\\", \"a\\\\b\", \"\\\\a\\\\b\");\n-        // join is implemented using push, so there's no need for\n-        // the full set of prefix tests\n-    }\n-\n-    #[test]\n-    fn test_join_many() {\n-        macro_rules! t {\n-            (s: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let res = path.join_many(&$join);\n-                    assert_eq!(res.as_str(), Some($exp));\n-                }\n-            );\n-            (v: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let res = path.join_many(&$join);\n-                    assert_eq!(res.as_vec(), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: &b\"a\\\\b\\\\c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: &b\"a\\\\b\\\\c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()],\n-           b\"a\\\\b\\\\c\\\\d\\\\e\");\n-    }\n-\n-    #[test]\n-    fn test_with_helpers() {\n-        macro_rules! t {\n-            (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n-                {\n-                    let pstr = $path;\n-                    let path = Path::new(pstr);\n-                    let arg = $arg;\n-                    let res = path.$op(arg);\n-                    let exp = Path::new($res);\n-                    assert_eq!(res, exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n-        t!(s: \".\", with_filename, \"foo\", \"foo\");\n-        t!(s: \"\\\\a\\\\b\\\\c\", with_filename, \"d\", \"\\\\a\\\\b\\\\d\");\n-        t!(s: \"\\\\\", with_filename, \"foo\", \"\\\\foo\");\n-        t!(s: \"\\\\a\", with_filename, \"foo\", \"\\\\foo\");\n-        t!(s: \"foo\", with_filename, \"bar\", \"bar\");\n-        t!(s: \"\\\\\", with_filename, \"foo\\\\\", \"\\\\foo\");\n-        t!(s: \"\\\\a\", with_filename, \"foo\\\\\", \"\\\\foo\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename, \"\", \"a\\\\b\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename, \".\", \"a\\\\b\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename, \"..\", \"a\");\n-        t!(s: \"\\\\a\", with_filename, \"\", \"\\\\\");\n-        t!(s: \"foo\", with_filename, \"\", \".\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename, \"d\\\\e\", \"a\\\\b\\\\d\\\\e\");\n-        t!(s: \"a\\\\b\\\\c\", with_filename, \"\\\\d\", \"a\\\\b\\\\d\");\n-        t!(s: \"..\", with_filename, \"foo\", \"..\\\\foo\");\n-        t!(s: \"..\\\\..\", with_filename, \"foo\", \"..\\\\..\\\\foo\");\n-        t!(s: \"..\", with_filename, \"\", \"..\");\n-        t!(s: \"..\\\\..\", with_filename, \"\", \"..\\\\..\");\n-        t!(s: \"C:\\\\foo\\\\bar\", with_filename, \"baz\", \"C:\\\\foo\\\\baz\");\n-        t!(s: \"C:\\\\foo\", with_filename, \"bar\", \"C:\\\\bar\");\n-        t!(s: \"C:\\\\\", with_filename, \"foo\", \"C:\\\\foo\");\n-        t!(s: \"C:foo\\\\bar\", with_filename, \"baz\", \"C:foo\\\\baz\");\n-        t!(s: \"C:foo\", with_filename, \"bar\", \"C:bar\");\n-        t!(s: \"C:\", with_filename, \"foo\", \"C:foo\");\n-        t!(s: \"C:\\\\foo\", with_filename, \"\", \"C:\\\\\");\n-        t!(s: \"C:foo\", with_filename, \"\", \"C:\");\n-        t!(s: \"C:\\\\foo\\\\bar\", with_filename, \"..\", \"C:\\\\\");\n-        t!(s: \"C:\\\\foo\", with_filename, \"..\", \"C:\\\\\");\n-        t!(s: \"C:\\\\\", with_filename, \"..\", \"C:\\\\\");\n-        t!(s: \"C:foo\\\\bar\", with_filename, \"..\", \"C:\");\n-        t!(s: \"C:foo\", with_filename, \"..\", \"C:..\");\n-        t!(s: \"C:\", with_filename, \"..\", \"C:..\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename, \"bar\", \"\\\\\\\\server\\\\share\\\\bar\");\n-        t!(s: \"\\\\\\\\server\\\\share\", with_filename, \"foo\", \"\\\\\\\\server\\\\share\\\\foo\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename, \"\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\", with_filename, \"\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename, \"..\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\server\\\\share\", with_filename, \"..\", \"\\\\\\\\server\\\\share\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", with_filename, \"baz\", \"\\\\\\\\?\\\\C:\\\\foo\\\\baz\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename, \"bar\", \"\\\\\\\\?\\\\C:\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_filename, \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename, \"..\", \"\\\\\\\\?\\\\C:\\\\..\");\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename, \"baz\", \"\\\\\\\\?\\\\foo\\\\baz\");\n-        t!(s: \"\\\\\\\\?\\\\foo\", with_filename, \"bar\", \"\\\\\\\\?\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\?\\\\\", with_filename, \"foo\", \"\\\\\\\\?\\\\\\\\foo\");\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename, \"..\", \"\\\\\\\\?\\\\foo\\\\..\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename, \"baz\", \"\\\\\\\\.\\\\foo\\\\baz\");\n-        t!(s: \"\\\\\\\\.\\\\foo\", with_filename, \"bar\", \"\\\\\\\\.\\\\foo\\\\bar\");\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename, \"..\", \"\\\\\\\\.\\\\foo\\\\..\");\n-\n-        t!(s: \"hi\\\\there.txt\", with_extension, \"exe\", \"hi\\\\there.exe\");\n-        t!(s: \"hi\\\\there.txt\", with_extension, \"\", \"hi\\\\there\");\n-        t!(s: \"hi\\\\there.txt\", with_extension, \".\", \"hi\\\\there..\");\n-        t!(s: \"hi\\\\there.txt\", with_extension, \"..\", \"hi\\\\there...\");\n-        t!(s: \"hi\\\\there\", with_extension, \"txt\", \"hi\\\\there.txt\");\n-        t!(s: \"hi\\\\there\", with_extension, \".\", \"hi\\\\there..\");\n-        t!(s: \"hi\\\\there\", with_extension, \"..\", \"hi\\\\there...\");\n-        t!(s: \"hi\\\\there.\", with_extension, \"txt\", \"hi\\\\there.txt\");\n-        t!(s: \"hi\\\\.foo\", with_extension, \"txt\", \"hi\\\\.foo.txt\");\n-        t!(s: \"hi\\\\there.txt\", with_extension, \".foo\", \"hi\\\\there..foo\");\n-        t!(s: \"\\\\\", with_extension, \"txt\", \"\\\\\");\n-        t!(s: \"\\\\\", with_extension, \".\", \"\\\\\");\n-        t!(s: \"\\\\\", with_extension, \"..\", \"\\\\\");\n-        t!(s: \".\", with_extension, \"txt\", \".\");\n-        // extension setter calls filename setter internally, no need for extended tests\n-    }\n-\n-    #[test]\n-    fn test_setters() {\n-        macro_rules! t {\n-            (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n-                {\n-                    let path = $path;\n-                    let arg = $arg;\n-                    let mut p1 = Path::new(path);\n-                    p1.$set(arg);\n-                    let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n-                }\n-            );\n-            (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n-                {\n-                    let path = $path;\n-                    let arg = $arg;\n-                    let mut p1 = Path::new(path);\n-                    p1.$set(arg);\n-                    let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n-                }\n-            )\n-        }\n-\n-        t!(v: &b\"a\\\\b\\\\c\"[..], set_filename, with_filename, &b\"d\"[..]);\n-        t!(v: &b\"\\\\\"[..], set_filename, with_filename, &b\"foo\"[..]);\n-        t!(s: \"a\\\\b\\\\c\", set_filename, with_filename, \"d\");\n-        t!(s: \"\\\\\", set_filename, with_filename, \"foo\");\n-        t!(s: \".\", set_filename, with_filename, \"foo\");\n-        t!(s: \"a\\\\b\", set_filename, with_filename, \"\");\n-        t!(s: \"a\", set_filename, with_filename, \"\");\n-\n-        t!(v: &b\"hi\\\\there.txt\"[..], set_extension, with_extension, &b\"exe\"[..]);\n-        t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"exe\");\n-        t!(s: \"hi\\\\there.\", set_extension, with_extension, \"txt\");\n-        t!(s: \"hi\\\\there\", set_extension, with_extension, \"txt\");\n-        t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"\");\n-        t!(s: \"hi\\\\there\", set_extension, with_extension, \"\");\n-        t!(s: \".\", set_extension, with_extension, \"txt\");\n-\n-        // with_ helpers use the setter internally, so the tests for the with_ helpers\n-        // will suffice. No need for the full set of prefix tests.\n-    }\n-\n-    #[test]\n-    fn test_getters() {\n-        macro_rules! t {\n-            (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n-                {\n-                    let path = $path;\n-                    assert_eq!(path.filename_str(), $filename);\n-                    assert_eq!(path.dirname_str(), $dirname);\n-                    assert_eq!(path.filestem_str(), $filestem);\n-                    assert_eq!(path.extension_str(), $ext);\n-                }\n-            );\n-            (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n-                {\n-                    let path = $path;\n-                    assert_eq!(path.filename(), $filename);\n-                    assert_eq!(path.dirname(), $dirname);\n-                    assert_eq!(path.filestem(), $filestem);\n-                    assert_eq!(path.extension(), $ext);\n-                }\n-            )\n-        }\n-\n-        t!(v: Path::new(&b\"a\\\\b\\\\c\"[..]), Some(&b\"c\"[..]), b\"a\\\\b\", Some(&b\"c\"[..]), None);\n-        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n-        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n-        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n-        t!(s: Path::new(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n-              Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: Path::new(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n-              Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: Path::new(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n-              Some(\".\"), Some(\"there\"));\n-\n-        // these are already tested in test_components, so no need for extended tests\n-    }\n-\n-    #[test]\n-    fn test_dir_path() {\n-        t!(s: Path::new(\"hi\\\\there\").dir_path(), \"hi\");\n-        t!(s: Path::new(\"hi\").dir_path(), \".\");\n-        t!(s: Path::new(\"\\\\hi\").dir_path(), \"\\\\\");\n-        t!(s: Path::new(\"\\\\\").dir_path(), \"\\\\\");\n-        t!(s: Path::new(\"..\").dir_path(), \"..\");\n-        t!(s: Path::new(\"..\\\\..\").dir_path(), \"..\\\\..\");\n-\n-        // dir_path is just dirname interpreted as a path.\n-        // No need for extended tests\n-    }\n-\n-    #[test]\n-    fn test_is_absolute() {\n-        macro_rules! t {\n-            ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let (abs, vol, cwd, rel) = ($abs, $vol, $cwd, $rel);\n-                    assert_eq!(path.is_absolute(), abs);\n-                    assert_eq!(is_vol_relative(&path), vol);\n-                    assert_eq!(is_cwd_relative(&path), cwd);\n-                    assert_eq!(path.is_relative(), rel);\n-                }\n-            )\n-        }\n-        t!(\"a\\\\b\\\\c\", false, false, false, true);\n-        t!(\"\\\\a\\\\b\\\\c\", false, true, false, false);\n-        t!(\"a\", false, false, false, true);\n-        t!(\"\\\\a\", false, true, false, false);\n-        t!(\".\", false, false, false, true);\n-        t!(\"\\\\\", false, true, false, false);\n-        t!(\"..\", false, false, false, true);\n-        t!(\"..\\\\..\", false, false, false, true);\n-        t!(\"C:a\\\\b.txt\", false, false, true, false);\n-        t!(\"C:\\\\a\\\\b.txt\", true, false, false, false);\n-        t!(\"\\\\\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false, false);\n-        t!(\"\\\\\\\\?\\\\a\\\\b\\\\c.txt\", true, false, false, false);\n-        t!(\"\\\\\\\\?\\\\C:\\\\a\\\\b.txt\", true, false, false, false);\n-        t!(\"\\\\\\\\?\\\\C:a\\\\b.txt\", true, false, false, false); // NB: not equivalent to C:a\\b.txt\n-        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false, false);\n-        t!(\"\\\\\\\\.\\\\a\\\\b\", true, false, false, false);\n-    }\n-\n-    #[test]\n-    fn test_is_ancestor_of() {\n-        macro_rules! t {\n-            (s: $path:expr, $dest:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let dest = Path::new($dest);\n-                    let exp = $exp;\n-                    let res = path.is_ancestor_of(&dest);\n-                    assert_eq!(res, exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", true);\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", false);\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", true);\n-        t!(s: \"\\\\a\\\\b\", \"\\\\a\\\\b\\\\c\", true);\n-        t!(s: \"\\\\a\\\\b\\\\c\\\\d\", \"\\\\a\\\\b\\\\c\", false);\n-        t!(s: \"\\\\a\\\\b\", \"a\\\\b\\\\c\", false);\n-        t!(s: \"a\\\\b\", \"\\\\a\\\\b\\\\c\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", false);\n-        t!(s: \"..\\\\a\\\\b\\\\c\", \"a\\\\b\\\\c\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"..\\\\a\\\\b\\\\c\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\cd\", false);\n-        t!(s: \"a\\\\b\\\\cd\", \"a\\\\b\\\\c\", false);\n-        t!(s: \"..\\\\a\\\\b\", \"..\\\\a\\\\b\\\\c\", true);\n-        t!(s: \".\", \"a\\\\b\", true);\n-        t!(s: \".\", \".\", true);\n-        t!(s: \"\\\\\", \"\\\\\", true);\n-        t!(s: \"\\\\\", \"\\\\a\\\\b\", true);\n-        t!(s: \"..\", \"a\\\\b\", true);\n-        t!(s: \"..\\\\..\", \"a\\\\b\", true);\n-        t!(s: \"foo\\\\bar\", \"foobar\", false);\n-        t!(s: \"foobar\", \"foo\\\\bar\", false);\n-\n-        t!(s: \"foo\", \"C:foo\", false);\n-        t!(s: \"C:foo\", \"foo\", false);\n-        t!(s: \"C:foo\", \"C:foo\\\\bar\", true);\n-        t!(s: \"C:foo\\\\bar\", \"C:foo\", false);\n-        t!(s: \"C:\\\\foo\", \"C:\\\\foo\\\\bar\", true);\n-        t!(s: \"C:\", \"C:\", true);\n-        t!(s: \"C:\", \"C:\\\\\", false);\n-        t!(s: \"C:\\\\\", \"C:\", false);\n-        t!(s: \"C:\\\\\", \"C:\\\\\", true);\n-        t!(s: \"C:\\\\foo\\\\bar\", \"C:\\\\foo\", false);\n-        t!(s: \"C:foo\\\\bar\", \"C:foo\", false);\n-        t!(s: \"C:\\\\foo\", \"\\\\foo\", false);\n-        t!(s: \"\\\\foo\", \"C:\\\\foo\", false);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\", true);\n-        t!(s: \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\foo\", true);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"\\\\\\\\server\\\\share\", false);\n-        t!(s: \"C:\\\\foo\", \"\\\\\\\\server\\\\share\\\\foo\", false);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"C:\\\\foo\", false);\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", true);\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", \"\\\\\\\\?\\\\foo\\\\bar\", false);\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"\\\\foo\\\\bar\\\\baz\", false);\n-        t!(s: \"\\\\foo\\\\bar\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\\\\baz\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\\\\baz\", \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\foo\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\", \"\\\\\\\\?\\\\C:\\\\\", false); // this is a weird one\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\c:\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\?\\\\c:\\\\a\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\D:\\\\a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\foo\", \"\\\\\\\\?\\\\foobar\", false);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\\\\c\", true);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\\\\\", true);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\\\\\", false);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\\\\d\", true);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\\\\d\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", false);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", true);\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\", true);\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\", \"\\\\\\\\.\\\\foo\\\\bar\", false);\n-        t!(s: \"\\\\\\\\.\\\\foo\", \"\\\\\\\\.\\\\foo\\\\bar\", true);\n-        t!(s: \"\\\\\\\\.\\\\foo\", \"\\\\\\\\.\\\\foobar\", false);\n-\n-        t!(s: \"\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\a\\\\b\", false);\n-        t!(s: \"\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\a\\\\b\", false);\n-        t!(s: \"Z:\\\\a\\\\b\", \"\\\\\\\\?\\\\z:\\\\a\\\\b\", true);\n-        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\D:\\\\a\\\\b\", false);\n-        t!(s: \"a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"a\\\\b\", false);\n-        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\a\\\\b\", true);\n-        t!(s: \"C:a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", false);\n-        t!(s: \"C:a\\\\b\", \"\\\\\\\\?\\\\C:a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:a\\\\b\", false);\n-        t!(s: \"\\\\\\\\?\\\\C:a\\\\b\", \"C:a\\\\b\", false);\n-        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\\", true);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\\", \"C:\\\\a\\\\b\", true);\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", true);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", true);\n-    }\n-\n-    #[test]\n-    fn test_ends_with_path() {\n-        macro_rules! t {\n-            (s: $path:expr, $child:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let child = Path::new($child);\n-                    assert_eq!(path.ends_with_path(&child), $exp);\n-                }\n-            );\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"c\", true);\n-        t!(s: \"a\\\\b\\\\c\", \"d\", false);\n-        t!(s: \"foo\\\\bar\\\\quux\", \"bar\", false);\n-        t!(s: \"foo\\\\bar\\\\quux\", \"barquux\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"b\\\\c\", true);\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n-        t!(s: \"a\\\\b\\\\c\", \"foo\\\\a\\\\b\\\\c\", false);\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", false); // child must be relative\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"foo\\\\a\\\\b\\\\c\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"\", false);\n-        t!(s: \"\", \"\", true);\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"d\\\\e\\\\f\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", false);\n-        t!(s: \"a\\\\b\\\\c\", \"b\", false);\n-        t!(s: \"C:\\\\a\\\\b\", \"b\", true);\n-        t!(s: \"C:\\\\a\\\\b\", \"C:b\", false);\n-        t!(s: \"C:\\\\a\\\\b\", \"C:a\\\\b\", false);\n-    }\n-\n-    #[test]\n-    fn test_path_relative_from() {\n-        macro_rules! t {\n-            (s: $path:expr, $other:expr, $exp:expr) => (\n-                {\n-                    assert_eq!(Path::new($path).path_relative_from(&Path::new($other))\n-                              .as_ref().and_then(|x| x.as_str()), $exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", Some(\"..\\\\c\"));\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", Some(\"..\"));\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", Some(\".\"));\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\\\\e\", Some(\"..\\\\..\"));\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\d\\\\e\", Some(\"..\\\\..\\\\b\\\\c\"));\n-        t!(s: \"a\\\\b\\\\c\", \"d\\\\e\\\\f\", Some(\"..\\\\..\\\\..\\\\a\\\\b\\\\c\"));\n-        t!(s: \"a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", None);\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"a\\\\b\\\\c\", Some(\"\\\\a\\\\b\\\\c\"));\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\\\\d\", Some(\"..\"));\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\\\\d\\\\e\", Some(\"..\\\\..\"));\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\d\\\\e\", Some(\"..\\\\..\\\\b\\\\c\"));\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\d\\\\e\\\\f\", Some(\"..\\\\..\\\\..\\\\a\\\\b\\\\c\"));\n-        t!(s: \"hi\\\\there.txt\", \"hi\\\\there\", Some(\"..\\\\there.txt\"));\n-        t!(s: \".\", \"a\", Some(\"..\"));\n-        t!(s: \".\", \"a\\\\b\", Some(\"..\\\\..\"));\n-        t!(s: \".\", \".\", Some(\".\"));\n-        t!(s: \"a\", \".\", Some(\"a\"));\n-        t!(s: \"a\\\\b\", \".\", Some(\"a\\\\b\"));\n-        t!(s: \"..\", \".\", Some(\"..\"));\n-        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", Some(\".\"));\n-        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", Some(\".\"));\n-        t!(s: \"\\\\\", \"\\\\\", Some(\".\"));\n-        t!(s: \"\\\\\", \".\", Some(\"\\\\\"));\n-        t!(s: \"..\\\\..\\\\a\", \"b\", Some(\"..\\\\..\\\\..\\\\a\"));\n-        t!(s: \"a\", \"..\\\\..\\\\b\", None);\n-        t!(s: \"..\\\\..\\\\a\", \"..\\\\..\\\\b\", Some(\"..\\\\a\"));\n-        t!(s: \"..\\\\..\\\\a\", \"..\\\\..\\\\a\\\\b\", Some(\"..\"));\n-        t!(s: \"..\\\\..\\\\a\\\\b\", \"..\\\\..\\\\a\", Some(\"b\"));\n-\n-        t!(s: \"C:a\\\\b\\\\c\", \"C:a\\\\b\", Some(\"c\"));\n-        t!(s: \"C:a\\\\b\", \"C:a\\\\b\\\\c\", Some(\"..\"));\n-        t!(s: \"C:\" ,\"C:a\\\\b\", Some(\"..\\\\..\"));\n-        t!(s: \"C:a\\\\b\", \"C:c\\\\d\", Some(\"..\\\\..\\\\a\\\\b\"));\n-        t!(s: \"C:a\\\\b\", \"D:c\\\\d\", Some(\"C:a\\\\b\"));\n-        t!(s: \"C:a\\\\b\", \"C:..\\\\c\", None);\n-        t!(s: \"C:..\\\\a\", \"C:b\\\\c\", Some(\"..\\\\..\\\\..\\\\a\"));\n-        t!(s: \"C:\\\\a\\\\b\\\\c\", \"C:\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\\\\b\\\\c\", Some(\"..\"));\n-        t!(s: \"C:\\\\\", \"C:\\\\a\\\\b\", Some(\"..\\\\..\"));\n-        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", Some(\"..\\\\..\\\\a\\\\b\"));\n-        t!(s: \"C:\\\\a\\\\b\", \"C:a\\\\b\", Some(\"C:\\\\a\\\\b\"));\n-        t!(s: \"C:a\\\\b\", \"C:\\\\a\\\\b\", None);\n-        t!(s: \"\\\\a\\\\b\", \"C:\\\\a\\\\b\", None);\n-        t!(s: \"\\\\a\\\\b\", \"C:a\\\\b\", None);\n-        t!(s: \"a\\\\b\", \"C:\\\\a\\\\b\", None);\n-        t!(s: \"a\\\\b\", \"C:a\\\\b\", None);\n-\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\a\\\\b\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"..\"));\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\\\\e\", \"\\\\\\\\a\\\\b\\\\c\\\\d\", Some(\"..\\\\e\"));\n-        t!(s: \"\\\\\\\\a\\\\c\\\\d\", \"\\\\\\\\a\\\\b\\\\d\", Some(\"\\\\\\\\a\\\\c\\\\d\"));\n-        t!(s: \"\\\\\\\\b\\\\c\\\\d\", \"\\\\\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\b\\\\c\\\\d\"));\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\d\\\\e\", Some(\"\\\\\\\\a\\\\b\\\\c\"));\n-        t!(s: \"\\\\d\\\\e\", \"\\\\\\\\a\\\\b\\\\c\", None);\n-        t!(s: \"d\\\\e\", \"\\\\\\\\a\\\\b\\\\c\", None);\n-        t!(s: \"C:\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"C:\\\\a\\\\b\\\\c\"));\n-        t!(s: \"C:\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"C:\\\\c\"));\n-\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"a\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\\\\c\", Some(\"..\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\b\", Some(\"\\\\\\\\?\\\\a\"));\n-\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", Some(\"..\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\b\", Some(\"..\\\\a\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\D:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\c:\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"C:\\\\a\\\\b\", Some(\"..\"));\n-        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n-        t!(s: \"C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", Some(\"..\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"D:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\"));\n-        t!(s: \"\\\\\\\\?\\\\c:\\\\a\\\\b\", \"C:\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:a\\\\b\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\", \"C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b/c\", \"C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\b/c\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\", \"C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\"));\n-        t!(s: \"C:a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", None);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b/c\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\b/c\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\.\\\\b\", \"\\\\\\\\?\\\\C:\\\\.\", Some(\"b\"));\n-        t!(s: \"C:\\\\b\", \"\\\\\\\\?\\\\C:\\\\.\", Some(\"..\\\\b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\.\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\.\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\.\\\\d\", Some(\"..\\\\..\\\\b\\\\c\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\..\\\\b\", \"\\\\\\\\?\\\\a\\\\..\", Some(\"b\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\..\", \"\\\\\\\\?\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\\\\..\"));\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\..\\\\b\", Some(\"..\\\\..\\\\b\\\\c\"));\n-\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", Some(\"..\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\", \"\\\\\\\\?\\\\UNC\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\\\\c\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\c\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"..\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\", \"\\\\\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\", \"\\\\\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\", \"\\\\\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\"));\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\", \"\\\\\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\"));\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"c\"));\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\a\\\\b\\\\c\"));\n-    }\n-\n-    #[test]\n-    fn test_str_components() {\n-        macro_rules! t {\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let comps = path.str_components().map(|x|x.unwrap())\n-                                .collect::<Vec<&str>>();\n-                    let exp: &[&str] = &$exp;\n-                    assert_eq!(comps, exp);\n-                    let comps = path.str_components().rev().map(|x|x.unwrap())\n-                                .collect::<Vec<&str>>();\n-                    let exp = exp.iter().rev().cloned().collect::<Vec<&str>>();\n-                    assert_eq!(comps, exp);\n-                }\n-            );\n-        }\n-\n-        t!(s: &b\"a\\\\b\\\\c\"[..], [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a\\\\b\\\\d\", [\"a\", \"b\", \"d\"]);\n-        t!(s: \"a\\\\b\\\\cd\", [\"a\", \"b\", \"cd\"]);\n-        t!(s: \"\\\\a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a\", [\"a\"]);\n-        t!(s: \"\\\\a\", [\"a\"]);\n-        t!(s: \"\\\\\", []);\n-        t!(s: \".\", [\".\"]);\n-        t!(s: \"..\", [\"..\"]);\n-        t!(s: \"..\\\\..\", [\"..\", \"..\"]);\n-        t!(s: \"..\\\\..\\\\foo\", [\"..\", \"..\", \"foo\"]);\n-        t!(s: \"C:foo\\\\bar\", [\"foo\", \"bar\"]);\n-        t!(s: \"C:foo\", [\"foo\"]);\n-        t!(s: \"C:\", []);\n-        t!(s: \"C:\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n-        t!(s: \"C:\\\\foo\", [\"foo\"]);\n-        t!(s: \"C:\\\\\", []);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n-        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", [\"foo\"]);\n-        t!(s: \"\\\\\\\\server\\\\share\", []);\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", [\"bar\", \"baz\"]);\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", [\"bar\"]);\n-        t!(s: \"\\\\\\\\?\\\\foo\", []);\n-        t!(s: \"\\\\\\\\?\\\\\", []);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\", [\"b\"]);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", [\"b\"]);\n-        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\\\\\\\\baz\", [\"bar\", \"\", \"baz\"]);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", [\"foo\"]);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\\", []);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\\", [\"foo\"]);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", [\"foo\"]);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", []);\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\", [\"bar\", \"baz\"]);\n-        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", [\"bar\"]);\n-        t!(s: \"\\\\\\\\.\\\\foo\", []);\n-    }\n-\n-    #[test]\n-    fn test_components_iter() {\n-        macro_rules! t {\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&[u8]] = &$exp;\n-                    assert_eq!(comps, exp);\n-                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n-                    let exp = exp.iter().rev().cloned().collect::<Vec<&[u8]>>();\n-                    assert_eq!(comps, exp);\n-                }\n-            )\n-        }\n-\n-        t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n-        t!(s: \".\", [b\".\"]);\n-        // since this is really a wrapper around str_components, those tests suffice\n-    }\n-\n-    #[test]\n-    fn test_make_non_verbatim() {\n-        macro_rules! t {\n-            ($path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let exp: Option<&str> = $exp;\n-                    let exp = exp.map(|s| Path::new(s));\n-                    assert_eq!(make_non_verbatim(&path), exp);\n-                }\n-            )\n-        }\n-\n-        t!(r\"\\a\\b\\c\", Some(r\"\\a\\b\\c\"));\n-        t!(r\"a\\b\\c\", Some(r\"a\\b\\c\"));\n-        t!(r\"C:\\a\\b\\c\", Some(r\"C:\\a\\b\\c\"));\n-        t!(r\"C:a\\b\\c\", Some(r\"C:a\\b\\c\"));\n-        t!(r\"\\\\server\\share\\foo\", Some(r\"\\\\server\\share\\foo\"));\n-        t!(r\"\\\\.\\foo\", None);\n-        t!(r\"\\\\?\\foo\", None);\n-        t!(r\"\\\\?\\C:\", None);\n-        t!(r\"\\\\?\\C:foo\", None);\n-        t!(r\"\\\\?\\C:\\\", Some(r\"C:\\\"));\n-        t!(r\"\\\\?\\C:\\foo\", Some(r\"C:\\foo\"));\n-        t!(r\"\\\\?\\C:\\foo\\bar\\baz\", Some(r\"C:\\foo\\bar\\baz\"));\n-        t!(r\"\\\\?\\C:\\foo\\.\\bar\\baz\", None);\n-        t!(r\"\\\\?\\C:\\foo\\bar\\..\\baz\", None);\n-        t!(r\"\\\\?\\C:\\foo\\bar\\..\", None);\n-        t!(r\"\\\\?\\UNC\\server\\share\\foo\", Some(r\"\\\\server\\share\\foo\"));\n-        t!(r\"\\\\?\\UNC\\server\\share\", Some(r\"\\\\server\\share\"));\n-        t!(r\"\\\\?\\UNC\\server\", None);\n-        t!(r\"\\\\?\\UNC\\server\\\", None);\n-    }\n-}"}, {"sha": "9800a2527772dbcccc5c9e76f53302670bdd557f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 105, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -224,27 +224,22 @@\n //! ```\n \n #![unstable(feature = \"rand\")]\n-#![deprecated(reason = \"use the crates.io `rand` library instead\",\n-              since = \"1.0.0-alpha\")]\n-#![allow(deprecated)]\n+\n+use prelude::v1::*;\n \n use cell::RefCell;\n-use clone::Clone;\n-use old_io::IoResult;\n-use iter::Iterator;\n+use io;\n use mem;\n use rc::Rc;\n-use result::Result::{Ok, Err};\n-use vec::Vec;\n \n #[cfg(target_pointer_width = \"32\")]\n use core_rand::IsaacRng as IsaacWordRng;\n #[cfg(target_pointer_width = \"64\")]\n use core_rand::Isaac64Rng as IsaacWordRng;\n \n-pub use core_rand::{Rand, Rng, SeedableRng, Open01, Closed01};\n-pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng, ChaChaRng};\n-pub use core_rand::{distributions, reseeding};\n+pub use core_rand::{Rand, Rng, SeedableRng};\n+pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n+pub use core_rand::reseeding;\n pub use rand::os::OsRng;\n \n pub mod os;\n@@ -269,7 +264,7 @@ impl StdRng {\n     ///\n     /// Reading the randomness from the OS may fail, and any error is\n     /// propagated via the `IoResult` return value.\n-    pub fn new() -> IoResult<StdRng> {\n+    pub fn new() -> io::Result<StdRng> {\n         OsRng::new().map(|mut r| StdRng { rng: r.gen() })\n     }\n }\n@@ -298,22 +293,6 @@ impl<'a> SeedableRng<&'a [usize]> for StdRng {\n     }\n }\n \n-/// Create a weak random number generator with a default algorithm and seed.\n-///\n-/// It returns the fastest `Rng` algorithm currently available in Rust without\n-/// consideration for cryptography or security. If you require a specifically\n-/// seeded `Rng` for consistency over time you should pick one algorithm and\n-/// create the `Rng` yourself.\n-///\n-/// This will read randomness from the operating system to seed the\n-/// generator.\n-pub fn weak_rng() -> XorShiftRng {\n-    match OsRng::new() {\n-        Ok(mut r) => r.gen(),\n-        Err(e) => panic!(\"weak_rng: failed to create seeded RNG: {:?}\", e)\n-    }\n-}\n-\n /// Controls how the thread-local RNG is reseeded.\n struct ThreadRngReseeder;\n \n@@ -376,83 +355,6 @@ impl Rng for ThreadRng {\n     }\n }\n \n-/// Generates a random value using the thread-local random number generator.\n-///\n-/// `random()` can generate various types of random things, and so may require\n-/// type hinting to generate the specific type you want.\n-///\n-/// This function uses the thread local random number generator. This means\n-/// that if you're calling `random()` in a loop, caching the generator can\n-/// increase performance. An example is shown below.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-///\n-/// let x: u8 = rand::random();\n-/// println!(\"{}\", 2 * x as u16);\n-///\n-/// let y = rand::random::<f64>();\n-/// println!(\"{}\", y);\n-///\n-/// if rand::random() { // generates a boolean\n-///     println!(\"Better lucky than good!\");\n-/// }\n-/// ```\n-///\n-/// Caching the thread local random number generator:\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::Rng;\n-///\n-/// let mut v = vec![1, 2, 3];\n-///\n-/// for x in v.iter_mut() {\n-///     *x = rand::random()\n-/// }\n-///\n-/// // would be faster as\n-///\n-/// let mut rng = rand::thread_rng();\n-///\n-/// for x in v.iter_mut() {\n-///     *x = rng.gen();\n-/// }\n-/// ```\n-#[inline]\n-pub fn random<T: Rand>() -> T {\n-    thread_rng().gen()\n-}\n-\n-/// Randomly sample up to `amount` elements from an iterator.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{thread_rng, sample};\n-///\n-/// let mut rng = thread_rng();\n-/// let sample = sample(&mut rng, 1..100, 5);\n-/// println!(\"{:?}\", sample);\n-/// ```\n-pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,\n-                                         mut iter: I,\n-                                         amount: usize) -> Vec<T> {\n-    let mut reservoir: Vec<T> = iter.by_ref().take(amount).collect();\n-    for (i, elem) in iter.enumerate() {\n-        let k = rng.gen_range(0, i + 1 + amount);\n-        if k < amount {\n-            reservoir[k] = elem;\n-        }\n-    }\n-    return reservoir;\n-}\n-\n #[cfg(test)]\n mod test {\n     use prelude::v1::*;"}, {"sha": "6c10759023770b3f36d861721f4431ae9921bccb", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -18,10 +18,10 @@ mod imp {\n     use prelude::v1::*;\n     use self::OsRngInner::*;\n \n+    use fs::File;\n+    use io;\n     use libc;\n     use mem;\n-    use old_io::{IoResult, File};\n-    use old_path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use sys::os::errno;\n@@ -147,12 +147,12 @@ mod imp {\n \n     impl OsRng {\n         /// Create a new `OsRng`.\n-        pub fn new() -> IoResult<OsRng> {\n+        pub fn new() -> io::Result<OsRng> {\n             if is_getrandom_available() {\n                 return Ok(OsRng { inner: OsGetrandomRng });\n             }\n \n-            let reader = try!(File::open(&Path::new(\"/dev/urandom\")));\n+            let reader = try!(File::open(\"/dev/urandom\"));\n             let reader_rng = ReaderRng::new(reader);\n \n             Ok(OsRng { inner: OsReaderRng(reader_rng) })\n@@ -186,7 +186,6 @@ mod imp {\n     use prelude::v1::*;\n \n     use io;\n-    use old_io::IoResult;\n     use mem;\n     use rand::Rng;\n     use libc::{c_int, size_t};\n@@ -202,7 +201,8 @@ mod imp {\n     ///\n     /// This does not block.\n     pub struct OsRng {\n-        // dummy field to ensure that this struct cannot be constructed outside of this module\n+        // dummy field to ensure that this struct cannot be constructed outside\n+        // of this module\n         _dummy: (),\n     }\n \n@@ -220,7 +220,7 @@ mod imp {\n \n     impl OsRng {\n         /// Create a new `OsRng`.\n-        pub fn new() -> IoResult<OsRng> {\n+        pub fn new() -> io::Result<OsRng> {\n             Ok(OsRng { _dummy: () })\n         }\n     }\n@@ -238,10 +238,12 @@ mod imp {\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n             let ret = unsafe {\n-                SecRandomCopyBytes(kSecRandomDefault, v.len() as size_t, v.as_mut_ptr())\n+                SecRandomCopyBytes(kSecRandomDefault, v.len() as size_t,\n+                                   v.as_mut_ptr())\n             };\n             if ret == -1 {\n-                panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+                panic!(\"couldn't generate random bytes: {}\",\n+                       io::Error::last_os_error());\n             }\n         }\n     }\n@@ -253,7 +255,6 @@ mod imp {\n \n     use io;\n     use mem;\n-    use old_io::{IoResult, IoError};\n     use rand::Rng;\n     use libc::types::os::arch::extra::{LONG_PTR};\n     use libc::{DWORD, BYTE, LPCSTR, BOOL};\n@@ -293,7 +294,7 @@ mod imp {\n \n     impl OsRng {\n         /// Create a new `OsRng`.\n-        pub fn new() -> IoResult<OsRng> {\n+        pub fn new() -> io::Result<OsRng> {\n             let mut hcp = 0;\n             let ret = unsafe {\n                 CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n@@ -302,7 +303,7 @@ mod imp {\n             };\n \n             if ret == 0 {\n-                Err(IoError::last_error())\n+                Err(io::Error::last_os_error())\n             } else {\n                 Ok(OsRng { hcryptprov: hcp })\n             }"}, {"sha": "3d0055b43c71267d07768a49ff9ee853574a756f", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -8,66 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A wrapper around any Reader to treat it as an RNG.\n+//! A wrapper around any Read to treat it as an RNG.\n \n-use old_io::Reader;\n+#![allow(dead_code)]\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n use rand::Rng;\n-use result::Result::{Ok, Err};\n \n-/// An RNG that reads random bytes straight from a `Reader`. This will\n+/// An RNG that reads random bytes straight from a `Read`. This will\n /// work best with an infinite reader, but this is not required.\n ///\n /// # Panics\n ///\n /// It will panic if it there is insufficient data to fulfill a request.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand, old_io)]\n-/// use std::rand::{reader, Rng};\n-/// use std::old_io::MemReader;\n-///\n-/// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n-/// println!(\"{:x}\", rng.gen::<usize>());\n-/// ```\n pub struct ReaderRng<R> {\n     reader: R\n }\n \n-impl<R: Reader> ReaderRng<R> {\n-    /// Create a new `ReaderRng` from a `Reader`.\n+impl<R: Read> ReaderRng<R> {\n+    /// Create a new `ReaderRng` from a `Read`.\n     pub fn new(r: R) -> ReaderRng<R> {\n         ReaderRng {\n             reader: r\n         }\n     }\n }\n \n-impl<R: Reader> Rng for ReaderRng<R> {\n+impl<R: Read> Rng for ReaderRng<R> {\n     fn next_u32(&mut self) -> u32 {\n         // This is designed for speed: reading a LE integer on a LE\n         // platform just involves blitting the bytes into the memory\n         // of the u32, similarly for BE on BE; avoiding byteswapping.\n-        if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u32().unwrap()\n-        } else {\n-            self.reader.read_be_u32().unwrap()\n-        }\n+        let mut bytes = [0; 4];\n+        self.fill_bytes(&mut bytes);\n+        unsafe { *(bytes.as_ptr() as *const u32) }\n     }\n     fn next_u64(&mut self) -> u64 {\n         // see above for explanation.\n-        if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u64().unwrap()\n-        } else {\n-            self.reader.read_be_u64().unwrap()\n-        }\n+        let mut bytes = [0; 8];\n+        self.fill_bytes(&mut bytes);\n+        unsafe { *(bytes.as_ptr() as *const u64) }\n     }\n-    fn fill_bytes(&mut self, v: &mut [u8]) {\n-        if v.len() == 0 { return }\n-        match self.reader.read_at_least(v.len(), v) {\n-            Ok(_) => {}\n-            Err(e) => panic!(\"ReaderRng.fill_bytes error: {:?}\", e)\n+    fn fill_bytes(&mut self, mut v: &mut [u8]) {\n+        while v.len() > 0 {\n+            let t = v;\n+            match self.reader.read(t) {\n+                Ok(0) => panic!(\"ReaderRng.fill_bytes: EOF reached\"),\n+                Ok(n) => v = t.split_at_mut(n).1,\n+                Err(e) => panic!(\"ReaderRng.fill_bytes: {}\", e),\n+            }\n         }\n     }\n }"}, {"sha": "95294b813ea195dbd7bafc7e180e5b98260e416c", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -10,24 +10,11 @@\n \n #![allow(missing_docs)]\n \n-use old_io::{self, IoError, IoResult};\n use prelude::v1::*;\n-use sys::{last_error, retry};\n-use ffi::CString;\n-#[allow(deprecated)] // Int\n-use num::Int;\n-\n-#[allow(deprecated)]\n-use old_path::BytesContainer;\n-\n-use collections;\n-\n-#[macro_use] pub mod helper_thread;\n \n pub mod backtrace;\n pub mod condvar;\n pub mod mutex;\n-pub mod net;\n pub mod net2;\n pub mod poison;\n pub mod remutex;\n@@ -40,72 +27,6 @@ pub mod wtf8;\n \n // common error constructors\n \n-#[allow(deprecated)]\n-pub fn eof() -> IoError {\n-    IoError {\n-        kind: old_io::EndOfFile,\n-        desc: \"end of file\",\n-        detail: None,\n-    }\n-}\n-\n-#[allow(deprecated)]\n-pub fn timeout(desc: &'static str) -> IoError {\n-    IoError {\n-        kind: old_io::TimedOut,\n-        desc: desc,\n-        detail: None,\n-    }\n-}\n-\n-#[allow(deprecated)]\n-pub fn short_write(n: usize, desc: &'static str) -> IoError {\n-    IoError {\n-        kind: if n == 0 { old_io::TimedOut } else { old_io::ShortWrite(n) },\n-        desc: desc,\n-        detail: None,\n-    }\n-}\n-\n-#[allow(deprecated)]\n-pub fn unimpl() -> IoError {\n-    IoError {\n-        kind: old_io::IoUnavailable,\n-        desc: \"operations not yet supported\",\n-        detail: None,\n-    }\n-}\n-\n-// unix has nonzero values as errors\n-#[allow(deprecated)]\n-pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n-    if ret != Int::zero() {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n-    F: FnMut(*const u8, usize) -> i64,\n-{\n-    let origamt = data.len();\n-    let mut data = data.as_ptr();\n-    let mut amt = origamt;\n-    while amt > 0 {\n-        let ret = retry(|| f(data, amt));\n-        if ret == 0 {\n-            break\n-        } else if ret != -1 {\n-            amt -= ret as usize;\n-            data = unsafe { data.offset(ret as isize) };\n-        } else {\n-            return ret;\n-        }\n-    }\n-    return (origamt - amt) as i64;\n-}\n-\n /// A trait for viewing representations from std types\n #[doc(hidden)]\n pub trait AsInner<Inner: ?Sized> {\n@@ -129,15 +50,3 @@ pub trait IntoInner<Inner> {\n pub trait FromInner<Inner> {\n     fn from_inner(inner: Inner) -> Self;\n }\n-\n-#[doc(hidden)]\n-#[allow(deprecated)]\n-pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n-    fn program(&self) -> &CString;\n-    fn args(&self) -> &[CString];\n-    fn env(&self) -> Option<&collections::HashMap<K, V>>;\n-    fn cwd(&self) -> Option<&CString>;\n-    fn uid(&self) -> Option<usize>;\n-    fn gid(&self) -> Option<usize>;\n-    fn detach(&self) -> bool;\n-}"}, {"sha": "0fbcf3aee6100f7df43db7610f275ccae9a97440", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 3, "deletions": 78, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -15,14 +15,12 @@\n //!\n //! # Example\n //!\n-//! ```rust,ignore\n-//! #![feature(globs)]\n-//!\n-//! use std::old_io::fs::File;\n+//! ```no_run\n+//! use std::fs::File;\n //! use std::os::unix::prelude::*;\n //!\n //! fn main() {\n-//!     let f = File::create(&Path::new(\"foo.txt\")).unwrap();\n+//!     let f = File::create(\"foo.txt\").unwrap();\n //!     let fd = f.as_raw_fd();\n //!\n //!     // use fd with native unix bindings\n@@ -34,7 +32,6 @@\n /// Unix-specific extensions to general I/O primitives\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod io {\n-    #[allow(deprecated)] use old_io;\n     use fs;\n     use libc;\n     use net;\n@@ -82,14 +79,6 @@ pub mod io {\n         unsafe fn from_raw_fd(fd: RawFd) -> Self;\n     }\n \n-    #[allow(deprecated)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for old_io::fs::File {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for fs::File {\n         fn as_raw_fd(&self) -> RawFd {\n@@ -103,70 +92,6 @@ pub mod io {\n         }\n     }\n \n-    #[allow(deprecated)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for old_io::pipe::PipeStream {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[allow(deprecated)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for old_io::net::pipe::UnixStream {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[allow(deprecated)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for old_io::net::pipe::UnixListener {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[allow(deprecated)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for old_io::net::pipe::UnixAcceptor {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow(deprecated)]\n-    impl AsRawFd for old_io::net::tcp::TcpStream {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow(deprecated)]\n-    impl AsRawFd for old_io::net::tcp::TcpListener {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow(deprecated)]\n-    impl AsRawFd for old_io::net::tcp::TcpAcceptor {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n-    #[allow(deprecated)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl AsRawFd for old_io::net::udp::UdpSocket {\n-        fn as_raw_fd(&self) -> RawFd {\n-            self.as_inner().fd()\n-        }\n-    }\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl AsRawFd for net::TcpStream {\n         fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }"}, {"sha": "6121105f10b956c4cefb6ce859e9753726ee85ad", "filename": "src/libstd/sys/unix/fs.rs", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,409 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Blocking posix-based file I/O\n-#![allow(deprecated)]\n-\n-#![allow(deprecated)] // this module itself is essentially deprecated\n-\n-use prelude::v1::*;\n-\n-use ffi::{CString, CStr};\n-use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n-use old_io::{IoResult, FileStat, SeekStyle};\n-use old_io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n-use old_io;\n-use old_path::{Path, GenericPath};\n-use libc::{self, c_int, c_void};\n-use mem;\n-use ptr;\n-use sys::retry;\n-use sys_common::{keep_going, eof, mkerr_libc};\n-\n-pub type fd_t = libc::c_int;\n-\n-pub struct FileDesc {\n-    /// The underlying C file descriptor.\n-    fd: fd_t,\n-\n-    /// Whether to close the file descriptor on drop.\n-    close_on_drop: bool,\n-}\n-\n-impl FileDesc {\n-    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { fd: fd, close_on_drop: close_on_drop }\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> IoResult<usize> {\n-        let ret = retry(|| unsafe {\n-            libc::read(self.fd(),\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as libc::size_t)\n-        });\n-        if ret == 0 {\n-            Err(eof())\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as usize)\n-        }\n-    }\n-    pub fn write(&self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::write(self.fd(), buf as *const libc::c_void,\n-                            len as libc::size_t) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn fd(&self) -> fd_t { self.fd }\n-\n-    pub fn seek(&self, pos: i64, whence: SeekStyle) -> IoResult<u64> {\n-        let whence = match whence {\n-            SeekSet => libc::SEEK_SET,\n-            SeekEnd => libc::SEEK_END,\n-            SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-\n-    pub fn tell(&self) -> IoResult<u64> {\n-        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-\n-    pub fn fsync(&self) -> IoResult<()> {\n-        mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n-    }\n-\n-    pub fn datasync(&self) -> IoResult<()> {\n-        return mkerr_libc(os_datasync(self.fd()));\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fdatasync(fd) })\n-        }\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"linux\")))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fsync(fd) })\n-        }\n-    }\n-\n-    pub fn truncate(&self, offset: i64) -> IoResult<()> {\n-        mkerr_libc(retry(|| unsafe {\n-            libc::ftruncate(self.fd(), offset as libc::off_t)\n-        }))\n-    }\n-\n-    pub fn fstat(&self) -> IoResult<FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::zeroed() };\n-        match unsafe { libc::fstat(self.fd(), &mut stat) } {\n-            0 => Ok(mkstat(&stat)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-\n-    /// Extract the actual filedescriptor without closing it.\n-    pub fn unwrap(self) -> fd_t {\n-        let fd = self.fd;\n-        unsafe { mem::forget(self) };\n-        fd\n-    }\n-}\n-\n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            let n = unsafe { libc::close(self.fd) };\n-            if n != 0 {\n-                println!(\"error {} when closing file descriptor {}\", n, self.fd);\n-            }\n-        }\n-    }\n-}\n-\n-fn cstr(path: &Path) -> IoResult<CString> {\n-    Ok(try!(CString::new(path.as_vec())))\n-}\n-\n-pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n-    let flags = match fm {\n-        Open => 0,\n-        Append => libc::O_APPEND,\n-        Truncate => libc::O_TRUNC,\n-    };\n-    // Opening with a write permission must silently create the file.\n-    let (flags, mode) = match fa {\n-        Read => (flags | libc::O_RDONLY, 0),\n-        Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                        libc::S_IRUSR | libc::S_IWUSR),\n-        ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                            libc::S_IRUSR | libc::S_IWUSR),\n-    };\n-\n-    let path = try!(cstr(path));\n-    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(FileDesc::new(fd, true)),\n-    }\n-}\n-\n-pub fn mkdir(p: &Path, mode: usize) -> IoResult<()> {\n-    let p = try!(cstr(p));\n-    mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n-}\n-\n-pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n-    use libc::{dirent_t};\n-    use libc::{opendir, readdir_r, closedir};\n-\n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n-        let root = Path::new(root);\n-\n-        dirs.into_iter().filter(|path| {\n-            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n-        }).map(|path| root.join(path)).collect()\n-    }\n-\n-    extern {\n-        fn rust_dirent_t_size() -> libc::c_int;\n-        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n-    }\n-\n-    let size = unsafe { rust_dirent_t_size() };\n-    let mut buf = Vec::<u8>::with_capacity(size as usize);\n-    let ptr = buf.as_mut_ptr() as *mut dirent_t;\n-\n-    let p = try!(CString::new(p.as_vec()));\n-    let dir_ptr = unsafe {opendir(p.as_ptr())};\n-\n-    if dir_ptr as usize != 0 {\n-        let mut paths = vec!();\n-        let mut entry_ptr = ptr::null_mut();\n-        while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n-            if entry_ptr.is_null() { break }\n-            paths.push(unsafe {\n-                Path::new(CStr::from_ptr(rust_list_dir_val(entry_ptr)).to_bytes())\n-            });\n-        }\n-        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n-        Ok(prune(&p, paths))\n-    } else {\n-        Err(super::last_error())\n-    }\n-}\n-\n-pub fn unlink(p: &Path) -> IoResult<()> {\n-    let p = try!(cstr(p));\n-    mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n-}\n-\n-pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n-    let old = try!(cstr(old));\n-    let new = try!(cstr(new));\n-    mkerr_libc(unsafe {\n-        libc::rename(old.as_ptr(), new.as_ptr())\n-    })\n-}\n-\n-pub fn chmod(p: &Path, mode: usize) -> IoResult<()> {\n-    let p = try!(cstr(p));\n-    mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n-    }))\n-}\n-\n-pub fn rmdir(p: &Path) -> IoResult<()> {\n-    let p = try!(cstr(p));\n-    mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n-}\n-\n-pub fn chown(p: &Path, uid: isize, gid: isize) -> IoResult<()> {\n-    let p = try!(cstr(p));\n-    mkerr_libc(retry(|| unsafe {\n-        libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n-    }))\n-}\n-\n-pub fn readlink(p: &Path) -> IoResult<Path> {\n-    let c_path = try!(cstr(p));\n-    let p = c_path.as_ptr();\n-    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n-    if len == -1 {\n-        len = 1024; // FIXME: read PATH_MAX from C ffi?\n-    }\n-    let mut buf: Vec<u8> = Vec::with_capacity(len as usize);\n-    match unsafe {\n-        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n-                       len as libc::size_t) as libc::c_int\n-    } {\n-        -1 => Err(super::last_error()),\n-        n => {\n-            assert!(n > 0);\n-            unsafe { buf.set_len(n as usize); }\n-            Ok(Path::new(buf))\n-        }\n-    }\n-}\n-\n-pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = try!(cstr(src));\n-    let dst = try!(cstr(dst));\n-    mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n-}\n-\n-pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = try!(cstr(src));\n-    let dst = try!(cstr(dst));\n-    mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n-}\n-\n-fn mkstat(stat: &libc::stat) -> FileStat {\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    fn ctime(stat: &libc::stat) -> u64 {\n-      mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64)\n-    }\n-\n-    fn atime(stat: &libc::stat) -> u64 {\n-      mktime(stat.st_atime as u64, stat.st_atime_nsec as u64)\n-    }\n-\n-    fn mtime(stat: &libc::stat) -> u64 {\n-      mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64)\n-    }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn flags(_stat: &libc::stat) -> u64 { 0 }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn gen(_stat: &libc::stat) -> u64 { 0 }\n-\n-    FileStat {\n-        size: stat.st_size as u64,\n-        kind: match (stat.st_mode as libc::mode_t) & libc::S_IFMT {\n-            libc::S_IFREG => old_io::FileType::RegularFile,\n-            libc::S_IFDIR => old_io::FileType::Directory,\n-            libc::S_IFIFO => old_io::FileType::NamedPipe,\n-            libc::S_IFBLK => old_io::FileType::BlockSpecial,\n-            libc::S_IFLNK => old_io::FileType::Symlink,\n-            _ => old_io::FileType::Unknown,\n-        },\n-        perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n-        created: ctime(stat),\n-        modified: mtime(stat),\n-        accessed: atime(stat),\n-        unstable: UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: flags(stat),\n-            gen: gen(stat),\n-        },\n-    }\n-}\n-\n-pub fn stat(p: &Path) -> IoResult<FileStat> {\n-    let p = try!(cstr(p));\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n-        0 => Ok(mkstat(&stat)),\n-        _ => Err(super::last_error()),\n-    }\n-}\n-\n-pub fn lstat(p: &Path) -> IoResult<FileStat> {\n-    let p = try!(cstr(p));\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n-        0 => Ok(mkstat(&stat)),\n-        _ => Err(super::last_error()),\n-    }\n-}\n-\n-pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    let p = try!(cstr(p));\n-    let buf = libc::utimbuf {\n-        actime: (atime / 1000) as libc::time_t,\n-        modtime: (mtime / 1000) as libc::time_t,\n-    };\n-    mkerr_libc(unsafe { libc::utime(p.as_ptr(), &buf) })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::FileDesc;\n-    use libc;\n-    use os;\n-    use prelude::v1::*;\n-\n-    #[cfg_attr(any(target_os = \"freebsd\",\n-                   target_os = \"openbsd\",\n-                   target_os = \"bitrig\"),\n-               ignore)]\n-    // under some system, pipe(2) will return a bidrectionnal pipe\n-    #[test]\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        let (mut reader, mut writer) = unsafe { ::sys::os::pipe().unwrap() };\n-\n-        writer.write(b\"test\").unwrap();\n-        let mut buf = [0; 4];\n-        match reader.read(&mut buf) {\n-            Ok(4) => {\n-                assert_eq!(buf[0], 't' as u8);\n-                assert_eq!(buf[1], 'e' as u8);\n-                assert_eq!(buf[2], 's' as u8);\n-                assert_eq!(buf[3], 't' as u8);\n-            }\n-            r => panic!(\"invalid read: {:?}\", r),\n-        }\n-\n-        assert!(writer.read(&mut buf).is_err());\n-        assert!(reader.write(&buf).is_err());\n-    }\n-}"}, {"sha": "a8a6219f3981deb2cdf952973448016be13bf301", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -13,124 +13,30 @@\n \n use prelude::v1::*;\n \n-use ffi::CStr;\n use io::{self, ErrorKind};\n use libc;\n use num::{Int, SignedInt};\n-use old_io::{self, IoError};\n-use str;\n-use sys_common::mkerr_libc;\n \n pub mod backtrace;\n pub mod c;\n pub mod condvar;\n pub mod ext;\n pub mod fd;\n-pub mod fs;  // support for std::old_io\n-pub mod fs2; // support for std::fs\n-pub mod helper_signal;\n+pub mod fs2;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n-pub mod pipe;\n pub mod pipe2;\n-pub mod process;\n pub mod process2;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod sync;\n-pub mod tcp;\n pub mod thread;\n pub mod thread_local;\n pub mod time;\n-pub mod timer;\n-pub mod tty;\n-pub mod udp;\n pub mod stdio;\n \n-pub mod addrinfo {\n-    pub use sys_common::net::get_host_addresses;\n-    pub use sys_common::net::get_address_name;\n-}\n-\n-// FIXME: move these to c module\n-pub type sock_t = self::fs::fd_t;\n-pub type wrlen = libc::size_t;\n-pub type msglen_t = libc::size_t;\n-pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }\n-\n-#[allow(deprecated)]\n-pub fn last_error() -> IoError {\n-    decode_error_detailed(os::errno() as i32)\n-}\n-\n-#[allow(deprecated)]\n-pub fn last_net_error() -> IoError {\n-    last_error()\n-}\n-\n-extern \"system\" {\n-    fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n-}\n-\n-#[allow(deprecated)]\n-pub fn last_gai_error(s: libc::c_int) -> IoError {\n-\n-    let mut err = decode_error(s);\n-    err.detail = Some(unsafe {\n-        let data = CStr::from_ptr(gai_strerror(s));\n-        str::from_utf8(data.to_bytes()).unwrap().to_string()\n-    });\n-    err\n-}\n-\n-/// Convert an `errno` value into a high-level error variant and description.\n-#[allow(deprecated)]\n-pub fn decode_error(errno: i32) -> IoError {\n-    // FIXME: this should probably be a bit more descriptive...\n-    let (kind, desc) = match errno {\n-        libc::EOF => (old_io::EndOfFile, \"end of file\"),\n-        libc::ECONNREFUSED => (old_io::ConnectionRefused, \"connection refused\"),\n-        libc::ECONNRESET => (old_io::ConnectionReset, \"connection reset\"),\n-        libc::EPERM | libc::EACCES =>\n-            (old_io::PermissionDenied, \"permission denied\"),\n-        libc::EPIPE => (old_io::BrokenPipe, \"broken pipe\"),\n-        libc::ENOTCONN => (old_io::NotConnected, \"not connected\"),\n-        libc::ECONNABORTED => (old_io::ConnectionAborted, \"connection aborted\"),\n-        libc::EADDRNOTAVAIL => (old_io::ConnectionRefused, \"address not available\"),\n-        libc::EADDRINUSE => (old_io::ConnectionRefused, \"address in use\"),\n-        libc::ENOENT => (old_io::FileNotFound, \"no such file or directory\"),\n-        libc::EISDIR => (old_io::InvalidInput, \"illegal operation on a directory\"),\n-        libc::ENOSYS => (old_io::IoUnavailable, \"function not implemented\"),\n-        libc::EINVAL => (old_io::InvalidInput, \"invalid argument\"),\n-        libc::ENOTTY =>\n-            (old_io::MismatchedFileTypeForOperation,\n-             \"file descriptor is not a TTY\"),\n-        libc::ETIMEDOUT => (old_io::TimedOut, \"operation timed out\"),\n-        libc::ECANCELED => (old_io::TimedOut, \"operation aborted\"),\n-        libc::consts::os::posix88::EEXIST =>\n-            (old_io::PathAlreadyExists, \"path already exists\"),\n-\n-        // These two constants can have the same value on some systems,\n-        // but different values on others, so we can't use a match\n-        // clause\n-        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-            (old_io::ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-        _ => (old_io::OtherIoError, \"unknown error\")\n-    };\n-    IoError { kind: kind, desc: desc, detail: None }\n-}\n-\n-#[allow(deprecated)]\n-pub fn decode_error_detailed(errno: i32) -> IoError {\n-    let mut err = decode_error(errno);\n-    err.detail = Some(os::error_string(errno));\n-    err\n-}\n-\n-#[allow(deprecated)]\n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {\n         libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n@@ -199,18 +105,3 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n         tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n     }\n }\n-\n-#[allow(deprecated)]\n-pub fn wouldblock() -> bool {\n-    let err = os::errno();\n-    err == libc::EWOULDBLOCK as i32 || err == libc::EAGAIN as i32\n-}\n-\n-#[allow(deprecated)]\n-pub fn set_nonblocking(fd: sock_t, nb: bool) {\n-    let set = nb as libc::c_int;\n-    mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) })).unwrap();\n-}\n-\n-// nothing needed on unix platforms\n-pub fn init_net() {}"}, {"sha": "1c6a13352fff971ed0ea52d1938128487226197b", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -22,14 +22,12 @@ use io;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n-#[allow(deprecated)] use old_io::{IoError, IoResult};\n use ptr;\n use path::{self, PathBuf};\n use slice;\n use str;\n use sys::c;\n use sys::fd;\n-use sys::fs::FileDesc;\n use vec;\n \n const BUF_BYTES: usize = 2048;\n@@ -448,16 +446,6 @@ pub fn unsetenv(n: &OsStr) {\n     }\n }\n \n-#[allow(deprecated)]\n-pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n-    let mut fds = [0; 2];\n-    if libc::pipe(fds.as_mut_ptr()) == 0 {\n-        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n-    } else {\n-        Err(IoError::last_error())\n-    }\n-}\n-\n pub fn page_size() -> usize {\n     unsafe {\n         libc::sysconf(libc::_SC_PAGESIZE) as usize"}, {"sha": "f0071295bf237316afdc4bed80434ea40e267d7f", "filename": "src/libstd/sys/unix/pipe.rs", "status": "removed", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,328 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-\n-use ffi::CString;\n-use libc;\n-use mem;\n-use sync::{Arc, Mutex};\n-use sync::atomic::{AtomicBool, Ordering};\n-use old_io::{self, IoResult, IoError};\n-\n-use sys::{self, timer, retry, c, set_nonblocking, wouldblock};\n-use sys::fs::{fd_t, FileDesc};\n-use sys_common::net::*;\n-use sys_common::net::SocketStatus::*;\n-use sys_common::{eof, mkerr_libc};\n-\n-fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n-    match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(fd)\n-    }\n-}\n-\n-fn addr_to_sockaddr_un(addr: &CString,\n-                       storage: &mut libc::sockaddr_storage)\n-                       -> IoResult<libc::socklen_t> {\n-    // the sun_path length is limited to SUN_LEN (with null)\n-    assert!(mem::size_of::<libc::sockaddr_storage>() >=\n-            mem::size_of::<libc::sockaddr_un>());\n-    let s = unsafe { &mut *(storage as *mut _ as *mut libc::sockaddr_un) };\n-\n-    let len = addr.as_bytes().len();\n-    if len > s.sun_path.len() - 1 {\n-        return Err(IoError {\n-            kind: old_io::InvalidInput,\n-            desc: \"invalid argument: path must be smaller than SUN_LEN\",\n-            detail: None,\n-        })\n-    }\n-    s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-    for (slot, value) in s.sun_path.iter_mut().zip(addr.as_bytes().iter()) {\n-        *slot = *value as libc::c_char;\n-    }\n-\n-    // count the null terminator\n-    let len = mem::size_of::<libc::sa_family_t>() + len + 1;\n-    return Ok(len as libc::socklen_t);\n-}\n-\n-struct Inner {\n-    fd: fd_t,\n-\n-    // Unused on Linux, where this lock is not necessary.\n-    #[allow(dead_code)]\n-    lock: Mutex<()>,\n-}\n-\n-impl Inner {\n-    fn new(fd: fd_t) -> Inner {\n-        Inner { fd: fd, lock: Mutex::new(()) }\n-    }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { let _ = libc::close(self.fd); } }\n-}\n-\n-fn connect(addr: &CString, ty: libc::c_int,\n-           timeout: Option<u64>) -> IoResult<Inner> {\n-    let mut storage = unsafe { mem::zeroed() };\n-    let len = try!(addr_to_sockaddr_un(addr, &mut storage));\n-    let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-    match timeout {\n-        None => {\n-            match retry(|| unsafe { libc::connect(inner.fd, addrp, len) }) {\n-                -1 => Err(super::last_error()),\n-                _  => Ok(inner)\n-            }\n-        }\n-        Some(timeout_ms) => {\n-            try!(connect_timeout(inner.fd, addrp, len, timeout_ms));\n-            Ok(inner)\n-        }\n-    }\n-}\n-\n-fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n-    let mut storage = unsafe { mem::zeroed() };\n-    let len = try!(addr_to_sockaddr_un(addr, &mut storage));\n-    let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &storage as *const _ as *const libc::sockaddr;\n-    match unsafe {\n-        libc::bind(inner.fd, addrp, len)\n-    } {\n-        -1 => Err(super::last_error()),\n-        _  => Ok(inner)\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Unix Streams\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UnixStream {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl UnixStream {\n-    pub fn connect(addr: &CString,\n-                   timeout: Option<u64>) -> IoResult<UnixStream> {\n-        connect(addr, libc::SOCK_STREAM, timeout).map(|inner| {\n-            UnixStream::new(Arc::new(inner))\n-        })\n-    }\n-\n-    fn new(inner: Arc<Inner>) -> UnixStream {\n-        UnixStream {\n-            inner: inner,\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-\n-    pub fn fd(&self) -> fd_t { self.inner.fd }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recv(fd,\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as libc::size_t,\n-                       flags) as libc::c_int\n-        };\n-        read(fd, self.read_deadline, dolock, doread)\n-    }\n-\n-    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::send(fd,\n-                       buf as *const _,\n-                       len as libc::size_t,\n-                       flags) as i64\n-        };\n-        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n-            Ok(_) => Ok(()),\n-            Err(e) => Err(e)\n-        }\n-    }\n-\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n-    }\n-\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-}\n-\n-impl Clone for UnixStream {\n-    fn clone(&self) -> UnixStream {\n-        UnixStream::new(self.inner.clone())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Unix Listener\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UnixListener {\n-    inner: Inner,\n-    path: CString,\n-}\n-\n-// we currently own the CString, so these impls should be safe\n-unsafe impl Send for UnixListener {}\n-unsafe impl Sync for UnixListener {}\n-\n-impl UnixListener {\n-    pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n-        bind(addr, libc::SOCK_STREAM).map(|fd| {\n-            UnixListener { inner: fd, path: addr.clone() }\n-        })\n-    }\n-\n-    pub fn fd(&self) -> fd_t { self.inner.fd }\n-\n-    pub fn listen(self) -> IoResult<UnixAcceptor> {\n-        match unsafe { libc::listen(self.fd(), 128) } {\n-            -1 => Err(super::last_error()),\n-\n-            _ => {\n-                let (reader, writer) = try!(unsafe { sys::os::pipe() });\n-                set_nonblocking(reader.fd(), true);\n-                set_nonblocking(writer.fd(), true);\n-                set_nonblocking(self.fd(), true);\n-                Ok(UnixAcceptor {\n-                    inner: Arc::new(AcceptorInner {\n-                        listener: self,\n-                        reader: reader,\n-                        writer: writer,\n-                        closed: AtomicBool::new(false),\n-                    }),\n-                    deadline: 0,\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UnixAcceptor {\n-    inner: Arc<AcceptorInner>,\n-    deadline: u64,\n-}\n-\n-struct AcceptorInner {\n-    listener: UnixListener,\n-    reader: FileDesc,\n-    writer: FileDesc,\n-    closed: AtomicBool,\n-}\n-\n-impl UnixAcceptor {\n-    pub fn fd(&self) -> fd_t { self.inner.listener.fd() }\n-\n-    pub fn accept(&mut self) -> IoResult<UnixStream> {\n-        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n-\n-        while !self.inner.closed.load(Ordering::SeqCst) {\n-            unsafe {\n-                let mut storage: libc::sockaddr_storage = mem::zeroed();\n-                let storagep = &mut storage as *mut libc::sockaddr_storage;\n-                let size = mem::size_of::<libc::sockaddr_storage>();\n-                let mut size = size as libc::socklen_t;\n-                match retry(|| {\n-                    libc::accept(self.fd(),\n-                                 storagep as *mut libc::sockaddr,\n-                                 &mut size as *mut libc::socklen_t) as libc::c_int\n-                }) {\n-                    -1 if wouldblock() => {}\n-                    -1 => return Err(super::last_error()),\n-                    fd => return Ok(UnixStream::new(Arc::new(Inner::new(fd)))),\n-                }\n-            }\n-            try!(await(&[self.fd(), self.inner.reader.fd()],\n-                       deadline, Readable));\n-        }\n-\n-        Err(eof())\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-\n-    pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, Ordering::SeqCst);\n-        let fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.write(&[0]) {\n-            Ok(..) => Ok(()),\n-            Err(..) if wouldblock() => Ok(()),\n-            Err(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl Clone for UnixAcceptor {\n-    fn clone(&self) -> UnixAcceptor {\n-        UnixAcceptor { inner: self.inner.clone(), deadline: 0 }\n-    }\n-}\n-\n-impl Drop for UnixListener {\n-    fn drop(&mut self) {\n-        // Unlink the path to the socket to ensure that it doesn't linger. We're\n-        // careful to unlink the path before we close the file descriptor to\n-        // prevent races where we unlink someone else's path.\n-        unsafe {\n-            let _ = libc::unlink(self.path.as_ptr());\n-        }\n-    }\n-}"}, {"sha": "8095325f83d1faf553220784814a6e2f84b102a7", "filename": "src/libstd/sys/unix/process.rs", "status": "removed", "additions": 0, "deletions": 627, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3", "patch": "@@ -1,627 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)] // this module itself is essentially deprecated\n-\n-use prelude::v1::*;\n-use self::Req::*;\n-\n-use collections::HashMap;\n-use ffi::CString;\n-use hash::Hash;\n-use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use old_io::{IoResult, EndOfFile};\n-use libc::{self, pid_t, c_void, c_int};\n-use io;\n-use mem;\n-use sys::os;\n-use old_path::BytesContainer;\n-use ptr;\n-use sync::mpsc::{channel, Sender, Receiver};\n-use sys::fs::FileDesc;\n-use sys::{self, retry, c, wouldblock, set_nonblocking, ms_to_timeval};\n-use sys_common::helper_thread::Helper;\n-use sys_common::{AsInner, mkerr_libc, timeout};\n-\n-pub use sys_common::ProcessConfig;\n-\n-helper_init! { static HELPER: Helper<Req> }\n-\n-/// The unique id of the process (this should never be negative).\n-pub struct Process {\n-    pub pid: pid_t\n-}\n-\n-enum Req {\n-    NewChild(libc::pid_t, Sender<ProcessExit>, u64),\n-}\n-\n-const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n-\n-impl Process {\n-    pub fn id(&self) -> pid_t {\n-        self.pid\n-    }\n-\n-    pub unsafe fn kill(&self, signal: isize) -> IoResult<()> {\n-        Process::killpid(self.pid, signal)\n-    }\n-\n-    pub unsafe fn killpid(pid: pid_t, signal: isize) -> IoResult<()> {\n-        let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-        mkerr_libc(r)\n-    }\n-\n-    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n-                              out_fd: Option<P>, err_fd: Option<P>)\n-                              -> IoResult<Process>\n-        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash, V: BytesContainer\n-    {\n-        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-\n-        mod rustrt {\n-            extern {\n-                pub fn rust_unset_sigprocmask();\n-            }\n-        }\n-\n-        unsafe fn set_cloexec(fd: c_int) {\n-            let ret = c::ioctl(fd, c::FIOCLEX);\n-            assert_eq!(ret, 0);\n-        }\n-\n-        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n-        }\n-        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::funcs::bsd44::getdtablesize()\n-        }\n-\n-        let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        // temporary until unboxed closures land\n-        let cfg = unsafe {\n-            mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n-        };\n-\n-        with_envp(cfg.env(), move|envp: *const c_void| {\n-            with_argv(cfg.program(), cfg.args(), move|argv: *const *const libc::c_char| unsafe {\n-                let (input, mut output) = try!(sys::os::pipe());\n-\n-                // We may use this in the child, so perform allocations before the\n-                // fork\n-                let devnull = b\"/dev/null\\0\";\n-\n-                set_cloexec(output.fd());\n-\n-                let pid = fork();\n-                if pid < 0 {\n-                    return Err(super::last_error())\n-                } else if pid > 0 {\n-                    #[inline]\n-                    fn combine(arr: &[u8]) -> i32 {\n-                        let a = arr[0] as u32;\n-                        let b = arr[1] as u32;\n-                        let c = arr[2] as u32;\n-                        let d = arr[3] as u32;\n-\n-                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-                    }\n-\n-                    let p = Process{ pid: pid };\n-                    drop(output);\n-                    let mut bytes = [0; 8];\n-                    return match input.read(&mut bytes) {\n-                        Ok(8) => {\n-                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                                \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                            let errno = combine(&bytes[0.. 4]);\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            Err(super::decode_error(errno))\n-                        }\n-                        Err(ref e) if e.kind == EndOfFile => Ok(p),\n-                        Err(e) => {\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                        },\n-                        Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"short read on the CLOEXEC pipe\")\n-                        }\n-                    };\n-                }\n-\n-                // And at this point we've reached a special time in the life of the\n-                // child. The child must now be considered hamstrung and unable to\n-                // do anything other than syscalls really. Consider the following\n-                // scenario:\n-                //\n-                //      1. Thread A of process 1 grabs the malloc() mutex\n-                //      2. Thread B of process 1 forks(), creating thread C\n-                //      3. Thread C of process 2 then attempts to malloc()\n-                //      4. The memory of process 2 is the same as the memory of\n-                //         process 1, so the mutex is locked.\n-                //\n-                // This situation looks a lot like deadlock, right? It turns out\n-                // that this is what pthread_atfork() takes care of, which is\n-                // presumably implemented across platforms. The first thing that\n-                // threads to *before* forking is to do things like grab the malloc\n-                // mutex, and then after the fork they unlock it.\n-                //\n-                // Despite this information, libnative's spawn has been witnessed to\n-                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-                // all collected backtraces point at malloc/free traffic in the\n-                // child spawned process.\n-                //\n-                // For this reason, the block of code below should contain 0\n-                // invocations of either malloc of free (or their related friends).\n-                //\n-                // As an example of not having malloc/free traffic, we don't close\n-                // this file descriptor by dropping the FileDesc (which contains an\n-                // allocation). Instead we just close it manually. This will never\n-                // have the drop glue anyway because this code never returns (the\n-                // child will either exec() or invoke libc::exit)\n-                let _ = libc::close(input.fd());\n-\n-                fn fail(output: &mut FileDesc) -> ! {\n-                    let errno = sys::os::errno() as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(output.write(&bytes).is_ok());\n-                    unsafe { libc::_exit(1) }\n-                }\n-\n-                rustrt::rust_unset_sigprocmask();\n-\n-                // If a stdio file descriptor is set to be ignored (via a -1 file\n-                // descriptor), then we don't actually close it, but rather open\n-                // up /dev/null into that file descriptor. Otherwise, the first file\n-                // descriptor opened up in the child would be numbered as one of the\n-                // stdio file descriptors, which is likely to wreak havoc.\n-                let setup = |src: Option<P>, dst: c_int| {\n-                    let src = match src {\n-                        None => {\n-                            let flags = if dst == libc::STDIN_FILENO {\n-                                libc::O_RDONLY\n-                            } else {\n-                                libc::O_RDWR\n-                            };\n-                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n-                        }\n-                        Some(obj) => {\n-                            let fd = obj.as_inner().fd();\n-                            // Leak the memory and the file descriptor. We're in the\n-                            // child now an all our resources are going to be\n-                            // cleaned up very soon\n-                            mem::forget(obj);\n-                            fd\n-                        }\n-                    };\n-                    src != -1 && retry(|| dup2(src, dst)) != -1\n-                };\n-\n-                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n-\n-                // close all other fds\n-                for fd in (3..getdtablesize()).rev() {\n-                    if fd != output.fd() {\n-                        let _ = close(fd as c_int);\n-                    }\n-                }\n-\n-                match cfg.gid() {\n-                    Some(u) => {\n-                        if libc::setgid(u as libc::gid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                match cfg.uid() {\n-                    Some(u) => {\n-                        // When dropping privileges from root, the `setgroups` call\n-                        // will remove any extraneous groups. If we don't call this,\n-                        // then even though our uid has dropped, we may still have\n-                        // groups that enable us to do super-user things. This will\n-                        // fail if we aren't root, so don't bother checking the\n-                        // return value, this is just done as an optimistic\n-                        // privilege dropping function.\n-                        extern {\n-                            fn setgroups(ngroups: libc::c_int,\n-                                         ptr: *const libc::c_void) -> libc::c_int;\n-                        }\n-                        let _ = setgroups(0, ptr::null());\n-\n-                        if libc::setuid(u as libc::uid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                if cfg.detach() {\n-                    // Don't check the error of setsid because it fails if we're the\n-                    // process leader already. We just forked so it shouldn't return\n-                    // error, but ignore it anyway.\n-                    let _ = libc::setsid();\n-                }\n-                if !dirp.is_null() && chdir(dirp) == -1 {\n-                    fail(&mut output);\n-                }\n-                if !envp.is_null() {\n-                    *sys::os::environ() = envp as *const _;\n-                }\n-                let _ = execvp(*argv, argv as *mut _);\n-                fail(&mut output);\n-            })\n-        })\n-    }\n-\n-    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n-        use cmp;\n-        use sync::mpsc::TryRecvError;\n-\n-        static mut WRITE_FD: libc::c_int = 0;\n-\n-        let mut status = 0 as c_int;\n-        if deadline == 0 {\n-            return match retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) }) {\n-                -1 => panic!(\"unknown waitpid error: {:?}\", super::last_error()),\n-                _ => Ok(translate_status(status)),\n-            }\n-        }\n-\n-        // On unix, wait() and its friends have no timeout parameters, so there is\n-        // no way to time out a thread in wait(). From some googling and some\n-        // thinking, it appears that there are a few ways to handle timeouts in\n-        // wait(), but the only real reasonable one for a multi-threaded program is\n-        // to listen for SIGCHLD.\n-        //\n-        // With this in mind, the waiting mechanism with a timeout barely uses\n-        // waitpid() at all. There are a few times that waitpid() is invoked with\n-        // WNOHANG, but otherwise all the necessary blocking is done by waiting for\n-        // a SIGCHLD to arrive (and that blocking has a timeout). Note, however,\n-        // that waitpid() is still used to actually reap the child.\n-        //\n-        // Signal handling is super tricky in general, and this is no exception. Due\n-        // to the async nature of SIGCHLD, we use the self-pipe trick to transmit\n-        // data out of the signal handler to the rest of the application. The first\n-        // idea would be to have each thread waiting with a timeout to read this\n-        // output file descriptor, but a write() is akin to a signal(), not a\n-        // broadcast(), so it would only wake up one thread, and possibly the wrong\n-        // thread. Hence a helper thread is used.\n-        //\n-        // The helper thread here is responsible for farming requests for a\n-        // waitpid() with a timeout, and then processing all of the wait requests.\n-        // By guaranteeing that only this helper thread is reading half of the\n-        // self-pipe, we're sure that we'll never lose a SIGCHLD. This helper thread\n-        // is also responsible for select() to wait for incoming messages or\n-        // incoming SIGCHLD messages, along with passing an appropriate timeout to\n-        // select() to wake things up as necessary.\n-        //\n-        // The ordering of the following statements is also very purposeful. First,\n-        // we must be guaranteed that the helper thread is booted and available to\n-        // receive SIGCHLD signals, and then we must also ensure that we do a\n-        // nonblocking waitpid() at least once before we go ask the sigchld helper.\n-        // This prevents the race where the child exits, we boot the helper, and\n-        // then we ask for the child's exit status (never seeing a sigchld).\n-        //\n-        // The actual communication between the helper thread and this thread is\n-        // quite simple, just a channel moving data around.\n-\n-        HELPER.boot(register_sigchld, waitpid_helper);\n-\n-        match self.try_wait() {\n-            Some(ret) => return Ok(ret),\n-            None => {}\n-        }\n-\n-        let (tx, rx) = channel();\n-        HELPER.send(NewChild(self.pid, tx, deadline));\n-        return match rx.recv() {\n-            Ok(e) => Ok(e),\n-            Err(..) => Err(timeout(\"wait timed out\")),\n-        };\n-\n-        // Register a new SIGCHLD handler, returning the reading half of the\n-        // self-pipe plus the old handler registered (return value of sigaction).\n-        //\n-        // Be sure to set up the self-pipe first because as soon as we register a\n-        // handler we're going to start receiving signals.\n-        fn register_sigchld() -> (libc::c_int, c::sigaction) {\n-            unsafe {\n-                let mut pipes = [0; 2];\n-                assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n-                set_nonblocking(pipes[0], true);\n-                set_nonblocking(pipes[1], true);\n-                WRITE_FD = pipes[1];\n-\n-                let mut old: c::sigaction = mem::zeroed();\n-                let mut new: c::sigaction = mem::zeroed();\n-                new.sa_handler = sigchld_handler;\n-                new.sa_flags = c::SA_NOCLDSTOP;\n-                assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n-                (pipes[0], old)\n-            }\n-        }\n-\n-        // Helper thread for processing SIGCHLD messages\n-        fn waitpid_helper(input: libc::c_int,\n-                          messages: Receiver<Req>,\n-                          (read_fd, old): (libc::c_int, c::sigaction)) {\n-            set_nonblocking(input, true);\n-            let mut set: c::fd_set = unsafe { mem::zeroed() };\n-            let mut tv: libc::timeval;\n-            let mut active = Vec::<(libc::pid_t, Sender<ProcessExit>, u64)>::new();\n-            let max = cmp::max(input, read_fd) + 1;\n-\n-            'outer: loop {\n-                // Figure out the timeout of our syscall-to-happen. If we're waiting\n-                // for some processes, then they'll have a timeout, otherwise we\n-                // wait indefinitely for a message to arrive.\n-                //\n-                // FIXME: sure would be nice to not have to scan the entire array\n-                let min = active.iter().map(|a| a.2).enumerate().min_by(|p| {\n-                    p.1\n-                });\n-                let (p, idx) = match min {\n-                    Some((idx, deadline)) => {\n-                        let now = sys::timer::now();\n-                        let ms = if now < deadline {deadline - now} else {0};\n-                        tv = ms_to_timeval(ms);\n-                        (&mut tv as *mut _, idx)\n-                    }\n-                    None => (ptr::null_mut(), -1),\n-                };\n-\n-                // Wait for something to happen\n-                c::fd_set(&mut set, input);\n-                c::fd_set(&mut set, read_fd);\n-                match unsafe { c::select(max, &mut set, ptr::null_mut(),\n-                                         ptr::null_mut(), p) } {\n-                    // interrupted, retry\n-                    -1 if os::errno() == libc::EINTR as i32 => continue,\n-\n-                    // We read something, break out and process\n-                    1 | 2 => {}\n-\n-                    // Timeout, the pending request is removed\n-                    0 => {\n-                        drop(active.remove(idx));\n-                        continue\n-                    }\n-\n-                    n => panic!(\"error in select {:?} ({:?})\", os::errno(), n),\n-                }\n-\n-                // Process any pending messages\n-                if drain(input) {\n-                    loop {\n-                        match messages.try_recv() {\n-                            Ok(NewChild(pid, tx, deadline)) => {\n-                                active.push((pid, tx, deadline));\n-                            }\n-                            // Once we've been disconnected it means the main\n-                            // thread is exiting (at_exit has run). We could\n-                            // still have active waiter for other threads, so\n-                            // we're just going to drop them all on the floor.\n-                            // This means that they won't receive a \"you're\n-                            // done\" message in which case they'll be considered\n-                            // as timed out, but more generally errors will\n-                            // start propagating.\n-                            Err(TryRecvError::Disconnected) => {\n-                                break 'outer;\n-                            }\n-                            Err(TryRecvError::Empty) => break,\n-                        }\n-                    }\n-                }\n-\n-                // If a child exited (somehow received SIGCHLD), then poll all\n-                // children to see if any of them exited.\n-                //\n-                // We also attempt to be responsible netizens when dealing with\n-                // SIGCHLD by invoking any previous SIGCHLD handler instead of just\n-                // ignoring any previous SIGCHLD handler. Note that we don't provide\n-                // a 1:1 mapping of our handler invocations to the previous handler\n-                // invocations because we drain the `read_fd` entirely. This is\n-                // probably OK because the kernel is already allowed to coalesce\n-                // simultaneous signals, we're just doing some extra coalescing.\n-                //\n-                // Another point of note is that this likely runs the signal handler\n-                // on a different thread than the one that received the signal. I\n-                // *think* this is ok at this time.\n-                //\n-                // The main reason for doing this is to allow stdtest to run native\n-                // tests as well. Both libgreen and libnative are running around\n-                // with process timeouts, but libgreen should get there first\n-                // (currently libuv doesn't handle old signal handlers).\n-                if drain(read_fd) {\n-                    let i: usize = unsafe { mem::transmute(old.sa_handler) };\n-                    if i != 0 {\n-                        assert!(old.sa_flags & c::SA_SIGINFO == 0);\n-                        (old.sa_handler)(c::SIGCHLD);\n-                    }\n-\n-                    // FIXME: sure would be nice to not have to scan the entire\n-                    //        array...\n-                    active.retain(|&(pid, ref tx, _)| {\n-                        let pr = Process { pid: pid };\n-                        match pr.try_wait() {\n-                            Some(msg) => { tx.send(msg).unwrap(); false }\n-                            None => true,\n-                        }\n-                    });\n-                }\n-            }\n-\n-            // Once this helper thread is done, we re-register the old sigchld\n-            // handler and close our intermediate file descriptors.\n-            unsafe {\n-                assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::null_mut()), 0);\n-                let _ = libc::close(read_fd);\n-                let _ = libc::close(WRITE_FD);\n-                WRITE_FD = -1;\n-            }\n-        }\n-\n-        // Drain all pending data from the file descriptor, returning if any data\n-        // could be drained. This requires that the file descriptor is in\n-        // nonblocking mode.\n-        fn drain(fd: libc::c_int) -> bool {\n-            let mut ret = false;\n-            loop {\n-                let mut buf = [0u8; 1];\n-                match unsafe {\n-                    libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void,\n-                               buf.len() as libc::size_t)\n-                } {\n-                    n if n > 0 => { ret = true; }\n-                    0 => return true,\n-                    -1 if wouldblock() => return ret,\n-                    n => panic!(\"bad read {} ({})\",\n-                                io::Error::last_os_error(), n),\n-                }\n-            }\n-        }\n-\n-        // Signal handler for SIGCHLD signals, must be async-signal-safe!\n-        //\n-        // This function will write to the writing half of the \"self pipe\" to wake\n-        // up the helper thread if it's waiting. Note that this write must be\n-        // nonblocking because if it blocks and the reader is the thread we\n-        // interrupted, then we'll deadlock.\n-        //\n-        // When writing, if the write returns EWOULDBLOCK then we choose to ignore\n-        // it. At that point we're guaranteed that there's something in the pipe\n-        // which will wake up the other end at some point, so we just allow this\n-        // signal to be coalesced with the pending signals on the pipe.\n-        extern fn sigchld_handler(_signum: libc::c_int) {\n-            let msg = 1;\n-            match unsafe {\n-                libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n-            } {\n-                1 => {}\n-                -1 if wouldblock() => {} // see above comments\n-                n => panic!(\"bad error on write fd: {:?} {:?}\", n, os::errno()),\n-            }\n-        }\n-    }\n-\n-    pub fn try_wait(&self) -> Option<ProcessExit> {\n-        let mut status = 0 as c_int;\n-        match retry(|| unsafe {\n-            c::waitpid(self.pid, &mut status, c::WNOHANG)\n-        }) {\n-            n if n == self.pid => Some(translate_status(status)),\n-            0 => None,\n-            n => panic!(\"unknown waitpid error `{:?}`: {:?}\", n,\n-                       super::last_error()),\n-        }\n-    }\n-}\n-\n-fn with_argv<T,F>(prog: &CString, args: &[CString],\n-                  cb: F)\n-                  -> T\n-    where F : FnOnce(*const *const libc::c_char) -> T\n-{\n-    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n-\n-    // Convert the CStrings into an array of pointers. Note: the\n-    // lifetime of the various CStrings involved is guaranteed to be\n-    // larger than the lifetime of our invocation of cb, but this is\n-    // technically unsafe as the callback could leak these pointers\n-    // out of our scope.\n-    ptrs.push(prog.as_ptr());\n-    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n-\n-    // Add a terminating null pointer (required by libc).\n-    ptrs.push(ptr::null());\n-\n-    cb(ptrs.as_ptr())\n-}\n-\n-fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n-                      cb: F)\n-                      -> T\n-    where F : FnOnce(*const c_void) -> T,\n-          K : BytesContainer + Eq + Hash,\n-          V : BytesContainer\n-{\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\0\" strings. Since we must create\n-    // these strings locally, yet expose a raw pointer to them, we\n-    // create a temporary vector to own the CStrings that outlives the\n-    // call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.0.container_as_bytes());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.1.container_as_bytes());\n-                kv.push(0); // terminating null\n-                tmps.push(kv);\n-            }\n-\n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n-\n-            cb(ptrs.as_ptr() as *const c_void)\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-\n-fn translate_status(status: c_int) -> ProcessExit {\n-    #![allow(non_snake_case)]\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    mod imp {\n-        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n-        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n-        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\"))]\n-    mod imp {\n-        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n-        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n-        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n-    }\n-\n-    if imp::WIFEXITED(status) {\n-        ExitStatus(imp::WEXITSTATUS(status) as isize)\n-    } else {\n-        ExitSignal(imp::WTERMSIG(status) as isize)\n-    }\n-}"}, {"sha": "caa7b4eb29c7bb558ac65a50d6ec1433a81f6a14", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b", "patch": "@@ -328,8 +328,8 @@ impl Process {\n         }) {\n             n if n == self.pid => Some(translate_status(status)),\n             0 => None,\n-            n => panic!(\"unknown waitpid error `{:?}`: {:?}\", n,\n-                       super::last_error()),\n+            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n+                       io::Error::last_os_error()),\n         }\n     }\n }"}, {"sha": "a9f2198208bc31cbd825ce36302f2c9c4fa0619f", "filename": "src/libstd/sys/unix/tcp.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "9309147b15c44f6bd14ae38417bf04ef010fcda2", "filename": "src/libstd/sys/unix/timer.rs", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "2f6fd713bfba50c01d7049e83e84ab5a48d873fd", "filename": "src/libstd/sys/unix/tty.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/unix/udp.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Funix%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fudp.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "ea95cc5bfd5b9aa930aced9fde634ce62753059f", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b"}, {"sha": "0bbb1a9e92752c09c39f81adbcb6b53335b23baf", "filename": "src/libstd/sys/windows/fs.rs", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "a9fb2c682276715b3eadb2ad52057da118415082", "filename": "src/libstd/sys/windows/helper_signal.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "1171c6c068b12077b2ad92328cf035149266a189", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 174, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b"}, {"sha": "ebf5532b0cadb1837e5aa58ed1c9660ed5c081ea", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b"}, {"sha": "064c003bd15a909b90392f5ce531e5330a6085d7", "filename": "src/libstd/sys/windows/pipe.rs", "status": "removed", "additions": 0, "deletions": 775, "changes": 775, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "b10042090ddc8d634a89d875cb10334ea07cf52e", "filename": "src/libstd/sys/windows/process.rs", "status": "removed", "additions": 0, "deletions": 518, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "41e97dc8475027741473f7f5458ff89661bdfea2", "filename": "src/libstd/sys/windows/tcp.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "8856cc26b2e9060b8eaa3dbff863e5e70a6bba5f", "filename": "src/libstd/sys/windows/timer.rs", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "791c7532bd007148b282967fb797a45828b29c34", "filename": "src/libstd/sys/windows/tty.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/windows/udp.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabf0c6371d3b193664f58746fa27c1835a010f3/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs?ref=dabf0c6371d3b193664f58746fa27c1835a010f3"}, {"sha": "3f36d0e8eda0f8ebd8246b3b45e246102cd1b12b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b"}, {"sha": "2bb74944ce91abf0b085cd932ceb4439e985ae62", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4e77d4b543632ca4df8fdd7092850dffc3954b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bf4e77d4b543632ca4df8fdd7092850dffc3954b"}]}