{"sha": "a549da7e3ea66fd336de331c7c8d62b186051521", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NDlkYTdlM2VhNjZmZDMzNmRlMzMxYzdjOGQ2MmIxODYwNTE1MjE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:05:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:22:06Z"}, "message": "Move SearchScope", "tree": {"sha": "79acdd59071106abffbd1010042a2a12292fe7f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79acdd59071106abffbd1010042a2a12292fe7f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a549da7e3ea66fd336de331c7c8d62b186051521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a549da7e3ea66fd336de331c7c8d62b186051521", "html_url": "https://github.com/rust-lang/rust/commit/a549da7e3ea66fd336de331c7c8d62b186051521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a549da7e3ea66fd336de331c7c8d62b186051521/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92", "html_url": "https://github.com/rust-lang/rust/commit/66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92"}], "stats": {"total": 294, "additions": 149, "deletions": 145}, "files": [{"sha": "6fd46c52d807b5ec66d63f00eb57ba3dfc605141", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=a549da7e3ea66fd336de331c7c8d62b186051521", "patch": "@@ -31,7 +31,7 @@ use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeI\n \n pub(crate) use self::rename::rename;\n \n-pub use self::search_scope::SearchScope;\n+pub use ra_ide_db::search::SearchScope;\n \n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=a549da7e3ea66fd336de331c7c8d62b186051521", "patch": "@@ -1,145 +1 @@\n-//! Generally, `search_scope` returns files that might contain references for the element.\n-//! For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n-//! In some cases, the location of the references is known to within a `TextRange`,\n-//! e.g. for things like local variables.\n-use std::mem;\n \n-use hir::{DefWithBody, HasSource, ModuleSource};\n-use ra_db::{FileId, SourceDatabaseExt};\n-use ra_prof::profile;\n-use ra_syntax::{AstNode, TextRange};\n-use rustc_hash::FxHashMap;\n-\n-use ra_ide_db::RootDatabase;\n-\n-use super::Definition;\n-\n-pub struct SearchScope {\n-    entries: FxHashMap<FileId, Option<TextRange>>,\n-}\n-\n-impl SearchScope {\n-    fn empty() -> SearchScope {\n-        SearchScope { entries: FxHashMap::default() }\n-    }\n-\n-    pub(crate) fn for_def(def: &Definition, db: &RootDatabase) -> SearchScope {\n-        let _p = profile(\"search_scope\");\n-        let module = match def.module(db) {\n-            Some(it) => it,\n-            None => return SearchScope::empty(),\n-        };\n-        let module_src = module.definition_source(db);\n-        let file_id = module_src.file_id.original_file(db);\n-\n-        if let Definition::Local(var) = def {\n-            let range = match var.parent(db) {\n-                DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n-                DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n-                DefWithBody::Static(s) => s.source(db).value.syntax().text_range(),\n-            };\n-            let mut res = FxHashMap::default();\n-            res.insert(file_id, Some(range));\n-            return SearchScope::new(res);\n-        }\n-\n-        let vis = def.visibility(db).as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n-\n-        if vis.as_str() == \"pub(super)\" {\n-            if let Some(parent_module) = module.parent(db) {\n-                let mut res = FxHashMap::default();\n-                let parent_src = parent_module.definition_source(db);\n-                let file_id = parent_src.file_id.original_file(db);\n-\n-                match parent_src.value {\n-                    ModuleSource::Module(m) => {\n-                        let range = Some(m.syntax().text_range());\n-                        res.insert(file_id, range);\n-                    }\n-                    ModuleSource::SourceFile(_) => {\n-                        res.insert(file_id, None);\n-                        res.extend(parent_module.children(db).map(|m| {\n-                            let src = m.definition_source(db);\n-                            (src.file_id.original_file(db), None)\n-                        }));\n-                    }\n-                }\n-                return SearchScope::new(res);\n-            }\n-        }\n-\n-        if vis.as_str() != \"\" {\n-            let source_root_id = db.file_source_root(file_id);\n-            let source_root = db.source_root(source_root_id);\n-            let mut res = source_root.walk().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n-\n-            // FIXME: add \"pub(in path)\"\n-\n-            if vis.as_str() == \"pub(crate)\" {\n-                return SearchScope::new(res);\n-            }\n-            if vis.as_str() == \"pub\" {\n-                let krate = module.krate();\n-                for rev_dep in krate.reverse_dependencies(db) {\n-                    let root_file = rev_dep.root_file(db);\n-                    let source_root_id = db.file_source_root(root_file);\n-                    let source_root = db.source_root(source_root_id);\n-                    res.extend(source_root.walk().map(|id| (id, None)));\n-                }\n-                return SearchScope::new(res);\n-            }\n-        }\n-\n-        let mut res = FxHashMap::default();\n-        let range = match module_src.value {\n-            ModuleSource::Module(m) => Some(m.syntax().text_range()),\n-            ModuleSource::SourceFile(_) => None,\n-        };\n-        res.insert(file_id, range);\n-        SearchScope::new(res)\n-    }\n-\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n-        SearchScope { entries }\n-    }\n-    pub fn single_file(file: FileId) -> SearchScope {\n-        SearchScope::new(std::iter::once((file, None)).collect())\n-    }\n-    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n-        let (mut small, mut large) = (&self.entries, &other.entries);\n-        if small.len() > large.len() {\n-            mem::swap(&mut small, &mut large)\n-        }\n-\n-        let res = small\n-            .iter()\n-            .filter_map(|(file_id, r1)| {\n-                let r2 = large.get(file_id)?;\n-                let r = intersect_ranges(*r1, *r2)?;\n-                Some((*file_id, r))\n-            })\n-            .collect();\n-        return SearchScope::new(res);\n-\n-        fn intersect_ranges(\n-            r1: Option<TextRange>,\n-            r2: Option<TextRange>,\n-        ) -> Option<Option<TextRange>> {\n-            match (r1, r2) {\n-                (None, r) | (r, None) => Some(r),\n-                (Some(r1), Some(r2)) => {\n-                    let r = r1.intersection(&r2)?;\n-                    Some(Some(r))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl IntoIterator for SearchScope {\n-    type Item = (FileId, Option<TextRange>);\n-    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.entries.into_iter()\n-    }\n-}"}, {"sha": "79f48c9e32e54357e24aa4bb73d33b447210a09b", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=a549da7e3ea66fd336de331c7c8d62b186051521", "patch": "@@ -9,6 +9,7 @@ pub mod feature_flags;\n pub mod symbol_index;\n pub mod change;\n pub mod defs;\n+pub mod search;\n pub mod imports_locator;\n mod wasm_shims;\n "}, {"sha": "add63b870fe3e813b6f2f675c31fd06655b7d196", "filename": "crates/ra_ide_db/src/search.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a549da7e3ea66fd336de331c7c8d62b186051521/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=a549da7e3ea66fd336de331c7c8d62b186051521", "patch": "@@ -0,0 +1,147 @@\n+//! Generally, `search_scope` returns files that might contain references for the element.\n+//! For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n+//! In some cases, the location of the references is known to within a `TextRange`,\n+//! e.g. for things like local variables.\n+use std::mem;\n+\n+use hir::{DefWithBody, HasSource, ModuleSource};\n+use ra_db::{FileId, SourceDatabaseExt};\n+use ra_prof::profile;\n+use ra_syntax::{AstNode, TextRange};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{defs::Definition, RootDatabase};\n+\n+pub struct SearchScope {\n+    entries: FxHashMap<FileId, Option<TextRange>>,\n+}\n+\n+impl SearchScope {\n+    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+        SearchScope { entries }\n+    }\n+\n+    pub fn empty() -> SearchScope {\n+        SearchScope::new(FxHashMap::default())\n+    }\n+\n+    pub fn single_file(file: FileId) -> SearchScope {\n+        SearchScope::new(std::iter::once((file, None)).collect())\n+    }\n+\n+    pub fn for_def(def: &Definition, db: &RootDatabase) -> SearchScope {\n+        let _p = profile(\"search_scope\");\n+        let module = match def.module(db) {\n+            Some(it) => it,\n+            None => return SearchScope::empty(),\n+        };\n+        let module_src = module.definition_source(db);\n+        let file_id = module_src.file_id.original_file(db);\n+\n+        if let Definition::Local(var) = def {\n+            let range = match var.parent(db) {\n+                DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n+                DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n+                DefWithBody::Static(s) => s.source(db).value.syntax().text_range(),\n+            };\n+            let mut res = FxHashMap::default();\n+            res.insert(file_id, Some(range));\n+            return SearchScope::new(res);\n+        }\n+\n+        let vis = def.visibility(db).as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n+\n+        if vis.as_str() == \"pub(super)\" {\n+            if let Some(parent_module) = module.parent(db) {\n+                let mut res = FxHashMap::default();\n+                let parent_src = parent_module.definition_source(db);\n+                let file_id = parent_src.file_id.original_file(db);\n+\n+                match parent_src.value {\n+                    ModuleSource::Module(m) => {\n+                        let range = Some(m.syntax().text_range());\n+                        res.insert(file_id, range);\n+                    }\n+                    ModuleSource::SourceFile(_) => {\n+                        res.insert(file_id, None);\n+                        res.extend(parent_module.children(db).map(|m| {\n+                            let src = m.definition_source(db);\n+                            (src.file_id.original_file(db), None)\n+                        }));\n+                    }\n+                }\n+                return SearchScope::new(res);\n+            }\n+        }\n+\n+        if vis.as_str() != \"\" {\n+            let source_root_id = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root_id);\n+            let mut res = source_root.walk().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n+\n+            // FIXME: add \"pub(in path)\"\n+\n+            if vis.as_str() == \"pub(crate)\" {\n+                return SearchScope::new(res);\n+            }\n+            if vis.as_str() == \"pub\" {\n+                let krate = module.krate();\n+                for rev_dep in krate.reverse_dependencies(db) {\n+                    let root_file = rev_dep.root_file(db);\n+                    let source_root_id = db.file_source_root(root_file);\n+                    let source_root = db.source_root(source_root_id);\n+                    res.extend(source_root.walk().map(|id| (id, None)));\n+                }\n+                return SearchScope::new(res);\n+            }\n+        }\n+\n+        let mut res = FxHashMap::default();\n+        let range = match module_src.value {\n+            ModuleSource::Module(m) => Some(m.syntax().text_range()),\n+            ModuleSource::SourceFile(_) => None,\n+        };\n+        res.insert(file_id, range);\n+        SearchScope::new(res)\n+    }\n+\n+    pub fn intersection(&self, other: &SearchScope) -> SearchScope {\n+        let (mut small, mut large) = (&self.entries, &other.entries);\n+        if small.len() > large.len() {\n+            mem::swap(&mut small, &mut large)\n+        }\n+\n+        let res = small\n+            .iter()\n+            .filter_map(|(file_id, r1)| {\n+                let r2 = large.get(file_id)?;\n+                let r = intersect_ranges(*r1, *r2)?;\n+                Some((*file_id, r))\n+            })\n+            .collect();\n+\n+        return SearchScope::new(res);\n+\n+        fn intersect_ranges(\n+            r1: Option<TextRange>,\n+            r2: Option<TextRange>,\n+        ) -> Option<Option<TextRange>> {\n+            match (r1, r2) {\n+                (None, r) | (r, None) => Some(r),\n+                (Some(r1), Some(r2)) => {\n+                    let r = r1.intersection(&r2)?;\n+                    Some(Some(r))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl IntoIterator for SearchScope {\n+    type Item = (FileId, Option<TextRange>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.entries.into_iter()\n+    }\n+}"}]}