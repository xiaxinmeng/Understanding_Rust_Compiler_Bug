{"sha": "17ff2a0d7960c58b12898cb0142917a0cffb7559", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ZmYyYTBkNzk2MGM1OGIxMjg5OGNiMDE0MjkxN2EwY2ZmYjc1NTk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-09T16:48:16Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-09T18:37:52Z"}, "message": "Further support for predicate constraints\n\nChanged function types to include a list of constraints. Added\ncode for parsing and pretty-printing constraints. This necessitated\nsplitting pprust into two files (pprust and ppaux) to break a\ncirculate dependency, as ty_to_str now needs to print out constraints,\nwhich may include literals, but pprust depended on ty.", "tree": {"sha": "74e82389edf4d92fd3dd5c893f1ccfa84a5dd9c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74e82389edf4d92fd3dd5c893f1ccfa84a5dd9c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ff2a0d7960c58b12898cb0142917a0cffb7559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ff2a0d7960c58b12898cb0142917a0cffb7559", "html_url": "https://github.com/rust-lang/rust/commit/17ff2a0d7960c58b12898cb0142917a0cffb7559", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ff2a0d7960c58b12898cb0142917a0cffb7559/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46920e073b4a8da80ad895a9af149e6ff2686e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/46920e073b4a8da80ad895a9af149e6ff2686e0a", "html_url": "https://github.com/rust-lang/rust/commit/46920e073b4a8da80ad895a9af149e6ff2686e0a"}], "stats": {"total": 1593, "additions": 984, "deletions": 609}, "files": [{"sha": "202b963bd6085c37f5a5b15974ec6438c9eb74a8", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -431,7 +431,7 @@ fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t,\n                                      &str name) -> str {\n     auto f = metadata::def_to_str;\n     auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::ac_no_abbrevs);\n-    auto s = ty::ty_to_short_str(ccx.tcx, t);\n+    auto s = pretty::ppaux::ty_to_short_str(ccx.tcx, t);\n \n     auto hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);"}, {"sha": "326ad81011d570f279e249887ca7ca36de894f3c", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -11,6 +11,7 @@ import middle::ty;\n import middle::typeck;\n import middle::tstate::ck;\n import pretty::pprust;\n+import pretty::ppaux;\n import back::link;\n import lib::llvm;\n import util::common;\n@@ -133,10 +134,10 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n             auto def_map = resolve::resolve_crate(sess, crate);\n             auto ty_cx = ty::mk_ctxt(sess, def_map);\n             typeck::check_crate(ty_cx, crate);\n-            mode = pprust::mo_typed(ty_cx);\n+            mode = ppaux::mo_typed(ty_cx);\n         }\n-        case (ppm_normal) { mode = pprust::mo_untyped; }\n-        case (ppm_identified) { mode = pprust::mo_identified; }\n+        case (ppm_normal) { mode = ppaux::mo_untyped; }\n+        case (ppm_identified) { mode = ppaux::mo_identified; }\n     }\n \n     pprust::print_file(sess, crate.node.module, input, std::io::stdout(),"}, {"sha": "3588c61c824673e8baa699a7a2cfb5560dc3b9c3", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -312,8 +312,8 @@ type mt = rec(@ty ty, mutability mut);\n type ty_field_ = rec(ident ident, mt mt);\n type ty_arg_ = rec(mode mode, @ty ty);\n type ty_method_ = rec(proto proto, ident ident,\n-                     vec[ty_arg] inputs, @ty output,\n-                     controlflow cf);\n+                      vec[ty_arg] inputs, @ty output,\n+                      controlflow cf, vec[@constr] constrs);\n type ty_field = spanned[ty_field_];\n type ty_arg = spanned[ty_arg_];\n type ty_method = spanned[ty_method_];\n@@ -342,7 +342,7 @@ tag ty_ {\n     ty_chan(@ty);\n     ty_tup(vec[mt]);\n     ty_rec(vec[ty_field]);\n-    ty_fn(proto, vec[ty_arg], @ty, controlflow);\n+    ty_fn(proto, vec[ty_arg], @ty, controlflow, vec[@constr]);\n     ty_obj(vec[ty_method]);\n     ty_path(path, ann);\n     ty_type;\n@@ -362,7 +362,8 @@ type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n type fn_decl = rec(vec[arg] inputs,\n                    @ty output,\n                    purity purity,\n-                   controlflow cf);\n+                   controlflow cf,\n+                   vec[@constr] constraints);\n tag purity {\n     pure_fn;   // declared with \"pred\"\n     impure_fn; // declared with \"fn\""}, {"sha": "e0be9606384b43c846dc660444eab37d2f300416", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -14,8 +14,10 @@ import middle::ty;\n import back::x86;\n import util::common;\n import util::common::span;\n+import util::common::respan;\n import util::common::a_bang;\n import util::common::a_ty;\n+import util::common::may_begin_ident;\n \n import std::str;\n import std::uint;\n@@ -54,6 +56,14 @@ fn next(@pstate st) -> u8 {\n     ret ch;\n }\n \n+fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n+    auto res = \"\";\n+    while (peek(st) as char != last) {\n+        res += str::unsafe_from_byte(next(st));\n+    }\n+    ret res;\n+}\n+\n fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len,\n                  str_def sd, ty::ctxt tcx) -> ty::t {\n     auto st = @rec(data=data, crate=crate_num,\n@@ -69,6 +79,62 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     }\n }\n \n+fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n+    let vec[@ast::constr] res = [];\n+    alt (peek(st) as char) {\n+        case (':') {\n+            do {\n+                auto ignore = next(st);\n+                vec::push(res, parse_constr(st, sd));\n+            } while (peek(st) as char == ',')\n+        }\n+        case (_) {}\n+    }\n+    ret res;\n+}\n+\n+fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n+    let vec[@ast::constr_arg] args = [];\n+    auto sp = rec(lo=0u,hi=0u); // FIXME\n+    let vec[ast::ident] ids = [];\n+    let vec[@ast::ty] tys = [];\n+    let ast::path pth = respan(sp,\n+                               rec(idents=ids, types=tys)); // FIXME\n+    let ast::ident p1 = parse_ident(st, sd, '(');\n+    log_err(\"ignore=\");\n+    log_err(p1);\n+    let char ignore = next(st) as char;\n+    assert(ignore as char == '(');\n+    do {\n+        alt (peek(st) as char) {\n+            case ('*') {\n+                auto ignore = next(st);\n+                args += [@respan(sp, ast::carg_base)];\n+            }\n+            case (?c) {\n+                log_err(\"c =\");\n+                log_err(str::from_bytes([c as u8]));\n+                if (may_begin_ident(c)) {\n+                    auto id = parse_ident(st, sd, ',');\n+                    args += [@respan(sp, ast::carg_ident(id))];\n+                }\n+                else {\n+                    log_err(\"Lit args are unimplemented\");\n+                    fail; // FIXME\n+                }\n+                /*\n+                else {\n+                    auto lit = parse_lit(st, sd, ',');\n+                    args += [respan(st.span, ast::carg_lit(lit))];\n+                }\n+                */\n+            }\n+        }\n+    } while (next(st) as char == ',');\n+    ignore = next(st) as char;\n+    ret @respan(sp, rec(path=pth, args=args));\n+}\n+\n fn parse_ty(@pstate st, str_def sd) -> ty::t {\n     alt (next(st) as char) {\n         case ('n') { ret ty::mk_nil(st.tcx); }\n@@ -135,11 +201,13 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0, func._1, func._2);\n+            ret ty::mk_fn(st.tcx, ast::proto_fn, func._0,\n+                          func._1, func._2, func._3);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0, func._1, func._2);\n+            ret ty::mk_fn(st.tcx, ast::proto_iter, func._0,\n+                          func._1, func._2, func._3);\n         }\n         case ('N') {\n             auto abi;\n@@ -170,7 +238,8 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                                 ident=name,\n                                 inputs=func._0,\n                                 output=func._1,\n-                                cf=func._2)];\n+                                cf=func._2,\n+                                constrs=func._3)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);\n@@ -250,7 +319,8 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n-                                              ast::controlflow) {\n+                                              ast::controlflow,\n+                                              vec[@ast::constr]) {\n     assert (next(st) as char == '[');\n     let vec[ty::arg] inputs = [];\n     while (peek(st) as char != ']') {\n@@ -262,15 +332,17 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n         inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n     }\n     st.pos = st.pos + 1u;\n+    auto cs  = parse_constrs(st, sd);\n     auto res = parse_ty_or_bang(st, sd);\n     alt (res) {\n         case (a_bang) {\n-            ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn);\n+            ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn, cs);\n         }\n         case (a_ty(?t)) {\n-            ret tup(inputs, t, ast::return);\n+            ret tup(inputs, t, ast::return, cs);\n         }\n     }\n+    \n }\n \n \n@@ -579,7 +651,7 @@ fn get_tag_variants(ty::ctxt tcx, ast::def_id def)\n         auto ctor_ty = item_type(item, external_crate_id, tcx);\n         let vec[ty::t] arg_tys = [];\n         alt (ty::struct(tcx, ctor_ty)) {\n-            case (ty::ty_fn(_, ?args, _, _)) {\n+            case (ty::ty_fn(_, ?args, _, _, _)) {\n                 for (ty::arg a in args) {\n                     arg_tys += [a.ty];\n                 }"}, {"sha": "897ec01aa057a449804a9f8addc5215ff94ca8b4", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -9,7 +9,7 @@ import std::option::some;\n import std::option::none;\n import driver::session::session;\n import util::common;\n-import util::common::new_str_hash;\n+import util::common::*;\n import util::data::interner;\n \n state type reader = state obj {\n@@ -111,32 +111,6 @@ fn new_reader(session sess, io::reader rdr,\n     ret rd;\n }\n \n-fn in_range(char c, char lo, char hi) -> bool {\n-    ret lo <= c && c <= hi;\n-}\n-\n-fn is_alpha(char c) -> bool {\n-    ret in_range(c, 'a', 'z') ||\n-        in_range(c, 'A', 'Z');\n-}\n-\n-fn is_dec_digit(char c) -> bool {\n-    ret in_range(c, '0', '9');\n-}\n-\n-fn is_alnum(char c) -> bool {\n-    ret is_alpha(c) || is_dec_digit(c);\n-}\n-\n-fn is_hex_digit(char c) -> bool {\n-    ret in_range(c, '0', '9') ||\n-        in_range(c, 'a', 'f') ||\n-        in_range(c, 'A', 'F');\n-}\n-\n-fn is_bin_digit(char c) -> bool {\n-    ret c == '0' || c == '1';\n-}\n \n fn dec_digit_val(char c) -> int {\n     ret (c as int) - ('0' as int);"}, {"sha": "b8ec6a8a74905eb97873d321c60c576b88379e1c", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -345,9 +345,7 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n     auto inputs = parse_seq(token::LPAREN, token::RPAREN,\n                             some(token::COMMA), parse_fn_input_ty, p);\n \n-    // FIXME: dropping constrs on the floor at the moment.\n-    // pick them up when they're used by typestate pass.\n-    parse_constrs(p);\n+    auto constrs = parse_constrs(p);\n \n     let @ast::ty output;\n     auto cf = ast::return;\n@@ -367,7 +365,7 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n         output = @spanned(lo, inputs.span.hi, ast::ty_nil);\n     }\n \n-    ret ast::ty_fn(proto, inputs.node, output, cf);\n+    ret ast::ty_fn(proto, inputs.node, output, cf, constrs.node);\n }\n \n fn parse_proto(&parser p) -> ast::proto {\n@@ -386,10 +384,11 @@ fn parse_ty_obj(&parser p, &mutable uint hi) -> ast::ty_ {\n         auto f = parse_ty_fn(proto, p, flo);\n         expect(p, token::SEMI);\n         alt (f) {\n-            case (ast::ty_fn(?proto, ?inputs, ?output, ?cf)) {\n+            case (ast::ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n                 ret spanned(flo, output.span.hi,\n                             rec(proto=proto, ident=ident,\n-                                inputs=inputs, output=output, cf=cf));\n+                                inputs=inputs, output=output, cf=cf,\n+                                constrs=constrs));\n             }\n         }\n         fail;\n@@ -547,15 +546,15 @@ fn parse_ty(&parser p) -> @ast::ty {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_fn, p, flo);\n         alt (t) {\n-            case (ast::ty_fn(_, _, ?out, _)) {\n+            case (ast::ty_fn(_, _, ?out, _, _)) {\n                 hi = out.span.hi;\n             }\n         }\n     } else if (eat_word(p, \"iter\")) {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_iter, p, flo);\n         alt (t) {\n-            case (ast::ty_fn(_, _, ?out, _)) {\n+            case (ast::ty_fn(_, _, ?out, _, _)) {\n                 hi = out.span.hi;\n             }\n         }\n@@ -1756,9 +1755,7 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n \n     let ty_or_bang res;\n \n-    // FIXME: dropping constrs on the floor at the moment.\n-    // pick them up when they're used by typestate pass.\n-    parse_constrs(p);\n+    auto constrs = parse_constrs(p).node;\n \n     if (p.peek() == token::RARROW) {\n         p.bump();\n@@ -1771,13 +1768,13 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     alt (res) {\n         case (a_ty(?t)) {\n             ret rec(inputs=inputs.node, output=t,\n-              purity=purity, cf=ast::return);\n+                    purity=purity, cf=ast::return, constraints=constrs);\n         }\n         case (a_bang) {\n             ret rec(inputs=inputs.node,\n                     output=@spanned(p.get_lo_pos(),\n                                     p.get_hi_pos(), ast::ty_bot),\n-                    purity=purity, cf=ast::noreturn);\n+                    purity=purity, cf=ast::noreturn, constraints=constrs);\n         }\n     }\n }\n@@ -1833,7 +1830,9 @@ fn parse_dtor(&parser p) -> @ast::method {\n     let ast::fn_decl d = rec(inputs=inputs,\n                              output=output,\n                              purity=ast::impure_fn,\n-                             cf=ast::return); \n+                             cf=ast::return,\n+ // I guess dtors can't have constraints? \n+                             constraints=[]);\n     let ast::_fn f = rec(decl = d,\n                          proto = ast::proto_fn,\n                          body = b);"}, {"sha": "73dc08c6d37e30cf79d2bc654703fe9680a94e47", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -100,7 +100,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n     -> rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n     auto arg_ts = alt (ty::struct(*cx.tcx, fty)) {\n-        case (ty::ty_fn(_, ?args, _, _)) { args }\n+        case (ty::ty_fn(_, ?args, _, _, _)) { args }\n         case (ty::ty_native_fn(_, ?args, _)) { args }\n     };\n \n@@ -490,7 +490,7 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut)\n                 ret false;\n             }\n             // These may contain anything.\n-            case (ty::ty_fn(_, _, _, _)) { ret true; }\n+            case (ty::ty_fn(_, _, _, _, _)) { ret true; }\n             case (ty::ty_obj(_)) { ret true; }\n             // A type param may include everything, but can only be treated as\n             // opaque downstream, and is thus safe unless we saw mutable"}, {"sha": "8322de5bc90ff02578059fe2b58dfc21c3a505d7", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -9,10 +9,13 @@ import std::option::some;\n import std::option::none;\n \n import front::ast;\n+import front::ast::*;\n import middle::trans;\n import middle::ty;\n+import middle::ty::path_to_str;\n import back::x86;\n import util::common;\n+import pretty::ppaux::lit_to_str;\n \n import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n@@ -194,9 +197,9 @@ mod Encode {\n                 }\n                 w.write_char(']');\n             }\n-            case (ty::ty_fn(?proto,?args,?out,?cf)) {\n+            case (ty::ty_fn(?proto,?args,?out,?cf,?constrs)) {\n                 enc_proto(w, proto);\n-                enc_ty_fn(w, cx, args, out, cf);\n+                enc_ty_fn(w, cx, args, out, cf, constrs);\n             }\n             case (ty::ty_native_fn(?abi,?args,?out)) {\n                 w.write_char('N');\n@@ -208,14 +211,15 @@ mod Encode {\n                     case (ast::native_abi_cdecl) { w.write_char('c'); }\n                     case (ast::native_abi_llvm) { w.write_char('l'); }\n                 }\n-                enc_ty_fn(w, cx, args, out, ast::return);\n+                let vec[@constr] res_constrs = [];\n+                enc_ty_fn(w, cx, args, out, ast::return, res_constrs);\n             }\n             case (ty::ty_obj(?methods)) {\n                 w.write_str(\"O[\");\n                 for (ty::method m in methods) {\n                     enc_proto(w, m.proto);\n                     w.write_str(m.ident);\n-                    enc_ty_fn(w, cx, m.inputs, m.output, m.cf);\n+                    enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n                 }\n                 w.write_char(']');\n             }\n@@ -241,7 +245,7 @@ mod Encode {\n     }\n \n     fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n-                 &ast::controlflow cf) {\n+                 &ast::controlflow cf, &vec[@ast::constr] constrs) {\n         w.write_char('[');\n         for (ty::arg arg in args) {\n             if (arg.mode == ty::mo_alias) { w.write_char('&'); }\n@@ -256,6 +260,37 @@ mod Encode {\n                 enc_ty(w, cx, out);\n             }\n         }\n+        auto colon = true;\n+        for (@ast::constr c in constrs) {\n+            if (colon) { w.write_char(':'); colon = false; }\n+            else { w.write_char(','); }\n+            enc_constr(w, cx, c);\n+        }\n+    }\n+\n+    fn enc_constr(&io::writer w, &@ctxt cx, &@ast::constr c) {\n+        w.write_str(path_to_str(c.node.path));\n+        w.write_char('(');\n+        auto comma = false;\n+        for (@constr_arg a in c.node.args) {\n+            if (comma) {\n+                w.write_char(',');\n+            }\n+            else {\n+                comma = true;\n+            }\n+            alt (a.node) {\n+                case (carg_base) {\n+                    w.write_char('*');\n+                }\n+                case (carg_ident(?i)) {\n+                    w.write_str(i);\n+                }\n+                case (carg_lit(?l)) {\n+                    w.write_str(lit_to_str(l));\n+                }\n+            }\n+        }\n     }\n \n }"}, {"sha": "72a382c1361820078627e65b2c7694fb4bfd6795", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -71,6 +71,9 @@ import link::mangle_exported_name;\n import link::crate_meta_name;\n import link::crate_meta_vers;\n import link::crate_meta_extras_hash;\n+import pretty::ppaux::ty_to_str;\n+import pretty::ppaux::ty_to_short_str;\n+import pretty::pprust::expr_to_str;\n \n state obj namegen(mutable int i) {\n     fn next(str prefix) -> str {\n@@ -677,7 +680,7 @@ fn type_of(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n         cx.sess.span_err (sp,\n           \"type_of() called on a type with dynamic size: \" +\n-                          ty::ty_to_str(cx.tcx, t));\n+                          ty_to_str(cx.tcx, t));\n     }\n \n     ret type_of_inner(cx, sp, t);\n@@ -870,7 +873,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             }\n             llty = T_struct(tys);\n         }\n-        case (ty::ty_fn(?proto, ?args, ?out, _)) {\n+        case (ty::ty_fn(?proto, ?args, ?out, _, _)) {\n             llty = T_fn_pair(cx.tn, type_of_fn(cx, sp, proto, args, out, 0u));\n         }\n         case (ty::ty_native_fn(?abi, ?args, ?out)) {\n@@ -910,7 +913,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n     assert (llty as int != 0);\n     if (cx.sess.get_opts().save_temps) {\n         llvm::LLVMAddTypeName(cx.llmod,\n-                             str::buf(ty::ty_to_short_str(cx.tcx, t)),\n+                             str::buf(ty_to_short_str(cx.tcx, t)),\n                              llty);\n     }\n     cx.lltypes.insert(t, llty);\n@@ -941,7 +944,7 @@ fn type_of_arg(@local_ctxt cx, &span sp, &ty::arg arg) -> TypeRef {\n fn type_of_ty_param_count_and_ty(@local_ctxt lcx, &span sp,\n                                  &ty::ty_param_count_and_ty tpt) -> TypeRef {\n     alt (ty::struct(lcx.ccx.tcx, tpt._1)) {\n-        case (ty::ty_fn(?proto, ?inputs, ?output, _)) {\n+        case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             auto llfnty = type_of_fn(lcx.ccx, sp, proto,\n                                      inputs, output, tpt._0);\n             ret T_fn_pair(lcx.ccx.tn, llfnty);\n@@ -1243,7 +1246,7 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n             case (ty::ty_vec(_)) {\n                 ret ty::mk_imm_vec(ccx.tcx, ty::mk_nil(ccx.tcx));\n             }\n-            case (ty::ty_fn(_,_,_,_)) {\n+            case (ty::ty_fn(_,_,_,_,_)) {\n                 ret ty::mk_imm_tup(ccx.tcx, \n                                    [ty::mk_imm_box(ccx.tcx, \n                                                    ty::mk_nil(ccx.tcx)),\n@@ -1841,7 +1844,7 @@ fn set_glue_inlining(&@local_ctxt cx, ValueRef f, &ty::t t) {\n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t,\n                   vec[uint] ty_params) -> @tydesc_info {\n-    log \"+++ declare_tydesc \" + ty::ty_to_str(cx.ccx.tcx, t);\n+    log \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     auto ccx = cx.ccx;\n \n     auto llsize;\n@@ -1878,7 +1881,7 @@ fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t,\n                      mutable cmp_glue = none[ValueRef],\n                      ty_params = ty_params);\n \n-    log \"--- declare_tydesc \" + ty::ty_to_str(cx.ccx.tcx, t);\n+    log \"--- declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     ret info;\n }\n \n@@ -2163,7 +2166,7 @@ fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             rslt = trans_non_gc_free(cx_, b);\n         }\n \n-        case (ty::ty_fn(_,_,_,_)) {\n+        case (ty::ty_fn(_,_,_,_,_)) {\n \n             auto box_cell =\n                 cx.build.GEP(v0,\n@@ -2239,7 +2242,7 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             rslt = decr_refcnt_maybe_free(cx, box_cell, v0, t);\n         }\n \n-        case (ty::ty_fn(_,_,_,_)) {\n+        case (ty::ty_fn(_,_,_,_,_)) {\n \n             auto box_cell =\n                 cx.build.GEP(v0,\n@@ -2465,7 +2468,7 @@ fn make_cmp_glue(&@block_ctxt cx,\n         // FIXME: compare obj, fn by pointer?\n         trans_fail(cx, none[common::span],\n                    \"attempt to compare values of type \" +\n-                   ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+                   ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n     }\n }\n \n@@ -2726,7 +2729,7 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n                     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, fn_ty)) {\n-                        case (ty::ty_fn(_, ?args, _, _)) {\n+                        case (ty::ty_fn(_, ?args, _, _, _)) {\n                             auto j = 0;\n                             for (ty::arg a in args) {\n                                 auto v = [C_int(0), C_int(j as int)];\n@@ -2773,7 +2776,7 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n \n             ret res(next_cx, C_nil());\n         }\n-        case (ty::ty_fn(_,_,_,_)) {\n+        case (ty::ty_fn(_,_,_,_,_)) {\n             auto box_cell_a =\n                 cx.build.GEP(av,\n                              [C_int(0),\n@@ -2930,7 +2933,7 @@ fn iter_sequence(@block_ctxt cx,\n \n             cx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n                                     \"trans::iter_sequence: \" +\n-                                    ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+                                    ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n         }\n     }\n }\n@@ -2961,7 +2964,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                     case (some(_)) {}\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n \n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n@@ -2974,15 +2977,15 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                                           mgghf_single(tg), ti.ty_params);\n \n                         log #fmt(\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                     }\n                 }\n             } else if (field == abi::tydesc_field_drop_glue)  {\n                 alt ({ti.drop_glue}) {\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n@@ -2993,7 +2996,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_single(dg), ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue DROP %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                     }\n                 }\n \n@@ -3002,7 +3005,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n@@ -3014,7 +3017,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_single(dg), ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue FREE %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                     }\n                 }\n \n@@ -3023,7 +3026,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue CMP %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n@@ -3033,7 +3036,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_cmp, ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue CMP %s\",\n-                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                                 ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                     }\n                 }\n             }\n@@ -3274,7 +3277,7 @@ fn copy_val(&@block_ctxt cx,\n     }\n \n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::copy_val: \" +\n-                        ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+                        ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n }\n \n // This works like copy_val, except that it deinitializes the source.\n@@ -3311,7 +3314,7 @@ fn move_val(&@block_ctxt cx,\n     }\n \n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::move_val: \" +\n-                        ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+                        ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n }\n \n \n@@ -4499,7 +4502,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n         case (ast::def_variant(?tid, ?vid)) {\n             auto v_tyt = ty::lookup_item_type(cx.fcx.lcx.ccx.tcx, vid);\n             alt (ty::struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n-                case (ty::ty_fn(_, _, _, _)) {\n+                case (ty::ty_fn(_, _, _, _, _)) {\n                     // N-ary variant.\n                     ret lval_generic_fn(cx, v_tyt, vid, ann);\n                 }\n@@ -4691,7 +4694,7 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         case (_) {\n             cx.fcx.lcx.ccx.sess.span_unimpl(e.span,\n                                             \"expr variant in trans_lval: \"\n-                                            + pretty::pprust::expr_to_str(e));\n+                                            + expr_to_str(e));\n         }\n     }\n }\n@@ -5850,7 +5853,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n                 // FIXME: Support these types.\n                 cx.fcx.lcx.ccx.sess.span_err(e.span,\n                                  \"log called on unsupported type \" +\n-                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, e_ty));\n+                                  ty_to_str(cx.fcx.lcx.ccx.tcx, e_ty));\n             }\n         }\n     }\n@@ -5864,7 +5867,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n fn trans_check_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n-    auto expr_str = pretty::pprust::expr_to_str(e);\n+    auto expr_str = expr_to_str(e);\n     auto fail_cx = new_sub_block_ctxt(cx, \"fail\");\n     auto fail_res = trans_fail(fail_cx, some[common::span](e.span), expr_str);\n \n@@ -6085,9 +6088,9 @@ fn trans_spawn(&@block_ctxt cx,\n     // Make the task name\n     auto tname = alt(name) {\n         case(none) {\n-            auto argss = vec::map(pretty::pprust::expr_to_str, args);\n+            auto argss = vec::map(expr_to_str, args);\n             #fmt(\"%s(%s)\",\n-                 pretty::pprust::expr_to_str(func),\n+                 expr_to_str(func),\n                  str::connect(argss, \", \"))\n         }\n         case(some(?n)) {\n@@ -6865,15 +6868,15 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n \n fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n     alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, ann))) {\n-        case (ty::ty_fn(_, ?arg_tys, _, _)) {\n+        case (ty::ty_fn(_, ?arg_tys, _, _, _)) {\n             ret arg_tys;\n         }\n     }\n }\n \n fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n     alt (ty::struct(ccx.tcx, t)) {\n-        case (ty::ty_fn(_, _, ?ret_ty, _)) {\n+        case (ty::ty_fn(_, _, ?ret_ty, _, _)) {\n             ret ret_ty;\n         }\n     }\n@@ -7043,7 +7046,7 @@ fn create_vtbl(@local_ctxt cx,\n \n         auto llfnty = T_nil();\n         alt (ty::struct(cx.ccx.tcx, node_ann_type(cx.ccx, m.node.ann))) {\n-            case (ty::ty_fn(?proto, ?inputs, ?output, _)) {\n+            case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n                 llfnty = type_of_fn_full(cx.ccx, m.span, proto,\n                                          some[TypeRef](llself_ty),\n                                          inputs, output,\n@@ -7466,7 +7469,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n     auto llfty;\n     auto llpairty;\n     alt (ty::struct(ccx.tcx, node_ann_type(ccx, ann))) {\n-        case (ty::ty_fn(?proto, ?inputs, ?output, _)) {\n+        case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             llfty = type_of_fn(ccx, sp, proto, inputs, output,\n                                vec::len[ast::ty_param](ty_params));\n             llpairty = T_fn_pair(ccx.tn, llfty);"}, {"sha": "06de1befb74382384ca9a5eac846bdfb0cf81d14", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 138, "deletions": 39, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -8,6 +8,7 @@ import std::option::none;\n import std::option::some;\n import std::option::maybe;\n \n+import front::ast;\n import front::ast::*;\n \n import middle::ty::expr_ann;\n@@ -22,7 +23,6 @@ import util::common::log_expr_err;\n import util::common::uistr;\n import util::common::lit_eq;\n import pretty::pprust::path_to_str;\n-import pretty::pprust::lit_to_str;\n \n import tstate::ann::pre_and_post;\n import tstate::ann::pre_and_post_state;\n@@ -42,6 +42,8 @@ import tstate::ann::set_postcondition;\n import tstate::ann::ts_ann;\n \n import util::common::istr;\n+import pretty::ppaux::constr_args_to_str;\n+import pretty::ppaux::lit_to_str;\n \n /* logging funs */\n \n@@ -214,7 +216,7 @@ type pred_desc_ = rec(vec[@constr_arg] args,\n type pred_desc = spanned[pred_desc_];\n tag constraint {\n     cinit(uint, span, ident);\n-    cpred(path, vec[pred_desc]);\n+    cpred(path, @vec[pred_desc]);\n }\n tag constr_ {\n     ninit(ident);\n@@ -484,7 +486,7 @@ the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx,\n                                              expr_ann(e)))) {\n-        case (ty::ty_fn(_,_,_,?cf)) {\n+        case (ty::ty_fn(_,_,_,?cf,_)) {\n             ret cf;\n         }\n         case (_) {\n@@ -493,6 +495,17 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n+fn constraints_expr(&crate_ctxt ccx, @expr e) -> vec[@ast::constr] {\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, expr_ann(e)))) {\n+        case (ty::ty_fn(_,_,_,_,?cs)) {\n+            ret cs;\n+        }\n+        case (_) {\n+            ret [];\n+        }\n+    }\n+}\n+\n fn ann_to_def_strict(&crate_ctxt ccx, &ann a) -> def {\n     alt (ccx.tcx.def_map.find(a.id)) {\n         case (none) { \n@@ -514,7 +527,7 @@ fn norm_a_constraint(&constraint c) -> vec[norm_constraint] {\n         }\n         case (cpred(?p, ?descs)) {\n             let vec[norm_constraint] res = [];\n-            for (pred_desc pd in descs) {\n+            for (pred_desc pd in *descs) {\n                 vec::push(res, rec(bit_num=pd.node.bit_num,\n                   c=respan(pd.span, npred(p, pd.node.args))));\n             }\n@@ -534,60 +547,146 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n     ret res;\n }\n \n-fn arg_eq(@constr_arg a, @constr_arg b) -> bool {\n-    alt (a.node) {\n-        case (carg_base) {\n-            alt (b.node) {\n-                case (carg_base) {\n-                    ret true;\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n+\n+// FIXME:\n+// this probably doesn't handle name shadowing well (or at all)\n+// variables should really always be id'd by def_id and not ident\n+fn match_args(&fn_ctxt fcx, @vec[pred_desc] occs,\n+              vec[@constr_arg] occ) -> uint {\n+    log (\"match_args: looking at \" + constr_args_to_str(occ));\n+    for (pred_desc pd in *occs) {\n+        log (\"match_args: candidate \" + pred_desc_to_str(pd));\n+        if (ty::args_eq(pd.node.args, occ)) {\n+            ret pd.node.bit_num;\n+        }\n+    }\n+    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");  \n+}\n+\n+\n+type constraint_info = rec(def_id id, constr c);\n+\n+fn constr_to_constr_occ(&ty::ctxt tcx, &constr_ c) -> constr_occ {\n+    alt (c) {\n+        case (ninit(_)) { ret occ_init; }\n+        case (npred(_, ?args)) { ret occ_args(args); }\n+    }\n+}\n+\n+fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n+    alt (tcx.def_map.find(t)) {\n+        case (none) {\n+            tcx.sess.bug(\"def_id_for_constr: bad node_id \" + uistr(t));\n+         }\n+        case (some(def_fn(?i))) {\n+            ret i;\n+        }\n+        case (_) {\n+            tcx.sess.bug(\"def_id_for_constr: pred is not a function\");\n         }\n-        case (carg_ident(?s)) {\n-            alt (b.node) {\n-                case (carg_ident(?t)) {\n-                    ret (s == t);\n+    }\n+}\n+\n+\n+fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) -> vec[@constr_arg] {\n+    fn one(ty::ctxt tcx, &@expr e) -> @constr_arg {\n+        alt (e.node) {\n+            case (expr_path(?p, _)) {\n+                if (vec::len(p.node.idents) == 1u) {\n+                    ret @respan(p.span, carg_ident(p.node.idents.(0)));\n                 }\n-                case (_) {\n-                    ret false;\n+                else {\n+                    tcx.sess.bug(\"exprs_to_constr_args: non-local variable \"\n+                                 + \"as pred arg\");\n                 }\n             }\n+            case (expr_lit(?l, _)) {\n+                ret @respan(e.span, carg_lit(l));\n+            }\n+            case (_) {\n+                tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n+            }\n         }\n-        case (carg_lit(?l)) {\n-            alt (b.node) {\n-                case (carg_lit(?m)) {\n-                    ret lit_eq(l, m);\n+    }\n+    auto f = bind one(tcx, _);\n+    ret vec::map(f, args); \n+}\n+\n+fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constraint_info {\n+    alt (e.node) {\n+        // FIXME\n+        // change the first pattern to expr_path to test a typechecker bug\n+        case (expr_call(?operator, ?args, _)) {\n+            alt (operator.node) {\n+                case (expr_path(?p, ?a)) {\n+                    ret rec(id=def_id_for_constr(tcx, a.id),\n+                            c=respan(e.span,\n+                                npred(p, exprs_to_constr_args(tcx, args)))); \n                 }\n                 case (_) {\n-                    ret false;\n+                    tcx.sess.span_err(operator.span, \"Internal error: \" +\n+                       \" ill-formed operator in predicate\");\n                 }\n             }\n         }\n+        case (_) {\n+            tcx.sess.span_err(e.span, \"Internal error: \" +\n+                              \" ill-formed predicate\");\n+        }\n+    }\n+}\n+\n+fn pred_desc_to_str(&pred_desc p) -> str {\n+    ret (\"<\" + uistr(p.node.bit_num) + \", \" + \n+         constr_args_to_str(p.node.args) + \">\");\n+}\n+\n+fn substitute_constr_args(&ty::ctxt cx,\n+                          &vec[@expr] actuals,\n+                          &vec[arg] formals, &@ast::constr c) -> constr_occ {\n+    let vec[@constr_arg] res = [];\n+    auto subst = vec::zip(formals, actuals);\n+    for (@constr_arg a in c.node.args) {\n+        res += [substitute_arg(cx, subst, a)];\n     }\n+    ret occ_args(res);\n }\n \n-fn args_eq(vec[@constr_arg] a, vec[@constr_arg] b) -> bool {\n-    let uint i = 0u;\n-    for (@constr_arg arg in a) {\n-        if (!arg_eq(arg, b.(i))) {\n-            ret false;\n+type subst = vec[tup(arg, @expr)];\n+\n+fn substitute_arg(&ty::ctxt cx, &subst subst, @ast::constr_arg a)\n+     -> @constr_arg {\n+    alt (a.node) {\n+        case (carg_ident(?i)) {\n+            ret find_arg(a.span, cx, i, subst);\n         }\n-        i += 1u;\n+        case (_) { ret a; }\n     }\n-    ret true;\n+\n }\n \n-fn match_args(&fn_ctxt fcx, vec[pred_desc] occs,\n-              vec[@constr_arg] occ) -> uint {\n-    for (pred_desc pd in occs) {\n-        if (args_eq(pd.node.args, occ)) {\n-            ret pd.node.bit_num;\n+fn find_arg(&span sp, ty::ctxt cx, ident i, subst subst) -> @constr_arg {\n+    for (tup(arg, @expr) p in subst) {\n+        if (p._0.ident == i) {\n+            alt (p._1.node) {\n+                case (expr_path(?pt, _)) {\n+                    // ??? maybe should check that pt is a local?\n+                    let option::t[ident] thing = vec::last(pt.node.idents);\n+                    assert (! option::is_none(thing));\n+                    ret @respan(p._1.span, carg_ident(option::get(thing)));\n+                }\n+                case (expr_lit(?l, _)) {\n+                    ret @respan(p._1.span, carg_lit(l));\n+                }\n+                case (_) {\n+                    cx.sess.span_err(p._1.span,\n+                                     \"Unsupported form of argument \" +\n+                                     \"in a call to a constrained function\");\n+                }\n+            }\n         }\n     }\n-    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");  \n+    cx.sess.span_err(sp, \"Constraint contains an unbound variable \" + i);\n }\n \n //"}, {"sha": "ec782e58ffde540d08bf82cb98890d140f3f0f5f", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -17,6 +17,8 @@ import aux::fn_info;\n import aux::crate_ctxt;\n import aux::num_constraints;\n import aux::constr_map;\n+import aux::constraint_info;\n+import aux::expr_to_constr;\n \n import util::common::new_def_hash;\n import util::common::uistr;\n@@ -26,8 +28,6 @@ import util::common::respan;\n type ctxt = rec(@vec[constraint_info] cs,\n                 ty::ctxt tcx);\n \n-type constraint_info = rec(def_id id, aux::constr c);\n-\n fn collect_local(&ctxt cx, &@decl d) -> () {\n     alt (d.node) {\n       case (decl_local(?loc)) {\n@@ -41,67 +41,6 @@ fn collect_local(&ctxt cx, &@decl d) -> () {\n     }\n }\n \n-fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) -> vec[@constr_arg] {\n-    fn one(ty::ctxt tcx, &@expr e) -> @constr_arg {\n-        alt (e.node) {\n-            case (expr_path(?p, _)) {\n-                if (vec::len(p.node.idents) == 1u) {\n-                    ret @respan(p.span, carg_ident(p.node.idents.(0)));\n-                }\n-                else {\n-                    tcx.sess.bug(\"exprs_to_constr_args: non-local variable \"\n-                                 + \"as pred arg\");\n-                }\n-            }\n-            case (expr_lit(?l, _)) {\n-                ret @respan(e.span, carg_lit(l));\n-            }\n-            case (_) {\n-                tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n-            }\n-        }\n-    }\n-    auto f = bind one(tcx, _);\n-    ret vec::map(f, args); \n-}\n-\n-fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n-    alt (tcx.def_map.find(t)) {\n-        case (none) {\n-            tcx.sess.bug(\"def_id_for_constr: bad node_id \" + uistr(t));\n-         }\n-        case (some(def_fn(?i))) {\n-            ret i;\n-        }\n-        case (_) {\n-            tcx.sess.bug(\"def_id_for_constr: pred is not a function\");\n-        }\n-    }\n-}\n-\n-fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constraint_info {\n-    alt (e.node) {\n-        // change the first pattern to expr_path to test a typechecker bug\n-        case (expr_call(?operator, ?args, _)) {\n-            alt (operator.node) {\n-                case (expr_path(?p, ?a)) {\n-                    ret rec(id=def_id_for_constr(tcx, a.id),\n-                            c=respan(e.span,\n-                                npred(p, exprs_to_constr_args(tcx, args)))); \n-                }\n-                case (_) {\n-                    tcx.sess.span_err(operator.span, \"Internal error: \" +\n-                       \" ill-formed operator in predicate\");\n-                }\n-            }\n-        }\n-        case (_) {\n-            tcx.sess.span_err(e.span, \"Internal error: \" +\n-                              \" ill-formed predicate\");\n-        }\n-    }\n-}\n-\n fn collect_pred(&ctxt cx, &@expr e) -> () {\n     alt (e.node) {\n         case (expr_check(?e, _)) {\n@@ -140,14 +79,14 @@ fn add_constraint(&ty::ctxt tcx, constraint_info c, uint next, constr_map tbl)\n                                          + \" as a variable and a pred\");\n                         }\n                         case (cpred(_, ?pds)) {\n-                            vec::push(pds, respan(cn.span,\n+                             vec::push(*pds, respan(cn.span,\n                               rec(args=args, bit_num=next)));\n                         }\n                     }\n                 }\n                 case (none[constraint]) {\n-                    tbl.insert(c.id, cpred(p,\n-                      [respan(cn.span, rec(args=args, bit_num=next))]));\n+                     tbl.insert(c.id, cpred(p,\n+                      @[respan(cn.span, rec(args=args, bit_num=next))]));\n                 }\n             }\n         }"}, {"sha": "6901d30b50921c5650ded5f99dd82bb1be706d9f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 126, "deletions": 183, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -50,7 +50,8 @@ type method = rec(ast::proto proto,\n                   ast::ident ident,\n                   vec[arg] inputs,\n                   t output,\n-                  controlflow cf);\n+                  controlflow cf,\n+                  vec[@ast::constr] constrs);\n \n tag any_item {\n     any_item_rust(@ast::item);\n@@ -77,7 +78,7 @@ type ty_ctxt = ctxt;    // Needed for disambiguation from unify::ctxt.\n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n fn method_ty_to_fn_ty(&ctxt cx, method m) -> t {\n-    ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf);\n+    ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n }\n \n // Never construct these manually. These are interned.\n@@ -113,7 +114,7 @@ tag sty {\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast::proto, vec[arg], t, controlflow);\n+    ty_fn(ast::proto, vec[arg], t, controlflow, vec[@ast::constr]);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n     ty_var(int);                                    // type variable\n@@ -324,7 +325,7 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n             }\n         }\n \n-        case (ty_fn(_, ?args, ?tt, _)) {\n+        case (ty_fn(_, ?args, ?tt, _, _)) {\n             derive_flags_sig(cx, has_params, has_vars, args, tt);\n         }\n \n@@ -428,8 +429,8 @@ fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty,\n-         &controlflow cf) -> t {\n-    ret gen_ty(cx, ty_fn(proto, args, ty, cf));\n+         &controlflow cf, &vec[@ast::constr] constrs) -> t {\n+    ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &vec[arg] args, &t ty) -> t {\n@@ -478,161 +479,6 @@ fn path_to_str(&ast::path pth) -> str {\n     ret result;\n }\n \n-fn ty_to_str(&ctxt cx, &t typ) -> str {\n-\n-    fn fn_input_to_str(&ctxt cx, &rec(mode mode, t ty) input) -> str {\n-        auto s;\n-        alt (input.mode) {\n-            case (mo_val) { s = \"\"; }\n-            case (mo_alias) { s = \"&\"; }\n-        }\n-\n-        ret s + ty_to_str(cx, input.ty);\n-    }\n-\n-    fn fn_to_str(&ctxt cx,\n-                 ast::proto proto,\n-                 option::t[ast::ident] ident,\n-                 vec[arg] inputs, t output) -> str {\n-            auto f = bind fn_input_to_str(cx, _);\n-\n-            auto s;\n-            alt (proto) {\n-                case (ast::proto_iter) {\n-                    s = \"iter\";\n-                }\n-                case (ast::proto_fn) {\n-                    s = \"fn\";\n-                }\n-            }\n-\n-            alt (ident) {\n-                case (some(?i)) {\n-                    s += \" \";\n-                    s += i;\n-                }\n-                case (_) { }\n-            }\n-\n-            s += \"(\";\n-            s += str::connect(vec::map[arg,str](f, inputs), \", \");\n-            s += \")\";\n-\n-            if (struct(cx, output) != ty_nil) {\n-                s += \" -> \" + ty_to_str(cx, output);\n-            }\n-            ret s;\n-    }\n-\n-    fn method_to_str(&ctxt cx, &method m) -> str {\n-        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident),\n-                      m.inputs, m.output) + \";\";\n-    }\n-\n-    fn field_to_str(&ctxt cx, &field f) -> str {\n-        ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n-    }\n-\n-    fn mt_to_str(&ctxt cx, &mt m) -> str {\n-        auto mstr;\n-        alt (m.mut) {\n-            case (ast::mut)       { mstr = \"mutable \"; }\n-            case (ast::imm)       { mstr = \"\";         }\n-            case (ast::maybe_mut) { mstr = \"mutable? \"; }\n-        }\n-\n-        ret mstr + ty_to_str(cx, m.ty);\n-    }\n-\n-    alt (cname(cx, typ)) {\n-        case (some(?cs)) { ret cs; }\n-        case (_) { /* fall through */ }\n-    }\n-\n-    auto s = \"\";\n-\n-    alt (struct(cx, typ)) {\n-        case (ty_native)       { s += \"native\";                         }\n-        case (ty_nil)          { s += \"()\";                             }\n-        case (ty_bot)          { s += \"_|_\";                            }\n-        case (ty_bool)         { s += \"bool\";                           }\n-        case (ty_int)          { s += \"int\";                            }\n-        case (ty_float)        { s += \"float\";                          }\n-        case (ty_uint)         { s += \"uint\";                           }\n-        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm);        }\n-        case (ty_char)         { s += \"char\";                           }\n-        case (ty_str)          { s += \"str\";                            }\n-        case (ty_box(?tm))     { s += \"@\" + mt_to_str(cx, tm);          }\n-        case (ty_ptr(?tm))     { s += \"*\" + mt_to_str(cx, tm);          }\n-        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n-        case (ty_port(?t))     { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n-        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n-        case (ty_type)         { s += \"type\";                           }\n-        case (ty_task)         { s += \"task\";                           }\n-\n-        case (ty_tup(?elems)) {\n-            auto f = bind mt_to_str(cx, _);\n-            auto strs = vec::map[mt,str](f, elems);\n-            s += \"tup(\" + str::connect(strs, \",\") + \")\";\n-        }\n-\n-        case (ty_rec(?elems)) {\n-            auto f = bind field_to_str(cx, _);\n-            auto strs = vec::map[field,str](f, elems);\n-            s += \"rec(\" + str::connect(strs, \",\") + \")\";\n-        }\n-\n-        case (ty_tag(?id, ?tps)) {\n-            // The user should never see this if the cname is set properly!\n-            s += \"<tag#\" + util::common::istr(id._0) + \":\" +\n-                util::common::istr(id._1) + \">\";\n-            if (vec::len[t](tps) > 0u) {\n-                auto f = bind ty_to_str(cx, _);\n-                auto strs = vec::map[t,str](f, tps);\n-                s += \"[\" + str::connect(strs, \",\") + \"]\";\n-            }\n-        }\n-\n-        case (ty_fn(?proto, ?inputs, ?output, _)) {\n-            s += fn_to_str(cx, proto, none[ast::ident], inputs, output);\n-        }\n-\n-        case (ty_native_fn(_, ?inputs, ?output)) {\n-            s += fn_to_str(cx, ast::proto_fn, none[ast::ident],\n-                           inputs, output);\n-        }\n-\n-        case (ty_obj(?meths)) {\n-            auto f = bind method_to_str(cx, _);\n-            auto m = vec::map[method,str](f, meths);\n-            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n-        }\n-\n-        case (ty_var(?v)) {\n-            s += \"<T\" + util::common::istr(v) + \">\";\n-        }\n-\n-        case (ty_param(?id)) {\n-            s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n-        }\n-\n-        case (_) {\n-            s += ty_to_short_str(cx, typ);\n-        }\n-\n-    }\n-\n-    ret s;\n-}\n-\n-fn ty_to_short_str(&ctxt cx, t typ) -> str {\n-    auto f = def_to_str;\n-    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::ac_no_abbrevs);\n-    auto s = metadata::Encode::ty_str(ecx, typ);\n-    if (str::byte_len(s) >= 32u) { s = str::substr(s, 0u, 32u); }\n-    ret s;\n-}\n-\n // Type folds\n \n type ty_walk = fn(t);\n@@ -669,7 +515,7 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n                 walk_ty(cx, walker, fl.mt.ty);\n             }\n         }\n-        case (ty_fn(?proto, ?args, ?ret_ty, _)) {\n+        case (ty_fn(?proto, ?args, ?ret_ty, _, _)) {\n             for (arg a in args) {\n                 walk_ty(cx, walker, a.ty);\n             }\n@@ -768,14 +614,14 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             }\n             ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n         }\n-        case (ty_fn(?proto, ?args, ?ret_ty, ?cf)) {\n+        case (ty_fn(?proto, ?args, ?ret_ty, ?cf, ?constrs)) {\n             let vec[arg] new_args = [];\n             for (arg a in args) {\n                 auto new_ty = fold_ty(cx, fld, a.ty);\n                 new_args += [rec(mode=a.mode, ty=new_ty)];\n             }\n             ty = copy_cname(cx, mk_fn(cx, proto, new_args,\n-                                      fold_ty(cx, fld, ret_ty), cf), ty);\n+                                  fold_ty(cx, fld, ret_ty), cf, constrs), ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = [];\n@@ -796,7 +642,8 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n                 }\n                 new_methods += [rec(proto=m.proto, ident=m.ident,\n                                inputs=new_args,\n-                               output=fold_ty(cx, fld, m.output), cf=m.cf)];\n+                               output=fold_ty(cx, fld, m.output),\n+                               cf=m.cf, constrs=m.constrs)];\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n@@ -860,7 +707,7 @@ fn type_is_structural(&ctxt cx, &t ty) -> bool {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n         case (ty_tag(_,_))  { ret true; }\n-        case (ty_fn(_,_,_,_)) { ret true; }\n+        case (ty_fn(_,_,_,_,_)) { ret true; }\n         case (ty_obj(_))    { ret true; }\n         case (_)            { ret false; }\n     }\n@@ -1177,7 +1024,8 @@ fn hash_type_structure(&sty st) -> uint {\n             }\n             ret h;\n         }\n-        case (ty_fn(_, ?args, ?rty, _)) { ret hash_fn(25u, args, rty); }\n+        // ???\n+        case (ty_fn(_, ?args, ?rty, _, _)) { ret hash_fn(25u, args, rty); } \n         case (ty_native_fn(_, ?args, ?rty)) { ret hash_fn(26u, args, rty); }\n         case (ty_obj(?methods)) {\n             auto h = 27u;\n@@ -1211,6 +1059,72 @@ fn hash_ty(&t typ) -> uint { ret typ; }\n \n // Type equality. This function is private to this module (and slow); external\n // users should use `eq_ty()` instead.\n+\n+fn arg_eq(@ast::constr_arg a, @ast::constr_arg b) -> bool {\n+    alt (a.node) {\n+        case (ast::carg_base) {\n+            alt (b.node) {\n+                case (ast::carg_base) {\n+                    ret true;\n+                }\n+                case (_) {\n+                    ret false;\n+                }\n+            }\n+        }\n+        case (ast::carg_ident(?s)) {\n+            alt (b.node) {\n+                case (ast::carg_ident(?t)) {\n+                    ret (s == t);\n+                }\n+                case (_) {\n+                    ret false;\n+                }\n+            }\n+        }\n+        case (ast::carg_lit(?l)) {\n+            alt (b.node) {\n+                case (ast::carg_lit(?m)) {\n+                    ret util::common::lit_eq(l, m);\n+                }\n+                case (_) {\n+                    ret false;\n+                }\n+            }\n+        }\n+    }\n+}\n+fn args_eq(vec[@ast::constr_arg] a, vec[@ast::constr_arg] b) -> bool {\n+    let uint i = 0u;\n+    for (@ast::constr_arg arg in a) {\n+        if (!arg_eq(arg, b.(i))) {\n+            ret false;\n+        }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+\n+fn constr_eq(&@ast::constr c, &@ast::constr d) -> bool {\n+    ret path_to_str(c.node.path) == path_to_str(d.node.path) // FIXME: hack\n+        && args_eq(c.node.args, d.node.args);\n+}\n+\n+fn constrs_eq(&vec[@ast::constr] cs, &vec[@ast::constr] ds) -> bool {\n+    if (vec::len(cs) != vec::len(ds)) {\n+        ret false;\n+    }\n+    auto i = 0;\n+    for (@ast::constr c in cs) {\n+        if (!constr_eq(c, ds.(i))) {\n+            ret false;\n+        }\n+        i += 1;\n+    }\n+    ret true;\n+}\n+\n fn equal_type_structures(&sty a, &sty b) -> bool {\n     fn equal_mt(&mt a, &mt b) -> bool {\n         ret a.mut == b.mut && eq_ty(a.ty, b.ty);\n@@ -1381,11 +1295,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_fn(?p_a, ?args_a, ?rty_a, ?cf_a)) {\n+        case (ty_fn(?p_a, ?args_a, ?rty_a, ?cf_a, ?constrs_a)) {\n             alt (b) {\n-                case (ty_fn(?p_b, ?args_b, ?rty_b, ?cf_b)) {\n+                case (ty_fn(?p_b, ?args_b, ?rty_b, ?cf_b, ?constrs_b)) {\n                     ret p_a == p_b &&\n                         cf_a == cf_b &&\n+                        constrs_eq(constrs_a, constrs_b) &&\n                         equal_fn(args_a, rty_a, args_b, rty_b);\n                 }\n                 case (_) { ret false; }\n@@ -1576,15 +1491,15 @@ fn type_contains_params(&ctxt cx, &t typ) -> bool {\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(_, ?a, _, _)) { ret a; }\n+        case (ty::ty_fn(_, ?a, _, _, _)) { ret a; }\n         case (ty::ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     cx.sess.bug(\"ty_fn_args() called on non-fn type\");\n }\n \n fn ty_fn_proto(&ctxt cx, &t fty) -> ast::proto {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(?p, _, _, _)) { ret p; }\n+        case (ty::ty_fn(?p, _, _, _, _)) { ret p; }\n     }\n     cx.sess.bug(\"ty_fn_proto() called on non-fn type\");\n }\n@@ -1598,15 +1513,15 @@ fn ty_fn_abi(&ctxt cx, &t fty) -> ast::native_abi {\n \n fn ty_fn_ret(&ctxt cx, &t fty) -> t {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(_, _, ?r, _)) { ret r; }\n+        case (ty::ty_fn(_, _, ?r, _, _)) { ret r; }\n         case (ty::ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     cx.sess.bug(\"ty_fn_ret() called on non-fn type\");\n }\n \n fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n     alt (struct(cx, fty)) {\n-        case (ty::ty_fn(_, _, _, _)) { ret true; }\n+        case (ty::ty_fn(_, _, _, _, _)) { ret true; }\n         case (ty::ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n     }\n@@ -2012,7 +1927,9 @@ mod unify {\n                 &t actual,\n                 &vec[arg] expected_inputs, &t expected_output,\n                 &vec[arg] actual_inputs, &t actual_output,\n-                &controlflow expected_cf, &controlflow actual_cf)\n+                &controlflow expected_cf, &controlflow actual_cf,\n+                &vec[@ast::constr] expected_constrs,\n+                &vec[@ast::constr] actual_constrs)\n         -> result {\n \n         if (e_proto != a_proto) {\n@@ -2045,7 +1962,7 @@ mod unify {\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n                 auto t2 = mk_fn(cx.tcx, e_proto, result_ins, result_out,\n-                                actual_cf);\n+                                actual_cf, actual_constrs);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -2099,14 +2016,16 @@ mod unify {\n                           expected, actual,\n                           e_meth.inputs, e_meth.output,\n                           a_meth.inputs, a_meth.output,\n-                          e_meth.cf, a_meth.cf);\n+                          e_meth.cf, a_meth.cf,\n+                          e_meth.constrs, a_meth.constrs);\n         alt (r) {\n             case (ures_ok(?tfn)) {\n                 alt (struct(cx.tcx, tfn)) {\n-                    case (ty_fn(?proto, ?ins, ?out, ?cf)) {\n+                    case (ty_fn(?proto, ?ins, ?out, ?cf, ?constrs)) {\n                         result_meths += [rec(inputs = ins,\n                                              output = out,\n-                                             cf     = cf\n+                                             cf     = cf,\n+                                             constrs = constrs\n                                              with e_meth)];\n                     }\n                 }\n@@ -2486,15 +2405,18 @@ mod unify {\n             }\n \n             case (ty::ty_fn(?ep, ?expected_inputs,\n-                            ?expected_output, ?expected_cf)) {\n+                            ?expected_output, ?expected_cf,\n+                            ?expected_constrs)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_fn(?ap, ?actual_inputs,\n-                                    ?actual_output, ?actual_cf)) {\n+                                    ?actual_output, ?actual_cf,\n+                                    ?actual_constrs)) {\n                         ret unify_fn(cx, ep, ap,\n                                      expected, actual,\n                                      expected_inputs, expected_output,\n                                      actual_inputs, actual_output,\n-                                     expected_cf, actual_cf);\n+                                     expected_cf, actual_cf,\n+                                     expected_constrs, actual_constrs);\n                     }\n \n                     case (_) { ret ures_err(terr_mismatch); }\n@@ -2549,7 +2471,7 @@ mod unify {\n             alt (smallintmap::find[t](vb.types, i)) {\n                 case (none[t]) { typespec = \"\"; }\n                 case (some[t](?typ)) {\n-                    typespec = \" =\" + ty_to_str(tcx, typ);\n+                    typespec = \" =\" + pretty::ppaux::ty_to_str(tcx, typ);\n                 }\n             }\n \n@@ -2784,7 +2706,7 @@ fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n \n fn ret_ty_of_fn_ty(ctxt cx, t a_ty) -> t {\n     alt (ty::struct(cx, a_ty)) {\n-        case (ty::ty_fn(_, _, ?ret_ty, _)) {\n+        case (ty::ty_fn(_, _, ?ret_ty, _, _)) {\n             ret ret_ty;\n         }\n         case (_) {\n@@ -2797,6 +2719,27 @@ fn ret_ty_of_fn(ctxt cx, ast::ann ann) -> t {\n     ret ret_ty_of_fn_ty(cx, ann_to_type(cx, ann));\n }\n \n+fn lookup_fn_decl(ty_ctxt tcx, ast::ann ann)\n+    -> option::t[tup(ast::fn_decl, ast::def_id)] {\n+    auto nada = none[tup(ast::fn_decl, ast::def_id)];\n+    alt (tcx.def_map.find(ann.id)) {\n+        case (some(ast::def_fn(?d))) {\n+            alt (tcx.items.find(d)) {\n+                case (some(any_item_rust(?it))) {\n+                    alt (it.node) {\n+                        case (ast::item_fn(_,?f,_,_,_)) {\n+                            ret some(tup(f.decl, d));\n+                        }\n+                        case (_) { ret nada; }\n+                    }\n+                }\n+                case (_) { ret nada; }\n+            }\n+        }\n+        case (_) { ret nada; }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "01e66afd8d1c8f4e3fef111e1e6b0492cd7d8eca", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -22,7 +22,7 @@ import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::path_to_str;\n import middle::ty::ty_param_substs_opt_and_ty;\n-import middle::ty::ty_to_str;\n+import pretty::ppaux::ty_to_str;\n import middle::ty::ty_param_count_and_ty;\n import middle::ty::ty_nil;\n import middle::ty::unify::ures_ok;\n@@ -45,6 +45,8 @@ import std::option::from_maybe;\n \n import middle::tstate::ann::ts_ann;\n \n+import pretty::ppaux::ty_to_str;\n+\n type ty_table = hashmap[ast::def_id, ty::t];\n type fn_purity_table = hashmap[ast::def_id, ast::purity];\n \n@@ -305,11 +307,11 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             typ = ty::mk_rec(tcx, flds);\n         }\n \n-        case (ast::ty_fn(?proto, ?inputs, ?output, ?cf)) {\n+        case (ast::ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             auto i = vec::map[ast::ty_arg, arg](f, inputs);\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n-            typ = ty::mk_fn(tcx, proto, i, out_ty, cf);\n+            typ = ty::mk_fn(tcx, proto, i, out_ty, cf, constrs);\n         }\n \n         case (ast::ty_path(?path, ?ann)) {\n@@ -342,7 +344,8 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                                       ident=m.node.ident,\n                                       inputs=ins,\n                                       output=out,\n-                                      cf=m.node.cf);\n+                                      cf=m.node.cf,\n+                                      constrs=m.node.constrs);\n                 vec::push[ty::method](tmeths, new_m);\n             }\n \n@@ -452,7 +455,8 @@ mod collect {\n                      &ast::def_id def_id) -> ty::ty_param_count_and_ty {\n         auto input_tys = vec::map[ast::arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n-        auto t_fn = ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf);\n+        auto t_fn = ty::mk_fn(cx.tcx, proto, input_tys, output_ty,\n+                              decl.cf, decl.constraints);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.tcx.tcache.insert(def_id, tpt);\n@@ -507,7 +511,8 @@ mod collect {\n         auto inputs = vec::map[ast::arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n-                inputs=inputs, output=output, cf=m.node.meth.decl.cf);\n+                inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n+                constrs=m.node.meth.decl.constraints);\n     }\n \n     fn ty_of_obj(@ctxt cx,\n@@ -536,8 +541,9 @@ mod collect {\n             vec::push[arg](t_inputs, rec(mode=ty::mo_alias, ty=t_field));\n         }\n \n+        let vec[@ast::constr] constrs = [];\n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n-                              ast::return);\n+                              ast::return, constrs);\n \n         auto tpt = tup(t_obj._0, t_fn);\n         cx.tcx.tcache.insert(ctor_id, tpt);\n@@ -668,8 +674,10 @@ mod collect {\n                     args += [rec(mode=ty::mo_alias, ty=arg_ty)];\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n+                // FIXME: this will be different for constrained types\n+                let vec[@ast::constr] res_constrs = [];\n                 result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n-                                      ast::return);\n+                                      ast::return, res_constrs);\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n@@ -766,10 +774,10 @@ mod collect {\n                 alt (object.dtor) {\n                     case (none) { /* nothing to do */ }\n                     case (some(?m)) {\n-                        // TODO: typechecker botch\n-                        let vec[arg] no_args = [];\n-                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n-                                           ty::mk_nil(cx.tcx), ast::return);\n+                        let vec[@ast::constr] constrs = [];\n+                        let vec[arg] res_inputs  = [];\n+                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, res_inputs,\n+                                   ty::mk_nil(cx.tcx), ast::return, constrs);\n                         write::ty_only(cx.tcx, m.node.ann.id, t);\n                     }\n                 }\n@@ -970,7 +978,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n \n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (ty::struct(ccx.tcx, tpt._1)) {\n-        case (ty::ty_fn(_, ?ins, _, _)) {\n+        case (ty::ty_fn(_, ?ins, _, _, _)) {\n             // N-ary variant.\n             for (ty::arg arg in ins) {\n                 auto arg_ty = ty::substitute_type_params(ccx.tcx,\n@@ -1290,7 +1298,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                     // can never tell.\n                     fcx.ccx.tcx.sess.span_err(pat.span,\n                         #fmt(\"mismatched types: expected tag but found %s\",\n-                             ty::ty_to_str(fcx.ccx.tcx, expected)));\n+                             ty_to_str(fcx.ccx.tcx, expected)));\n                 }\n             }\n \n@@ -1422,7 +1430,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         // Grab the argument types and the return type.\n         auto arg_tys;\n         alt (structure_of(fcx, sp, fty)) {\n-            case (ty::ty_fn(_, ?arg_tys_0, _, _)) {\n+            case (ty::ty_fn(_, ?arg_tys_0, _, _, _)) {\n                 arg_tys = arg_tys_0;\n             }\n             case (ty::ty_native_fn(_, ?arg_tys_0, _)) {\n@@ -1886,10 +1894,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto t_1;\n             alt (structure_of(fcx, expr.span, fty)) {\n-                case (ty::ty_fn(?proto, ?arg_tys, ?rt, ?cf)) {\n+                case (ty::ty_fn(?proto, ?arg_tys, ?rt, ?cf, ?constrs)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n \n+                    // FIXME:\n+                    // probably need to munge the constrs to drop constraints\n+                    // for any bound args\n+\n                     // For each blank argument, add the type of that argument\n                     // to the resulting function type.\n                     auto i = 0u;\n@@ -1903,7 +1915,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         i += 1u;\n                     }\n                     t_1 = ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1,\n-                                    cf);\n+                                    cf, constrs);\n                 }\n                 case (_) {\n                     log_err \"LHS of bind expr didn't have a function type?!\";\n@@ -1923,10 +1935,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             check_call(fcx, expr.span, f, args);\n \n             // Pull the return type out of the type of the function.\n-            auto rt_1 = ty::mk_nil(fcx.ccx.tcx); // FIXME: typestate botch\n+            auto rt_1; // = ty::mk_nil(fcx.ccx.tcx); // FIXME: typestate botch\n             auto fty = ty::expr_ty(fcx.ccx.tcx, f);\n             alt (structure_of(fcx, expr.span, fty)) {\n-                case (ty::ty_fn(_,_,?rt,_))         { rt_1 = rt; }\n+                case (ty::ty_fn(_,_,?rt,_, _))         { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt))  { rt_1 = rt; }\n                 case (_) {\n                     log_err \"LHS of call expr didn't have a function type?!\";\n@@ -2134,7 +2146,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     }\n                     auto meth = methods.(ix);\n                     auto t = ty::mk_fn(fcx.ccx.tcx, meth.proto,\n-                                       meth.inputs, meth.output, meth.cf);\n+                                       meth.inputs, meth.output, meth.cf,\n+                                       meth.constrs);\n                     write::ty_only_fixup(fcx, a.id, t);\n                 }\n \n@@ -2254,7 +2267,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                      m.node.meth.decl.inputs);\n                 auto output = convert(m.node.meth.decl.output);\n                 ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n-                        inputs=inputs, output=output, cf=m.node.meth.decl.cf);\n+                        inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n+                        constrs=m.node.meth.decl.constraints);\n             }\n \n             fn get_anon_obj_method_types(@crate_ctxt ccx,"}, {"sha": "ce1b2a336d7fc59bffb76c1ba4dc4c6a70d2e6c2", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -115,7 +115,7 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n                 vt(v).visit_ty(f.node.mt.ty, e, v);\n             }\n         }\n-        case (ty_fn(_, ?args, ?out, _)) {\n+        case (ty_fn(_, ?args, ?out, _, _)) {\n             for (ty_arg a in args) {\n                 vt(v).visit_ty(a.node.ty, e, v);\n             }"}, {"sha": "d1101bcfcd8b7de836beedae8138daa5423b2108", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -170,7 +170,7 @@ fn walk_ty(&ast_visitor v, @ast::ty t) {\n                 walk_ty(v, f.node.mt.ty);\n             }\n         }\n-        case (ast::ty_fn(_, ?args, ?out, _)) {\n+        case (ast::ty_fn(_, ?args, ?out, _, _)) {\n             for (ast::ty_arg a in args) {\n                 walk_ty(v, a.node.ty);\n             }"}, {"sha": "694291dcca9b4655192d1bafa93f51d49c487bc1", "filename": "src/comp/pretty/ppaux.rs", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -0,0 +1,438 @@\n+import std::io;\n+import middle::ty::*;\n+import front::ast::constr_arg;\n+import front::lexer;\n+import pp::word;\n+import pp::eof;\n+import pp::zerobreak;\n+import pp::hardbreak;\n+import front::codemap;\n+import front::codemap::codemap;\n+\n+fn ty_to_str(&ctxt cx, &t typ) -> str {\n+\n+  fn fn_input_to_str(&ctxt cx,\n+                     &rec(middle::ty::mode mode, t ty) input) -> str {\n+        auto s;\n+        alt (input.mode) {\n+            case (mo_val) { s = \"\"; }\n+            case (mo_alias) { s = \"&\"; }\n+        }\n+\n+        ret s + ty_to_str(cx, input.ty);\n+    }\n+\n+    fn fn_to_str(&ctxt cx,\n+                 ast::proto proto,\n+                 option::t[ast::ident] ident,\n+                 vec[arg] inputs, t output, ast::controlflow cf,\n+                 &vec[@ast::constr] constrs) -> str {\n+            auto f = bind fn_input_to_str(cx, _);\n+\n+            auto s;\n+            alt (proto) {\n+                case (ast::proto_iter) {\n+                    s = \"iter\";\n+                }\n+                case (ast::proto_fn) {\n+                    s = \"fn\";\n+                }\n+            }\n+\n+            alt (ident) {\n+                case (some(?i)) {\n+                    s += \" \";\n+                    s += i;\n+                }\n+                case (_) { }\n+            }\n+\n+            s += \"(\";\n+            s += str::connect(vec::map[arg,str](f, inputs), \", \");\n+            s += \")\";\n+\n+            if (struct(cx, output) != ty_nil) {\n+                alt (cf) {\n+                    case (ast::noreturn) {\n+                        s += \" -> !\";\n+                    }\n+                    case (ast::return) {\n+                        s += \" -> \" + ty_to_str(cx, output);\n+                    }\n+                }\n+            }\n+\n+            s += constrs_str(constrs);\n+            ret s;\n+    }\n+\n+    fn method_to_str(&ctxt cx, &method m) -> str {\n+        ret fn_to_str(cx, m.proto, some[ast::ident](m.ident),\n+                      m.inputs, m.output, m.cf, m.constrs) + \";\";\n+    }\n+\n+    fn field_to_str(&ctxt cx, &field f) -> str {\n+        ret mt_to_str(cx, f.mt) + \" \" + f.ident;\n+    }\n+\n+    fn mt_to_str(&ctxt cx, &mt m) -> str {\n+        auto mstr;\n+        alt (m.mut) {\n+            case (ast::mut)       { mstr = \"mutable \"; }\n+            case (ast::imm)       { mstr = \"\";         }\n+            case (ast::maybe_mut) { mstr = \"mutable? \"; }\n+        }\n+\n+        ret mstr + ty_to_str(cx, m.ty);\n+    }\n+\n+    alt (cname(cx, typ)) {\n+        case (some(?cs)) {\n+            ret cs;\n+        }\n+        case (_) { }\n+    }\n+\n+    auto s = \"\";\n+\n+    alt (struct(cx, typ)) {\n+        case (ty_native)       { s += \"native\";                         }\n+        case (ty_nil)          { s += \"()\";                             }\n+        case (ty_bot)          { s += \"_|_\";                            }\n+        case (ty_bool)         { s += \"bool\";                           }\n+        case (ty_int)          { s += \"int\";                            }\n+        case (ty_float)        { s += \"float\";                          }\n+        case (ty_uint)         { s += \"uint\";                           }\n+        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm);        }\n+        case (ty_char)         { s += \"char\";                           }\n+        case (ty_str)          { s += \"str\";                            }\n+        case (ty_box(?tm))     { s += \"@\" + mt_to_str(cx, tm);          }\n+        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n+        case (ty_port(?t))     { s += \"port[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(cx, t) + \"]\"; }\n+        case (ty_type)         { s += \"type\";                           }\n+        case (ty_task)         { s += \"task\";                           }\n+\n+        case (ty_tup(?elems)) {\n+            auto f = bind mt_to_str(cx, _);\n+            auto strs = vec::map[mt,str](f, elems);\n+            s += \"tup(\" + str::connect(strs, \",\") + \")\";\n+        }\n+\n+        case (ty_rec(?elems)) {\n+            auto f = bind field_to_str(cx, _);\n+            auto strs = vec::map[field,str](f, elems);\n+            s += \"rec(\" + str::connect(strs, \",\") + \")\";\n+        }\n+\n+        case (ty_tag(?id, ?tps)) {\n+            // The user should never see this if the cname is set properly!\n+            s += \"<tag#\" + util::common::istr(id._0) + \":\" +\n+                util::common::istr(id._1) + \">\";\n+            if (vec::len[t](tps) > 0u) {\n+                auto f = bind ty_to_str(cx, _);\n+                auto strs = vec::map[t,str](f, tps);\n+                s += \"[\" + str::connect(strs, \",\") + \"]\";\n+            }\n+        }\n+\n+        case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n+            s += fn_to_str(cx, proto, none[ast::ident], inputs, output, cf,\n+                           constrs);\n+        }\n+\n+        case (ty_native_fn(_, ?inputs, ?output)) {\n+          let vec[@ast::constr] constrs = [];\n+            s += fn_to_str(cx, ast::proto_fn, none[ast::ident],\n+                           inputs, output, ast::return, constrs);\n+        }\n+\n+        case (ty_obj(?meths)) {\n+            auto f = bind method_to_str(cx, _);\n+            auto m = vec::map[method,str](f, meths);\n+            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n+        }\n+\n+        case (ty_var(?v)) {\n+            s += \"<T\" + util::common::istr(v) + \">\";\n+        }\n+\n+        case (ty_param(?id)) {\n+            s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n+        }\n+\n+        case (_) {\n+            s += ty_to_short_str(cx, typ);\n+        }\n+\n+    }\n+\n+    ret s;\n+}\n+\n+\n+fn ty_to_short_str(&ctxt cx, t typ) -> str {\n+    auto f = def_to_str;\n+    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::ac_no_abbrevs);\n+    auto s = metadata::Encode::ty_str(ecx, typ);\n+    if (str::byte_len(s) >= 32u) { s = str::substr(s, 0u, 32u); }\n+    ret s;\n+}\n+\n+fn constr_arg_to_str(&ast::constr_arg_ c) -> str {\n+    alt (c) {\n+        case (ast::carg_base) {\n+            ret \"*\";\n+        }\n+        case (ast::carg_ident(?i)) {\n+            ret i;\n+        }\n+        case (ast::carg_lit(?l)) {\n+            ret lit_to_str(l);\n+        }\n+    }\n+}\n+\n+\n+fn constr_args_to_str(&vec[@constr_arg] args) -> str {\n+    auto comma = false;\n+    auto s   = \"(\";\n+    for (@constr_arg a in args) {\n+        if (comma) {\n+            s += \", \";\n+        }\n+        else {\n+            comma = true;\n+        }\n+        s += constr_arg_to_str(a.node);\n+    }\n+    s += \")\";\n+    ret s;\n+}\n+\n+fn print_literal(&ps s, &@ast::lit lit) {\n+    maybe_print_comment(s, lit.span.lo);\n+\n+    alt (next_lit(s)) {\n+        case (some(?lt)) {\n+            if (lt.pos == lit.span.lo) {\n+                word(s.s, lt.lit);\n+                s.cur_lit += 1u;\n+                ret;\n+            }\n+        }\n+        case (_) {}\n+    }\n+\n+    alt (lit.node) {\n+        case (ast::lit_str(?st)) {print_string(s, st);}\n+        case (ast::lit_char(?ch)) {\n+            word(s.s, \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'')\n+                + \"'\");\n+        }\n+        case (ast::lit_int(?val)) {\n+            word(s.s, common::istr(val));\n+        }\n+        case (ast::lit_uint(?val)) {\n+            word(s.s, common::uistr(val) + \"u\");\n+        }\n+        case (ast::lit_float(?fstr)) {\n+            word(s.s, fstr);\n+        }\n+        case (ast::lit_mach_int(?mach,?val)) {\n+            word(s.s, common::istr(val as int));\n+            word(s.s, common::ty_mach_to_str(mach));\n+        }\n+        case (ast::lit_mach_float(?mach,?val)) {\n+            // val is already a str\n+            word(s.s, val);\n+            word(s.s, common::ty_mach_to_str(mach));\n+        }\n+        case (ast::lit_nil) {word(s.s, \"()\");}\n+        case (ast::lit_bool(?val)) {\n+            if (val) {word(s.s, \"true\");} else {word(s.s, \"false\");}\n+        }\n+    }\n+}\n+\n+fn lit_to_str(&@ast::lit l) -> str { be to_str(l, print_literal); }\n+\n+fn next_lit(&ps s) -> option::t[lexer::lit] {\n+    alt (s.literals) {\n+        case (some(?lits)) {\n+            if (s.cur_lit < vec::len(lits)) {\n+                ret some(lits.(s.cur_lit));\n+            } else {ret none[lexer::lit];}\n+        }\n+        case (_) {ret none[lexer::lit];}\n+    }\n+}\n+\n+fn maybe_print_comment(&ps s, uint pos) {\n+    while (true) {\n+        alt (next_comment(s)) {\n+            case (some(?cmnt)) {\n+                if (cmnt.pos < pos) {\n+                    print_comment(s, cmnt);\n+                    s.cur_cmnt += 1u;\n+                } else { break; }\n+            }\n+            case (_) {break;}\n+        }\n+    }\n+}\n+\n+\n+fn print_comment(&ps s, lexer::cmnt cmnt) {\n+    alt (cmnt.style) {\n+        case (lexer::mixed) {\n+            assert vec::len(cmnt.lines) == 1u;\n+            zerobreak(s.s);\n+            word(s.s, cmnt.lines.(0));\n+            zerobreak(s.s);\n+        }\n+\n+        case (lexer::isolated) {\n+            hardbreak(s.s);\n+            ibox(s, 0u);\n+            for (str line in cmnt.lines) {\n+                word(s.s, line);\n+                hardbreak(s.s);\n+            }\n+            end(s);\n+        }\n+\n+        case (lexer::trailing) {\n+            word(s.s, \" \");\n+            if (vec::len(cmnt.lines) == 1u) {\n+                word(s.s, cmnt.lines.(0));\n+                hardbreak(s.s);\n+            } else {\n+                ibox(s, 0u);\n+                for (str line in cmnt.lines) {\n+                    word(s.s, line);\n+                    hardbreak(s.s);\n+                }\n+                end(s);\n+            }\n+        }\n+    }\n+}\n+\n+fn print_string(&ps s, &str st) {\n+    word(s.s, \"\\\"\"); word(s.s, escape_str(st, '\"')); word(s.s, \"\\\"\");\n+}\n+\n+\n+fn escape_str(str st, char to_escape) -> str {\n+    let str out = \"\";\n+    auto len = str::byte_len(st);\n+    auto i = 0u;\n+    while (i < len) {\n+        alt (st.(i) as char) {\n+            case ('\\n') {out += \"\\\\n\";}\n+            case ('\\t') {out += \"\\\\t\";}\n+            case ('\\r') {out += \"\\\\r\";}\n+            case ('\\\\') {out += \"\\\\\\\\\";}\n+            case (?cur) {\n+                if (cur == to_escape) {out += \"\\\\\";}\n+                // FIXME some (or all?) non-ascii things should be escaped\n+                str::push_char(out, cur);\n+            }\n+        }\n+        i += 1u;\n+    }\n+    ret out;\n+}\n+\n+fn to_str[T](&T t, fn(&ps s, &T s) f) -> str {\n+    auto writer = io::string_writer();\n+    auto s = rust_printer(writer.get_writer());\n+    f(s, t);\n+    eof(s.s);\n+    ret writer.get_str();\n+}\n+\n+\n+fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n+    alt (s.comments) {\n+        case (some(?cmnts)) {\n+            if (s.cur_cmnt < vec::len(cmnts)) {\n+                ret some(cmnts.(s.cur_cmnt));\n+            } else {ret none[lexer::cmnt];}\n+        }\n+        case (_) {ret none[lexer::cmnt];}\n+    }\n+}\n+\n+type ps = @rec(pp::printer s,\n+               option::t[codemap] cm,\n+               option::t[vec[lexer::cmnt]] comments,\n+               option::t[vec[lexer::lit]] literals,\n+               mutable uint cur_cmnt,\n+               mutable uint cur_lit,\n+               mutable vec[pp::breaks] boxes,\n+               mode mode);\n+\n+fn ibox(&ps s, uint u) {\n+    vec::push(s.boxes, pp::inconsistent);\n+    pp::ibox(s.s, u);\n+}\n+\n+fn end(&ps s) {\n+    vec::pop(s.boxes);\n+    pp::end(s.s);\n+}\n+\n+tag mode {\n+    mo_untyped;\n+    mo_typed(ctxt);\n+    mo_identified;\n+}\n+\n+fn rust_printer(io::writer writer) -> ps {\n+    let vec[pp::breaks] boxes = [];\n+    ret @rec(s=pp::mk_printer(writer, default_columns),\n+             cm=none[codemap],\n+             comments=none[vec[lexer::cmnt]],\n+             literals=none[vec[lexer::lit]],\n+             mutable cur_cmnt=0u,\n+             mutable cur_lit=0u,\n+             mutable boxes=boxes,\n+             mode=mo_untyped);\n+}\n+\n+const uint indent_unit = 4u;\n+const uint default_columns = 78u;\n+\n+fn constr_to_str(&@ast::constr c) -> str {\n+  ret path_to_str(c.node.path)\n+    + constr_args_to_str(c.node.args);\n+}\n+\n+fn constrs_str(&vec[@ast::constr] constrs) -> str {\n+  auto s = \"\";\n+  auto colon = true;\n+  for (@ast::constr c in constrs) {\n+    if (colon) {\n+      s += \" : \";\n+      colon = false;\n+    }\n+    else {\n+      s += \", \";\n+    }\n+    s += constr_to_str(c);\n+  }\n+  ret s;\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "2fd0356365bd830192656bdf4f13684f9e618d7b", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 10, "deletions": 200, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -4,13 +4,12 @@ import std::str;\n import std::io;\n import std::option;\n import driver::session::session;\n-import front::ast;\n import front::lexer;\n import front::codemap;\n import front::codemap::codemap;\n+import front::ast;\n import middle::ty;\n import util::common;\n-import pp;\n \n import option::some;\n import option::none;\n@@ -27,44 +26,7 @@ import pp::breaks;\n import pp::consistent;\n import pp::inconsistent;\n import pp::eof;\n-\n-const uint indent_unit = 4u;\n-const uint default_columns = 78u;\n-\n-tag mode {\n-    mo_untyped;\n-    mo_typed(ty::ctxt);\n-    mo_identified;\n-}\n-\n-type ps = @rec(pp::printer s,\n-               option::t[codemap] cm,\n-               option::t[vec[lexer::cmnt]] comments,\n-               option::t[vec[lexer::lit]] literals,\n-               mutable uint cur_cmnt,\n-               mutable uint cur_lit,\n-               mutable vec[pp::breaks] boxes,\n-               mode mode);\n-\n-fn rust_printer(io::writer writer) -> ps {\n-    let vec[pp::breaks] boxes = [];\n-    ret @rec(s=pp::mk_printer(writer, default_columns),\n-             cm=none[codemap],\n-             comments=none[vec[lexer::cmnt]],\n-             literals=none[vec[lexer::lit]],\n-             mutable cur_cmnt=0u,\n-             mutable cur_lit=0u,\n-             mutable boxes=boxes,\n-             mode=mo_untyped);\n-}\n-\n-fn to_str[T](&T t, fn(&ps s, &T s) f) -> str {\n-    auto writer = io::string_writer();\n-    auto s = rust_printer(writer.get_writer());\n-    f(s, t);\n-    eof(s.s);\n-    ret writer.get_str();\n-}\n+import ppaux::*;\n \n fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n               mode mode) {\n@@ -88,7 +50,6 @@ fn expr_to_str(&@ast::expr e) -> str { be to_str(e, print_expr); }\n fn stmt_to_str(&ast::stmt s) -> str { be to_str(s, print_stmt); }\n fn item_to_str(&@ast::item i) -> str { be to_str(i, print_item); }\n fn path_to_str(&ast::path p) -> str { be to_str(p, print_path); }\n-fn lit_to_str(&@ast::lit l) -> str { be to_str(l, print_literal); }\n \n fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n     auto writer = io::string_writer();\n@@ -112,11 +73,6 @@ fn block_to_str(&ast::block blk) -> str {\n     ret writer.get_str();\n }\n \n-fn ibox(&ps s, uint u) {\n-    vec::push(s.boxes, pp::inconsistent);\n-    pp::ibox(s.s, u);\n-}\n-\n fn cbox(&ps s, uint u) {\n     vec::push(s.boxes, pp::consistent);\n     pp::cbox(s.s, u);\n@@ -127,12 +83,6 @@ fn box(&ps s, uint u, pp::breaks b) {\n     pp::box(s.s, u, b);\n }\n \n-fn end(&ps s) {\n-    vec::pop(s.boxes);\n-    pp::end(s.s);\n-}\n-\n-\n fn word_nbsp(&ps s, str w) {\n     word(s.s, w);\n     word(s.s, \" \");\n@@ -290,14 +240,15 @@ fn print_type(&ps s, &ast::ty ty) {\n                 cbox(s, indent_unit);\n                 maybe_print_comment(s, m.span.lo);\n                 print_ty_fn(s, m.node.proto, some(m.node.ident),\n-                            m.node.inputs, m.node.output, m.node.cf);\n+                            m.node.inputs, m.node.output, m.node.cf,\n+                            m.node.constrs);\n                 word(s.s, \";\");\n                 end(s);\n             }\n             bclose(s, ty.span);\n         }\n-        case (ast::ty_fn(?proto,?inputs,?output,?cf)) {\n-            print_ty_fn(s, proto, none[str], inputs, output, cf);\n+        case (ast::ty_fn(?proto,?inputs,?output,?cf,?constrs)) {\n+            print_ty_fn(s, proto, none[str], inputs, output, cf, constrs);\n         }\n         case (ast::ty_path(?path,_)) {\n             print_path(s, path);\n@@ -501,62 +452,6 @@ fn print_block(&ps s, ast::block blk) {\n     }\n }\n \n-fn next_lit(&ps s) -> option::t[lexer::lit] {\n-    alt (s.literals) {\n-        case (some(?lits)) {\n-            if (s.cur_lit < vec::len(lits)) {\n-                ret some(lits.(s.cur_lit));\n-            } else {ret none[lexer::lit];}\n-        }\n-        case (_) {ret none[lexer::lit];}\n-    }\n-}\n-\n-fn print_literal(&ps s, &@ast::lit lit) {\n-    maybe_print_comment(s, lit.span.lo);\n-\n-    alt (next_lit(s)) {\n-        case (some(?lt)) {\n-            if (lt.pos == lit.span.lo) {\n-                word(s.s, lt.lit);\n-                s.cur_lit += 1u;\n-                ret;\n-            }\n-        }\n-        case (_) {}\n-    }\n-\n-    alt (lit.node) {\n-        case (ast::lit_str(?st)) {print_string(s, st);}\n-        case (ast::lit_char(?ch)) {\n-            word(s.s, \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'')\n-                + \"'\");\n-        }\n-        case (ast::lit_int(?val)) {\n-            word(s.s, common::istr(val));\n-        }\n-        case (ast::lit_uint(?val)) {\n-            word(s.s, common::uistr(val) + \"u\");\n-        }\n-        case (ast::lit_float(?fstr)) {\n-            word(s.s, fstr);\n-        }\n-        case (ast::lit_mach_int(?mach,?val)) {\n-            word(s.s, common::istr(val as int));\n-            word(s.s, common::ty_mach_to_str(mach));\n-        }\n-        case (ast::lit_mach_float(?mach,?val)) {\n-            // val is already a str\n-            word(s.s, val);\n-            word(s.s, common::ty_mach_to_str(mach));\n-        }\n-        case (ast::lit_nil) {word(s.s, \"()\");}\n-        case (ast::lit_bool(?val)) {\n-            if (val) {word(s.s, \"true\");} else {word(s.s, \"false\");}\n-        }\n-    }\n-}\n-\n fn print_expr(&ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -917,7 +812,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             space(s.s);\n             word(s.s, \"as\");\n             space(s.s);\n-            word(s.s, ty::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+            word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pclose(s);\n         }\n         case (mo_identified) {\n@@ -951,7 +846,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n                         case (mo_typed(?tcx)) {\n                             auto lty =\n                                 ty::ann_to_type(tcx, loc.ann);\n-                            word_space(s, ty::ty_to_str(tcx, lty));\n+                            word_space(s, ppaux::ty_to_str(tcx, lty));\n                         }\n                         case (mo_identified) { /* no-op */ }\n                     }\n@@ -1170,27 +1065,6 @@ fn print_maybe_parens(&ps s, &@ast::expr expr, int outer_prec) {\n     if (add_them) {pclose(s);}\n }\n \n-fn escape_str(str st, char to_escape) -> str {\n-    let str out = \"\";\n-    auto len = str::byte_len(st);\n-    auto i = 0u;\n-    while (i < len) {\n-        alt (st.(i) as char) {\n-            case ('\\n') {out += \"\\\\n\";}\n-            case ('\\t') {out += \"\\\\t\";}\n-            case ('\\r') {out += \"\\\\r\";}\n-            case ('\\\\') {out += \"\\\\\\\\\";}\n-            case (?cur) {\n-                if (cur == to_escape) {out += \"\\\\\";}\n-                // FIXME some (or all?) non-ascii things should be escaped\n-                str::push_char(out, cur);\n-            }\n-        }\n-        i += 1u;\n-    }\n-    ret out;\n-}\n-\n fn print_mt(&ps s, &ast::mt mt) {\n     alt (mt.mut) {\n         case (ast::mut)       { word_nbsp(s, \"mutable\");  }\n@@ -1200,13 +1074,9 @@ fn print_mt(&ps s, &ast::mt mt) {\n     print_type(s, *mt.ty);\n }\n \n-fn print_string(&ps s, &str st) {\n-    word(s.s, \"\\\"\"); word(s.s, escape_str(st, '\"')); word(s.s, \"\\\"\");\n-}\n-\n fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n                &vec[ast::ty_arg] inputs, &@ast::ty output,\n-               &ast::controlflow cf) {\n+               &ast::controlflow cf, &vec[@ast::constr] constrs) {\n     ibox(s, indent_unit);\n     if (proto == ast::proto_fn) {word(s.s, \"fn\");}\n     else {word(s.s, \"iter\");}\n@@ -1241,34 +1111,10 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n         }\n         end(s);\n     }\n+    word_space(s, constrs_str(constrs));\n     end(s);\n }\n \n-fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n-    alt (s.comments) {\n-        case (some(?cmnts)) {\n-            if (s.cur_cmnt < vec::len(cmnts)) {\n-                ret some(cmnts.(s.cur_cmnt));\n-            } else {ret none[lexer::cmnt];}\n-        }\n-        case (_) {ret none[lexer::cmnt];}\n-    }\n-}\n-\n-fn maybe_print_comment(&ps s, uint pos) {\n-    while (true) {\n-        alt (next_comment(s)) {\n-            case (some(?cmnt)) {\n-                if (cmnt.pos < pos) {\n-                    print_comment(s, cmnt);\n-                    s.cur_cmnt += 1u;\n-                } else { break; }\n-            }\n-            case (_) {break;}\n-        }\n-    }\n-}\n-\n fn maybe_print_trailing_comment(&ps s, common::span span,\n                                 option::t[uint] next_pos) {\n     auto cm;\n@@ -1317,42 +1163,6 @@ fn in_cbox(&ps s) -> bool {\n     if (len == 0u) { ret false; }\n     ret s.boxes.(len-1u) == pp::consistent;\n }\n-\n-fn print_comment(&ps s, lexer::cmnt cmnt) {\n-    alt (cmnt.style) {\n-        case (lexer::mixed) {\n-            assert vec::len(cmnt.lines) == 1u;\n-            zerobreak(s.s);\n-            word(s.s, cmnt.lines.(0));\n-            zerobreak(s.s);\n-        }\n-\n-        case (lexer::isolated) {\n-            hardbreak(s.s);\n-            ibox(s, 0u);\n-            for (str line in cmnt.lines) {\n-                word(s.s, line);\n-                hardbreak(s.s);\n-            }\n-            end(s);\n-        }\n-\n-        case (lexer::trailing) {\n-            word(s.s, \" \");\n-            if (vec::len(cmnt.lines) == 1u) {\n-                word(s.s, cmnt.lines.(0));\n-                hardbreak(s.s);\n-            } else {\n-                ibox(s, 0u);\n-                for (str line in cmnt.lines) {\n-                    word(s.s, line);\n-                    hardbreak(s.s);\n-                }\n-                end(s);\n-            }\n-        }\n-    }\n-}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "ebd62b99fc30cdfcf79467148b2904254771d146", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -38,6 +38,7 @@ mod middle {\n mod pretty {\n     mod pprust;\n     mod pp;\n+    mod ppaux;\n }\n \n mod front {"}, {"sha": "443063c6f3f294a45c0bf7df75a396bd451b23aa", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -23,8 +23,8 @@ import pretty::pprust::print_path;\n import pretty::pprust::print_decl;\n import pretty::pprust::print_fn;\n import pretty::pprust::print_type;\n-import pretty::pprust::print_literal;\n-import pretty::pprust::mo_untyped;\n+import pretty::ppaux::print_literal;\n+import pretty::ppaux::mo_untyped;\n import pretty::pp::mk_printer;\n \n type filename = str;\n@@ -294,6 +294,37 @@ fn respan[T](&span sp, &T t) -> spanned[T] {\n     ret rec(node=t, span=sp);\n }\n \n+fn may_begin_ident(char c) -> bool {\n+    ret (is_alpha(c) || c == '_');\n+}\n+\n+fn in_range(char c, char lo, char hi) -> bool {\n+    ret lo <= c && c <= hi;\n+}\n+\n+fn is_alpha(char c) -> bool {\n+    ret in_range(c, 'a', 'z') ||\n+        in_range(c, 'A', 'Z');\n+}\n+\n+fn is_dec_digit(char c) -> bool {\n+    ret in_range(c, '0', '9');\n+}\n+\n+fn is_alnum(char c) -> bool {\n+    ret is_alpha(c) || is_dec_digit(c);\n+}\n+\n+fn is_hex_digit(char c) -> bool {\n+    ret in_range(c, '0', '9') ||\n+        in_range(c, 'a', 'f') ||\n+        in_range(c, 'A', 'F');\n+}\n+\n+fn is_bin_digit(char c) -> bool {\n+    ret c == '0' || c == '1';\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "037b26a51e3c6c90ad5a45a710da094cfea8684d", "filename": "src/lib/vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ff2a0d7960c58b12898cb0142917a0cffb7559/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=17ff2a0d7960c58b12898cb0142917a0cffb7559", "patch": "@@ -321,6 +321,21 @@ fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n     }\n }\n \n+// FIXME make the lengths being equal a constraint\n+fn zip[T, U](&vec[T] v, &vec[U] u) -> vec[tup(T, U)] {\n+    auto sz = len[T](v);\n+    assert (sz == len[U](u));\n+\n+    if (sz == 0u) {\n+        ret alloc[tup(T, U)](0u);\n+    }\n+    else {\n+        auto rest = zip[T, U](slice[T](v, 1u, sz), slice[U](u, 1u, sz));\n+        vec::push(rest, tup(v.(0), u.(0)));\n+        ret rest;\n+    }\n+}\n+\n fn or(&vec[bool] v) -> bool {\n     auto f = orb;\n     ret vec::foldl[bool, bool](f, false, v);"}]}